# 一窥 Puppet 中的 Ruby 部分——Facts、Types 和 Providers

到目前为止，在本书中，你主要做了一些实际操作——编写清单、设置主机、分配代理、签署证书等等。在介绍你需要掌握的缺失语言概念之前，这些概念将帮助你在更大的项目中有效地使用 Puppet，我们需要先了解一些背景知识。别担心，这不会全是枯燥的理论——Puppet 的大部分重要部分与你的日常工作密切相关。

本章的主题在之前已有所提及；第一章，*编写你的第一个清单*，简要描述了类型和提供者的概念。接下来的一些相关主题将通过“使用 Facter 收集系统信息”、“理解类型系统”和“使用提供者控制命令执行”这些部分深入探讨。

# 将所有内容整合在一起——使用 Facter 收集系统信息

配置管理是一个相当动态的问题。换句话说，需要配置的系统大多是不断变化的目标。在某些情况下，系统管理员或操作员会很幸运，能与大量 100% 一致的硬件和软件进行工作。然而，在大多数情况下，服务器和其他计算节点的环境是相当异质的，至少在某些微妙的方面是这样。即使在统一的网络中，也可能有多代机器或操作系统，它们在各自的配置要求上会有更大或更小的差异。

例如，Puppet 的一个常见任务是处理系统监控的配置。你的业务逻辑可能会为仪表盘设置警告阈值，比如系统负载值。然而，这些阈值很少是固定的。在一台双处理器的虚拟机上，系统负载值为 `10` 表示系统严重过载，而同样的值对一台硬件配置最先进的大型数据库管理系统（DBMS）服务器来说是完全可以接受的。

另一个重要的因素是软件平台。你的基础设施可能跨越多个 Linux 发行版或其他操作系统，如 BSD、Solaris 或 Windows，每种操作系统在处理某些场景时都有不同的方法。例如，假设你想让 Puppet 管理来自 `fstab` 文件的一些内容。在你那台罕见的 Solaris 系统上，你必须确保 Puppet 目标指向的是 `/etc/vfstab` 文件，而不是 `/etc/fstab`。

通常不建议直接在清单中与 `fstab` 文件进行交互。这个例子将在涉及提供者的章节中进一步完善。

Puppet 力求为你提供一种统一的方式来管理你的所有基础设施。因此，它需要一种方法，使你的清单能够适应代理机器上不同的情况。这包括它们的操作系统、硬件布局以及许多其他细节。请记住，通常情况下，清单需要在主机上进行编译。

有几种可行的方式可以为这个特定问题实现解决方案。一种直接的方法是使用一种语言结构，允许主机将一段 Shell 脚本（或其他代码）发送给代理并接收其输出。

以下是伪代码；然而，Puppet DSL 中并没有反引号表达式：

```
if `grep -c ^processor /proc/cpuinfo` > 2 {
  $load_warning = 4
}
else {
  $load_warning = 2
} 
```

这个解决方案会非常强大，但也很昂贵。当编译过程遇到这样的表达式时，主机需要回调代理。编写能够应对这种命令返回错误代码的清单会非常繁琐，Puppet 可能最终会变成一个奇怪的脚本引擎。

Puppet 使用不同的方法。它依赖于一个名为 Facter 的二级系统，Facter 的唯一目的是检查其运行所在的机器。它提供了一组根据运行系统生成的已知变量名称和值。例如，一个实际的 Puppet 清单，如果需要根据代理上的处理器数量形成条件，将使用以下表达式：

```
if $::processors['count'] > 4 { … } 
```

Facter 的变量被称为**事实**，`processors`就是其中之一。使用 Facter 3 或更高版本时，大多数数据将以结构化事实（JSON）的形式收集和呈现。在这个示例中，我们访问了`processors`数据中的`'count'`元素。旧的键值对仍然可用。事实值由代理收集并发送到主机，主机会使用这些事实来编译目录。所有事实名称都可以作为变量在清单中使用。

事实（Facts）也可以用于与`puppet apply`一起使用的清单。你可以通过以下简单的方式来测试：

`puppet apply -e 'notify { "I am ${::networking['fqdn']} and have ${::processors['count']} CPUs": }'`

# 访问和使用事实值

你已经在一个示例中看到过`processors`事实的使用。在清单中，每个事实值都作为全局变量值可用。这就是为什么你可以在需要的地方直接使用`::processors`表达式的原因。

你经常会看到类似`$::processors['count']`或`$::networking['ip']`的常规用法。强烈建议在事实名称前加上双冒号。官方风格指南在[`docs.puppetlabs.com/guides/style_guide.html#namespacing-variables`](https://docs.puppetlabs.com/guides/style_guide.html#namespacing-variables)中推荐了这一做法。这个前缀表明你正在引用来自 Facter 的变量。Facter 变量被放入 Puppet 主机的顶级作用域中。

一些有用的事实已经提到过了。`processors`事实可能在你的配置中起着作用。当配置某些服务时，你可能希望在配置文件中或作为参数值使用机器的`networking['ip']`值：

```
file { '/etc/mysql/conf.d/bind-address':
  ensure  => 'file',
  mode    => '0644',
  content => "[mysqld]\nbind-address=${::networking['ip']}\n",
}
```

除了主机名外，你的清单还可以利用代理机器的**完全限定域名**（**FQDN**）。

代理默认使用其 `fqdn` 事实的值作为其证书的名称（`clientcert`）。主机会收到这两个值。注意，代理可以覆盖 `fqdn` 的值，但 `clientcert` 的值与代理所使用的签名证书绑定。有时，你希望主机将敏感信息传递给单独的节点。清单必须通过 `clientcert` 事实来标识代理，而不能使用 `fqdn` 或 `hostname`，原因如上所述。以下代码给出了一个示例：

```
file { '/etc/my-secret': 
  ensure => 'file', 
  mode   => '0600', 
  owner  => 'root', 
  source => 
  "puppet:///modules/secrets/${::clientcert}/key", 
} 
```

有一组专门用于描述操作系统的事实。每个事实在不同的情况下都很有用。`os[‘name’]` 事实的值可以是 `Debian` 或 `CentOS` 等：

```
if $::os['name'] != 'Ubuntu' {
  package { 'avahi-daemon':
    ensure => absent
  }
}
```

如果你的清单在 RHEL、CentOS 和 Fedora 上的行为完全相同（但在 Debian 和 Ubuntu 上不同），你应该使用 `osfamily` 事实：

```
if $::os['family'] == 'RedHat' {
  $kernel_package = 'kernel'
}
```

`os[‘release’][‘full’]` 事实允许你根据不同的操作系统版本来定制你的清单：

```
if $::so['name'] == 'Debian' {
  if versioncmp($::os['release']['full'], '7.0') >= 0 {
    $ssh_ecdsa_support = true
  }
}
```

事实如 MAC 地址、不同的 SSH 主机密钥、指纹等使得使用 Puppet 来管理硬件清单变得非常简单。当然，还有许多其他有用的事实。当然，这些集合并不能满足每个用户的所有需求。这就是为什么 Facter 是可扩展的原因。

# 扩展 Facter 以添加自定义事实

从技术上讲，除了维护你自己的 Facter 包，或者通过 Puppet 管理直接将 Ruby 代码文件部署到代理上外，什么都不会阻止你在核心事实旁边添加你自己的事实代码。不过，Puppet 提供了一种更方便的替代方案——自定义事实。

我们还没有涉及 Puppet 模块的内容。它们将在第五章《将类、配置文件和扩展结合成模块》中进行详细介绍。目前，只需在主机上创建一个 Ruby 文件 `/etc/puppetlabs/code/environments/production/modules/hello_world/lib/facter/hello.rb`。Puppet 会将其识别为名为 `hello` 的自定义事实。（对于 Puppet 3 或更早版本，路径应该是 `/etc/puppet/modules/hello_world/lib/facter/hello.rb`。）

Facter 的内部工作原理非常简单且目标明确。每个事实都有一块 Ruby 代码，代码的返回值即为事实值。许多事实是自足的，但也有一些会依赖于一个或多个基础事实的值。例如，确定本地机器的 IP 地址的方法在很大程度上依赖于操作系统。

`hello` 事实非常简单：

```
Facter.add(:hello) do
  setcode { "Hello, world!" }
end
```

`setcode` 块的返回值是字符串 `Hello, world!`，你可以在 Puppet 清单中使用这个事实作为 `$::hello`。

在 Facter 2.0 版本之前，每个事实都有一个字符串值。如果代码块返回另一个值，例如数组或哈希，Facter 1.x 会将其转换为字符串。许多情况下，这样的结果并不有用。出于这个历史原因，存在像`ipaddress_eth0`和`ipaddress_lo`这样的事实，而不是（或者说除了）带有接口名称和地址的正确哈希结构。

在代理端启用`pluginsync`选项非常重要。这已成为默认设置，并且不需要任何定制。代理在每次与主机连接时都会同步所有自定义事实。之后，它们将永久保留在代理机器上。然后，你可以使用以下命令行从命令行检索`hello`事实：

```
# puppet facts | grep hello 
```

只需调用以下命令而不带参数，你就可以请求列出所有事实名称和值。

```
# puppet facts
```

还有一个`facter`命令。它的功能大致与`puppet facts`相同，但只会显示内置事实，而不是自定义事实。

在 Puppet 3 及更早版本中，没有`puppet facts`子命令。你必须依赖 Facter CLI（Facter 2.x 或更早版本），并调用`facter -p`来包括自定义事实。一些 Facter 3.0 版本移除了这个参数；新版本又重新支持了它。

本书不会涵盖 Facter API 的所有方面，但有一个功能非常重要。你的许多自定义事实仅在类 Unix 系统上有用，另一些则只在 Windows 主机上有用。你可以使用与以下类似的结构来检索这些事实：

```
if Facter.value(:kernel) != "windows"
  nil
else
  # actual fact code here
end
```

这会相当繁琐和重复。不过，你可以在`Facter.add(name) { ... }`块内调用`confine`方法：

```
Facter.add(:msvs_version) do
  confine :kernel => :windows
  setcode do
    # …
  end
end
```

你也可以将一个事实限制为多个替代值：

```
confine :kernel => [ :linux, :sunos ]
```

最后，如果某个事实在不同情况下是合理的，但每个情况下需要完全不同的代码，你可以多次添加相同的事实，每次使用不同的`confine`值。像`ipaddress`这样的核心事实经常这样做：

```
Facter.add(:ipaddress) do
  confine :kernel => :linux
  …
end
Facter.add(:ipaddress) do
  confine :kernel => %w{FreeBSD OpenBSD Darwin DragonFly}
  …
end
… 
```

你可以基于其他事实的任何组合来限制事实，而不仅仅是`kernel`。不过，这种方式非常流行。在某些情况下，`operatingsystem`或`osfamily`事实可能更合适。从技术上讲，你甚至可以将一些事实限制为某些`processorcount`值，等等。

# 使用外部事实简化操作

如果由于某些原因你团队中不希望编写和维护 Ruby 代码，你可能更倾向于使用其他方式，比如允许使用 Shell 脚本，或者任何编程语言，甚至完全不涉及编程的静态数据。Facter 支持这种方式，即**外部事实**。

创建外部事实与常规自定义事实的过程类似，但有以下区别：

+   外部事实由独立的可执行文件或带有静态数据的文件生成，代理必须在`/etc/puppetlabs/facter/facts.d/`目录下找到它们。

+   数据不仅仅是一个字符串值，而是一个任意数量的 `key=value` 键值对

数据不必使用 `ini` 文件表示法；键/值对也可以采用 YAML 或 JSON 格式。以下外部事实包含相同的数据：

```
# site-facts.txt
workgroup='CT4Site2'
domain_psk='nm56DxLp%' 
```

事实可以按以下方式以 YAML 格式编写：

```
# site-facts.yaml
workgroup: 'CT4Site2'
domain_psk: 'nm56DxLp%'
```

在 JSON 格式中，事实可以如下编写：

```
# site-facts.json
{ 'workgroup': 'CT4Site2', 'domain_psk': 'nm56DxLp%' } 
```

外部事实的部署通过你的 Puppet 清单中的 `file` 资源简单地实现：

```
file { '/etc/puppetlabs/facter/facts.d/site-facts.yaml':
  ensure => 'file',
  source => 'puppet:///…',
}   
```

在较新的 Puppet 和 Facter 版本中，外部事实将像自定义事实一样自动同步，只要它们在任何模块的 `facts.d/*` 中被发现（例如，`/etc/puppetlabs/code/environments/production/modules/hello_world/facts.d/hello.sh`）。这不仅更加方便，而且有一个重要的好处：当 Puppet 必须通过 `file` 资源获取外部事实时，它的事实值在清单编译时不可用。而 `pluginsync` 机制确保所有同步的事实在清单编译开始之前就可用。

当事实不是静态的，无法放置在 `txt` 或 `YAML` 文件中时，你可以将文件设为可执行并添加一个 shebang。它通常是一个 shell 脚本，但实现方式无关紧要；重要的是确保正确格式化的数据写入标准输出。你可以通过这种方式简化 `/etc/puppetlabs/code/environments/production/modules/hello_world/facts.d/hello.sh` 中的 `hello` 事实：

```
#!/bin/sh
echo hello=Hello, world\!
```

对于可执行的事实，`ini` 风格的 `key=value` 格式是唯一支持的格式。在此上下文中，YAML 或 JSON 格式不适用。

Facter 2 引入了结构化事实。结构化事实返回一个数组或哈希。在较旧版本的 Puppet（3.4 之前）中，结构化事实必须通过在 `puppet.conf` 中将 `stringify_facts` 设置为 false 来启用。这是 Puppet 4.0 及以后版本的默认设置。

# Facter 的目标

Facter 的整体结构和理念服务于实现平台无关的使用和开发目标。相同的事实集合（大致）在所有支持的平台上都可以使用。这使得 Puppet 用户能够在所有不同系统的清单中保持一致的开发风格。

Facter 对硬件和软件的特征形成了一个抽象层。它是 Puppet 平台无关架构中的一个重要组成部分。之前提到的另一个特性是类型和提供者子系统。类型和提供者将在接下来的章节中详细探讨。

# 理解类型系统

作为 Puppet 模型的基石之一，资源在第一章 *编写你的第一个清单*中很早就引入了。记住，每个资源表示代理系统上的一部分状态。它有一个资源类型、一个名称（或标题）和一组属性。属性可以是`property`或`parameter`。在这两者之间，属性代表了独立的状态，而参数仅影响 Puppet 对`property`值的操作。

让我们更详细地了解资源类型，并理解它们的内部工作原理。这不仅在用你自己的资源类型扩展 Puppet 时非常重要（将在第五章 *将类、配置文件和扩展结合成模块*中演示）。它还帮助你根据清单预测 Puppet 将采取的操作，并更好地理解主节点和代理的工作原理。

首先，我们更深入地了解 Puppet 的操作结构，了解它的组成部分和阶段。代理在独立的**事务**中执行所有工作。事务在以下任何情况下开始：

+   背景代理进程激活并向主节点检查。

+   启动代理进程时使用`--onetime`或`--test`选项。

+   使用`puppet apply`编译本地清单。

事务总是经过多个阶段。它们如下：

1.  收集事实值以形成实际的目录请求。

1.  从主节点接收已编译的目录。

1.  预取当前资源状态。

1.  目录内容的验证。

1.  系统与目录中的`property`值进行同步。

Facter 在前一节中已有解释。资源类型在编译过程中及之后的代理事务中变得非常重要。主节点加载所有资源类型以执行一些基本检查；它基本上确保在清单中找到的资源类型确实存在，并且属性名称与相应的类型匹配。

# 资源类型在代理端的生命周期

一旦编译成功，主节点会发出目录，代理进入目录验证阶段。每个资源类型可以定义一些 Ruby 方法，以确保传递的值是合理的。这发生在两个层次上：每个属性可以验证其输入值，然后整个资源可以检查一致性。

一个关于属性值验证的例子可以在`ssh_authorized_key`资源类型中找到。如果此类型的资源的`key`值包含空格字符，则验证失败，因为 SSH 密钥不能包含多个字符串。

整个资源的验证是通过`cron`类型进行的，例如。它确保`time`字段能够一起合理地配合。以下资源将无法通过验证，因为特殊时间（如`midnight`）不能与数字字段组合：

```
cron { 'invalid-resource':
  command => 'apt-get update',
  special => 'midnight',
  weekday => [ '2', '5' ],
}
```

这个阶段的另一个任务是将输入值转换为更合适的内部表示。资源类型代码称之为`munge`操作。`munge`的典型例子包括去除字符串值的前后空格，或将数组值转换为适当的字符串格式——这可以是以逗号分隔的列表，但对于搜索路径，分隔符应该是冒号。其他类型的值会使用不同的表示方式。

接下来是预取阶段。某些资源类型允许代理创建系统中存在的资源实例的内部列表。这些类型被称为可枚举类型。例如，对于已安装的软件包，这是可能的（且有意义的）——Puppet 可以直接调用包管理器来生成该列表。对于其他类型，如`file`，这就不太合适了。创建整个文件系统中所有可访问路径的列表可能会非常耗费资源，具体取决于代理所在的系统。

可以通过在命令行中运行`puppet resource <resource type> <title>`来模拟预取，如下所示：

```
# puppet resource user root
   user { 'root':
     ensure           => 'present',
     comment          => 'root',
     gid              => '0',
     home             => '/root',
     password         => '$6$17[...]o.rLdk/9MZANEGt/',
     password_max_age => '99999',
     password_min_age => '0',
     shell            => '/bin/bash',
     uid              => '0',
  }
```

最后，代理开始遍历其内部的相互依赖资源图。如果有必要，每个资源都会同步。大多数情况下，这是分别针对每个单独的属性进行的。

对于支持的类型，`ensure`属性是一个显著的例外。它应该自行管理所有其他属性；当通过`ensure`属性将资源从`absent`更改为`present`时（换句话说，资源正在被创建），此操作还应同步所有其他属性。

整个代理过程有一些值得注意的方面。首先，属性是独立处理的。每个属性可以为不同的阶段定义自己的方法。有相当多的钩子，允许资源类型作者为模型添加大量的灵活性。

对于有志成为类型作者的人来说，浏览核心类型可以是非常有启发性的。你会对许多属性很熟悉；在你的清单中使用它们并研究它们的钩子会带来不少见解。

还需要注意的是，整个验证过程是由代理执行的，而不是主节点。这在性能上是有益的。主节点节省了大量的工作，这些工作被分配到代理网络中（并且网络会根据需求自动扩展）。

# 提供者的命令执行控制

在本章开始时，你了解了 Facter 以及它如何作为支持平台上的一层抽象。这一统一的信息库是 Puppet 实现操作系统独立性的最重要手段之一。另一个手段当然是 DSL。最后，Puppet 还需要一种方法，能够透明地根据每个代理运行的平台来调整其行为。

换句话说，根据计算环境的特性，代理需要在不同的资源实现之间切换。这与面向对象编程类似——类型系统提供了一个统一的接口，类似于抽象基类。程序员不必担心具体引用的是哪个类，只要它正确实现了所有必需的方法。在这个类比中，Puppet 的提供者就像是实现了抽象接口的具体类。

举个实际的例子，看看软件包管理。不同版本的类 Unix 操作系统有各自的实现。最常见的 Puppet 平台分别使用 `apt` 和 `yum`，但也可以（有时必须）通过 `dpkg` 和 `rpm` 来管理它们的软件包。其他平台则使用像 `emerge`、`zypper`、`fink` 等工具，甚至还有很多其他工具。甚至有一些软件包，它们存在于操作系统软件库之外，由 `gem`、`pip` 等特定语言的软件包管理工具处理。每个管理工具都有一个对应的 package 类型提供者。

这些工具中的许多允许执行相同的一组操作——安装和卸载软件包，以及将软件包更新到特定版本。然而，后者并不是普遍可行的。例如，`dpkg` 只能安装命令行中指定的本地软件包，无法选择其他版本。

也有一些独特的功能，这些功能是特定工具的专有，或者只有少数工具支持。某些管理系统可以将软件包锁定在特定版本。某些系统使用不同的状态来区分未安装的和已清除的软件包。某些系统有虚拟软件包的概念。这样的例子还可以继续列举下去。

正因为这种潜在的多样性（不仅限于软件包管理系统），Puppet 提供者可以选择 **功能**。这些功能集是特定于资源类型的。所有同类型的提供者可以支持同一组功能中的一个或多个。对于 `package` 类型，功能包括 `versionable`、`purgeable`、`holdable` 等等。你可以像下面这样为任何软件包资源设置 `ensure => purged`：

```
package { 'haproxy':
  ensure => 'purged'
} 
```

然而，如果你通过`rpm`管理`HAproxy`包，Puppet 将无法理解它，因为`rpm`没有`purged`状态的概念，因此，`purgeable`功能在`rpm`提供者中缺失。尝试使用不受支持的功能通常会产生错误信息。有些属性，如`install_options`，可能会导致 Puppet 发出警告。

Puppet Labs 官方网站上的官方文档包含了所有核心资源类型及其内建提供者的完整列表，并附有各自的功能矩阵。非常容易找到合适的提供者及其能力。文档可以在[`docs.puppetlabs.com/references/latest/type.html`](https://docs.puppetlabs.com/references/latest/type.html)找到。

# 使用通用提供者的资源类型

有一些资源类型不使用提供者，但它们在核心类型中是罕见的。Puppet 使得大多数有趣的管理任务变得更加容易，只是它们在操作系统之间的工作方式不同，而提供者以最优雅的方式实现了这一点。

即使是所有平台上都相同的简单任务，也可能需要一个提供者。例如，有一个`host`类型，用于管理`/etc/hosts`文件中的条目。其语法是通用的，因此代码技术上可以仅在类型中实现。然而，Puppet 代码库中确实有某些种类的提供者的抽象基类。其中一个使得构建提供者来编辑文件变得非常容易，前提是这些文件由带有有序字段的单行记录组成。因此，为`host`类型实现一个提供者，并以这个提供者类为基础是有意义的。

对于好奇的人来说，下面是一个主机资源的样子：

```
host { 'puppet':
  ip           => '10.144.12.100',
  host_aliases => [ 'puppet.example.net', 'master' ],
} 
```

# 总结类型和提供者

Puppet 的资源类型及其提供者共同构成了一个坚固的抽象层，涵盖了软件配置的细节。类型系统是 Puppet 强大 DSL 的可扩展基础。它为多态提供者层提供了一个复杂的接口。

提供者灵活地实现了 Puppet 应执行的实际管理操作。它们将必要的同步步骤映射到命令和系统交互上。许多提供者无法满足资源类型所模型化的每一个细微差别。功能系统以透明的方式处理这些差异。

# 将所有内容整合在一起

读到这里，你可能会觉得这一章是一个相当奇怪的主题混合。虽然类型和提供者确实密切相关，但 Facter 的整个介绍在这个上下文中似乎有些不合时宜。然而，这种感觉是具有误导性的；事实在类型/提供者结构中扮演着至关重要的角色。它们对 Puppet 在不同提供者之间做出良好选择至关重要。

我们再来看一个来自*扩展 Facter 自定义事实*部分的例子。内容涉及`fstab`条目和 Solaris 的区别，Solaris 使用`/etc/vfstab`而非`/etc/fstab`。该部分建议使用一个根据事实值自适应的清单。如你所学，Puppet 有一个资源类型来管理`fstab`内容：`mount`类型。然而，对于路径有所不同的小差异，Solaris 并没有专门的`mount`提供者。实际上，所有平台只有一个提供者，但在 Solaris 上，它的行为有所不同。它通过解析 Facter 的`os['family']`值来实现这一点。以下代码示例来自实际的提供者代码：

```
case Facter.value(:os['family'])
when"Solaris"
  fstab = "/etc/vfstab"
else
  fstab = "/etc/fstab"
end 
```

然而，在其他情况下，Puppet 应在不同的平台上使用完全不同的提供者。包管理就是一个经典的例子。在类似 Red Hat 的平台上，你几乎希望 Puppet 在所有情况下都使用`yum`提供者。也可以使用`rpm`，甚至`apt`可能也可用。然而，如果你告诉 Puppet 确保安装某个包，你期望它在必要时使用`yum`来安装该包。

这显然是一个常见主题。某些管理任务需要在不同的环境中执行，且使用的工具链完全不同。在这种情况下，显而易见哪个提供者最适合。为了实现这一点，如果条件满足，提供者可以声明自己是默认的。对于`yum`来说，条件如下：

```
defaultfor :os['name'] => [:fedora, :centos, :redhat] 
```

这些条件基于事实值。如果某个特定代理的`operatingsystem`值在列出的范围内，`yum`会认为自己是默认的包管理提供者。

操作系统和操作系统家族的事实是提供者中最常见的查询选项，但任何事实都是可用的。

除了标记自己为默认外，还有更多依赖事实值的提供者过滤。提供者还可以限制自己只能在某些值的组合下使用。例如，`yum`的替代者`zypper`限制自己只适用于 SUSE Linux 发行版：

```
confine :os['name'] => [:suse, :sles, :sled, :opensuse] 
```

这种提供者方法与本章前面讨论的 Facter 中的`confine`方法相同。如果代理机器上的相应事实没有任何白名单值，提供者甚至不会被视为有效。

如果你查看核心提供者的代码，会发现限制（甚至默认提供者的声明）基于功能值，尽管没有该名称的 Facter 事实。这些功能与提供者功能无关，它们来自与 Facter 类似的另一层反射机制，但它们是硬编码到 Puppet 代理中的。这些代理功能是一些标志，用于标识某些系统属性，这些属性无需以事实的形式向清单提供。例如，`exec`类型的`posix`提供者在存在相应功能时成为默认提供者：`defaultfor :feature => :posix`

您会发现某些提供者完全放弃了 `confine` 方法，因为它并非正确操作代理所必需的。Puppet 在查找所需的操作系统命令时，也会识别不合适的提供者。例如，某些 BSD 版本的 `pw` 提供者不会使用 `confine` 声明。它只声明其一个必需的命令：

```
commands :pw => "pw"  
```

在搜索路径中找不到 `pw` 二进制文件的代理将完全不尝试使用此提供者。

这就是通过 Facter 探索类型和提供者内部工作原理的简短介绍。有关构建类型提供者的完整示例，并使用您现在已学习的内部工具，您可以参考第五章，*将类、配置文件和扩展结合成模块*。

# 总结

Puppet 使用 Facter 收集所有代理系统的信息。信息库由大量独立的部分组成，称为事实（facts）。清单可以查询这些事实的值，以适应触发其编译的相应代理。Puppet 还使用事实来选择提供者，这些工作马使得抽象的资源类型在广泛支持的平台上可用。

资源类型不仅完全定义了 Puppet 在 DSL 中暴露的接口，它们还负责所有输入值的验证、在将值交给提供者之前必须执行的转换，以及其他相关任务。

提供者封装了实际操作系统及其相应工具链的所有知识。它们实现了资源类型所描述的功能。Puppet 模型的配置适用于不同的平台，而平台之间有所不同，因此并非每个资源类型的每个方面都适用于所有代理。通过仅暴露受支持的特性，提供者可以表达此类限制。

在深入了解内部细节后，我们将再次关注更实际的问题。接下来的章节将涵盖构建各类规模复杂和高级清单所需的工具。
