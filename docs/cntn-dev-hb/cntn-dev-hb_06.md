# 第六章：6

# 容器编排的基本原理

到目前为止，我们已经了解了什么是软件容器，它们如何工作，以及如何创建它们。我们专注于作为开发人员使用它们，创建我们的应用程序并将功能分布到在容器中运行的不同组件中。本章将为你介绍一个全新的视角。我们将学习如何在生产环境中使用容器运行我们的应用程序。我们还将介绍容器编排器的概念，探讨它们能提供什么，并讨论我们需要在应用程序中加入哪些关键改进，以便在分布式集群中以集群范围的方式运行它们。

在本章中，我们将涵盖以下主题：

+   介绍编排的关键概念

+   理解无状态和有状态应用程序

+   探索容器编排器

接下来，我们将研究如何在*第七章*《使用 Swarm 进行编排》和*第八章*《使用 Kubernetes 编排器部署应用程序》中利用 Docker Swarm 和 Kubernetes 编排器的功能。本章不包括任何实验，因为它旨在教授 Docker Swarm 和 Kubernetes 背后的理论。

# 介绍编排的关键概念

在主机上运行应用程序可能会很复杂，但在由多个主机组成的分布式环境中执行同一应用程序则会非常繁琐。在本节中，我们将回顾一些关于应用组件编排的关键概念，无论它们是通过容器运行，还是作为不同的虚拟机运行。

编排器是帮助我们管理应用程序组件之间不同交互和依赖关系的特殊软件组件。正如你能想象的那样，如果你将应用程序拆分为多个不同的功能模块，每个模块都有自己的实体，那么将它们编排在一起是至关重要的。我们必须在此提到，某些特殊功能，例如依赖管理，可能在你的编排器中不可用，因此你需要自己进行管理。这就引出了一个重要问题：为了准备我们的应用程序，我们需要了解编排器的哪些知识？编排器保持我们的进程运行，管理应用程序组件之间的通信，并连接这些进程所需的存储。

特别针对基于容器的应用程序，很容易理解容器运行时将成为编排基础设施的一部分，因为它们是运行容器所必需的。与容器工作时最大的问题是与其网络功能相关的内在动态性。这在虚拟机环境中可能不是问题，但容器通常在每次执行时使用不同的 IP 地址（尽管我们可以手动为容器分配 IP 地址，但这并不是一个好习惯）。请注意，在之前章节的实验中（*第四章*，*运行 Docker 容器*，和 *第五章*，*创建多容器应用程序*），我们使用了服务名称而不是容器 IP 地址。

让我们回顾一下在设计应用程序以在分布式集群中运行其组件时需要牢记的关键概念：

+   **依赖关系解析**：你的应用程序可能存在一些依赖关系。这意味着某些服务需要在其他服务之前启动，以使应用程序功能正常。一些编排解决方案，如 Docker Compose（独立编排），包括此功能，但大多数其他解决方案通常没有。作为开发者，你需要在代码中解决这些依赖关系所带来的问题。一个简单的例子是数据库连接。如果由于数据库故障，某些组件的连接丢失，那么由你来决定如何处理。某些组件可能仍能正常工作，而其他组件可能需要重新连接。在这种情况下，你应该在任何事务之前进行连接性验证，并准备管理可能在组件发现数据库故障之前积压的排队事务。

+   **状态**：随时了解每个组件的当前状态至关重要。一些调度器有自己的功能来检查和验证每个组件的状态，但作为应用程序的开发者，你最清楚哪些路径、进程、端口等是必需的，以及如何测试它们是否正常工作。在*第二章*，*构建 Docker 镜像*中，我们讨论了容器镜像内容越简洁，安全性就越好。如果你的应用程序需要额外的软件来测试其健康状况，你应该包括它；然而，可能更好的做法是包括一些测试端点或可以在需要时调用的测试函数，以验证应用程序组件的健康状况。

+   **熔断器**：如果我们已经成功地管理了应用程序的依赖关系，熔断器将帮助我们识别任何问题，并在某些组件出现故障时做出适当的决策。编排工具本身不提供任何熔断器功能；你需要额外的软件或基础设施组件来实现此类解决方案。根据应用程序的复杂性，集成一些熔断器可能是有益的。例如，我们可以在数据库不可用时停止所有依赖健康数据库的组件，而其他组件可以继续运行并提供其功能。

+   **可扩展性**：也许你的一些应用组件会以多个副本的形式运行。可扩展性应在设计时就考虑进去。编排工具允许你执行多个副本的任何组件，但管理它们的共存仍然由你来负责。如果一个数据库组件以多个副本运行，而没有为这种情况做准备，就会损坏你的数据。在这种情况下，你需要使用主从式或分布式数据库架构。关于数据事务的其他问题可能会出现，比如在前端，如果你没有管理用户会话。在这种情况下，确保会话一致性可能需要额外的组件，以确保所有事务遵循协调的工作流。编排工具并不了解你应用组件的功能，因此，由你来决定哪些组件可以扩展或缩减。一些编排工具会提供规则，帮助你决定何时进行扩展，但它们仅仅触发管理组件副本的动作。所有副本将以相同方式处理，如果你需要负载均衡功能来确保某些副本接收比其他副本更多的数据，你需要添加额外的组件。

+   **高可用性**：高可用性的概念可能因询问对象的不同而有所不同，无论是基础设施团队还是应用团队的人，他们都会同意它应该对最终用户是透明的。从基础设施的角度来看，我们可以从多个层面考虑高可用性：

    +   **基础设施冗余**：当物理或虚拟机用于提供我们应用的高可用性时，我们需要对所有基础设施进行冗余，包括底层的通信层和存储层。大多数设备都知道如何管理当复制设备作为主设备时必须更改的特殊配置。服务器应保持法定人数或主从关系，以决定哪一台服务器处理用户请求。这在我们计划采用主动-被动（只有一个实例处理所有请求，其他实例只有在出现错误时才接管）或主动-主动响应（所有实例同时提供服务）的情况下也是必要的。

    +   **健康组件的路由**：复制的基础设施需要额外的组件层来路由用户的请求。负载均衡器帮助以完全透明的方式为用户呈现不同应用程序的端点。

    +   **存储后端**：正如我们所期望的那样，存储不仅必须安全地保留数据，还必须将其附加到任何正在运行和提供服务的实例上。在主备环境中，存储将从损坏的实例切换到健康的实例。作为开发人员，您可能需要在切换后确保数据完整性。

    高可用性意味着服务永远不会中断，即使维护任务需要停止一个实例。容器编排器本身不提供高可用性；它必须作为应用程序设计的一部分考虑进去。

+   **服务状态定义**：通常我们定义应用程序的部署方式，包括必须可用的副本数量，以便服务被视为健康。如果任何副本失败，编排器将为您创建或启动一个新的副本。我们不需要触发任何事件，只需定义监视器，以便编排器审查每个应用程序组件的状态。

+   **弹性**：应用程序可能会失败，编排器会尝试重新启动它们。这就是*弹性*的概念，编排器默认提供。当您的应用程序在容器中运行时，容器运行时会在出现问题时重新启动应用程序，保持应用程序的运行。编排器与容器运行时交互，管理容器在整个集群范围内的启动和停止过程，试图减轻应用程序失败的影响。因此，您必须设计您的应用程序以快速停止和启动。通常，在容器中运行的应用程序不会花费超过几秒钟的时间来运行，因此您的用户可能甚至不会注意到中断。因此，为了避免给用户带来重大问题，我们必须为应用程序的组件提供高可用性。

+   **分布式数据**：当您的应用程序以分布式集群方式运行时，不同的主机将运行您的应用程序组件，因此需要在需要时提供所需的数据。编排器将与容器运行时交互以挂载容器卷。您可以在所有可能的主机上挂载数据，以预期容器将使用它，这乍看起来可能是个好主意。然而，管理应用程序数据权限可能会给您带来意想不到的后果。例如，您可能会错误配置根目录的权限，不同的应用程序正在其中存储它们的数据，允许一些应用程序读取其他应用程序的数据文件。通常最好将卷管理委托给编排器本身，利用其为此提供的功能。

+   **互操作性**：应用程序组件之间的通信可能非常复杂，但编排提供了简化的网络层。在*第七章*《使用 Swarm 进行编排》和*第八章*《使用 Kubernetes 编排器部署应用程序》中，我们将看到这两种编排器如何为您的应用程序提供不同的通信层。学习和理解它们如何部署应用程序的通信，并从一开始就设计应用程序以避免任何网络锁定非常重要。这样，您的应用程序就可以在任何可用的编排器上运行。

+   **动态寻址**：容器环境基于由容器运行时管理的动态对象。这些对象中的一些可能具有静态属性，例如容器内的 IP 地址。在高度动态的基础设施中管理静态属性可能非常困难，并且不推荐这样做。如果您遵循编排器的规则，编排器会为您管理动态性。

+   **服务可发现性**：在编排器中发布的服务将会在内部宣布，并且可以从其他任何应用程序组件访问。默认情况下，这些服务仅在内部工作，这提高了您完整应用程序的安全性，因为您仅发布那些必须由用户访问的前端服务。

+   **多站点**：对于跟随太阳的工作负载或灾难恢复架构，拥有多个数据中心在大型企业中是很常见的。您必须始终确保您的应用程序可以在任何地方运行。我们可以更进一步，因为一些公司可能同时拥有云提供的基础设施和本地服务——在这种情况下，您的应用程序可能在云基础设施上运行某些组件，而其他组件则在本地运行。除了这种情况可能带来的基础设施同步挑战，如果您在设计应用程序时考虑到这些高级环境，并且了解需要避免的断点（例如，失去通信时组件之间的法定人数问题），您仍然能够在极端情况下运行您的应用程序。

部署应用程序到集群中的关键方面之一是组件状态的管理。在下一节中，我们将回顾在设计应用程序时，将组件的状态设置在容器生命周期之外的重要性。

# 理解无状态和有状态应用程序

之前，我们简要介绍了关于如何协调应用程序并将其分布式运行在集群上的关键点和概念，你可能已经注意到，在没有中断的情况下向用户提供服务是非常复杂的。我们回顾了编排工具如何帮助我们提供具有弹性的进程，并且看到高可用性如何必须在应用程序中设计。此类设计的一个关键方面涉及到你的应用程序如何随着时间推移管理进程的状态。

应用程序根据其如何管理进程的状态分为两类：**有状态**和**无状态**。

在学习每一个之前，理解应用程序或进程的状态意味着什么非常重要。系统的状态是指在特定时间点其所处的状态。这个系统可以是运行中的，也可以是停止的，或者处于两者之间的状态，如正在启动或停止。能够识别和管理应用程序组件的状态非常重要。为了管理系统的状态，例如触发启动或停止系统的操作，我们必须知道如何获取状态。在许多情况下，这并不简单，尤其是复杂的情况可能需要管理某些依赖关系或与其他外部系统的交互。

现在我们已经定义了系统的状态，接下来让我们通过一些示例来描述有状态应用和无状态应用。

## 有状态应用

想象一下一个情境，一个进程需要加载一些数据才能启动。如果这个进程在启动时读取所有配置，那么每次配置发生变化时，我们都需要重启它。但如果这个进程在需要某些功能或操作时才读取部分配置（或全部配置），那么就可能不需要重启。这就是为什么我们需要知道进程是否已经启动，以便加载所需数据。在某些情况下，我们可以设计一个完整的进程，每次启动时都加载数据，而不需要检查之前是否已启动。然而，在其他情况下，不能这样做，因为我们不能替换数据或加载数据超过一次。一个简单的文件可以用作标志，指示加载过程是否已经执行，或者是否需要重新加载数据。

如果我们的应用程序作为一个简单进程在主机上运行，那么可以很容易地在本地管理状态，但如果使用容器则不太容易。当容器在主机上运行时，它使用自己的存储层，除非我们指定一个卷来存储一些数据。运行相同进程的一个新容器，如果你的应用程序通过设计将该标志文件存储在容器生命周期之外，则可以重用以前的卷。在一个独立的主机上运行所有进程时，这看起来相当简单。

卷可以是绑定挂载（来自主机文件系统的目录）或命名卷（具有已知且可重用名称的卷）。当你在集群范围内运行应用程序时，这种方法可能无法正确工作。因为绑定挂载是附加到主机的，该目录在其他主机上不存在。可以使用远程文件系统来持久化标志，并使其在其他主机上可用。在这种情况下，我们使用卷，编排工具将管理所需文件系统的挂载。

然而，当涉及多个进程时，管理应用程序的状态会变得更加困难。在这种情况下，建议从一开始就将这一需求纳入应用程序设计过程中。例如，如果我们设计一个 Web 应用程序，我们需要存储一些用户数据以识别谁发起了特定请求。在这种情况下，我们不仅要管理进程状态——还需要管理用户数据，因此需要多个文件，并且我们必须使用数据库来存储这些数据。我们通常说这样的应用程序是**有状态**的，并且需要**持久数据**。

## 无状态应用程序

无状态应用程序则不需要任何数据持久性。我们可以在需要时重新启动这些组件，而无需持久化任何数据。应用程序本身包含所有所需的信息。想象一个接收数据的服务，如果该服务没有响应，我们会再次发送数据，直到它给出响应。这个服务可以对接收到的数据执行一些操作并发送响应，而无需保存任何数据。在这种情况下，这个服务是**无状态**的。它可能需要一些外部数据来执行操作，但如果出现问题需要重新启动服务，我们无需关心任何挂起操作的状态。我们只需再次发送数据，直到获得有效响应。当一些操作仍在等待时，我们就有了一个有状态的过程，它需要我们加载一些挂起的请求，以及一个无状态的过程，因为它不会自行存储请求。发送请求的服务可能需要存储请求，而处理操作的服务则不需要。

正如你可能想象的那样，无状态应用程序在分布式环境中更容易管理。我们不需要在集群的不同位置管理进程状态及其相关数据。

在下一节中，我们将回顾一些最受欢迎的容器编排工具。

# 探索容器编排工具

现在我们知道了容器编排工具的基本要求，让我们回顾一些最重要和最具技术相关性的工具。我们还将快速了解每个选项的优缺点。

我们将从目前最受欢迎和广泛应用的容器编排工具 Kubernetes 开始。

## Kubernetes

**Kubernetes** 是一个开源容器编排平台，正迅速成为在云提供商和本地数据中心运行微服务的事实标准。它起初是 Google 为管理公司内部应用程序而开发的一个项目，始于 2003 年。这个项目最初叫做 Borg，旨在部署分布在不同节点和集群中的工作负载。该项目逐渐发展成一个更复杂的编排平台，称为 Omega，专注于运行数千个工作负载的大型集群，用于不同的应用程序。2014 年，Google 将 Borg 的代码公开发布到开源社区，并在同年将其改名为 Kubernetes。2015 年，Kubernetes 1.0 的第一个版本发布，此时 Red Hat、IBM、Microsoft 和 Docker 等公司也加入了这一社区项目。Kubernetes 社区现在非常庞大，正是这一点使得该编排器在当今如此受欢迎。

Kubernetes 最重要的特点是，它的核心专注于执行少数任务，并将更复杂的任务委托给外部插件或控制器。它的可扩展性极强，许多贡献者每天都会添加新功能。如今，Kubernetes 已成为最受欢迎且广泛使用的容器编排工具，当你要求软件供应商提供高可用性时，提供自己 Kubernetes 定义的应用程序已变得相当普遍。Kubernetes 默认不提供容器运行时、集群网络功能或集群存储。我们需要自己决定使用哪种容器运行时来运行容器，这些容器将由编排器进行部署和维护。

在网络方面，Kubernetes 定义了一系列规则，任何我们希望在平台中包含的 **容器网络接口** (**CNI**) 都必须遵循这些规则，以便实现跨容器通信的集群功能，正如我们将在*第八章*《使用 Kubernetes 编排器部署应用程序》中学习到的那样。Kubernetes 的网络模型与其他编排解决方案不同，它呈现的是一种简单或扁平的网络（容器之间不需要路由），所有容器默认都是可以访问的。部署 Kubernetes 网络的许多开源和专有选项也可用，包括 Flannel、Weave、Cilium 和 Calico。这些网络提供商定义了我们的 Kubernetes 集群的覆盖网络和 IPAM 配置，甚至加密节点之间的通信。

Kubernetes 提供了许多云服务提供商的集成，因为它的设计初衷就是云就绪。提供云控制器用于管理与发布应用程序或使用某些特殊云提供的存储后端的集成。如本节前面所述，Kubernetes 并未提供部署任何集群级存储后端的解决方案，但你可以将 NFS 和一些 AWS、Google 和 Azure 存储后端集成到你的应用程序中。为了扩展存储可能性，你可以使用**容器存储接口**（**CSI**），这是不同供应商或社区驱动的存储后端，可以轻松地集成到 Kubernetes 中，为我们管理的容器提供不同的存储解决方案。

许多云服务提供商和软件供应商打包并分享或销售他们自己的 Kubernetes 版本。例如，Red Hat/IBM 在其 OpenShift 产品中提供了自己的 Kubernetes 平台。微软、亚马逊、谷歌，实际上几乎所有的云服务提供商都有自己的 Kubernetes 实现，供用户使用。在这些 Kubernetes 平台中，你甚至不需要管理任何控制平面功能——这些平台作为 Kubernetes 管理的解决方案提供给你，作为开发者，你可以使用它们来交付应用程序。这些解决方案被称为**Kubernetes 即服务**平台，用户为工作负载和应用程序使用的带宽付费。

Kubernetes 项目大约每 4 个月发布一次版本，并同时维护三个次要版本（因此每个版本都能提供几乎一年的补丁和支持）。在版本之间总是会有一些变动和弃用，因此非常重要的是要审查每个版本的变更说明。

Kubernetes 集群有不同角色的节点：**master**节点创建控制平面以交付容器，而**worker**节点执行分配给它们的工作负载。这种模型使我们能够通过复制一些 master 节点的服务来部署高可用性的 Kubernetes 集群。一个开源的键值数据库，名为 etcd，用于管理所有对象（在 Kubernetes 中称为**资源**）的引用和状态。

Kubernetes 发展得如此之快，以至于现在我们甚至可以通过使用像 KubeVirt 这样的操作符将虚拟机管理和集成到 Kubernetes 集群中。Kubernetes 的另一个伟大特点是，当 Kubernetes 核心资源无法满足应用程序的某些特殊需求时，你可以为应用程序创建自己的资源（**Kubernetes 自定义资源定义**）。

让我们快速总结一下使用 Kubernetes 的优点：

+   许多云服务提供商和本地软件解决方案的容器提供商为客户提供了 Kubernetes 的支持

+   有非常详尽的文档和大量学习基础知识的示例与指南

+   通过标准化接口（如 CNI 和 CSI）高度可扩展

+   很多对象或资源能够满足你大多数应用程序在集群范围内运行的需求。

+   包含许多安全功能，如基于角色的访问控制、服务帐户、安全上下文和网络策略。

+   提供多种发布应用程序的方法。

+   作为许多软件供应商的标准部署方法，你可以轻松地找到以 Kubernetes 清单格式打包的应用程序。

然而，它也有一些缺点。包括以下几点：

+   由于其不断演化和许多资源类型，它并不容易掌握。与其他编排解决方案相比，学习曲线可能显得更陡峭。

+   每年发布的版本可能需要大量的工作来维护平台。

+   拥有许多变种可能会成为问题，因为每个供应商都会在其平台上引入自己的特性。

+   你永远不会仅为一个应用程序或几个小应用程序使用 Kubernetes，因为它需要大量的维护和部署工作。事实上，像微软的 Azure Kubernetes 服务这样的 Kubernetes 即服务提供商将帮助你减少维护工作。

我们将在*第八章*中详细学习 Kubernetes 的所有功能，以及如何在该编排工具中准备和部署我们的应用程序，*使用 Kubernetes 编排器部署应用程序*。

## Docker Swarm

**Docker Swarm**是由 Docker 公司创建的容器编排解决方案。它旨在提供一个简单的编排平台，默认情况下包括运行我们容器化应用程序所需的所有功能，覆盖整个集群。这包括覆盖网络（可以加密）和隔离，通过为每个项目创建不同的网络（如果需要）。

可以使用不同的对象来部署我们的应用程序，如**全局**服务或**复制**服务，每个服务都有其自己的属性，用于管理容器如何在集群中分布。正如我们在 Kubernetes 中看到的，也使用主节点-工作节点（主从）模式。主节点创建完整的控制平面，工作节点执行容器。

需要提到的是集群中变更管理的一个重要区别。Kubernetes 使用 etcd 作为其键值数据库，而 Docker Swarm 使用 Raft 共识算法管理自己的对象数据库解决方案，并提供完整的命令行界面。只需安装 Docker 引擎就可以开始使用 Docker Swarm，因为容器运行时二进制文件也包含了 SwarmKit 特性。Moby 是 Docker Inc. 背后的开源项目，创建了用于交付和改进容器通信的工具包（VPNKit）以及改进默认的 `docker build` 功能的工具包（BuildKit），其中一些内容我们在 *第二章*，*构建 Docker 镜像* 中，使用 `buildx` 扩展构建命令行进行了介绍。SwarmKit 是 Docker Swarm 背后的 Moby 项目，提供集群功能、安全性以及模型的简易性。Docker Swarm 相当简单，但这并不意味着它不适合生产环境。它提供了部署高可用性应用所需的最小功能。

需要提到的是，Compose YAML 文件允许我们使用一组清单来部署应用程序，创建并管理 Docker Swarm 中的所有应用对象。我们在 *第五章*，*创建多容器应用程序* 中学到的一些键值，在这里无法使用，例如 `depends_on`，因此应用程序的依赖管理必须在代码中自行处理。

下面是 Docker Swarm 的一些优点：

+   比其他容器编排工具更易于学习

+   集成在 Docker 引擎内，并通过 Docker 命令行进行管理

+   单一二进制文件部署

+   与 Compose YAML 文件兼容

一些缺点如下：

+   部署应用程序所需的对象或资源较少，这可能会影响应用程序中应用的逻辑。重要的是要理解，作为开发人员，你可以在代码中实现应用程序的逻辑，并避免与编排相关的任何潜在问题。

+   它仅与 Docker 容器运行时兼容，因此存在供应商锁定，无法使用其他容器运行时提供的安全性改进。

+   尽管 Docker Swarm 提供了一些与容器运行时相关的插件，但它不像 Kubernetes 那样开放和可扩展。

+   发布应用程序更容易，但这意味着没有外部工具，我们无法应用任何高级功能。

我们将在 *第七章*，*使用 Swarm 进行编排* 中深入了解 Docker Swarm。

## Nomad

HashiCorp **Nomad** 是一个平台，允许我们运行容器、虚拟机（使用 **QEMU**，这是一个著名的开源虚拟化引擎）和 Java 应用程序。它专注于调度应用程序工作负载，并检查其他 HashiCorp 工具（如 **Consul** 和 **Vault**）提供的服务，如发现、健康检查监控、DNS 和秘密管理。Nomad 的安全性基于 **访问控制列表**（**ACLs**），包括令牌、策略、角色和权限。在网络方面，它使用 CNI 插件进行桥接工作模式。其多站点功能允许我们从单一编排角度，通过 **联邦**，在不同区域运行应用程序。

Nomad 采用了一些 Kubernetes 和 Docker Swarm 提到的架构特性，其中一些节点充当控制平面（服务器），而其他节点（客户端）执行所有工作负载。服务器接收用户的作业，管理客户端，并确定工作负载的分配。

HashiCorp 提供了社区版和 **软件即服务**（**SaaS**）平台，部署在其云中。它可以通过 API 与一些 CI/CD 环境集成，并且可以包含基础设施自动化的脚本。其一些优点如下：

+   使用和维护简单

+   单二进制部署

+   灵活部署和管理虚拟机，以及容器化和非容器化应用程序

以下是它的一些局限性：

+   尽管 HashiCorp 提供了良好的文档，但它的用户并不多，因此项目背后缺乏强大的社区支持。

+   Nomad 与 Docker Swarm（一个遗留平台）和 Kubernetes 一起出现，但 Nomad 最初侧重于虚拟机和应用程序。容器编排与 Docker Swarm 和 Kubernetes 密切相关，后者在该领域因而获得了更多的关注。

+   由于相关项目较少，Nomad 被单一公司掌控，这家公司可能更为成熟。这使得该产品的演进或新特性添加相比社区驱动的项目进展较慢。

## Apache Mesos

**Mesos** 是一个由 Apache 组织在 2009 年创建的项目，用于运行集群范围的工作负载。这发生在容器广泛应用之前，因此容器只有在大部分架构逻辑已经设计完成后才被集成到该项目中。这意味着 Mesos 可以像 Nomad 一样，在集群范围内运行容器和正常的应用程序工作负载。

Hadoop 和其他大数据工作负载管理器是由 Apache Mesos 管理的主要框架，而它在容器方面的使用相对有限，或者至少没有其他解决方案那么受欢迎。Mesos 的优势在于，它可以轻松集成 Apache 项目的工作负载，如 Spark、Hadoop 和 Kafka，因为它是为这些项目设计的。

然而，它的缺点包括：

+   专用的工作负载或框架可能需要手动配置，因此它们不像 Kubernetes 或 Docker Compose 的 YAML 文件那样标准化。

+   这个协调器并不是很受欢迎，因此它的社区较小，相比于 Kubernetes 或 Docker Swarm，只有少数几个教程示例可供参考。

## 云服务商特定的编排平台

现在我们已经对最重要的本地编排工具有了快速了解（其中一些也作为云解决方案提供），接下来让我们看看一些云服务商为其平台专门创建的编排解决方案。使用它们特定功能时，你可能会遇到一定程度的供应商锁定问题。让我们看看其中最重要的几个：

+   **Amazon Elastic Container Service** (**ECS**) 和 **Fargate**：Amazon ECS 是一个由 Amazon 管理的容器编排服务。ECS 依赖于你的 EC2 合同资源（存储、虚拟网络和负载均衡器），因此，你可以通过添加更多资源或节点来增加或减少平台可用的硬件。Amazon **Elastic Kubernetes Service** (**EKS**) 与这个简化的选项完全不同，因为它为你部署了一个完整的 Kubernetes 集群。另一方面，AWS Fargate 是一种更简化的技术，让你可以在不需要管理服务器或集群的情况下运行容器。你只需将应用程序打包成容器，指定基础操作系统和 CPU、内存需求。你只需要配置一些网络设置和 **身份与访问管理** (**IAM**) 来保障访问安全。这些就是你最终能够运行应用程序的所有要求。

+   **Google Anthos** 和 **Google Cloud Run**：尽管 Google Cloud Platform 提供了自己的 Kubernetes 即服务平台 **Google Kubernetes Engine** (**GKE**)，但它也提供了 Anthos 和 Cloud Run。Anthos 是一个混合型且与云平台无关的容器管理平台，允许将运行在 Google 云和你的数据中心中的容器化应用程序集成。它专注于准备和运行作为虚拟机使用的容器化应用程序。另一方面，Google Cloud Run 更加灵活，提供了按需扩展工作负载的能力，并可以集成 CI/CD 工具以及不同的容器运行时。

+   **Azure Service Fabric** 和 **Azure Container Instances** (**ACI**)：微软提供了不同的解决方案来运行简单的容器，同时也有 **Azure Kubernetes Service** (**AKS**) 可供使用。Azure Service Fabric 为你的应用程序提供了一个完整的微服务平台，而 ACI 则是一个简化版本，你可以像使用小型虚拟机一样运行容器。你只需为应用程序编写代码并构建容器镜像，而无需管理运行它们的基础设施。

所有这些云平台允许你测试甚至在生产环境中运行应用程序，而无需管理任何底层的编排。只需使用简单的 Web 界面，你就可以确定当应用程序组件失败时应该采取的措施，并可以根据需要添加资源。每个供应商提供的云存储服务可供你的应用程序使用，你还可以通过云平台提供的报告监控应用程序的完整成本。以下是这些云供应商平台的一些优点：

+   比任何其他容器编排都更容易使用

+   对于测试甚至执行应用程序来说，可能不需要完整的 Kubernetes 集群，这使得云供应商解决方案成为一种合理的选择

它们的缺点包括以下几点：

+   使用这些平台时，供应商锁定问题始终存在，因为你将使用许多云供应商嵌入的服务

+   它们可以有效地用于测试，甚至发布一些简单的应用程序，但在使用微服务时，根据应用程序组件的复杂性，可能会出现一些问题。

# 总结

在本章中，我们回顾了在应用程序中使用的常见编排概念以及可用的不同平台。我们了解了可帮助我们决定哪些选项更适合我们应用程序的最重要功能。学习编排器的工作原理将极大地帮助你作为开发者，在设计应用程序时实现集群级别的高可用性，得益于编排提供的独特功能。在接下来的章节中，我们将深入探讨 Kubernetes（最受欢迎且广泛扩展的容器编排平台）和 Docker Swarm，这两者都可以在云端和本地环境中使用。
