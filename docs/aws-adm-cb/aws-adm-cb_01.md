# 第一章：AWS 基础知识

在本章中，我们将介绍：

+   基础设施即代码

+   AWS CloudFormation

+   AWS 命令行工具

# 介绍

**亚马逊网络服务**（**AWS**）是一个公共云服务提供商。它提供按需付费的基础设施和平台服务。这意味着您可以按需访问曾经需要一次性购买的资源。您可以访问企业级服务，同时只为您所需的部分付费，通常按小时计费。

AWS 以提供开发者所需的基础组件为荣，使他们能够构建和扩展所需的解决方案。

# 创建账户

为了跟上教程，您需要一个 AWS 账户。请访问[`aws.amazon.com/`](https://aws.amazon.com/)点击注册按钮并输入您的信息，创建账户。

尽管我们会尽可能利用免费套餐，但您仍然需要一张有效的信用卡来完成注册过程。请访问[`aws.amazon.com/free/`](https://aws.amazon.com/free/)了解更多信息。请注意，免费套餐仅适用于账户生命周期的第一年。

# 区域和可用区

AWS 的一个基本概念是，其服务及基于这些服务构建的解决方案是 *为故障而设计的*。这意味着，底层资源的故障是一个积极规划的场景，而不是等到无法忽视时才去避免。

因此，所有可用的服务和资源都被划分到地理上分散的 **区域** 中。使用特定区域意味着您可以为用户提供速度和性能优化的服务。

在一个区域内，总是有多个 **可用区**（又称 **AZ**）。每个 AZ 代表一个地理上独立—但仍然接近—的物理数据中心。AZ 拥有自己的设施和电源，因此，可能导致单个 AZ 离线的事件不太可能影响该区域的其他 AZ。

较小的区域至少有两个 AZ，而最大的区域有五个。

在撰写本文时，以下区域是活跃的：

| 代码 | 名称 | 可用区 |
| --- | --- | --- |
| `us-east-1` | 北弗吉尼亚 | 5 |
| `us-east-2` | 俄亥俄州 | 3 |
| `us-west-1` | 北加利福尼亚州 | 3 |
| `us-west-2` | 俄勒冈州 | 3 |
| `ca-central-1` | 加拿大 | 2 |
| `eu-west-1` | 爱尔兰 | 3 |
| `eu-west-2` | 伦敦 | 2 |
| `eu-central-1` | 法兰克福 | 2 |
| `ap-northeast-1` | 东京 | 3 |
| `ap-northeast-2` | 首尔 | 2 |
| `ap-southeast-1` | 新加坡 | 2 |
| `ap-southeast-2` | 悉尼 | 3 |
| `ap-south-1` | 孟买 | 2 |
| `sa-east-1` | 圣保罗 | 3 |

# AWS 网页控制台

创建 AWS 账户后，您首先会看到的是基于网页的控制台，并且在查看和确认您的配置时，您将经常使用它。

![](img/B06326_01_01.png)

AWS 网页控制台

控制台提供了所有可用服务的概览，以及相关的计费和费用信息。每个服务都有自己的部分，显示的信息取决于查看的服务。随着新特性和服务的发布，控制台会不断变化和改进。如果你登录时发现界面有所变化，不必惊讶。

请记住，控制台始终按 *区域* 显示你的资源。如果你看不到已创建的资源，请确保已选择正确的区域。

选择距离你物理位置最近的区域，以获得最快的响应时间。请注意，并非所有区域都有相同的服务可用。较大的老旧区域通常有最多的服务可用。某些较新的或较小的区域（可能离你较近）可能还没有启用所有服务。虽然服务会持续发布到各个区域，但如果你必须使用新服务，可能需要选择其他区域。

`us-east-1`（即北弗吉尼亚）区域是特殊的，因为它是第一个区域。所有服务都可以在那里使用，新的服务 *总是* 首先发布在那里。

随着你对 AWS 使用的熟练度提高，你将在控制台上花费的时间会减少，而更多地通过 AWS CLI 工具和 CloudFormation 以编程方式控制服务，接下来我们将更详细地讨论这些内容。

# CloudFormation 模板

在可能的情况下，我们已经将食谱（recipe）基于 CloudFormation 模板。CloudFormation 是 AWS 提供的 *基础设施即代码* 服务。

在 CloudFormation 不适用的情况下，我们使用了 AWS CLI 来使流程具备可重复性和自动化能力。

由于食谱基于 CloudFormation 模板，你可以轻松地将不同的模板结合起来，实现你想要的结果。通过编辑模板或将它们结合在一起，你可以以最小的努力创建更有用和定制化的配置。

# 基础设施即代码

**基础设施即代码** (**IaC**) 是通过代码定义来管理基础设施的做法。

在 **基础设施即服务** (**IaaS**) 平台上，例如 AWS，需要使用 IaC 才能最大化效用和价值。IaC 与传统的 *交互式* 基础设施管理方法的主要区别在于，它是机器可处理的。这带来了诸多好处：

+   改进的资源可见性

+   部署和环境之间更高的一致性

+   更容易的故障排除

+   能够以更少的努力实现更大的扩展性

+   更好的成本控制

在更为抽象的层面，所有这些因素也为你的开发人员带来了其他改进：你现在可以利用经过验证的软件开发实践来管理基础设施，并在团队中实现 DevOps 实践。

# 可见性

由于你的基础设施以机器可读的文件形式表示，你可以像对待应用程序代码一样对待它。你可以采用软件开发的最佳实践，并将其应用到你的基础设施中。这意味着你可以像管理代码一样将其存储在版本控制中（例如，Git 和 SVN），并享受它所带来的好处：

+   所有对基础设施的更改都会记录在提交历史中

+   你可以在接受/合并之前审查变更

+   你可以轻松比较不同的配置

+   你可以选择并使用特定时间点的配置

# 一致性

在各个环境（例如开发、测试和生产环境）中保持一致的配置意味着你可以更加自信地部署基础设施。当你知道正在使用的配置时，由于有一个共同的基准，你可以轻松地在其他环境中测试变更。

IaC 不同于*仅仅编写基础设施脚本*。大多数工具和服务将利用高级语言和领域特定语言（DSL），使你能够专注于更高层次的需求。它使你能够使用先进的软件开发技术，如静态分析、自动化测试和优化。

# 故障排除

IaC 使得复制和故障排除变得更加容易：因为你可以复制你的环境，所以可以准确地重现你的生产环境进行测试。

过去，由于硬件成本过高，测试环境很少有完全相同的基础设施。现在，由于可以按需创建和销毁，你能够仅在需要时复制环境。你只需要为它们运行的时间付费，通常按小时计算。测试完成后，只需关闭环境并停止支付费用。

比故障排除更好的是在问题导致错误之前就修复它们。当你在多个环境中完善你的基础设施即代码（IaC）时，你将获得一种没有它很难获得的自信。在将你的基础设施部署到生产环境时，你已经做过多次了。

# 扩展性

手动配置基础设施可能是一个繁琐且容易出错的过程。通过自动化，你消除了手动实现的潜在可变性：计算机擅长无聊的重复任务，所以把这些任务交给它们做吧！

一旦自动化，提供更多资源的劳动成本几乎为零——你已经完成了这项工作。无论你是需要启动一台服务器还是一千台，它都不需要额外的工作。

从实际角度来看，AWS 中的资源几乎没有限制。如果你愿意为此付费，AWS 会让你使用它。

# 成本

AWS 有着强烈的（商业）利益，希望你能够尽可能容易地提供基础设施。作为客户，你的好处是你可以根据需求*创建和销毁*这些资源。

显然，在传统的物理硬件环境中按需销毁基础设施是不可能的。你几乎无法找到一个数据中心，允许你仅仅因为当前没有使用服务器和空间，就停止为它们付费。

另一个按需基础设施能够大幅节省成本的使用场景是你的开发环境。只有在有开发人员使用它时，开发环境才有意义。当开发人员下班回家时，你可以关闭开发环境，这样就不需要为其付费了。在开发人员早上来之前，简单地安排他们的环境进行创建。

# DevOps

DevOps 和 IaC 是密切相关的。将你的基础设施（传统上是运营的关注点）作为代码（传统上是开发的关注点）进行存储的做法，促使了责任的共享，从而促进了协作。

![](img/B06326_01_02.png)

图片来源：维基百科

通过自动化软件开发生命周期中的**PACKAGE**、**RELEASE**和**CONFIGURE**活动（如图所示），你可以提高发布速度，同时增加信心。

基于云的 IaC 鼓励*为故障做架构设计*：因为你的资源是虚拟化的，所以必须为物理（主机）硬件故障的可能性做计划，尽管这种情况不太可能发生。

能够在几分钟内重建整个环境是终极的恢复解决方案。

与物理硬件不同，你可以通过删除关键组件来轻松模拟和测试软件架构中的故障——反正它们都是虚拟的！

# 服务器配置

服务器端的 IaC 示例包括配置管理工具，如 Ansible、Chef 和 Puppet。

虽然重要，这些配置管理工具并非 AWS 特有，因此我们在此不会详细介绍。如果你需要了解更多，市面上有无数书籍和课程专门讲解此话题。

# AWS 上的 IaC

CloudFormation 是 AWS 的 IaC 服务。

使用特定格式和语言编写的模板定义了应当配置的 AWS 资源。CloudFormation 是声明式的，不仅可以配置资源，还可以更新它们。

我们将在下一个主题中详细介绍 CloudFormation。

# CloudFormation

本书中我们将广泛使用 CloudFormation，因此理解它是什么以及它如何融入 AWS 生态系统非常重要。这里的信息应该足以帮助你入门，但在必要时，我们会参考 AWS 的官方文档。

# 什么是 CloudFormation？

**CloudFormation** 服务允许你以自动化和可重复的方式配置和管理一组 AWS 资源。在 AWS 术语中，这些资源集合被称为**堆栈**。不过请注意，堆栈的大小可以根据需要调整。它可以由一个单一的 S3 桶组成，也可以包含托管你三层 Web 应用所需的一切。

在本章中，我们将向你展示如何定义要包含在 CloudFormation 堆栈中的资源。我们会进一步讨论这些堆栈的组成，以及何时和为何更倾向于将资源分配到多个堆栈中。最后，我们将分享一些在构建无数 CloudFormation 堆栈过程中学到的小技巧。

请注意！  

几乎每个人在使用 CloudFormation 的过程中都会遇到至少一两个小问题。不过，这一切都是值得的。  

# 为什么 CloudFormation 很重要？  

到现在为止，自动化的好处应该已经开始显现给你看了。但不要陷入误区，认为 CloudFormation 只对大规模资源集合有用。即使是执行最简单的任务，比如创建一个 S3 桶，如果你需要在每个区域都做一遍，也会变得非常重复。  

我们与很多客户合作，这些客户在其基础设施方面有非常严格的控制和治理，尤其是在网络层面（例如 VPC、NACL 和安全组）。能够使用 YAML（或 JSON）表达一个人的云足迹，将其存储在源代码仓库中，并通过高可见性的流水线进行处理，能让这些客户确信他们的基础设施更改已经经过同行评审，并且会在生产环境中按预期工作。当然，遵循 IaC SDLC 实践的纪律性和承诺在其中起着重要作用，但 CloudFormation 帮助我们摆脱了依赖 20 页手动变更清单、应对未追踪或未解释的配置漂移，以及避免因操作失误导致的意外停机的时代。  

# 层蛋糕  

现在是开始从层次的角度思考你的 AWS 部署的好时机。你的各个层次将会相互叠加，你将会在它们之间定义清晰的关系。  

这是一个自下而上的示例，展示了你的层蛋糕可能的样子：  

+   VPC 与 CloudTrail  

+   子网、路由和 NACL  

+   NAT 网关、VPN 或堡垒主机及相关安全组  

+   应用堆栈 1：安全组，S3 桶  

+   应用堆栈 1：跨可用区的 RDS 和只读副本  

+   应用堆栈 1：应用程序和 Web 服务器自动扩展组以及 ELB  

+   应用堆栈 1：CloudFront 和 WAF 配置  

在这个示例中，你的 VPC 中可能会有许多应用堆栈层，前提是你的子网中有足够的 IP 地址！这通常出现在开发环境中的 VPC。因此，你可以立即享受到多租户能力与应用隔离的好处。  

这种方法的一个优势是，在你开发 CloudFormation 模板时，如果你弄错了应用服务器的配置，你不需要回滚 CFN 为你完成的所有工作。你可以直接删除该特定层（以及依赖它的层），然后从那里重新开始。如果你将所有内容包含在一个单一的模板中，就不可能做到这一点。  

我们通常与客户合作，其中每一层的所有权和管理反映了公司内技术部门的结构。传统的基础设施、网络和网络安全人员通常对为数字团队创建安全的应用部署环境感兴趣，因此他们喜欢对基础层进行严格的管理。**康威定律**（Conway's Law），由梅尔文·康威提出，在这里开始发挥作用：

“任何设计系统的组织，最终都会产生一个设计，其结构是该组织沟通结构的复制。”

最后，即使你是一个小团队中的单人基础设施开发人员，你也会从这种方法中受益。例如，你会发现它显著减少了你遇到 AWS 限制、超时和循环依赖的风险。

# CloudFormation 模板

这时我们开始动手实践。CloudFormation 模板文件是你堆栈的编程表示，通常以 YAML 或 JSON 形式表达。当你希望创建 CloudFormation 堆栈时，你将这个模板文件通过 API、Web 控制台、命令行工具或其他方法（例如 SDK）推送到 CloudFormation。

模板可以被 CloudFormation 一次又一次地重放，创建多个堆栈实例。

# YAML 与 JSON

直到最近，JSON 是唯一的选择。我们实际上鼓励你采用 YAML，并且我们将在本书中使用它作为所有示例。以下是其中一些原因：

+   它看起来更美观。语法更简洁，如果你选择生成 CloudFormation 模板，几乎每种编程语言都有某种形式的 YAML 库。

+   你的模板大小将会更小。这从开发人员的角度来看更实用，同时也意味着你更不容易遇到 CloudFormation 模板文件大小限制（50 KB）。

+   字符串替换功能更易于使用和解释。

+   你的 EC2 `UserData`（当 EC2 实例启动时运行的脚本）将更容易实现和维护。

# 进一步了解 CloudFormation 模板

CloudFormation 模板由多个部分组成，但我们将重点关注以下四个部分：

+   参数

+   资源

+   输出

+   映射

这是一个简短的 YAML 示例：

```
AWSTemplateFormatVersion: '2010-09-09' 
Parameters: 
  EC2KeyName: 
    Type: String 
    Description: EC2 Key Pair to launch with 
Mappings: 
  RegionMap: 
    us-east-1: 
      AMIID: ami-9be6f38c 
    ap-southeast-2: 
      AMIID: ami-28cff44b 
Resources: 
  ExampleEC2Instance: 
    Type: AWS::EC2::Instance 
    Properties: 
      InstanceType: t2.nano 
      UserData: 
        Fn::Base64: 
          Fn::Sub': |
            #!/bin/bash -ex
            /opt/aws/bin/cfn-signal '${ExampleWaitHandle}' 
      ImageId: 
        Fn::FindInMap: [ RegionMap, Ref: 'AWS::Region', AMIID ]    
      KeyName: 
        Ref: EC2KeyName 
  ExampleWaitHandle: 
    Type: AWS::CloudFormation::WaitConditionHandle 
    Properties: 
  ExampleWaitCondition: 
    Type: AWS::CloudFormation::WaitCondition 
    DependsOn: ExampleEC2Instance 
    Properties: 
      Handle: 
        Ref: ExampleWaitHandle 
      Timeout: 600 
Outputs: 
  ExampleOutput: 
    Value: 
      Fn::GetAtt: ExampleWaitCondition.Data 
    Description: The data signaled with the WaitCondition

```

# 参数

CloudFormation 参数是你在创建或更新堆栈时定义的输入值，类似于你向任何命令行工具提供参数的方式。它们允许你在不修改模板的情况下自定义堆栈。参数可能用于的常见示例如下：

+   **EC2 AMI ID**：你可能希望使用安装了最新安全补丁的新 AMI 重新部署堆栈。

+   **子网 ID**：你可能有一个自动伸缩组需要在其中部署服务器的子网列表。这些子网 ID 在开发、测试和生产环境中会有所不同。

+   **端点目标和凭证**：这些包括 API 主机名、用户名和密码等内容。

你会发现有很多种参数类型。简而言之，它们包括：

+   字符串

+   数字

+   列表

+   逗号分隔列表

除了这些，AWS 还提供了一些 AWS 特定的参数类型。这些在通过 CloudFormation 网页控制台执行模板时特别有用。例如，`AWS::EC2::AvailabilityZone::Name`类型的参数会让网页控制台显示一个有效可选可用区的下拉列表。在`ap-southeast-2`区域，列表如下所示：

+   `ap-southeast-2a`

+   `ap-southeast-2b`

+   `ap-southeast-2c`

AWS 特定的参数类型列表正在不断增长，已经大到无法在此列举。尽管如此，我们会在本书中多次使用它们，并且它们可以很容易地在 AWS CloudFormation 文档中找到。

在创建或更新堆栈时，你需要为模板中定义的所有参数提供值。在适当的情况下，你可以为参数定义默认值。例如，你可能有一个名为`debug`的参数，用来指示应用程序以调试模式运行。你通常不希望默认启用此模式，因此可以将此参数的默认值设置为`false`、`disabled`或应用程序理解的其他值。当然，在创建或更新堆栈时，可以覆盖此值。

你可以并且应该为每个参数提供一个简短而有意义的描述。这些描述会在网页控制台的每个参数字段旁边显示。当正确使用时，它们为执行你 CloudFormation 模板的人提供了提示和上下文。

在这一点上，我们需要介绍内置的`Ref`函数。当你需要引用一个参数值时，可以使用这个函数：

```
KeyName:
  Ref: EC2KeyName

```

虽然`Ref`并不是你需要了解的唯一内置函数，但它几乎肯定是你将使用最多的一个。我们将在本章后面详细讨论内置函数。

# 资源

资源是你实际的 AWS 基础设施组件。这些包括 EC2 实例、S3 存储桶、ELB 等。几乎你可以通过 AWS 网页控制台点击和选择创建的任何资源类型，都可以通过 CloudFormation 来创建。

在本章中列出所有 AWS 资源类型并不实际，尽管在你完成本书的食谱时，你会熟悉最常见的资源类型。AWS 在这里保留了一个资源类型的完整列表

[`docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html)

关于 CloudFormation 资源，有一些重要的事项需要记住：

+   新的或领先的 AWS 资源通常不会立即得到支持。CloudFormation 支持通常滞后于新 AWS 功能发布几周（有时几个月）。对于基础设施自动化至关重要的人员来说，过去这是非常令人沮丧的。快进到今天，通过使用自定义资源，这种情况在一定程度上得到了缓解。本章后面将进一步讨论这些内容。

+   资源有一个默认的返回值。您可以使用 `Ref` 获取这些返回值，以在模板的其他位置使用。例如，`AWS::EC2::VPC` 资源类型有一个默认返回值，即 VPC 的 ID。它们看起来像这样：`vpc-11aa111a`。

+   资源通常包含额外的返回值。使用内置的 `Fn::GetAtt` 函数来获取这些额外的值。继续上一个示例，`AWS::EC2::VPC` 资源类型还返回以下内容：

    +   `CidrBlock`

    +   `DefaultNetworkAcl`

    +   `DefaultSecurityGroup`

    +   `Ipv6CidrBlocks`

# 输出

就像 AWS 资源一样，CloudFormation 堆栈也可以有返回值，称为 **outputs**。这些值完全由用户定义。如果您没有指定任何输出，则在堆栈完成时不返回任何内容。

当您使用 CI/CD 工具创建 CloudFormation 堆栈时，输出可以非常有用。例如，您可能希望输出 ELB 的公共主机名，以便您的 CI/CD 工具可以在作业输出中将其转换为可点击的链接。

当您连接层次蛋糕的各个部分时，也会使用它们。您可能希望引用另一个堆栈中创建的 S3 存储桶或安全组。这在新的跨堆栈引用功能中更加容易，我们稍后会在本章讨论。您可以预期在任何 CloudFormation 模板的输出部分经常看到 `Ref` 和 `Fn::GetAtt` 函数。

# 映射

映射部分用于定义一组键/值对。如果您需要任何类型的 AWS 区域可移植性，例如用于灾难恢复或可用性目的，或仅仅为了使您的应用程序更接近最终用户，那么几乎肯定需要在模板中指定一些映射。如果您在模板中引用了任何区域特定的内容，则特别需要这样做。

典型的例子是在模板中指定一组 EC2 AMI ID 的映射。这是因为 AMI 是区域特定的资源，因此在一个区域中对有效 **Amazon Machine Image** (**AMI**) ID 的引用在另一个区域中是无效的。

映射看起来像这样：

```
Mappings:
  RegionMap:
    us-east-1:
      AMIID: ami-9be6f38c
    ap-southeast-2:
      AMIID: ami-28cff44b

```

# 依赖关系和顺序

在执行模板时，CloudFormation 将自动确定资源之间的依赖关系，并相应地按顺序创建它们。此外，资源的创建尽可能并行化，以使您的堆栈执行尽快完成。然而，有时会出现问题。

假设应用服务器依赖于数据库服务器。在连接数据库之前，应用服务器需要知道数据库的 IP 地址或主机名。实际上，这种情况需要你先创建数据库服务器，然后使用 `Ref` 获取其 IP 地址，并将其提供给应用服务器。由于 CloudFormation 并不了解这两个资源之间的耦合关系，因此它会按任意顺序（或者如果可能，则并行）创建这些资源。

为了解决这个问题，我们使用 `DependsOn` 属性告诉 CloudFormation 应用服务器依赖于数据库服务器。事实上，`DependsOn` 实际上可以接收一个字符串列表，如果某个资源依赖于多个资源才能创建。例如，如果我们的应用服务器还依赖于一个 Memcached 服务器，那么我们可以使用 `DependsOn` 来声明这两个依赖关系。

如果需要，你可以进一步扩展这个过程。假设数据库服务器启动后，它将自动启动数据库、设置模式并导入大量数据。我们可能需要等待此过程完成，然后再创建一个应用服务器，该服务器试图连接到一个期望已完成模式和数据集的数据库。在这种情况下，我们希望有一种方法向 CloudFormation 发出信号，表示数据库服务器已完成初始化，以便它可以继续创建依赖于它的资源。这就是 `WaitCondition` 和 `WaitConditionHandle` 的作用。

首先，你创建一个 `AWS::CloudFormation::WaitConditionHandle` 类型，之后你可以通过 `Ref` 来引用它。

接下来，你创建一个 `AWS::CloudFormation::WaitCondition` 类型。在我们的例子中，我们希望等待时间从数据库服务器创建开始，因此我们指定该 `WaitCondition` 资源依赖于我们的数据库服务器（`DependsOn`）。

在数据库服务器完成数据导入并准备接受连接后，它会调用由 `WaitConditionHandle` 资源提供的回调 URL，向 CloudFormation 发出信号，表示它可以停止等待并开始执行其余的 CloudFormation 堆栈。该 URL 通过 `UserData` 提供给数据库服务器，仍然使用 `Ref`。通常，`curl`、`wget` 或类似工具用于调用该 URL。

`WaitCondition` 资源也可以设置 `Timeout` 时间。这是一个以秒为单位的值。在我们的示例中，我们可能会设置为 `900`，因为我们知道启动数据库并导入数据不应该超过 15 分钟。

下面是一个 `DependsOn`、`WaitConditionHandle` 和 `WaitCondition` 组合使用的示例：

```
ExampleWaitHandle: 
  Type: AWS::CloudFormation::WaitConditionHandle 
  Properties: 
ExampleWaitCondition: 
  Type: AWS::CloudFormation::WaitCondition 
  DependsOn: ExampleEC2Instance 
  Properties: 
    Handle: 
      Ref: ExampleWaitHandle 
    Timeout: 600

```

# 函数

CloudFormation 提供了一些内置函数，使得编写模板变得更加简单。我们已经了解了 `Ref` 和 `Fn::GetAtt`。接下来我们看看你可能会遇到的其他一些函数。

# Fn::Join

使用 `Fn::Join` 将一组字符串通过指定的分隔符连接起来，例如：

```
"Fn::Join": [ ".", [ 1, 2, 3, 4 ] ]

```

这将产生以下值：

```
"1.2.3.4"

```

# Fn::Sub

使用 `Fn::Sub` 执行字符串替换。请考虑以下情况：

```
DSN: "Fn::Sub"
  - mysql://${db_user}:${db_pass}@${db_host}:3306/wordpress
  - { db_user: lchan, db_pass: ch33s3, db_host: localhost }

```

这将产生以下值：

```
mysql://lchan:ch33s3@localhost:3306/wordpress

```

当你将这些函数与 `Ref` 和 `Fn::GetAtt` 结合使用时，你可以开始做一些非常强大的事情，正如我们将在本书的配方中看到的那样。

其他可用的内置函数包括：

+   `Fn::Base64`

+   `Fn::FindInMap`

+   `Fn::GetAZs`

+   `Fn::ImportValue`

+   `Fn::Select`

所有这些功能的文档可以在这里找到 [`docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference.html`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference.html)。

# 条件语句

根据你的堆栈运行的环境，通常会根据需要配置一个相似但不同的资源集。例如，在开发环境中，你可能不希望创建一整套数据库服务器（HA 主服务器和只读副本），而是选择仅创建一个数据库服务器。你可以通过使用条件语句来实现这一点：

+   `Fn::And`

+   `Fn::Equals`

+   `Fn::If`

+   `Fn::Not`

+   `Fn::Or`

# 权限和服务角色

关于 CloudFormation，有一点很重要：它基本上只是代表你进行 API 调用。这意味着 CloudFormation 将使用你执行模板时所用的相同权限或角色。例如，如果你没有权限在 Route 53 中创建新的托管区域，那么你尝试运行的任何包含新 Route 53 托管区域的模板都将失败。

另一方面，这创造了一个相对棘手的情况，任何开发 CloudFormation 的人通常都具有非常高的权限，并且这些权限在每次执行模板时都会被不必要地授予给 CloudFormation。

如果我的 CloudFormation 模板仅包含一个资源，即一个 Route 53 托管区域，那么让该模板以完全管理员权限执行就没有意义。给 CloudFormation 一个非常有限的权限集来执行模板，更有意义，这样如果执行了一个错误的模板（即错误的复制粘贴操作导致资源被删除），爆炸半径也会受到限制。

幸运的是，最近引入了服务角色，你现在可以定义一个 IAM 角色，并告知 CloudFormation 在执行堆栈时使用该角色，从而为你提供了一个更安全的操作空间。

# 自定义资源

如本章前面所讨论的那样，在发布新的 AWS 功能和你能够在 CloudFormation 中使用该功能之间，通常会有一个较长的等待期。

在自定义资源出现之前，这将 AWS 开发人员带入了在 CloudFormation 中执行超过 95% 自动化任务的路径，然后再运行一些 CLI 命令来填补空白。通常很难准确地知道哪些资源属于哪个堆栈，并且也很难确定你的堆栈何时完成执行，这成了一个猜谜游戏。

快进到今天，新的趋势是使用自定义资源委托给 AWS **Lambda**函数。Lambda 可以通过代表你进行 API 调用来填补空白，并且更容易追踪这些资源的来源和完成情况。

如果运气好的话，你暂时不需要使用这个功能。与此同时，AWS 自定义资源的文档非常全面。如果你尝试使用 CloudFormation 创建一个在 AWS 文档中找不到的资源，那么很可能它在 CloudFormation 中还不被支持，这时候使用自定义资源就是解决方案。更多信息请参考[`docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-custom-resources.html`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-custom-resources.html)。

# 跨堆栈引用

在使用分层结构方法时，常常需要将一个堆栈的输出作为另一个堆栈的输入。例如，你可能在一个堆栈中创建了一个 VPC，并且在创建另一个堆栈中的资源时需要其 VPC ID。

长时间以来，创建堆栈时需要提供一些辅助机制来传递堆栈之间的输出。AWS 最近引入了跨堆栈引用，这提供了一种更原生的方式来实现这一目标。

你现在可以*导出*一个或多个堆栈的输出。这使得这些输出可以在其他堆栈中使用。请注意，这些值的名称需要是唯一的，因此最好在导出的名称中包括 CloudFormation 堆栈名称，以确保唯一性。

一旦某个值被导出，它就可以通过`Fn::ImportValue`函数在另一个堆栈中导入，非常方便！

但是，请确保在导出的值被引用期间，你无法删除或修改它。此外，你也不能删除包含导出值的堆栈。一旦某个东西引用了一个导出的值，它就会一直存在，直到没有堆栈再引用它为止。

# 更新资源

基础设施即代码（IaC）的一个原则是，所有的变更都应该以代码的形式进行表示，以便于审查和测试。这一点在使用 CloudFormation 时尤为重要。

在为你创建堆栈后，CloudFormation 服务实际上是“放手”的。如果你对 CloudFormation 创建的任何资源进行更改（无论是在 Web 控制台、命令行，还是通过其他方法），你实际上是在导致配置漂移。CloudFormation 此时已经无法准确了解堆栈中资源的状态。

正确的方法是在 CloudFormation 模板中进行这些更改，并对堆栈执行更新操作。这确保了 CloudFormation 始终知道堆栈的状态，并使你能够保持信心，认为你的基础设施代码是正在运行环境的完整且准确的表示。

# 变更集

在执行堆栈更新时，可能无法清楚地了解将对堆栈进行哪些更改。根据你要更改的资源，你可能会发现它需要被删除并重新创建，以便实现更改。当然，如果相关资源包含你希望保留的数据，这种行为是完全不希望发生的。请记住，RDS 数据库可能是一个特别的痛点。

为了缓解这种情况，CloudFormation 允许你在执行更新之前创建并查看*变更集*。变更集显示了 CloudFormation 打算在你的资源上执行哪些操作。如果变更集看起来没问题，你可以选择继续。如果你不满意看到的内容，可以删除变更集并选择另一个行动方案——也许选择创建并切换到一个全新的堆栈以避免服务中断。

# 其他需要了解的事项

在你开始构建自己的 CloudFormation 堆栈时，还有一些其他事项需要放在心上。我们来看看。

# 名称冲突

通常，如果你省略了资源的名称属性，CloudFormation 会为你生成一个名称。这可能导致奇怪的资源名称，但它会增加模板的*可重放性*。以 `AWS::S3::Bucket` 为例，如果你指定了 `BucketName` 参数但没有确保其唯一性，CloudFormation 在第二次执行模板时会失败，因为该桶已存在。省略 `BucketName` 可以解决此问题。或者，你可以选择每次运行模板时生成一个独特的名称。这里可能没有对错之分，所以做最适合你的方式就好。

# 回滚

在创建 CloudFormation 堆栈时，你可以选择禁用回滚。在你决定将其设置为 `true` 之前，请记住，这个设置会在堆栈创建后持续存在。我们曾经遇到过在更新现有堆栈失败（由于某种原因）但回滚已被禁用的危险情况。这对任何人来说都不是一种愉快的处境。

# 限制

最有可能让你担心的限制如下：

+   CloudFormation 模板的最大大小为 50 KB。这个限制相当宽松，如果你达到了这个限制，那么几乎可以肯定需要考虑将模板拆分成多个较小的模板。如果你确实需要超过 50 KB 的限制，最常见的方法是先将模板上传到 S3，然后提供 S3 URL 给 CloudFormation 执行。

+   你可以指定的最大参数数量为*60*。如果你需要更多，那么再次考虑是否需要为你的“蛋糕”添加更多的层次。否则，使用列表或映射可能会帮你脱困。

+   输出数量也限制为*60*。如果你达到了这个限制，可能是时候考虑使用多个较小的模板了。

+   资源数量限制为*200*。这里的规则与之前相同。

+   默认情况下，你的 CloudFormation 堆栈数量被限制为*200*个。你只需联系 AWS 即可增加这个限制。

# 循环依赖

需要牢记的一点是，你可能会遇到循环依赖的情况，即多个资源在创建时相互依赖。一个常见的例子是两个安全组互相引用，以便允许彼此之间的访问。

针对这种特定场景的解决方法是使用 `AWS::EC2::SecurityGroupEgress` 和 `AWS::EC2::SecurityGroupIngress` 类型，而不是 `AWS::EC2::SecurityGroup` 的入口和出口规则类型。

# DSL 和生成器

DSL 和生成器是基础设施编码人员之间热烈辩论的焦点。一些人喜欢它们，另一些人则讨厌它们。人们喜欢它们的原因包括以下几点：

+   它们允许用更本地化的语言或团队语言编写 CloudFormation。

+   它们允许使用一些高级编程构造。迭代就是一个被广泛引用的例子。

+   在 CloudFormation 支持 YAML 之前，使用 DSL 通常能使代码更易读，且冗长度大大降低。

人们不喜欢它们的原因包括以下几点：

+   DSL 在历史上曾经成为废弃软件，或与 CloudFormation 版本差距较大，尽管现在有一些得到良好支持的 DSL。

+   开发人员可能需要学习一门新语言，并且还要应对另一个新的文档体系，除了要学习 CloudFormation 和浏览 AWS 文档。

+   Google 和 Stack Overflow 的作用会略显不足，因为需要翻译问题和答案。

除了这里写的内容外，本书中不会再涉及这个话题。我们不能给出具体的建议，让你选择哪条路，因为这几乎总是一个高度个人化和情境化的选择。不过，特别是在熟悉 AWS 和 CloudFormation 的过程中，一个明智的做法是坚持使用 YAML（或 JSON），直到你认为 DSL 或生成器可能有用为止。

# 凭证

无论如何，你都不希望在模板中硬编码凭证或将其提交到源码仓库中。这样做不仅增加了凭证被盗用的风险，还降低了模板的可移植性。如果凭证被硬编码且需要更改，这显然需要你编辑 CloudFormation 模板。

相反，你应该将凭证作为参数添加到模板中。确保在这样做时使用 `NoEcho` 参数，以便 CloudFormation 在显示参数时屏蔽其值。

# 堆栈策略

如果您的堆栈中有资源希望保护免受意外删除或修改，可以应用堆栈策略来实现这一点。默认情况下，所有资源都可以被删除或修改。当您应用堆栈策略时，所有资源将被保护，除非您在策略中明确允许它们被删除或修改。请注意，堆栈策略在堆栈创建期间不生效——它们仅在您尝试更新堆栈时生效。

# 命令行界面工具

AWS **命令行界面** (**CLI**) 工具是 AWS 管理员工具包中的一个重要组成部分。

CLI 工具通常是与 API 交互的最快和最简单的方法之一。作为一种基于文本的工具，它比使用网页控制台更容易扩展。与控制台不同，它可以通过脚本等方式进行自动化。AWS **应用程序编程接口** (**API**) 表示作为 AWS 管理员可用的所有功能。它也更容易通过命令行历史记录进行跟踪。像所有优秀的 CLI 工具一样，简单的单个命令可以串联（或*管道*）在一起，执行复杂的任务。

CLI 工具是开源软件，维护在 GitHub 上 [`github.com/aws/aws-cli`](https://github.com/aws/aws-cli)。更多详细文档，请参考 AWS CLI 主页 [`aws.amazon.com/cli`](https://aws.amazon.com/cli)。

# 安装

CLI 工具需要 Python 2.6.5 或更高版本。

安装它的最简单方法是使用 Python 包管理器`pip`：

```
pip install awscli

```

这将使得`aws`命令在您的系统上可用。

# 升级

AWS 经常发布新服务和新功能。为了使用这些新功能，您需要升级 CLI 工具。

要升级，请定期运行以下`pip`命令：

```
pip install --upgrade awscli

```

# 配置

CLI 工具与 AWS API 之间的认证是通过两项信息完成的：

+   访问密钥 ID

+   秘密访问密钥

顾名思义，您应该保密您的秘密访问密钥！小心存储或发送它的地方。

创建用户后，您可以配置工具以用于认证目的。

虽然您可以直接用访问密钥配置 CLI 工具，但不推荐这样做。相反，您应该使用配置文件来存储凭证。使用配置文件可以让您在一个一致的、易于管理的集中位置来保护您的秘密密钥。

# 默认配置文件

在没有任何额外配置或选项的情况下，您的 CLI 工具命令将使用默认配置文件。

要设置默认配置文件，您可以使用以下命令：

```
aws configure

```

这将提示您输入访问密钥 ID、秘密访问密钥、区域和输出格式。

# 命名配置文件

除了默认配置文件外，您还可以配置其他命名的配置文件。这对于在具有不同访问权限级别的用户之间切换（例如，只读用户和管理员）或甚至在不同帐户的用户之间切换非常有用。

```
aws configure --profile <profile-name>

```

在响应提示后，你可以通过在命令中传递 `--profile <profile-name>` 选项来引用命名的配置文件。

# 环境变量

你还可以通过使用环境变量来配置 CLI：

```
export AWS_PROFILE=<profile-name>

```

虽然你应该优先使用配置文件，而不是直接设置访问 ID 和密钥，但有时你可能不得不这么做。如果你*必须*直接设置密钥，请通过环境变量来设置，这样你就不需要传递密钥或将其硬编码：

```
export AWS_ACCESS_KEY_ID=<access-key-id>
export AWS_SECRET_ACCESS_KEY=<secret-access-key>

```

# 实例角色

在 EC2 实例上运行 CLI 工具时，你可以利用实例的 IAM 角色进行调用。这意味着你不需要手动配置凭证或设置环境变量。

在幕后，实例将检索并设置它自己的 AWS 环境变量，以允许 API 调用。你需要确保该实例具有适当的权限。

AWS CLI 工具在 AWS 基于 Linux 的实例上预装。

# 用法

所有 CLI 工具命令都是基于服务的。通过使用服务命令和子命令，你可以直接向 AWS API 发出调用。

# 命令

每个命令代表一个 AWS 服务。虽然大多数服务只有一个命令与之关联，但有些服务有多个命令（例如，S3 有 `s3` 和 `s3api`）。

运行 `aws help` 查看所有可用的命令/服务—它们可能会在本书打印时有所变化！

# 子命令

每个命令都有一组子命令，用于执行特定服务的操作。

运行 `aws <command> help` 查看所有子命令。

# 选项

子命令接受以 `--` 开头的选项。

使用 `aws <command> <subcommand> help` 查看所有选项及其用途。

虽然大多数是可选的（因此得名），但那些*没有*被方括号（`[]`）括起来的选项是必需的。如果你没有包含它们，将会收到错误信息（并附有相关细节）。

内置文档是开始寻找答案的最佳地方。通常在所有选项描述之后会有示例。否则，网上有很多可用的示例。

有些选项适用于所有或大多数命令，因此它们特别有用，值得了解。

# 输出

CLI 工具可以配置为以 JSON、表格或文本格式输出。要控制输出类型，请使用 `--output` 选项。

要为所有命令设置默认的输出类型，可以为你的配置文件设置 `output` 参数。

# JSON

**JavaScript 对象表示法** (**JSON**) ([`json.org/`](http://json.org/))，一种标准的、机器和人类可读的信息交换格式。以下是 `us-east-1`（北弗吉尼亚）区域的可用可用区（AZ）在 JSON 格式中的表示：

```
aws ec2 describe-availability-zones --output json 
{ 
"AvailabilityZones": [ 
        { 
"State": "available", 
"RegionName": "us-east-1", 
"Messages": [], 
"ZoneName": "us-east-1a" 
        }, 
        { 
"State": "available", 
"RegionName": "us-east-1", 
"Messages": [], 
"ZoneName": "us-east-1c" 
        }, 
        { 
"State": "available", 
"RegionName": "us-east-1", 
"Messages": [], 
"ZoneName": "us-east-1d" 
        }, 
        { 
"State": "available", 
"RegionName": "us-east-1", 
"Messages": [], 
"ZoneName": "us-east-1e" 
        } 
    ] 
}

```

# 表格

表格格式会显示一个文本/ASCII 表格的结果。这对于生成可打印报告非常有用：

![](img/B06326_01_03.png)

# 文本

文本输出格式仅显示结果的键/值响应。没有添加任何额外的格式或显示字符。

![](img/B06326_01_04.png)

# 查询

CLI 工具支持使用 `--query` 选项转换 API 的响应。此选项将 JMESPath 查询作为参数，并返回查询结果。

JMESPath 是一种用于查询 JSON 的语言。有关更多信息，请访问 [`jmespath.org/`](http://jmespath.org/)。

由于查询作为命令的一部分在服务器上处理，而不是在客户端处理，因此可以通过将工作卸载到服务器，减少生成的有效负载的大小并提高响应时间。

JMESPath 可用于转换你收到的响应：

```
$ aws ec2 describe-availability-zones \
 --output json \
 --query 'AvailabilityZones[].ZoneName'
 [
 "us-east-1a",
 "us-east-1c",
 "us-east-1d",
 "us-east-1e"
 ]

```

它也可以用来过滤接收到的数据：

```
$ aws ec2 describe-availability-zones 
 --output json 
 --query "AvailabilityZones[?ZoneName == 'us-east-1a'].State"
 [
 "available"
 ]

```

# 生成 CLI 骨架

在使用 CLI 工具执行复杂任务时，传递一个包含选项的 JSON 对象可能会更简单。这种交互方式可能意味着你应该使用某个 AWS **软件开发工具包**（**SDK**）。

# 输入

要生成一个示例 JSON 对象（它将被接受），可以使用 `--generate-cli-skeleton` 选项运行命令：

```
$ aws ec2 describe-availability-zones --generate-cli-skeleton 
{ 
"DryRun": true, 
"ZoneNames": [ 
"" 
 ], 
"Filters": [ 
 { 
"Name": "", 
"Values": [ 
"" 
 ] 
 } 
 ] 
}

```

你可以复制、编辑并使用此对象来定义你的命令选项，而无需传递多个单独的选项。这对于包含选项数组或选项数量可变的命令效果最佳。

# 输出

你还可以通过调用带有 `--generate-cli-skeleton output` 选项的命令，预览命令的输出。这可以加速合并 CLI 命令的过程，因为你可以在不实际调用 API 的情况下查看响应：

```
$ aws ec2 describe-availability-zones --generate-cli-skeleton output 
{ 
"AvailabilityZones": [ 
 { 
"ZoneName": "ZoneName", 
"State": "State", 
"RegionName": "RegionName", 
"Messages": [ 
 { 
"Message": "Message" 
 } 
 ] 
 } 
 ] 
}

```

# 分页

CLI 工具返回的结果默认限制为 1,000 个资源。

通常这不是问题，但在某些规模下，你可能会遇到分页问题。一个常见的例子是 S3 桶中的文件。

如果你完全确定应该在响应中看到某个特定资源但没有看到，请检查你的分页设置。该资源可能已经包含在匹配的资源中，只是没有出现在返回的响应部分。

以下选项允许你控制从 API 返回的结果的数量和起始位置：

+   `--page-size`：此选项限制显示给你的资源数量，但不会实际限制返回的资源数量。默认的项目数（即 1,000 个）仍将被处理并返回给你。

+   `--max-items`：此选项设置响应中实际返回的项目数量的上限。你可能会收到更少的项目，但不会收到超过此数量的项目。

+   `--starting-token`：此选项更改响应的起始位置。使用此选项可以显示后续的结果，超出第一页的内容。

```
aws s3 ls --bucket bucket-name --max-items 100 --starting-token None___100

```

# 自动完成

你可以通过配置 CLI 工具中包含的自动完成器来启用命令、子命令和选项的制表符自动完成。

在 OS X、Linux 和 Windows 系统中使用 bash shell，你可以使用以下命令加载自动完成器：

```
complete -C 'which aws_completer'aws

```

默认情况下，`aws_completer` 程序安装在 `/usr/local/bin`。如果你的工具安装在非标准位置，你需要找到它并将 `which aws_completer` 命令更改为相关路径。

# 相关工具

以下程序与 AWS CLI 工具配合良好，可能会派上用场。

# jq

jq 是一个轻量级的工具，用于处理和转换 JSON。它遵循 *Unix 哲学*：做一件事，并做到最好。可以在 [`stedolan.github.io/jq/`](https://stedolan.github.io/jq/) 找到它。

虽然 jq 和 JMESPath 很相似，但 jq 更容易上手。它还支持将 JSON 转换为纯文本；而 JMESPath 查询总是返回更多的 JSON 数据。

你可以将来自 CLI 工具的 JSON 结果传递给它，并轻松转换结果以供其他地方使用。这个示例使用 jq 的属性名称选择器将 JSON 输出转换为文本：

```
$ aws ec2 describe-availability-zones --output json | jq '.AvailabilityZones[].ZoneName'
"us-east-1a"
"us-east-1c"
"us-east-1d"
"us-east-1e"

```
