# 第六章：资源和文件管理

|   | *"简单的艺术是复杂的谜题"* |   |
| --- | --- | --- |
|   | --道格拉斯·霍顿 |

在本章中，我们将介绍以下内容：

+   高效分配 cron 作业

+   资源应用的调度

+   使用主机资源

+   使用导出的主机资源

+   使用多个文件来源

+   分配和合并目录树

+   清理旧文件

+   审计资源

+   临时禁用资源

# 介绍

在上一章中，我们介绍了虚拟资源和导出资源。虚拟资源和导出资源是管理资源如何应用到节点的一种方式。在本章中，我们将讨论何时以及如何应用资源。在某些情况下，您可能只希望在非工作时间应用资源，而在其他情况下，您可能希望只审计资源但不做任何更改。在其他情况下，您可能希望根据使用代码的节点应用完全不同的资源。正如我们将看到的，Puppet 有足够的灵活性来处理所有这些场景。

# 高效分配 cron 作业

当你有许多服务器执行相同的 cron 作业时，通常最好不要让它们同时运行。如果所有作业都访问一个共同的服务器（例如，执行备份时），这可能会给该服务器带来过大的负载，即使它们没有同时访问，所有服务器同时忙碌也可能会影响它们提供其他服务的能力。

像往常一样，Puppet 可以提供帮助；这次，我们使用 `inline_template` 函数来为每个作业计算一个唯一的时间。

## 如何实现...

以下是如何让 Puppet 为每台机器在不同时间安排相同作业的方法：

1.  修改你的 `site.pp` 文件，如下所示：

    ```
    node 'cookbook' {
      cron { 'run-backup':
        ensure  => present,
        command => '/usr/local/bin/backup',
        hour    => inline_template('<%= @hostname.sum % 24 %>'),
        minute  => '00',
      }
    }
    ```

1.  运行 Puppet：

    ```
    [root@cookbook ~]# puppet agent -t
    Info: Caching catalog for cookbook.example.com
    Info: Applying configuration version '1413730771'
    Notice: /Stage[main]/Main/Node[cookbook]/Cron[run-backup]/ensure: created
    Notice: Finished catalog run in 0.11 seconds

    ```

1.  运行 `crontab` 查看作业配置：

    ```
    [root@cookbook ~]# crontab -l
    # HEADER: This file was autogenerated at Sun Oct 19 10:59:32 -0400 2014 by puppet.
    # HEADER: While it can still be managed manually, it is definitely not recommended.
    # HEADER: Note particularly that the comments starting with 'Puppet Name' should
    # HEADER: not be deleted, as doing so could cause duplicate cron jobs.
    # Puppet Name: run-backup
    0 15 * * * /usr/local/bin/backup

    ```

## 它是如何工作的...

我们希望将 cron 作业的执行时间分配到所有节点上。我们选择一个在所有机器上唯一的值，并将其转换为数字。这样，值将在节点之间分布，并且每个节点的值不会变化。

我们可以使用 Ruby 的 `sum` 方法来进行转换，该方法从一个唯一于机器的字符串（在此例中是机器的主机名）计算出一个数值。`sum` 函数会生成一个大整数（例如，字符串 `cookbook` 的和为 855），而我们希望 `hour` 的值在 0 到 23 之间，因此我们使用 Ruby 的 `%`（取模）运算符将结果限制在这个范围内。根据主机名的不同，我们应该能得到一个合理的（尽管不是统计学上均匀的）值分布。这里的另一个选择是使用 `fqdn_rand()` 函数，它的工作方式与我们的示例类似。

如果所有机器都有相同的名称（确实会发生），不要指望这个技巧能奏效！在这种情况下，你可以使用其他在机器上唯一的字符串，比如 `ipaddress` 或 `fqdn`。

## 还有更多...

如果每台机器上有多个 cron 任务，并且你希望它们相隔特定的小时数执行，可以在 `hostname.sum` 资源中添加此数字，然后取模。假设我们想在某个任意时间运行 `dump_database` 任务，并在一小时后运行 `run_backup` 任务，可以使用以下代码片段实现：

```
cron { 'dump-database':
  ensure  => present,
  command => '/usr/local/bin/dump_database',
  hour    => inline_template('<%= @hostname.sum % 24 %>'),
  minute  => '00',
}

cron { 'run-backup':
  ensure  => present,
  command => '/usr/local/bin/backup',
  hour    => inline_template('<%= ( @hostname.sum + 1) % 24 %>'),
  minute  => '00',
}
```

这两个任务将导致每台运行 Puppet 的机器有不同的 `hour` 值，但 `run_backup` 总是会在 `dump_database` 后一小时执行。

大多数 cron 实现都包含了用于每小时、每天、每周和每月任务的目录。目录 `/etc/cron.hourly`、`/etc/cron.daily`、`/etc/cron.weekly` 和 `/etc/cron.monthly` 在我们的 Debian 和 Enterprise Linux 机器上都有。这些目录包含可执行文件，它们会根据参考的调度（每小时、每天、每周或每月）执行。我发现最好将这些文件夹中的所有任务描述清楚，并将任务作为 `file` 资源推送。盒子上的管理员可以通过在这些目录中使用 `grep` 查找你的脚本。为了在这里使用相同的技巧，我们可以将 cron 任务推送到 `/etc/cron.hourly`，然后验证这个小时是否是任务执行的正确时间。要使用 cron 目录创建 cron 任务，按照以下步骤操作：

1.  首先，在 `modules/cron/init.pp` 中创建一个 `cron` 类：

    ```
    class cron {
      file { '/etc/cron.hourly/run-backup':
        content => template('cron/run-backup'),
        mode    => 0755,
      }
    }
    ```

1.  在 `site.pp` 中的烹饪书节点中包含 `cron` 类：

    ```
    node cookbook {
      include cron
    }
    ```

1.  创建一个模板来保存 cron 任务：

    ```
    #!/bin/bash

    runhour=<%= @hostname.sum%24 %>
    hour=$(date +%H)
    if [ "$runhour" -ne "$hour" ]; then
      exit 0
    fi

    echo run-backup
    ```

1.  然后，运行 Puppet：

    ```
    [root@cookbook ~]# puppet agent -t
    Info: Caching catalog for cookbook.example.com
    Info: Applying configuration version '1413732254'
    Notice: /Stage[main]/Cron/File[/etc/cron.hourly/run-backup]/ensure: defined content as '{md5}5e50a7b586ce774df23301ee72904dda'
    Notice: Finished catalog run in 0.11 seconds

    ```

1.  验证脚本的值是否与我们之前计算的 `15` 相同：

    ```
    #!/bin/bash

    runhour=15
    hour=$(date +%H)
    if [ "$runhour" -ne "$hour" ]; then
      exit 0
    fi

    echo run-backup
    ```

现在，这个任务将每小时运行，但只有当 `$(date +%H)` 返回的小时等于 `15` 时，脚本的其他部分才会执行。将 cron 任务作为文件资源创建在大型组织中，可以让其他管理员更容易找到它们。当你的机器数量非常庞大时，在任务开始时添加另一个随机等待时间可能会有好处。你需要修改 `echo run-backup` 之前的那一行，添加以下内容：

```
MAXWAIT=600
sleep $((RANDOM%MAXWAIT))
```

这将最多等待 `600` 秒，但每次运行时等待的时间不同（假设你的随机数生成器工作正常）。这种随机等待在你有成千上万台机器运行相同任务时非常有用，尤其是当你需要尽可能分散任务的运行时。

## 另见

+   第二章中的 *从 cron 运行 Puppet* 方案，*Puppet 基础设施*

# 调度资源应用的时间

到目前为止，我们查看了 Puppet 可以做什么，以及它做事情的顺序，但没有查看它做事的时间。控制这一点的一种方法是使用 `schedule` 元参数。当你需要限制某个资源在指定时间段内应用的次数时，`schedule` 可以提供帮助。例如：

```
exec { "/usr/bin/apt-get update":
    schedule => daily,
}
```

理解 `schedule` 最重要的一点是，它只能阻止资源的应用。它不能保证资源以特定的频率被应用。例如，前面代码片段中显示的 `exec` 资源设置了 `schedule => daily`，但这只是表示 `exec` 资源每天可以运行的最大次数。它不会每天运行超过一次。如果你根本没有运行 Puppet，那么资源将完全不被应用。例如，在配置为每 4 小时运行一次代理（通过 `runinterval` 配置设置）的机器上，使用每小时计划是没有意义的。

也就是说，`schedule` 最好用于限制在不应该运行或不需要运行时阻止资源运行；例如，你可能希望确保 `apt-get update` 不会在一个小时内运行超过一次。你可以使用一些内置的计划：

+   `hourly`

+   `daily`

+   `weekly`

+   `monthly`

+   `never`

然而，你可以修改这些并创建你自己的自定义计划，使用 `schedule` 资源。我们将在以下示例中看到如何操作。假设我们希望确保一个表示维护作业的 `exec` 资源在办公时间内不会运行，因为它可能会干扰生产。

## 如何操作...

在这个例子中，我们将创建一个自定义的 `schedule` 资源，并将其分配给该资源：

1.  按如下方式修改你的 `site.pp` 文件：

    ```
    schedule { 'outside-office-hours':
      period => daily,
      range  => ['17:00-23:59','00:00-09:00'],
      repeat => 1,
    }
    node 'cookbook' {
      notify { 'Doing some maintenance':
        schedule => 'outside-office-hours',
      }
    }
    ```

1.  运行 Puppet。你看到的结果将取决于当天的时间。如果现在是在你定义的办公时间之外，Puppet 会按如下方式应用资源：

    ```
    [root@cookbook ~]# date
    Fri Jan  2 23:59:01 PST 2015
    [root@cookbook ~]# puppet agent -t
    Info: Caching catalog for cookbook.example.com
    Info: Applying configuration version '1413734477'
    Notice: Doing some maintenance
    Notice: /Stage[main]/Main/Node[cookbook]/Notify[Doing some maintenance]/message: defined 'message' as 'Doing some maintenance'
    Notice: Finished catalog run in 0.07 seconds

    ```

1.  如果时间在办公时间内，Puppet 将不会做任何操作：

    ```
    [root@cookbook ~]# date
    Fri Jan  2 09:59:01 PST 2015
    [root@cookbook ~]# puppet agent -t
    Info: Caching catalog for cookbook.example.com
    Info: Applying configuration version '1413734289'
    Notice: Finished catalog run in 0.09 seconds

    ```

## 它是如何工作的...

一个计划由三部分信息组成：

+   `period`（`hourly`、`daily`、`weekly` 或 `monthly`）

+   `range`（默认为整个时间段，但可以是其较小的一部分）

+   `repeat` 次数（在范围内允许应用资源的频率；默认为 1 或每个周期一次）

我们的自定义计划 `outside-office-hours` 提供了这三项参数：

```
schedule { 'outside-office-hours':
  period => daily,
  range  => ['17:00-23:59','00:00-09:00'],
  repeat => 1,
}
```

`period` 是 `daily`，`range` 被定义为一个由两个时间间隔组成的数组：

```
17:00-23:59
00:00-09:00
```

现在可以使用名为 `outside-office-hours` 的计划，它就像 `daily` 或 `hourly` 计划一样，可以与任何资源一起使用。在我们的示例中，我们通过 `schedule` 元参数将此计划分配给 `exec` 资源：

```
notify { 'Doing some maintenance':
  schedule => 'outside-office-hours',
}
```

如果没有这个 `schedule` 参数，资源将在每次运行 Puppet 时都被应用。使用此参数后，Puppet 会检查以下参数，以决定是否应用该资源：

+   是否时间在允许的范围内

+   是否资源在此期间已经运行了最大允许次数

例如，假设我们考虑在某一天的下午 4 点、5 点和 6 点 Puppet 会发生什么：

+   **下午 4 点**：在允许的时间范围之外，因此 Puppet 什么也不做

+   **下午 5 点**：它在允许的时间范围内，并且在此期间资源尚未运行，因此 Puppet 会应用该资源

+   **下午 6 点**：它在允许的时间范围内，但资源在此期间已运行最大次数，因此 Puppet 不会执行任何操作

依此类推，直到第二天。

## 还有更多...

`repeat` 参数控制在给定调度其他约束条件下资源会被应用多少次。例如，要使资源每小时最多应用六次，可以使用如下调度：

```
period => hourly,
repeat => 6,
```

请记住，这并不能保证作业每小时执行六次。它只是设置了一个上限；无论 Puppet 运行多频繁，或者其他任何事情发生，如果本小时已经运行过六次作业，它将不会再运行。如果 Puppet 仅每天运行一次，该作业将只会执行一次。因此，`schedule` 最好用来确保某些操作不会在特定时间发生（或不会超过给定的频率）。

# 使用主机资源

在云基础设施中，使用 DNS 将机器名称映射到 IP 地址并不总是实用或方便，特别是那些地址可能经常变化的情况。然而，如果你改为使用 `/etc/hosts` 文件中的条目，那么你就会面临如何将这些条目分发到所有机器并保持更新的问题。

这里有一个更好的方法；Puppet 的主机资源类型控制一个单独的 `/etc/hosts` 条目，你可以利用它轻松地将主机名映射到整个网络中的 IP 地址。例如，如果所有机器需要知道主数据库服务器的地址，你可以使用 `host` 资源来管理它。

## 如何操作...

按照以下步骤创建一个示例 `host` 资源：

1.  按照以下方式修改你的 `site.pp` 文件：

    ```
    node 'cookbook' {
      host { 'packtpub.com':
        ensure => present,
        ip     => '83.166.169.231',
      }
    }
    ```

1.  运行 Puppet：

    ```
    [root@cookbook ~]# puppet agent -t
    Info: Caching catalog for cookbook.example.com
    Info: Applying configuration version '1413781153'
    Notice: /Stage[main]/Main/Node[cookbook]/Host[packtpub.com]/ensure: created
    Info: Computing checksum on file /etc/hosts
    Notice: Finished catalog run in 0.12 seconds

    ```

## 它是如何工作的...

Puppet 将检查 `target` 文件（通常是 `/etc/hosts`），查看主机条目是否已经存在，如果不存在，则添加它。如果该主机名的条目已经存在但地址不同，Puppet 将更改地址以匹配清单。

## 还有更多...

将你的主机资源组织成类别可能会很有帮助。例如，你可以将所有数据库服务器的主机资源放入一个名为 `admin::dbhosts` 的类别中，然后该类别被所有 Web 服务器引用。

当机器可能需要在多个类别中定义时（例如，数据库服务器也可能是一个仓库服务器），虚拟资源可以解决这个问题。例如，你可以在一个类别中将所有主机定义为虚拟：

```
class admin::allhosts {
  @host { 'db1.packtpub.com':
    tag => 'database'
    ...
  }
}
```

你可以在不同的类别中实现所需的主机：

```
class admin::dbhosts {
  Host <| tag=='database' |>
}

class admin::webhosts {
  Host <| tag=='web' |>
}
```

# 使用导出的主机资源

在前面的例子中，我们使用了太空船语法来收集类型为数据库或网页的主机的虚拟主机资源。你可以使用相同的方法来处理导出资源。使用导出资源的好处是，随着你添加更多的数据库服务器，收集器语法会自动拉取新创建的服务器导出主机条目。这使得你的`/etc/hosts`条目更加动态。

## 准备工作

我们将使用导出的资源。如果你还没有做，设置好 puppetdb 并启用 storeconfigs 以按照第二章的说明使用 puppetdb，*Puppet 基础设施*。

## 如何操作...

在这个例子中，我们将配置数据库服务器和客户端之间的通信。我们将利用导出资源进行配置。

1.  创建一个新的数据库模块，`db`：

    ```
    t@mylaptop ~/puppet/modules $ mkdir -p db/manifests

    ```

1.  为你的数据库服务器创建一个新的类，`db::server`：

    ```
    class db::server {
      @@host {"$::fqdn":
        host_aliases => $::hostname,
        ip           => $::ipaddress,
        tag          => 'db::server',
      }
      # rest of db class
    }
    ```

1.  为你的数据库客户端创建一个新的类：

    ```
    class db::client {
      Host <<| tag == 'db::server' |>>
    }
    ```

1.  将数据库服务器模块应用于某些节点，例如在`site.pp`中：

    ```
    node 'dbserver1.example.com' {
      class {'db::server': }
    }
    node 'dbserver2.example.com' {
      class {'db::server': }
    }
    ```

1.  在带有数据库服务器模块的节点上运行 Puppet，以创建导出资源。

1.  将数据库客户端模块应用于 cookbook：

    ```
    node 'cookbook' {
      class {'db::client': }
    }
    ```

1.  运行 Puppet：

    ```
    [root@cookbook ~]# puppet agent -t
    Info: Caching catalog for cookbook.example.com
    Info: Applying configuration version '1413782501'
    Notice: /Stage[main]/Db::Client/Host[dbserver2.example.com]/ensure: created
    Info: Computing checksum on file /etc/hosts
    Notice: /Stage[main]/Db::Client/Host[dbserver1.example.com]/ensure: created
    Notice: Finished catalog run in 0.10 seconds

    ```

1.  验证`/etc/hosts`中的主机条目：

    ```
    [root@cookbook ~]# cat /etc/hosts
    # HEADER: This file was autogenerated at Mon Oct 20 01:21:42 -0400 2014
    # HEADER: by puppet.  While it can still be managed manually, it
    # HEADER: is definitely not recommended.
    127.0.0.1	localhost  localhost.localdomain localhost4 localhost4.localdomain4 
    ::1  localhost  localhost.localdomain localhost6 localhost6.localdomain6
    83.166.169.231  packtpub.com
    192.168.122.150  dbserver2.example.com  dbserver2
    192.168.122.151  dbserver1.example.com  dbserver1

    ```

## 它是如何工作的...

在`db::server`类中，我们创建了一个导出的主机资源：

```
@@host {"$::fqdn":
  host_aliases => $::hostname,
  ip           => $::ipaddress,
  tag          => 'db::server',
}
```

这个资源使用应用所在节点的完全限定域名（`$::fqdn`）。我们还使用短主机名（`$::hostname`）作为该节点的别名。别名会在`fqdn`后面打印到`/etc/hosts`中。我们使用节点的`$::ipaddress`事实作为主机条目的 IP 地址。最后，我们为资源添加标签，以便以后根据该标签进行收集。

这里需要记住的关键点是，如果主机的 IP 地址发生变化，导出资源会更新，收集该导出资源的节点将相应更新它们的主机记录。

我们在`db::client`中创建了一个收集器，该收集器只收集已标记为`'db::server'`的导出主机资源：

```
Host <<| tag == 'db::server' |>>
```

我们为两个节点 dbserver1 和 dbserver2 应用了`db::server`类，随后通过应用`db::client`类将它们收集到 cookbook 中。主机条目被放置在`/etc/hosts`中（默认文件）。我们可以看到，主机条目包含了 dbserver1 和 dbserver2 的 fqdn 和简短主机名。

## 还有更多...

以这种方式使用导出资源非常有用。另一个类似的系统是创建一个 NFS 服务器类，生成它导出的挂载点的导出资源（通过 NFS）。然后你可以使用标签让客户端收集服务器的适当挂载点。在前面的例子中，我们利用了一个标签来帮助我们收集导出资源。值得注意的是，当资源被创建时，会自动添加几个标签，其中一个是资源创建的作用域。

# 使用多个文件源

Puppet `file` 资源的一个优点是可以为 `source` 参数指定多个值。Puppet 会按顺序进行查找。如果找不到第一个源，它会继续查找下一个，以此类推。你可以利用这一点指定默认替代文件，或者甚至指定一系列逐渐通用的替代文件。

## 如何实现……

本示例展示了如何使用多个文件源：

1.  按如下方式创建一个新的问候模块：

    ```
    class greeting {
      file { '/tmp/greeting':
        source => [ 'puppet:///modules/greeting/hello.txt',
                    'puppet:///modules/greeting/universal.txt'],
      }
    }
    ```

1.  创建文件 `modules/greeting/files/hello.txt`，内容如下：

    ```
    Hello, world.
    ```

1.  创建文件 `modules/greeting/files/universal.txt`，内容如下：

    ```
    Bah-weep-Graaaaagnah wheep ni ni bong
    ```

1.  将类添加到节点：

    ```
    node cookbook {
      class {'greeting': }
    }
    ```

1.  运行 Puppet：

    ```
    [root@cookbook ~]# puppet agent -t
    Info: Caching catalog for cookbook.example.com
    Info: Applying configuration version '1413784347'
    Notice: /Stage[main]/Greeting/File[/tmp/greeting]/ensure: defined content as '{md5}54098b367d2e87b078671fad4afb9dbb'
    Notice: Finished catalog run in 0.43 seconds

    ```

1.  检查 `/tmp/greeting` 文件的内容：

    ```
    [root@cookbook ~]# cat /tmp/greeting 
    Hello, world.

    ```

1.  现在，从 Puppet 仓库中移除 `hello.txt` 文件，并重新运行代理：

    ```
    [root@cookbook ~]# puppet agent -t
    Info: Caching catalog for cookbook.example.com
    Info: Applying configuration version '1413784939'
    Notice: /Stage[main]/Greeting/File[/tmp/greeting]/content: 
    --- /tmp/greeting	2014-10-20 01:52:28.117999991 -0400
    +++ /tmp/puppet-file20141020-4960-1o9g344-0	2014-10-20 02:02:20.695999979 -0400
    @@ -1 +1 @@
    -Hello, world.
    +Bah-weep-Graaaaagnah wheep ni ni bong

    Info: Computing checksum on file /tmp/greeting
    Info: /Stage[main]/Greeting/File[/tmp/greeting]: Filebucketed /tmp/greeting to puppet with sum 54098b367d2e87b078671fad4afb9dbb
    Notice: /Stage[main]/Greeting/File[/tmp/greeting]/content: content changed '{md5}54098b367d2e87b078671fad4afb9dbb' to '{md5}933c7f04d501b45456e830de299b5521'
    Notice: Finished catalog run in 0.77 seconds

    ```

## 它是如何工作的……

在第一次运行 Puppet 时，Puppet 按照给定的顺序搜索可用的文件源：

```
source => [
  'puppet:///modules/greeting/hello.txt',
  'puppet:///modules/greeting/universal.txt'
],
```

`hello.txt` 文件位于列表的第一位，并且存在，因此 Puppet 使用该文件作为 `/tmp/greeting` 的来源：

```
Hello, world.
```

在第二次运行 Puppet 时，`hello.txt` 缺失，因此 Puppet 会继续查找下一个文件 `universal.txt`。该文件存在，因此它成为 `/tmp/greeting` 的来源：

```
Bah-weep-Graaaaagnah wheep ni ni bong
```

## 还有更多……

你可以在任何使用 `file` 资源的地方使用这个技巧。一个常见的例子是部署在所有节点上的服务，如 rsyslog。除了 rsyslog 服务器外，所有主机的 `rsyslog` 配置都是相同的。创建一个包含 `rsyslog` 配置文件的 `rsyslog` 类并使用 `file` 资源：

```
class rsyslog {
  file { '/etc/rsyslog.conf':
    source => [
      "puppet:///modules/rsyslog/rsyslog.conf.${::hostname}",
      'puppet:///modules/rsyslog/rsyslog.conf' ],
  }
```

然后，你将默认配置放入 `rsyslog.conf` 中。对于你的 rsyslog 服务器 `logger`，创建一个 `rsyslog.conf.logger` 文件。在机器 `logger` 上，`rsyslog.conf.logger` 会先于 `rsyslog.conf` 被使用，因为它在文件源数组中的顺序靠前。

## 另见：

+   第三章中的*向类传递参数*配方，*编写更好的清单*

# 分发和合并目录树

如我们在上一章所见，文件资源具有 `recurse` 参数，这使得 Puppet 可以传输整个目录树。我们使用此参数将管理员用户的点文件复制到他们的主目录。在本节中，我们将展示如何使用 `recurse` 和另一个参数 `sourceselect` 来扩展我们之前的示例。

## 如何实现……

如下修改我们的管理员用户示例：

1.  移除 `$dotfiles` 参数，删除基于 `$dotfiles` 的条件。向主目录 `file` 资源添加第二个源：

    ```
    define admin_user ($key, $keytype) { 
     $username = $name
     user { $username:
     ensure     => present,
     }
     file { "/home/${username}/.ssh":
     ensure  => directory,
     mode    => '0700',
     owner   => $username,
     group   => $username,
     require => File["/home/${username}"],
     }
     ssh_authorized_key { "${username}_key":
     key     => $key,
     type    => "$keytype",
     user    => $username,
     require => File["/home/${username}/.ssh"],
     }
     # copy in all the files in the subdirectory
     file { "/home/${username}":
     recurse => true,
     mode    => '0700',
     owner   => $username,
     group   => $username,
     source  => [
     "puppet:///modules/admin_user/${username}",
     'puppet:///modules/admin_user/base' ],
     sourceselect => 'all',
     require      => User["$username"],
     }
    }

    ```

1.  创建一个基础目录并从 `/etc/skel` 复制所有系统默认文件：

    ```
    t@mylaptop ~/puppet/modules/admin_user/files $ cp -a /etc/skel base

    ```

1.  创建一个新的 `admin_user` 资源，定义时不包括目录：

    ```
    node 'cookbook' {
      admin_user {'steven':
        key     => 'AAAAB3N...',
        keytype => 'dsa',
      }
    }
    ```

1.  运行 Puppet：

    ```
    [root@cookbook ~]# puppet agent -t
    Info: Caching catalog for cookbook.example.com
    Info: Applying configuration version '1413787159'
    Notice: /Stage[main]/Main/Node[cookbook]/Admin_user[steven]/User[steven]/ensure: created
    Notice: /Stage[main]/Main/Node[cookbook]/Admin_user[steven]/File[/home/steven]/ensure: created
    Notice: /Stage[main]/Main/Node[cookbook]/Admin_user[steven]/File[/home/steven/.bash_logout]/ensure: defined content as '{md5}6a5bc1cc5f80a48b540bc09d082b5855'
    Notice: /Stage[main]/Main/Node[cookbook]/Admin_user[steven]/File[/home/steven/.emacs]/ensure: defined content as '{md5}de7ee35f4058681a834a99b5d1b048b3'
    Notice: /Stage[main]/Main/Node[cookbook]/Admin_user[steven]/File[/home/steven/.bashrc]/ensure: defined content as '{md5}2f8222b4f275c4f18e69c34f66d2631b'
    Notice: /Stage[main]/Main/Node[cookbook]/Admin_user[steven]/File[/home/steven/.bash_profile]/ensure: defined content as '{md5}f939eb71a81a9da364410b799e817202'
    Notice: /Stage[main]/Main/Node[cookbook]/Admin_user[steven]/File[/home/steven/.ssh]/ensure: created
    Notice: /Stage[main]/Main/Node[cookbook]/Admin_user[steven]/Ssh_authorized_key[steven_key]/ensure: created
    Notice: Finished catalog run in 1.11 seconds

    ```

## 它是如何工作的……

如果 `file` 资源设置了 `recurse` 参数，并且它是一个目录，Puppet 不仅会部署该目录本身，还会部署它的所有内容（包括子目录及其内容）。正如我们在之前的例子中看到的，当文件有多个来源时，找到的第一个源文件将用于满足请求。这也适用于目录。

## 还有更多...

通过将参数 `sourceselect` 设置为 'all'，所有源目录的内容将会合并。例如，将 `thomas admin_user` 添加回你的节点定义 `site.pp` 中的 cookbook：

```
admin_user {'thomas':
    key     => 'ABBA...',
    keytype => 'rsa',
  }
```

现在再运行 Puppet 来更新 cookbook：

```
[root@cookbook thomas]# puppet agent -t
Info: Caching catalog for cookbook.example.com
Info: Applying configuration version '1413787770'
Notice: /Stage[main]/Main/Node[cookbook]/Admin_user[thomas]/File[/home/thomas/.bash_profile]/content: content changed '{md5}3e8337f44f84b298a8a99869ae8ca76a' to '{md5}f939eb71a81a9da364410b799e817202'
Notice: /Stage[main]/Main/Node[cookbook]/Admin_user[thomas]/File[/home/thomas/.bash_profile]/group: group changed 'root' to 'thomas'
Notice: /Stage[main]/Main/Node[cookbook]/Admin_user[thomas]/File[/home/thomas/.bash_profile]/mode: mode changed '0644' to '0700'
Notice: /File[/home/thomas/.bash_profile]/seluser: seluser changed 'system_u' to 'unconfined_u'
Notice: /Stage[main]/Main/Node[cookbook]/Admin_user[thomas]/File[/home/thomas/.bash_logout]/ensure: defined content as '{md5}6a5bc1cc5f80a48b540bc09d082b5855'
Notice: /Stage[main]/Main/Node[cookbook]/Admin_user[thomas]/File[/home/thomas/.bashrc]/content: content changed '{md5}db2a20b2b9cdf36cca1ca4672622ddd2' to '{md5}033c3484e4b276e0641becc3aa268a3a'
Notice: /Stage[main]/Main/Node[cookbook]/Admin_user[thomas]/File[/home/thomas/.bashrc]/group: group changed 'root' to 'thomas'
Notice: /Stage[main]/Main/Node[cookbook]/Admin_user[thomas]/File[/home/thomas/.bashrc]/mode: mode changed '0644' to '0700'
Notice: /File[/home/thomas/.bashrc]/seluser: seluser changed 'system_u' to 'unconfined_u'
Notice: /Stage[main]/Main/Node[cookbook]/Admin_user[thomas]/File[/home/thomas/.emacs]/ensure: defined content as '{md5}de7ee35f4058681a834a99b5d1b048b3'
Notice: Finished catalog run in 0.86 seconds

```

因为我们之前在 cookbook 中应用了 `thomas admin_user`，所以该用户已存在。在 Puppet 服务器上的 `thomas` 目录中定义的两个文件已经存在于主目录中，因此只创建了额外的文件 `.bash_logout`、`.bash_profile` 和 `.emacs`。使用这两个参数，你可以拥有可以轻松覆盖的默认文件。

有时候，你可能希望将文件部署到现有目录中，但移除任何不是由 Puppet 管理的文件。一个好的例子是，如果你在环境中使用 `mcollective`。存放客户端凭证的目录应只包含来自 Puppet 的证书。

`purge` 参数可以为你完成这个任务。将目录定义为 Puppet 中的资源：

```
file { '/etc/mcollective/ssl/clients':
  purge   => true,
  recurse => true,
}
```

`recurse` 和 `purge` 的组合将移除 `/etc/mcollective/ssl/clients` 中所有不是由 Puppet 部署的文件和子目录。然后，你可以通过将文件放置在 Puppet 服务器的适当目录中，将自己的文件部署到该位置。

如果有子目录包含你不想清理的文件，只需将该子目录定义为 Puppet 资源，它将被忽略：

```
file { '/etc/mcollective/ssl/clients':
  purge => true,
  recurse => true,
}
file { '/etc/mcollective/ssl/clients/local':
  ensure => directory,
}
```

### 注意

请注意，至少在当前的 Puppet 实现中，递归文件复制可能会非常慢，并且会给服务器带来较重的内存负载。如果数据不经常变化，最好还是部署并解压一个 `tar` 文件。可以通过文件资源来管理 `tar` 文件，并使用 exec 来解压归档文件。对于包含小文件的递归目录，问题不大。Puppet 并不是一个高效的文件服务器，所以使用 Puppet 来创建并分发大型 tar 文件并不是一个好主意。如果你需要复制大文件，使用操作系统的打包工具是更好的解决方案。

# 清理旧文件

Puppet 的 `tidy` 资源将帮助你清理旧的或过时的文件，从而减少磁盘使用量。例如，如果你启用了 Puppet 报告功能，如生成报告部分所述，你可能希望定期删除旧的报告文件。

## 如何操作...

开始吧。

1.  按如下方式修改你的 `site.pp` 文件：

    ```
    node 'cookbook' {
      tidy { '/var/lib/puppet/reports':
        age     => '1w',
        recurse => true,
      }
    }
    ```

1.  运行 Puppet：

    ```
    [root@cookbook clients]# puppet agent -t
    Info: Caching catalog for cookbook.example.com
    Notice: /Stage[main]/Main/Node[cookbook]/File[/var/lib/puppet/reports/cookbook.example.com/201409090637.yaml]/ensure: removed
    Notice: /Stage[main]/Main/Node[cookbook]/File[/var/lib/puppet/reports/cookbook.example.com/201409100556.yaml]/ensure: removed
    Notice: /Stage[main]/Main/Node[cookbook]/File[/var/lib/puppet/reports/cookbook.example.com/201409090631.yaml]/ensure: removed
    Notice: /Stage[main]/Main/Node[cookbook]/File[/var/lib/puppet/reports/cookbook.example.com/201408210557.yaml]/ensure: removed
    Notice: /Stage[main]/Main/Node[cookbook]/File[/var/lib/puppet/reports/cookbook.example.com/201409080557.yaml]/ensure: removed
    Notice: /Stage[main]/Main/Node[cookbook]/File[/var/lib/puppet/reports/cookbook.example.com/201409100558.yaml]/ensure: removed
    Notice: /Stage[main]/Main/Node[cookbook]/File[/var/lib/puppet/reports/cookbook.example.com/201408210546.yaml]/ensure: removed
    Notice: /Stage[main]/Main/Node[cookbook]/File[/var/lib/puppet/reports/cookbook.example.com/201408210539.yaml]/ensure: removed
    Notice: Finished catalog run in 0.80 seconds

    ```

## 它是如何工作的...

Puppet 会在指定路径中搜索任何符合 `age` 参数的文件；在此情况下为 `2w`（两周）。它还会搜索子目录（`recurse => true`）。

所有符合你标准的文件将被删除。

## 还有更多…

你可以通过使用一个字符来指定时间单位（秒、分钟、小时、天或周），如下所示：

+   `60s`

+   `180m`

+   `24h`

+   `30d`

+   `4w`

你可以指定删除大于某个大小的文件，方式如下：

```
size => '100m',
```

这将删除大于或等于 100 MB 的文件。对于千字节，使用 `k`，对于字节，使用 `b`。

### 注意

请注意，如果你同时指定了年龄和大小参数，它们会被视为独立的标准。例如，如果你指定以下内容，Puppet 将删除所有至少一天前的文件，或者至少 512 KB 大小的文件：

age => "1d",

size => "512k",

# 审计资源

使用 `--noop` 开关的干运行模式，是一种简单的方式来审计 Puppet 控制下的机器上的任何更改。然而，Puppet 也有一个专门的审计功能，可以报告资源或特定属性的更改。

## 如何操作…

这是一个展示 Puppet 审计功能的示例：

1.  按照如下方式修改你的 `site.pp` 文件：

    ```
    node 'cookbook' {
      file { '/etc/passwd':
        audit => [ owner, mode ],
      }
    }
    ```

1.  运行 Puppet：

    ```
    [root@cookbook clients]# puppet agent -t
    Info: Caching catalog for cookbook.example.com
    Info: Applying configuration version '1413789080'
    Notice: /Stage[main]/Main/Node[cookbook]/File[/etc/passwd]/owner: audit change: newly-recorded value 0
    Notice: /Stage[main]/Main/Node[cookbook]/File[/etc/passwd]/mode: audit change: newly-recorded value 644
    Notice: Finished catalog run in 0.55 seconds

    ```

## 它是如何工作的…

`audit` 元参数告诉 Puppet 你希望记录和监控资源的某些内容。该值可以是你想要审计的参数列表。

在这种情况下，当 Puppet 运行时，它将记录 `/etc/passwd` 文件的所有者和权限。在未来的运行中，Puppet 会检查这两个内容是否发生了变化。例如，如果你运行：

```
[root@cookbook ~]# chmod 666 /etc/passwd

```

Puppet 会在下次运行时捕获这个更改并记录下来：

```
Notice: /Stage[main]/Main/Node[cookbook]/File[/etc/passwd]/mode: audit change: previously recorded value 0644 has been changed to 0666

```

## 还有更多…

这个功能非常有用，可以用来审计大规模网络中机器的任何变化，无论是恶意的还是意外的。它还非常方便用于监控那些不受 Puppet 管理的内容，例如生产服务器上的应用程序代码。你可以在这里了解更多关于 Puppet 审计功能的信息：

[`puppetlabs.com/blog/all-about-auditing-with-puppet/`](http://puppetlabs.com/blog/all-about-auditing-with-puppet/)

如果你只是想审计某个资源的所有内容，可以使用 `all`：

```
file { '/etc/passwd':
  audit => all,
}
```

## 另请参见

+   *无操作 - 不改变任何设置* 配方见 第十章，*监控、报告和故障排除*

# 临时禁用资源

有时候你可能希望暂时禁用一个资源，以免它干扰到其他工作。例如，你可能想在将配置文件推送到 Puppet 之前，在服务器上调整配置，直到你得到确切的设置。你不希望 Puppet 在此期间用旧版本覆盖它，所以你可以在该资源上设置 `noop` 元参数：

```
noop => true,
```

## 如何操作…

这个示例展示了如何使用 `noop` 元参数：

1.  按照如下方式修改你的 `site.pp` 文件：

    ```
    node 'cookbook' {
      file { '/etc/resolv.conf':
        content => "nameserver 127.0.0.1\n",
        noop    => true,
      }
    }
    ```

1.  运行 Puppet：

    ```
    [root@cookbook ~]# puppet agent -t
    Info: Caching catalog for cookbook.example.com
    Info: Applying configuration version '1413789438'
    Notice: /Stage[main]/Main/Node[cookbook]/File[/etc/resolv.conf]/content: 
    --- /etc/resolv.conf  2014-10-20 00:27:43.095999975 -0400
    +++ /tmp/puppet-file20141020-8439-1lhuy1y-0	2014-10-20 03:17:18.969999979 -0400
    @@ -1,3 +1 @@ 
    -; generated by /sbin/dhclient-script
    -search example.com
    -nameserver 192.168.122.1
    +nameserver 127.0.0.1

    Notice: /Stage[main]/Main/Node[cookbook]/File[/etc/resolv.conf]/content: current_value {md5}4c0d192511df253826d302bc830a371b, should be {md5}949343428bded6a653a85910f6bdb48e (noop)
    Notice: Node[cookbook]: Would have triggered 'refresh' from 1 events
    Notice: Class[Main]: Would have triggered 'refresh' from 1 events
    Notice: Stage[main]: Would have triggered 'refresh' from 1 events
    Notice: Finished catalog run in 0.50 seconds

    ```

## 它是如何工作的…

`noop` 元参数设置为 `true`，因此对于这个特定的资源，它就像你需要用 `--noop` 标志运行 Puppet 一样。Puppet 注意到该资源本来会被应用，但实际上什么都没有做。

在测试模式下运行代理（`-t`）的一个好处是，Puppet 会输出如果没有 `noop` 的话，它会执行的差异（你可以通过 `--show_diff` 在不使用 `-t` 的情况下让 Puppet 显示差异；`-t` 涉及许多不同的设置）：

```
--- /etc/resolv.conf  2014-10-20 00:27:43.095999975 -0400
+++ /tmp/puppet-file20141020-8439-1lhuy1y-0	2014-10-20 03:17:18.969999979 -0400
@@ -1,3 +1 @@
-; generated by /sbin/dhclient-script
-search example.com
-nameserver 192.168.122.1
+nameserver 127.0.0.1

```

这在调试模板时非常有用；你可以在不实际应用更改的情况下，先进行修改，然后查看它们在节点上会是什么样子。通过查看差异，你可以判断更新后的模板是否产生了正确的输出。
