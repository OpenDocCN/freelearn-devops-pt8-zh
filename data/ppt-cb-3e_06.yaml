- en: Chapter 6. Managing Resources and Files
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章：资源和文件管理
- en: '|   | *"The art of simplicity is a puzzle of complexity".* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"简单的艺术是复杂的谜题"* |   |'
- en: '|   | --Douglas Horton |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --道格拉斯·霍顿 |'
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Distributing cron jobs efficiently
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效分配 cron 作业
- en: Scheduling when resources are applied
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源应用的调度
- en: Using host resources
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用主机资源
- en: Using exported host resources
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用导出的主机资源
- en: Using multiple file sources
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个文件来源
- en: Distributing and merging directory trees
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配和合并目录树
- en: Cleaning up old files
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理旧文件
- en: Auditing resources
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审计资源
- en: Temporarily disabling resources
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时禁用资源
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we introduced virtual and exported resources. Virtual
    and exported resources are ways to manage the way in which resources are applied
    to a node. In this chapter, we will deal with when and how to apply resources.
    In some cases, you may only wish to apply a resource off hours, while in others,
    you may wish to only audit the resource but change nothing. In other cases, you
    may wish to apply completely different resources based on which node is using
    the code. As we will see, Puppet has the flexibility to deal with all these scenarios.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了虚拟资源和导出资源。虚拟资源和导出资源是管理资源如何应用到节点的一种方式。在本章中，我们将讨论何时以及如何应用资源。在某些情况下，您可能只希望在非工作时间应用资源，而在其他情况下，您可能希望只审计资源但不做任何更改。在其他情况下，您可能希望根据使用代码的节点应用完全不同的资源。正如我们将看到的，Puppet
    有足够的灵活性来处理所有这些场景。
- en: Distributing cron jobs efficiently
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效分配 cron 作业
- en: When you have many servers executing the same cron job, it's usually a good
    idea not to run them all at the same time. If all the jobs access a common server
    (for example, when running backups), it may put too much load on that server,
    and even if they don't, all the servers will be busy at the same time, which may
    affect their capacity to provide other services.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有许多服务器执行相同的 cron 作业时，通常最好不要让它们同时运行。如果所有作业都访问一个共同的服务器（例如，执行备份时），这可能会给该服务器带来过大的负载，即使它们没有同时访问，所有服务器同时忙碌也可能会影响它们提供其他服务的能力。
- en: As usual, Puppet can help; this time, using the `inline_template` function to
    calculate a unique time for each job.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，Puppet 可以提供帮助；这次，我们使用 `inline_template` 函数来为每个作业计算一个唯一的时间。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Here''s how to have Puppet schedule the same job at a different time for each
    machine:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何让 Puppet 为每台机器在不同时间安排相同作业的方法：
- en: 'Modify your `site.pp` file as follows:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改你的 `site.pp` 文件，如下所示：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Run Puppet:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Puppet：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Run `crontab` to see how the job has been configured:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `crontab` 查看作业配置：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We want to distribute the hour of the cron job runs across all our nodes. We
    choose something that is unique across all the machines and convert it to a number.
    This way, the value will be distributed across the nodes and will not change per
    node.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将 cron 作业的执行时间分配到所有节点上。我们选择一个在所有机器上唯一的值，并将其转换为数字。这样，值将在节点之间分布，并且每个节点的值不会变化。
- en: We can do the conversion using Ruby's `sum` method, which computes a numerical
    value from a string that is unique to the machine (in this case, the machine's
    hostname). The `sum` function will generate a large integer (in the case of the
    string `cookbook`, the sum is 855), and we want values for `hour` between 0 and
    23, so we use Ruby's `%` (modulo) operator to restrict the result to this range.
    We should get a reasonably good (though not statistically uniform) distribution
    of values, depending on your hostnames. Another option here is to use the `fqdn_rand()`
    function, which works in much the same way as our example.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Ruby 的 `sum` 方法来进行转换，该方法从一个唯一于机器的字符串（在此例中是机器的主机名）计算出一个数值。`sum` 函数会生成一个大整数（例如，字符串
    `cookbook` 的和为 855），而我们希望 `hour` 的值在 0 到 23 之间，因此我们使用 Ruby 的 `%`（取模）运算符将结果限制在这个范围内。根据主机名的不同，我们应该能得到一个合理的（尽管不是统计学上均匀的）值分布。这里的另一个选择是使用
    `fqdn_rand()` 函数，它的工作方式与我们的示例类似。
- en: If all your machines have the same name (it does happen), don't expect this
    trick to work! In this case, you can use some other string that is unique to the
    machine, such as `ipaddress` or `fqdn`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有机器都有相同的名称（确实会发生），不要指望这个技巧能奏效！在这种情况下，你可以使用其他在机器上唯一的字符串，比如 `ipaddress` 或 `fqdn`。
- en: There's more...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you have several cron jobs per machine and you want to run them a certain
    number of hours apart, add this number to the `hostname.sum` resource before taking
    the modulus. Let''s say we want to run the `dump_database` job at some arbitrary
    time and the `run_backup` job an hour later, this can be done using the following
    code snippet:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每台机器上有多个 cron 任务，并且你希望它们相隔特定的小时数执行，可以在 `hostname.sum` 资源中添加此数字，然后取模。假设我们想在某个任意时间运行
    `dump_database` 任务，并在一小时后运行 `run_backup` 任务，可以使用以下代码片段实现：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The two jobs will end up with different `hour` values for each machine Puppet
    runs on, but `run_backup` will always be one hour after `dump_database`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个任务将导致每台运行 Puppet 的机器有不同的 `hour` 值，但 `run_backup` 总是会在 `dump_database` 后一小时执行。
- en: 'Most cron implementations have directories for hourly, daily, weekly, and monthly
    tasks. The directories `/etc/cron.hourly`, `/etc/cron.daily`, `/etc/cron.weekly`,
    and `/etc/cron.monthly` exist on both our Debian and Enterprise Linux machines.
    These directories hold executables, which will be run on the referenced schedule
    (hourly, daily, weekly, or monthly). I find it better to describe all the jobs
    in these folders and push the jobs as `file` resources. An admin on the box searching
    for your script will be able to find it with `grep` in these directories. To use
    the same trick here, we would push a cron task into `/etc/cron.hourly` and then
    verify that the hour is the correct hour for the task to run. To create the cron
    jobs using the cron directories, follow these steps:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 cron 实现都包含了用于每小时、每天、每周和每月任务的目录。目录 `/etc/cron.hourly`、`/etc/cron.daily`、`/etc/cron.weekly`
    和 `/etc/cron.monthly` 在我们的 Debian 和 Enterprise Linux 机器上都有。这些目录包含可执行文件，它们会根据参考的调度（每小时、每天、每周或每月）执行。我发现最好将这些文件夹中的所有任务描述清楚，并将任务作为
    `file` 资源推送。盒子上的管理员可以通过在这些目录中使用 `grep` 查找你的脚本。为了在这里使用相同的技巧，我们可以将 cron 任务推送到 `/etc/cron.hourly`，然后验证这个小时是否是任务执行的正确时间。要使用
    cron 目录创建 cron 任务，按照以下步骤操作：
- en: 'First, create a `cron` class in `modules/cron/init.pp`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 `modules/cron/init.pp` 中创建一个 `cron` 类：
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Include the `cron` class in your cookbook node in `site.pp`:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `site.pp` 中的烹饪书节点中包含 `cron` 类：
- en: '[PRE5]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a template to hold the cron task:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个模板来保存 cron 任务：
- en: '[PRE6]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, run Puppet:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，运行 Puppet：
- en: '[PRE7]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Verify that the script has the same value we calculated before, `15`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证脚本的值是否与我们之前计算的 `15` 相同：
- en: '[PRE8]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, this job will run every hour but only when the hour, returned by `$(date
    +%H)`, is equal to `15` will the rest of the script run. Creating your cron jobs
    as file resources in a large organization makes it easier for your fellow administrators
    to find them. When you have a very large number of machines, it can be advantageous
    to add another random wait at the beginning of your job. You would need to modify
    the line before `echo run-backup` and add the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个任务将每小时运行，但只有当 `$(date +%H)` 返回的小时等于 `15` 时，脚本的其他部分才会执行。将 cron 任务作为文件资源创建在大型组织中，可以让其他管理员更容易找到它们。当你的机器数量非常庞大时，在任务开始时添加另一个随机等待时间可能会有好处。你需要修改
    `echo run-backup` 之前的那一行，添加以下内容：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will sleep a maximum of `600` seconds but will sleep a different amount
    each time it runs (assuming your random number generator is working). This sort
    of random wait is useful when you have thousands of machines, all running the
    same task and you need to stagger the runs as much as possible.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这将最多等待 `600` 秒，但每次运行时等待的时间不同（假设你的随机数生成器工作正常）。这种随机等待在你有成千上万台机器运行相同任务时非常有用，尤其是当你需要尽可能分散任务的运行时。
- en: See also
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Running Puppet from cron* recipe in [Chapter 2](ch02.html "Chapter 2. Puppet
    Infrastructure"), *Puppet Infrastructure*
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](ch02.html "第二章：Puppet基础设施")中的 *从 cron 运行 Puppet* 方案，*Puppet基础设施*'
- en: Scheduling when resources are applied
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度资源应用的时间
- en: 'So far, we looked at what Puppet can do, and the order that it does things
    in, but not when it does them. One way to control this is to use the `schedule`
    metaparameter. When you need to limit the number of times a resource is applied
    within a specified period, `schedule` can help. For example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们查看了 Puppet 可以做什么，以及它做事情的顺序，但没有查看它做事的时间。控制这一点的一种方法是使用 `schedule` 元参数。当你需要限制某个资源在指定时间段内应用的次数时，`schedule`
    可以提供帮助。例如：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The most important thing to understand about `schedule` is that it can only
    stop a resource being applied. It doesn't guarantee that the resource will be
    applied with a certain frequency. For example, the `exec` resource shown in the
    preceding code snippet has `schedule => daily`, but this just represents an upper
    limit on the number of times the `exec` resource can run per day. It won't be
    applied more than once a day. If you don't run Puppet at all, the resource won't
    be applied at all. Using the hourly schedule, for instance, is meaningless on
    a machine configured to run the agent every 4 hours (via the `runinterval` configuration
    setting).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 `schedule` 最重要的一点是，它只能阻止资源的应用。它不能保证资源以特定的频率被应用。例如，前面代码片段中显示的 `exec` 资源设置了
    `schedule => daily`，但这只是表示 `exec` 资源每天可以运行的最大次数。它不会每天运行超过一次。如果你根本没有运行 Puppet，那么资源将完全不被应用。例如，在配置为每
    4 小时运行一次代理（通过 `runinterval` 配置设置）的机器上，使用每小时计划是没有意义的。
- en: 'That being said, `schedule` is best used to restrict resources from running
    when they shouldn''t, or don''t need to; for example, you might want to make sure
    that `apt-get update` isn''t run more than once an hour. There are some built-in
    schedules available for you to use:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，`schedule` 最好用于限制在不应该运行或不需要运行时阻止资源运行；例如，你可能希望确保 `apt-get update` 不会在一个小时内运行超过一次。你可以使用一些内置的计划：
- en: '`hourly`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hourly`'
- en: '`daily`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`daily`'
- en: '`weekly`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weekly`'
- en: '`monthly`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`monthly`'
- en: '`never`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`never`'
- en: However, you can modify these and create your own custom schedules, using the
    `schedule` resource. We'll see how to do this in the following example. Let's
    say we want to make sure that an `exec` resource representing a maintenance job
    won't run during office hours, when it might interfere with production.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以修改这些并创建你自己的自定义计划，使用 `schedule` 资源。我们将在以下示例中看到如何操作。假设我们希望确保一个表示维护作业的 `exec`
    资源在办公时间内不会运行，因为它可能会干扰生产。
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this example, we''ll create a custom `schedule` resource and assign this
    to the resource:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个自定义的 `schedule` 资源，并将其分配给该资源：
- en: 'Modify your `site.pp` file as follows:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式修改你的 `site.pp` 文件：
- en: '[PRE11]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Run Puppet. What you''ll see will depend on the time of the day. If it''s currently
    outside the office hours period you defined, Puppet will apply the resource as
    follows:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Puppet。你看到的结果将取决于当天的时间。如果现在是在你定义的办公时间之外，Puppet 会按如下方式应用资源：
- en: '[PRE12]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the time is within the office hours period, Puppet will do nothing:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果时间在办公时间内，Puppet 将不会做任何操作：
- en: '[PRE13]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A schedule consists of three bits of information:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一个计划由三部分信息组成：
- en: The `period` (`hourly`, `daily`, `weekly`, or `monthly`)
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`period`（`hourly`、`daily`、`weekly` 或 `monthly`）'
- en: The `range` (defaults to the whole period, but can be a smaller part of it)
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`range`（默认为整个时间段，但可以是其较小的一部分）'
- en: The `repeat` count (how often the resource is allowed to be applied within the
    range; the default is 1 or once per period)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repeat` 次数（在范围内允许应用资源的频率；默认为 1 或每个周期一次）'
- en: 'Our custom schedule named `outside-office-hours` supplies these three parameters:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自定义计划 `outside-office-hours` 提供了这三项参数：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `period` is `daily`, and `range` is defined as an array of two time intervals:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`period` 是 `daily`，`range` 被定义为一个由两个时间间隔组成的数组：'
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The schedule named `outside-office-hours` is now available for us to use with
    any resource, just as though it were built into Puppet such as the `daily` or
    `hourly` schedules. In our example, we assign this schedule to the `exec` resource
    using the `schedule` metaparameter:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用名为 `outside-office-hours` 的计划，它就像 `daily` 或 `hourly` 计划一样，可以与任何资源一起使用。在我们的示例中，我们通过
    `schedule` 元参数将此计划分配给 `exec` 资源：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Without this `schedule` parameter, the resource would be applied every time
    Puppet runs. With it, Puppet will check the following parameters to decide whether
    or not to apply the resource:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有这个 `schedule` 参数，资源将在每次运行 Puppet 时都被应用。使用此参数后，Puppet 会检查以下参数，以决定是否应用该资源：
- en: Whether the time is in the permitted range
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否时间在允许的范围内
- en: Whether the resource has already been run the maximum permitted number of times
    in this period
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否资源在此期间已经运行了最大允许次数
- en: 'For example, let''s consider what happens if Puppet runs at 4 p.m., 5 p.m.,
    and 6 p.m. on a given day:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们考虑在某一天的下午 4 点、5 点和 6 点 Puppet 会发生什么：
- en: '**4 p.m.**: It''s outside the permitted time range, so Puppet will do nothing'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**下午 4 点**：在允许的时间范围之外，因此 Puppet 什么也不做'
- en: '**5 p.m.**: It''s inside the permitted time range, and the resource hasn''t
    been run yet in this period, so Puppet will apply the resource'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**下午5点**：它在允许的时间范围内，并且在此期间资源尚未运行，因此 Puppet 会应用该资源'
- en: '**6 p.m.**: It''s inside the permitted time range, but the resource has already
    been run the maximum number of times in this period, so Puppet will do nothing'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**下午6点**：它在允许的时间范围内，但资源在此期间已运行最大次数，因此 Puppet 不会执行任何操作'
- en: And so on until the next day.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 依此类推，直到第二天。
- en: There's more...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `repeat` parameter governs how many times the resource will be applied
    given the other constraints of the schedule. For example, to apply a resource
    no more than six times an hour, use a schedule as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat` 参数控制在给定调度其他约束条件下资源会被应用多少次。例如，要使资源每小时最多应用六次，可以使用如下调度：'
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Remember that this won't guarantee that the job is run six times an hour. It
    just sets an upper limit; no matter how often Puppet runs or anything else happens,
    the job won't be run if it has already run six times this hour. If Puppet only
    runs once a day, the job will just be run once. So `schedule` is best used to
    make sure things don't happen at certain times (or don't exceed a given frequency).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这并不能保证作业每小时执行六次。它只是设置了一个上限；无论 Puppet 运行多频繁，或者其他任何事情发生，如果本小时已经运行过六次作业，它将不会再运行。如果
    Puppet 仅每天运行一次，该作业将只会执行一次。因此，`schedule` 最好用来确保某些操作不会在特定时间发生（或不会超过给定的频率）。
- en: Using host resources
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用主机资源
- en: It's not always practical or convenient to use DNS to map your machine names
    to IP addresses, especially in cloud infrastructures, where those addresses may
    change all the time. However, if you use entries in the `/etc/hosts` file instead,
    you then have the problem of how to distribute these entries to all machines and
    keep them up to date.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在云基础设施中，使用 DNS 将机器名称映射到 IP 地址并不总是实用或方便，特别是那些地址可能经常变化的情况。然而，如果你改为使用 `/etc/hosts`
    文件中的条目，那么你就会面临如何将这些条目分发到所有机器并保持更新的问题。
- en: Here's a better way to do it; Puppet's host resource type controls a single
    `/etc/hosts` entry, and you can use this to map a hostname to an IP address easily
    across your whole network. For example, if all your machines need to know the
    address of the main database server, you can manage it with a `host` resource.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个更好的方法；Puppet 的主机资源类型控制一个单独的 `/etc/hosts` 条目，你可以利用它轻松地将主机名映射到整个网络中的 IP 地址。例如，如果所有机器需要知道主数据库服务器的地址，你可以使用
    `host` 资源来管理它。
- en: How to do it...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to create an example `host` resource:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个示例 `host` 资源：
- en: 'Modify your `site.pp` file as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式修改你的 `site.pp` 文件：
- en: '[PRE18]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run Puppet:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Puppet：
- en: '[PRE19]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Puppet will check the `target` file (usually `/etc/hosts`) to see whether the
    host entry already exists, and if not, add it. If an entry for that hostname already
    exists with a different address, Puppet will change the address to match the manifest.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 将检查 `target` 文件（通常是 `/etc/hosts`），查看主机条目是否已经存在，如果不存在，则添加它。如果该主机名的条目已经存在但地址不同，Puppet
    将更改地址以匹配清单。
- en: There's more...
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Organizing your host resources into classes can be helpful. For example, you
    could put the host resources for all your DB servers into one class called `admin::dbhosts`,
    which is included by all web servers.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的主机资源组织成类别可能会很有帮助。例如，你可以将所有数据库服务器的主机资源放入一个名为 `admin::dbhosts` 的类别中，然后该类别被所有
    Web 服务器引用。
- en: 'Where machines may need to be defined in multiple classes (for example, a database
    server might also be a repository server), virtual resources can solve this problem.
    For example, you could define all your hosts as virtual in a single class:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当机器可能需要在多个类别中定义时（例如，数据库服务器也可能是一个仓库服务器），虚拟资源可以解决这个问题。例如，你可以在一个类别中将所有主机定义为虚拟：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You could then realize the hosts you need in the various classes:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在不同的类别中实现所需的主机：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using exported host resources
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用导出的主机资源
- en: In the previous example, we used the spaceship syntax to collect virtual host
    resources for hosts of type database or type web. You can use the same trick with
    exported resources. The advantage to using exported resources is that as you add
    more database servers, the collector syntax will automatically pull in the newly
    created exported host entries for those servers. This makes your `/etc/hosts`
    entries more dynamic.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了太空船语法来收集类型为数据库或网页的主机的虚拟主机资源。你可以使用相同的方法来处理导出资源。使用导出资源的好处是，随着你添加更多的数据库服务器，收集器语法会自动拉取新创建的服务器导出主机条目。这使得你的`/etc/hosts`条目更加动态。
- en: Getting ready
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using exported resources. If you haven't already done so, set up
    puppetdb and enable storeconfigs to use puppetdb as outlined in [Chapter 2](ch02.html
    "Chapter 2. Puppet Infrastructure"), *Puppet Infrastructure*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用导出的资源。如果你还没有做，设置好puppetdb并启用storeconfigs以按照[第2章](ch02.html "第2章。Puppet基础设施")的说明使用puppetdb，*Puppet基础设施*。
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In this example, we will configure database servers and clients to communicate
    with each other. We'll make use of exported resources to do the configuration.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将配置数据库服务器和客户端之间的通信。我们将利用导出资源进行配置。
- en: 'Create a new database module, `db`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的数据库模块，`db`：
- en: '[PRE22]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a new class for your database servers, `db::server`:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的数据库服务器创建一个新的类，`db::server`：
- en: '[PRE23]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a new class for your database clients:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的数据库客户端创建一个新的类：
- en: '[PRE24]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Apply the database server module to some nodes, in `site.pp`, for example:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据库服务器模块应用于某些节点，例如在`site.pp`中：
- en: '[PRE25]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Run Puppet on the nodes with the database server module to create the exported
    resources.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在带有数据库服务器模块的节点上运行Puppet，以创建导出资源。
- en: 'Apply the database client module to cookbook:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据库客户端模块应用于cookbook：
- en: '[PRE26]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run Puppet:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Puppet：
- en: '[PRE27]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Verify the host entries in `/etc/hosts`:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证`/etc/hosts`中的主机条目：
- en: '[PRE28]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the `db::server` class, we create an exported host resource:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在`db::server`类中，我们创建了一个导出的主机资源：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This resource uses the fully qualified domain name (`$::fqdn`) of the node on
    which it is applied. We also use the short hostname (`$::hostname`) as an alias
    of the node. Aliases are printed after `fqdn` in `/etc/hosts`. We use the node's
    `$::ipaddress` fact as the IP address for the host entry. Finally, we add a tag
    to the resource so that we can collect based on that tag later.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个资源使用应用所在节点的完全限定域名（`$::fqdn`）。我们还使用短主机名（`$::hostname`）作为该节点的别名。别名会在`fqdn`后面打印到`/etc/hosts`中。我们使用节点的`$::ipaddress`事实作为主机条目的IP地址。最后，我们为资源添加标签，以便以后根据该标签进行收集。
- en: The important thing to remember here is that if the ip address should change
    for the host, the exported resource will be updated, and nodes that collect the
    exported resource will update their host records accordingly.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要记住的关键点是，如果主机的IP地址发生变化，导出资源会更新，收集该导出资源的节点将相应更新它们的主机记录。
- en: 'We created a collector in `db::client`, which only collects exported host resources
    that have been tagged with `''db::server''`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`db::client`中创建了一个收集器，该收集器只收集已标记为`'db::server'`的导出主机资源：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We applied the `db::server` class for a couple of nodes, dbserver1 and dbserver2,
    which we then collected on cookbook by applying the `db::client` class. The host
    entries were placed in `/etc/hosts` (the default file). We can see that the host
    entry contains both the fqdn and the short hostname for dbserver1 and dbserver2.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为两个节点dbserver1和dbserver2应用了`db::server`类，随后通过应用`db::client`类将它们收集到cookbook中。主机条目被放置在`/etc/hosts`中（默认文件）。我们可以看到，主机条目包含了dbserver1和dbserver2的fqdn和简短主机名。
- en: There's more...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Using exported resources in this manner is very useful. Another similar system
    would be to create an NFS server class, which creates exported resources for the
    mount points that it exports (via NFS). You can then use tags to have clients
    collect the appropriate mount points from the server. In the previous example,
    we made use of a tag to aid in our collection of exported resources. It is worth
    noting that there are several tags automatically added to resources when they
    are created, one of which is the scope where the resource was created.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用导出资源非常有用。另一个类似的系统是创建一个NFS服务器类，生成它导出的挂载点的导出资源（通过NFS）。然后你可以使用标签让客户端收集服务器的适当挂载点。在前面的例子中，我们利用了一个标签来帮助我们收集导出资源。值得注意的是，当资源被创建时，会自动添加几个标签，其中一个是资源创建的作用域。
- en: Using multiple file sources
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多个文件源
- en: A neat feature of Puppet's `file` resource is that you can specify multiple
    values for the `source` parameter. Puppet will search them in order. If the first
    source isn't found, it moves on to the next, and so on. You can use this to specify
    a default substitute if the particular file isn't present, or even a series of
    increasingly generic substitutes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet `file` 资源的一个优点是可以为 `source` 参数指定多个值。Puppet 会按顺序进行查找。如果找不到第一个源，它会继续查找下一个，以此类推。你可以利用这一点指定默认替代文件，或者甚至指定一系列逐渐通用的替代文件。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'This example demonstrates using multiple file sources:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例展示了如何使用多个文件源：
- en: 'Create a new greeting module as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式创建一个新的问候模块：
- en: '[PRE31]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create the file `modules/greeting/files/hello.txt` with the following contents:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文件 `modules/greeting/files/hello.txt`，内容如下：
- en: '[PRE32]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create the file `modules/greeting/files/universal.txt` with the following contents:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文件 `modules/greeting/files/universal.txt`，内容如下：
- en: '[PRE33]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the class to a node:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类添加到节点：
- en: '[PRE34]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Run Puppet:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Puppet：
- en: '[PRE35]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Check the contents of the `/tmp/greeting` file:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 `/tmp/greeting` 文件的内容：
- en: '[PRE36]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now remove the `hello.txt` file from your Puppet repository and rerun the agent:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从 Puppet 仓库中移除 `hello.txt` 文件，并重新运行代理：
- en: '[PRE37]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'On the first Puppet run, puppet searches for the available file sources in
    the order given:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次运行 Puppet 时，Puppet 按照给定的顺序搜索可用的文件源：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The file `hello.txt` is first in the list, and is present, so Puppet uses that
    as the source for `/tmp/greeting`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`hello.txt` 文件位于列表的第一位，并且存在，因此 Puppet 使用该文件作为 `/tmp/greeting` 的来源：'
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'On the second Puppet run, `hello.txt` is missing, so Puppet goes on to look
    for the next file, `universal.txt`. This is present, so it becomes the source
    for `/tmp/greeting`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次运行 Puppet 时，`hello.txt` 缺失，因此 Puppet 会继续查找下一个文件 `universal.txt`。该文件存在，因此它成为
    `/tmp/greeting` 的来源：
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: There's more...
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'You can use this trick anywhere you have a `file` resource. A common example
    is a service that is deployed on all nodes, such as rsyslog. The `rsyslog` configuration
    is the same on every host except for the rsyslog server. Create an `rsyslog` class
    with a file resource for the `rsyslog` configuration file:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何使用 `file` 资源的地方使用这个技巧。一个常见的例子是部署在所有节点上的服务，如 rsyslog。除了 rsyslog 服务器外，所有主机的
    `rsyslog` 配置都是相同的。创建一个包含 `rsyslog` 配置文件的 `rsyslog` 类并使用 `file` 资源：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Then, you put the default configuration in `rsyslog.conf`. For your rsyslog
    server, `logger`, create an `rsyslog.conf.logger` file. On the machine logger,
    `rsyslog.conf.logger` will be used before `rsyslog.conf` because it is listed
    first in the array of sources.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将默认配置放入 `rsyslog.conf` 中。对于你的 rsyslog 服务器 `logger`，创建一个 `rsyslog.conf.logger`
    文件。在机器 `logger` 上，`rsyslog.conf.logger` 会先于 `rsyslog.conf` 被使用，因为它在文件源数组中的顺序靠前。
- en: See also
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见：
- en: The *Passing parameters to classes* recipe in [Chapter 3](ch03.html "Chapter 3. Writing
    Better Manifests"), *Writing Better Manifests*
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 3 章](ch03.html "第 3 章. 编写更好的清单")中的*向类传递参数*配方，*编写更好的清单*'
- en: Distributing and merging directory trees
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分发和合并目录树
- en: As we saw in the previous chapter, the file resource has a `recurse` parameter,
    which allows Puppet to transfer entire directory trees. We used this parameter
    to copy an admin user's dotfiles into their home directory. In this section, we'll
    show how to use `recurse` and another parameter `sourceselect` to extend our previous
    example.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上一章所见，文件资源具有 `recurse` 参数，这使得 Puppet 可以传输整个目录树。我们使用此参数将管理员用户的点文件复制到他们的主目录。在本节中，我们将展示如何使用
    `recurse` 和另一个参数 `sourceselect` 来扩展我们之前的示例。
- en: How to do it...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'Modify our admin user example as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如下修改我们的管理员用户示例：
- en: 'Remove the `$dotfiles` parameter, remove the condition based on `$dotfiles`.
    Add a second source to the home directory `file` resource:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除 `$dotfiles` 参数，删除基于 `$dotfiles` 的条件。向主目录 `file` 资源添加第二个源：
- en: '[PRE42]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create a base directory and copy all the system default files from `/etc/skel`:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基础目录并从 `/etc/skel` 复制所有系统默认文件：
- en: '[PRE43]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create a new `admin_user` resource, one that will not have a directory defined:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `admin_user` 资源，定义时不包括目录：
- en: '[PRE44]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Run Puppet:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Puppet：
- en: '[PRE45]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: If a `file` resource has the `recurse` parameter set on it, and it is a directory,
    Puppet will deploy not only the directory itself, but all its contents (including
    subdirectories and their contents). As we saw in the previous example, when a
    file has more than one source, the first source file found is used to satisfy
    the request. This applies to directories as well.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `file` 资源设置了 `recurse` 参数，并且它是一个目录，Puppet 不仅会部署该目录本身，还会部署它的所有内容（包括子目录及其内容）。正如我们在之前的例子中看到的，当文件有多个来源时，找到的第一个源文件将用于满足请求。这也适用于目录。
- en: There's more...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'By specifying the parameter `sourceselect` as ''all'', the contents of all
    the source directories will be combined. For example, add `thomas admin_user`
    back into your node definition in `site.pp` for cookbook:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将参数 `sourceselect` 设置为 'all'，所有源目录的内容将会合并。例如，将 `thomas admin_user` 添加回你的节点定义
    `site.pp` 中的 cookbook：
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now run Puppet again on cookbook:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再运行 Puppet 来更新 cookbook：
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Because we previously applied the `thomas admin_user` to cookbook, the user
    existed. The two files defined in the `thomas` directory on the Puppet server
    were already in the home directory, so only the additional files, `.bash_logout`,
    `.bash_profile`, and `.emacs` were created. Using these two parameters together,
    you can have default files that can be overridden easily.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们之前在 cookbook 中应用了 `thomas admin_user`，所以该用户已存在。在 Puppet 服务器上的 `thomas` 目录中定义的两个文件已经存在于主目录中，因此只创建了额外的文件
    `.bash_logout`、`.bash_profile` 和 `.emacs`。使用这两个参数，你可以拥有可以轻松覆盖的默认文件。
- en: Sometimes you want to deploy files to an existing directory but remove any files
    which aren't managed by Puppet. A good example would be if you are using `mcollective`
    in your environment. The directory holding client credentials should only have
    certificates that come from Puppet.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能希望将文件部署到现有目录中，但移除任何不是由 Puppet 管理的文件。一个好的例子是，如果你在环境中使用 `mcollective`。存放客户端凭证的目录应只包含来自
    Puppet 的证书。
- en: 'The `purge` parameter will do this for you. Define the directory as a resource
    in Puppet:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`purge` 参数可以为你完成这个任务。将目录定义为 Puppet 中的资源：'
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The combination of `recurse` and `purge` will remove all files and subdirectories
    in `/etc/mcollective/ssl/clients` that are not deployed by Puppet. You can then
    deploy your own files to that location by placing them in the appropriate directory
    on the Puppet server.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`recurse` 和 `purge` 的组合将移除 `/etc/mcollective/ssl/clients` 中所有不是由 Puppet 部署的文件和子目录。然后，你可以通过将文件放置在
    Puppet 服务器的适当目录中，将自己的文件部署到该位置。'
- en: 'If there are subdirectories that contain files you don''t want to purge, just
    define the subdirectory as a Puppet resource, and it will be left alone:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有子目录包含你不想清理的文件，只需将该子目录定义为 Puppet 资源，它将被忽略：
- en: '[PRE49]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be aware that, at least in current implementations of Puppet, recursive file
    copies can be quite slow and place a heavy memory load on the server. If the data
    doesn't change very often, it might be better to deploy and unpack a `tar` file
    instead. This can be done with a file resource for the `tar` file and an exec,
    which requires the file resource and unpacks the archive. Recursive directories
    are less of a problem when filled with small files. Puppet is not a very efficient
    file server, so creating large tar files and distributing them with Puppet is
    not a good idea either. If you need to copy large files around, using the Operating
    Systems packager is a better solution.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，至少在当前的 Puppet 实现中，递归文件复制可能会非常慢，并且会给服务器带来较重的内存负载。如果数据不经常变化，最好还是部署并解压一个 `tar`
    文件。可以通过文件资源来管理 `tar` 文件，并使用 exec 来解压归档文件。对于包含小文件的递归目录，问题不大。Puppet 并不是一个高效的文件服务器，所以使用
    Puppet 来创建并分发大型 tar 文件并不是一个好主意。如果你需要复制大文件，使用操作系统的打包工具是更好的解决方案。
- en: Cleaning up old files
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理旧文件
- en: Puppet's `tidy` resource will help you clean up old or out-of-date files, reducing
    disk usage. For example, if you have Puppet reporting enabled as described in
    the section on generating reports, you might want to regularly delete old report
    files.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 的 `tidy` 资源将帮助你清理旧的或过时的文件，从而减少磁盘使用量。例如，如果你启用了 Puppet 报告功能，如生成报告部分所述，你可能希望定期删除旧的报告文件。
- en: How to do it...
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let's get started.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 开始吧。
- en: 'Modify your `site.pp` file as follows:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式修改你的 `site.pp` 文件：
- en: '[PRE50]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Run Puppet:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Puppet：
- en: '[PRE51]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How it works...
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Puppet searches the specified path for any files matching the `age` parameter;
    in this case, `2w` (two weeks). It also searches subdirectories (`recurse => true`).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 会在指定路径中搜索任何符合 `age` 参数的文件；在此情况下为 `2w`（两周）。它还会搜索子目录（`recurse => true`）。
- en: Any files matching your criteria will be deleted.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 所有符合你标准的文件将被删除。
- en: There's more...
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'You can specify file ages in seconds, minutes, hours, days, or weeks by using
    a single character to specify the time unit, as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用一个字符来指定时间单位（秒、分钟、小时、天或周），如下所示：
- en: '`60s`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`60s`'
- en: '`180m`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`180m`'
- en: '`24h`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`24h`'
- en: '`30d`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`30d`'
- en: '`4w`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4w`'
- en: 'You can specify that files greater than a given size should be removed, as
    follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以指定删除大于某个大小的文件，方式如下：
- en: '[PRE52]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This removes files of 100 megabytes and over. For kilobytes, use `k`, and for
    bytes, use `b`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这将删除大于或等于 100 MB 的文件。对于千字节，使用 `k`，对于字节，使用 `b`。
- en: Note
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that if you specify both age and size parameters, they are treated as
    independent criteria. For example, if you specify the following, Puppet will remove
    all files that are either at least one day old, or at least 512 KB in size:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你同时指定了年龄和大小参数，它们会被视为独立的标准。例如，如果你指定以下内容，Puppet 将删除所有至少一天前的文件，或者至少 512 KB
    大小的文件：
- en: age => "1d",
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: age => "1d",
- en: size => "512k",
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: size => "512k",
- en: Auditing resources
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审计资源
- en: Dry run mode, using the `--noop` switch, is a simple way to audit any changes
    to a machine under Puppet's control. However, Puppet also has a dedicated audit
    feature, which can report changes to resources or specific attributes.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `--noop` 开关的干运行模式，是一种简单的方式来审计 Puppet 控制下的机器上的任何更改。然而，Puppet 也有一个专门的审计功能，可以报告资源或特定属性的更改。
- en: How to do it...
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Here''s an example showing Puppet''s auditing capabilities:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个展示 Puppet 审计功能的示例：
- en: 'Modify your `site.pp` file as follows:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照如下方式修改你的 `site.pp` 文件：
- en: '[PRE53]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Run Puppet:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Puppet：
- en: '[PRE54]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works...
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `audit` metaparameter tells Puppet that you want to record and monitor certain
    things about the resource. The value can be a list of the parameters that you
    want to audit.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`audit` 元参数告诉 Puppet 你希望记录和监控资源的某些内容。该值可以是你想要审计的参数列表。'
- en: 'In this case, when Puppet runs, it will now record the owner and mode of the
    `/etc/passwd` file. In future runs, Puppet will spot whether either of these has
    changed. For example, if you run:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当 Puppet 运行时，它将记录 `/etc/passwd` 文件的所有者和权限。在未来的运行中，Puppet 会检查这两个内容是否发生了变化。例如，如果你运行：
- en: '[PRE55]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Puppet will pick up this change and log it on the next run:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 会在下次运行时捕获这个更改并记录下来：
- en: '[PRE56]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: There's more...
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'This feature is very useful to audit large networks for any changes to machines,
    either malicious or accidental. It''s also very handy to keep an eye on things
    that aren''t managed by Puppet, for example, application code on production servers.
    You can read more about Puppet''s auditing capability here:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能非常有用，可以用来审计大规模网络中机器的任何变化，无论是恶意的还是意外的。它还非常方便用于监控那些不受 Puppet 管理的内容，例如生产服务器上的应用程序代码。你可以在这里了解更多关于
    Puppet 审计功能的信息：
- en: '[http://puppetlabs.com/blog/all-about-auditing-with-puppet/](http://puppetlabs.com/blog/all-about-auditing-with-puppet/)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://puppetlabs.com/blog/all-about-auditing-with-puppet/](http://puppetlabs.com/blog/all-about-auditing-with-puppet/)'
- en: 'If you just want to audit everything about a resource, use `all`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是想审计某个资源的所有内容，可以使用 `all`：
- en: '[PRE57]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: See also
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: The *Noop - the don't change anything option* recipe in [Chapter 10](ch10.html
    "Chapter 10. Monitoring, Reporting, and Troubleshooting"), *Monitoring, Reporting,
    and Troubleshooting*
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无操作 - 不改变任何设置* 配方见 [第10章](ch10.html "第10章：监控、报告和故障排除")，*监控、报告和故障排除*'
- en: Temporarily disabling resources
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 临时禁用资源
- en: 'Sometimes you want to disable a resource for the time being so that it doesn''t
    interfere with other work. For example, you might want to tweak a configuration
    file on the server until you have the exact settings you want, before checking
    it into Puppet. You don''t want Puppet to overwrite it with an old version in
    the meantime, so you can set the `noop` metaparameter on the resource:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能希望暂时禁用一个资源，以免它干扰到其他工作。例如，你可能想在将配置文件推送到 Puppet 之前，在服务器上调整配置，直到你得到确切的设置。你不希望
    Puppet 在此期间用旧版本覆盖它，所以你可以在该资源上设置 `noop` 元参数：
- en: '[PRE58]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: How to do it...
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'This example shows you how to use the `noop` metaparameter:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了如何使用 `noop` 元参数：
- en: 'Modify your `site.pp` file as follows:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照如下方式修改你的 `site.pp` 文件：
- en: '[PRE59]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Run Puppet:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Puppet：
- en: '[PRE60]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: How it works...
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `noop` metaparameter is set to `true`, so for this particular resource,
    it's as if you had to run Puppet with the `--noop` flag. Puppet noted that the
    resource would have been applied, but otherwise did nothing.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`noop` 元参数设置为 `true`，因此对于这个特定的资源，它就像你需要用 `--noop` 标志运行 Puppet 一样。Puppet 注意到该资源本来会被应用，但实际上什么都没有做。'
- en: 'The nice thing with running the agent in test mode (`-t`) is that Puppet output
    a diff of what it would have done if the `noop` was not present (you can tell
    puppet to show the diff''s without using `-t` with `--show_diff`; `-t` implies
    many different settings):'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试模式下运行代理（`-t`）的一个好处是，Puppet 会输出如果没有 `noop` 的话，它会执行的差异（你可以通过 `--show_diff`
    在不使用 `-t` 的情况下让 Puppet 显示差异；`-t` 涉及许多不同的设置）：
- en: '[PRE61]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This can be very useful when debugging a template; you can work on your changes
    and then see what they would look like on the node without actually applying them.
    Using the diff, you can see whether your updated template produces the correct
    output.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这在调试模板时非常有用；你可以在不实际应用更改的情况下，先进行修改，然后查看它们在节点上会是什么样子。通过查看差异，你可以判断更新后的模板是否产生了正确的输出。
