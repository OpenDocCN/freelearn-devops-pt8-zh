- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: OpenShift GitOps – Argo CD
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenShift GitOps – Argo CD
- en: 'In the previous chapter, we learned how to create and run a pipeline using
    Tekton to build and deploy an application. While Tekton is great for building
    and performing other actions that are usually related to **continuous integration**
    (**CI**), **GitOps** is becoming the norm for **continuous deployment** (**CD**)
    regarding Kubernetes-native applications. In this chapter, we will dive into GitOps
    and talk about one of the best tools for CD: **Argo CD**.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用 Tekton 创建和运行管道，以构建和部署应用程序。虽然 Tekton 很适合构建和执行通常与 **持续集成** (**CI**)
    相关的其他操作，但 **GitOps** 正成为 **持续部署** (**CD**) 的标准，尤其是在 Kubernetes 原生应用程序方面。在本章中，我们将深入探讨
    GitOps，并讨论其中一个最适合 CD 的工具：**Argo CD**。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下内容：
- en: What is GitOps?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 GitOps？
- en: What is Argo CD?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 Argo CD？
- en: Application delivery model
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用交付模型
- en: Installing OpenShift GitOps
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 OpenShift GitOps
- en: Configuring Argo CD against multiple clusters
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 Argo CD 以支持多个集群
- en: Argo CD definitions and challenges
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Argo CD 定义和挑战
- en: Argo CD main objects
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Argo CD 主要对象
- en: Deploying an application using GitOps
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GitOps 部署应用程序
- en: Deploying to multiple clusters
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署到多个集群
- en: Let’s dive in!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Note
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The source code used in this chapter is available at [https://github.com/PacktPublishing/OpenShift-Multi-Cluster-Management-Handbook/tree/main/chapter10](https://github.com/PacktPublishing/OpenShift-Multi-Cluster-Management-Handbook/tree/main/chapter10).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用的源代码可以在 [https://github.com/PacktPublishing/OpenShift-Multi-Cluster-Management-Handbook/tree/main/chapter10](https://github.com/PacktPublishing/OpenShift-Multi-Cluster-Management-Handbook/tree/main/chapter10)
    获取。
- en: What is GitOps?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 GitOps？
- en: 'The term GitOps was first described by *Lexis Richardson*, CEO of *Weaveworks*,
    in 2017\. At that time, he presented the four principles of GitOps, which are
    as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps 这一术语首次由 *Lexis Richardson*，*Weaveworks* 的 CEO，于 2017 年提出。当时，他提出了 GitOps
    的四个原则，具体如下：
- en: '**The entire system is described declaratively**: This means that any configuration
    of your application and infrastructure needs to be treated as code, but not as
    a set of instructions, as you would with scripts or automation code. Instead,
    you must use a set of facts that describes the desired state of your system. These
    declaration files are versioned in Git, which is your single source of truth.
    The great benefit of this principle is that you can easily deploy or roll back
    your applications and, more importantly, restore your environment quickly if a
    disaster occurs.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整个系统是声明性描述的**：这意味着应用程序和基础设施的任何配置都需要作为代码来处理，而不是像脚本或自动化代码那样作为一组指令来处理。相反，您必须使用一组事实来描述系统的期望状态。这些声明文件在
    Git 中进行版本控制，Git 是你唯一的真理源。这个原则的一个巨大好处是，你可以轻松地部署或回滚应用程序，更重要的是，如果发生灾难，你可以迅速恢复环境。'
- en: '**The canonical desired system state is versioned in Git**: Git is your source
    of truth. It needs to be the single place that triggers all the changes in your
    systems. Ideally, nothing should be done directly on the systems, but through
    configuration changes on Git that will be applied automatically using a tool such
    as Argo CD.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准的期望系统状态在 Git 中有版本控制**：Git 是你的真理源。它需要成为触发你系统中所有更改的唯一地方。理想情况下，不应直接对系统进行任何操作，而应通过
    Git 上的配置更改来实现，这些更改将通过工具如 Argo CD 自动应用。'
- en: '**Approved changes are automatically applied to the system**: Since you have
    the desired state of your system stored in Git, any changes can be automatically
    applied to the system as they are pushed to the repository.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**批准的更改会自动应用到系统中**：由于你已经将系统的期望状态存储在 Git 中，任何更改都可以在推送到仓库时自动应用到系统中。'
- en: '**Software agents ensure correctness and alert you about divergence**: It is
    crucial to have tools in place that will ensure that your system is in the desired
    state, as described in Git. If any drift is detected, the tool needs to be able
    to self-heal the application and get it back to its desired state.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件代理确保正确性并在偏差时提醒您**：拥有确保系统处于所需状态的工具至关重要，这一状态在 Git 中有所描述。如果检测到任何漂移，工具需要能够自我修复应用程序，并将其恢复到所需状态。'
- en: 'GitOps became the norm for Kubernetes and cloud-native applications due to
    the following benefits:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps 成为 Kubernetes 和云原生应用程序的标准，因其带来了以下好处：
- en: '**Standard process and tools**: Git workflows allow teams to work collaboratively
    and in a reproducible manner, avoiding issues regarding human-repetitive tasks.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准流程和工具**：Git 工作流允许团队以协作和可重现的方式工作，避免了与人类重复性任务相关的问题。'
- en: '**Robust and secure process**: By working with **pull requests** (**PRs**)
    in Git, all the changes need to be reviewed and approved. You can also trace all
    changes in Git and revert them if needed.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强大且安全的过程**：通过在 Git 中使用**拉取请求**（**PRs**），所有更改都需要经过审查和批准。您还可以跟踪 Git 中的所有更改，并在需要时进行回退。'
- en: '**Auditable changes**: All changes are tracked and easily auditable in Git
    history.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可审计的更改**：所有更改都在 Git 历史中跟踪，并且可以轻松审计。'
- en: '**Consistency**: You can deploy the same application in multiple different
    clusters consistently:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：您可以在多个不同集群中一致地部署相同的应用程序：'
- en: '![Figure 10.1 – GitOps workflow ](img/B18015_10_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – GitOps 工作流](img/B18015_10_01.jpg)'
- en: Figure 10.1 – GitOps workflow
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – GitOps 工作流
- en: Now that you have a better understanding of what GitOps is, let’s start learning
    how to put GitOps workflows into practice.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对 GitOps 有了更好的理解，接下来让我们学习如何将 GitOps 工作流付诸实践。
- en: What is Argo CD?
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Argo CD？
- en: In theory, it is possible to adopt GitOps without the need to use any specific
    tool. You could implement scripts and automation to deploy and manage your applications
    using declarative files from Git that describe your systems. However, that would
    be costly and time-consuming. The good news is that there are some great open
    source options for Kubernetes that are stable and work well. At the time of writing,
    the main tools for Kubernetes are **Argo CD** and **Flux CD**; both are great
    tools but in this book, we will explore Argo CD, which comes at *no additional
    cost with a Red Hat OpenShift subscription*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，采用 GitOps 不一定需要使用任何特定工具。您可以通过实现脚本和自动化来使用 Git 中描述系统的声明性文件部署和管理应用程序。然而，这样做会非常耗费成本和时间。幸运的是，目前有一些很棒的
    Kubernetes 开源工具，它们稳定且效果良好。在本书撰写时，Kubernetes 的主要工具是**Argo CD** 和 **Flux CD**；这两者都是很棒的工具，但在本书中，我们将探索
    Argo CD，它*无需额外费用，已包含在 Red Hat OpenShift 订阅中*。
- en: In a nutshell, Argo CD is a tool that is capable of *reading* a set of *Kubernetes
    manifests, Helm charts, or Jsonnet files* stored in a Git repository and *applying*
    them to a Kubernetes namespace. Argo CD is not only able to apply manifests, though
    – it can also automate self-healing, object pruning, and other great capabilities,
    as we will explore in this chapter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Argo CD 是一个工具，能够*读取*存储在 Git 仓库中的一组*Kubernetes 清单、Helm 图表或 Jsonnet 文件*，并将其*应用*到
    Kubernetes 命名空间。虽然 Argo CD 不仅能够应用清单，还能自动化自愈、对象修剪等其他强大功能，正如我们在本章中将要探索的内容。
- en: Application delivery model
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用交付模型
- en: 'At this point, you may be wondering how OpenShift Pipelines (**Tekton**) and
    GitOps (**Argo CD**) are related. Tekton and Argo CD are complementary tools that
    are perfect together. While Tekton is a perfect fit for *CI* pipelines that run
    unit tests and build and generate container images, Argo CD is more appropriate
    for *continuous delivery* practice. The following diagram summarizes what a CI/CD
    pipeline with Tekton and Argo CD looks like:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可能会想知道 OpenShift Pipelines（**Tekton**）和 GitOps（**Argo CD**）之间有什么关系。Tekton
    和 Argo CD 是相辅相成的工具，完美配合。虽然 Tekton 非常适合执行单元测试、构建和生成容器镜像的*CI* 流水线，但 Argo CD 更适合用于*持续交付*实践。下图总结了使用
    Tekton 和 Argo CD 的 CI/CD 流水线的样子：
- en: '![Figure 10.2 – Application delivery model using Tekton and Argo CD ](img/B18015_10_02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – 使用 Tekton 和 Argo CD 的应用交付模型](img/B18015_10_02.jpg)'
- en: Figure 10.2 – Application delivery model using Tekton and Argo CD
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 使用 Tekton 和 Argo CD 的应用交付模型
- en: 'CD with GitOps means that the actual state of the application should be monitored
    and that any changes need to be reverted to the application’s desired state, as
    described in the Git repository:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GitOps 的 CD 意味着应该监控应用程序的实际状态，并且任何更改都需要恢复到应用程序在 Git 仓库中描述的期望状态：
- en: '![Figure 10.3 – Continuous delivery with GitOps ](img/B18015_10_03.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3 – 使用 GitOps 进行持续交付](img/B18015_10_03.jpg)'
- en: Figure 10.3 – Continuous delivery with GitOps
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 使用 GitOps 进行持续交付
- en: In this chapter, we will use our example from the previous chapter and use Argo
    CD to deploy the application and practice this application delivery model.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用上一章的示例，利用 Argo CD 部署应用程序并实践这一应用交付模型。
- en: Installing OpenShift GitOps
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 OpenShift GitOps
- en: The installation process is simple and is similar to what we followed in the
    previous chapter regarding OpenShift Pipelines.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程简单，类似于我们在上一章中讨论的 OpenShift Pipelines 安装过程。
- en: Prerequisites
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先决条件
- en: To install OpenShift GitOps, you will need an OpenShift cluster with cluster-admin
    permissions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 OpenShift GitOps，您需要一个具有集群管理员权限的 OpenShift 集群。
- en: Installation
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装
- en: 'Follow these steps:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: Access the **OpenShift web console** using the administrator’s perspective.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用管理员视角访问**OpenShift web 控制台**。
- en: 'Navigate to **Operators** | **OperatorHub**:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航至**操作符** | **OperatorHub**：
- en: '![Figure 10.4 – OperatorHub ](img/B18015_10_04.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4 – OperatorHub](img/B18015_10_04.jpg)'
- en: Figure 10.4 – OperatorHub
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – OperatorHub
- en: 'Search for `OpenShift GitOps` using the *Filter by keyword* box:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*关键字筛选*框搜索 `OpenShift GitOps`：
- en: '![Figure 10.5 – Red Hat OpenShift GitOps on OperatorHub ](img/B18015_10_05.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5 – Red Hat OpenShift GitOps 在 OperatorHub 上](img/B18015_10_05.jpg)'
- en: Figure 10.5 – Red Hat OpenShift GitOps on OperatorHub
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – Red Hat OpenShift GitOps 在 OperatorHub 上
- en: 'Click on the **Red Hat OpenShift GitOps** tile and then the **Install** button
    to go to the **Install** screen:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Red Hat OpenShift GitOps**图标，然后点击**安装**按钮，进入**安装**页面：
- en: '![Figure 10.6 – Installing OpenShift GitOps ](img/B18015_10_06.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6 – 安装 OpenShift GitOps](img/B18015_10_06.jpg)'
- en: Figure 10.6 – Installing OpenShift GitOps
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – 安装 OpenShift GitOps
- en: Now, select `openshift-operators` namespace and permits the operator to install
    OpenShift GitOps instances in any target namespace.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，选择 `openshift-operators` 命名空间，并允许操作符在任何目标命名空间中安装 OpenShift GitOps 实例。
- en: Select **Automatic** or **Manual** for the upgrade’s **Approval Strategy**.
    If you go for **Automatic**, upgrades will be performed automatically by the **Operator
    Lifecycle Manager** (**OLM**) as soon as they are released by Red Hat, while for
    **Manual**, you need to approve it before it can be applied.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**自动**或**手动**作为升级的**审批策略**。如果选择**自动**，升级将在 Red Hat 发布后，由**操作符生命周期管理器**(**OLM**)自动执行；而选择**手动**时，你需要批准后才能应用升级。
- en: Select an **Update channel**. The **stable** channel is recommended as it contains
    the latest stable and *supported* version of the operator.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个**更新频道**。推荐选择**稳定**频道，因为它包含了操作符的最新稳定和*受支持*版本。
- en: 'Click the **Install** button:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**安装**按钮：
- en: '![Figure 10.7 – Installing the operator ](img/B18015_10_07.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7 – 安装操作符](img/B18015_10_07.jpg)'
- en: Figure 10.7 – Installing the operator
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – 安装操作符
- en: 'Wait up to 5 minutes until you see the following message:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待最多 5 分钟，直到你看到以下消息：
- en: '![Figure 10.8 – Operator installed ](img/B18015_10_08.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.8 – 操作符已安装](img/B18015_10_08.jpg)'
- en: Figure 10.8 – Operator installed
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 – 操作符已安装
- en: OpenShift GitOps (Argo CD) also has a CLI, which helps execute common tasks,
    such as updating the admin’s password, registering external clusters, and much
    more. Let’s learn how to install the `argocd` CLI.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift GitOps (Argo CD) 也有一个 CLI，帮助执行常见任务，如更新管理员密码、注册外部集群等。让我们来学习如何安装 `argocd`
    CLI。
- en: Installing the argocd CLI
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 `argocd` CLI
- en: The `argocd` CLI makes it easier to work with Argo CD. Through it, you can manage
    Argo CD projects, applications, cluster credentials, and more.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`argocd` CLI 使得与 Argo CD 的工作更加便捷。通过它，你可以管理 Argo CD 项目、应用程序、集群凭据等。'
- en: 'To install the `argocd` CLI, follow these steps:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 `argocd` CLI，请按照以下步骤操作：
- en: Download the latest Argo CD binary file from [https://github.com/argoproj/argo-cd/releases/latest](https://github.com/argoproj/argo-cd/releases/latest).
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://github.com/argoproj/argo-cd/releases/latest](https://github.com/argoproj/argo-cd/releases/latest)
    下载最新的 Argo CD 二进制文件。
- en: 'If you are using Linux, download the CLI and add it to your path:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用的是 Linux，下载 CLI 并将其添加到你的路径中：
- en: '[PRE0]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If everything went well, you will see the following output by running the `argocd
    version` command. Ignore the error message you see in the last line; it is an
    expected message as we haven’t logged in to any OpenShift cluster yet:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，运行 `argocd version` 命令时你将看到如下输出。忽略最后一行的错误信息；它是预期中的消息，因为我们还没有登录到任何 OpenShift
    集群：
- en: '[PRE1]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, let’s learn how to configure Argo CD to deploy applications against multiple
    clusters.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何配置 Argo CD，以便在多个集群中部署应用程序。
- en: Configuring Argo CD against multiple clusters
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Argo CD 用于多个集群
- en: If you are planning to use Argo CD to deploy applications to *external clusters*,
    you need to add the new cluster’s credentials using the `argocd` CLI. You can
    skip this step if you want to deploy applications in the same cluster where Argo
    CD is installed (the `kubernetes.default.svc` file already exists and should be
    used in this case).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划使用 Argo CD 将应用程序部署到*外部集群*，你需要使用 `argocd` CLI 添加新集群的凭据。如果你只想在安装了 Argo CD
    的同一集群中部署应用程序（`kubernetes.default.svc` 文件已存在，并且应该在这种情况下使用），则可以跳过此步骤。
- en: 'To register new clusters, perform the following steps using the `argocd` CLI
    you installed previously:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册新集群，请使用你之前安装的 `argocd` CLI 执行以下步骤：
- en: 'Log into the new cluster we want to register:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到我们想要注册的新集群：
- en: '[PRE2]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, log into the cluster where Argo CD is installed using `oc login`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用 `oc login` 登录到安装了 Argo CD 的集群：
- en: '[PRE3]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'At this point, you should have both clusters in your `kubeconfig` file:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，您应该在 `kubeconfig` 文件中拥有两个集群：
- en: '[PRE4]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Set a different context for the new cluster:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新集群设置不同的上下文：
- en: '[PRE5]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Get the Argo CD public URL from the `openshift-gitops` namespace:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `openshift-gitops` 命名空间获取 Argo CD 公共 URL：
- en: '[PRE6]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Get the administrator password:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取管理员密码：
- en: '[PRE7]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Log in using `argocd`:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `argocd` 登录：
- en: '[PRE8]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, add the new cluster to Argo CD:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将新集群添加到 Argo CD：
- en: '[PRE9]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With that, you are ready to deploy applications either into your local or remote
    cluster using Argo CD! But before we dive into application deployment, let’s check
    out some of the important aspects related to Argo CD.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，您就可以使用 Argo CD 将应用程序部署到本地或远程集群了！但在深入应用程序部署之前，我们先来看一下与 Argo CD 相关的一些重要方面。
- en: Argo CD definitions and challenges
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Argo CD 定义和挑战
- en: Before we walk through the application deployment process, we need to discuss
    some important challenges related to GitOps, decisions, and standards.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讲解应用程序部署过程之前，我们需要讨论一些与 GitOps、决策和标准相关的重要挑战。
- en: GitHub repository structure
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitHub 仓库结构
- en: The first important question that always comes up with GitOps is about the GitHub
    repository’s structure. Should I only use one repository for source code and the
    Kubernetes manifests? How should I deal with different configuration files for
    different environments, such as development, QA, and production?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps 常见的第一个重要问题是关于 GitHub 仓库结构的。是否应该仅使用一个仓库来存放源代码和 Kubernetes 清单？如何处理不同环境（如开发、QA
    和生产）的不同配置文件？
- en: 'Well, there are no right or wrong answers to these questions, as each option
    has its pros and cons. You need to find out which approach works best for you.
    My advice here is: try it! There is nothing better than practical experience,
    so use each model and find out which one fits best for your applications and teams.
    In the following sections, we’ll look at some of the most popular repository structures
    out there for GitOps-oriented applications.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对这些问题没有标准的正确或错误答案，因为每种选项都有其优缺点。您需要找出最适合您的方法。我的建议是：尝试一下！没有什么比实际经验更好的了，所以请使用每个模型，找出最适合您应用程序和团队的方案。在接下来的部分中，我们将讨论一些
    GitOps 定向应用程序中最流行的仓库结构。
- en: Mono-repository
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单一仓库
- en: 'In this structure, you will have one repository for all your Kubernetes manifests
    and infrastructure-related files. Although there is not a single standard for
    this structure, you will probably have a repository similar to the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种结构下，您将拥有一个仓库来存放所有 Kubernetes 清单和基础设施相关文件。尽管没有统一的标准来定义这种结构，但您可能会有一个类似以下的仓库：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s look at this code in more detail:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这些代码：
- en: '**#[1]**: This folder contains the CI/CD pipelines, Argo CD, and other related
    configuration files that are common for any environment'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**#[1]**：此文件夹包含 CI/CD 流水线、Argo CD 以及其他相关的配置文件，这些文件对任何环境都是通用的'
- en: '**#[2]**: This folder contains the manifests that are specific to each environment,
    such as development, QA, and production'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**#[2]**：此文件夹包含特定于每个环境的清单文件，如开发、QA 和生产'
- en: '**#[3]**: These are the manifest files that are specific to the development
    environment'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**#[3]**：这些是特定于开发环境的清单文件'
- en: '**#[4]**: Here, you have the Kubernetes manifests to deploy the applications
    that are tracked and released in this repository'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**#[4]**：在这里，您可以找到部署应用程序的 Kubernetes 清单，这些应用程序在这个仓库中进行追踪和发布'
- en: '`RoleBinding` permissions, `Namespace`, and so on'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RoleBinding` 权限，`Namespace` 等等'
- en: '**#[6]**: These are the manifest files that are specific to the QA environment'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**#[6]**：这些是特定于 QA 环境的清单文件'
- en: 'The main benefit of this approach is its **simplicity**: in this approach,
    you only need to manage one repository for one or more applications, which makes
    it easier to manage branches, tags, **PRs**, and anything related to the application''s
    manifests repository. However, the major con of this strategy is that all the
    contributors can read and make changes to the production manifests. That said,
    it might be *hard to detect unintentional changes to production*, especially with
    large PRs.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的主要好处是**简洁性**：在这种方法中，您只需管理一个仓库来存放一个或多个应用程序，这使得管理分支、标签、**PR** 以及与应用程序清单仓库相关的任何事务都变得更加容易。然而，这种策略的主要缺点是，所有贡献者都可以读取并更改生产清单。这意味着可能会*很难发现对生产环境的无意更改*，尤其是对于大型
    PR 来说。
- en: This leads us to the next approach, in which you have a different repository
    per environment.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了我们下一种方法，在这种方法中，每个环境都有一个不同的代码库。
- en: Repository per environment
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 每个环境一个代码库
- en: 'With this strategy, you will have multiple repositories, one for each environment.
    In other words, you will have one repository for *development* manifests, another
    one for *QA*, and so on. In this strategy, you will likely use PRs to promote
    changes between each environment and have a granular review process, which leads
    to a less error-prone process. In this strategy, you can also manage Git permissions
    according to each environment:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种策略，您将拥有多个代码库，每个环境一个。换句话说，您将为*开发*清单、*QA*清单等创建不同的代码库。在这种策略下，您可能会使用PR（Pull
    Requests）在每个环境之间推广变更，并拥有一个精细的审查过程，从而减少错误的发生。在这种策略下，您还可以根据每个环境管理Git权限：
- en: '![Figure 10.9 – One repository per environment ](img/B18015_10_09.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.9 – 每个环境一个代码库 ](img/B18015_10_09.jpg)'
- en: Figure 10.9 – One repository per environment
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – 每个环境一个代码库
- en: In this chapter, we will be using a mono-repository strategy and use Git push
    requests and PRs with multiple branches to mitigate the risk of unintentional
    changes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将采用单一代码库策略，并使用Git推送请求和PR与多个分支，以减少无意更改的风险。
- en: 'Next, we will discuss another important aspect related to GitOps on Kubernetes:
    templating YAML files and avoiding duplication.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论与Kubernetes上的GitOps相关的另一个重要方面：模板化YAML文件并避免重复。
- en: Templating Kubernetes manifests
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板化Kubernetes清单
- en: 'Whatever repository structure you decide to go for, one thing is certain: you
    will need to have separate files and folders for each environment you manage.
    So, how can you avoid duplicating YAML manifest files everywhere and turning your
    GitOps process into a nightmare?'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您决定采用什么样的代码库结构，有一点是确定的：您将需要为每个您管理的环境创建单独的文件和文件夹。那么，如何避免到处重复YAML清单文件并将GitOps过程变成一场噩梦呢？
- en: 'Currently, the most popular options to do this are as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，最流行的做法如下：
- en: '**Helm**: Rely on Helm Charts and Helm Templates to package and deliver Kubernetes
    applications. Through Helm Templates, you can combine values with templates and
    generate valid Kubernetes manifest files as a result.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Helm**：依赖于Helm Charts和Helm Templates来打包和交付Kubernetes应用程序。通过Helm Templates，您可以将值与模板结合，生成有效的Kubernetes清单文件。'
- en: '**Kustomize**: With Kustomize, you can reuse existing manifest files using
    a patch strategy. It uses a hierarchical structure so that you can flexibly reuse
    shared configurations and create layers of configurations with only environment-specific
    parameters that will be overloaded with base parameters.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kustomize**：使用Kustomize，您可以通过补丁策略重用现有的清单文件。它采用层次结构，这样您可以灵活地重用共享配置，并创建只包含特定于环境的参数的配置层，这些参数将会覆盖基础参数。'
- en: 'While Helm is a great package tool, we are going to focus on Kustomize in this
    chapter due to the following reasons:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Helm是一个很好的打包工具，但由于以下原因，本章将重点讨论Kustomize：
- en: Kustomize runs natively on Kubernetes and the OpenShift CLI (`kubectl`/`oc`)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kustomize原生运行在Kubernetes和OpenShift CLI（`kubectl`/`oc`）上
- en: It is declarative, which is an important factor for GitOps, as we mentioned
    previously
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是声明性的，这是GitOps的一个重要因素，正如我们之前提到的那样。
- en: You can use a remote base in a repository as the starter set of the manifest
    and have the overlays stored in different repositories
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用远程基础代码库作为清单的起始集，并将覆盖存储在不同的代码库中。
- en: Let’s take a closer look at Kustomize.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解Kustomize。
- en: Kustomize
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kustomize
- en: 'Kustomize is composed of hierarchical layers of manifest files:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize由层次化的清单文件组成：
- en: '`Base`: This is a directory that contains the resources that are always reused
    as the base manifest files. These describe the application and objects declaratively.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Base`：这是一个包含始终作为基础清单文件重用的资源的目录。这些资源以声明性方式描述应用程序和对象。'
- en: '`Overlays`: This is a directory that only contains the configurations that
    are specific for each overlay. For instance, it is common to have an overlay for
    the development environment, another for QA, and so on. The configurations that
    reside in the `overlay` directories replace the values that are in the `base`
    directory.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Overlays`：这是一个仅包含每个覆盖特定配置的目录。例如，通常会有一个用于开发环境的覆盖，一个用于QA的覆盖，等等。存储在`overlay`目录中的配置会替换`base`目录中的值。'
- en: 'You can have multiple layers of bases and overlays – as many as you want. However,
    to maintain the legibility and maintainability of your application manifest files,
    it is not recommended to use several layers of manifest files. The following diagram
    shows an example of a base and two overlays that might be used with Kustomize:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以有多个基础和覆盖层——可以根据需要使用任意数量。然而，为了保持应用清单文件的可读性和可维护性，不建议使用多个清单层次结构。以下图示展示了一个基础和两个覆盖层的示例，可能会与
    Kustomize 一起使用：
- en: '![Figure 10.10 – Kustomize layers ](img/B18015_10_10.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.10 – Kustomize 层次结构](img/B18015_10_10.jpg)'
- en: Figure 10.10 – Kustomize layers
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 – Kustomize 层次结构
- en: 'The following is a typical folder structure you’ll see when you’re using Kustomize:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你在使用 Kustomize 时通常会看到的文件夹结构：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We will practice using Kustomize a bit more in this chapter when we deploy our
    example.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在部署示例时进一步练习使用 Kustomize。
- en: Managing secrets
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理秘密
- en: Last, but not least, the real challenge with Kubernetes is managing sensitive
    data using secrets. While secrets are somewhat safe, depending on how the permissions
    are set among users, they are not encrypted. This is a real problem when we think
    about storing those secrets in a GitHub repository. So, how can we handle secrets
    securely?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，Kubernetes 的真正挑战是使用秘密管理敏感数据。虽然秘密在一定程度上是安全的，但根据用户权限的设置，它们并没有加密。当我们考虑将这些秘密存储在
    GitHub 仓库中时，这就成为一个真实的问题。那么，我们该如何安全地处理秘密呢？
- en: 'There are two ways to handle secrets:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 处理密码有两种方法：
- en: Use an external vault to store the secrets securely outside Git and the cluster
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用外部保险库安全地存储秘密，避免存储在 Git 和集群中
- en: Encrypt the secret before saving it in Git using a sealed secret tool such as
    Bitnami Sealed Secrets
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将秘密保存在 Git 中之前，使用加密工具（如 Bitnami Sealed Secrets）对其进行加密
- en: Notes
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: '1\. Secrets are presented in Base64 encoding. The following command, for instance,
    decrypts a secret named `db-root-password` that contains a password field:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 密码以 Base64 编码呈现。例如，以下命令解密名为 `db-root-password` 的密码字段：
- en: '`oc get secret db-root-password –o jsonpath="{.data.password}" | base64 -d`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`oc get secret db-root-password –o jsonpath="{.data.password}" | base64 -d`'
- en: 2\. Bitnami Sealed Secrets allows you to encrypt your secret into a `SealedSecret`
    object and store it securely, even in a public GitHub repository, since it is
    encrypted using a public/private certificate. To learn more, check out the link
    in the *Further reading* section.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. Bitnami Sealed Secrets 允许你将秘密加密为 `SealedSecret` 对象，并安全存储，即使是在公共 GitHub 仓库中，因为它使用公钥/私钥证书进行加密。欲了解更多信息，请查看
    *进一步阅读* 部分中的链接。
- en: With that, we have discussed the main points that you need to think about regarding
    GitOps. They are important topics we decided to bring to you before our practical
    example but don’t get too worried about that yet – you will find out what works
    best for you and your team by practicing and learning from it. In the next section,
    we will introduce some of the main objects you will work with in Argo CD.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，我们已经讨论了你在 GitOps 中需要考虑的主要问题。在我们实际示例之前，这些都是我们决定向你介绍的重要话题，但别太担心——你会通过实践和学习，找到最适合你和你团队的方法。在接下来的部分，我们将介绍一些你将在
    Argo CD 中使用的主要对象。
- en: Argo CD main objects
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Argo CD 主要对象
- en: 'In this section, we will look at some of the main Argo CD objects you need
    to know about. Argo CD is quite simple and most of what you will do can be summarized
    in two objects: **AppProject** and **Application**.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一些你需要了解的主要 Argo CD 对象。Argo CD 相当简单，绝大多数操作可以归纳为两个对象：**AppProject**
    和 **Application**。
- en: In this section, we will not mention all the different objects Argo CD has since
    that is not the main focus of this book. Check out the *Further reading* section
    to learn more.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们不会提及 Argo CD 的所有不同对象，因为这不是本书的主要焦点。请查阅 *进一步阅读* 部分了解更多。
- en: AppProject
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AppProject
- en: 'Projects allow you to group applications and structure them according to any
    group logic you need. Using projects, you can do the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 项目允许你将应用程序分组，并根据你需要的任何逻辑结构进行组织。使用项目，你可以执行以下操作：
- en: Limit the Git *source repositories* that can be used to deploy applications
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制可以用来部署应用程序的 Git *源仓库*
- en: Restrict the *clusters and namespaces destination* that the applications can
    be deployed to
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制应用程序可以部署到的 *集群和命名空间目标*
- en: Limit the type of objects that can be deployed (for example, Deployments, Secrets,
    DaemonSets, and so on)
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制可以部署的对象类型（例如，Deployments、Secrets、DaemonSets 等）
- en: Set roles to limit the permissions that are allowed by groups and/or JWTs
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置角色以限制组和/或 JWTs 允许的权限
- en: When Argo CD is installed, it comes with a `default` project. If you don’t specify
    a project in your Argo CD application, the `default` option will be used. Creating
    additional projects is optional as you could use Argo CD’s `default` project instead.
    However, it is recommended to create additional projects to help you organize
    your Argo CD applications.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当安装 Argo CD 时，它会附带一个`默认`项目。如果在 Argo CD 应用程序中没有指定项目，则将使用`默认`选项。创建额外的项目是可选的，因为你可以选择使用
    Argo CD 的`默认`项目。然而，建议创建额外的项目，以帮助你更好地组织 Argo CD 应用程序。
- en: Note
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There is no relationship between Argo CD’s default project and OpenShift’s default
    namespace. Although they have the same name, they are unrelated.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD 的默认项目与 OpenShift 的默认命名空间之间没有关系。尽管它们的名称相同，但它们是没有关联的。
- en: 'A typical `AppProject` specification looks as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的`AppProject`规范如下：
- en: '[PRE12]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s look at this code in more detail:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地查看这段代码：
- en: '**[1]**: The name of the project.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[1]**：项目的名称。'
- en: '**[2]**: The Git source repositories that are allowed. In this case, any source
    repository is allowed'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[2]**：允许的 Git 源仓库。在这种情况下，允许任何源仓库。'
- en: '**[3]**: The destination clusters and namespaces that are allowed. In this
    case, any combination of clusters and namespaces is allowed'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[3]**：允许的目标集群和命名空间。在这种情况下，允许任何集群和命名空间的组合。'
- en: '**[4]**: The objects that can be deployed (for example, Deployments, Secrets,
    DaemonSets, and so on). In this case, there is no limitation'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[4]**：可以部署的对象（例如 Deployments、Secrets、DaemonSets 等）。在这种情况下，没有任何限制。'
- en: Properly adjust the code pointed out to achieve manifest file.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 正确调整代码，以实现清单文件。
- en: Applications
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序
- en: Applications represent application instances that have been deployed and managed
    by Argo CD. The specification of an application is composed of `source` and `destination`.
    `source` is where the Kubernetes manifests (Git repository) that specify the desired
    state of the application reside, while `destination` specifies the cluster and
    namespace where the application will be deployed. Besides that, you can also specify
    the synchronization policies you want Argo CD to apply.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序代表已由 Argo CD 部署和管理的应用程序实例。应用程序的规范由`source`和`destination`组成。`source`是存放指定应用程序期望状态的
    Kubernetes 清单（Git 仓库）的地方，而`destination`则指定应用程序将要部署的集群和命名空间。此外，你还可以指定希望 Argo CD
    应用的同步策略。
- en: 'The following is an example of an `Application` specification:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`应用程序`规范的示例：
- en: '[PRE13]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s look at this code in more detail:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地查看这段代码：
- en: '`Application` name.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`应用程序`名称。'
- en: '`openshift-gitops`.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openshift-gitops`。'
- en: '`AppProject` object. Do not get it confused with the OpenShift project; they
    are unrelated.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppProject`对象。不要将其与 OpenShift 项目混淆，它们没有关系。'
- en: '**[4]**: Git source repository information about where the Kubernetes manifests
    reside.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[4]**：关于 Kubernetes 清单所在位置的 Git 源仓库信息。'
- en: '**[5]**: The cluster and namespace where the application will be deployed.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[5]**：应用程序将要部署的集群和命名空间。'
- en: '**[6]**: The synchronization policies that Argo CD will use. We will learn
    more about these policies in the next section.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[6]**：Argo CD 将使用的同步策略。我们将在下一节中了解这些策略。'
- en: Important Note
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Argo CD’s namespace (`openshift-gitops`) has special privileges within the cluster
    to perform all the necessary activities. Due to that, you must protect access
    to this namespace to avoid unwanted deployments or changes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD 的命名空间（`openshift-gitops`）在集群中具有执行所有必要活动的特殊权限。因此，你必须保护对该命名空间的访问，以避免不必要的部署或更改。
- en: Syncing policies
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同步策略
- en: 'You can configure Argo CD to automatically synchronize your application when
    there is any drift between the desired state specified in the manifests in Git
    and the actual application state. You have the following options with Argo CD:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以配置 Argo CD 在 Git 中的清单指定的期望状态与实际应用状态之间出现任何偏差时，自动同步应用程序。你可以使用 Argo CD 提供以下选项：
- en: '`true`, Argo CD will automatically sync when it detects any differences between
    the manifests in Git and the actual state. By default, this flag is `false`.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是`true`，Argo CD 会在检测到 Git 中的清单与实际状态之间的任何差异时自动同步。默认情况下，此标志为`false`。
- en: '`prune` flag to `true`.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`prune`标志设置为`true`。
- en: Syncing the order
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同步顺序
- en: 'For standard Kubernetes manifests, Argo CD already knows the correct order
    that needs to be applied to avoid precedence issues. For instance, consider an
    application that contains three manifests for namespace creation, deployment,
    and role bindings. In such a case, Argo CD will always apply the objects in the
    following order:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于标准的Kubernetes清单，Argo CD已经知道需要应用的正确顺序，以避免优先级问题。例如，考虑一个包含三个清单的应用，分别用于命名空间创建、部署和角色绑定。在这种情况下，Argo
    CD将始终按照以下顺序应用这些对象：
- en: Namespace
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名空间
- en: Role bindings
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 角色绑定
- en: Deployment
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署
- en: That said, this is the kind of thing you don’t need to be worried about as Argo
    CD is smart enough to apply them in the correct order.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，你不必为此担心，因为Argo CD足够智能，能够按照正确的顺序应用它们。
- en: However, there are some other specific cases where you may need to specify objects’
    precedence. Let’s say that you want to deploy an application composed of one StatefulSet
    to deploy a database and a deployment for an application that uses the database.
    In this case, you can use **resource hooks** to specify the correct order to apply
    the objects.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在一些特定的情况下，你可能需要指定对象的优先级。例如，假设你想部署一个由一个StatefulSet（用于部署数据库）和一个部署（用于使用数据库的应用）组成的应用。在这种情况下，你可以使用**资源钩子**来指定正确的应用顺序。
- en: 'The following types of resource hooks can be used:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下类型的资源钩子：
- en: '`PreSync`: Objects marked with `PreSync` are executed before any other manifests.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PreSync`：标记为`PreSync`的对象将在任何其他清单之前执行。'
- en: '`Sync`: This runs after `PreSync` is complete. You can also use `sync-wave`
    to set the sync precedence of the objects in the `Sync` phase.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sync`：此操作在`PreSync`完成后运行。你还可以使用`sync-wave`来设置在`Sync`阶段中对象的同步优先级。'
- en: '`PostSync`: Runs after all the `Sync` objects have been applied and are in
    a `Healthy` state.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PostSync`：在所有`Sync`对象应用完并处于`健康`状态后运行。'
- en: '`SyncFail`: The manifests with this annotation will only be executed when a
    sync operation fails.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SyncFail`：带有此注释的清单仅在同步操作失败时执行。'
- en: 'The following is an example of a resource hook specification:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个资源钩子规范的示例：
- en: '[PRE14]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There are different types of annotations that you can include in your manifests
    to perform more complex tasks. Check out the *Further reading* section to learn
    more.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在清单中包含不同类型的注释，以执行更复杂的任务。请查看*进一步阅读*部分了解更多信息。
- en: With that, we have covered the most important concepts and theories behind GitOps
    and Argo CD. Now, without further ado, let’s look at our example and practice
    what we have discussed so far!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经涵盖了GitOps和Argo CD背后最重要的概念和理论。现在，事不宜迟，让我们来看看我们的示例，并实践迄今为止所讨论的内容！
- en: Deploying an application using GitOps
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GitOps部署应用
- en: 'In this practical exercise, we will build and deploy our sample application
    in three different namespaces to simulate an application life cycle composed of
    development, QA, and production environments. The following diagram shows the
    delivery model we will use in this exercise to practice Argo CD deployments. Use
    it as much as you want as a starting point to build a comprehensive and complex
    ALM workflow that’s suitable for your needs:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实际操作中，我们将在三个不同的命名空间中构建并部署我们的示例应用，以模拟由开发、QA和生产环境组成的应用生命周期。下图展示了我们将在本次练习中使用的交付模型，以便实践Argo
    CD部署。你可以将其作为起点，根据自己的需求构建全面且复杂的ALM工作流：
- en: '![Figure 10.11 – Application delivery model using Tekton, Argo CD, and Git
    ](img/B18015_10_11.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图10.11 – 使用Tekton、Argo CD和Git的应用交付模型](img/B18015_10_11.jpg)'
- en: Figure 10.11 – Application delivery model using Tekton, Argo CD, and Git
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11 – 使用Tekton、Argo CD和Git的应用交付模型
- en: 'Once again, we are going to use the content we have prepared in this book’s
    GitHub repository. To do this, you must *fork this repository to your GitHub account*:
    [https://github.com/PacktPublishing/OpenShift-Multi-Cluster-Management-Handbook](https://github.com/PacktPublishing/OpenShift-Multi-Cluster-Management-Handbook).
    Once you have forked it, follow the instructions in this section to put this workflow
    into practice.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，我们将使用本书GitHub仓库中准备的内容。为此，你必须*将此仓库fork到你的GitHub账号*：[https://github.com/PacktPublishing/OpenShift-Multi-Cluster-Management-Handbook](https://github.com/PacktPublishing/OpenShift-Multi-Cluster-Management-Handbook)。一旦你完成fork，请按照本节中的说明操作，将此工作流付诸实践。
- en: Building a new image version
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建一个新的镜像版本
- en: 'In this section, we will build a new container image version, 1.0, and push
    it to the OpenShift internal registry, as shown in the following diagram:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建一个新的容器镜像版本1.0，并将其推送到OpenShift内部注册表，如下图所示：
- en: '![Figure 10.12 – Building a new image version ](img/B18015_10_12.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.12 – 构建新镜像版本](img/B18015_10_12.jpg)'
- en: Figure 10.12 – Building a new image version
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 – 构建新镜像版本
- en: 'To do so, perform the following steps:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，请执行以下步骤：
- en: 'Clone the repository in your machine:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的机器上克隆该仓库：
- en: '[PRE15]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Run the following script and follow the instructions to change the references
    from the original repository (`PacktPublishing`) to your forked repository:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下脚本并按照指示将引用从原始仓库（`PacktPublishing`）更改为你自己的分叉仓库：
- en: '[PRE16]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a new branch for development:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为开发创建一个新分支：
- en: '[PRE17]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Open the `./sample-go-app/clouds-api/clouds.go` file with your preferred text
    editor and change line 147 by adding `version=1.0` to it:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的文本编辑器打开`./sample-go-app/clouds-api/clouds.go`文件，并在第147行添加`version=1.0`：
- en: '[PRE18]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Commit and push change to the `dev` branch:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交并推送更改到`dev`分支：
- en: '[PRE19]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the following command to deploy the required prerequisites and the pipeline
    that builds image version 1.0, which we will deploy in the development namespace
    shortly. Make sure that you are already logged into the OpenShift cluster (by
    using the `oc login` command):'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来部署所需的先决条件和构建版本为1.0的镜像管道，稍后我们将在开发命名空间中部署它。确保你已经登录到OpenShift集群（使用`oc login`命令）：
- en: '[PRE20]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, run the pipeline and check the logs:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行管道并查看日志：
- en: '[PRE21]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With that, you have built the `clouds-api:v1.0` container image and pushed it
    to OpenShift’s internal registry. Now, let’s deploy this image using **Kustomize**
    and **Argo CD**.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你就构建了`clouds-api:v1.0`容器镜像，并将其推送到OpenShift的内部注册表中。现在，让我们使用**Kustomize**和**Argo
    CD**来部署此镜像。
- en: Deploying in development
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在开发环境中部署
- en: In this section, we are going to use Kustomize to overwrite the image tag of
    the deployment YAML file so that it uses `v1.0`, which we built in the previous
    section. We will also create a new namespace for the development branch named
    `clouds-api-dev`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用Kustomize覆盖部署YAML文件中的镜像标签，使其使用我们在上一节中构建的`v1.0`。我们还将为开发分支创建一个名为`clouds-api-dev`的新命名空间。
- en: 'The following diagram shows the steps we will perform:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了我们将执行的步骤：
- en: '![Figure 10.13 – Deploying in development ](img/B18015_10_13.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.13 – 在开发环境中部署](img/B18015_10_13.jpg)'
- en: Figure 10.13 – Deploying in development
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13 – 在开发环境中部署
- en: 'Perform the following steps:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Change the image version of our development `kustomization.yaml` file. To do
    so, change line 18 from `changeme` to `v1.0`:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改我们开发环境`kustomization.yaml`文件中的镜像版本。为此，将第18行的`changeme`改为`v1.0`：
- en: '[PRE22]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Alternatively, you may use the `sed` command to replace this line:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另外，你也可以使用`sed`命令来替换这一行：
- en: '[PRE23]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, push this change to the `dev` branch:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将此更改推送到`dev`分支：
- en: '[PRE24]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let’s create a new Argo CD project:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们来创建一个新的Argo CD项目：
- en: '[PRE25]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create a new Argo CD application that will deploy the application in the development
    namespace:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Argo CD 应用程序，将应用部署到开发命名空间中：
- en: '[PRE26]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Get Argo CD’s URL and admin passwords using the following commands:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令获取Argo CD的URL和管理员密码：
- en: '[PRE27]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Access the Argo CD UI using the URL and admin user provided previously. You
    should see a new application there named `clouds-app-dev`:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用之前提供的URL和管理员用户访问Argo CD UI。你应该能看到一个名为`clouds-app-dev`的新应用程序：
- en: '![Figure 10.14 – The Argo CD application to deploy in development ](img/B18015_10_14.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.14 – 在开发中部署的 Argo CD 应用](img/B18015_10_14.jpg)'
- en: Figure 10.14 – The Argo CD application to deploy in development
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.14 – 在开发中部署的 Argo CD 应用
- en: 'Click **clouds-app-dev** to learn more about the application:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**clouds-app-dev**以了解更多关于该应用程序的信息：
- en: '![Figure 10.15 – The Argo CD application ](img/B18015_10_15.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.15 – Argo CD 应用](img/B18015_10_15.jpg)'
- en: Figure 10.15 – The Argo CD application
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.15 – Argo CD 应用
- en: 'Run the `curl` command to check that version 1.0 of the application is running
    and has been successfully deployed by Argo CD:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`curl`命令来检查版本1.0的应用程序是否正在运行，并已通过Argo CD成功部署：
- en: '[PRE28]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You should see the following response:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到以下响应：
- en: '[PRE29]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With that, our sample application is running in the development namespace.
    Now, let’s learn how to promote this application to the next stage: QA.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的示例应用程序就运行在开发命名空间中了。现在，让我们学习如何将这个应用程序提升到下一个阶段：QA。
- en: Promoting to QA
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提升到QA
- en: 'We have application version 1.0 running in development. Now, let’s use Kustomize
    and Argo CD once more to deploy it in a new namespace that’s dedicated to QA,
    as shown in the following diagram:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在开发环境中运行了1.0版本的应用程序。现在，让我们再次使用Kustomize和Argo CD将其部署到一个新的命名空间，该命名空间专用于QA，如下图所示：
- en: '![Figure 10.16 – Promoting to QA ](img/B18015_10_16.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.16 – 提升到QA](img/B18015_10_16.jpg)'
- en: Figure 10.16 – Promoting to QA
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.16 – 推送到 QA 环境
- en: 'Follow these steps:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'Create a new branch for QA:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 QA 创建一个新分支：
- en: '[PRE30]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create an overlay for QA by copying the `dev` overlay:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过复制 `dev` 覆盖层来为 QA 创建一个覆盖层：
- en: '[PRE31]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Replace the references to `dev` with `qa`:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有 `dev` 的引用替换为 `qa`：
- en: '[PRE32]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Push the changes to Git:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将更改推送到 Git：
- en: '[PRE33]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Deploy the manifest file to promote the environment using Argo CD:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将清单文件部署到生产环境，以便使用 Argo CD 推送到环境：
- en: '[PRE34]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Access the Argo CD UI again. At this point, you should have two applications
    on Argo CD:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次访问 Argo CD UI。此时，你应该在 Argo CD 上看到两个应用程序：
- en: '![Figure 10.17 – Argo CD applications ](img/B18015_10_17.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.17 – Argo CD 应用程序](img/B18015_10_17.jpg)'
- en: Figure 10.17 – Argo CD applications
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.17 – Argo CD 应用程序
- en: 'Let’s access the application that is running in the QA namespace:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们访问正在 QA 命名空间中运行的应用程序：
- en: '[PRE35]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You should see the same response that you saw previously:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到与之前相同的响应：
- en: '[PRE36]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: With that, we have promoted our application to QA! Now, let’s learn how to move
    it to the last stage, which is the production environment.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们已经将应用程序推送到 QA 环境！现在，让我们学习如何将它迁移到最后一个阶段，即生产环境。
- en: Promoting to production
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推送到生产环境
- en: 'For production, we are going to use a different approach – we are going to
    use PRs instead of simple Git pushes. We will use a temporary branch named `pre-prod`
    to commit the overlay manifests that will be used for production, as shown in
    the following diagram:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产环境，我们将使用不同的方法——我们将使用 PR 而不是简单的 Git 推送。我们将使用一个名为 `pre-prod` 的临时分支来提交将用于生产的覆盖清单，如下图所示：
- en: '![Figure 10.18 – Promoting to production ](img/B18015_10_18.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.18 – 推送到生产环境](img/B18015_10_18.jpg)'
- en: Figure 10.18 – Promoting to production
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.18 – 推送到生产环境
- en: 'Follow these steps to promote version 1.0 of our application to production:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这些步骤将我们的应用程序版本 1.0 推送到生产环境：
- en: 'Create a new branch to prepare for production:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新分支，为生产环境做准备：
- en: '[PRE37]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create an overlay for production, similar to what you did with QA:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为生产环境创建一个覆盖层，类似于你在 QA 环境中所做的：
- en: '[PRE38]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Push the changes to the `pre-prod` branch:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将更改推送到 `pre-prod` 分支：
- en: '[PRE39]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, create a PR on GitHub and merge it with the main branch. Access the **Pull
    requests** tab of your GitHub repository and click the **New pull request** button:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 GitHub 上创建一个 PR 并将其与主分支合并。访问你 GitHub 仓库的 **Pull requests** 标签页并点击 **New
    pull request** 按钮：
- en: '![Figure 10.19 – Creating a PR ](img/B18015_10_19.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.19 – 创建 PR](img/B18015_10_19.jpg)'
- en: Figure 10.19 – Creating a PR
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.19 – 创建 PR
- en: 'Since you are working in the forked repository, GitHub suggests that you create
    a PR for the source repository (in this case, from `PacktPublishing`). We want
    to create a PR that goes from our `pre-prod` branch to the `main` branch, both
    in our forked repository. So, change the base repository to our forked repository:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于你正在使用分叉的代码库，GitHub 建议你为源代码库创建一个 PR（在本例中是从 `PacktPublishing`）。我们想要创建一个从我们的
    `pre-prod` 分支到 `main` 分支的 PR，这两个分支都位于我们分叉的代码库中。因此，将基础代码库更改为我们的分叉代码库：
- en: '![Figure 10.20 – Creating a PR ](img/B18015_10_20.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.20 – 创建 PR](img/B18015_10_20.jpg)'
- en: Figure 10.20 – Creating a PR
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.20 – 创建 PR
- en: 'Then, select `pre-prod` in the **compare** field:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 **compare** 字段中选择 `pre-prod`：
- en: '![Figure 10.21 – Creating a PR ](img/B18015_10_21.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.21 – 创建 PR](img/B18015_10_21.jpg)'
- en: Figure 10.21 – Creating a PR
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.21 – 创建 PR
- en: 'Now, fill out the form and click **Create pull request**:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，填写表单并点击 **Create pull request**：
- en: '![Figure 10.22 – Creating a PR ](img/B18015_10_22.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.22 – 创建 PR](img/B18015_10_22.jpg)'
- en: Figure 10.22 – Creating a PR
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.22 – 创建 PR
- en: 'In a real-life scenario, this PR would be reviewed, approved by peers, and
    then merged. We are still practicing at the moment, so let’s go ahead and click
    the **Merge pull request** button:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实际场景中，这个 PR 会被审查、同事审批并合并。我们目前还在练习阶段，因此让我们点击 **Merge pull request** 按钮：
- en: '![Figure 10.23 – Approving the PR ](img/B18015_10_23.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.23 – 审批 PR](img/B18015_10_23.jpg)'
- en: Figure 10.23 – Approving the PR
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.23 – 审批 PR
- en: 'The overlay manifests for version 1.0 of the production environment are already
    in the `main` branch of our Git repository. This means we can deploy it using
    Argo CD:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生产环境版本 1.0 的覆盖清单已经存在于我们 Git 仓库的 `main` 分支中。这意味着我们可以使用 Argo CD 部署它：
- en: '[PRE40]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'At this point, you should have three applications on Argo CD:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到此为止，你应该在 Argo CD 上有三个应用程序：
- en: '![Figure 10.24 – Argo CD applications ](img/B18015_10_24.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.24 – Argo CD 应用程序](img/B18015_10_24.jpg)'
- en: Figure 10.24 – Argo CD applications
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.24 – Argo CD 应用程序
- en: 'Let’s access the application to see version 1.0 of our application running
    in production:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们访问应用程序，查看运行在生产环境中的应用版本 1.0：
- en: '[PRE41]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You should see the same response that you saw previously:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到和之前一样的响应：
- en: '[PRE42]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Congratulations! We have deployed our application using Argo CD into three
    different namespaces, each one representing a different environment: development,
    QA, and production. Since this book is intended to be about *multi-cluster*, we
    must learn how to do the same process but deploy into multiple clusters, instead
    of only one. In the next section, you will see that the process is the same, except
    you must change one parameter in Argo CD’s `Application` object.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们已经使用 Argo CD 将应用程序部署到三个不同的命名空间，每个命名空间代表一个不同的环境：开发、QA 和生产。由于本书旨在讲解*多集群*，我们必须学习如何执行相同的过程，但将应用部署到多个集群，而不是仅仅部署到一个集群。在下一节中，你将看到整个过程相同，唯一的不同是你必须在
    Argo CD 的 `Application` 对象中更改一个参数。
- en: Deploying to multiple clusters
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到多个集群
- en: 'We learned how to register external clusters in the *Configuring Argo CD against
    multiple clusters* section. As soon as you have multiple external clusters registered
    to Argo CD, deploying an application to one of them is simple – you only need
    to refer to the external cluster you registered in the `destination` field of
    Argo CD’s `Application`. An example of this can be seen in the following manifest:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *配置 Argo CD 以支持多集群* 章节中学习了如何注册外部集群。一旦你在 Argo CD 中注册了多个外部集群，部署应用到其中一个集群就变得简单——你只需要在
    Argo CD 的 `Application` 中的 `destination` 字段引用你注册的外部集群。以下清单中展示了一个示例：
- en: '[PRE43]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You can create as many `Application` objects as you need, deploying only to
    the local cluster or including multiple external clusters. As you have seen, the
    deployment process itself is similar, regardless of whether you are deploying
    to a local or external cluster.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要创建多个 `Application` 对象，将应用部署到本地集群或多个外部集群。如你所见，部署过程本身是相似的，无论你是将应用部署到本地集群还是外部集群。
- en: Important Note
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: When you work with multiple clusters, you need to pay special attention to the
    **container image registry**. The OpenShift internal registry, as its name suggests,
    should only be used internally in a single cluster; it is not suitable for multiple
    clusters. In such a case, an enterprise container image registry is recommended.
    There are multiple options on the market, such as Nexus, Quay, Harbor, and many
    others. In this book, we will cover Quay in [*Chapter 13*](B18015_13.xhtml#_idTextAnchor275),
    *OpenShift Plus – a Multi-Cluster Enterprise-Ready Solution*.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 当你与多个集群一起工作时，你需要特别关注 **容器镜像注册表**。正如其名称所示，OpenShift 内部注册表应该只在单个集群内使用；它不适合用于多个集群。在这种情况下，建议使用企业级容器镜像注册表。市场上有多种选择，例如
    Nexus、Quay、Harbor 等等。在本书中，我们将在 [*第 13 章*](B18015_13.xhtml#_idTextAnchor275) 中介绍
    Quay，*OpenShift Plus - 一种多集群企业级解决方案*。
- en: Summary
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about various concepts related to **GitOps**. You
    also learned about **Argo CD** and how to install it on OpenShift and use it.
    You also built and deployed a sample application to three different namespaces
    to simulate the *development*, *QA*, and *production* environments. Finally, you
    learned that deploying to the local or external cluster is a similar process –
    you only need to change the destination server field.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了与 **GitOps** 相关的各种概念。你还学习了 **Argo CD** 以及如何在 OpenShift 上安装并使用它。你还构建并部署了一个示例应用程序到三个不同的命名空间，以模拟
    *开发*、*QA* 和 *生产* 环境。最后，你了解到，无论是部署到本地集群还是外部集群，过程类似——你只需要更改目标服务器字段。
- en: Argo CD allows you to establish an efficient and robust application delivery
    model using GitOps, in which you ensure *consistency*, *auditable changes*, and
    a *secure process*, no matter where you are deploying your applications. And the
    best part is that there is no additional cost to use it since it is included in
    Red Hat OpenShift’s subscription. That said, if you are deploying containerized
    applications on OpenShift, I strongly recommend that you try OpenShift GitOps
    and use the concepts we explored in this chapter.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD 允许你使用 GitOps 建立高效且强大的应用交付模型，在这种模型中，无论你将应用部署到哪里，都能确保*一致性*、*可审计的变更*和*安全的过程*。而最棒的是，它的使用没有额外费用，因为它已经包含在
    Red Hat OpenShift 的订阅中。也就是说，如果你在 OpenShift 上部署容器化应用，我强烈建议你尝试 OpenShift GitOps，并使用我们在本章中探讨的概念。
- en: In the next chapter, we will explore a great tool that will help you deploy
    and manage several OpenShift clusters from a single unified interface – **Red
    Hat Advanced Cluster Management**. This tool allows you to monitor, manage, define,
    and enforce policies and deploy applications to several clusters.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将探讨一个极好的工具，它将帮助你通过单一统一界面部署和管理多个 OpenShift 集群 —— **Red Hat 高级集群管理**。这个工具可以让你监控、管理、定义和执行策略，并向多个集群部署应用。
- en: Let’s move on and take a deep dive into Red Hat Advanced Cluster Management!
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续，深入了解 Red Hat 高级集群管理！
- en: Further reading
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'To find out more about the topics that were covered in this chapter, take a
    look at the following resources:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解本章所涵盖的主题，请查看以下资源：
- en: '*A History of GitOps:* [https://www.weave.works/blog/the-history-of-gitops](https://www.weave.works/blog/the-history-of-gitops
    )'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GitOps 的历史：* [https://www.weave.works/blog/the-history-of-gitops](https://www.weave.works/blog/the-history-of-gitops)'
- en: '*Argo CD official documentation:* [https://argo-cd.readthedocs.io/](https://argo-cd.readthedocs.io/)'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Argo CD 官方文档：* [https://argo-cd.readthedocs.io/](https://argo-cd.readthedocs.io/)'
- en: '*Great tutorial about* **Kustomize**: [https://blog.stack-labs.com/code/kustomize-101/](https://blog.stack-labs.com/code/kustomize-101/)'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*关于* **Kustomize** 的优秀教程：[https://blog.stack-labs.com/code/kustomize-101/](https://blog.stack-labs.com/code/kustomize-101/)'
- en: '*Bitnami’s Sealed Secrets overview:* [https://github.com/bitnami-labs/sealed-secret](https://github.com/bitnami-labs/sealed-secrets).'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Bitnami 的 Sealed Secrets 概述：* [https://github.com/bitnami-labs/sealed-secret](https://github.com/bitnami-labs/sealed-secrets)。'
