- en: Chapter 3. Going Further with Terraform
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章：深入了解 Terraform
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Handling different environments with Terraform
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Terraform 处理不同环境
- en: Provisioning a CentOS 7 EC2 instance with Chef using Terraform
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Terraform 配置带有 Chef 的 CentOS 7 EC2 实例
- en: Using data sources, templates, and local execution
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据源、模板和本地执行
- en: Executing remote commands at bootstrap using Terraform
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Terraform 在引导过程中执行远程命令
- en: Using Docker with Terraform
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Terraform 中使用 Docker
- en: Simulating infrastructure changes using Terraform
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Terraform 模拟基础设施更改
- en: Teamwork – sharing Terraform infrastructure state
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队协作 —— 共享 Terraform 基础设施状态
- en: Maintaining a clean and standardized Terraform code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护清晰且标准化的 Terraform 代码
- en: One Makefile to rule them all
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Makefile 来管理所有
- en: Team workflow example
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队工作流示例
- en: Managing GitHub with Terraform
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Terraform 管理 GitHub
- en: External monitoring integration with StatusCake
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 StatusCake 的外部监控集成
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we'll go beyond the essentials of using Terraform we covered
    in [Chapter 2](ch02.html "Chapter 2. Provisioning IaaS with Terraform"), *Provisioning
    IaaS with Terraform*. We'll discover many important techniques to use Terraform
    in conjunction with other players in the field such as Docker and Chef, how it
    can be used in multiple environments (such as development/staging/production),
    how powerful it can be to manage not only infrastructure but many SaaS as well,
    and how to integrate the tool within a team workflow (sharing, synchronizing,
    maintaining, harmonizing, and so on). These topics are all equally important,
    as they will define the quality of our daily work and our ability to interact
    with other people, services, and systems.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将超越在[第二章](ch02.html "第二章：使用 Terraform 配置 IaaS")中涵盖的 Terraform 使用基础知识，*使用
    Terraform 配置 IaaS*。我们将探索许多重要的技巧，如何将 Terraform 与 Docker 和 Chef 等其他工具结合使用，如何在多个环境中使用（如开发/阶段/生产），它如何在管理基础设施以及许多
    SaaS 时展现强大的能力，如何将该工具集成到团队工作流中（共享、同步、维护、协调等）。这些话题都同样重要，因为它们将决定我们日常工作的质量以及我们与他人、服务和系统的互动能力。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Terraform version in use for this book is 0.7.3.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用的 Terraform 版本是 0.7.3。
- en: Handling different environments with Terraform
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Terraform 处理不同环境
- en: 'It''s a common and recommended setup to have different infrastructure environments,
    with some level of parity. Those environments can vary greatly between companies
    and projects in both names and focus, but here are commonly found environments:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有不同的基础设施环境，并使它们具有一定的相似性是常见且推荐的设置。这些环境在公司和项目中可能有很大差异，无论是在名称上还是重点上，但通常可以找到以下几种环境：
- en: 'Development: where developers can implement and quickly test new features'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发：开发人员可以在此实现并快速测试新功能
- en: 'Staging: where the new features are tested in a more consistent environment
    than the development one, sometimes very similar to a preproduction environment'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阶段环境：在比开发环境更一致的环境中测试新功能，有时非常类似于预生产环境
- en: 'Preproduction: this environment is the most similar possible to production'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预生产环境：此环境与生产环境尽可能相似
- en: 'Production: the full-featured live production environment'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产环境：完整功能的实时生产环境
- en: We'll see how using infrastructure-as-code and especially how Terraform fundamentally
    helps to build strong and replicated environments. This time we'll use a CoreOS
    AMI for a change.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到，使用基础设施即代码，尤其是 Terraform 如何从根本上帮助构建强大且可复制的环境。这一次，我们将使用 CoreOS AMI 作为改变。
- en: Getting ready
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此配方，您需要以下内容：
- en: A working Terraform installation
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可用的 Terraform 安装
- en: An AWS account with an SSH key configured in Terraform (refer to the [Chapter
    2](ch02.html "Chapter 2. Provisioning IaaS with Terraform"), *Provisioning IaaS
    with Terraform,* recipes)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置了 SSH 密钥的 AWS 账户并在 Terraform 中配置（参见[第二章](ch02.html "第二章：使用 Terraform 配置 IaaS")，*使用
    Terraform 配置 IaaS*的配方）
- en: An Internet connection
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网连接
- en: How to do it…
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: Using infrastructure-as-code, the easiest thing is to simply duplicate the code
    to create as many environments as needed. However, there's a much more powerful
    way to leverage the full capabilities of Terraform.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基础设施即代码，最简单的做法是简单地复制代码以创建所需数量的环境。然而，还有一种更强大的方式，可以充分利用 Terraform 的全部能力。
- en: 'Let''s define the requirements of simple target environments that we''ll translate
    into dynamic Terraform code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义简单目标环境的需求，并将其转换为动态的 Terraform 代码：
- en: '| Parameter | Staging | Production |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 阶段环境 | 生产环境 |'
- en: '| --- | --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Number of instances** | 1 | 3 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| **实例数量** | 1 | 3 |'
- en: '| **Type of instance** | `t2.micro` | `t2.medium` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **实例类型** | `t2.micro` | `t2.medium` |'
- en: '| **Operating system** | CoreOS Stable | CoreOS Stable |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **操作系统** | CoreOS Stable | CoreOS Stable |'
- en: '| **AMI in eu-west-1** | `ami-85097ff6` | `ami-85097ff6` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| **eu-west-1 区域的 AMI** | `ami-85097ff6` | `ami-85097ff6` |'
- en: '| **AMI in us-east-1** | `ami-0aef8e1d` | `ami-0aef8e1d` |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **us-east-1 区域的 AMI** | `ami-0aef8e1d` | `ami-0aef8e1d` |'
- en: '| **S3 bucket naming** | iacbook-staging | iacbook-production |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **S3 存储桶命名** | iacbook-staging | iacbook-production |'
- en: '| **Default environment** | Yes | No |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **默认环境** | 是 | 否 |'
- en: Let's start by declaring those variables in the `variables.tf` file, exactly
    as we' saw in [Chapter 2](ch02.html "Chapter 2. Provisioning IaaS with Terraform"),
    *Provisioning laaS with Terraform*, except we'll describe environments such as
    *staging* and *production* instead of the AWS regions for the cluster size and
    instance types.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在 `variables.tf` 文件中声明这些变量开始，正如我们在[第 2 章](ch02.html "第 2 章：使用 Terraform
    配置 IaaS")中看到的那样，*使用 Terraform 配置 IaaS*，不同的是这次我们将描述像 *staging* 和 *production* 这样的环境，而不是
    AWS 区域用于集群大小和实例类型的定义。
- en: 'Define the CoreOS AMI variable:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 CoreOS AMI 变量：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Define a cluster size variable with different values according to the environment:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 根据环境定义集群大小变量：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, define the different AWS instance types:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，定义不同的 AWS 实例类型：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now let''s use those in a highly dynamic infrastructure code (`instances.tf`),
    using the `aws_instance` resource and by choosing automatically the correct cluster
    size and instance type according to the environment, while choosing the right
    AMI according to the execution region:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在一个高度动态的基础设施代码（`instances.tf`）中使用这些变量，使用 `aws_instance` 资源，并根据环境自动选择正确的集群大小和实例类型，同时根据执行区域选择合适的
    AMI：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We constructed each instance `Name` tag according to its environment and its
    numerical value in the count (that is, `coreos_production_2`).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据环境和实例计数的数值（即 `coreos_production_2`）构建了每个实例的 `Name` 标签。
- en: 'Our specification table indicates we need two different S3 buckets as well.
    Let''s reuse in `s3.tf` something close to what we did in [Chapter 2](ch02.html
    "Chapter 2. Provisioning IaaS with Terraform"), *Provisioning IaaS with Terraform*:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的规格表还表明我们需要两个不同的 S3 存储桶。让我们在 `s3.tf` 文件中重用一些在[第 2 章](ch02.html "第 2 章：使用 Terraform
    配置 IaaS")中做过的类似操作，*使用 Terraform 配置 IaaS*：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It's the same construction here, each environment will get its bucket dynamically
    named after it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的构建方式相同，每个环境会动态生成一个与其相关联的存储桶。
- en: Keeping the tfstate isolated
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保持 tfstate 文件隔离
- en: 'It''s strongly recommended to **not mix** Terraform state files between environments.
    One elegant solution to keep them well separated is to use the following option
    when executing the `terraform` command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议**不要混合**不同环境的 Terraform 状态文件。为了保持它们良好的隔离，执行 `terraform` 命令时使用以下选项是一个优雅的解决方案：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Your default environment (set to staging) will now reside in the `staging.tfstate`
    file.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你的默认环境（设置为暂存环境）现在将存储在 `staging.tfstate` 文件中。
- en: Setting the production flag
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置生产环境标志
- en: 'Now we have our staging infrastructure running smoothly, it''s time to launch
    the real thing—the production environment. As we''re already using a dedicated
    terraform state file, let''s do the same for production, and set the `environment`
    variable directly through the command line:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的暂存基础设施运行顺利，是时候启动正式环境——生产环境了。由于我们已经在使用一个专用的 terraform 状态文件，我们也为生产环境做同样的设置，并通过命令行直接设置
    `environment` 变量：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You now have two clearly separated environments using the very same code, but
    living independently from each other. Concise and elegant!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你拥有两个清晰分离的环境，使用相同的代码，但彼此独立运行。简洁而优雅！
- en: Provisioning a CentOS 7 EC2 instance with Chef using Terraform
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Terraform 通过 Chef 配置一个 CentOS 7 EC2 实例
- en: Once the underlying infrastructure is generated by Terraform, chances are the
    job isn't already finished. That's the moment a configuration management tool
    such as Chef, Ansible, or Puppet enters the game, to provision the virtual machine.
    Thankfully, Chef is a first class provisioning tool in Terraform. We'll see here
    how to fully bootstrap a CentOS 7.2 instance on AWS with Terraform, from nothing
    to a fully configured node, by gracefully handing over the configuration to Chef
    after having it automatically deployed and registered on Hosted Chef.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Terraform生成了底层基础设施，任务可能还没有完成。这时，像Chef、Ansible或Puppet这样的配置管理工具就派上了用场，来配置虚拟机。幸运的是，Chef是Terraform中的一流配置工具。接下来我们将看到如何通过Terraform从头开始在AWS上完全引导一个CentOS
    7.2实例，从空白到一个完全配置的节点，并且在自动部署和注册到Hosted Chef之后，优雅地将配置交给Chef。
- en: If it's the first time you've launched CentOS 7 servers on AWS, you have to
    agree their terms and conditions at [https://aws.amazon.com/marketplace/pp/B00O7WM7QW](https://aws.amazon.com/marketplace/pp/B00O7WM7QW).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是您第一次在AWS上启动CentOS 7服务器，您必须同意它们的条款和条件，地址是[https://aws.amazon.com/marketplace/pp/B00O7WM7QW](https://aws.amazon.com/marketplace/pp/B00O7WM7QW)。
- en: Getting ready
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此配方，您将需要以下内容：
- en: A working Terraform installation
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的Terraform安装
- en: An AWS account with an SSH key configured in Terraform and a security group
    allowing SSH connections from outside (refer to the [Chapter 2](ch02.html "Chapter 2. Provisioning
    IaaS with Terraform"), *Provisioning IaaS with Terraform,* recipes)
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要一个配置了SSH密钥的AWS账户，并且有一个安全组允许外部SSH连接（参见[第2章](ch02.html "第2章：使用Terraform配置IaaS")，*使用Terraform配置IaaS*配方）
- en: An account on a Chef server (we recommend using a free hosted Chef account.
    Please refer to the *Creating a free hosted server Chef account and a Puppet server*
    recipe of [Chapter 6](ch06.html "Chapter 6. Fundamentals of Managing Servers with
    Chef and Puppet"), *Fundamentals of Managing Servers with Chef and Puppet*), with
    the default cookbook uploaded
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Chef服务器上的账户（我们推荐使用免费的托管Chef账户。请参考[第6章](ch06.html "第6章：使用Chef和Puppet管理服务器的基础知识")，*使用Chef和Puppet管理服务器的基础知识*配方），并且上传了默认的Cookbook
- en: An Internet connection
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要一个互联网连接
- en: How to do it…
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'As there''re a lot of sources involved, let''s put all the required information
    in a table (the Chef information is taken from the Chef Starter Kit, or your own
    Chef server, fill in your own values):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于涉及到许多来源，让我们将所有所需的信息放入一个表格中（Chef信息来自Chef入门套件，或您的Chef服务器，填写您自己的值）：
- en: '| **Hostname** | `centos-1` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| **主机名** | `centos-1` |'
- en: '| --- | --- |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **Instance type** | `t2.micro` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **实例类型** | `t2.micro` |'
- en: '| **AMI in eu-west-1** | ami-7abd0209 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| **eu-west-1中的AMI** | ami-7abd0209 |'
- en: '| **AMI in us-east-1** | ami-6d1c2007 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **us-east-1中的AMI** | ami-6d1c2007 |'
- en: '| **SSH username** | centos |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| **SSH用户名** | centos |'
- en: '| **SSH key** | `keys/aws_terraform` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| **SSH密钥** | `keys/aws_terraform` |'
- en: '| **TCP ports needed** | 22 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| **所需TCP端口** | 22 |'
- en: '| **Cookbook(s) to apply** | starter |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| **应用的Cookbook** | starter |'
- en: '| **Chef server URL** | [https://api.chef.io/organizations/iacbook](https://api.chef.io/organizations/iacbook)
    |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| **Chef服务器URL** | [https://api.chef.io/organizations/iacbook](https://api.chef.io/organizations/iacbook)
    |'
- en: '| **Validation key** | `iacbook.pem` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| **验证密钥** | `iacbook.pem` |'
- en: '| **Validation client name** | iacbook |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| **验证客户端名称** | iacbook |'
- en: '| **Chef client version** | 12.13.37 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **Chef客户端版本** | 12.13.37 |'
- en: 'Let''s start by declaring our AMIs as a map in the `variables.tf` file:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先在`variables.tf`文件中声明我们的AMI映射：
- en: '[PRE7]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now add the instance type in the same file:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在同一个文件中添加实例类型：
- en: '[PRE8]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Declare the Chef version we''re currently using in production, so it''s stable
    and stays the same:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明我们当前在生产中使用的Chef版本，以便它保持稳定并不变：
- en: '[PRE9]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Declare the Chef server URL. If you''re using the book example with hosted
    Chef, you''ll find the correct address in the `knife.rb` file: it''s simply [https://api.chef.io/organizations/<your_organization_name>](https://api.chef.io/organizations/<your_organization_name>),
    otherwise, use your own Chef server):'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明Chef服务器的URL。如果您使用的是书中的托管Chef示例，您可以在`knife.rb`文件中找到正确的地址：它就是[https://api.chef.io/organizations/<your_organization_name>](https://api.chef.io/organizations/<your_organization_name>)，否则，使用您自己的Chef服务器：
- en: '[PRE10]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, add the *validation client* name for the Chef server:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加Chef服务器的*验证客户端*名称：
- en: '[PRE11]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To connect to the instance, we know the default username is `centos`, but as
    it can evolve or you may use your own images, it''s better to fix it in a variable
    as well:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要连接到实例，我们知道默认的用户名是`centos`，但由于它可能会变化，或者您可能会使用自己的镜像，因此最好也将其固定在变量中：
- en: '[PRE12]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Creating the EC2 instance
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 EC2 实例
- en: 'We know from previous recipes that a basic instance running CentOS looks like
    this in Terraform''s `instances.tf` using a security group named `base_security_group`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从之前的示例中知道，运行 CentOS 的基本实例在 Terraform 的 `instances.tf` 中看起来像这样，使用名为 `base_security_group`
    的安全组：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we need to provide two kinds of information to our Terraform file: what
    to do with Chef on the server and how to connect to it.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要为 Terraform 文件提供两种信息：在服务器上使用 Chef 的方式，以及如何连接到它。
- en: Passing connection information
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递连接信息
- en: 'To tell Terraform how to connect itself to the new EC2 instance, we use a `connection
    {}` block inside the `aws_instance` resource to tell it which user and key to
    use through SSH:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了告诉 Terraform 如何连接到新的 EC2 实例，我们在 `aws_instance` 资源内使用 `connection {}` 块，告诉它通过
    SSH 使用哪个用户和密钥：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Giving Chef information
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向 Chef 提供信息
- en: We need to give some information to Terraform to pass it on to Chef. This will
    all happen inside a `provisioner "chef" {}` block inside the `aws_instance` resource.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向 Terraform 提供一些信息，以便它可以传递给 Chef。这一切都会发生在 `aws_instance` 资源内的 `provisioner
    "chef" {}` 块中。
- en: 'Using all the variables we declared, here''s how it looks:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们声明的所有变量，下面是它的样子：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Don't forget to use a valid path for the validation key!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了使用有效的路径来验证密钥！
- en: Now you can `terraform apply` this and see everything happen, from instance
    creation to Chef Client deployment and cookbook installation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以运行 `terraform apply`，看到从实例创建到 Chef 客户端部署和 cookbook 安装的一切过程。
- en: How it works…
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: First, Terraform creates the required AWS environment (keys, security groups,
    and instances), and once the instance is running, it connects to it with the right
    credentials by SSH, then deploys the specified Chef client version from the official
    source, and finally executes an initial chef-client run that registers the node
    on the Chef server and applies the requested cookbooks.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Terraform 创建所需的 AWS 环境（密钥、安全组和实例），一旦实例运行，它会通过 SSH 以正确的凭证连接到它，然后从官方源部署指定的
    Chef 客户端版本，最后执行初始的 chef-client 运行，将节点注册到 Chef 服务器并应用请求的 cookbook。
- en: There's more…
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: A lot more configuration options are possible for the Chef provisioner inside
    Terraform. For example, all available chef-client options can be passed as an
    array using `client_options`, and the Chef environment (usually very important)
    is passed using `environment` as a string. If you use a custom built image with
    the Chef client already baked in, you will be interested in setting `skip_install`
    to `true` so it doesn't get reinstalled.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Terraform 内部的 Chef 提供者，还可以进行更多的配置选项。例如，可以通过 `client_options` 将所有可用的 chef-client
    选项作为数组传递，而 Chef 环境（通常非常重要）则通过 `environment` 作为字符串传递。如果你使用了已经集成 Chef 客户端的自定义镜像，那么你可能会想设置
    `skip_install` 为 `true`，以避免重新安装。
- en: Using data sources, templates, and local execution
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据源、模板和本地执行
- en: When we deploy or update an infrastructure with Terraform, it's sometimes enjoyable
    to have some local content dynamically generated. For example, if you want to
    provision with Ansible the new virtual machine launched by Terraform, chances
    are you'll need to populate a `hosts` file with the public IP address of this
    host locally on your laptop.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 Terraform 部署或更新基础设施时，有时会很享受动态生成一些本地内容。例如，如果你希望使用 Ansible 来配置 Terraform
    启动的新虚拟机，那么你可能需要在本地的笔记本电脑上填充一个 `hosts` 文件，内容是该主机的公共 IP 地址。
- en: Ansible can use some dynamic inventories with AWS by itself, but we'll see here
    how to use a template in Terraform and dynamically fill in the required information
    so we end up with a working Ansible setup, thanks to Terraform.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 可以通过自身使用一些 AWS 动态库存，但在这里我们将看到如何在 Terraform 中使用模板，并动态填充所需的信息，最终实现一个有效的
    Ansible 设置，这都得益于 Terraform。
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To step through this recipe, you will need the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本教程，你需要以下内容：
- en: A working Terraform installation
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的 Terraform 安装
- en: An AWS account with an SSH key configured in Terraform and a security group
    allowing SSH connections from outside (refer to the [Chapter 2](ch02.html "Chapter 2. Provisioning
    IaaS with Terraform"), *Provisioning IaaS with Terraform* recipes)
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 AWS 账户，已经在 Terraform 中配置了 SSH 密钥，并且安全组允许来自外部的 SSH 连接（参考 [第 2 章](ch02.html
    "第 2 章：使用 Terraform 配置 IaaS")，*使用 Terraform 配置 IaaS* 章节）
- en: An Internet connection
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个互联网连接
- en: How to do it…
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'Let''s start by launching a standard CentOS 7.2 on AWS with a standard set
    of variables in `variables.tf`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先在 AWS 上启动一个标准的 CentOS 7.2，并使用 `variables.tf` 中的一组标准变量：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here''s the simplest `instances.tf` file to launch the instance:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是启动实例的最简单的 `instances.tf` 文件：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Data and templates
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据和模板
- en: 'Now, how does a typical `hosts` file look for Ansible? It looks like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Ansible 的典型 `hosts` 文件是什么样的呢？它看起来像这样：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So, later, Ansible will apply whatever role is needed for each server of each
    section.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，稍后，Ansible 会根据每个部分的每台服务器应用需要的角色。
- en: 'In our case, we want a simple section named `centos7_hosts` and the servers
    IP as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们需要一个简单的部分，命名为 `centos7_hosts`，并包含服务器的 IP 地址，如下所示：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s construct our first template named `hosts.tpl` with a variable named
    `host_public_ipv4` that will ultimately be replaced by the real future IP of the
    host we''ll later launch:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建第一个名为 `hosts.tpl` 的模板，模板中有一个变量 `host_public_ipv4`，最终会被我们稍后启动的主机的真实 IP 地址替换：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To generate this file, we''ll use a template with a variable in it, that Terraform
    will generate for us, using a `data` resource in `data.tf`—it simply contains
    the file interpolation of our template and passes it the variable we need from
    our AWS instance:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成这个文件，我们将使用一个包含变量的模板，Terraform 会为我们生成它，使用 `data` 资源在 `data.tf` 中——它简单地包含了我们模板的文件插值，并从我们的
    AWS 实例中传递所需的变量：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The local-exec Terraform provisioner
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地执行的 Terraform 配置器
- en: 'This generates the template internally, meaning the data is available, but
    not dumped anywhere. That''s where the `local-exec` provisioner comes in, by simply
    echoing the rendered template from the data source into the file we want (in `data.tf`):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程在内部生成模板，意味着数据已经可用，但不会被直接输出到任何地方。此时，`local-exec` 配置器就派上用场了，它通过简单地将渲染后的模板从数据源回显到我们想要的文件中（在
    `data.tf` 中）：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We use `"null_resource"` for this purpose, so the generation of the template
    is independent of any other executing resource. In other situations, we can perfectly
    use the `"local-exec" { }` provisioner directly from inside a standard resource.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `"null_resource"` 来实现这一目的，这样模板的生成就不依赖于任何其他执行的资源。在其他情况下，我们可以直接在标准资源内部使用
    `"local-exec" { }` 配置器。
- en: 'We can now `terraform apply` this setup. How does our `hosts` file look? Like
    this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行 `terraform apply` 来应用这个配置。我们的 `hosts` 文件看起来如何？像这样：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It's correctly populated!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 它已正确填充！
- en: Apply a configured Ansible
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用配置好的 Ansible
- en: 'Our code repository is now ready for use by Ansible. Here''s a sample Ansible
    role that simply installs Docker and starts it, so we can play with it, under
    `ansible/main.yml`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码仓库现在已经准备好供 Ansible 使用了。这里是一个示例 Ansible 角色，简单地安装并启动 Docker，这样我们就可以开始使用它，文件位于
    `ansible/main.yml`：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now you just have to execute Ansible when you want, it is all ready and configured!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需要在你需要的时候执行 Ansible，一切都已准备好并配置完成！
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Executing remote commands at bootstrap using Terraform
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Terraform 执行远程命令以进行引导
- en: It's a very common practice to have a set of initial commands executed right
    after bootstrap, even before the proper configuration management system such as
    Chef or Ansible takes responsibility. It can include immediate full updating of
    the OS, initial registration on discovery systems such as Consul, or initial addition
    of local DNS servers. It really shouldn't go farther than delivering a system
    in a slightly more advanced and expected state for the next configuration system
    to take over. Under no circumstance should it replace a proper configuration management
    tool.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动后立即执行一组初始命令是非常常见的做法，甚至在正确的配置管理系统（如 Chef 或 Ansible）接管之前。它可以包括操作系统的完整更新、在发现系统（如
    Consul）上的初始注册，或初步添加本地 DNS 服务器。它的目的是将系统交付到一个更高级别和预期的状态，以便下一个配置系统接管。绝对不应替代合适的配置管理工具。
- en: In this recipe, we'll launch a CentOS 7.2 system, then fully update it so it's
    as secure as possible, install EPEL so we have a greater library of available
    packages, add the Puppet Labs Yum repository and install a Puppet agent, and add
    a different name server so our system is ready for the next step (which we won't
    cover here, as it's probably executing Puppet code).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将启动一个 CentOS 7.2 系统，然后对其进行完全更新，使其尽可能安全，安装 EPEL 以获得更丰富的包库，添加 Puppet
    Labs Yum 仓库并安装 Puppet 代理，并添加一个不同的名称服务器，以便我们的系统准备好进行下一步（我们在这里不涵盖这个步骤，因为它可能是在执行
    Puppet 代码）。
- en: Getting ready
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步完成这个食谱，你将需要以下内容：
- en: A working Terraform installation
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的 Terraform 安装
- en: An AWS account with an SSH key configured in Terraform and a security group
    allowing SSH connections from outside (refer to the [chapter 2](ch02.html "Chapter 2. Provisioning
    IaaS with Terraform"), *Provisioning IaaS with Terraform* recipes)
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个配置了 SSH 密钥的 AWS 账户，在 Terraform 中，并且安全组允许来自外部的 SSH 连接（参见[第 2 章](ch02.html "第
    2 章：使用 Terraform 提供 IaaS")，*使用 Terraform 提供 IaaS* 配方）
- en: An Internet connection
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条互联网连接
- en: How to do it…
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Before diving into the provisioning part, let''s start by describing a classic
    CentOS 7.2 AMI in `instances.tf`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入到提供部分之前，让我们先在 `instances.tf` 中描述一个经典的 CentOS 7.2 AMI：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The variables in the `variables.tf` file are as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`variables.tf` 文件中的变量如下：'
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, what are our immediate objectives for this system?:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们对这个系统的直接目标是什么？：
- en: 'Fully update it: `sudo yum install -y`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全更新：`sudo yum install -y`
- en: 'Enable the EPEL repository: `sudo yum install epel-release -y`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用 EPEL 仓库：`sudo yum install epel-release -y`
- en: 'Add a custom name server: `echo "nameserver 8.8.8.8" | sudo tee -a /etc/resolv.conf`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加自定义名称服务器：`echo "nameserver 8.8.8.8" | sudo tee -a /etc/resolv.conf`
- en: 'Add the Puppet Labs repository: `sudo yum install https://yum.puppetlabs.com/puppetlabs-release-pc1-el-7.noarch.rpm
    -y`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 Puppet Labs 仓库：`sudo yum install https://yum.puppetlabs.com/puppetlabs-release-pc1-el-7.noarch.rpm
    -y`
- en: 'Install the Puppet agent: `sudo yum install puppet-agent -y`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Puppet agent：`sudo yum install puppet-agent -y`
- en: 'Display the Puppet version: `sudo /opt/puppetlabs/bin/puppet agent --version`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示 Puppet 版本：`sudo /opt/puppetlabs/bin/puppet agent --version`
- en: 'Let''s add those commands inside a `remote-exec` provisioner inside our `aws_instance`
    resource, changing the default username to `centos`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些命令添加到 `aws_instance` 资源中的 `remote-exec` 提供者中，并将默认用户名更改为 `centos`：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When you `terraform apply` this, you'll end up with a fully updated CentOS 7.2
    system, with EPEL available, a custom DNS server added and Puppet agent installed.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行 `terraform apply` 时，你将得到一个完全更新的 CentOS 7.2 系统，EPEL 可用，添加了自定义 DNS 服务器，并且安装了
    Puppet agent。
- en: Ready for the next stage of deployment with Puppet!
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为 Puppet 的下一个部署阶段做好准备！
- en: Using Docker with Terraform
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 和 Terraform
- en: Terraform can also be used to manipulate Docker. The classical usage is against
    an already running Docker server on the network, but it will work exactly the
    same locally with your own Docker installation. Using Terraform for controlling
    Docker, we'll be able to dynamically trigger Docker image updates, execute containers
    with every imaginable option, manipulate Docker networks, and use Docker volumes.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 也可以用于操作 Docker。传统的用法是与已经运行的 Docker 服务器进行交互，但在本地使用你自己的 Docker 安装时也可以完全一样。使用
    Terraform 控制 Docker，我们将能够动态触发 Docker 镜像更新，执行带有各种选项的容器，操作 Docker 网络，并使用 Docker
    卷。
- en: 'Here, we''ll deploy an isolated blog container (Ghost) that will be publicly
    served by the `nginx-proxy` container over HTTP. This very useful `nginx-proxy`
    container is proposed by Jason Wilder from InfluxDB on his GitHub: [https://github.com/jwilder/nginx-proxy](https://github.com/jwilder/nginx-proxy).'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将部署一个孤立的博客容器（Ghost），它将通过 `nginx-proxy` 容器公开服务，并通过 HTTP 提供服务。这个非常有用的 `nginx-proxy`
    容器由 InfluxDB 的 Jason Wilder 在他的 GitHub 上提出：[https://github.com/jwilder/nginx-proxy](https://github.com/jwilder/nginx-proxy)。
- en: Getting ready
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此配方，你将需要以下内容：
- en: A working Terraform installation.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的 Terraform 安装。
- en: A working Docker installation (native Docker for Mac, Docker Engine on Linux,
    a remote server running Docker on TCP, and so on). Docker 1.12 is used for this
    recipe.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的 Docker 安装（Mac 的原生 Docker，Linux 上的 Docker 引擎，运行 Docker 的远程服务器等）。本配方使用
    Docker 1.12。
- en: An Internet connection.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条互联网连接。
- en: How to do it…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Before starting to code anything using Terraform, ensure you can connect to
    any kind of Docker Engine, local or remote:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用 Terraform 编写代码之前，确保你能够连接到任何类型的 Docker 引擎，无论是本地还是远程：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you have issues at this point, you need to fix them before going further.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此时遇到问题，需要在继续之前解决这些问题。
- en: Our goal is to serve, through an `nginx-proxy` container, a blog container (Ghost)
    that will not be directly available on the network.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是通过 `nginx-proxy` 容器提供一个博客容器（Ghost），该容器不会直接在网络上提供服务。
- en: 'If you''re connecting to a remote Docker server, you need to configure the
    Docker provider (maybe in `provider.tf`). Alternatively, it can use the `DOCKER_HOST`
    environment variable, or just the local daemon if not specified. When using locally
    for this exercise, you can just forget about including the provider:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你连接的是远程 Docker 服务器，你需要配置 Docker 提供者（可能在 `provider.tf` 中）。另外，它也可以使用 `DOCKER_HOST`
    环境变量，或者如果没有指定，则使用本地守护进程。对于本练习中的本地使用，你可以直接忽略包含提供者：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s start by declaring two data sources for each of our Docker images (in
    `docker.tf`). The `ghost` image will be in its `0.10` version tag, while `nginx-proxy`
    will use the `0.4.0` version tag. Using a data source will help us manipulate
    the image later:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`docker.tf`中声明两个数据源，分别对应我们的Docker镜像。`ghost`镜像将使用其`0.10`版本标签，而`nginx-proxy`将使用`0.4.0`版本标签。使用数据源有助于我们稍后操作镜像：
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now that we can access the image, let''s exactly do that, using the `docker_image`
    resource. We''re reusing all the information our data source is exposing to us,
    such as the image name or its SHA256, so we know if a new image is available to
    pull:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以访问镜像了，接下来就照做，使用`docker_image`资源。我们将重用我们的数据源所提供的所有信息，如镜像名称或其SHA256值，这样我们就知道是否有新镜像可供拉取：
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s now declare the private Ghost container (without any port mapping),
    using the `docker_container` resource. Let''s use the image we just declared through
    the `docker_image` resource, and export an environment variable named `VIRTUAL_HOST`,
    to be used by the nginx-proxy container (refer to the nginx-proxy documentation
    for more information). Replace with the host you want if you''re not running against
    a local Docker host:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们声明私人Ghost容器（没有任何端口映射），使用`docker_container`资源。我们将使用刚才声明的`docker_image`资源中的镜像，并导出一个名为`VIRTUAL_HOST`的环境变量，供nginx-proxy容器使用（更多信息请参考nginx-proxy文档）。如果你不是在本地Docker主机上运行，请替换为你想使用的主机：
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now let''s start the `nginx-proxy` container. We know from its documentation
    that it needs to share the Docker socket in read-only mode (`/var/run/docker.sock`)
    to dynamically access the running containers, and we want it to run on the default
    HTTP port (`tcp`/`80`). Let''s do that:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们启动`nginx-proxy`容器。我们从它的文档中知道，它需要以只读模式共享Docker套接字(`/var/run/docker.sock`)，以动态访问正在运行的容器，并且我们希望它运行在默认的HTTP端口(`tcp`/`80`)上。我们来实现这一点：
- en: '[PRE34]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now if you `terraform apply` this, you can navigate over to `http://localhost/admin`
    (replace `localhost` with the Docker server you used) and set up your Ghost blog!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你执行`terraform apply`，你可以访问`http://localhost/admin`（将`localhost`替换为你使用的Docker服务器地址），并设置你的Ghost博客！
- en: '![How to do it…](img/B05671_03_01.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/B05671_03_01.jpg)'
- en: Simulating infrastructure changes using Terraform
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Terraform模拟基础设施变更
- en: In an earlier recipe, you learned how to manage different environments with
    Terraform, which is great. But how do we test for changes before applying them?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的教程中，你已经学会了如何使用Terraform管理不同的环境，这很好。但我们如何在应用更改之前测试它们呢？
- en: Terraform has a great internal mechanism that allows us to *plan* for changes
    by comparing what our infrastructure code wants and what the remote state includes.
    That way, we can safely check whether what we thought was a minor modification
    in our code has in fact a destructive impact (sometimes, some parameters in a
    resource trigger a full destruction of the resource!).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform有一个很棒的内部机制，可以通过比较我们的基础设施代码期望的内容和远程状态包含的内容来*规划*变更。这样，我们就能安全地检查，我们认为代码中的小改动是否实际上会带来破坏性影响（有时候，资源中的某些参数会触发资源的完全销毁！）。
- en: We'll cover different ways of anticipating, simulating, and targeting changes
    in our infrastructure, as an added safety check before applying the changes for
    good.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍如何通过不同的方式预测、模拟和定位基础设施中的变更，这是在正式应用更改之前的一种额外安全检查。
- en: Getting ready
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照这个教程进行操作，你需要以下内容：
- en: A working Terraform installation
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可用的Terraform安装
- en: An AWS account with an SSH key configured in Terraform (refer to the [Chapter
    2](ch02.html "Chapter 2. Provisioning IaaS with Terraform"), *Provisioning IaaS
    with Terraform* recipes)
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置了SSH密钥的AWS账户（请参阅[第二章](ch02.html "第二章。使用Terraform配置IaaS")，*使用Terraform配置IaaS*教程）
- en: An Internet connection
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个互联网连接
- en: How to do it…
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Let''s start with a simple CoreOS machine on AWS. We know the AMI ID, we want
    a single `t2.micro` host. Let''s put that information in the `variables.tf` file:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个简单的CoreOS机器开始，这台机器部署在AWS上。我们知道AMI ID，我们需要一个单独的`t2.micro`主机。我们把这些信息放到`variables.tf`文件中：
- en: '[PRE35]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The simplest `aws_instance` resource we can make is the following in `instances.tf`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建的最简单的`aws_instance`资源如下，位于`instances.tf`中：
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Planning
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规划
- en: 'Until now, we''ve used `terraform apply` for immediate action. There''s another
    command: `terraform plan`. It does what it says. It plans for changes, but doesn''t
    apply them:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我们已经使用`terraform apply`进行即时操作。还有另一个命令：`terraform plan`。它正如其名所示。它会计划变更，但不会应用这些变更：
- en: '[PRE37]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: So, by planning before applying, we can know what's about to happen to our infrastructure.
    We're happy about an instance with the right AMI being created, so let's `terraform
    apply`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过在应用之前进行计划，我们可以知道我们的基础设施将会发生什么变化。我们对将创建一个使用正确AMI的实例感到满意，所以让我们执行`terraform
    apply`。
- en: 'Now the infrastructure is created, if you run a plan again, it will say nothing
    should be modified:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在基础设施已经创建完成，如果你再次运行计划，它会说没有需要修改的内容：
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: A normally operating infrastructure should always be in a state where a `terraform
    plan` doesn't want to change anything.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正常运行的基础设施应该始终处于一个状态，`terraform plan`不需要更改任何内容。
- en: 'Now let''s say we need our infrastructure to evolve, and create an S3 bucket.
    That would look like this in a file named `s3.tf`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们需要让我们的基础设施发展，并创建一个S3存储桶。这在名为`s3.tf`的文件中应该是这样的：
- en: '[PRE39]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We''re not sure about what''s about to happen, so let''s plan with Terraform,
    so it''s telling us exactly what it''s intending to do:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不确定即将发生什么，所以让我们使用Terraform进行规划，这样它会准确告诉我们它打算做什么：
- en: '[PRE40]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The plan looks good—it seems to want to create an S3 bucket named the way we
    want! Let's `terraform apply` this and move on.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 计划看起来不错——它似乎想创建一个名为我们想要的名字的S3存储桶！让我们执行`terraform apply`，然后继续进行。
- en: Quickly simulating changes
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 快速模拟更改
- en: 'We now wonder what would happen if we were to change the number of instances.
    That''s the `cluster_size` variable, currently set to `1`. Instead of messing
    with the code, we can test the impact of changing that value directly from the
    command line:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想知道如果我们更改实例数量会发生什么。这是`cluster_size`变量，目前设置为`1`。我们可以直接从命令行测试更改该值的影响，而无需更改代码：
- en: '[PRE41]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Good news! It looks like increasing the `cluster_size` value has the intended
    effect: creating a new instance.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息！看起来增加`cluster_size`值达到了预期效果：创建了一个新实例。
- en: 'Now, we wonder legitimately what would be the effect of changing the instance
    type, from `t2.micro` to `t2.medium`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们正合理地想知道将实例类型从`t2.micro`更改为`t2.medium`会产生什么影响：
- en: '[PRE42]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Ouch! Changing the instance type seems to be a destructive action. Let''s work
    on that later, and add the change to a new file named `plan.tfvars`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！更改实例类型似乎是一个破坏性操作。我们稍后再处理这个问题，并将更改添加到一个名为`plan.tfvars`的新文件中：
- en: '[PRE43]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We know we''d like to propose to change the number of instances to `2`, so
    let''s add that to the same file:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们想要提议将实例数量更改为`2`，所以让我们将其添加到同一个文件中：
- en: '[PRE44]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can now test against this file containing all our changes, using the `-var-file`
    option:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用包含所有更改的文件，使用`-var-file`选项进行测试：
- en: '[PRE45]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Good! You learn that our first instance will be destroyed and recreated to move
    from `t2.micro` to `t2.medium`, and that a second instance will be created with
    the same values. Let's not apply this, as added fees will be incurred.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！你已经了解到我们的第一个实例将会被销毁并重新创建，从`t2.micro`升级到`t2.medium`，并且第二个实例将会使用相同的值被创建。我们暂时不应用这个更改，因为会产生额外费用。
- en: Targeting for a specific change
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定向进行特定更改
- en: 'Our colleague asks us if we''re sure our proposed changes have no impact specifically
    on the S3 bucket. Terraform allows us to get an answer to that question very specifically
    by targeting the resource directly in the planning phase:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的同事问我们是否确定我们提出的更改不会对S3存储桶产生影响。Terraform允许我们在计划阶段通过直接定位资源来非常具体地回答这个问题：
- en: '[PRE46]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Our colleague is happy, and we're now sure that this change will do exactly
    what's intended. We can submit this change for review.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的同事很高兴，我们现在确定这个更改将完全按预期进行。我们可以提交这个更改进行审核。
- en: Teamwork – sharing Terraform infrastructure state
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 团队合作 – 共享Terraform基础设施状态
- en: 'You probably work with a team, and now you''re using Terraform to manage your
    infrastructure, you''ll face an issue: how does your team work together on infrastructure-as-code?
    There''re many answers to that, and one crucial question to address is: how is
    transmitted or synchronized the Terraform state?'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能与团队一起工作，现在你正在使用Terraform管理基础设施，你将面临一个问题：你的团队如何在基础设施即代码方面协同工作？对此有许多答案，一个关键问题需要解决的是：Terraform状态是如何传递或同步的？
- en: We'll see here how we can share the state using Git (a version control system
    where developers can store code), AWS S3 (an Amazon Web Services storage system
    using HTTP) or Consul (a tool for service discovery and a key-value store), chosen
    among many other solutions.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们将看到如何使用Git（一个版本控制系统，开发人员可以用来存储代码）、AWS S3（一个使用HTTP的亚马逊Web服务存储系统）或Consul（一个服务发现工具和键值存储），在众多其他解决方案中选择一种来共享状态。
- en: Getting ready
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正在准备中
- en: 'To step through this recipe, you will need the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行这个操作，你需要以下内容：
- en: A working Terraform installation
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个工作正常的Terraform安装
- en: An AWS account with an SSH key configured in Terraform (refer to the [Chapter
    2](ch02.html "Chapter 2. Provisioning IaaS with Terraform"), *Provisioning IaaS
    with Terraform* recipes)
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个配置了 SSH 密钥的 AWS 账户在 Terraform 中（参考 [第 2 章](ch02.html "Chapter 2. Provisioning
    IaaS with Terraform")，*使用 Terraform 提供 IaaS* 配方）
- en: A working Docker installation for the Consul simulation solution (optional)
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于 Consul 仿真解决方案的工作 Docker 安装（可选）
- en: An Internet connection
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条互联网连接
- en: How to do it…
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Let''s start by having an initial infrastructure running (a single virtual
    machine for this example). Here''s an `aws_instance` resource in `instances.tf`
    for a CoreOS stable release taken from previous recipes:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从启动一个初始基础设施开始（本例中为一台虚拟机）。以下是 `instances.tf` 中的 `aws_instance` 资源，它基于之前的配方使用了
    CoreOS 稳定版本：
- en: '[PRE47]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here are example variables in `variables.tf`; feel free to adapt them:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `variables.tf` 中的示例变量；可以根据需要进行调整：
- en: '[PRE48]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Terraform stores its state by default in a file named `terraform.tfstate`,
    with a backup file named `terraform.tfstate.backup`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 默认将其状态存储在名为 `terraform.tfstate` 的文件中，并且有一个名为 `terraform.tfstate.backup`
    的备份文件：
- en: '[PRE49]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Sharing with Git
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 Git 共享
- en: 'The simplest of all options is to share the state file using Git: you''re already
    supposed to version your infrastructure code! Go and create an account somewhere.
    GitHub ([https://github.com](https://github.com)) doesn''t have free private repositories,
    but GitLab ([https://gitlab.com](https://gitlab.com)) or BitBucket ([https://bitbucket.org](https://bitbucket.org))
    do. Follow the instructions to have your Git repository locally working.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 所有选项中最简单的是通过 Git 来共享状态文件：你本来就应该对你的基础设施代码进行版本管理！去某个平台创建一个账户。GitHub ([https://github.com](https://github.com))
    不提供免费的私有仓库，但 GitLab ([https://gitlab.com](https://gitlab.com)) 或 BitBucket ([https://bitbucket.org](https://bitbucket.org))
    提供。按照说明操作，使你的 Git 仓库本地工作。
- en: 'Now, add the `tfstate` files:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加 `tfstate` 文件：
- en: '[PRE50]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Commit the files:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 提交文件：
- en: '[PRE51]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Push the commit:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 推送提交：
- en: '[PRE52]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now your coworkers absolutely need to pull the changes before applying any
    action, or calamity might follow soon:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的同事在应用任何操作之前必须拉取更改，否则灾难可能很快就会发生：
- en: '[PRE53]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Sharing remotely with S3
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 S3 进行远程共享
- en: Sharing the state file through Git works, to some extent. You'll end up someday
    in a situation where someone forgets to push or pull. Merging conflicts in a state
    file is really not something nice to do.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Git 共享状态文件在某种程度上是可行的。最终你会遇到某种情况，有人忘记推送或拉取。在状态文件中合并冲突真的不是一件愉快的事情。
- en: One solution to stop thinking about it is using S3 to share the state file and
    use the remote state feature of Terraform.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 一个解决方案是使用 S3 来共享状态文件，并使用 Terraform 的远程状态功能。
- en: 'Start by creating an S3 bucket just for that, in `s3.tf`, with versioning enabled
    (so you can roll back to a previous version of the infrastructure):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 从在 `s3.tf` 中创建一个专门用于此的 S3 存储桶开始，启用版本控制（这样你就可以回滚到基础设施的早期版本）：
- en: '[PRE54]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s `terraform apply` this S3 bucket, and move on to the remote configuration
    with our information:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们 `terraform apply` 这个 S3 存储桶，并继续使用我们的信息进行远程配置：
- en: '[PRE55]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You can now see the terraform state file in the S3 browser:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以在 S3 浏览器中看到 Terraform 状态文件：
- en: '![Sharing remotely with S3](img/B05671_03_02.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![使用 S3 进行远程共享](img/B05671_03_02.jpg)'
- en: 'Now make any change to the infrastructure, such as adding a new S3 bucket,
    to see the file change in action:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对基础设施进行任何更改，例如添加一个新的 S3 存储桶，以便看到文件变化的效果：
- en: '[PRE56]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'After a `terraform apply`, simply push the changes:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `terraform apply` 后，直接推送更改：
- en: '[PRE57]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'See the history in the S3 browser:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在 S3 浏览器中查看历史记录：
- en: '![Sharing remotely with S3](img/B05671_03_03.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![使用 S3 进行远程共享](img/B05671_03_03.jpg)'
- en: 'The coworker has to configure their environment and pull the information:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 同事必须配置他们的环境并拉取信息：
- en: '[PRE58]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'A local copy is now residing in the `.terraform` folder:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 本地副本现在位于 `.terraform` 文件夹中：
- en: '[PRE59]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Sharing remotely with Consul
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Consul 进行远程共享
- en: A very nice way to share the state file is by using Consul, a powerful key/value
    storage from Hashicorp ([http://consul.io/)](http://consul.io/)). Using Consul
    to store the Terraform states makes it easier to work with a team, as there's
    only a single replicated state. No risk of using an old state file if we forgot
    to synchronize our git repository.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 Consul 共享状态文件是一种非常好的方式，Consul 是 Hashicorp 提供的强大键值存储服务（[http://consul.io/)](http://consul.io/))。使用
    Consul 存储 Terraform 状态使得与团队协作变得更容易，因为只有一个单一的复制状态。如果我们忘记同步 Git 仓库，就不会有使用旧状态文件的风险。
- en: 'Configuring a proper Consul in cluster for production is out of the scope of
    this book, but if you don''t have a Consul cluster at hand to try this out, here''s
    a way to quickly have one, using Docker and a Consul image:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 配置生产环境中的正确 Consul 集群超出了本书的范围，但如果你手头没有 Consul 集群来尝试，可以使用 Docker 和 Consul 镜像快速创建一个：
- en: '[PRE60]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now let''s configure our Terraform remote for Consul, and name it `terraform/my_customer`,
    so we can manage multiple customers simultaneously:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为 Consul 配置 Terraform 远程，并命名为 `terraform/my_customer`，以便可以同时管理多个客户：
- en: '[PRE61]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Job done! Your coworkers can now push and pull from the Consul source! In a
    production Consul cluster, it means replicated and synchronized states on each
    node, with added privacy.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 工作完成！你的同事现在可以从 Consul 源中推送和拉取了！在生产环境的 Consul 集群中，这意味着每个节点的状态都被复制和同步，同时增加了隐私性。
- en: Other state sharing options
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他状态共享选项
- en: There're many other ways to share the state, such as on Azure, using OpenStack
    Swift, any kind of HTTP server supporting REST, CoreOS's own etcd key-value store,
    Google Cloud storage, or Atlas, the commercial solution by Hashicorp.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他方式可以共享状态，例如在 Azure 上，使用 OpenStack Swift，任何支持 REST 的 HTTP 服务器，CoreOS 自己的
    etcd 键值存储，Google Cloud 存储或 Hashicorp 提供的商业解决方案 Atlas。
- en: Maintaining a clean and standardized Terraform code
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 维护一个干净且标准化的 Terraform 代码
- en: Everyone has coding styles, but enforcing a standardized and commonly readable
    style is the key for a smooth collaborative team work. That's why Terraform has
    a command to ensure both format and style are all right.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都有自己的编码风格，但强制执行标准化和常见的可读风格是顺利协作的关键。这就是为什么 Terraform 提供了一个命令来确保格式和风格都正确。
- en: I encourage readers to use it extensively, and even integrate it in **Continuous
    Integration** (**CI**) systems and in Makefiles.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励读者广泛使用它，甚至将其集成到 **持续集成** (**CI**) 系统和 Makefile 中。
- en: Getting ready
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个教程，你将需要以下内容：
- en: A working Terraform installation
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的 Terraform 安装
- en: An Internet connection
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个互联网连接
- en: How to do it…
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: We'll intentionally write a simple Terraform code with non-standard style and
    with an error (a missing variable). This will help us manipulate the various tools
    Terraform offers to ensure the most consistent and homogenous code, so we can
    achieve more quickly a better quality and a higher level of standardization of
    our code.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意编写一个风格非标准且带有错误（缺失变量）的简单 Terraform 代码。这将帮助我们操作 Terraform 提供的各种工具，以确保代码的最一致性和同质性，从而更快地实现更高质量和更高水平的代码标准化。
- en: 'Let''s write a provider for AWS like this in `provider.tf` (deliberately on
    one line):'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `provider.tf` 中这样编写一个 AWS 的 provider（故意写在一行中）：
- en: '[PRE62]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Syntax validation
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语法验证
- en: 'Try to validate that file, and it will notify us that we''re missing a variable:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试验证该文件，它会通知我们缺少一个变量：
- en: '[PRE63]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The validation fails, and the return code is `1`:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 验证失败，返回代码是 `1`：
- en: '[PRE64]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Let''s add this variable to a `variables.tf` file:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个变量添加到 `variables.tf` 文件中：
- en: '[PRE65]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Hooray! A `terraform validate` is now happy:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 好极了！`terraform validate` 现在运行正常：
- en: '[PRE66]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Style validation
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样式验证
- en: This thing is, we solved the obvious problem (a missing variable), but what
    about style? The preceding style perfectly works, but style might not be canonical.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，我们解决了明显的问题（缺失变量），但样式如何呢？前面的样式完全可行，但可能并不是标准样式。
- en: 'Let''s use the `fmt` option to check for styling issues, displaying the `diff`
    onscreen, but not writing the files automatically:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `fmt` 选项检查样式问题，显示屏幕上的 `diff`，但不自动写入文件：
- en: '[PRE67]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We see our style was quite far away from the guidelines. Let''s fix this and
    automatically format our files correctly:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现我们的样式与指南相差甚远。让我们修复它并自动正确地格式化文件：
- en: '[PRE68]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Our two files are now correctly formatted!
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的两个文件现在已正确格式化！
- en: I highly recommend putting those two commands in your CI tests (you are running
    infrastructure code tests in CI, aren't you?), and even before reaching the CI,
    it's even better if it's in the project's `Makefile`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议将这两个命令放入你的 CI 测试中（你是否在 CI 中运行基础设施代码测试？），甚至在到达 CI 之前，如果它在项目的 `Makefile`
    中，那会更好。
- en: 'Here''s a simple `Makefile` example:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的 `Makefile` 示例：
- en: '[PRE69]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now you can just type `make` in the Terraform directory and you're sure your
    code both validates and is coherently styled.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你只需要在 Terraform 目录中输入 `make`，就可以确保你的代码既通过验证，又符合一致的风格。
- en: One Makefile to rule them all
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个 Makefile 控制所有
- en: Some languages have environment or version managers such as RVM for Ruby, NVM
    for Node, or even Rackspace's DVM for Docker.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编程语言有环境或版本管理工具，如 Ruby 的 RVM、Node 的 NVM，甚至是 Rackspace 的 Docker 版本管理工具 DVM。
- en: 'It''s highly recommended to lock the Terraform version, so everyone in the
    team uses the same version, and updates can be painlessly handled. To do that,
    I suggest using a Terraform container, so we''ll use here the one I use myself:
    `sjourdan/terraform:<version>` (from [https://github.com/sjourdan/terraform-docker](https://github.com/sjourdan/terraform-docker)).
    But I understand replacing the simple `terraform` command by something such as
    ``docker run -it --rm -v `pwd`:/data sjourdan/terraform:0.7.3`` can feel not so
    appealing. That''s why we can use a common `Makefile` for each project using Terraform.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议锁定 Terraform 的版本，这样团队中的每个人都使用相同的版本，并且更新可以无痛处理。为了做到这一点，我建议使用一个 Terraform
    容器，所以我们这里使用的是我自己用的那个：`sjourdan/terraform:<version>`（来自 [https://github.com/sjourdan/terraform-docker](https://github.com/sjourdan/terraform-docker)）。但我理解用
    `docker run -it --rm -v `pwd`:/data sjourdan/terraform:0.7.3` 替代简单的 `terraform`
    命令可能感觉不太吸引人。这就是为什么我们可以为每个使用 Terraform 的项目使用一个通用的 `Makefile`。
- en: Using a common entry point for manipulating the infrastructure code helps a
    lot of sharing practices, enforcing policies, and integrating third-party services
    such as CI systems.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个通用的入口点来操作基础设施代码有助于很多共享实践，执行政策并集成第三方服务，如 CI 系统。
- en: Getting ready
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行这个食谱，你将需要以下内容：
- en: A working Terraform installation
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可用的 Terraform 安装
- en: An AWS account with an SSH key configured in Terraform (refer to the [Chapter
    2](ch02.html "Chapter 2. Provisioning IaaS with Terraform"), *Provisioning IaaS
    with Terraform* recipes)
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置了 SSH 密钥的 AWS 账户，并在 Terraform 中进行设置（请参考[第二章](ch02.html "第二章：使用 Terraform 提供
    IaaS")，*使用 Terraform 提供 IaaS*的食谱）
- en: An Internet connection
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个互联网连接
- en: How to do it…
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'Let''s begin by setting the Terraform version we want to use in a Makefile
    so it will be easy to manipulate for updates in the future:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先在 `Makefile` 中设置我们希望使用的 Terraform 版本，这样以后更新时可以轻松操作：
- en: '[PRE70]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Let''s now create a `TERRAFORM_BIN` variable that will include the full Docker
    command, plus share our local folder:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个 `TERRAFORM_BIN` 变量，它将包含完整的 Docker 命令，并共享我们的本地文件夹：
- en: '[PRE71]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'I like auto-documenting my Makefile, and I propose a popular technique: `make`
    by default calls `make help`, which in turn parses the `Makefile` for comments,
    and displays them. That way, I can choose what to output by simply adding a comment.
    Here''s how it works:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢自动化记录我的 `Makefile`，并且我提议使用一种流行的技巧：默认情况下，`make` 会调用 `make help`，然后解析 `Makefile`
    中的注释并显示它们。这样，我可以通过简单地添加注释来选择输出内容。它是这样工作的：
- en: '[PRE72]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now simply use this feature to create an entry for the validation and formatting
    from the previous recipe:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只需使用这个功能为之前食谱中的验证和格式化创建一个条目：
- en: '[PRE73]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'If you simply type `make`, you''ll get an automatic help:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只输入 `make`，你将看到自动帮助信息：
- en: '[PRE74]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Now, a simple `make validate` will both validate the syntax and format the code.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，简单的 `make validate` 将同时验证语法并格式化代码。
- en: It would be great to have the `plan` and `apply` commands as well, and if you
    followed the recipe on environment management with Terraform, that would be awesome
    if it worked right from the `Makefile`, we'd save a lot of time.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果能同时拥有 `plan` 和 `apply` 命令会更好，如果你跟随了 Terraform 环境管理的食谱，如果它能直接从 `Makefile` 工作，那就太棒了，这样我们可以节省很多时间。
- en: 'Start by creating the `Makefile` main "help" entries:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 从创建 `Makefile` 主要的 "help" 入口开始：
- en: '[PRE75]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Note
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We added the validation step at each step, so we're always absolutely sure it
    passes full validation (and you can add your own validation steps).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在每一步都加入了验证步骤，这样我们始终可以确保它通过了完整的验证（你也可以添加自己的验证步骤）。
- en: 'Let''s check for an environment variable named `env`, passed at `make` execution
    (such as `make plan env=staging`), and returns an error if not set:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来检查一个名为 `env` 的环境变量，它是在 `make` 执行时传递的（例如 `make plan env=staging`），如果没有设置则返回错误：
- en: '[PRE76]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now we can write what `terraform-plan` and `terraform-apply` are exactly running,
    with isolated Terraform states and environments:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写 `terraform-plan` 和 `terraform-apply` 实际执行的内容，带有独立的 Terraform 状态和环境：
- en: '[PRE77]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'By the way, you can add support for environments to our previous `terraform-validate`
    example:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，你可以为我们之前的 `terraform-validate` 示例添加环境支持：
- en: '[PRE78]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Add as many features as you want to your project's `Makefile`; you'll soon realize
    this simple tool helps so much.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的需要向项目的 `Makefile` 添加任意功能；你很快会发现这个简单的工具非常有帮助。
- en: 'For example, I always add a `make destroy` command, so I can easily destroy
    a test infrastructure (be careful though!):'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我总是添加一个 `make destroy` 命令，这样我就可以轻松销毁测试基础设施（不过要小心！）：
- en: '[PRE79]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Our Makefile now looks like this:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Makefile` 现在是这样的：
- en: '[PRE80]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Also, it can be used like this:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，它也可以像这样使用：
- en: '[PRE81]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Note
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Add absolutely anything that might make your lives easier, such as releases,
    tests, and so on.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 添加任何能让你们的工作更轻松的内容，比如发布、测试等等。
- en: See also
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: 'The auto documented Makefile: [http://marmelab.com/blog/2016/02/29/auto-documented-makefile.html](http://marmelab.com/blog/2016/02/29/auto-documented-makefile.html)'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '自动文档化的 Makefile: [http://marmelab.com/blog/2016/02/29/auto-documented-makefile.html](http://marmelab.com/blog/2016/02/29/auto-documented-makefile.html)'
- en: 'Rbenv: [https://github.com/rbenv/rbenv](https://github.com/rbenv/rbenv)'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Rbenv: [https://github.com/rbenv/rbenv](https://github.com/rbenv/rbenv)'
- en: 'RVM: [https://github.com/rvm/rvm](https://github.com/rvm/rvm)'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RVM: [https://github.com/rvm/rvm](https://github.com/rvm/rvm)'
- en: 'DVM: [https://github.com/getcarina/dvm](https://github.com/getcarina/dvm)'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'DVM: [https://github.com/getcarina/dvm](https://github.com/getcarina/dvm)'
- en: 'NVM: [https://github.com/creationix/nvm](https://github.com/creationix/nvm)'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'NVM: [https://github.com/creationix/nvm](https://github.com/creationix/nvm)'
- en: Team workflow example
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 团队工作流示例
- en: Working with infrastructure code is very similar to working with software code.
    Countless books and methods exist on the subject and approaches are usually very
    opinionated.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 与基础设施代码的工作与软件代码的工作非常相似。关于这一主题有无数书籍和方法，而且通常每种方法都有很强的个人观点。
- en: 'A simple workflow I propose to use here for our infrastructure-as-code work
    is based on what''s called the **GitHub Flow** ([https://guides.github.com/introduction/flow/](https://guides.github.com/introduction/flow/)):'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我提出的用于基础设施即代码的简单工作流是基于所谓的 **GitHub Flow**（[https://guides.github.com/introduction/flow/](https://guides.github.com/introduction/flow/)）：
- en: '![Team workflow example](img/B05671_03_13.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![团队工作流示例](img/B05671_03_13.jpg)'
- en: Getting ready
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照这个方法步骤执行，你需要以下内容：
- en: An account on some Git hosting (self-hosted or commercial)
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些 Git 托管服务上有一个账户（自托管或商业服务）
- en: A working Terraform installation
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个工作中的 Terraform 安装
- en: An AWS account with an SSH key configured in Terraform (refer to the [Chapter
    2](ch02.html "Chapter 2. Provisioning IaaS with Terraform"), *Provisioning IaaS
    with Terraform* recipes)
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置了 SSH 密钥的 AWS 账户（参见 [第 2 章](ch02.html "第2章. 使用 Terraform 配置 IaaS")，*使用 Terraform
    配置 IaaS* 配方）
- en: An Internet connection
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个互联网连接
- en: How to do it…
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Start by creating a new repository for use with your team. Use any service
    that works for you: GitLab, GitHub, BitBucket, and others. This example uses GitHub.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 从为你们的团队创建一个新的仓库开始。使用任何适合你的服务：GitLab、GitHub、BitBucket 等等。这个示例使用的是 GitHub。
- en: A simple Git repository
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个简单的 Git 仓库
- en: 'Create a new repository on GitHub:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitHub 上创建一个新的仓库：
- en: Note
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We might be storing secrets in that repository, such as SSH private keys or
    passwords. It's probably a safer option to create a private Git repository for
    now.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会在该仓库中存储一些机密信息，如 SSH 私钥或密码。现在创建一个私有 Git 仓库可能是一个更安全的选择。
- en: '![A simple Git repository](img/B05671_03_04.jpg)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![一个简单的 Git 仓库](img/B05671_03_04.jpg)'
- en: 'Now import this new empty repository on your workstation, in a dedicated folder:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在你的工作站上导入这个新的空仓库，放在一个专用文件夹里：
- en: '[PRE82]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Initial infrastructure code
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始基础设施代码
- en: 'Create a new Git branch to work on an initial infrastructure:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 Git 分支来处理初步基础设施：
- en: '[PRE83]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Add some Terraform code from the previous recipes, such as a single CoreOS
    instance. For the record, here''s the `variables.tf` file:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的配方中添加一些 Terraform 代码，例如单个 CoreOS 实例。为了记录，下面是 `variables.tf` 文件：
- en: '[PRE84]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Here''s a deliberately badly formatted `provider.tf`:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个故意格式不正确的 `provider.tf` 文件：
- en: '[PRE85]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Also, here''s a CoreOS instance in `instances.tf`:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这里有一个在`instances.tf`中的 CoreOS 实例：
- en: '[PRE86]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Terraform code validation
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Terraform 代码验证
- en: 'Let''s be sure our code validates:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 确保我们的代码是有效的：
- en: '[PRE87]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Thankfully, it does!
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，它确实有效！
- en: 'Does this code plan to do what we want it to do? Have a look:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是否按我们希望的方式执行？看看：
- en: '[PRE88]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This looks exactly like our objective. Let's continue.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来正是我们目标的实现。让我们继续。
- en: Infrastructure code commit
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基础设施代码提交
- en: 'What are the new files on this branch that aren''t on master? Let''s find out:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个分支上有哪些新文件还没有出现在 master 上？让我们找出来：
- en: '[PRE89]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Good, those are the files we just created. Let''s add them to a `commit`:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，那些是我们刚创建的文件。让我们把它们加入到一个`commit`中：
- en: '[PRE90]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now let''s send the branch upstream so that our coworkers can see our work
    that''s still not yet in production:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们把分支推送到上游，这样我们的同事们就能看到我们的工作，尽管它还没有投入生产：
- en: '[PRE91]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Make a pull request
  id: totrans-420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提交一个拉取请求
- en: 'Navigate to your repository, and you''ll see something similar to the following
    screenshot, showing an information about the new branch being just pushed. GitHub
    proposes to easily create a pull request. A pull request is a request to merge
    the content of one branch to another branch. In our case, we want to ask our coworkers
    to merge our `new_infrastructure` branch into the master branch, to create some
    discussion:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 进入你的仓库，你会看到类似下面的截图，显示新推送的分支信息。GitHub 提议轻松创建拉取请求。拉取请求是一个请求，将一个分支的内容合并到另一个分支。在我们的案例中，我们希望请求同事将我们的`new_infrastructure`分支合并到
    master 分支，以便进行讨论：
- en: '![Make a pull request](img/B05671_03_05.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![创建拉取请求](img/B05671_03_05.jpg)'
- en: 'When you open a pull request, GitHub automatically tries the requested merge
    (in our case, from our branch to master). Here, no conflicts are noted, so we
    can write a message explaining what our request is all about. A pull request is
    often composed of multiple commits, so a summary is more than welcome:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开一个拉取请求时，GitHub 会自动尝试合并请求（在我们的例子中，从我们的分支到 master）。这里没有发现冲突，因此我们可以写一条消息，解释我们的请求内容。拉取请求通常由多个提交组成，所以提供一个总结是非常欢迎的：
- en: '![Make a pull request](img/B05671_03_06.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![创建拉取请求](img/B05671_03_06.jpg)'
- en: 'Now everyone from your team have access to your work and can discuss it right
    from GitHub if necessary:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你团队中的每个人都可以访问你的工作，并且在必要时可以直接从 GitHub 上进行讨论：
- en: '![Make a pull request](img/B05671_03_07.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
  zh: '![创建拉取请求](img/B05671_03_07.jpg)'
- en: 'A few minutes later, one of your coworkers reviews your code and sends you
    a remark:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，你的一个同事审查了你的代码，并给你发来了评论：
- en: '![Make a pull request](img/B05671_03_08.jpg)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![创建拉取请求](img/B05671_03_08.jpg)'
- en: 'She might be right; let''s find out with the Terraform formatter:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 她可能是对的；我们用 Terraform 格式化工具来验证一下：
- en: '[PRE92]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Looks like there was a formatting issue! Use `git diff` to see what''s the
    difference:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来是格式化问题！使用`git diff`查看差异：
- en: '[PRE93]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We''re happy with that; let''s `add`, `commit`, and `push`. Pushing to our
    remote branch will automatically add our commit to the pull request as well:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对此感到满意，现在可以`add`、`commit`、并`push`。推送到远程分支将自动将我们的提交添加到拉取请求中：
- en: '[PRE94]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Our coworker can now see in real time that we took her remark into account,
    as GitHub automatically marks it as outdated:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的同事可以实时看到我们已经考虑了她的评论，因为 GitHub 会自动将其标记为过时：
- en: '![Make a pull request](img/B05671_03_09.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![创建拉取请求](img/B05671_03_09.jpg)'
- en: 'Now our coworker pulled the changes on her side, tried to plan the changes
    herself with Terraform, and announces she''s happy with the results as well:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的同事已经在她那边拉取了更改，并用 Terraform 尝试规划这些更改，她宣布自己也对结果满意：
- en: '![Make a pull request](img/B05671_03_10.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![创建拉取请求](img/B05671_03_10.jpg)'
- en: Apply the changes
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用这些更改
- en: 'So let''s do that right now:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 那我们现在就来做这个：
- en: '[PRE95]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Is there anything new in our repository? Have a look:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的仓库里有什么新东西吗？看看：
- en: '[PRE96]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Sure, now we have to ship our infrastructure state to the pull request:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，现在我们必须将我们的基础设施状态推送到拉取请求中：
- en: '[PRE97]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Our coworker sees that everything is all right, and she also checked the server
    is doing well. So, now she can merge our branch, close the pull request with a
    message, and then delete the now useless branch:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的同事看到一切正常，并且她也检查了服务器运行状况。所以，现在她可以合并我们的分支，关闭拉取请求并附上消息，然后删除现在不再需要的分支：
- en: '![Apply the changes](img/B05671_03_11.jpg)![Apply the changes](img/B05671_03_12.jpg)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![应用更改](img/B05671_03_11.jpg)![应用更改](img/B05671_03_12.jpg)'
- en: Our code and its fixes are now on master, along with the updated infrastructure
    state, all done in full collaboration with a coworker.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的代码和修复已经合并到 master 分支，同时更新了基础设施的状态，所有这些都与同事充分协作完成。
- en: 'For any new feature, anything added to the infrastructure should follow the
    same pattern: create a branch, insert your changes, open a pull request, discuss
    the changes with the coworkers, apply the change, and merge to master. Master
    is now the reference again.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何新功能，任何添加到基础设施的内容都应该遵循相同的模式：创建一个分支，插入更改，打开拉取请求，与同事讨论更改，应用更改并合并到 master。master
    现在再次成为参考。
- en: Managing GitHub with Terraform
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Terraform 管理 GitHub
- en: There're many service providers to use with Terraform. GitHub is one of them,
    and we'll see how to manage members of an organization, various teams, and control
    repository access, right from our infrastructure code. That way, we have an automatic
    history log of who accesses what.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Terraform 有很多服务提供商。GitHub 就是其中之一，我们将看到如何通过基础设施代码管理组织成员、不同团队以及控制仓库访问权限。这样，我们就能自动记录谁访问了什么内容。
- en: Getting ready
  id: totrans-452
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'To step through this recipe, you will need the following:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个步骤，您需要以下内容：
- en: A working Terraform installation
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的 Terraform 安装
- en: A GitHub account (with an API token)
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 GitHub 账户（带 API 令牌）
- en: An Internet connection
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个互联网连接
- en: How to do it…
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We want to manage a GitHub organization named **ACME**. Here are the users
    and their groups:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要管理一个名为 **ACME** 的 GitHub 组织。以下是用户及其组别：
- en: '| GitHub username | GitHub team name | Membership level | Team privacy |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| GitHub 用户名 | GitHub 团队名称 | 会员级别 | 团队隐私 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| John | Documentation | member | closed |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| John | 文档 | 成员 | 已关闭 |'
- en: '| Jane | Engineering | admin | secret |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| Jane | 工程 | 管理员 | 秘密 |'
- en: 'Here''s the policy we decided concerning the Git repository named `infrastructure-repository`:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们决定的有关名为 `infrastructure-repository` 的 Git 仓库的政策：
- en: '| GitHub team name | Repository permissions |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| GitHub 团队名称 | 仓库权限 |'
- en: '| --- | --- |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Documentation | pull |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '| 文档 | 拉取 |'
- en: '| Engineering | admin |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '| 工程 | 管理员 |'
- en: Configuring GitHub
  id: totrans-468
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 GitHub
- en: 'Let''s start by creating a `github` provider, as we used an `aws` provider
    for AWS in the previous recipes. The documentation lists the requirements: an
    API token and an organization name:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从创建一个 `github` 提供程序开始，就像在前面的配方中使用 `aws` 提供程序一样。文档列出了要求：一个 API 令牌和一个组织名称：
- en: '[PRE98]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Set the generic variables in a `variables.tf` file:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `variables.tf` 文件中设置通用变量：
- en: '[PRE99]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Don't forget to override those variables to fit your own in the `terraform.tfvars`
    file.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在 `terraform.tfvars` 文件中覆盖这些变量，以适应您自己的设置。
- en: Adding users to the GitHub organization
  id: totrans-474
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将用户添加到 GitHub 组织中
- en: 'We want to add the username `john` as a member, and `jane` as an admin, in
    a file you can name `github.tf` (feel free to split managed GitHub features in
    many smaller files as your organization grows):'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要将用户名 `john` 添加为成员，将 `jane` 添加为管理员，文件名可以是 `github.tf`（随着组织的增长，可以将管理的 GitHub
    功能拆分成多个更小的文件）：
- en: '[PRE100]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: John and Jane are now part of the GitHub organization (they will receive invitations
    by e-mail).
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: John 和 Jane 现在是 GitHub 组织的一部分（他们将通过电子邮件收到邀请）。
- en: Adding GitHub teams
  id: totrans-478
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加 GitHub 团队
- en: 'Let''s create our two teams, technical writers and engineering, with their
    respective privacy settings:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来创建两个团队——技术写作和工程——并设置各自的隐私设置：
- en: '[PRE101]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Add our two members to their respective teams—Jane in engineering, John in
    documentation:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的两个成员分别添加到他们的团队中——Jane 在工程组，John 在文档组：
- en: '[PRE102]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Setting Git repository access rights
  id: totrans-483
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置 Git 仓库访问权限
- en: 'The policy we''ve set is that members of the engineering group are admins of
    the repository, while technical writers can only pull the code:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设定的政策是，工程组的成员是仓库的管理员，而技术写作人员只能拉取代码：
- en: '[PRE103]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: You've just set the essentials to manage your GitHub organization right from
    Terraform!
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚设置了管理 GitHub 组织的基础配置，直接通过 Terraform！
- en: External monitoring integration with StatusCake
  id: totrans-487
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部监控与 StatusCake 的集成
- en: 'External monitoring is helpful because it gives insights on how performant
    your infrastructure is, as seen from the outside, maybe from many places in the
    world. We can build our own availability monitoring systems, or we can use third-party
    services. StatusCake is a good example for us as they have a good API and a free
    service tier for us to try with Terraform. We''ll monitor two things: host latency
    and HTTP availability.'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 外部监控非常有用，因为它提供了从外部、也许是从世界各地多个地方看到的您基础设施的性能洞察。我们可以建立自己的可用性监控系统，也可以使用第三方服务。StatusCake
    对我们来说是一个很好的例子，因为它们有良好的 API，并且提供一个免费的服务层供我们用 Terraform 试用。我们将监控两项内容：主机延迟和 HTTP
    可用性。
- en: Getting ready
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个步骤，您需要以下内容：
- en: A working Terraform installation
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的 Terraform 安装
- en: A StatusCake account ([https://statuscake.com](https://statuscake.com))
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 StatusCake 账户 ([https://statuscake.com](https://statuscake.com))
- en: Optionally, an infrastructure managed by Terraform (refer to the previous recipes)
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的，由 Terraform 管理的基础设施（请参见前面的配方）
- en: An Internet connection
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个互联网连接
- en: How to do it…
  id: totrans-495
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Start by setting the new `statuscake` provider, as we did with AWS or GitHub,
    using a username and API key:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 从设置新的 `statuscake` 提供程序开始，就像我们之前设置 AWS 或 GitHub 一样，使用用户名和 API 密钥：
- en: '[PRE104]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Declare the variables in `variables.tf`:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `variables.tf` 中声明变量：
- en: '[PRE105]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Also, don't forget to set those variables to your own values in `terraform.tfvars`.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，不要忘记将这些变量设置为您自己的值，并存入 `terraform.tfvars` 文件。
- en: Creating an automated ping monitoring test
  id: totrans-501
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个自动化的 ping 监控测试
- en: 'Let''s create an initial test, a simple ICMP ping to a server whose IP is `1.2.3.4`,
    every 5 minutes:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个初步的测试，一个简单的 ICMP ping 到 IP 为 `1.2.3.4` 的服务器，每 5 分钟一次：
- en: '[PRE106]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Note
  id: totrans-504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `website_name` or `website_url` can be a reference to an existing Terraform
    resource. If our AWS instance resource is named `centos`, you can access the value
    dynamically like this, instead of a static value:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '`website_name` 或 `website_url` 可以引用现有的 Terraform 资源。如果我们的 AWS 实例资源名为 `centos`，你可以像这样动态访问该值，而不是使用静态值：'
- en: '[PRE107]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'If your resource has a `count` number, you can iterate through it so all the
    available instances are automatically monitored. It works like this:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的资源有一个 `count` 数量，你可以遍历它，这样所有可用的实例就会自动被监控。它的工作原理是这样的：
- en: '[PRE108]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Another useful feature is to switch the value of `paused` to `true` for planned
    downtimes, so you're not hammered with alerts you're already aware of.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的功能是在计划的停机时间中将 `paused` 的值切换为 `true`，这样你就不会收到已经知道的警报了。
- en: Creating an HTTPS test
  id: totrans-510
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 HTTPS 测试
- en: A very common test we'll want to make is HTTP availability. It's really no different
    than an ICMP check;
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 一个我们非常常见的测试是 HTTP 可用性测试。它与 ICMP 检查没有太大区别；
- en: '[PRE109]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
