- en: Workflow
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作流程
- en: 'In this chapter, we''ll discuss the workflow in Puppet. We''ll cover what makes
    a good technical workflow, how to apply that to Puppet, and how to use the **Puppet
    Development Kit** (**PDK**) to improve our workflow. We''ll investigate the following
    qualities of a good workflow: ease of use, rapid feedback, ease of onboarding,
    and quality control. We''ll use Puppet Git repositories to provide a basic Puppet
    workflow that can be tuned to any system of management. We''ll also explore the
    new PDK released by Puppet, which can improve our workflow.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论 Puppet 中的工作流程。我们将介绍什么是好的技术工作流程，如何将其应用到 Puppet 上，以及如何使用**Puppet 开发工具包**（**PDK**）来改进我们的工作流程。我们将探讨一个好的工作流程的以下特性：易用性、快速反馈、入职容易性和质量控制。我们将使用
    Puppet Git 仓库提供一个基本的 Puppet 工作流程，该流程可以调整以适应任何管理系统。我们还将探索 Puppet 发布的新的 PDK，它可以改进我们的工作流程。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Puppet workflow
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet 工作流程
- en: Designing a Puppet workflow
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计 Puppet 工作流程
- en: Using the PDK
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PDK
- en: Puppet workflow
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Puppet 工作流程
- en: 'A workflow is a series of processes that work flows through, from initiation
    to completion. As the Puppet environments become more complex in an organization,
    a trusted and shared workflow will make sharing work easier. A Puppet workflow
    should allow us to access code, edit code, test our code, and, eventually, deploy
    our code back to the Puppet Master. Although it is not required, it is highly
    recommended that an organization or group of workers adopt a shared workflow.
    A shared workflow possesses a few main benefits, as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程是一系列处理流程，从启动到完成。随着组织中 Puppet 环境变得更加复杂，一个值得信赖的共享工作流程将使得共享工作变得更加容易。Puppet
    工作流程应该允许我们访问代码、编辑代码、测试代码，并最终将代码部署回 Puppet Master。虽然这不是强制要求，但强烈建议组织或团队采用共享工作流程。共享工作流程有几个主要好处，如下所示：
- en: A measurable ease of use
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可衡量的易用性
- en: Rapid feedback
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速反馈
- en: Ease of onboarding
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 入职容易性
- en: Quality control
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 质量控制
- en: Ease of use
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 易用性
- en: The primary reason to design and begin a workflow is to provide for ease of
    use. A team should design a workflow around their code base, allowing them to
    understand how to retrieve specific code, how to edit that code, and the impacts
    of the new edits. A workflow also provides a standardized way of packaging the
    code, to be delivered and used by the existing code base. Each step in the workflow
    should be clear, concise, communicated, and repeatable. It is important that everyone
    on the team understands not only how the workflow works, but why each step of
    the workflow exists, so that they can troubleshoot and contribute to the workflow,
    should something change in the organization.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 设计并开始工作流程的主要原因是为了提供易用性。团队应该围绕他们的代码库设计工作流程，使他们能够了解如何检索特定的代码、如何编辑这些代码以及新的编辑会带来哪些影响。工作流程还提供了一种标准化的方式来打包代码，以便现有代码库使用。工作流程中的每个步骤应该是清晰、简洁、易于沟通和可重复的。重要的是，团队中的每个人不仅要了解工作流程的运作方式，还要理解每个步骤存在的原因，这样他们才能在组织中发生变化时进行故障排除并为工作流程做出贡献。
- en: One of the primary benefits of a shared workflow, as opposed to individualized
    workflows, is the ability to measure the impact of the workflow on the organization.
    To measure our workflow, we first separate standard and nonstandard units of work.
    The edits that we make to our code often vary in size and complexity, and are
    not easy to measure in standard units. On the other hand, code is generally checked
    out, tested, and deployed in the same way every time, leaving us with a good estimate
    of how long it will take to go through our workflow, minus the code edits.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 相对于个性化的工作流程，共享工作流程的主要好处之一是能够衡量工作流程对组织的影响。为了衡量我们的工作流程，我们首先将标准和非标准的工作单位分开。我们对代码所做的编辑通常在大小和复杂性上有所不同，且不容易用标准单位衡量。另一方面，代码通常是以相同的方式进行检出、测试和部署的，这使我们能够很好地估算出完成工作流程所需的时间，减去代码编辑的部分。
- en: If our workflow takes about 30 seconds to clone the code repository, an unknown
    amount of time to edit code, 5 minutes to run a test, and another 30 seconds to
    deploy the code in our environment, our workflow, with a single test, will take
    about 6 minutes. If we have eight members of our team, who each run through this
    workflow 10 times a day on average, our workflow actually constitutes about 8
    hours a week of our combined work (*8 x 10 x 6* = *480* minutes, or 8 hours).
    Cutting this testing time in half reduces our total time as a team spent on the
    workflow by about 3 1/3 hours per week. Because of this measurable amount of time
    that can be saved in a workflow, a team should consider optimizing their workflow
    whenever possible.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的工作流需要大约 30 秒来克隆代码库，编辑代码的时间不确定，5 分钟来运行测试，另加 30 秒来在我们的环境中部署代码，那么我们的工作流，进行一次测试时，约需
    6 分钟。如果我们的团队有 8 名成员，每人平均每天执行这个工作流 10 次，那么我们的工作流实际上每周占用了大约 8 小时的团队工作时间（*8 x 10
    x 6* = *480* 分钟，或 8 小时）。将测试时间减半，可以使我们团队在工作流上花费的总时间减少大约 3 1/3 小时每周。因此，由于工作流中可以节省的这部分可量化时间，团队应尽可能考虑优化工作流。
- en: Generally, you won't need more than a rough estimate of the time it takes to
    perform the standard functions of the workflow, but you will need to know which
    pieces might be performed more than once. With Puppet, a user will likely write,
    push, and test code more than they will pull it down. You can inspect each piece
    of the workflow separately and seek to improve a part of the process, but you
    should consider the ramifications of a change to the rest of the workflow.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你不需要比估算执行工作流中标准功能所需时间更详细的估算，但你需要知道哪些部分可能会被多次执行。在使用 Puppet 时，用户很可能会写代码、推送代码并进行测试，而不是从服务器拉取代码。你可以分别检查工作流的每个部分，尝试改进其中的一部分，但你也应该考虑到修改对工作流其他部分的影响。
- en: Rapid feedback
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速反馈
- en: A good workflow should provide constant feedback to its users. Each step should
    be clearly defined, with strict pass or fail criteria. For example, Git will warn
    a user whenever it detects a problem, such as being unable to pull code or push
    code back to the origin repository. We can extend this with Git commit hooks,
    both server-side and client-side, which perform checks to ensure that the code
    is in a proper state before being accepted into an organizational Git server from
    the local repository. Running Puppet itself within our test criteria, we expect
    clean and idempotent runs. The Puppet catalog should not produce failing resources,
    nor should it manage the same resource with every Puppet run.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的工作流应该为用户提供持续的反馈。每个步骤都应该有明确的定义，并具有严格的通过或失败标准。例如，Git 会在检测到问题时发出警告，比如无法拉取代码或推送代码到原始仓库。我们可以通过扩展
    Git 提交钩子（无论是服务器端还是客户端）来进行检查，确保代码在被接纳到组织的 Git 服务器之前是处于正确状态的。在我们的测试标准中运行 Puppet
    时，我们期望它能进行干净且幂等的运行。Puppet 目录不应生成失败的资源，也不应在每次 Puppet 运行时管理相同的资源。
- en: The time it takes to solve problems with Puppet shrinks as more feedback is
    provided by a workflow to the engineer. If you work in a workflow that requires
    pushing code to an environment on the Puppet Master, and you are testing on a
    true agent, a simple run of `puppet parser validate` can save a lot of time. The
    parser validation will quickly tell you if Puppet code can be compiled, rather
    than what it will do. This simple command can reduce the number of times that
    we `git commit` on the code, push it to the Git repository, deploy it to an environment,
    log in to the test machine, and wait for the Puppet agent to trigger a catalog
    error. We can even ensure that this command is run before every commit with a
    precommit Git hook. Automated testing tools, such as RSpec and Beaker, can extend
    this methodology, and, combined with a CI/CD pipeline (discussed in the next chapter),
    can provide even more rapid feedback to code developers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Puppet 解决问题所需的时间会随着工作流对工程师提供的反馈量增加而缩短。如果你在一个需要将代码推送到 Puppet Master 环境并在真实代理上进行测试的工作流中，简单地运行
    `puppet parser validate` 可以节省大量时间。解析器验证会快速告诉你 Puppet 代码是否可以编译，而不是告诉你它将会做什么。这个简单的命令可以减少我们在代码上执行
    `git commit`、推送到 Git 仓库、部署到环境、登录测试机并等待 Puppet 代理触发目录错误的次数。我们甚至可以确保每次提交前都会运行这个命令，使用
    Git 的预提交钩子。自动化测试工具，如 RSpec 和 Beaker，可以扩展这种方法，并且与 CI/CD 管道（将在下一章讨论）结合使用，可以为代码开发者提供更快速的反馈。
- en: Ease of onboarding
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容易上手
- en: A well-built workflow naturally facilitates the ease of adding new members to
    a project, whether open source or a part of an organization. A simple tool suite
    and guide can be invaluable to those new members, and can help them to get over
    the hurdle of the first commit. Even a simple getting started `README` can go
    a long way, if properly maintained. Onboarding new members to a project is costly,
    and quality workflow can minimize the time spent by the new member. Bringing on
    new project members also requires some information and time from existing project
    members. If your project is an ongoing development effort, it's highly likely
    that you'll have some turnover, and saving time for existing members while shortening
    the time for new members to reach effectiveness should be a priority in your workflow.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个良好的工作流自然能够促进新成员加入项目的便利性，无论是开源项目还是组织的一部分。一个简单的工具套件和指南对新成员来说是无价的，能帮助他们克服首次提交的难关。即使是一个简单的`README`，如果维护得当，也能发挥很大作用。将新成员引入项目是昂贵的，而高质量的工作流可以减少新成员所花费的时间。加入新项目成员还需要现有项目成员提供一些信息和时间。如果你的项目是一个持续开发的工作，成员流动很可能会发生，因此，在工作流中节省现有成员的时间，并缩短新成员达到有效性所需的时间，应当是优先事项。
- en: Quality control
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 质量控制
- en: A good workflow should always seek to reduce mistakes and increase code quality.
    Every built-in safety mechanism in a workflow allows a team to iterate over more
    complex features more quickly. Simple things, such as preventing pushes directly
    to production branches and basing production environments on semantically versioned
    code, allow for rapid development, without any worries about toppling critical
    infrastructure.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的工作流应始终致力于减少错误并提高代码质量。工作流中的每一个内置安全机制都可以让团队更快速地在复杂功能上进行迭代。简单的措施，比如防止直接推送到生产分支并将生产环境基于语义版本化的代码，可以实现快速开发，而不必担心破坏关键基础设施。
- en: 'The following lists a few examples of workflow improvements designed around
    security and stability:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出了一些围绕安全性和稳定性设计的工作流改进示例：
- en: Preventing direct code pushes to production on the control repository
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止直接向控制仓库的生产环境推送代码
- en: Preventing direct code pushes to masters on individual modules
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止直接向单个模块的主节点推送代码
- en: Running Puppet parser validation on all manifests prior to a push back to the 
    repository of origin
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将所有清单推送回源仓库之前，运行 Puppet 解析器验证所有清单
- en: Running code reviews prior to merging into a master or `production-like` branches
    of the control repository
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将代码合并到主分支或类似生产环境的控制仓库分支之前，进行代码审查
- en: Automated testing
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化测试
- en: Designing a Puppet workflow
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计 Puppet 工作流
- en: Puppet has undergone a lot of changes in code management since its beginnings.
    Even the general workflow has changed drastically. This section will help you
    to understand some of the history of code management in Puppet, some of the challenges,
    and, most importantly, some of the solutions for designing and working with a
    strong Puppet workflow.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Puppet 开始以来，代码管理经历了很多变化。即使是整体工作流也发生了巨大变化。本节将帮助你了解 Puppet 代码管理的一些历史，面临的一些挑战，最重要的是，一些设计和使用强大
    Puppet 工作流的解决方案。
- en: Originally, we wrote Puppet manifests directly to the disk. We logged on to
    the Puppet Master via SSH and edited our manifests directly, treating most of
    our code like configuration files for remote machines. This model required custom
    backups and recovery for code applied to agents, and did not provide easy rollbacks. If
    something went wrong in a deployment, you were forced to take snippets of code
    from a backup manually and deploy it to a system. Some members of the community
    took to storing their Puppet code in Git. As the number of individual repositories
    grew in organizations, manually bringing in Git repositories individually became
    more troublesome, and some community open source projects formed that were focused
    on staging Git code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们直接将 Puppet 清单写入磁盘。我们通过 SSH 登录到 Puppet Master 并直接编辑清单，将大部分代码视为远程机器的配置文件。这种模式需要为应用到代理的代码提供自定义备份和恢复，并且不提供便捷的回滚功能。如果部署出现问题，你不得不手动从备份中提取代码片段并将其部署到系统中。一些社区成员开始将
    Puppet 代码存储在 Git 中。随着组织中独立仓库数量的增加，手动一个个引入 Git 仓库变得更加麻烦，一些社区开源项目也开始形成，专注于 Git 代码的分阶段管理。
- en: Components of the Puppet workflow
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Puppet 工作流的组成部分
- en: 'Although r10k is not the only Puppet Code Manager, it has become the standard
    Code Manager deployed to enterprise organizations. We''ll break the work down
    into tasks and repositories, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 r10k 不是唯一的 Puppet 代码管理工具，但它已成为企业组织中部署的标准代码管理工具。我们将把工作分解为任务和仓库，如下所示：
- en: 'Repositories:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库：
- en: Control repository
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制仓库
- en: Module repositories
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块仓库
- en: 'Tasks:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务：
- en: Clone
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 克隆
- en: Create new branch
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新分支
- en: Edit relevant code
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑相关代码
- en: Add and commit
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加并提交
- en: Push
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推送
- en: Puppet login and deploy
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet 登录并部署
- en: Classify
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分类
- en: Test (automatic or manual)
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试（自动或手动）
- en: Repositories
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仓库
- en: Code management requires that all code be stored in Git. Splitting your code
    up into multiple repositories and placing the code on the master allows for references
    to different versions of code. Each of your modules should reside in a separate
    repository, allowing for versioning and governance on a per-module basis. The
    `Puppetfile` will call these repositories by using the Puppet Forge, or pointers
    at your own local Git instance.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 代码管理要求所有代码都存储在 Git 中。将代码拆分到多个仓库并将其置于主分支上，可以引用不同版本的代码。每个模块应独立存放在单独的仓库中，以便进行版本控制和治理。`Puppetfile`
    将通过 Puppet Forge 或指向您自己本地 Git 实例来调用这些仓库。
- en: Control repository
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制仓库
- en: Our control repository, as described in the previous chapter, is nothing more
    than a Git code repository. The only unique quality that you need to keep in mind
    when working with it, is that branch names correspond to Puppet environments.
    If you create a Git branch named `feature` and deploy the code, the Puppet Master
    will deploy that code to `/etc/puppetlabs/code/environments/feature`. Generally,
    the Master branch is replaced with another protected branch named `production`
    in the control repository, so that agents can check in to a production branch
    by default.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，我们的控制仓库不过是一个 Git 代码仓库。与其打交道时需要特别注意的一点是，分支名称对应于 Puppet 环境。如果您创建一个名为 `feature`
    的 Git 分支并部署代码，Puppet Master 将把代码部署到 `/etc/puppetlabs/code/environments/feature`。通常，主分支会被另一个名为
    `production` 的保护分支取代，以便代理默认将代码提交到生产分支。
- en: Module repository
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块仓库
- en: Module repositories are standard Git repositories. Generally, we want to protect
    the master branch and keep it from receiving direct commits. Contributors to component
    modules should instead submit pull requests to the repository and allow for a
    code review before accepting the code into the master branch. The master branch
    should be a functional version of the module at all times, although it need not
    be a version ready to be deployed into production. Treating the master as stable
    code allows non-production environments to point reliably at the master branch
    of all repositories, to get the latest accepted code during development. When
    it comes to deploying to production, we'll actually use a Git tag to create a
    version, such as 1.2.0\. We can then deploy our latest code into non-production
    and formally accept code into production.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 模块仓库是标准的 Git 仓库。通常，我们希望保护主分支，避免其接收直接提交。组件模块的贡献者应通过提交拉取请求（pull request）来提交代码，并在将代码合并到主分支之前进行代码审查。主分支应该始终是模块的功能性版本，尽管它不需要是一个准备好部署到生产环境的版本。将主分支视为稳定代码，可以让非生产环境可靠地指向所有仓库的主分支，以在开发过程中获取最新的接受代码。在部署到生产环境时，我们将使用
    Git 标签来创建一个版本，比如 1.2.0。然后，我们可以将最新的代码部署到非生产环境，并正式将代码接受到生产环境中。
- en: Tasks
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务
- en: The primary driver of the workflow in a Code Manager or r10k-based system is
    a Git workflow. There are multiple models of Git workflows, such as GitHub flow
    and Git flow, but the primary focus of this book isn't on Git, so we'll start
    with a minimal set of commands and procedures. The most effective way to get started
    is to work on the temporary environments provided by our control repository. In
    this workflow, we assume that a Git solution is already implemented on-site, or
    is provided by a managed service provider, and the Puppet Master is using Code
    Manager to deploy environments.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于 Code Manager 或 r10k 的系统中，工作流的主要驱动因素是 Git 工作流。Git 工作流有多种模型，比如 GitHub flow
    和 Git flow，但本书的主要重点不是 Git，因此我们将从一组最基本的命令和流程开始。最有效的开始方式是使用我们的控制仓库提供的临时环境。在这个工作流中，我们假设已经在现场实现了
    Git 解决方案，或者由托管服务提供商提供，并且 Puppet Master 正在使用 Code Manager 部署环境。
- en: The first step of the workflow is to identify the components that need to change.
    In this workflow example, we'll assume that we're performing a change on a component
    module and a profile embedded in the control repository. We'll include remediation
    steps during the manual test phase, to include new code deployments and new pushes
    to the Git repository.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流的第一步是识别需要更改的组件。在这个工作流示例中，我们假设正在对一个组件模块和嵌入在控制仓库中的配置文件进行更改。在手动测试阶段，我们会包含修复步骤，包含新的代码部署和新的推送到
    Git 仓库。
- en: Clone and edit the component repositories
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 克隆并编辑组件仓库
- en: 'First, we''ll clone the component module, change to a new feature branch, and
    perform edits on the files in the repository. We''ll ensure that we use a Git
    branch during development, so that we can send our code to the upstream Git repository
    without impacting the original code. We''ll end this step with a new snapshot
    of code on a separate branch of an existing module, so that we can test this code
    in isolation. This set of steps is the general workflow for the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将克隆组件模块，切换到新特性分支，并对仓库中的文件进行编辑。我们将确保在开发过程中使用 Git 分支，这样可以将我们的代码推送到上游 Git
    仓库，而不影响原始代码。我们将以在现有模块的单独分支上创建新的代码快照来结束这一步，以便我们可以独立地测试这段代码。这一系列步骤是以下操作的通用工作流程：
- en: Making a copy of the upstream repository for an individual module (`git clone`/`pull`)
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为单个模块制作上游仓库的副本（`git clone`/`pull`）
- en: Creating a branch of the module, separate from the Master (`git checkout`)
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个与主分支分开的模块分支（`git checkout`）
- en: Making any and all edits to the code (IDE of choice)
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对代码进行任何和所有编辑（选择的 IDE）
- en: Creating a snapshot of the current state of the code (`git add` and `commit`)
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建代码当前状态的快照（`git add` 和 `commit`）
- en: Sending the snapshot back to the upstream repository (`git push`)
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将快照推送回上游仓库（`git push`）
- en: 'In action, the code is as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 实际操作中的代码如下：
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Our edits are now in the upstream repository, in a `new_feature` branch. The
    master branch will continue to serve as a reference point for further development
    for others, and for testing in a staging environment. So that we can begin to
    test this code, we'll create a new Puppet environment, designed specifically for
    testing and iteration over this code set.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的编辑现在已经在上游仓库的`new_feature`分支中。主分支将继续作为其他人进一步开发的参考点，并用于在暂存环境中的测试。为了开始测试这段代码，我们将创建一个新的
    Puppet 环境，专门用于测试和对这段代码进行迭代。
- en: Cloning the control repository
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 克隆控制仓库
- en: 'The first step starts like the last one: cloning the Git repository. One thing
    to remember about Puppet environments is that a branch of this repository corresponds
    to a Puppet environment. Most users of Puppet don''t have a master environment,
    but rather, the production environment that Puppet places nodes into by default.
    If your organization has any environments prior to production, as many do, you''ll
    want to make sure that you begin on the existing branch before creating a new
    branch. The `git checkout -b` command creates a new branch, starting from the
    branch that you are currently on. The following are the steps for creating a new
    environment, modeled after an existing environment:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步和上一步一样：克隆 Git 仓库。关于 Puppet 环境需要记住的一点是，这个仓库的分支对应一个 Puppet 环境。大多数 Puppet 用户没有主环境，而是使用
    Puppet 默认放置节点的生产环境。如果你的组织有任何生产环境之前的环境（许多组织都有），你需要确保在创建新分支之前，先从现有分支开始。`git checkout
    -b`命令会创建一个新分支，起始于你当前所在的分支。以下是创建新环境的步骤，模仿现有环境：
- en: Make a copy of the control repository from the upstream repository (`git clone`).
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上游仓库克隆控制仓库的副本（`git clone`）。
- en: Check out the environment that you want to write new code against (`git checkout`).
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检出你希望基于其编写新代码的环境（`git checkout`）。
- en: 'Check out a new branch, based on the current branch (`git checkout -b`):'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检出一个新分支，基于当前分支（`git checkout -b`）：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Like the steps we took for our component module repository, this set of commands
    ensures that we have a local copy of the repository with the latest commits to
    the integration branch, and that we started a new branch based on the existing
    code. We're in a state to edit files found directly in our control repository,
    such as the `Puppetfile`, `hieradata`, and embedded `roles` and `profiles` (if
    you keep them in the control repository, rather than as separate, individual repositories).
    Once we have the code, we will want to edit the relevant files, create a new commit,
    push the code back to the origin repository, and deploy the environment.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们为组件模块仓库所采取的步骤一样，这一系列命令确保我们拥有最新的提交的集成分支的本地仓库副本，并且我们基于现有代码启动了一个新分支。我们已经准备好直接在控制仓库中编辑文件，例如
    `Puppetfile`、`hieradata` 以及嵌入的 `roles` 和 `profiles`（如果你将它们保存在控制仓库中，而不是作为独立的仓库）。一旦我们拿到代码，我们将编辑相关文件，创建新提交，将代码推送回源仓库，并部署环境。
- en: Editing the control repository
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑控制仓库
- en: 'Once we''re inside of the local copy of the intended environment, it will be
    the right time to make changes to the code. We generally spawn these additional
    short-lived environments so that simple commands can be used to deploy new code.
    We have a few files to target, because we think of the control repository as a
    configuration file for the rest of the environment. The `Puppetfile` is used to
    manage dependencies, including any component modules (from the Forge or your own
    environment). `roles` and `profiles` are often kept in the control repository,
    as well, and code can be edited directly in these environments. The workflow for
    making changes in the control repository is as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们进入目标环境的本地副本，就可以开始对代码进行更改了。我们通常会创建这些额外的短期环境，以便通过简单的命令部署新代码。我们有一些文件需要关注，因为我们将控制仓库视为整个环境的配置文件。`Puppetfile`
    用于管理依赖项，包括任何组件模块（来自 Forge 或你自己的环境）。`roles` 和 `profiles` 通常也保存在控制仓库中，代码可以直接在这些环境中进行编辑。对控制仓库进行更改的工作流程如下：
- en: Edit the files (in the IDE of your choice).
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑文件（使用你选择的 IDE）。
- en: Make a snapshot of the current state of the code (`git add` and `commit`).
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建当前代码状态的快照（`git add` 和 `commit`）。
- en: 'Send the environment back to the remote repository (`git push`):'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将环境推送回远程仓库（`git push`）：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At this point, we've edited a module and files in the control repository and
    pushed them back to the origin. We'll now deploy the branch we made in the preceding
    code, and we will tweak our profile to use the module changes. Unless you have
    set up Git hooks or a CI/CD solution, you'll also have to trigger an environment
    deployment on the Puppet Master.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经编辑了控制仓库中的模块和文件并推送回源仓库。接下来，我们将部署前面代码中创建的分支，并调整我们的配置以使用模块更改。除非你已经设置了 Git
    钩子或 CI/CD 解决方案，否则你还需要在 Puppet Master 上触发环境部署。
- en: Deploying the new environment on the Puppet Master
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Puppet Master 上部署新环境
- en: 'Puppet provides the PE Client Tools, as described in [Chapter 5](6c818865-77fb-4527-a3a5-922db1301217.xhtml),
    *Managing Code*, specifically for deploying code. If these tools are not available
    on your workstation, you can also log in to the Puppet Master, where they are
    already available for use. Assuming that you are using Code Manager, the following
    steps remain the same whether you are on a local workstation or a remote server:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 提供了 PE 客户端工具，如 [第5章](6c818865-77fb-4527-a3a5-922db1301217.xhtml) *管理代码*
    中所述，专门用于部署代码。如果这些工具在你的工作站上不可用，你也可以登录到 Puppet Master，那里已经可以使用它们。假设你正在使用 Code Manager，无论是在本地工作站还是远程服务器上，接下来的步骤都是相同的。
- en: Retrieve the login token from Puppet Enterprise (`puppet-access login`).
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Puppet Enterprise 获取登录令牌（`puppet-access login`）。
- en: 'Deploy an environment from the upstream repository branch (`puppet-code deploy`):'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上游仓库分支部署环境（`puppet-code deploy`）：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now our code has been deployed as a fresh environment on the Puppet Master.
    We're still missing a step to classify our test system and ensure that it is placed
    in the proper environment. For a Puppet Enterprise user, you can both classify
    and declare an environment by using a node classifier group in the PE console.
    To create a new node group, select an environment, check the environment group
    box, name it, and click Create. Enter your new environment group, pin your test
    node to the group, and add any relevant classes to the classification page.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的代码已作为一个全新的环境部署在 Puppet Master 上。我们仍然缺少一个步骤，就是对我们的测试系统进行分类并确保它被放置在正确的环境中。对于
    Puppet Enterprise 用户，你可以使用 PE 控制台中的节点分类器组来同时分类和声明一个环境。要创建一个新的节点组，选择一个环境，勾选环境组框，命名并点击创建。进入你的新环境组，将测试节点固定到该组，并向分类页面添加任何相关的类。
- en: 'You can also classify via `manifests/site.pp` in the control repository, as
    follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过 `manifests/site.pp` 在控制库中进行分类，方法如下：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The code for classification via Hiera is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Hiera 进行分类的代码如下：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are multiple ways to classify that are commonly used by Puppet users,
    but without automated testing, we'll have to do some classification and run the
    agent to check the results of our tests.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 用户常用的分类方法有多种，但没有自动化测试的话，我们需要做一些分类并运行代理来检查测试结果。
- en: Testing the changes
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试更改
- en: 'After your test node is properly attached to the environment group, you can
    log in to the node and trigger an agent run with puppet `agent -t`. Alternatively,
    you can run the Puppet agent through the PE console and read the log there. If
    you don''t see any changes, there are a few possible reasons, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的测试节点正确连接到环境组后，你可以登录到节点并触发代理运行，使用 puppet `agent -t`。或者，你也可以通过 PE 控制台运行 Puppet
    代理并查看日志。如果没有看到任何变化，可能有以下几种原因：
- en: The agent has already run, between when you classified the node in the console
    and ran the Puppet agent.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理已经运行，在你在控制台中对节点进行分类和运行 Puppet 代理之间。
- en: A step was missed and the code was not properly deployed.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 漏掉了一个步骤，代码未正确部署。
- en: Your code does not trigger any new changes on the system, and you should modify
    the system to see if Puppet corrects the change.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的代码没有在系统上触发任何新的更改，你应该修改系统以查看 Puppet 是否会修正该更改。
- en: 'Ensure that you check the resources targeted by your change to see whether
    the agent has already deployed the new changes. You might also want to verify
    that the code deployment was done properly, and that you pushed your code back
    to the Git repository. If your code does not trigger any changes on the system,
    or if it triggers undesired changes, you can perform the following shorter workflow
    until the code is resolved properly:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 确保检查你的更改所针对的资源，查看代理是否已经部署了新的更改。你可能还需要验证代码部署是否已正确完成，并确保你已将代码推送回 Git 库。如果你的代码没有触发系统上的任何更改，或者触发了不期望的更改，你可以执行以下更短的工作流程，直到代码正确解决：
- en: 'Edit the code in the target repository: the control repository or the module
    repository (with the IDE of choice)'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目标库中编辑代码：控制库或模块库（使用你选择的 IDE）
- en: Make a snapshot of the code (`git add` and `commit`)
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建代码的快照（`git add` 和 `commit`）
- en: Push the code back to the remote repository (`git push`)
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码推送回远程库（`git push`）
- en: Redeploy the environment (`puppet-access login` and `puppet-code deploy`)
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新部署环境（`puppet-access login` 和 `puppet-code deploy`）
- en: Trigger an agent run on the test machine (`puppet agent` or PE console)
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试机器上触发代理运行（`puppet agent` 或 PE 控制台）
- en: Check for changes on the target system
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查目标系统上的变化
- en: 'Repeat until the desired state is achieved:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复直到达到预期状态：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once our code is in the desired state, we will be ready to begin placing it
    back into a long-lived environment on the Puppet Master. Modules should have their
    code merged back to the master, and changes to the control repository will need
    to be merged with a longer lived branch.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的代码达到预期状态，我们就可以开始将它放回 Puppet Master 上的长期环境中。模块应该将其代码合并回主分支，并且对控制库的更改需要与长期存在的分支合并。
- en: Merging branches
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并分支
- en: 'In our earlier steps, we isolated our working code into a feature-branch and
    a short-lived, non-production environment. While teams and organizations should
    select some merging safeguards and strategies, such as peer code reviews and automated
    testing, this section will focus on the steps required to merge branches into
    master or long-lived branches in Puppet. Enterprise and open source web-based
    Git solutions usually contain some extra controls to indicate who can merge into
    a repository, and to which branches. The general best practice is to allow for
    a peer review of code, and the reviewer can accept the code into the long-lived
    branch or master branch. Merging our code via the command line is a simple process,
    as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的步骤中，我们将工作代码隔离到了一个功能分支和一个短期的、非生产环境中。虽然团队和组织应当选择一些合并的保护措施和策略，例如同行代码审查和自动化测试，但本节将重点介绍将分支合并到
    master 或长生命周期分支的步骤。企业和开源的基于 Web 的 Git 解决方案通常包含一些额外的控制，来指示谁可以合并到仓库，以及合并到哪些分支。一般的最佳实践是允许进行同行代码审查，审查者可以将代码接受到长生命周期分支或
    master 分支中。通过命令行合并代码是一个简单的过程，步骤如下：
- en: Switch to the branch that you want to merge to (`git checkout`)
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到你想要合并的分支（`git checkout`）
- en: Merge another branch into this one (`git merge`)
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将另一个分支合并到当前分支（`git merge`）
- en: 'Push the merged branch into upstream repository (`git push`):'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将合并后的分支推送到上游仓库（`git push`）：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Merging in the control repository can sometimes be troublesome, due to the `Puppetfile`
    being (intentionally) different between versions. Our `production-like` branches
    should use Git tags to declare the intended version of the code to be deployed
    and promoted up the series of environments. Our `non-production-like` environments
    are generally pointed to the master branch of each module, providing the latest
    accepted stable code to the environment for testing and development. Merging is
    performed in the same way as with a component module; just ensure that you don't
    overwrite the `Puppetfile` on a `production-like` branch with the less controlled
    `Puppetfile` in a `non-production-like` branch. Production branches should refer
    to Git tags for deploying code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制仓库中进行合并有时会遇到麻烦，因为 `Puppetfile` 在不同版本间（有意）不同。我们的 `生产型` 分支应该使用 Git 标签来声明要部署的代码的目标版本，并将其推广到各个环境中。我们的
    `非生产型` 环境通常指向每个模块的 master 分支，提供最新的稳定代码供环境测试和开发。合并的方式与组件模块相同；只需确保不要将 `生产型` 分支上的
    `Puppetfile` 覆盖为 `非生产型` 分支中的、控制较少的 `Puppetfile`。生产分支应参考 Git 标签来部署代码。
- en: Git tags and versioning
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git 标签与版本控制
- en: 'Git tags are used to create a permanent state of code and separate it from
    the existing branches. Tags are not intended to be iterated upon, but rather,
    should be used as a marker in time for the state of the code. This makes tags
    a perfect fit for the release versioning of Puppet code. We can create tags from
    any branch, but the master is the most common branch to cut release tags from.
    We can simply use the `git tag` command on our module repository to create a snapshot
    with a semantic version number and push it to the origin repository, to be called
    on by r10k or Code Manager. The workflow for a Git tag is also short, as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签用于创建代码的一个永久状态，并将其与现有分支区分开。标签不是用来迭代的，而是作为代码状态的时间标记。这使得标签非常适合用于 Puppet 代码的发布版本控制。我们可以从任何分支创建标签，但
    master 是最常用的创建发布标签的分支。我们可以简单地在模块仓库中使用 `git tag` 命令来创建一个带有语义版本号的快照，并将其推送到 origin
    仓库，供 r10k 或 Code Manager 调用。Git 标签的工作流也很简洁，步骤如下：
- en: Check out the target branch (usually the master) for the tag (`git checkout`)
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检出目标分支（通常是 master）以便打标签（`git checkout`）
- en: Version the code (`git tag`)
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对代码进行版本控制（`git tag`）
- en: 'Push the tag to the remote repository (`git push`):'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推送标签到远程仓库（`git push`）：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After our module has been properly versioned, we can edit the `production-like`
    Puppetfile to utilize our tag, rather than point to a particular development or
    master branch:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模块成功版本控制后，我们可以编辑 `生产型` 的 Puppetfile 来使用我们的标签，而不是指向某个特定的开发分支或 master 分支：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is a simple version of the Puppet workflow, but it still leaves room for
    improvement. Puppet recently released a tool called the PDK, to help facilitate
    quality Puppet tooling into your workflow.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Puppet 工作流的简化版本，但仍有改进的空间。Puppet 最近发布了一款名为 PDK 的工具，旨在帮助将高质量的 Puppet 工具整合进你的工作流中。
- en: Using the PDK
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PDK
- en: A good workflow should provide ease of use, rapid feedback, ease of onboarding,
    and quality control. The PDK aims to increase productivity across this space.
    Many tools in the PDK have existed for quite some time, but they were often difficult
    to use and configure for workstation development.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的工作流程应当提供易用性、快速反馈、便捷的上手过程和质量控制。PDK 旨在提高这一领域的生产力。PDK 中的许多工具已经存在了一段时间，但它们通常很难使用且配置复杂，尤其是在工作站开发环境下。
- en: PDK
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PDK
- en: 'Puppet makes the PDK freely available on their website, and it has a release
    for each major operating system. It uses a fully isolated environment to provide
    Puppet binaries and RubyGems that make development much simpler. Tools included
    in the PDK, as of version 1.5.0, are as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 在其官网上免费提供 PDK，并且为每个主要操作系统提供了相应的版本。它使用完全隔离的环境提供 Puppet 二进制文件和 RubyGems，这使得开发变得更加简便。PDK
    中包含的工具，从版本 1.5.0 开始，如下所示：
- en: 'Create new Puppet artifacts:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的 Puppet 工件：
- en: Modules
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块
- en: Classes
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Defined types
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已定义类型
- en: Tasks
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务
- en: Puppet Ruby providers
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet Ruby 提供程序
- en: 'PDK validate—simple health checks:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PDK 验证——简单的健康检查：
- en: Puppet parser validate (Puppet syntax)
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet 解析器验证（Puppet 语法）
- en: Puppet lint (Puppet style)
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet 风格检查（Puppet 风格）
- en: Puppet metadata syntax
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet 元数据语法
- en: Puppet metadata style
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet 元数据样式
- en: RuboCop (Ruby style)
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: RuboCop（Ruby 风格）
- en: PDK test unit (Puppet RSpec—unit testing)
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PDK 单元测试（Puppet RSpec—单元测试）
- en: Creating new Puppet artifacts
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的 Puppet 工件
- en: The PDK allows users to create new artifacts, using best practices. Each `pdk
    new` command builds an artifact already structured for Puppet. These artifacts
    are intended to conform to Puppet's best practices. If you're testing the PDK
    in an isolated environment for the first time, starting with a new module is the
    easiest method.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: PDK 允许用户使用最佳实践创建新的工件。每个 `pdk new` 命令都会构建一个已经按照 Puppet 结构化的工件。这些工件旨在符合 Puppet
    的最佳实践。如果你是第一次在隔离的环境中测试 PDK，从新模块开始是最简单的方法。
- en: The pdk new command
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pdk new 命令
- en: 'The command `pdk new module` brings the user to a prompt, requesting that the
    user specify the Puppet Forge username, the author''s full name, the module license,
    and the supported operating systems. If you do not have a Forge username or a
    module license, you can enter in any value. After the prompt, you''ll find a new
    directory that contains code. If you want to send this code to an upstream repository,
    follow these steps on the command line:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 命令`pdk new module`会引导用户进入一个提示，要求用户指定 Puppet Forge 用户名、作者全名、模块许可证以及支持的操作系统。如果你没有
    Forge 用户名或模块许可证，可以随便输入任何值。输入提示后，你会找到一个新目录，其中包含代码。如果你希望将这些代码推送到上游仓库，可以在命令行中按以下步骤操作：
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you're working with a previously created module, you can use the `pdk convert`
    command to place any items missing from the template into the existing module.
    By default, the PDK deploys the templates found at [https://github.com/puppetlabs/pdk-templates](https://github.com/puppetlabs/pdk-templates).
    If you need to change any of the files found here, you can clone a copy of `pdk-templates`
    from the official repository and send it to a central Git repository. You'll need
    to use the `pdk convert --template-url <https> ` to select the new template and
    deploy it to the existing module. The `--template-url flag ` command will also
    set the new URL as the default URL on the workstation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用一个之前创建的模块，可以使用 `pdk convert` 命令将模板中缺失的任何项加入到现有模块中。默认情况下，PDK 部署位于 [https://github.com/puppetlabs/pdk-templates](https://github.com/puppetlabs/pdk-templates)
    的模板。如果你需要修改这里找到的任何文件，可以从官方仓库克隆 `pdk-templates` 的副本，并将其推送到一个中心 Git 仓库。你需要使用 `pdk
    convert --template-url <https>` 来选择新的模板并将其部署到现有模块中。`--template-url flag` 命令还将把新
    URL 设置为工作站上的默认 URL。
- en: You should feel free to make your own copy of this template, as the one provided
    by Puppet is fairly extensive and rather opinionated. It even includes some ways
    to get started with CI/CD systems, such as `gitlab-ci`. Trim the files for systems
    that you don't use, and make sure that everything provided by the template makes
    sense for your organization.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随意制作这个模板的副本，因为 Puppet 提供的模板相当全面，并且有较强的主观看法。它甚至包括一些启动 CI/CD 系统的方法，例如 `gitlab-ci`。你可以删除不使用系统的相关文件，并确保模板提供的内容对你的组织是有意义的。
- en: 'The template repository provides three directories and configuration files
    to the PDK, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 模板仓库为 PDK 提供了三个目录和配置文件，如下所示：
- en: '`moduleroot`: The Ruby templates in this directory will be placed on top of
    existing files. This is useful when you want to enforce a particular file, like
    a CI/CD pipeline.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`moduleroot`：此目录中的 Ruby 模板将覆盖现有文件。若您需要强制使用某个特定文件（例如 CI/CD 流水线文件），这非常有用。'
- en: '`moduleroot_init`: The Ruby templates in this directory will not override existing
    files. This is great for starter files, like module templates.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`moduleroot_init`：此目录中的 Ruby 模板不会覆盖现有文件。这对于起始文件（如模块模板）非常适用。'
- en: '`object_templates`: The Ruby templates that determine the output of the file
    on commands like `pdk new class`.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object_templates`：Ruby 模板，决定在执行诸如 `pdk new class` 等命令时文件的输出。'
- en: '`config_defaults.yaml`: This provides defaults and variables to be used for
    all Ruby templates in the PDK template.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config_defaults.yaml`：为 PDK 模板中的所有 Ruby 模板提供默认值和变量。'
- en: 'Once you have your new module template, you can begin to create manifests inside
    of the module for Puppet code with the PDK. From inside of the new module, we
    can use `pdk new class` to begin making manifests. The command creates manifests
    according to an autoload layout, so running `pdk new class server::main` would
    create a file at `manifests/server/main.pp`. The class created with the default
    template will start as an empty, non-parameterized class, with Puppet string-style
    documentation at the top of the file. The `pdk new defined_type ` command will
    make a similar file, but will use the defined declaration instead of the class
    declaration:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获得新的模块模板，您可以开始在模块内创建 Puppet 代码清单。通过在新模块内使用 `pdk new class`，我们可以开始创建清单。该命令会按照自动加载布局创建清单，因此运行
    `pdk new class server::main` 会在 `manifests/server/main.pp` 位置创建一个文件。使用默认模板创建的类将是一个空的、无参数的类，文件顶部会有
    Puppet 字符串风格的文档注释。`pdk new defined_type` 命令会创建一个类似的文件，但会使用定义声明而不是类声明：
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `pdk new task` command will create files in the `tasks` directory, based
    on the template for use with Puppet tasks. Puppet tasks are a way to automate
    ad hoc scripts and commands across your infrastructure, using Puppet. `pdk new
    provider` is an experimental feature for designing new custom Ruby providers to
    Puppet.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`pdk new task` 命令将基于模板在 `tasks` 目录中创建文件，用于 Puppet 任务。Puppet 任务是通过 Puppet 自动化管理基础设施中临时脚本和命令的一种方式。`pdk
    new provider` 是用于设计新的自定义 Ruby 提供程序到 Puppet 的实验性功能。'
- en: Once the new objects are created and developed against, the PDK will also provide
    a tool suite for syntax and style, with `pdk validate`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建并开发了新的对象，PDK 还将提供一套工具集来进行语法和样式检查，使用 `pdk validate`。
- en: The pdk validate command
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pdk validate 命令
- en: 'The PDK provides `pdk validate` to check both syntax and style. Syntax checks
    make sure that your code can compile, and that you''re not missing things such
    as commas or closing braces in manifests or JSON metadata. Syntax checks can also
    be performed manually on manifests with `puppet parser validate`. Style checking
    looks at the code to make sure that it adheres to a standard style guide. Puppet-lint
    is used to provide style checks to Puppet, and all of the rules can be found at [http://puppet-lint.com/](http://puppet-lint.com/).
    When a module is healthy, the PDK will return check marks against all tasks:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: PDK 提供了 `pdk validate` 来检查语法和样式。语法检查确保代码可以编译，并且确保清单文件或 JSON 元数据中没有遗漏逗号或闭括号等内容。语法检查还可以通过
    `puppet parser validate` 手动执行。样式检查会检查代码是否符合标准的样式指南。Puppet-lint 用于提供 Puppet 的样式检查，所有规则可以在
    [http://puppet-lint.com/](http://puppet-lint.com/) 查找。当模块处于健康状态时，PDK 将会对所有任务显示勾选标记：
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'An invalid `metadata.json` will prevent the uploading of modules to the Forge
    and the running of RSpec tests. This file details the author of the module, and
    other information, such as dependencies and supported operating systems:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 无效的 `metadata.json` 文件将阻止将模块上传到 Forge，并且无法运行 RSpec 测试。该文件详细列出了模块的作者信息以及其他信息，如依赖关系和支持的操作系统：
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`pdk validate` also runs Puppet parser validation across every manifest in
    the module. In the following example, a curly brace was forgotten at the end of
    `init.pp`, and the PDK is informing us that the code will not compile:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`pdk validate` 还会在模块中的每个清单文件上运行 Puppet 解析器验证。在以下示例中，`init.pp` 文件末尾忘记了一个大括号，PDK
    提示我们该代码无法编译：'
- en: '[PRE16]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If the Puppet parser validation passes, `puppet-lint` will run on all manifests.
    It will print out errors and warnings in the code, based on the Puppet Style Guide.
    In the following example, we run pdk validate against a manifest has a line that
    continues beyond 140 characters on line 10 and trailing whitespace after line
    9:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Puppet 解析器验证通过，`puppet-lint` 将在所有清单上运行。它将根据 Puppet 风格指南打印代码中的错误和警告。在以下示例中，我们对一个清单运行
    pdk validate，清单中第 10 行有一行超出了 140 字符，并且第 9 行后有多余的空格：
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In some cases, rather than print out a warning or error, we want to disable
    it. A list of checks can be found at [http://puppet-lint.com/checks/](http://puppet-lint.com/checks/),
    and can be used to disable individual checks. In the following example, notice
    the comment after the message statement, telling lint to ignore the 140-character
    limit:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们希望禁用某个警告或错误，而不是打印出来。可以在 [http://puppet-lint.com/checks/](http://puppet-lint.com/checks/)
    上找到检查列表，并可以用于禁用单个检查。在以下示例中，注意消息语句后的注释，告诉 lint 忽略 140 字符限制：
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we have multiple places in a single manifest that we''d like to ignore,
    we can use the lint block `ignore` by placing the comment on a line alone and
    ending it with `# lint:endignore`. In the following example, we have two large
    strings that won''t be alerted on `puppet-lint`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望在一个清单中忽略多个地方，可以通过将注释放在单独的一行并以 `# lint:endignore` 结束，使用 lint 块 `ignore`。在以下示例中，我们有两个大字符串，在
    `puppet-lint` 检查时不会触发警告：
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you have a check that you''d like to disable, you can also create a `puppet-lint.rc`
    file. This file can be placed in `/etc` for a global config, as `.puppet-lint.rc`
    in the home directory for a user config, or at the base of a module, as `.puppet-lint.rc`.
    If your team uses local development workstations, consider adding a `.puppet-lint.rc`
    to your PDK template, to enforce a standard on each repository:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望禁用某些检查，可以创建一个 `puppet-lint.rc` 文件。该文件可以放置在 `/etc` 目录下作为全局配置，也可以放置在主目录下的
    `.puppet-lint.rc` 文件作为用户配置，或者放置在模块的根目录下作为 `.puppet-lint.rc`。如果你的团队使用本地开发工作站，可以考虑将
    `.puppet-lint.rc` 添加到 PDK 模板中，以便在每个仓库中强制执行标准：
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, any Ruby code will be validated by RuboCop. RuboCop will check the
    style of all Ruby files in a module. This provides style checking to custom facts,
    types, providers, and even tasks written in Ruby:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，任何 Ruby 代码都将通过 RuboCop 进行验证。RuboCop 将检查模块中所有 Ruby 文件的样式。这为自定义 facts、types、providers
    以及用 Ruby 编写的任务提供了样式检查：
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`pdk validate` provides a quick check of the style and syntax of your code.
    It does not check the functionality of your code. The PDK also provides a boiler
    template for RSpec tests out of the box, so that when a new class is created with `pdk
    new class`, a simple corresponding RSpec test is created along with it.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`pdk validate` 提供了一个快速检查代码样式和语法的工具，但不会检查代码的功能。PDK 还提供了一个开箱即用的 RSpec 测试模板，因此，当使用
    `pdk new class` 创建一个新类时，系统会自动创建一个简单的对应 RSpec 测试。'
- en: The pdk test unit command
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pdk test unit 命令
- en: 'New manifests built with `pdk new class` are also provided with a default RSpec
    test. Unit tests are written to ensure that a manifest performs what is expected
    as it is running. The default unit test provided by Puppet ensures that the code
    compiles successfully on every operating system listed in the `metadata.json`,
    with default facts for those operating systems. This can be expanded to create
    more robust unit tests. In the following example, a check has been added that
    states that the `init.pp` of the module should provide a file called `/etc/example`
    that is not provided by the manifest:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `pdk new class` 创建的新清单也会提供一个默认的 RSpec 测试。编写单元测试以确保清单在运行时执行预期的操作。Puppet 提供的默认单元测试确保代码在
    `metadata.json` 中列出的每个操作系统上都能成功编译，并使用这些操作系统的默认 facts。这可以扩展以创建更强大的单元测试。在以下示例中，已添加一个检查，表示模块的
    `init.pp` 应提供一个名为 `/etc/example` 的文件，而该文件在清单中并未提供：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The simple test provided by the default PDK only provides `it { is_expected.to
    compile }` as an RSpec test for each module. In the next chapter, we'll expand
    upon our initial RSpec module, as we cover unit tests and provide some basic code
    coverage testing to our Puppet modules.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 PDK 提供的简单测试仅为每个模块提供 `it { is_expected.to compile }` 作为 RSpec 测试。在下一章中，我们将扩展初始的
    RSpec 模块，涵盖单元测试并为 Puppet 模块提供一些基本的代码覆盖率测试。
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started this chapter by detailing what makes for a good workflow. Much of
    the workflow becomes easier when combined with continuous integration and continuous
    delivery strategies, which will be covered in the next chapter. We'll expand upon
    the RSpec tests built by the Puppet PDK, and we'll discuss acceptance test strategies.
    We'll also cover some new workflows and tools to provide more immediate feedback
    during the development of Puppet code and manifests.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开始时，我们详细描述了什么构成一个良好的工作流程。将工作流程与持续集成和持续交付策略结合后，许多工作变得更加容易，这些内容将在下一章中介绍。我们将扩展由
    Puppet PDK 构建的 RSpec 测试，并讨论验收测试策略。我们还将介绍一些新的工作流程和工具，以便在开发 Puppet 代码和清单时提供更及时的反馈。
