- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Creating Multi-Container Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建多容器应用程序
- en: This book guides you step by step along the path of developing your applications
    using containers. In previous chapters, we learned how to create container images,
    how to share them, and, finally, how to run application processes within containers.
    In this chapter, we will go a step further by running applications using multiple
    containers. This is the method you would probably use for developing your applications,
    running different interconnected components, sharing information, and publishing
    only the frontend processes to users. By the end of this chapter, you will be
    able to build, deliver, and run applications by using a composition of multiple
    containers managed all at once with a newly learned command line.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将一步步引导你使用容器开发应用程序的路径。在之前的章节中，我们学习了如何创建容器镜像，如何共享它们，最后，如何在容器内运行应用程序进程。在本章中，我们将进一步讨论如何使用多个容器运行应用程序。这是你开发应用程序时可能会使用的方法，通过运行不同的相互连接的组件、共享信息，并只将前端进程暴露给用户。通过本章的学习，你将能够构建、交付并运行由多个容器组成的应用程序，并使用新学会的命令行一次性管理这些容器。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Installing and using Docker Compose
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和使用 Docker Compose
- en: Introducing the Docker Compose file syntax
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Docker Compose 文件语法
- en: Building and sharing multi-container applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和共享多容器应用程序
- en: Running and debugging multi-container applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行和调试多容器应用程序
- en: Managing multiple environments with Docker Compose
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 管理多个环境
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We will use open source tools for building, sharing, and running an application
    composed of multiple containers. The labs for this chapter will help you understand
    the content presented, and they are published at [https://github.com/PacktPublishing/Containers-for-Developers-Handbook/tree/main/Chapter5](https://github.com/PacktPublishing/Containers-for-Developers-Handbook/tree/main/Chapter5).
    The *Code In Action* video for this chapter can be found at [https://packt.link/JdOIY](https://packt.link/JdOIY).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用开源工具来构建、共享和运行由多个容器组成的应用程序。本章的实验将帮助你理解所展示的内容，实验文件可以在 [https://github.com/PacktPublishing/Containers-for-Developers-Handbook/tree/main/Chapter5](https://github.com/PacktPublishing/Containers-for-Developers-Handbook/tree/main/Chapter5)
    上找到。本章的 *Code In Action* 视频可以在 [https://packt.link/JdOIY](https://packt.link/JdOIY)
    观看。
- en: Installing and using Docker Compose
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和使用 Docker Compose
- en: '**Docker Compose** is a tool developed by Docker Inc. to help developers create,
    deliver, and run applications with multiple components running within containers.
    This tool may come with your Docker container runtime distribution or have to
    be installed separately. If you are using tools such as **Podman**, you will also
    have available equivalent command-line tools.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker Compose** 是 Docker Inc. 开发的一款工具，帮助开发人员在多个容器中运行的应用程序中创建、交付和运行多个组件。这个工具可能随
    Docker 容器运行时分发版一起提供，或者需要单独安装。如果你使用诸如 **Podman** 的工具，也会提供等效的命令行工具。'
- en: Docker Compose, developed in 2014 as an open source project, aims to manage
    multiple containers based on YAML definitions. This command line will talk directly
    with the Docker container runtime API. This means that all containers managed
    by a `docker-compose` file will run together on top of the same container runtime,
    hence on the same host. Understanding this is key because you will need third-party
    tools and configurations if you need to provide high availability for your applications.
    We can think of Docker Compose as a single-node container orchestrator.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 于2014年作为一个开源项目开发，旨在基于 YAML 定义管理多个容器。该命令行将直接与 Docker 容器运行时 API
    进行交互。这意味着所有由 `docker-compose` 文件管理的容器将一起运行在同一个容器运行时之上，因此在同一主机上。理解这一点非常重要，因为如果需要为你的应用提供高可用性，你将需要使用第三方工具和配置。我们可以将
    Docker Compose 看作是一个单节点容器编排器。
- en: 'If you are using Docker Desktop, you will notice that Docker Compose is already
    available for you. It should be integrated into your WSL environment if you checked
    the **Enable integration** option in your Docker Desktop (this option should be
    already checked for all previous chapters’ labs and examples in your environment).
    You can verify this by quickly accessing your Docker Desktop’s settings by navigating
    to **Settings** | **Resources** | **WSL Integration**:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Docker Desktop，你会注意到 Docker Compose 已经为你提供了。它应该已经集成到你的 WSL 环境中，如果你在
    Docker Desktop 中勾选了**启用集成**选项（该选项应该在你环境中的所有前几章实验和示例中已经勾选）。你可以通过快速访问 Docker Desktop
    设置来验证这一点，路径为**设置** | **资源** | **WSL 集成**：
- en: '![Figure 5.1 – Docker Desktop WSL Integration settings](img/B19845_05_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – Docker Desktop WSL 集成设置](img/B19845_05_01.jpg)'
- en: Figure 5.1 – Docker Desktop WSL Integration settings
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – Docker Desktop WSL 集成设置
- en: 'Then, you can open a terminal in your WSL environment and simply execute `which
    docker-compose`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以在 WSL 环境中打开终端，并简单地执行 `which docker-compose`：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Docker Desktop installs a modern Docker CLI environment, and this includes
    a `docker-compose` built-in link. You can verify this by simply retrieving the
    related information as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Desktop 安装了一个现代的 Docker CLI 环境，这包括一个内置的 `docker-compose` 链接。你可以通过简单地检索相关信息来验证这一点，如下所示：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Therefore, we can use either `docker-compose` or `docker compose` for running
    `compose` commands.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以使用 `docker-compose` 或 `docker compose` 来运行 `compose` 命令。
- en: 'If you are using the Docker container runtime directly on your computer and
    your client environment does not include this built-in link, you will need to
    properly install `docker-compose` binaries. You can use any of the following procedures:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你直接在计算机上使用 Docker 容器运行时，并且客户端环境中没有这个内置链接，你需要正确安装 `docker-compose` 二进制文件。你可以使用以下任何一种方法：
- en: '`docker-compose` module by using the Python package installer (`pip install
    docker-compose`). This will install the latest Python-based `docker-compose` release
    (1.29.2):'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 包管理器安装 `docker-compose` 模块（`pip install docker-compose`）。这将安装最新的基于
    Python 的 `docker-compose` 版本（1.29.2）：
- en: '[PRE2]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'However, this method will be deprecated as newer `docker-compose` binaries
    are built using the Go language. We can check the version currently installed
    by using the `–``version` argument:'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，这种方法将在新版本的 `docker-compose` 二进制文件使用 Go 语言构建后被淘汰。我们可以使用 `--version` 参数检查当前安装的版本：
- en: '[PRE3]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`docker-compose` package. We will show you the steps for Ubuntu 22.04, which
    provides the required package and its dependencies:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-compose` 包。我们将展示在 Ubuntu 22.04 上的安装步骤，该版本提供了所需的软件包及其依赖项：'
- en: '[PRE4]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, this method also installs the latest Python-based version of
    `docker-compose`:'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，这种方法还会安装最新的基于 Python 的 `docker-compose` 版本：
- en: '[PRE5]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Docker Compose v1 will be deprecated in June, 2023\. We should use at least
    Docker Compose v2 and an appropriate command-line release based on Go. This release
    may be installed automatically with Docker Desktop, as mentioned at the beginning
    of this section, or by using Docker Compose as a Docker client plugin.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Docker Compose v1 将在 2023 年 6 月被淘汰。我们应该至少使用 Docker Compose v2 和基于 Go 的适当命令行版本。该版本可以通过
    Docker Desktop 自动安装，正如本节开头所提到的，或者通过将 Docker Compose 作为 Docker 客户端插件安装。
- en: '`docker-compose-plugin`. We will show you the following Ubuntu process as an
    example:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-compose-plugin`。我们将以以下 Ubuntu 过程为例：'
- en: '[PRE6]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Important note
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'It is possible to install `docker-compose` directly by downloading its binary
    from the project’s GitHub repository. You can use the following link for further
    instructions: [https://docs.docker.com/compose/install/linux/#install-the-plugin-manually](https://docs.docker.com/compose/install/linux/#install-the-plugin-manually).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以直接通过从项目的 GitHub 仓库下载其二进制文件来安装 `docker-compose`。你可以使用以下链接查看进一步的安装说明：[https://docs.docker.com/compose/install/linux/#install-the-plugin-manually](https://docs.docker.com/compose/install/linux/#install-the-plugin-manually)。
- en: 'Once we install `docker-compose` by following any of the methods described,
    we are ready to quickly review the main features available:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们按照任何一种方法安装了 `docker-compose`，就可以快速回顾可用的主要功能：
- en: We can build multiple images, code blocks, and Dockerfiles, which may be separated
    into different folders. This is very useful for automating the construction of
    all application components at once.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以构建多个镜像、代码块和 Dockerfile，它们可以分布在不同的文件夹中。这对于自动化一次性构建所有应用组件非常有用。
- en: Sharing the applications’ container image components is easier with `docker-compose`,
    as all images will be pushed at once.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `docker-compose` 共享应用的容器镜像组件更加简便，因为所有镜像将一次性推送。
- en: We can start and stop applications based on multiple containers with `docker-compose`.
    All components will run at the same time by default, although we can define dependencies
    between components.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `docker-compose` 启动和停止基于多个容器的应用。所有组件默认情况下将同时运行，尽管我们可以定义组件间的依赖关系。
- en: All applications’ standard errors and output will be available from a single
    command, which means that we can access all application logs at once. This will
    be very useful when debugging interactions between multiple components at the
    same time.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有应用的标准错误和输出将通过单一命令获取，这意味着我们可以一次性访问所有应用日志。这在调试多个组件之间的交互时非常有用。
- en: Provisioning and decommissioning environments are very easy using `docker-compose`,
    as all required application components will be created and removed by using simple
    actions such as `docker compose create` and `docker` `compose rm`.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `docker-compose` 来提供和淘汰环境非常简单，因为所有必需的应用组件都可以通过简单的操作如 `docker compose create`
    和 `docker compose rm` 创建和删除。
- en: '`docker-compose` perfect for easily sharing data and isolating inter-process
    communication. We will publish only specific application processes, while others
    will be kept internal, hidden from the users.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-compose` 非常适合轻松共享数据并隔离进程间通信。我们将只发布特定的应用进程，其他进程将保持内部运行，用户无法看到。'
- en: We will use `<PROJECT>-<SERVICE_NAME>` syntax. We can retrieve the list of running
    projects by using `docker-compose ls`. This command will show you all running
    `docker-compose` projects with their Compose YAML file definitions.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用 `<PROJECT>-<SERVICE_NAME>` 语法。我们可以通过使用 `docker-compose ls` 命令来获取运行中的项目列表。此命令将展示所有正在运行的
    `docker-compose` 项目及其 Compose YAML 文件定义。
- en: By using `docker-compose --profile prod up --detach` to launch our application
    in production, while using `--profile debug` will run some additional components/services
    for debugging. We will use the `profile` key in our Compose YAML file to group
    services, which can be added to multiple profiles. We will use a string to define
    these profiles and we will use it later in the `docker-compose` command line.
    If no profile is specified, `docker-compose` will execute the actions without
    using any profile (objects with no profile will be used).
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用 `docker-compose --profile prod up --detach` 启动生产环境中的应用，而使用 `--profile debug`
    将运行一些额外的组件/服务进行调试。我们将在 Compose YAML 文件中使用 `profile` 键来分组服务，服务可以被添加到多个配置文件中。我们将使用字符串来定义这些配置文件，并在后续的
    `docker-compose` 命令行中使用它们。如果没有指定配置文件，`docker-compose` 将在不使用任何配置文件的情况下执行操作（没有配置文件的对象将会被使用）。
- en: 'The following list shows the main actions available for `docker-compose`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了 `docker-compose` 的主要操作：
- en: '`config`: This action will check and show a review of the Compose YAML file.
    It can be used in combination with `--services` or `--volumes` arguments to retrieve
    only these objects. As mentioned before, `--profile` can be used to specifically
    retrieve information about a certain set or group of objects.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config`：此操作将检查并展示 Compose YAML 文件的回顾。它可以与 `--services` 或 `--volumes` 参数结合使用，以仅获取这些对象。如前所述，`--profile`
    可用于特别获取某一组或一类对象的信息。'
- en: '`images`: This shows the images defined in our Compose YAML file. This will
    be useful if you are wondering whether images will need to be built or may already
    be present in your environment.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`images`：此命令展示了我们 Compose YAML 文件中定义的镜像。如果你在想是否需要构建镜像或镜像是否已经存在于你的环境中，这将非常有用。'
- en: '`build`: This action makes `docker-compose` a great tool, even if you are planning
    to deploy your applications on a container orchestration cluster such as Kubernetes,
    as we are able to build all our application components’ container images with
    just one command. Images created using `docker-compose` will include the project’s
    name in its name; hence, they will be identified as `<PROJECT_NAME>-<SERVICE_NAME>`.
    A Dockerfile should be included in all component directories, although we can
    override the building of certain images by specifying an image repository directly.
    Remember all the content we learned about tagging images in [*Chapter 3*](B19845_03.xhtml#_idTextAnchor082),
    *Shipping Docker Images*. We can modify the build context and the Dockerfile filename
    using the `context` and `dockerfile` keys, respectively. If our Dockerfile contains
    various targets, we can define which one will be used for building the service’s
    image by using the `target` key. Arguments can also be passed to the build process
    to modify the environment by using the `args` key with a list of the key-value
    pairs that should be included.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build`：即使你计划将应用程序部署到像Kubernetes这样的容器编排集群中，此操作也使得`docker-compose`成为一个非常强大的工具，因为我们可以通过一个命令构建所有应用组件的容器镜像。使用`docker-compose`创建的镜像将包含项目名称，因此它们将被标识为`<PROJECT_NAME>-<SERVICE_NAME>`。每个组件目录中应该包含一个Dockerfile，尽管我们可以通过直接指定镜像仓库来覆盖某些镜像的构建。记得我们在[*第3章*](B19845_03.xhtml#_idTextAnchor082)中学到的镜像标签知识，*发布Docker镜像*。我们可以通过`context`和`dockerfile`键来修改构建上下文和Dockerfile文件名。如果Dockerfile包含多个目标，我们可以通过`target`键定义用于构建服务镜像的目标。还可以通过`args`键传递构建过程中的参数，以使用一系列键值对来修改环境。'
- en: '`pull`/`push`: The images defined can be downloaded all at once and the build
    definitions can also be pushed to remote registries once your images are created.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pull`/`push`：定义的镜像可以一次性下载，镜像创建后，构建定义也可以推送到远程注册表。'
- en: '`up`: This action is equivalent to executing `docker run` for each component/service
    defined in our Compose YAML file. By default, `docker compose up` will start all
    the containers at once and our terminal will attach to all containers’ outputs,
    which may be interesting for testing but not for production (our terminal will
    be stuck attached to the processes, and we must use *Ctrl* + *P* + *Q* to detach
    from them). To avoid this situation, we should use the `-d` or `--detach` argument
    to launch our containers in the background. `docker-compose` also supports the
    `run` action, but this is generally used for running specific services one at
    a time.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`up`：此操作相当于对我们在Compose YAML文件中定义的每个组件/服务执行`docker run`。默认情况下，`docker compose
    up`会同时启动所有容器，并且我们的终端将附加到所有容器的输出，这对于测试可能很有趣，但对于生产环境来说则不适用（我们的终端将被附加到进程中，我们必须使用*Ctrl*
    + *P* + *Q*来脱离它们）。为了避免这种情况，我们应使用`-d`或`--detach`参数来将容器在后台启动。`docker-compose`还支持`run`操作，但通常用于一次运行特定服务。'
- en: '`down`: This action, as expected, does the opposite of `up`; it will stop and
    remove all the containers that are running. It is important to understand that
    new containers will be created if they were previously removed by using this action.
    Any persistent data must be stored outside of the container’s life cycle. To completely
    remove your application, remember to always remove the associated volumes. We
    can add the `--volumes` argument to force the removal of any associated volume.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`down`：此操作，顾名思义，执行与`up`相反的操作；它将停止并删除所有正在运行的容器。需要理解的是，如果之前使用此操作删除了容器，那么新的容器将被重新创建。任何持久化数据都必须存储在容器生命周期之外。要完全删除应用程序，请记得始终删除关联的卷。我们可以添加`--volumes`参数来强制删除任何关联的卷。'
- en: '`create`/`run`/`start`/`stop`/`rm`: All these actions are equivalent to the
    ones we learned about in [*Chapter 4*](B19845_04.xhtml#_idTextAnchor096), *Running
    Docker Containers*, but in this case, they will apply to multiple containers at
    once.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create`/`run`/`start`/`stop`/`rm`：这些操作等同于我们在[*第4章*](B19845_04.xhtml#_idTextAnchor096)中学到的操作，*运行Docker容器*，但在这种情况下，它们将应用于一次多个容器。'
- en: '`ps`: As we are running multiple containers for a project, this action will
    list all associated containers. Containers’ performances can be reviewed by using
    `docker-compose top`, which is an extension of the `docker stats` command we learned
    in [*Chapter 4*](B19845_04.xhtml#_idTextAnchor096), *Running* *Docker Containers*.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ps`：由于我们为一个项目运行多个容器，因此此操作将列出所有关联的容器。容器的性能可以通过使用`docker-compose top`来查看，这是我们在[*第4章*](B19845_04.xhtml#_idTextAnchor096)中学习的`docker
    stats`命令的扩展，*运行* *Docker容器*。'
- en: '`exec`: This option allows us to execute a command attached to one of the containers
    (in this case, a project’s service).'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exec`：这个选项允许我们执行附加到某个容器（在这种情况下是项目的服务）上的命令。'
- en: '`logs`: We can use `docker-compose logs` to retrieve all the project’s container
    logs. This is very useful for retrieving all application logs by using a single
    point of view and just one command. The container output will be separated by
    colors and all the filter options learned about in [*Chapter 4*](B19845_04.xhtml#_idTextAnchor096),
    *Running Docker Containers*, as well as by `--follow`, which continuously follows
    all of them. We can retrieve just one service log by adding the service name as
    an argument.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logs`：我们可以使用 `docker-compose logs` 来检索所有项目容器的日志。这对于通过单一视角和一个命令获取所有应用程序日志非常有用。容器输出将通过颜色进行区分，并且所有在[*第4章*](B19845_04.xhtml#_idTextAnchor096)《运行
    Docker 容器》中学到的过滤选项都会被应用，包括 `--follow`，它会持续跟踪所有日志。我们也可以通过将服务名称作为参数来仅检索某个服务的日志。'
- en: Important note
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Although you will usually execute `docker-compose` actions against all containers,
    it is possible to specify one service at a time by adding the specific service
    name, `docker-compose <ACTION> <SERVICE>`. This option is extensible to almost
    all commands and very useful for debugging purposes when things go wrong with
    some containers.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您通常会针对所有容器执行 `docker-compose` 操作，但也可以通过添加特定的服务名称来一次指定一个服务，`docker-compose
    <ACTION> <SERVICE>`。这个选项几乎适用于所有命令，并且在调试容器出现问题时非常有用。
- en: Now that we know how to install `docker-compose` and what features we may expect,
    we can learn how to create applications using it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道如何安装 `docker-compose` 以及可以期待的功能，我们就可以学习如何使用它来创建应用程序了。
- en: Introducing the Docker Compose file syntax
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Docker Compose 文件语法
- en: We will use `docker-compose` with a YAML file, in which we will define all the
    services, volumes, and networks that will run together and be managed as components
    of an application. The YAML file used should follow the **Compose application
    model** (more information is available at [https://github.com/compose-spec/compose-spec/blob/master/spec.md](https://github.com/compose-spec/compose-spec/blob/master/spec.md)).
    This model will distribute application components in **services** and their intercommunication
    with each other using **networks**. These networks provide the isolation and abstraction
    layers for our application containers. Services will store and share their data
    by using **volumes**.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用带有 YAML 文件的 `docker-compose`，在该文件中我们将定义所有将一起运行并作为应用程序组件进行管理的服务、卷和网络。所使用的
    YAML 文件应遵循 **Compose 应用模型**（更多信息请参见 [https://github.com/compose-spec/compose-spec/blob/master/spec.md](https://github.com/compose-spec/compose-spec/blob/master/spec.md)）。该模型将应用程序组件分布在
    **服务** 中，并通过 **网络** 进行互相通信。这些网络为我们的应用程序容器提供了隔离和抽象层。服务将使用 **卷** 来存储和共享它们的数据。
- en: Services may need additional configurations, and we will use **config** and
    **secret** resources to add specific information to manage the application’s behavior.
    These objects will be mounted inside our containers, and processes running inside
    them will use the provided configurations. Secrets will be used to inject sensitive
    data and the container runtime will treat them differently.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 服务可能需要额外的配置，我们将使用 **config** 和 **secret** 资源来添加特定的信息以管理应用程序的行为。这些对象将被挂载到我们的容器内，容器中的进程将使用提供的配置。Secrets
    将用于注入敏感数据，容器运行时将以不同的方式处理它们。
- en: As discussed earlier in this chapter, Compose v1 will be deprecated soon, and
    you should migrate to at least Compose v2\. Your files may need some changes.
    You can verify this by reviewing the documentation at [https://docs.docker.com/compose/compose-file/compose-versioning](https://docs.docker.com/compose/compose-file/compose-versioning).
    The Compose application model specification merges the object definitions from
    v2 and v3.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章前面讨论的，Compose v1 很快将被弃用，您应该迁移到至少 Compose v2。您的文件可能需要进行一些更改。您可以通过查看 [https://docs.docker.com/compose/compose-file/compose-versioning](https://docs.docker.com/compose/compose-file/compose-versioning)
    来验证这一点。Compose 应用模型规范融合了 v2 和 v3 的对象定义。
- en: Now, let’s deep dive into the Docker Compose YAML file definition keys.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解 Docker Compose YAML 文件的定义关键字。
- en: YAML file definition keys
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: YAML 文件定义关键字
- en: By default, the `docker-compose` command will look for `docker-compose.yaml`
    or `compose.yaml` files in the current directory (you can use either `.yaml` or
    `.yml` extensions). Multiple Compose files can be used at the same time, and the
    order in which they appear will define the final file specification to use. Values
    will be overridden by the latest ordered file. We can also use variables that
    can be expanded in runtime by setting our environment variables. This will help
    us use a general file with variables for multiple environments.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`docker-compose` 命令将在当前目录中查找 `docker-compose.yaml` 或 `compose.yaml` 文件（你可以使用
    `.yaml` 或 `.yml` 扩展名）。可以同时使用多个 Compose 文件，它们出现的顺序将决定最终使用的文件规范。值将被最新的文件覆盖。我们还可以使用在运行时可以扩展的变量，通过设置环境变量来实现。这将帮助我们使用一个包含变量的通用文件来支持多个环境。
- en: 'The basic schema of a Compose YAML file will be presented as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Compose YAML 文件的基本结构如下所示：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Each service will need at least a container image definition or a directory
    where its Dockerfile is located.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务至少需要一个容器镜像定义或一个包含 Dockerfile 的目录。
- en: 'Let’s review the Compose syntax with an example file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例文件来回顾 Compose 语法：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first line is used to identify the Compose syntax version used. Currently,
    the `version` key is only informative, added for backward compatibility. If some
    keys are not allowed in the current Compose release, we will be warned, and those
    keys will be ignored. At the time of writing this book, Compose YAML files do
    not require this `version` key.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行用于标识使用的 Compose 语法版本。目前，`version` 键仅用于提供信息，添加此项是为了向后兼容。如果某些键在当前 Compose 版本中不被允许，我们将会收到警告，并且这些键将会被忽略。在撰写本书时，Compose
    YAML 文件不要求包含 `version` 键。
- en: 'This Compose YAML file contains three service definitions: `lb`, `db`, and
    `app`. All of them have an `image` key, which defines the image repository that
    will be used for creating each service. We also have a `build` key, which defines
    the directory that will be used for building the defined image. Having both keys
    will allow us to create the required image with the defined name before executing
    the service. As you may have noticed, we have defined dependencies for the `app`
    service. This service depends on the `lb` and `db` services; hence, their containers
    must be running and healthy before any `app` container starts. Health checks defined
    in each container image will be used to verify the healthiness of the container’s
    processes. That’s why you, as a developer, should define the appropriate health
    checks for your application’s components.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此 Compose YAML 文件包含三个服务定义：`lb`、`db` 和 `app`。它们都包含一个 `image` 键，定义了用于创建每个服务的镜像仓库。我们还有一个
    `build` 键，定义了用于构建镜像的目录。拥有这两个键将允许我们在执行服务之前，先创建具有指定名称的镜像。正如你可能注意到的，我们为 `app` 服务定义了依赖关系。该服务依赖于
    `lb` 和 `db` 服务，因此它们的容器必须在任何 `app` 容器启动之前处于运行并健康的状态。每个容器镜像中定义的健康检查将用于验证容器进程的健康状态。因此，作为开发者，你应该为应用组件定义适当的健康检查。
- en: Important note
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Although, in this example, we used the `depends_on` key, it is very important
    to include the management of different component dependencies in our application’s
    code. This is important because the `depends_on` key is only available in Compose
    YAML files. When you deploy your applications in Docker Swarm or Kubernetes, the
    dependencies can’t be managed in the same way. Compose manages dependencies for
    you, but this feature does not exist in orchestrated environments and your applications
    should be prepared for that. You may, for example, verify the connectivity with
    your database component before executing certain tasks, or you might manage the
    exceptions in your code related to the loss of this connection. Your application
    component may need several components, and you should decide what your application
    has to do if one of them is down. Key application components should stop your
    code in case full application functionality breaks.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个例子中我们使用了 `depends_on` 键，但在我们的应用代码中，管理不同组件之间的依赖关系是非常重要的。这一点很重要，因为 `depends_on`
    键仅在 Compose YAML 文件中有效。当你在 Docker Swarm 或 Kubernetes 中部署应用时，依赖关系不能以同样的方式进行管理。Compose
    会为你管理依赖关系，但在编排环境中并没有这个功能，你的应用程序应该为此做好准备。例如，你可能需要在执行某些任务之前验证与数据库组件的连接，或者你可能需要在代码中处理因失去连接而导致的异常。你的应用组件可能需要多个组件，你应该决定在其中一个组件发生故障时你的应用该如何处理。如果关键的应用组件发生故障，应该停止代码执行，以避免整个应用的功能中断。
- en: In this example, we also defined one volume, `pgdata`, and a network, `simplestlab`.
    The `volumes` and `networks` sections allow us to define objects to be used by
    the containers. Each defined service should include the volumes and networks that
    should be attached to the service’s containers. Containers associated with a service
    will be named after the service name, including the project as a prefix. Each
    container is considered an instance for the service and will be numbered; hence,
    the final container will be named `<PROJECT_NAME>-<SERVICE_NAME>-<INSTANCE_NUMBER>`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们还定义了一个卷 `pgdata` 和一个网络 `simplestlab`。`volumes` 和 `networks` 部分允许我们定义容器使用的对象。每个定义的服务应包含应附加到该服务容器的卷和网络。与服务关联的容器将以服务名称命名，并加上项目作为前缀。每个容器被视为服务的一个实例，并将进行编号；因此，最终容器的名称将是
    `<PROJECT_NAME>-<SERVICE_NAME>-<INSTANCE_NUMBER>`。
- en: We can have more than one instance per service. This means that multiple containers
    may run for a defined service. We will use `--scale SERVICE_NAME=<NUMBER_OF_REPLICAS>`
    to define the number of replicas that should be running for a specific service.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为每个服务配置多个实例。这意味着可以为一个定义的服务运行多个容器。我们将使用 `--scale SERVICE_NAME=<NUMBER_OF_REPLICAS>`
    来定义为特定服务运行的副本数量。
- en: Important note
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As mentioned before, dynamic names will be used for the service containers,
    but we can use the `container_name` key to define a specific name. This may be
    interesting for accessing a container name from other containers, but this service
    wouldn’t be able to scale because, as you already know, container names are unique
    for each container runtime; thus, we cannot manage replicas in this situation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，服务容器将使用动态名称，但我们可以使用 `container_name` 键来定义一个特定的名称。这对于从其他容器访问容器名称可能很有用，但此服务将无法扩展，因为如你所知，容器名称对于每个容器运行时都是唯一的，因此在这种情况下我们无法管理副本。
- en: 'Compose YAML files allow us to overwrite all the keys defined in the container
    images. We will include them inside each `services` definition block. In the presented
    example, we have included some environment variables for all services:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Compose YAML 文件允许我们覆盖容器镜像中定义的所有键。我们将在每个 `services` 定义块内包含它们。在示例中，我们为所有服务添加了一些环境变量：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you may notice, these environment variables define some configurations that
    will change the application components’ behavior. Some of these configurations
    contain sensitive data, and we can use additional Compose objects such as `secrets`.
    Non-sensitive data can be written using `config` objects.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能注意到的，这些环境变量定义了一些将改变应用组件行为的配置。这些配置中有些包含敏感数据，我们可以使用额外的 Compose 对象，如 `secrets`。非敏感数据可以使用
    `config` 对象写入。
- en: 'For these objects, an additional key will be used at the root level:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些对象，将在根级别使用一个额外的键：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, we changed all the `app` component environment variables for
    a `config` object, which will be mounted inside the container.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将所有 `app` 组件的环境变量更改为一个 `config` 对象，该对象将会被挂载到容器内。
- en: Important note
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: By default, `config` object files will be mounted in `/<source>` if no `target`
    key is used. Although there is a short version for mounting `config` object files
    inside service containers, it is recommended to use the presented long format,
    as it allows us to specify the complete paths for both `source` and `target`,
    as well as the file’s permissions and ownership.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果未使用 `target` 键，`config` 对象文件将会挂载到 `/<source>` 中。虽然有一种简短的方式可以将 `config`
    对象文件挂载到服务容器内，但建议使用长格式，因为它允许我们指定 `source` 和 `target` 的完整路径，以及文件的权限和所有权。
- en: Secret objects are only available in `swarm` mode. This means that even if you
    are just using a single node, you must execute `docker swarm init` to initialize
    a single-node Swarm cluster. This will allow us to create secrets, which are stored
    as cluster objects by the Docker container engine. Compose can manage these objects
    and present them in our service’s containers. By default, secrets will be mounted
    inside containers in the `/run/secrets/<SECRET_NAME>` path, but this can be changed,
    as we will see in the following example.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密对象仅在 `swarm` 模式下可用。这意味着即使你只使用一个节点，你也必须执行 `docker swarm init` 来初始化一个单节点的 Swarm
    集群。这将允许我们创建秘密，秘密会作为集群对象由 Docker 容器引擎存储。Compose 可以管理这些对象并将它们展示在我们服务的容器内。默认情况下，秘密会被挂载到容器中的
    `/run/secrets/<SECRET_NAME>` 路径，但我们可以在接下来的例子中看到，这个路径是可以更改的。
- en: 'First, we create a secret with the database password, used in the `db` service,
    by using `docker` `secret create`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过 `docker` `secret create` 创建一个包含数据库密码的秘密，该密码用于 `db` 服务：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we can change our Compose YAML file to include this new `secret`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以修改我们的 Compose YAML 文件，加入这个新的 `secret`：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this example, we created the secret using the standard output and we used
    `external: true` to declare that the secret is already set and the container runtime
    must use its key store to find it. We could have used a file instead as the source.
    It is also common to integrate some files as `secrets` inside containers by adding
    them in the following format:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个示例中，我们通过标准输出创建了一个秘密，并使用 `external: true` 来声明该秘密已被设置，容器运行时必须使用其密钥存储来查找它。我们本来也可以使用文件作为来源。通常，也会通过以下格式将某些文件集成为容器内的
    `secrets`：'
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The main difference here is that you may be using a plain text file as a secret
    that will be encrypted by the Docker container runtime and mounted inside your
    containers. Anyone with access to this plain text file will read your secrets.
    Using the standard output increases security because only the container runtime
    will have access to the `secret` object. In fact, the Docker Swarm store can also
    be encrypted, adding a new layer of security.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要区别在于，你可能会使用一个普通文本文件作为秘密，该文件将由 Docker 容器运行时加密并挂载到容器内部。任何可以访问该普通文本文件的人都能读取你的秘密。使用标准输出提高了安全性，因为只有容器运行时可以访问
    `secret` 对象。事实上，Docker Swarm 存储也可以被加密，增加了一层新的安全保障。
- en: Now that we understand the basic Compose YAML syntax, we can continue learning
    how to use these files to build and share our application’s container images.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了基本的 Compose YAML 语法，我们可以继续学习如何使用这些文件来构建和共享我们的应用容器镜像。
- en: Building and sharing multi-container applications
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和共享多容器应用
- en: Docker Compose allows you to run multi-container applications on single nodes.
    These applications will not really have high availability, as you will have a
    single point of failure and you will probably prefer to use orchestrated clusters
    by using Kubernetes or Docker Swarm. But even in these situations, `docker-compose`
    will help you build and manage the container images for your project. In this
    section, we will learn how to use these features.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 允许你在单个节点上运行多容器应用程序。这些应用程序实际上并不会具备高可用性，因为你会有单点故障，而且你可能更倾向于使用 Kubernetes
    或 Docker Swarm 来使用集群编排。然而，即便在这些情况下，`docker-compose` 仍然可以帮助你构建和管理项目的容器镜像。在本节中，我们将学习如何使用这些功能。
- en: Your Compose YAML file will have some service definitions, and each service’s
    container will need an image definition or a `build` directory. The `image` key
    will be used for either downloading this image from a registry (if it does not
    exist in your container runtime already) or setting the name of the service’s
    container image to be created if a `build` folder exists. As we already mentioned
    in the previous section, the project’s name will be used as a prefix for all your
    images by default, but having this `image` key overrides this. Project prefixes
    will help you identify all the images prepared for a project but may be confusing
    when a project must be executed twice (two different project instances). In such
    situations, it may be convenient to prepare and push your images for both projects
    instead of building them with default folder names.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 Compose YAML 文件将包含一些服务定义，每个服务的容器都需要一个镜像定义或 `build` 目录。`image` 键将用于下载该镜像（如果它在你的容器运行时中尚不存在）或设置服务容器镜像的名称，如果存在
    `build` 文件夹的话。如我们在前一节中提到的，项目名称将默认作为所有镜像的前缀，但有了这个 `image` 键则可以覆盖这一行为。项目前缀有助于你识别为项目准备的所有镜像，但当一个项目需要执行两次（两个不同的项目实例）时，可能会导致混淆。在这种情况下，将为两个项目分别准备并推送镜像，而不是使用默认的文件夹名称来构建镜像，会更为方便。
- en: 'We will now focus on the `build`-related keys:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将专注于与 `build` 相关的键：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As we mentioned, the `image` key defines the images to be downloaded but in
    this situation, the `build` key is also present with a folder string, which means
    that this folder will be used for building the image:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所述，`image` 键定义了要下载的镜像，但在这种情况下，`build` 键也存在，并且带有一个文件夹字符串，这意味着这个文件夹将用于构建镜像：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you may notice, a project name is included to avoid using the default directory
    name as a prefix, but the images created used the repository and tag strings defined.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所注意到的，项目名称被包含在内，以避免使用默认的目录名作为前缀，但创建的镜像使用了定义的仓库和标签字符串。
- en: 'Let’s remove the `image` key lines and launch the `build` process again:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们删除 `image` 键行并重新启动 `build` 过程：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'services:'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 服务：
- en: 'frontend:'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前端：
- en: 'build:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构建：
- en: 'secrets:'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 秘密：
- en: '- server-certificate'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- server-certificate'
- en: 'secrets:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 秘密：
- en: 'server-certificate:'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 服务器证书：
- en: 'file: ./server.cert'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '文件: ./server.cert'
- en: '[PRE17]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'services:'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 服务：
- en: 'frontend:'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前端：
- en: 'build:'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构建：
- en: 'secrets:'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 秘密：
- en: '- source: server-certificate'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- 来源: server-certificate'
- en: 'target: server.cert'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目标：server.cert
- en: 'uid: "103"'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'uid: "103"'
- en: 'gid: "103"'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'gid: "103"'
- en: 'mode: 0440'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '模式: 0440'
- en: 'secrets:'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 秘密：
- en: 'server-certificate:'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 服务器证书：
- en: 'file: ./server.cert'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '文件: ./server.cert'
- en: '[PRE18]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: $ docker-compose --project-name test push --include-deps app
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: $ docker-compose --project-name test push --include-deps app
- en: '[+] Running 0/26bc077c4d137 Layer already exists   3.6s'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[+] 运行中 0/26bc077c4d137 层已存在   3.6秒'
- en: '⠇ Pushing lb: 0bc077c4d137 Layer already exists    3.8s'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '⠇ 正在推送 lb: 0bc077c4d137 层已存在    3.8秒'
- en: …
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: …
- en: '⠧ Pushing db: a65fdf68ac5a Layer already exists    3.7s'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '⠧ 正在推送 db: a65fdf68ac5a 层已存在    3.7秒'
- en: …
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: …
- en: '⠧ Pushing app: 7dfc1aa4c504 Layer already exists   3.7s'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '⠧ 正在推送 app: 7dfc1aa4c504 层已存在   3.7秒'
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: $ docker-compose ls
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: $ docker-compose ls
- en: NAME                STATUS              CONFIG FILES
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 名称                状态              配置文件
- en: test                running(3)          /home/frjaraur/labs/simplest-lab/docker-compose.yaml
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 测试                运行中(3)          /home/frjaraur/labs/simplest-lab/docker-compose.yaml
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: $ docker-compose --project-name test \
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: $ docker-compose --project-name test \
- en: --file /home/frjaraur/labs/simplest-lab/docker-compose.yaml ps
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: --file /home/frjaraur/labs/simplest-lab/docker-compose.yaml ps
- en: NAME                IMAGE                                         COMMAND                  SERVICE             CREATED             STATUS              PORTS
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 名称                镜像                                         命令                  服务             创建时间             状态              端口
- en: test-app-1          docker.io/frjaraur/simplest-lab:simplestapp   "node simplestapp.js…"   app                 25
    hours ago        Up 28 minutes       3000/tcp
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: test-app-1          docker.io/frjaraur/simplest-lab:simplestapp   "node simplestapp.js…"   app                 25小时前        运行中
    28分钟       3000/tcp
- en: test-db-1           docker.io/frjaraur/simplest-lab:simplestdb    "docker-entrypoint.s…"   db                  25
    hours ago        Up 24 minutes       5432/tcp
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: test-db-1           docker.io/frjaraur/simplest-lab:simplestdb    "docker-entrypoint.s…"   db                  25小时前        运行中
    24分钟       5432/tcp
- en: test-lb-1           docker.io/frjaraur/simplest-lab:simplestlb    "/entrypoint.sh
    /bin…"   lb                  25 hours ago        Up 24 minutes       0.0.0.0:8080->80/tcp
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: test-lb-1           docker.io/frjaraur/simplest-lab:simplestlb    "/entrypoint.sh
    /bin…"   lb                  25小时前        运行中 24分钟       0.0.0.0:8080->80/tcp
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: $ docker-compose --project-name test exec db ps -ef
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: $ docker-compose --project-name test exec db ps -ef
- en: PID   USER     TIME  COMMAND
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: PID   用户     时间  命令
- en: 1 postgres  0:00 postgres
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 1 postgres  0:00 postgres
- en: '53 postgres  0:00 postgres: checkpointer'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '53 postgres  0:00 postgres: 检查点'
- en: '54 postgres  0:00 postgres: background writer'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '54 postgres  0:00 postgres: 背景写入器'
- en: '55 postgres  0:00 postgres: walwriter'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '55 postgres  0:00 postgres: walwriter'
- en: '56 postgres  0:00 postgres: autovacuum launcher'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '56 postgres  0:00 postgres: autovacuum 启动器'
- en: '57 postgres  0:00 postgres: stats collector'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '57 postgres  0:00 postgres: stats collector'
- en: '58 postgres  0:00 postgres: logical replication launcher'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '58 postgres  0:00 postgres: logical replication 启动器'
- en: 90 root      0:00 ps -ef
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 90 root      0:00 ps -ef
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'env_file:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 'env_file:'
- en: '- ./debug.env'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '- ./debug.env'
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'services:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 服务：
- en: 'lb:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: lb：
- en: 'build:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 构建：
- en: 'context: ./simplestlb'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '上下文: ./simplestlb'
- en: 'args:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: 'alpineversion: "1.14"'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 'alpine版本: "1.14"'
- en: 'dockerfile: Dockerfile.${environment}'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 'dockerfile: Dockerfile.${environment}'
- en: 'labels:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 标签：
- en: 'org.codegazers.description: "Test image"'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 'org.codegazers.description: "测试镜像"'
- en: 'image: ${dockerhubid}/simplest-lab:simplestlb'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '镜像: ${dockerhubid}/simplest-lab:simplestlb'
- en: 'environment:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 环境：
- en: '- APPLICATION_ALIAS=simplestapp'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '- 应用别名=simplestapp'
- en: '- APPLICATION_PORT=${backend_port}'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '- 应用端口=${backend_port}'
- en: 'networks:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 网络：
- en: 'simplestlab:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 'simplestlab:'
- en: 'aliases:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 别名：
- en: '- simplestlb'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '- simplestlb'
- en: 'ports:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 端口：
- en: '- "${loadbalancer_port}:80"'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '- "${loadbalancer_port}:80"'
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: environment=dev
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 环境=dev
- en: dockerhubid=frjaraur
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: dockerhubid=frjaraur
- en: loadbalancer_port=8080
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: loadbalancer端口=8080
- en: backend_port=3000
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 后端端口=3000
- en: '[PRE25]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: $ docker-compose --project-name test \
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: $ docker-compose --project-name test \
- en: --file myapp-docker-compose.yaml config
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: --file myapp-docker-compose.yaml 配置
- en: 'name: test'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '名称: test'
- en: 'services:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 服务：
- en: 'lb:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: lb：
- en: '...'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 'context: /home/frjaraur/tests/dcadeg/chapter5/simplest-lab/simplestlb'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '上下文: /home/frjaraur/tests/dcadeg/chapter5/simplest-lab/simplestlb'
- en: 'dockerfile: Dockerfile.dev'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 'dockerfile: Dockerfile.dev'
- en: 'args:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: 'alpineversion: "1.14"'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 'alpine版本: "1.14"'
- en: 'labels:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 标签：
- en: 'org.codegazers.description: Test image'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 'org.codegazers.description: 测试镜像'
- en: 'environment:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 环境：
- en: 'APPLICATION_ALIAS: simplestapp'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 应用别名：simplestapp
- en: 'APPLICATION_PORT: "3000"'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '应用端口: "3000"'
- en: 'image: frjaraur/simplest-lab:simplestlb'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '镜像: frjaraur/simplest-lab:simplestlb'
- en: '...'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 'ports:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 端口：
- en: '- mode: ingress'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '- 模式: ingress'
- en: 'target: 80'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '目标: 80'
- en: 'published: "8080"'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '已发布: "8080"'
- en: 'protocol: tcp'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 协议：tcp
- en: 'networks:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 网络：
- en: '...'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '[PRE26]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: $ dockerhubid=myid \
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: $ dockerhubid=myid \
- en: docker-compose --project-name test \
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: docker-compose --project-name test \
- en: --file myapp-docker-compose.yaml config
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: --file myapp-docker-compose.yaml 配置
- en: …
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: …
- en: 'image: myid/simplest-lab:simplestlb'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像：myid/simplest-lab:simplestlb
- en: '...'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: …
- en: '[PRE27]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'version: "3.7"'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 版本："3.7"
- en: 'services:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 服务：
- en: 'lb:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: lb：
- en: 'build: simplestlb'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 构建：simplestlb
- en: 'image: myregistry/simplest-lab:simplestlb'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像：myregistry/simplest-lab:simplestlb
- en: 'environment:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 环境：
- en: '- APPLICATION_ALIAS=simplestapp'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '- APPLICATION_ALIAS=simplestapp'
- en: '- APPLICATION_PORT=3000'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '- APPLICATION_PORT=3000'
- en: 'networks:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 网络：
- en: 'simplestlab:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: simplestlab：
- en: 'aliases:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 别名：
- en: '- simplestlb'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '- simplestlb'
- en: 'ports:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 端口：
- en: '- "8080:80"'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '- "8080:80"'
- en: 'db:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: db：
- en: 'build: simplestdb'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 构建：simplestdb
- en: 'image: myregistry/simplest-lab:simplestdb'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像：myregistry/simplest-lab:simplestdb
- en: 'environment:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 环境：
- en: '- "POSTGRES_PASSWORD=changeme"'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '- "POSTGRES_PASSWORD=changeme"'
- en: 'networks:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 网络：
- en: 'simplestlab:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: simplestlab：
- en: 'aliases:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 别名：
- en: '- simplestdb'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '- simplestdb'
- en: 'volumes:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 卷：
- en: '- pgdata:/var/lib/postgresql/data'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '- pgdata:/var/lib/postgresql/data'
- en: 'app:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 应用：
- en: 'build: simplestapp'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 构建：simplestapp
- en: 'image: myregistry/simplest-lab:simplestapp'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像：myregistry/simplest-lab:simplestapp
- en: 'environment:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 环境：
- en: '- dbhost=simplestdb'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '- dbhost=simplestdb'
- en: '- dbname=demo'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '- dbname=demo'
- en: '- dbuser=demo'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '- dbuser=demo'
- en: '- dbpasswd=d3m0'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '- dbpasswd=d3m0'
- en: 'networks:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 网络：
- en: 'simplestlab:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: simplestlab：
- en: 'aliases:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 别名：
- en: '- simplestapp'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '- simplestapp'
- en: 'depends_on:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于：
- en: '- lb'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '- lb'
- en: '- db'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '- db'
- en: 'volumes:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 卷：
- en: 'pgdata:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: pgdata：
- en: 'networks:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 网络：
- en: 'simplestlab:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: simplestlab：
- en: 'ipam:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ipam：
- en: 'driver: default'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动：默认
- en: 'config:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 配置：
- en: '- subnet: 172.16.0.0/16'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '- 子网：172.16.0.0/16'
- en: '[PRE28]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: $ docker-compose --file \
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker-compose --file \
- en: simplestlab/docker-compose.yaml \
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: simplestlab/docker-compose.yaml \
- en: --project-name chapter5 build
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --project-name chapter5 build
- en: '[+] Building 0.0s (0/0)'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[+] 正在构建 0.0s (0/0)'
- en: …
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: …
- en: => => writing image sha256:2d88460e20ca557fcd25907b5f026926b0e61d93fde58a8e0b854cfa0864c3bd                       0.0s
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: => => 写入镜像 sha256:2d88460e20ca557fcd25907b5f026926b0e61d93fde58a8e0b854cfa0864c3bd
    0.0s
- en: docker-compose run to build or pull the images and run all containers, but this
    way, we can review the process step by step.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: docker-compose run 来构建或拉取镜像并运行所有容器，但通过这种方式，我们可以逐步回顾过程。
- en: '[PRE29]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: $ docker image ls
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker image ls
- en: REPOSITORY                TAG           IMAGE ID       CREATED         SIZE
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 仓库                       标签          镜像ID          创建时间          大小
- en: myregistry/simplest-lab   simplestapp   2d88460e20ca   8 minutes ago   73.5MB
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: myregistry/simplest-lab simplestapp 2d88460e20ca 8分钟前 73.5MB
- en: myregistry/simplest-lab   simplestdb    e872ee4e9593   8 minutes ago   243MB
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: myregistry/simplest-lab simplestdb e872ee4e9593 8分钟前 243MB
- en: build key exists, the build process is executed instead of pulling images directly.
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构建键存在时，执行构建过程，而不是直接拉取镜像。
- en: '[PRE30]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: $ docker-compose --file \
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker-compose --file \
- en: simplestlab/docker-compose.yaml \
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: simplestlab/docker-compose.yaml \
- en: --project-name chapter5 create db
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --project-name chapter5 创建 db
- en: '[+] Running 3/3'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[+] 正在运行 3/3'
- en: ':: Network chapter5_simplestlab  Created                                              0.8s'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ':: 网络 chapter5_simplestlab 创建中 0.8s'
- en: ':: Volume "chapter5_pgdata"      Created                                                     0.0s'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ':: 卷 "chapter5_pgdata" 创建中 0.0s'
- en: ':: Container chapter5-db-1       Created                             0.2s'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ':: 容器 chapter5-db-1 创建中 0.2s'
- en: '[PRE31]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: $ docker-compose --file \
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker-compose --file \
- en: simplestlab/docker-compose.yaml \
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: simplestlab/docker-compose.yaml \
- en: --project-name chapter5 up -d db
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --project-name chapter5 up -d db
- en: '[+] Running 1/1'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[+] 正在运行 1/1'
- en: ':: Container chapter5-db-1  Started'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ':: 容器 chapter5-db-1 启动中'
- en: '[PRE32]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: $ docker-compose ps
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker-compose ps
- en: 'no configuration file provided: not found'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 没有提供配置文件：未找到
- en: $ docker-compose --file simplestlab/docker-compose.yaml ps
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker-compose --file simplestlab/docker-compose.yaml ps
- en: NAME                IMAGE               COMMAND             SERVICE             CREATED             STATUS              PORTS
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 名称                   镜像                        命令                     服务              创建时间           状态              端口
- en: '[PRE33]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: $ docker-compose --file \
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker-compose --file \
- en: simplestlab/docker-compose.yaml \
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: simplestlab/docker-compose.yaml \
- en: --project-name chapter5 ps
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --project-name chapter5 ps
- en: NAME                IMAGE                                COMMAND                  SERVICE             CREATED             STATUS              PORTS
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 名称                   镜像                         命令                     服务              创建时间           状态              端口
- en: 'lb and app services by using docker-compose up -d:'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过使用 docker-compose up -d 启动 lb 和 app 服务：
- en: '[PRE34]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: $ docker-compose --file \
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker-compose --file \
- en: simplestlab/docker-compose.yaml \
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: simplestlab/docker-compose.yaml \
- en: --project-name chapter5 ps
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --project-name chapter5 ps
- en: NAME                IMAGE                                 COMMAND                  SERVICE             CREATED             STATUS              PORTS
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 名称                   镜像                        命令                     服务              创建时间           状态              端口
- en: chapter5-app-1      myregistry/simplest-lab:simplestapp   "node simplestapp.js…"   app                 9
    minutes ago       Up 9 minutes        3000/tcp
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: chapter5-app-1 myregistry/simplest-lab:simplestapp "node simplestapp.js…" app
    9分钟前 正在运行9分钟 3000/tcp
- en: chapter5-db-1       myregistry/simplest-lab:simplestdb    "docker-entrypoint.s…"   db                  16
    minutes ago      Up 15 minutes       5432/tcp
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: chapter5-db-1 myregistry/simplest-lab:simplestdb "docker-entrypoint.s…" db 16分钟前
    启动 15分钟前 5432/tcp
- en: 'simplestlab application by connecting with your browser to http://127.0.0.1:8080:'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'simplestlab 应用可以通过浏览器访问 http://127.0.0.1:8080:'
- en: '[PRE36]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: $ docker-compose --file \
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker-compose --file \
- en: simplestlab/docker-compose.yaml \
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: simplestlab/docker-compose.yaml \
- en: --project-name chapter5 up --scale app=2 -d
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --project-name chapter5 up --scale app=2 -d
- en: '[+] Running 4/4'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[+] 正在运行 4/4'
- en: ':: Container chapter5-db-1   Running                          0.0s'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ':: 容器 chapter5-db-1 运行中 0.0s'
- en: ':: Container chapter5-lb-1   Running                           0.0s'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ':: 容器 chapter5-lb-1 运行中 0.0s'
- en: ':: Container chapter5-app-2  Created                               0.2s'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ':: 容器 chapter5-app-2 已创建 0.2s'
- en: 'app service’s logs. We will retrieve both containers’ logs:'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用服务日志。我们将获取两个容器的日志：
- en: '[PRE37]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: $ docker-compose --file \
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker-compose --file \
- en: simplestlab/docker-compose.yaml \
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: simplestlab/docker-compose.yaml \
- en: --project-name newdemo create
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --project-name newdemo create
- en: '[+] Running 0/0'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[+] 正在运行 0/0'
- en: ':: Network newdemo_simplestlab  Error    0.0s'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ':: 网络 newdemo_simplestlab 错误 0.0s'
- en: 'docker-compose definition:'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: docker-compose 定义：
- en: '[PRE39]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And now we try to deploy the application again:'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们再次尝试部署应用：
- en: '[PRE40]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: $ docker-compose --file simplestlab/docker-compose.yaml --project-name newdemo
    start
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker-compose --file simplestlab/docker-compose.yaml --project-name newdemo
    start
- en: '[+] Running 1/2'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[+] 正在运行 1/2'
- en: ':: Container newdemo-db-1  Started                            1.4s'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ':: 容器 newdemo-db-1 已启动 1.4s'
- en: ':: Container newdemo-lb-1  Starting                                    1.4s'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ':: 容器 newdemo-lb-1 启动中 1.4s'
- en: lb service. This seems fine for production, but defining a specific port in
    development, where multiple copies of an application can be expected, also breaks
    the dynamism of container-based components. For this to work, we could just simply
    change this port number, allow the system to choose a random one for us, or define
    a variable that will allow us to define a port for each project.
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: lb 服务。这个在生产环境中看起来是可以的，但是在开发环境中定义特定端口会破坏容器化组件的动态性，因为在开发中可能需要运行多个应用副本。为了让其正常工作，我们可以简单地更改端口号，让系统为我们选择一个随机端口，或者定义一个变量来为每个项目指定端口。
- en: '[PRE42]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'services:'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'services:'
- en: 'lb:'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'lb:'
- en: …
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: …
- en: 'ports:'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'ports:'
- en: '- "${LB_PORT}:80"'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- "${LB_PORT}:80"'
- en: '[PRE43]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: $ LB_PORT=8081 docker-compose --file \
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ LB_PORT=8081 docker-compose --file \
- en: simplestlab/docker-compose.yaml \
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: simplestlab/docker-compose.yaml \
- en: --project-name newdemo up lb
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --project-name newdemo up lb
- en: '[+] Running 1/1'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[+] 正在运行 1/1'
- en: ':: Container newdemo-lb-1  Recreated'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ':: 容器 newdemo-lb-1 已重新创建'
- en: '[PRE44]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: $ docker-compose --file simplestlab/docker-compose.yaml --project-name newdemo
    ps
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker-compose --file simplestlab/docker-compose.yaml --project-name newdemo
    ps
- en: WARN[0000] The "LB_PORT" variable is not set. Defaulting to a blank string.
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: WARN[0000] "LB_PORT" 变量未设置，默认值为空字符串。
- en: NAME                IMAGE                                COMMAND                  SERVICE             CREATED             STATUS              PORTS
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: NAME IMAGE COMMAND SERVICE CREATED STATUS PORTS
- en: newdemo-db-1        myregistry/simplest-lab:simplestdb   "docker-entrypoint.s…"   db                  11
    minutes ago      Up 8 minutes        5432/tcp
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: newdemo-db-1 myregistry/simplest-lab:simplestdb "docker-entrypoint.s…" db 11分钟前
    启动 8分钟前 5432/tcp
- en: newdemo-lb-1        myregistry/simplest-lab:simplestlb   "/entrypoint.sh /bin…"   lb                  46
    seconds ago      Up 34 seconds       0.0.0.0:8081->80/tcp
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: newdemo-lb-1 myregistry/simplest-lab:simplestlb "/entrypoint.sh /bin…" lb 46秒前
    启动 34秒前 0.0.0.0:8081->80/tcp
- en: $ docker-compose --file simplestlab/docker-compose.yaml --project-name newdemo
    up app -d
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker-compose --file simplestlab/docker-compose.yaml --project-name newdemo
    up app -d
- en: '[+] Running 3/3'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[+] 正在运行 3/3'
- en: ':: Container newdemo-db-1   Running                              0.0s'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ':: 容器 newdemo-db-1 运行中 0.0s'
- en: ':: Container newdemo-lb-1   Running                       0.0s'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ':: 容器 newdemo-lb-1 运行中 0.0s'
- en: 'docker-compose.yaml file, we were able to deploy a second project using a unique
    Compose YAML file. We can list the projects deployed in our host along with their
    number of components:'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: docker-compose.yaml 文件中，我们能够使用一个独特的 Compose YAML 文件部署第二个项目。我们可以列出主机上部署的项目及其组件数量：
- en: '[PRE45]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: $ docker-compose -f  /home/frjaraur/labs/Chapter5/simplestlab/docker-compose.yaml
    --project-name chapter5 down
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker-compose -f /home/frjaraur/labs/Chapter5/simplestlab/docker-compose.yaml
    --project-name chapter5 down
- en: WARN[0000] The "LB_PORT" variable is not set. Defaulting to a blank string.
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: WARN[0000] "LB_PORT" 变量未设置，默认值为空字符串。
- en: '[+] Running 5/5'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[+] 正在运行 5/5'
- en: ':: Container chapter5-app-2      Removed                          0.1s'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ':: 容器 chapter5-app-2 已删除 0.1s'
- en: ':: Container chapter5-app-1      Removed                          0.1s'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ':: 容器 chapter5-app-1      已移除                          0.1s'
- en: ':: Container chapter5-db-1       Removed                          0.1s'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ':: 容器 chapter5-db-1       已移除                          0.1s'
- en: ':: Container chapter5-lb-1       Removed                          0.1s'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ':: 容器 chapter5-lb-1       已移除                          0.1s'
- en: ':: Network chapter5_simplestlab  Removed                          0.6s'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ':: 网络 chapter5_simplestlab  已移除                          0.6s'
- en: '[PRE47]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: $ docker volume ls
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker volume ls
- en: DRIVER    VOLUME NAME
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: DRIVER    VOLUME NAME
- en: local     chapter5_pgdata
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: local     chapter5_pgdata
- en: 'chapter5 project, but we will use the --volumes argument to remove all the
    volumes associated with a project:'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: chapter5 项目，但我们将使用 --volumes 参数来移除与项目相关的所有卷：
- en: '[PRE48]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: $ docker volume ls
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker volume ls
- en: DRIVER    VOLUME NAME
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: DRIVER    VOLUME NAME
- en: local     chapter5_pgdata
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: local     chapter5_pgdata
- en: '[PRE49]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: $ docker volume rm  chapter5_pgdata
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker volume rm  chapter5_pgdata
- en: chapter5_pgdata
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: chapter5_pgdata
- en: '[PRE51]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Part 2:Container Orchestration
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：容器编排
- en: In this part of the book, we will cover the **orchestration** of containers
    in cluster-wide environments. We will learn how to deploy distributed component
    applications on different hosts in a cluster, allowing users to interact with
    components and publish services.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分中，我们将讲解如何在集群范围的环境中进行容器的**编排**。我们将学习如何在集群中的不同主机上部署分布式组件应用程序，允许用户与组件进行交互并发布服务。
- en: 'This part has the following chapters:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '*Chapter 6*, *Fundamentals of Orchestration*'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第六章*，*编排基础*'
- en: '[*Chapter 7*](B19845_07.xhtml#_idTextAnchor147), *Orchestrating with Swarm*'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第七章*](B19845_07.xhtml#_idTextAnchor147)，*与群体协作*'
- en: '[*Chapter 8*](B19845_08.xhtml#_idTextAnchor170), *Deploying Applications with
    the Kubernetes Orchestrator*'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第八章*](B19845_08.xhtml#_idTextAnchor170)，*使用 Kubernetes 编排器部署应用程序*'
