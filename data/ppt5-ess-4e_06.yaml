- en: The Puppet Beginners Advanced Parts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Puppet 初学者的进阶部分
- en: After our in-depth discussions on both the manifest structure elements (class
    and define) and encompassing structure (modules), you are in a great position
    to write manifests for all of your agents. Make sure that you get Forge modules
    that will allow them to do your work for you. Then go ahead and add site-specific
    modules that implement Forge modules to your needs. Finally, you will have composite
    classes for the `node` blocks to be used, or rather, included.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论了清单结构元素（class 和 define）以及整体结构（modules）之后，你已经处于一个很好的位置，可以为所有代理编写清单。确保你获得了可以帮助你工作的
    Forge 模块。然后，继续添加根据你需求实现 Forge 模块的特定站点模块。最后，你将拥有用于 `node` 块的组合类，可以被使用或包含。
- en: These concepts are quite a bit to take in. It's now time to decelerate a bit,
    lean back, and tackle simpler code structures and ideas. You are about to learn
    some techniques that you are not going to need every day. They can make difficult
    scenarios much easier, though. So, it might be a good idea to come back to this
    chapter again after you have spent some time in the field. You might find that
    some of your designs can be simplified with these tools.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念有些复杂。现在是时候稍微放慢一下节奏，靠后坐，处理一些更简单的代码结构和思路了。你即将学习一些不一定每天都用得上的技术，尽管如此，它们能让复杂的场景变得更简单。因此，在你实际工作一段时间后，再回过头来看这一章，可能会有帮助。你可能会发现，一些设计可以用这些工具简化。
- en: 'Specifically, these are the techniques that will be presented:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，以下是将要介绍的技术：
- en: Building dynamic configuration files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建动态配置文件
- en: Managing file snippets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理文件片段
- en: Using virtual resources
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用虚拟资源
- en: Cross-node configuration with exported resources
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨节点配置与导出资源
- en: Setting defaults for resource parameters
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为资源参数设置默认值
- en: Avoiding antipatterns
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免反模式
- en: Building dynamic configuration files
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建动态配置文件
- en: In the introduction, I stated that the techniques that you are now learning
    are not frequently required. That was true, except for this one topic. Templates
    are actually a cornerstone of configuration management with Puppet.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍部分，我提到过，你现在正在学习的技术并不常常需要。这是对的，除了一个话题。模板实际上是 Puppet 配置管理的基石。
- en: Templates are an alternative way to manage configuration files, or any files
    really. You have synchronized files from the master to an agent that handled some
    Apache configuration settings. These are not templates, technically. They are
    merely static files that have been prepared and are ready for carbon copying.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是管理配置文件或任何文件的另一种方式。你可以将主节点的文件同步到处理某些 Apache 配置设置的代理节点。严格来说，这些文件不是模板，它们只是已经准备好的静态文件，准备好进行复制粘贴。
- en: These static files suffice in many situations, but sometimes, you will want
    the master to manage very specific configuration values for each agent. These
    values can be quite individual. For example, an Apache server usually requires
    a `MaxClients` setting. Appropriate values depend on many aspects, including hardware
    specifications and characteristics of the web application that is being run. It
    would be impractical to prepare all possible choices as distinct files in the
    module.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些静态文件在很多情况下已经足够了，但有时候你会希望主节点为每个代理管理非常具体的配置值。这些值可能非常个性化。例如，Apache 服务器通常需要一个
    `MaxClients` 设置。适当的值取决于许多方面，包括硬件规格和运行的 Web 应用的特性。如果在模块中准备所有可能的选项作为独立文件是不可行的。
- en: Learning the template syntax
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习模板语法
- en: 'Templates make short work of such scenarios. With Puppet 4 EPP (embedded Puppet)
    templates were introduced. The older ERB (embedded Ruby) templates are still available
    and fully functional. If you know your way around PHP or JSP, you will quickly
    get the hang of EPP or ERB Puppet templates. The following EPP template will produce
    `Hello,world!` three times:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 模板可以轻松处理这种场景。在 Puppet 4 中，EPP（嵌入式 Puppet）模板被引入。旧版的 ERB（嵌入式 Ruby）模板仍然可用且功能完备。如果你熟悉
    PHP 或 JSP，你很快就能掌握 EPP 或 ERB Puppet 模板。以下 EPP 模板将输出 `Hello,world!` 三次：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following ERB template does the same:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 ERB 模板完成了相同的功能：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This template will also produce lots of empty lines, because the text between
    the `<%` and `%>` tags gets removed from the output but the final line breaks
    do not. To make the EPP engine do just that, change the closing tag to `-%>`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板也会产生很多空行，因为 `<%` 和 `%>` 标签之间的文本会从输出中移除，但最终的换行符不会被移除。为了让 EPP 引擎做到这一点，只需要将结束标签改为
    `-%>`：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This example is not very helpful for configuration files, of course. To include
    dynamic values in the output, enclose Ruby expressions in a `<%=tag` pair:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例当然对于配置文件不是很有帮助。要将动态值包含到输出中，请将 Ruby 表达式括在`<%=tag`对中：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, the iterator value is part of each line of the output. You can also use
    member variables that are prefixed with the `$` sign and use the full namespace
    to the variable.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，迭代器的值是输出每一行的一部分。你还可以使用以`$`符号为前缀的成员变量，并使用变量的完整命名空间。
- en: 'These variables are populated with the values from the Puppet manifest variables:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量被填充了来自 Puppet 清单变量的值：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Variables that are used in a template must be defined in the same scope or scopes
    from which the template is used. The next section explains how this works.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中使用的变量必须在使用模板的相同作用域或作用域中定义。下一部分将解释这是如何实现的。
- en: In Puppet 3.x, variable values are mostly strings, arrays, or hashes. To write
    efficient templates, it is helpful to occasionally glance at the methods available
    for the respective Ruby classes. In Puppet 4, variables have more diverse values.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puppet 3.x 中，变量值大多是字符串、数组或哈希。为了编写高效的模板，偶尔浏览相应 Ruby 类的方法是很有帮助的。在 Puppet 4 中，变量的值更加多样化。
- en: 'There are several ways to use Puppet variables in ERB templates:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方式可以在 ERB 模板中使用 Puppet 变量：
- en: 'Prefixing the variable with the `@` sign: This means that the variable is global,
    or it was defined in the same class where the template is used. This works with
    Puppet 2.7, Puppet 3, and Puppet 4'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`@`符号前缀变量：这意味着该变量是全局的，或者它是在使用模板的同一类中定义的。这在 Puppet 2.7、Puppet 3 和 Puppet 4
    中都适用。
- en: 'Using the `scope.lookupvar(''variablewithscopename'')` function: This allows
    you to refer to any variable in any class of the module. Please do not look up
    variables in other modules; it will build an invisible dependency on the other
    module. The syntax works with Puppet 2, Puppet 3, and Puppet 4'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`scope.lookupvar('variablewithscopename')`函数：这允许你引用模块中任何类中的任何变量。请不要在其他模块中查找变量；这样会在其他模块上建立一个隐性依赖关系。该语法适用于
    Puppet 2、Puppet 3 和 Puppet 4。
- en: 'Using `scope[''variablewithscope'']`: In Puppet 3, the scope hash can be used
    directly. The behavior is similar to `scope.lookupvar`. This will work with Puppet
    3 and Puppet 4'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`scope['variablewithscope']`：在 Puppet 3 中，可以直接使用作用域哈希。其行为类似于`scope.lookupvar`。这在
    Puppet 3 和 Puppet 4 中都适用。
- en: Using templates in practice
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在实践中使用模板
- en: 'Templates have their own place in modules. You can place them freely in the
    `templates/` subtree of the module. The `epp` function locates them using a simple
    descriptor: `epp(''cacti/apache/cacti.conf.epp'')`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 模板在模块中有其自己的位置。你可以自由地将它们放置在模块的`templates/`子树中。`epp`函数通过一个简单的描述符来定位它们：`epp('cacti/apache/cacti.conf.epp')`
- en: 'This expression evaluates the content of the template found in `modules/cacti/templates/apache/cacti.conf.epp`.
    The first path element (without a leading slash) is the module name. The rest
    of the path gets translated to the `templates/` tree in the module. The function
    is commonly used to generate the value of a `file` resource''s `content` property:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 该表达式计算位于`modules/cacti/templates/apache/cacti.conf.epp`中的模板内容。第一个路径元素（没有前导斜杠）是模块名称。其余的路径将被转换为模块中的`templates/`树。此函数通常用于生成`file`资源的`content`属性值：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Many templates expect some variables to be defined in their scope. The easiest
    way to make sure that this happens is to wrap the respective `file` resource in
    a parameterized container. Files that are **singletons** with a well-known name,
    such as `/etc/ssh/sshd_config`, should be managed through a parameterized class.
    Configuration items that can inhabit multiple files, such as `/etc/logrotate.d/*` or
    `/etc/apache2/conf.d/*`, are well suited to being wrapped in defined types:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 许多模板期望在它们的作用域中定义某些变量。确保这一点的最简单方法是将相应的`file`资源包装在一个参数化的容器中。那些具有已知名称的**单例**文件，如`/etc/ssh/sshd_config`，应该通过一个参数化类进行管理。可以包含多个文件的配置项，如`/etc/logrotate.d/*`或`/etc/apache2/conf.d/*`，非常适合通过定义的类型进行包装：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There is one main difference between EPP templates in classes compared to EPP
    templates in defines. EPP templates in classes can directly use the class variables
    with the namespace. A defined resource type does not have a fixed namespace. Therefore,
    it is required to add a mapping hash to the `epp` function, where we specify the
    variable inside the template and the corresponding variable inside the define.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的EPP模板与定义中的EPP模板之间有一个主要的区别。类中的EPP模板可以直接使用带命名空间的类变量。而定义的资源类型没有固定的命名空间。因此，需要向`epp`函数添加一个映射哈希，其中我们指定模板中的变量和定义中对应的变量。
- en: Afterwards, one can use the variables directly inside the template (`$pattern,
    $max_days, $options`).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，可以直接在模板中使用变量（`$pattern, $max_days, $options`）。
- en: 'For a quick and dirty string transformation of your data, you can also use
    the `inline_epp` function in your manifest. This is often found on the right-hand
    side of a variable assignment:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于快速且简便的数据字符串转换，你还可以在清单中使用`inline_epp`函数。这个函数通常出现在变量赋值的右侧：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This example assumes that the `$my_array` Puppet variable in the `my_class`
    class holds an array value.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例假设`my_class`类中的`$my_array` Puppet变量包含一个数组值。
- en: Avoiding performance bottlenecks from templates
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免模板中的性能瓶颈
- en: When using templates, both through the `epp` and `inline_epp` functions, be
    aware that each invocation implies a performance penalty for your Puppet master.
    During the compilation of the catalog, Puppet must initialize the EPP engine for
    any template it encounters. The EPP evaluation happens in an individual environment
    that is derived from the respective scope of the `epp` function invocation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用模板时，无论是通过`epp`还是`inline_epp`函数，都需要注意每次调用都会对Puppet主服务器带来性能损耗。在编译目录时，Puppet必须为它遇到的每个模板初始化EPP引擎。EPP评估发生在一个独立的环境中，该环境来自于`epp`函数调用的相应作用域。
- en: It is, therefore, not even important how complex your templates are. If your
    manifest requires frequent expansion of a very short template, it generates an
    enormous overhead for each initialization. Especially in the case of an easy `inline_epp`
    function, such as the one mentioned previously, it can be worthwhile to invest
    some more effort into creating a parser function instead, as seen in [Chapter
    5](3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml), *Combining Classes, Configuration
    Files, and Extensions into Modules*. A function can perform variable value transformation
    without incurring the cumulative penalty.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，模板的复杂度并不重要。如果你的清单需要频繁扩展一个非常简短的模板，那么每次初始化都会产生巨大的开销。特别是在使用简单的`inline_epp`函数时，如前所述，值得投入更多的精力来创建一个解析函数，正如在[第5章](3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml)中所看到的，*将类、配置文件和扩展合并为模块*。函数可以在不增加累积性能损失的情况下执行变量值转换。
- en: On the bright side, using templates is quite economic for the agent, who receives
    the whole textual file content right inside the catalog. There is no need to make
    an additional call to the master and retrieve file metadata. On a high-latency
    network, this can be a noticeable saving.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从积极的一面看，使用模板对于代理来说非常经济，因为代理可以直接在目录中接收到完整的文本文件内容。无需额外调用主服务器并检索文件元数据。在高延迟的网络环境下，这能带来明显的节省。
- en: There is no silver bullet here. Don't let the performance implications deter
    you from turning specific configuration files into templates. Template-based solutions
    will often make your module more maintainable, which will usually offset performance
    implications; hardware is constantly getting cheaper, after all. Just don't be
    wasteful with frequent (and simple) expansions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有万能的解决方案。不要让性能影响阻止你将特定的配置文件转换为模板。基于模板的解决方案通常会使你的模块更具可维护性，通常可以抵消性能上的影响；毕竟，硬件价格一直在下降。只要避免频繁（且简单）的扩展，就不会浪费资源。
- en: Managing file snippets
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理文件片段
- en: The next technique that we are going to discuss helps you solve conflicts in
    your manifests and build some elegant solutions in special situations. This mostly
    refers to configuration files where one is either not able to manage the whole
    file or where a file is constructed from different subclasses.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要讨论的技术帮助你解决清单中的冲突，并在特殊情况下构建一些优雅的解决方案。这主要指的是配置文件，其中一个文件可能无法完全管理，或者文件是由不同子类构建的。
- en: 'Puppet offers several ways to accomplish this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet提供了几种方法来实现这一点：
- en: Single line
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单行
- en: Single entry in a section
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个条目在一个部分中
- en: Building from multiple snippets
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从多个片段构建
- en: Other resource types
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他资源类型
- en: How do you deal with a configuration file, where a user may add additional content?
    What we have seen so far is management of complete configuration files, where
    changes will get reset. But think about the users `.bashrc` file, where the system
    administrator wants to ensure that the user is making use of a specific proxy.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如何处理一个配置文件，用户可能会添加额外的内容？到目前为止，我们看到的是管理完整的配置文件，在这些文件中，所做的更改将被重置。但考虑一下用户的`.bashrc`文件，系统管理员希望确保用户使用特定的代理。
- en: Normally, one can specify this globally in a `/etc/profile.d/` snippet. This
    is more meant to be a showcase.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，可以在`/etc/profile.d/`的片段中全局指定这一点。这更多的是作为展示。
- en: 'Puppet has a specific resource type which is able to manage a single line entry
    in a configuration file: the `file_line` resource type. This resource type is
    not a core resource type but is delivered by `stdlib` module.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet有一个特定的资源类型，可以管理配置文件中的单行条目：`file_line`资源类型。这个资源类型不是核心资源类型，但由`stdlib`模块提供。
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the previous example, the line will be added at the bottom of the file, if
    it is missing. If the line is already available, Puppet will not change the file.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，如果该行缺失，它将被添加到文件的底部。如果该行已经存在，Puppet将不会更改文件。
- en: 'Please remember that the `file_line` resource type expects that the file is
    already present on the system. If one is unsure about this, it is best practice
    to also manage the existence of the file without specifying content or source:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`file_line`资源类型要求文件已经存在于系统中。如果不确定这一点，最佳实践是管理文件的存在性，而不指定内容或源：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Single entry in a section
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分中的单个条目
- en: But what if one needs to configure a line within a configuration file which
    consists of sections? In this case, it is not a good idea to add the line at the
    bottom of the file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果需要在包含多个部分的配置文件中配置一行怎么办？在这种情况下，最好不要将该行添加到文件的底部。
- en: This is where the `ini_setting` resource type will be helpful. This resource
    type is not part of Puppet core, but is shipped with `puppetlabs-inifile` module.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`ini_setting`资源类型将发挥作用的地方。这个资源类型不是Puppet核心的一部分，但随`puppetlabs-inifile`模块一起提供。
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The previous example will check whether the agent section has an entry report
    `= true` and add it if it is missing. If the whole section is not yet there, it
    will also add the section. If the whole file is missing, the `ini_setting` resource
    type will also create the file.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例将检查代理部分是否有`report = true`的条目，如果缺少，则会添加该条目。如果整个部分还不存在，它也会添加该部分。如果整个文件缺失，`ini_setting`资源类型也会创建该文件。
- en: Normally, the `ini_setting` assumes that section names are put into brackets
    and that the `=` sign is used as a setting-value separator.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`ini_setting`假定节名称放在括号中，并且使用`=`符号作为设置值分隔符。
- en: The resource type allows the adoption of `section_prefix` and `section_suffix`
    and `key_value_separator`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 该资源类型允许采用`section_prefix`和`section_suffix`以及`key_value_separator`。
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will produce the following output:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: But managing all single entries in `ssh_config` file is very ineffective, as
    one must provide all single entries within single recourse type declarations.
    In this specific case, it is feasible to build the configuration file from snippets.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 但是管理`ssh_config`文件中的所有单个条目非常低效，因为必须在每个资源类型声明中提供所有单个条目。在这种特定情况下，从片段构建配置文件是可行的。
- en: Building from multiple snippets
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从多个片段构建
- en: There is one main difference between building a file from snippets compared
    to the `file_line` and `ini_setting` resource type. The latter two just manage
    single entries in a file, whereas managing a file from snippets manages the complete
    configuration file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与通过`file_line`和`ini_setting`资源类型构建文件相比，构建文件时有一个主要区别。后两者仅管理文件中的单个条目，而通过文件片段管理文件则是管理整个配置文件。
- en: This is very useful if one does not know beforehand how many entries are needed.
    For example, dynamically scaling haproxy backends or adding backup entries for
    a database server where the number of databases is yet unknown.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事先不知道需要多少条目，这非常有用。例如，动态扩展haproxy后端，或为数据库服务器添加备份条目，其中数据库的数量尚不确定。
- en: The most common solution for file snippets is the `puppetlabs-concat` module.
    The `concat` module needs at least one `no-noop` run, as it must manage the `concat`
    script on the nodes. This script is needed to build the final configuration file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 文件片段的最常见解决方案是`puppetlabs-concat`模块。`concat`模块需要至少一次`no-noop`运行，因为它必须在节点上管理`concat`脚本。此脚本用于构建最终的配置文件。
- en: 'First, it is required to mention to `concat` which file it is about to manage:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，需要向 `concat` 指明它即将管理的文件：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This prepares `concat` to be able to build the file from `concat_fragments`.
    All fragments should be put into a specific order:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使 `concat` 能够从 `concat_fragments` 构建文件。所有片段应按特定顺序排列：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using virtual resources
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用虚拟资源
- en: The next technique that we are going to discuss helps you solve conflicts in
    your manifests and build some elegant solutions in special situations.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将讨论的技术可以帮助你解决清单中的冲突，并在特殊情况下构建一些优雅的解决方案。
- en: Remember the uniqueness constraint that was introduced in [Chapter 1](8a22dc0e-3fe2-4153-b60e-935b7e6d9f94.xhtml),
    *Writing Your First Manifests,* any resource must be declared at most once in
    a manifest. There cannot be two classes or defined type instances that declare
    the same `file`, `package`, or any other type of resource. Each resource must
    have a unique type/name combination. This applies to instances of defined types
    as well as native resources.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 记住在[第1章](8a22dc0e-3fe2-4153-b60e-935b7e6d9f94.xhtml)中介绍的唯一性约束，*编写你的第一个清单*，任何资源在清单中最多只能声明一次。不能有两个类或定义类型实例声明相同的
    `file`、`package` 或任何其他类型的资源。每个资源必须具有唯一的类型/名称组合。这适用于定义类型的实例以及原生资源。
- en: This can pose issues when multiple modules need a common resource, such as an
    installed package, or perhaps even independent settings in the same configuration
    file. A component class for such resources, as introduced in [Chapter 4](daf11a18-5de2-4c3c-9880-e9a242ffb35b.xhtml),
    *Combining Resources in Classes and Defined Types*, will resolve basic conflicts
    of this kind. It can be included an arbitrary number of times in the same manifest.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个模块需要共享资源时，可能会出现问题，例如已安装的包，或者甚至是同一配置文件中的独立设置。像在[第4章](daf11a18-5de2-4c3c-9880-e9a242ffb35b.xhtml)中介绍的那样，为此类资源创建组件类，*将资源组合到类和定义类型中*，将解决此类基本冲突。它可以在同一清单中任意次数地包含。
- en: This can be impractical when the number of shared resources is fairly large.
    Imagine that you find yourself in a situation where a large number of different
    Puppet nodes require software from a significant set of `yum` repositories. Puppet
    will happily manage the repository configuration on the agents through its `yumrepo`
    type. However, you don't actually want all these repositories configured on every
    last machine they do incur maintenance overhead, after all. It would, instead,
    be desirable for each node to automatically receive the configuration for all
    repositories it requires for its packages, but not more.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当共享资源的数量非常大时，这种方式可能不太实际。假设你遇到了一种情况，许多不同的 Puppet 节点需要来自大量`yum`仓库的软件。Puppet 会通过其
    `yumrepo` 类型乐于在代理上管理仓库配置。然而，你并不希望所有这些仓库都在每一台机器上配置，因为这样会带来维护开销。相反，更理想的做法是，每个节点自动接收其所需仓库的配置，但不包含多余的仓库。
- en: 'When solving this using component classes, you would wrap each repository in
    a distinct class. The class names should closely resemble (and most likely contain)
    the name of the respective repositories:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用组件类解决这个问题时，你需要将每个仓库封装在一个独立的类中。类名应该与各自仓库的名称紧密相关（并且很可能包含这些名称）：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Package resources that rely on one or more such repositories will need to be
    accompanied by appropriate `include` statements:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于一个或多个此类仓库的包资源需要附带适当的 `include` 语句：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is possible, but it is less than ideal. Puppet does offer an alternative
    way to avoid duplicate resource declarations in the form of virtual resources.
    It allows you to add a resource declaration to your manifest without adding the
    resource to the actual catalog. The virtual resource must be **realized** or **collected**
    for this purpose. As with class inclusion, this realization of virtual resources
    can happen arbitrarily in the same manifest.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可行的，但效果不理想。Puppet 提供了一种避免重复资源声明的替代方法，形式为虚拟资源。它允许你在清单中添加资源声明，而无需将该资源添加到实际目录中。虚拟资源必须被**实现**或**收集**才能达到此目的。与类包含类似，虚拟资源的实现可以在同一清单中任意发生。
- en: 'Our previous example can, therefore, use a simpler structure with just one
    class to declare all the `yum` repositories as virtual resources with tag parameter
    set:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们之前的示例可以使用一个更简单的结构，通过一个类声明所有 `yum` 仓库作为虚拟资源，并设置标签参数：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `@` prefix marks the `yumrepo` resources as virtual. This class can be
    safely included by all nodes. It will not affect the catalog until the resources
    are realized:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`@` 前缀将 `yumrepo` 资源标记为虚拟资源。这个类可以安全地包含在所有节点中，直到资源被实际化之前，不会影响目录：'
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `realize` function converts the referenced virtual resources to real ones,
    which get added to the catalog. Granted, this is not much better than the previous
    code that relied on the component classes. The virtual resources do make the intent
    clearer, at least. Realizing them is less ambiguous than some `include` statements;
    a class can contain many resources and even more `include` statements.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`realize` 函数将引用的虚拟资源转换为真实资源，并将其添加到目录中。诚然，这比之前依赖组件类的代码并没有什么优势。虚拟资源至少使意图更加明确，实际化它们比一些
    `include` 语句要更清晰；一个类可以包含许多资源，甚至更多的 `include` 语句。'
- en: This `define` structure is actually possible with component classes as well.
    The class names can be passed as a parameter or from a central data structure.
    The `include` function will accept variable values for class names.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `define` 结构实际上也可以通过组件类来实现。类名可以作为参数传递，或者通过中央数据结构传递。`include` 函数将接受类名的变量值。
- en: Realizing resources more flexibly using collectors
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用收集器更灵活地实现资源
- en: 'Instead of invoking the `realize` function, you can also rely on a different
    syntactic construct, which is the `collector`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以不调用 `realize` 函数，而是依赖一个不同的语法结构，即 `collector`：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is more flexible than the function call at the cost of a slight performance
    penalty. It can be used as a reference to the realized resource(s) in certain
    contexts. For example, you can add ordering constraints with the chaining operator:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这比函数调用更灵活，代价是稍微有一些性能损失。它可以在某些上下文中作为已实现资源的引用。例如，你可以使用链式操作符添加顺序约束：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It is even possible to change values of resource attributes during collection.
    There is a whole section dedicated to such overrides later in this chapter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以在收集过程中更改资源属性的值。关于这种覆盖的内容将在本章后面的一个专门章节中讨论。
- en: 'As the collector is based on an expression, you can conveniently realize a
    whole range of resources. This can be quite dynamic sometimes, you will create
    virtual resources that are already being realized by a rather indiscriminate collector.
    Let''s look at a common example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于收集器基于表达式，你可以方便地实现一系列资源。有时这会非常动态，你会创建一些虚拟资源，这些资源已经被一个相当不加区分的收集器实现了。我们来看一个常见的例子：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With no expression, the collection encompasses all virtual resources of the
    given type. This allows you to collect them all, without worrying about their
    explicit titles or attributes. This might seem redundant, because then it makes
    no sense to declare the resources as virtual in the first place. However, keep
    in mind that the collector might appear in some select manifests only, while the
    virtual resources can be safely added to all your nodes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有表达式，集合将包括所有给定类型的虚拟资源。这使得你可以收集它们，而无需担心它们的显式标题或属性。这看起来可能是多余的，因为这会使得最初声明资源为虚拟资源没有意义。然而，请记住，收集器可能只出现在某些选定的清单中，而虚拟资源则可以安全地添加到所有节点中。
- en: 'To be a little more selective, it can be useful to group virtual resources
    based on their **tags**. We haven''t discussed tags yet. Each resource is tagged
    with several identifiers. Each tag is just a simple string. You can tag a resource
    manually by defining the `tag` metaparameter:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更具选择性，将虚拟资源根据其**标签**进行分组可能会很有用。我们还没有讨论标签。每个资源都被打上几个标识符标签。每个标签只是一个简单的字符串。你可以通过定义
    `tag` 元参数手动为资源打标签：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The named tag is then added to the resource. Puppet implicitly tags all resources
    with the name of the declaring class, the containing module, and a range of other
    useful meta information. For example, if your user module divides the `user` resources
    into classes such as `administrators`, `developers`, `qa`, and other roles, you
    can make certain nodes or classes select all users of a given role with a collection
    based on the class name tag:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，命名标签会被添加到资源中。Puppet 会隐式地为所有资源打上声明类的名称、包含模块的名称以及其他一系列有用的元信息标签。例如，如果你的用户模块将
    `user` 资源划分为 `administrators`、`developers`、`qa` 和其他角色，你可以通过基于类名标签的集合，让特定的节点或类选择给定角色的所有用户：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note that the tags actually form an array. The `==` comparison will look for
    the presence of the `developers` element in the `tag` array in this context. Have
    a look at another example to make this more clear:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些标签实际上形成了一个数组。`==` 比较将查找此上下文中 `tag` 数组中是否存在 `developers` 元素。看一下另一个例子，让这个概念更加清晰：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This way, you can collect all users who are members of the `sys` group.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，你可以收集所有属于 `sys` 组的用户。
- en: If you prefer function calls over the more cryptic collector syntax, you can
    keep using the `realize` function alongside collectors. This works without issues.
    Remember that each resource can be realized multiple times, even in both ways,
    simultaneously.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢函数调用而非较为晦涩的收集器语法，你可以继续使用 `realize` 函数和收集器一起使用。这样不会有问题。记住，每个资源可以多次实现，甚至可以同时以两种方式实现。
- en: If you are wondering, the manifest for a given agent can only realize virtual
    resources that are declared inside this same agent's manifest. Virtual resources
    do not leak into other manifests. Consequently, there can be no deliberate transfer
    of resources from one manifest to another, either. However, there is yet another
    concept that allows such an exchange; this is described in the next section.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道，给定代理的清单只能实现该代理清单中声明的虚拟资源。虚拟资源不会泄漏到其他清单中。因此，资源不能从一个清单故意转移到另一个清单中。不过，还有另外一个概念可以实现这样的交换；它将在下一节中描述。
- en: Cross-node configuration with exported resources
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用导出资源进行跨节点配置
- en: Puppet is commonly used to configure whole clusters of servers or HPC workers.
    Any configuration management system makes this task very efficient in comparison
    to manual care. Manifests can be shared between similar nodes. Configuration items
    that require individual customization per node are modeled individually. The whole
    process is very natural and direct.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 常用于配置整个服务器集群或 HPC 工作节点。与手动管理相比，任何配置管理系统都能使这项任务变得更加高效。相似节点之间可以共享清单。需要为每个节点单独定制的配置项会被单独建模。整个过程非常自然且直接。
- en: On the other hand, there are certain configuration tasks that do not lend themselves
    well to the paradigm of the central definition of all states. For example, a cluster
    setup might include the sharing of a generated key or registering IP addresses
    of peer nodes as they become available. An automatic setup should include an exchange
    of such shared information. Puppet can help out with this as well.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有一些配置任务不太适合所有状态的中央定义范式。例如，集群设置可能包括共享生成的密钥，或在对等节点变得可用时注册其 IP 地址。自动化设置应包括此类共享信息的交换。Puppet
    也可以帮助处理这个问题。
- en: This is a very good fit. It saves a metalayer, because you don't need to implement
    the setup of an information exchange system in Puppet. The sharing is secure,
    relying on Puppet's authentication and encryption infrastructure. There is logging
    and central control over the deployment of the shared configuration. Puppet retains
    its role as the central source for all system details; it serves as a hub for
    a secure exchange of information.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常合适的匹配。它节省了一个元层，因为你不需要在 Puppet 中实现信息交换系统的设置。共享是安全的，依赖于 Puppet 的身份验证和加密基础设施。还有日志记录和集中控制共享配置的部署。Puppet
    保持其作为所有系统详细信息的中央源的角色；它充当了安全信息交换的中心。
- en: Exporting and collecting resources
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导出和收集资源
- en: Puppet approaches the problem of sharing configuration information among multiple
    agent nodes by way of exported resources. The concept is simple. The manifest
    of **node A** can contain one or more resources that are purely virtual and not
    for realization in the manifest of this **node A**. Other nodes, such as **B**
    and **C**, can import some or all of these resources. Then, the resources become
    part of the catalogs of these remote nodes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 通过导出资源的方法来解决多个代理节点之间共享配置信息的问题。这个概念很简单。**节点 A** 的清单可以包含一个或多个纯虚拟资源，这些资源不在
    **节点 A** 的清单中实现。其他节点，例如 **B** 和 **C**，可以导入其中的一部分或全部资源。然后，这些资源成为这些远程节点的目录的一部分。
- en: '![](img/b0d63641-0c9a-4bd2-8308-29e622d732d8.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0d63641-0c9a-4bd2-8308-29e622d732d8.png)'
- en: The syntax to import and export resources is very similar to that of virtual
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 导入和导出资源的语法与虚拟资源的语法非常相似。
- en: resources. An exported resource is declared by prepending the resource type
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 资源。导出资源通过在资源类型前添加前缀来声明。
- en: 'name with two `@` characters:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 带有两个 `@` 字符的名称：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The importing manifests collect these resources using an expression, which is
    again similar to the collection of virtual resources, but with double-angled
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 导入清单使用表达式收集这些资源，这与收集虚拟资源类似，但使用了双角括号
- en: 'brackets, `<` and `>`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 括号，`<` 和 `>`：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Tags are a very common way to take fine-grained control over the distribution
    of such exported resources.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 标签是控制这种导出资源分发的非常常见的方式。
- en: Configuring the master to store exported resources
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置主节点以存储导出的资源
- en: The only recommendable way to enable support for exported resources is PuppetDB.
    It is a REST API that stores different kinds of data that the Puppet master deals
    with during regular operation in a PostgreSQL database. This includes catalog
    requests from agents (including their valuable facts), reports from catalog applications,
    and exported resources.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一推荐的启用导出资源支持的方式是 PuppetDB。它是一个 REST API，用于将 Puppet 主机在常规操作过程中处理的各种数据存储在 PostgreSQL
    数据库中。这包括来自代理的清单请求（包括其重要的事实数据）、清单应用程序的报告和导出资源。
- en: '[Chapter 2](7cafeeab-0e5c-4848-9eb0-1bae38ed3525.xhtml), *Puppet Server and
    Agents*, detailed a manual installation of the master. Let''s add the PuppetDB
    with more style through Puppet! On the Forge, you will find a convenient module
    that will make this easy:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 2 章](7cafeeab-0e5c-4848-9eb0-1bae38ed3525.xhtml)，*Puppet 服务器和代理*，详细描述了手动安装主机的过程。现在通过
    Puppet 以更优雅的方式添加 PuppetDB！在 Forge 上，你将找到一个便捷的模块来轻松实现这一点：'
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'On the master node, the setup now becomes a one-line invocation:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在主节点上，设置现在变成了一个简单的命令行调用：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As our test master uses a nonstandard SSL certificate that is named `master.example.net`
    (instead of its FQDN), it must be configured for `puppetdb` as well:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的测试主机使用的是一个非标准的 SSL 证书，名为 `master.example.net`（而不是其完全限定域名 FQDN），因此也必须为 `puppetdb`
    进行配置：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The ensuing catalog run is quite impressive. Puppet installs the PostgreSQL
    backend, the Jetty server, and the actual PuppetDB package, and it configures
    everything and starts the services up all in one go. After applying this short
    manifest, you have added a complex piece of infrastructure to your Puppet setup.
    You can now use exported resources for a variety of helpful tasks.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 随后的清单运行相当令人印象深刻。Puppet 安装了 PostgreSQL 后端、Jetty 服务器和实际的 PuppetDB 包，并一次性完成了所有配置和启动服务。在应用了这个简短的清单之后，你已经将一个复杂的基础设施组件添加到你的
    Puppet 设置中。现在，你可以利用导出的资源来执行各种有用的任务。
- en: Exporting SSH host keys
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导出 SSH 主机密钥
- en: For homegrown interactions between clustered machines, SSH can be an invaluable
    tool. File transfer and the remote execution of arbitrary commands is easily possible
    thanks to the ubiquitous `sshd` service. For security reasons, each host generates
    a unique key in order to identify itself. Of course, such public key authentication
    systems can only really work with a trust network, or the presharing of public
    keys.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于集群机器之间的自定义交互，SSH 可以是一个宝贵的工具。通过无处不在的 `sshd` 服务，文件传输和远程执行任意命令变得轻松可行。出于安全原因，每个主机都会生成一个唯一的密钥来识别自己。当然，这种公钥认证系统只有在信任网络中，或者预先共享公钥的情况下才能真正工作。
- en: 'Puppet can do the latter quite nicely:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 可以很好地完成后者的工作：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Interested nodes collect keys with the known pattern:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 感兴趣的节点会收集带有已知模式的密钥：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, SSH servers can be authenticated through the respective keys that Puppet
    safely stores in its database. As always, the Puppet master is the fulcrum of
    security.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，SSH 服务器可以通过 Puppet 安全存储在其数据库中的相应密钥进行身份验证。像往常一样，Puppet 主机是安全的支点。
- en: As a matter of fact, some `ssh` modules from the Puppet Forge will use this
    kind of construct to do this work for you.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，一些来自 Puppet Forge 的 `ssh` 模块会使用这种结构来为你完成这项工作。
- en: Managing hosts files locally
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地管理主机文件
- en: Many sites can rely on a local DNS infrastructure. Resolving names to local
    IP addresses is easy with such setups. However, small networks, or sites that
    consist of many independent clusters with little shared infrastructure, will have
    to rely on names in `/etc/hosts` instead.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 许多站点可以依赖本地的 DNS 基础设施。通过这种设置，解析名称为本地 IP 地址是很容易的。然而，小型网络，或者由许多独立集群组成且基础设施共享较少的站点，必须依赖
    `/etc/hosts` 中的名称。
- en: You can maintain a central hosts file per network cell, or you can make
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为每个网络单元维护一个中心化的主机文件，或者你可以
- en: 'Puppet maintain each entry in each hosts file separately. The latter approach
    has some advantages:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 会分别维护每个主机文件中的每一项条目。后一种方法有一些优势：
- en: Changes are automatically distributed through the Puppet agent network
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改会通过 Puppet 代理网络自动分发
- en: Puppet copes with unmanaged lines in the hosts files
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet 处理主机文件中未管理的行
- en: A manually maintained registry is prone to becoming outdated every once in a
    while. It will also obliterate local additions in any hosts files on the agent
    machines.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 手动维护的注册表容易过时，并且会覆盖代理机器上任何本地添加的hosts文件内容。
- en: 'The manifest implementation of the superior approach with exported resources
    is very similar to the `sshkey` example from the previous section:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用导出资源的优越方法的清单实现与前一节的`sshkey`示例非常相似：
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is the same principle, only now, each node exports its `$ipaddress` fact
    value alongside its name and not a public key. The import also works the same
    way:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是同样的原理，只不过现在每个节点导出的是它的`$ipaddress`事实值，而不是公钥，导入也按同样的方式进行：
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Automating custom configuration items
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化自定义配置项
- en: 'Do you remember the Cacti module that you created during the previous chapter?
    It makes it very simple to configure all monitored devices in the manifest of
    the Cacti server. However, as this is possible, wouldn''t it be even better if
    each node in your network was registered automatically with Cacti? It''s simple:
    make the devices export their respective `cacti_device` resources for the server
    to collect:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得在上一章创建的Cacti模块吗？它让你可以非常简单地在Cacti服务器的清单中配置所有被监控的设备。然而，既然已经可以这样做，难道不会更好，如果你网络中的每个节点都能自动注册到Cacti吗？这很简单：让设备导出它们各自的`cacti_device`资源供服务器收集：
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The Cacti server, apart from including the `cacti` class, just needs to collect
    the devices now:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Cacti服务器，除了包含`cacti`类外，现在只需要收集这些设备即可：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If one Cacti server handles all your machines, you can just omit the `tag`
    comparison:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个Cacti服务器处理所有的机器，你可以直接省略`tag`的比较：
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Once the module supports other Cacti resources, you can handle them in the same
    way. Let's look at an example from another popular monitoring solution.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模块支持其他Cacti资源，你可以用相同的方式来处理它们。我们来看一个来自另一个流行监控解决方案的例子。
- en: Simplifying the configuration of Nagios
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化Nagios的配置
- en: Puppet comes with support to manage the complete configuration of **Nagios**
    (and compatible versions of **Icinga**). Each configuration section can be represented
    by a distinct Puppet resource with types such as `nagios_host` or `nagios_service`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet支持管理**Nagios**（以及兼容版本的**Icinga**）的完整配置。每个配置部分都可以通过不同的Puppet资源来表示，类型如`nagios_host`或`nagios_service`。
- en: There is an endeavour to remove this support from core Puppet. This does not
    mean that support will be discontinued, however. It will just move to yet another
    excellent Puppet module.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有人正在努力从核心Puppet中移除对这个功能的支持。然而，这并不意味着支持会被完全取消，它只是会转移到另一个优秀的Puppet模块中。
- en: Each of your machines can export their individual `nagios_host` resources alongside
    their `host` and `cacti_device` resources. However, thanks to the diverse Nagios
    support, you can do even better.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你的每一台机器都可以在导出它们各自的`nagios_host`资源的同时，也导出`host`和`cacti_device`资源。然而，得益于Nagios的广泛支持，你还能做得更好。
- en: 'Assuming that you have a module or class to wrap SSH handling (you are using
    a Forge module for the actual management, of course), you can handle monitoring
    from inside your own SSH server class. By adding the export to this class, you
    make sure that nodes that include the class (and only these nodes) will also get
    monitoring:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个模块或类来封装SSH处理（当然，你是在使用Forge模块来进行实际管理），你可以从自己的SSH服务器类内部处理监控。通过在这个类中添加导出，你可以确保包括这个类的节点（只有这些节点）也会获得监控：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You probably know the drill by now, but let''s repeat the mantra once more:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经了解了这个流程，但让我们再重复一遍口号：
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: With this collection, the Nagios host configures itself with all services that
    the agent manifests create.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个集合，Nagios主机会根据所有代理清单创建的服务自动配置自己。
- en: For large Nagios configurations, you might want to consider reimplementing the
    Nagios types yourself, using simple defines that build the configuration from
    templates. The native types can be slower than the `file` resources in this case,
    because they have to parse the whole Nagios configuration on each run. The `file`
    resources can be much cheaper, as they rely on content-agnostic checksums.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型的Nagios配置，你可能希望自己重新实现Nagios类型，使用简单的定义，从模板构建配置。在这种情况下，原生类型可能比`file`资源更慢，因为它们需要在每次运行时解析整个Nagios配置。而`file`资源则会更便宜，因为它们依赖于内容无关的校验和。
- en: Maintaining your central firewall
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 维护你的中央防火墙
- en: 'Speaking of useful features that are not part of the core of Puppet, you can
    manage the rules of your `iptables` firewall, of course. You need the `puppetlabs-firewall`
    module to make the appropriate types available. Then, each machine can (among
    other useful things) export its own required port forwarding to the firewall machines:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 说到那些不属于 Puppet 核心功能但很有用的特性，你当然可以管理 `iptables` 防火墙的规则。你需要 `puppetlabs-firewall`
    模块来提供适当的类型。然后，每台机器都可以（除其他有用功能外）将其所需的端口转发导出到防火墙机器上：
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `$public_ip_address` value is not a Facter fact, of course. Your node will
    have to be configured with the appropriate information. You can refer to [Chapter
    7](b38488ca-86a7-4ecf-9a69-16938576d852.xhtml), *New Features from Puppet 4 and
    5*, for a good way to do this.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`$public_ip_address` 的值当然不是一个 Facter facts。你的节点必须配置适当的信息。你可以参考 [第 7 章](b38488ca-86a7-4ecf-9a69-16938576d852.xhtml)，*来自
    Puppet 4 和 5 的新功能*，了解一种不错的方法来实现这一点。'
- en: 'The title of a firewall rule resource conventionally begins with a three-digit
    index for ordering purposes. The firewall machines collect all these rules naturally:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 防火墙规则资源的标题通常以三位数字索引开头，以便进行排序。防火墙机器会自然地收集所有这些规则：
- en: '[PRE40]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see, the possibilities for modeling distributed systems through exported
    Puppet resources are manifold. The simple pattern that we've iterated for several
    resource types suffices for a wide range of use cases. Combined with defined resource
    types, it allows you to flexibly enable your manifests to work together in order
    to form complex cluster setups with relatively little effort. The larger your
    clusters, the more work Puppet lifts from you through exports and collections.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，通过导出的 Puppet 资源建模分布式系统的可能性是多种多样的。我们已经为几种资源类型总结的简单模式，足以应对广泛的使用场景。结合已定义的资源类型，它使得你能够灵活地启用清单，以便协同工作，从而形成复杂的集群配置，且所需的努力相对较少。集群越大，Puppet
    通过导出和收集，从你身上分担的工作就越多。
- en: Removing obsolete exports
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除过时的导出
- en: When a node manifest stops exporting any resource, that resource's record is
    removed from PuppetDB once the node's catalog is compiled. This usually happens
    when the agent checks in with the master.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当某个节点清单停止导出任何资源时，该资源的记录会在该节点的清单编译完成后从 PuppetDB 中移除。这通常发生在代理与主服务器连接时。
- en: However, if you take an agent out of commission permanently, this will never
    happen. That's why you will need to remove those exports from the DB manually.
    Otherwise, other nodes will keep importing the old resources.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你永久停用某个代理，这种情况就不会发生。因此，你需要手动从数据库中移除这些导出。否则，其他节点将继续导入旧资源。
- en: 'To clean such records from PuppetDB, use the `puppet node deactivate` command
    on the master server:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 PuppetDB 中清除此类记录，请在主服务器上使用 `puppet node deactivate` 命令：
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Setting defaults for resource parameters
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为资源参数设置默认值
- en: Both exported and virtual resources are declared once, and are then collected
    in different contexts. The syntax is very similar, as are the concepts.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 导出资源和虚拟资源都只声明一次，然后在不同的上下文中收集。语法非常相似，概念也类似。
- en: Sometimes, a central definition of a resource cannot be safely realized on all
    of your nodes, though; for example, consider the set of all your `user` resources.
    You will most likely wish to manage the user ID that is assigned to each account
    in order to make them consistent across your networks.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时，某些资源的中央定义无法在所有节点上安全实现；例如，考虑所有 `user` 资源的集合。你很可能希望管理分配给每个帐户的用户 ID，以便在你的网络中保持一致。
- en: This is often solved through LDAP or similar directories, but that is not possible
    for some sites.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常通过 LDAP 或类似的目录解决，但有些站点无法实现这一点。
- en: Even if all accounts on almost all machines will be able to use their designated
    ID, there are likely to be some exceptions. On a few older machines, some IDs
    are probably being used for other purposes already, which cannot be changed easily.
    On such machines, creating users with these IDs will fail.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 即使几乎所有机器上的所有账户都能够使用其指定的 ID，仍然可能会有一些例外。在一些较旧的机器上，某些 ID 可能已经被用作其他用途，且无法轻易更改。在这些机器上，使用这些
    ID 创建用户将失败。
- en: The accounts can be created if duplicate IDs are allowed, but that is not a
    solution to this problem duplicates are usually not desirable.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果允许重复的 ID，可以创建账户，但这并不是解决问题的方法，因为通常不希望出现重复 ID。
- en: 'Fortunately, Puppet has a convenient way to express such exceptions. To give
    the nonstandard UID, `2066`, to the user, `felix`, realize the resource with an
    attribute value specification:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Puppet提供了一种方便的方式来表达这种例外。要给用户`felix`分配非标准的UID `2066`，只需通过指定属性值来实现资源：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You can pass any property, parameter, or metaparameter that applies to the
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以传递任何适用的属性、参数或元参数给
- en: resource type in question. A value that you specify this way is final and cannot
    be overridden again.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 相关资源类型。你以这种方式指定的值是最终的，不能再被重写。
- en: This language feature is more powerful than the preceding example lets on. This
    is because the override is not limited to virtual and exported resources. You
    can override any resource from anywhere in your manifest. This allows for some
    remarkable constructs and shortcuts.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语言特性比前面的示例所显示的要强大得多。这是因为重写不仅限于虚拟和导出的资源。你可以重写清单中的任何资源。这为一些了不起的构造和快捷方式提供了可能。
- en: Consider, for example, the Cacti module that you created during the previous
    chapter. It declares a `package` resource in order to make sure that the software
    is installed. To that end, it specifies `ensure => installed`. If any user of
    your module needs Puppet to keep their packages up to date, this is not adequate
    though. The clean solution for this case is to add some parameters to the module's
    classes which allow the user to choose the `ensure` property value for the package
    and other resources. However, this is not really practical. Complex modules can
    manage hundreds of properties, and exposing them all through parameters would
    form a horribly confusing interface.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以你在上一章创建的Cacti模块为例。它声明了一个`package`资源，以确保软件被安装。为此，它指定了`ensure => installed`。然而，如果你的模块的任何用户需要Puppet保持其软件包最新，这就不够了。对此的解决方案是给模块的类添加一些参数，允许用户选择软件包和其他资源的`ensure`属性值。然而，这实际上并不实用。复杂的模块可能管理数百个属性，而通过参数暴露所有这些属性将形成一个令人困惑的界面。
- en: 'The override syntax can provide a simple and elegant workaround here. The manifest
    that achieves the desired result is very straightforward:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 重写语法在这里提供了一个简单而优雅的解决方法。实现所需结果的清单非常直接：
- en: '[PRE43]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: For all its simplicity, this manifest will be hard to decipher for collaborators
    who are not familiar with the collector/override syntax. This is not the only
    problem with overrides. You cannot override the same attribute multiple times.
    This is actually a good thing, because any rules that resolve such conflicting
    overrides make it extremely difficult to predict the actual semantics of a manifest
    that contains multiple overrides of this kind.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个清单简单，但对于那些不熟悉收集器/重写语法的协作者来说，理解起来会很困难。这并不是重写的唯一问题。你不能多次重写同一个属性。这其实是件好事，因为任何解决此类冲突重写规则的方式都让人很难预测包含多个此类重写的清单的实际语义。
- en: Relying on this override syntax too much will make your manifests prone to conflicts.
    Combining the wrong classes will make the compiler stop creating the catalog.
    Even if you manage to avoid all conflicts, the manifests will become rather chaotic.
    It can be difficult to locate all active overrides for a given node. The resulting
    behavior of any class or define becomes hard to predict.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 过度依赖这种重写语法会使你的清单容易产生冲突。组合错误的类会导致编译器停止创建目录。即使你设法避免了所有冲突，清单也会变得相当混乱。定位给定节点的所有活动重写可能会很困难。任何类或定义的最终行为变得难以预测。
- en: All things considered, it's safest to use overrides very sparingly.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，最安全的做法是非常谨慎地使用重写。
- en: 'The collectors are especially dangerous when used without a selector expression:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 收集器在没有选择器表达式的情况下使用时特别危险：
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Not only will it realize all virtual resources of the given type. It will also
    force surprising attribute values on both virtual and regular resources of the
    same type.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 它不仅会实现给定类型的所有虚拟资源。它还会强制给同一类型的虚拟和常规资源应用意外的属性值。
- en: Saving redundancy using resource defaults
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过使用资源默认值来节省冗余
- en: The final language construct that this chapter introduces can save you quite
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍的最终语言构造可以为你节省很多时间。
- en: 'some typing, or rather, it saves you from copying and pasting. Writing a long,
    repetitive manifest is not what costs you lots of time, of course. However, a
    briefer manifest is often more readable, and hence, more maintainable. You achieve
    this by defining resource defaults; attribute values that are used for resources
    that don''t choose their own:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一些打字工作，或者更准确地说，它可以让你避免复制和粘贴。写一个冗长的、重复的清单当然不会花费你大量时间。然而，简洁的清单通常更具可读性，因此也更易于维护。你可以通过定义资源默认值来实现这一点；这些默认值是为那些没有自定义值的资源所使用的：
- en: '[PRE45]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: By default, each grant should apply to all databases and comprise all privileges.
    This allows you to define each actual `mysql_grant` resource quite sparsely. Otherwise,
    you will have to specify the `privileges` property for all resources. The `options`
    attribute will be especially repetitive, because they are identical for all grants
    in this example.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每个授权应适用于所有数据库，并包括所有权限。这允许你相当简洁地定义每个实际的 `mysql_grant` 资源。否则，你将不得不为所有资源指定
    `privileges` 属性。在这个例子中，`options` 属性尤其重复，因为它们对于所有授权都是相同的。
- en: Note that the ensure property is repetitive as well, but it was not included.
    It is considered good practice to exempt this attribute from resource defaults.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`ensure` 属性也具有重复性，但没有被包含在内。通常认为将这个属性从资源默认值中排除是一个好做法。
- en: The `mysql_grant` resource type is not available in core Puppet. It's part of
    the `puppetlabs-mysql` module on the Forge.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`mysql_grant` 资源类型在核心 Puppet 中不可用。它是 `puppetlabs-mysql` 模块的一部分，位于 Forge 上。'
- en: 'Despite the convenience that this approach offers, it should not be used at
    each apparent opportunity. It has some downsides that you should keep in mind:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种方法带来了便利，但不应在每个看似适用的机会中使用。它也有一些缺点，值得你记住：
- en: The defaults can be surprising if they apply to resources that are declared
    at a lexical distance from the defaults' definition (such as several screens further
    down the manifest file)
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果默认值适用于在与默认定义有词法距离的资源（例如在清单文件几屏之远的地方声明的资源），它可能会让人感到意外。
- en: The defaults transcend the inclusion of classes and instantiation of defines
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认值超越了类的包含和定义的实例化。
- en: 'These two aspects form a dangerous combination. Defaults from a composite class
    can affect very distant parts of a manifest:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方面形成了一个危险的组合。来自复合类的默认值可能会影响到清单中非常遥远的部分：
- en: '[PRE46]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Files declared in the `webserver` class should belong to a default user. However,
    this default takes effect recursively in the included classes as well. The `owner`
    attribute is a property: a resource that defines no value, for it just ignores
    its current state. A value that is specified in the manifest will be enforced
    by the agent. Often, you do not care about the owner of a managed file:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `webserver` 类中声明的文件应该属于一个默认用户。然而，这个默认值在包含的类中也会递归生效。`owner` 属性是一个属性：一个没有定义值的资源，因为它会忽略当前的状态。清单中指定的值将会被代理执行强制执行。通常情况下，你不关心托管文件的所有者：
- en: '[PRE47]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'However, because of the default `owner` attribute, Puppet will now mandate
    that this file belongs to `www-data`. To avoid this, you will have to unset the
    default by overwriting it with `undef`, which is Puppet''s analog to the `nil`
    value:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于默认的 `owner` 属性，Puppet 现在会强制要求该文件属于 `www-data`。为了避免这种情况，你必须通过用 `undef` 来覆盖默认值，从而取消设置默认值，`undef`
    是 Puppet 中相当于 `nil` 的值：
- en: '[PRE48]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This can also be done in individual resources:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以在单独的资源中完成：
- en: '[PRE49]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: However, doing this constantly is hardly feasible. The latter option is especially
    unattractive, because it leads to more complexity in the manifest code, instead
    of simplifying it. After all, not defining a default `owner` attribute will be
    the cleaner way here.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，频繁地这样做几乎不可行。后者选项尤其不吸引人，因为它会导致清单代码的复杂度增加，而不是简化它。毕竟，在这里不定义默认的 `owner` 属性才是更简洁的方式。
- en: The semantics that make defaults take effect in so many manifest areas is known
    as **dynamic scoping**. It used to apply to variable values as well and is generally
    considered harmful. One of the most decisive changes in Puppet 3.0 was the removal
    of dynamic variable scoping, in fact. Resource defaults still use it, but it is
    expected that this will change in a future release as well.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使默认值在多个清单区域生效的语义被称为**动态作用域**。它曾经也适用于变量值，并且通常被认为是有害的。事实上，Puppet 3.0 中最决定性的变化之一就是移除了动态变量作用域。资源默认值仍然使用它，但预计这将在未来的版本中有所改变。
- en: Resource defaults should be used with consideration and care. For some properties,
    such as `file mode`, `owner`, and `group`, they should usually be avoided.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 应谨慎使用资源默认值。对于某些属性，如`file mode`、`owner`和`group`，通常应避免使用。
- en: Avoiding antipatterns
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免反模式
- en: 'Speaking of things to avoid, there is a language feature that we will only
    address in order to advise great caution. Puppet comes with a function called
    `defined`, which allows you to query the compiler about resources that have been
    declared in the manifest:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 说到需要避免的东西，有一个语言特性我们仅在此提及，以便提醒大家要格外小心。Puppet附带一个叫做`defined`的函数，它允许你查询清单中已声明的资源：
- en: '[PRE50]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The problem with the concept is that it cannot ever be reliable. Even if the
    resource appears in the manifest, the compiler might encounter it later than the
    `if` condition. This is potentially very problematic, because some modules will
    try to make themselves portable through this construct:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念的问题在于它永远无法可靠。即使资源出现在清单中，编译器也可能会在`if`条件之后才遇到它。这可能会引发严重问题，因为某些模块会尝试通过这种构造使自己变得可移植：
- en: '[PRE51]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The module author supposes that this resource definition will be skipped if
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 模块作者假设如果
- en: the manifest declares `Package['apache2']` somewhere else. As explained, this
    method will only be effective if the block is evaluated late enough during the
    compiler run. The conflict can still occur if the compiler encounters the other
    declaration after this one.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 清单在其他地方声明了`Package['apache2']`。如前所述，这种方法仅在块在编译器运行时足够晚的时候才有效。如果编译器在此块之后遇到其他声明，冲突仍然可能发生。
- en: 'The manifest''s behavior becomes outright unpredictable if a manifest contains
    multiple occurrences of the same query:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果清单中包含多个相同查询的出现，清单的行为会变得完全不可预测：
- en: '[PRE52]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The first block that is seen wins. This can even shift if unrelated parts of
    the manifest are restructured. You cannot predict whether a given manifest will
    use `ensure=>latest` for the `apache2` package or just use `installed`. The results
    become even more bizarre if such a block wants a resource removed through `ensure=>absent`,
    while the other does not.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个看到的块会优先执行。如果清单的无关部分被重组，这种优先顺序可能会发生变化。你无法预测给定的清单是会对`apache2`包使用`ensure=>latest`，还是使用`installed`。如果某个块希望通过`ensure=>absent`移除资源，而另一个块没有如此要求，结果将变得更加不可预测。
- en: 'The `defined` function has long been considered harmful, but there is no adequate
    alternative yet. The `ensure_resource` function from the `stdlib` module tries
    to make the scenario less problematic:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`defined`函数长期以来被认为是有害的，但目前尚无合适的替代方法。`stdlib`模块中的`ensure_resource`函数试图减少这种场景的危害：'
- en: '[PRE53]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: By relying on this function instead of the preceding antipattern based around
    the `defined` function, you will avoid the unpredictable behavior of conflicting
    declarations. Instead, this will cause the compiler to fail when the declarations
    are passed to `ensure_resource`. This is still not a clean practice, though. Failed
    compilation is not a desirable alternative either.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通过依赖这个函数，而不是依赖基于`defined`函数的前述反模式，你可以避免冲突声明导致的不可预测行为。相反，这会导致编译器在将声明传递给`ensure_resource`时失败。不过，这仍然不是一种干净的做法。编译失败也并不是一个理想的替代方案。
- en: Both functions should be avoided in favor of clean module structures with non-ambiguous
    resource declarations. More details on how to ensure reusable, composable, and
    stackable classes will be provided in [Chapter 9](0a0cf4b0-23fa-48fd-abf9-77ed851bb581.xhtml),
    *Puppet Roles and Profiles.*
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 应避免使用这两个函数，建议采用清晰的模块结构，并且避免模糊的资源声明。有关如何确保可重用、可组合和可堆叠的类的更多细节，请参见[第9章](0a0cf4b0-23fa-48fd-abf9-77ed851bb581.xhtml)，*Puppet角色和配置文件*。
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: A template is a frequent occurrence and is one of the best ways for Puppet to
    manage dynamic file content. Evaluating each template requires extra effort from
    the compiler, but the gain in flexibility is usually worth it. Variables in templates
    have to be declared using the Puppet variable syntax with full namespace, or by
    prodding a hash with variable inside templates and classes.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是Puppet中常见的现象，它是管理动态文件内容的最佳方式之一。每次评估模板都需要编译器付出额外的努力，但通常灵活性上的提升是值得的。模板中的变量必须使用Puppet变量语法，并带有完整的命名空间，或者在模板和类中通过操作哈希传递变量。
- en: The concept of virtual resources is much less ubiquitous. Virtual resources
    allow you to flexibly add certain entities to a node's catalog. The collector
    syntax that is used for this can also be used to override attribute values, which
    works for non-virtual resources as well.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟资源的概念并不如常见。虚拟资源允许你灵活地将某些实体添加到节点的目录中。用于此的收集器语法也可以用来覆盖属性值，这同样适用于非虚拟资源。
- en: Once PuppetDB is installed and configured, you can also export resources so
    that other node manifests can receive their configuration information. This allows
    you to model distributed systems quite elegantly.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装并配置了 PuppetDB，你还可以导出资源，以便其他节点清单能够接收它们的配置信息。这使得你可以优雅地建模分布式系统。
- en: The resource defaults are just a syntactic shortcut that help keep your manifest
    concise. They have to be used with care, though. Some language features, such
    as the `defined` function (and its module-based successor, which is the `ensure_resource`
    function), should be avoided if possible.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 资源默认值只是一个语法快捷方式，有助于保持清单的简洁。然而，它们需要小心使用。一些语言特性，如 `defined` 函数（以及它的模块化继任者，即 `ensure_resource`
    函数），如果可能的话，应避免使用。
- en: "[Chapter 7\uFEFF](b38488ca-86a7-4ecf-9a69-16938576d852.xhtml), *New Features\
    \ from Puppet 4 and 5*, gives you an overview and introduction to the roles and\
    \ profiles pattern, which is best practice for combining upstream modules with\
    \ platform implementations."
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: "[第7章\uFEFF](b38488ca-86a7-4ecf-9a69-16938576d852.xhtml)，*Puppet 4 和 5 的新特性*，为你概述并介绍了角色和配置文件模式，这是将上游模块与平台实现结合的最佳实践。"
