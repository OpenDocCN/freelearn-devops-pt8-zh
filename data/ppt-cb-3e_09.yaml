- en: Chapter 9. External Tools and the Puppet Ecosystem
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章 外部工具与 Puppet 生态系统
- en: '|   | *"By all means leave the road when you wish. That is precisely the use
    of a road: to reach individually chosen points of departure."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *“尽管如此，您可以随时偏离道路。道路的真正用途正是：到达个别选择的出发点。”* |   |'
- en: '|   | --*Robert Bringhurst, The Elements of Typographic Style* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*Robert Bringhurst，《排版风格元素》* |'
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下内容：
- en: Creating custom facts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义事实
- en: Adding external facts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加外部事实
- en: Setting facts as environment variables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将事实设置为环境变量
- en: Generating manifests with the Puppet resource command
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Puppet 资源命令生成清单
- en: Generating manifests with other tools
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用其他工具生成清单
- en: Using an external node classifier
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用外部节点分类器
- en: Creating your own resource types
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您自己的资源类型
- en: Creating your own providers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您自己的提供者
- en: Creating custom functions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义函数
- en: Testing your Puppet manifests with rspec-puppet
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 rspec-puppet 测试您的 Puppet 清单
- en: Using librarian-puppet
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 librarian-puppet
- en: Using r10k
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 r10k
- en: Introduction
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Puppet is a useful tool by itself, but you can get much greater benefits by
    using Puppet in combination with other tools and frameworks. We'll look at some
    ways of getting data into Puppet, including custom Facter facts, external facts,
    and tools to generate Puppet manifests automatically from the existing configuration.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 本身是一个非常有用的工具，但如果将 Puppet 与其他工具和框架结合使用，您可以获得更大的收益。我们将讨论一些将数据输入 Puppet
    的方法，包括自定义 Facter 事实、外部事实以及从现有配置自动生成 Puppet 清单的工具。
- en: You'll also learn how to extend Puppet by creating your own custom functions,
    resource types, and providers; how to use an external node classifier script to
    integrate Puppet with other parts of your infrastructure; and how to test your
    code with rspec-puppet.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您还将学习如何通过创建自定义函数、资源类型和提供者来扩展 Puppet；如何使用外部节点分类器脚本将 Puppet 与您基础设施的其他部分集成；以及如何使用
    rspec-puppet 测试您的代码。
- en: Creating custom facts
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义事实
- en: While Facter's built-in facts are useful, it's actually quite easy to add your
    own facts. For example, if you have machines in different data centers or hosting
    providers, you could add a custom fact for this so that Puppet can determine whether
    any local settings need to be applied (for example, local DNS servers or network
    routes).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Facter 内置的事实很有用，但实际上添加您自己的事实非常简单。例如，如果您有位于不同数据中心或托管服务商的机器，您可以为此添加自定义事实，这样
    Puppet 就可以判断是否需要应用任何本地设置（例如，本地 DNS 服务器或网络路由）。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Here''s an example of a simple custom fact:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的自定义事实示例：
- en: 'Create the directory `modules/facts/lib/facter` and then create the file `modules/facts/lib/facter/hello.rb`
    with the following contents:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建目录 `modules/facts/lib/facter`，然后创建文件 `modules/facts/lib/facter/hello.rb`，并填入以下内容：
- en: '[PRE0]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Modify your `site.pp` file as follows:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改您的 `site.pp` 文件如下：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Run Puppet:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Puppet：
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Facter facts are defined in Ruby files that are distributed with facter. Puppet
    can add additional facts to facter by creating files within the `lib/facter` subdirectory
    of a module. These files are then transferred to client nodes as we saw earlier
    with the `puppetlabs-stdlib` module. To have the command-line facter use these
    `puppet` facts, append the `-p` option to facter as shown in the following command
    line:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Facter 事实在与 facter 一起分发的 Ruby 文件中定义。Puppet 可以通过在模块的 `lib/facter` 子目录中创建文件，向
    facter 添加附加事实。然后，这些文件会像我们之前看到的 `puppetlabs-stdlib` 模块一样被传输到客户端节点。要让命令行工具 facter
    使用这些 `puppet` 事实，请像以下命令行所示一样在 facter 后添加 `-p` 选项：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you are using an older version of Puppet (older than 3.0), you will need
    to enable `pluginsync` in your `puppet.conf` file as shown in the following command
    line:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是旧版本的 Puppet（低于 3.0），您需要在 `puppet.conf` 文件中启用 `pluginsync`，如下所示命令行：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Facts can contain any Ruby code, and the last value evaluated inside the `setcode
    do ... end` block will be the value returned by the fact. For example, you could
    make a more useful fact that returns the number of users currently logged in to
    the system:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 事实可以包含任何 Ruby 代码，并且在 `setcode do ... end` 块中评估的最后一个值将是该事实返回的值。例如，您可以创建一个更有用的事实，它返回当前登录系统的用户数量：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To reference the fact in your manifests, just use its name like a built-in
    fact:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要在清单中引用事实，只需像内置事实一样使用其名称：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can add custom facts to any Puppet module. When creating facts that will
    be used by multiple modules, it may make sense to place them in a facts module.
    In most cases, the custom fact is related to a specific module and should be placed
    in that module.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向任何Puppet模块添加自定义事实。在创建多个模块会使用到的事实时，将它们放置在事实模块中可能更有意义。在大多数情况下，自定义事实与特定模块相关，应将其放置在该模块中。
- en: There's more...
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'The name of the Ruby file that holds the fact definition is irrelevant. You
    can name this file whatever you wish; the name of the fact comes from the `Facter.add()`
    function call. You may also call this function several times within a single Ruby
    file to define multiple facts as necessary. For instance, you could `grep` the
    `/proc/meminfo` file and return several facts based on memory information as shown
    in the `meminfo.rb` file in the following code snippet:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 持有事实定义的Ruby文件的名称并不重要。你可以随意命名这个文件；事实的名称来自于`Facter.add()`函数的调用。你也可以在单个Ruby文件中多次调用该函数，根据需要定义多个事实。例如，你可以`grep`
    `/proc/meminfo`文件，并根据内存信息返回多个事实，如以下代码片段中的`meminfo.rb`文件所示：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After synchronizing this file to a node, the `memory_active` and `memory_inactive`
    facts would be available as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件同步到节点后，`memory_active`和`memory_inactive`事实将如下面所示可用：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can extend the use of facts to build a completely nodeless Puppet configuration;
    in other words, Puppet can decide what resources to apply to a machine, based
    solely on the results of facts. Jordan Sissel has written about this approach
    at [http://www.semicomplete.com/blog/geekery/puppet-nodeless-configuration.html](http://www.semicomplete.com/blog/geekery/puppet-nodeless-configuration.html).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以扩展事实的使用，构建一个完全没有节点的Puppet配置；换句话说，Puppet可以仅根据事实的结果决定应用哪些资源到机器上。Jordan Sissel在[http://www.semicomplete.com/blog/geekery/puppet-nodeless-configuration.html](http://www.semicomplete.com/blog/geekery/puppet-nodeless-configuration.html)上写过关于这种方法的文章。
- en: 'You can find out more about custom facts, including how to make sure that OS-specific
    facts work only on the relevant systems, and how to weigh facts so that they''re
    evaluated in a specific order at the puppetlabs website:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Puppetlabs网站上了解更多关于自定义事实的内容，包括如何确保操作系统特定的事实仅在相关系统上工作，以及如何加权事实，以确保它们按照特定顺序进行评估：
- en: '[http://docs.puppetlabs.com/guides/custom_facts.html](http://docs.puppetlabs.com/guides/custom_facts.html)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.puppetlabs.com/guides/custom_facts.html](http://docs.puppetlabs.com/guides/custom_facts.html)'
- en: See also
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: The *Importing dynamic information* recipe in [Chapter 3](ch03.html "Chapter 3. Writing
    Better Manifests"), *Writing Better Manifests*
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。编写更好的清单")的*导入动态信息*操作说明中，*编写更好的清单*。
- en: The *Configuring Hiera* recipe in [Chapter 2](ch02.html "Chapter 2. Puppet Infrastructure"),
    *Puppet Infrastructure*
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。Puppet基础设施")的*配置Hiera*操作说明中，*Puppet基础设施*。
- en: Adding external facts
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加外部事实
- en: The *Creating custom facts* recipe describes how to add extra facts written
    in Ruby. You can also create facts from simple text files or scripts with external
    facts instead.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*创建自定义事实*的操作说明描述了如何添加用Ruby编写的额外事实。你也可以选择从简单的文本文件或脚本中创建事实，使用外部事实替代。'
- en: 'External facts live in the `/etc/facter/facts.d` directory and have a simple
    `key=value` format like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 外部事实存放在`/etc/facter/facts.d`目录中，并具有简单的`key=value`格式，如下所示：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Getting ready
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Here''s what you need to do to prepare your system to add external facts:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你需要做的准备工作，以便为系统添加外部事实：
- en: 'You''ll need Facter Version 1.7 or higher to use external facts, so look up
    the value of `facterversion` or use `facter -v`:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要Facter版本1.7或更高版本才能使用外部事实，因此可以查找`facterversion`的值，或使用`facter -v`命令：
- en: '[PRE10]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You''ll also need to create the external facts directory, using the following
    command:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还需要创建外部事实目录，使用以下命令：
- en: '[PRE11]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到……
- en: 'In this example, we''ll create a simple external fact that returns a message,
    as shown in the *Creating custom facts* recipe:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个简单的外部事实，返回一条信息，如*创建自定义事实*操作说明所示：
- en: 'Create the file `/etc/facter/facts.d/local.txt` with the following contents:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文件`/etc/facter/facts.d/local.txt`，并加入以下内容：
- en: '[PRE12]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run the following command:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE13]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Well, that was easy! You can add more facts to the same file, or other files,
    of course, as follows:'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 好了，这很简单！你当然可以像下面这样，向相同的文件或其他文件添加更多的事实：
- en: '[PRE14]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: However, what if you need to compute a fact in some way, for example, the number
    of logged-in users? You can create executable facts to do this.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，如果你需要以某种方式计算事实，例如，计算已登录用户的数量怎么办？你可以创建可执行的事实来完成这个任务。
- en: 'Create the file `/etc/facter/facts.d/users.sh` with the following contents:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文件`/etc/facter/facts.d/users.sh`，并包含以下内容：
- en: '[PRE15]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Make this file executable with the following command:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令使这个文件变为可执行：
- en: '[PRE16]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now check the `users` value with the following command:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在使用以下命令检查`users`值：
- en: '[PRE17]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, we'll create an external fact by creating files on the node.
    We'll also show how to override a previously defined fact.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将通过在节点上创建文件来创建一个外部事实。我们还将展示如何覆盖之前定义的事实。
- en: 'Current versions of Facter will look into `/etc/facter/facts.d` for files of
    type `.txt`, `.json`, or `.yaml`. If facter finds a text file, it will parse the
    file for `key=value` pairs and add the key as a new fact:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前版本的Facter会查找`/etc/facter/facts.d`目录下的`.txt`、`.json`或`.yaml`类型的文件。如果Facter找到文本文件，它会解析文件中的`key=value`对，并将键作为一个新的事实：
- en: '[PRE18]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If the file is a YAML or JSON file, then facter will parse the file for `key=value`
    pairs in the respective format. For YAML, for instance:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件是YAML或JSON格式，Facter会按照相应的格式解析文件中的`key=value`对。例如，对于YAML文件：
- en: '[PRE19]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The resulting output will be as follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果输出如下：
- en: '[PRE20]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the case of executable files, Facter will assume that their output is a list
    of `key=value` pairs. It will execute all the files in the `facts.d` directory
    and add their output to the internal fact hash.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于可执行文件，Facter会假设它们的输出是`key=value`对的列表。它将执行`facts.d`目录中的所有文件，并将它们的输出添加到内部事实哈希中。
- en: Tip
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In Windows, batch files or PowerShell scripts may be used in the same way that
    executable scripts are used in Linux.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Windows中，批处理文件或PowerShell脚本可以像在Linux中使用可执行脚本一样使用。
- en: 'In the `users` example, Facter will execute the `users.sh` script, which results
    in the following output:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`users`示例中，Facter将执行`users.sh`脚本，生成以下输出：
- en: '[PRE21]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It will then search this output for `users` and return the matching value:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它会在这个输出中搜索`users`并返回匹配的值：
- en: '[PRE22]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If there are multiple matches for the key you specified, Facter determines
    which fact to return based on a weight property. In my version of facter, the
    weight of external facts is 10,000 (defined in `facter/util/directory_loader.rb`
    as `EXTERNAL_FACT_WEIGHT`). This high value is to ensure that the facts you define
    can override the supplied facts. For example:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果为您指定的键有多个匹配项，Facter会根据权重属性决定返回哪个事实。在我使用的版本中，外部事实的权重为10,000（在`facter/util/directory_loader.rb`中定义为`EXTERNAL_FACT_WEIGHT`）。这个高权重值是为了确保您定义的事实能够覆盖已提供的事实。例如：
- en: '[PRE23]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There's more...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Since all external facts have a weight of 10,000, the order in which they are
    parsed within the `/etc/facter/facts.d` directory sets their precedence (with
    the last one encountered having the highest precedence). To create a fact that
    will be favored over another, you''ll need to have it created in a file that comes
    last alphabetically:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有外部事实的权重为10,000，它们在`/etc/facter/facts.d`目录中被解析的顺序决定了它们的优先级（最后被遇到的事实具有最高优先级）。要创建一个优先于其他事实的事实，您需要将它创建在按字母顺序最后的文件中：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Debugging external facts
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试外部事实
- en: 'If you''re having trouble getting Facter to recognize your external facts,
    run Facter in debug mode to see what''s happening:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在让Facter识别外部事实时遇到问题，可以以调试模式运行Facter，看看发生了什么：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `X` JSON file was parsed but returned an empty data set error, which means
    Facter didn't find any `key=value` pairs in the file or (in the case of an executable
    fact) in its output.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`X` JSON文件被解析，但返回了一个空数据集错误，这意味着Facter没有在文件中找到任何`key=value`对，或者（在可执行事实的情况下）在其输出中没有找到。'
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that if you have external facts present, Facter parses or runs all the
    facts in the `/etc/facter/facts.d` directory every time you query Facter. If some
    of these scripts take a long time to run, that can significantly slow down anything
    that uses Facter (run Facter with the `--iming` switch to troubleshoot this).
    Unless a particular fact needs to be recomputed every time it's queried, consider
    replacing it with a cron job that computes it every so often and writes the result
    to a text file in the Facter directory.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您有外部事实存在，Facter每次查询时都会解析或运行`/etc/facter/facts.d`目录中的所有事实。如果其中一些脚本运行时间较长，这可能会显著拖慢任何使用Facter的程序（使用`--iming`开关运行Facter以排除故障）。除非某个特定的事实每次查询时都需要重新计算，否则考虑使用cron作业定期计算该事实并将结果写入Facter目录中的文本文件。
- en: Using external facts in Puppet
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Puppet中使用外部事实
- en: 'Any external facts you create will be available to both Facter and Puppet.
    To reference external facts in your Puppet manifests, just use the fact name in
    the same way you would for a built-in or custom fact:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建的任何外部事实都将同时对Facter和Puppet可用。要在Puppet清单中引用外部事实，只需像使用内建或自定义事实一样使用事实名称：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Unless you are specifically attempting to override a defined fact, you should
    avoid using the name of a predefined fact.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你特别尝试覆盖已定义的事实，否则应避免使用预定义事实的名称。
- en: See also
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Importing dynamic information* recipe in [Chapter 3](ch03.html "Chapter 3. Writing
    Better Manifests"), *Writing Better Manifests*
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html "第3章. 编写更好的清单")中的*导入动态信息*食谱，*编写更好的清单*'
- en: The *Configuring Hiera* recipe in [Chapter 2](ch02.html "Chapter 2. Puppet Infrastructure"),
    *Puppet Infrastructure*
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](ch02.html "第2章. Puppet基础设施")中的*配置Hiera*食谱，*Puppet基础设施*'
- en: The *Creating custom facts* recipe in this chapter
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*创建自定义事实*食谱
- en: Setting facts as environment variables
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将事实设置为环境变量
- en: 'Another handy way to get information into Puppet and Facter is to pass it using
    environment variables. Any environment variable whose name starts with `FACTER_`
    will be interpreted as a fact. For example, ask facter the value of hello using
    the following command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种将信息传递给Puppet和Facter的便捷方式是使用环境变量。任何以`FACTER_`开头的环境变量都会被解释为一个事实。例如，使用以下命令询问facter
    hello的值：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now override the value with an environment variable and ask again:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过环境变量覆盖值，并重新询问：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It works just as well with Puppet, so let's run through an example.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 它同样适用于Puppet，因此让我们通过一个示例来操作。
- en: How to do it...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this example we''ll set a fact using an environment variable:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用环境变量设置一个事实：
- en: 'Keep the node definition for cookbook the same as our last example:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持cookbook的节点定义与我们上一个示例相同：
- en: '[PRE29]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Run the following command:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE30]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Generating manifests with the Puppet resource command
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Puppet资源命令生成清单
- en: If you have a server that is already configured as it needs to be, or nearly
    so, you can capture that configuration as a Puppet manifest. The Puppet resource
    command generates Puppet manifests from the existing configuration of a system.
    For example, you can have `puppet resource` generate a manifest that creates all
    the users found on the system. This is very useful to take a snapshot of a working
    system and get its configuration quickly into Puppet.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一台已经配置好的服务器，或者几乎配置完成，你可以将该配置捕获为Puppet清单。Puppet资源命令会从系统的现有配置生成Puppet清单。例如，你可以使用`puppet
    resource`生成一个清单，创建系统中所有找到的用户。这对于拍摄一个正常工作的系统快照并将其配置快速导入Puppet非常有用。
- en: How to do it...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Here are some examples of using `puppet resource` to get data from a running
    system:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用`puppet resource`从运行中的系统获取数据的一些示例：
- en: 'To generate the manifest for a particular user, run the following command:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要为特定用户生成清单，运行以下命令：
- en: '[PRE31]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For a particular service, run the following command:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于某个特定的服务，运行以下命令：
- en: '[PRE32]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For a package, run the following command:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于包，运行以下命令：
- en: '[PRE33]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There's more...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can use `puppet resource` to examine each of the resource types available
    in Puppet. In the preceding examples, we generated a manifest for a specific instance
    of the resource type, but you can also use `puppet resource` to dump all instances
    of the resource:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`puppet resource`来检查Puppet中可用的每种资源类型。在前面的示例中，我们为资源类型的特定实例生成了一个清单，但你也可以使用`puppet
    resource`来输出所有该资源类型的实例：
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will output the state of each service on the system; this is because each
    service is an enumerable resource. When you try the same command with a resource
    that is not enumerable, you get an error message:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出系统中每个服务的状态；这是因为每个服务都是可枚举的资源。当你尝试对一个不可枚举的资源执行相同命令时，会收到错误信息：
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Asking Puppet to describe each file on the system will not work; that's something
    best left to an audit tool such as `tripwire` (a system designed to look for changes
    on every file on the system, [http://www.tripwire.com](http://www.tripwire.com)).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让Puppet描述系统中的每个文件是行不通的；这最好交给像`tripwire`这样的审计工具（这是一个设计用来查找系统中每个文件变化的工具，[http://www.tripwire.com](http://www.tripwire.com)）。
- en: Generating manifests with other tools
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用其他工具生成清单
- en: If you want to quickly capture the complete configuration of a running system
    as a Puppet manifest, there are a couple of tools available to help. In this example,
    we'll look at Blueprint, which is designed to examine a machine and dump its state
    as Puppet code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想快速捕获一个正在运行的系统的完整配置作为 Puppet 清单，可以使用一些工具来帮助你。在这个例子中，我们将使用 Blueprint，它旨在检查一台机器并将其状态输出为
    Puppet 代码。
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Here's what you need to do to prepare your system to use Blueprint.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是你需要做的准备工作，以便在系统中使用 Blueprint。
- en: 'Run the following command to install Blueprint; we''ll use `puppet resource`
    here to change the state of the `python-pip` package:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以安装 Blueprint；我们将使用 `puppet resource` 来更改 `python-pip` 包的状态：
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Tip
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You may need to install Git on your cookbook node if it is not already installed.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的食谱节点上尚未安装 Git，你可能需要先安装它。
- en: How to do it...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'These steps will show you how to run Blueprint:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将向你展示如何运行 Blueprint：
- en: 'Run the following commands:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE37]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Read the `blueprint_test/manifests/init.pp` file to see the generated code:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阅读 `blueprint_test/manifests/init.pp` 文件以查看生成的代码：
- en: '[PRE38]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There's more...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Blueprint just takes a snapshot of the system as it stands; it makes no intelligent
    decisions, and Blueprint captures all the files on the system and all the packages.
    It will generate a configuration much larger than you may actually require. For
    instance, when configuring a server, you may specify that you want the Apache
    package installed. The dependencies for the Apache package will be installed automatically
    and you need to specify them. When generating the configuration with a tool such
    as Blueprint, you will capture all those dependencies and lock the versions that
    are installed on your system currently. Looking at our generated Blueprint code,
    we can see that this is the case:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Blueprint 只是对当前系统进行快照；它不会做出智能的决策，并且 Blueprint 会捕获系统上的所有文件和所有软件包。它将生成一个可能比你实际需要的配置要大的配置。例如，当配置一个服务器时，你可能会指定要安装
    Apache 包。Apache 包的依赖项将自动安装，而你不需要指定它们。当使用像 Blueprint 这样的工具生成配置时，你将捕获所有这些依赖项，并锁定当前安装在你系统上的版本。从我们生成的
    Blueprint 代码来看，我们可以看到确实如此：
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If you were creating this manifest yourself, you would likely specify `ensure
    => installed` instead of a specific version.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你自己创建这个清单，你可能会指定`ensure => installed`，而不是具体的版本号。
- en: Packages install default versions of files. Blueprint has no notion of this
    and will add all the files to the manifest, even those that have not changed.
    By default, Blueprint will indiscriminately capture all the files in `/etc` as
    file resources.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 包安装默认版本的文件。Blueprint 并没有意识到这一点，会将所有文件添加到清单中，甚至那些没有变化的文件。默认情况下，Blueprint 会毫不分辨地捕获
    `/etc` 中的所有文件作为文件资源。
- en: Blueprint and similar tools have a very small use case generally, but may help
    you to get familiar with the Puppet syntax and give you some ideas on how to specify
    your own manifests. I would not recommend blindly using this tool to create a
    system, however.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Blueprint 和类似的工具通常有很小的应用场景，但它们可以帮助你熟悉 Puppet 语法，并给你一些关于如何指定自己清单的思路。然而，我并不建议盲目地使用这个工具来创建系统。
- en: There's no shortcut to good configuration management, those who hope to save
    time and effort by cutting and pasting someone else's code as a whole (as with
    public modules) are likely to find that it saves neither.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的配置管理没有捷径，那些希望通过复制和粘贴别人的代码（如公开模块）来节省时间和精力的人，可能会发现这既不能节省时间，也不能减少精力。
- en: Using an external node classifier
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用外部节点分类器
- en: 'When Puppet runs on a node, it needs to know which classes should be applied
    to that node. For example, if it is a web server node, it might need to include
    an `apache` class. The normal way to map nodes to classes is in the Puppet manifest
    itself, for example, in your `site.pp` file:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Puppet 在节点上运行时，它需要知道应该将哪些类应用于该节点。例如，如果它是一个 Web 服务器节点，可能需要包含一个 `apache` 类。将节点映射到类的正常方式是在
    Puppet 清单本身中，例如，在你的 `site.pp` 文件中：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Alternatively, you can use an **External Node Classifier (ENC)** to do this
    job. An ENC is any executable program that can accept the fully-qualified domain
    name (FQDN) as the first command-line argument (`$1`). The script is expected
    to return a list of classes, parameters, and an optional environment to apply
    to the node. The output is expected to be in the standard YAML format. When using
    an ENC, you should keep in mind that the classes applied through the standard
    `site.pp` manifest are merged with those provided by the ENC.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用**外部节点分类器（ENC）**来完成这项工作。ENC是任何可执行程序，它可以接受完全限定域名（FQDN）作为第一个命令行参数（`$1`）。该脚本应返回一个类、参数以及一个可选的环境列表，用于应用到节点。输出应该是标准的YAML格式。在使用ENC时，你应该记住，通过标准`site.pp`清单应用的类将与ENC提供的类合并。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Parameters returned by the ENC are available as top-scope variables to the node.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ENC返回的参数可作为顶级作用域变量提供给节点。
- en: An ENC could be a simple shell script, for example, or a wrapper around a more
    complicated program or API that can decide how to map nodes to classes. The ENC
    provided by Puppet enterprise and The Foreman ([http://theforeman.org/](http://theforeman.org/))
    are both simple scripts, which connect to the web API of their respective systems.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ENC可以是一个简单的Shell脚本，或者是一个更复杂的程序或API的包装器，能够决定如何将节点映射到类。Puppet企业版和The Foreman提供的ENC（[http://theforeman.org/](http://theforeman.org/)）都是简单的脚本，它们连接到各自系统的Web
    API。
- en: In this example, we'll build the most simple of ENCs, a shell script that simply
    prints a list of classes to include. We'll start by including an `enc` class,
    which defines `notify` that will print a top-scope variable `$enc`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将构建最简单的ENC，一个Shell脚本，简单地打印出包含的类列表。我们将从包含一个`enc`类开始，该类定义了`notify`，它将打印出一个顶级作用域变量`$enc`。
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We''ll start by creating our `enc` class to include with the `enc` script:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从创建我们的`enc`类开始，并与`enc`脚本一起使用：
- en: 'Run the following command:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE41]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create the file `modules/enc/manifests/init.pp` with the following contents:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文件`modules/enc/manifests/init.pp`，内容如下：
- en: '[PRE42]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How to do it...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Here''s how to build a simple external node classifier. We''ll perform all
    these steps on our Puppet master server. If you are running masterless, then do
    these steps on a node:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何构建一个简单的外部节点分类器的步骤。我们将在我们的Puppet主服务器上执行所有这些步骤。如果你是在无主模式下运行，请在节点上执行这些步骤：
- en: 'Create the file `/etc/puppet/cookbook.sh` with the following contents:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文件`/etc/puppet/cookbook.sh`，内容如下：
- en: '[PRE43]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Run the following command:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE44]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Modify your `/etc/puppet/puppet.conf` file as follows:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式修改你的`/etc/puppet/puppet.conf`文件：
- en: '[PRE45]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Restart Apache (restart the master) to make the change effective.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重启Apache（重启主服务器）以使更改生效。
- en: 'Ensure your `site.pp` file has the following empty definition for the default
    node:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的`site.pp`文件中有以下默认节点的空定义：
- en: '[PRE46]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Run Puppet:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Puppet：
- en: '[PRE47]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How it works...
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When an ENC is set in `puppet.conf`, Puppet will call the specified program
    with the node's fqdn (technically, the certname variable) as the first command-line
    argument. In our example script, this argument is ignored, and it just outputs
    a fixed list of classes (actually, just one class).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`puppet.conf`中设置ENC时，Puppet将使用节点的FQDN（技术上是`certname`变量）作为第一个命令行参数调用指定的程序。在我们的示例脚本中，这个参数被忽略，它只输出一个固定的类列表（实际上，只有一个类）。
- en: Obviously this script is not terribly useful; a more sophisticated script might
    check a database to find the class list, or look up the node in a hash, or an
    external text file or database (often an organization's configuration management
    database, **CMDB**). Hopefully, this example is enough to get you started with
    writing your own external node classifier. Remember that you can write your script
    in any language you prefer.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，这个脚本并不是特别有用；一个更复杂的脚本可能会检查数据库以查找类列表，或者在哈希表中查找节点，或者查阅外部文本文件或数据库（通常是一个组织的配置管理数据库，**CMDB**）。希望这个示例足以帮助你开始编写你自己的外部节点分类器。记住，你可以使用任何你喜欢的语言编写脚本。
- en: There's more...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'An ENC can supply a whole list of classes to be included in the node, in the
    following (YAML) format:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ENC可以提供一整类需要包含在节点中的类，格式如下（YAML）：
- en: '[PRE48]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'For classes that take parameters, you can use this format:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要参数的类，你可以使用以下格式：
- en: '[PRE49]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You can also produce top-scope variables using an ENC with this format:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用以下格式的ENC生成顶级作用域变量：
- en: '[PRE50]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Variables that you set in this way will be available in your manifest using
    the normal syntax for a top-scope variable, for example `$::message`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你以这种方式设置的变量将在清单中使用常规的顶级作用域变量语法，例如`$::message`，可以访问这些变量。
- en: See also
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'See the puppetlabs ENC page for more information on writing and using ENCs:
    [http://docs.puppetlabs.com/guides/external_nodes.html](http://docs.puppetlabs.com/guides/external_nodes.html)'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见 puppetlabs ENC 页面，了解更多关于编写和使用 ENC 的信息：[http://docs.puppetlabs.com/guides/external_nodes.html](http://docs.puppetlabs.com/guides/external_nodes.html)
- en: Creating your own resource types
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你自己的资源类型
- en: 'As you know, Puppet has a bunch of useful built-in resource types: packages,
    files, users, and so on. Usually, you can do everything you need to do by using
    either combinations of these built-in resources, or `define`, which you can use
    more or less in the same way as a resource (see [Chapter 3](ch03.html "Chapter 3. Writing
    Better Manifests"), *Writing Better Manifests* for information on definitions).'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，Puppet 有许多有用的内置资源类型：包、文件、用户等。通常，你可以通过使用这些内置资源的组合，或者使用 `define`（你可以像使用资源一样使用它）来完成你需要做的所有事情（有关定义的更多信息，请参见[第
    3 章](ch03.html "Chapter 3. Writing Better Manifests")，*编写更好的清单*）。
- en: In the early days of Puppet, creating your own resource type was more common
    as the list of core resources was shorter than it is today. Before you consider
    creating your own resource type, I suggest searching the Forge for alternative
    solutions. Even if you can find a project that only partially solves your problem,
    you will be better served by extending and helping out that project, rather than
    trying to create your own. However, if you need to create your own resource type,
    Puppet makes it quite easy. The native types are written in Ruby, and you will
    need a basic familiarity with Ruby in order to create your own.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puppet 的早期，创建自定义资源类型更为常见，因为核心资源的列表比今天要短。在你考虑创建自己的资源类型之前，我建议你先在 Forge 中搜索替代解决方案。即使你只找到部分解决问题的项目，你也会通过扩展和帮助这个项目得到更好的服务，而不是试图创建自己的资源类型。然而，如果你确实需要创建自己的资源类型，Puppet
    使这变得非常容易。原生类型是用 Ruby 编写的，因此你需要对 Ruby 有一定的基础了解才能创建自己的资源类型。
- en: Let's refresh our memory on the distinction between types and providers. A type
    describes a resource and the parameters it can have (for example, the `package`
    type). A provider tells Puppet how to implement a resource type for a particular
    platform or situation (for example, the `apt/dpkg` providers implement the `package`
    type for Debian-like systems).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下类型与提供者的区别。类型描述了一个资源及其可以拥有的参数（例如，`package` 类型）。提供者告诉 Puppet 如何为特定平台或情况实现资源类型（例如，`apt/dpkg`
    提供者为类似 Debian 的系统实现了 `package` 类型）。
- en: A single type (`package`) can have many providers (APT, YUM, Fink, and so on).
    If you don't specify a provider when declaring a resource, Puppet will choose
    the most appropriate one given the environment.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单一类型（`package`）可以有多个提供者（APT、YUM、Fink 等）。如果在声明资源时没有指定提供者，Puppet 将根据环境选择最合适的提供者。
- en: We'll use Ruby in this section; if you are not familiar with Ruby try visiting
    [http://www.ruby-doc.org/docs/Tutorial/](http://www.ruby-doc.org/docs/Tutorial/)
    or [http://www.codecademy.com/tracks/ruby/](http://www.codecademy.com/tracks/ruby/).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 Ruby；如果你不熟悉 Ruby，可以访问[http://www.ruby-doc.org/docs/Tutorial/](http://www.ruby-doc.org/docs/Tutorial/)或[http://www.codecademy.com/tracks/ruby/](http://www.codecademy.com/tracks/ruby/)。
- en: How to do it...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: In this section, we'll see how to create a custom type that we can use to manage
    Git repositories, and in the next section, we'll write a provider to implement
    this type.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何创建一个自定义类型，用于管理 Git 仓库，而在接下来的部分中，我们将编写一个提供者来实现这个类型。
- en: 'Create the file `modules/cookbook/lib/puppet/type/gitrepo.rb` with the following
    contents:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 创建文件 `modules/cookbook/lib/puppet/type/gitrepo.rb`，内容如下：
- en: '[PRE51]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How it works...
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Custom types can live in any module, in a `lib/puppet/type` subdirectory and
    in a file named for the type (in our example, that's `modules/cookbook/lib/puppet/type/gitrepo.rb`).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义类型可以存在于任何模块中，位于 `lib/puppet/type` 子目录下，并且文件名应与类型名称相对应（在我们的例子中是 `modules/cookbook/lib/puppet/type/gitrepo.rb`）。
- en: 'The first line of `gitrepo.rb` tells Puppet to register a new type named `gitrepo`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`gitrepo.rb` 的第一行告诉 Puppet 注册一个名为 `gitrepo` 的新类型：'
- en: '[PRE52]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `ensurable` line automatically gives the type an `ensure` property, such
    as Puppet''s built-in resources:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`ensurable` 这一行会自动为该类型添加 `ensure` 属性，类似于 Puppet 的内置资源：'
- en: '[PRE53]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We''ll now give the type some parameters. For the moment, all we need is a
    `source` parameter for the Git source URL, and a `path` parameter to tell Puppet
    where the repo should be created in the filesystem:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将为该类型添加一些参数。目前，我们只需要一个 `source` 参数来指定 Git 源 URL，以及一个 `path` 参数来告诉 Puppet
    应该在哪个文件系统路径下创建该仓库：
- en: '[PRE54]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `isnamevar` declaration tells Puppet that the `source` parameter is the
    type''s namevar. So when you declare an instance of this resource, whatever name
    you give, it will be the value of `source`, for example:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`isnamevar` 声明告诉 Puppet `source` 参数是该类型的名称变量（namevar）。所以，当你声明此资源的实例时，不论你给定什么名字，它都会成为
    `source` 的值，例如：'
- en: '[PRE55]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, we tell Puppet that the type accepts the `path` parameter:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们告诉 Puppet 该类型接受 `path` 参数：
- en: '[PRE56]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: There's more...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'When deciding whether or not you should create a custom type, you should ask
    a few questions about the resource you are trying to describe such as:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定是否创建自定义类型时，你应该问自己一些问题，关于你试图描述的资源，例如：
- en: Is the resource enumerable? Can you easily obtain a list of all the instances
    of the resource on the system?
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源是可枚举的吗？你能轻松地获取系统上所有该资源实例的列表吗？
- en: Is the resource atomic? Can you ensure that only one copy of the resource exists
    on the system (this is particularly important when you want to use `ensure=>absent`
    on the resource)?
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源是原子性的吗？你能确保系统上只存在一份该资源吗（当你想对该资源使用`ensure=>absent`时，这一点尤为重要）？
- en: Is there any other resource that describes this resource? In such a case, a
    defined type based on the existing resource would, in most cases, be a simpler
    solution.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有其他资源描述此资源？在这种情况下，基于现有资源定义类型通常是更简单的解决方案。
- en: Documentation
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文档
- en: 'Our example is deliberately simple, but when you move on to developing real
    custom types for your production environment, you should add documentation strings
    to describe what the type and its parameters do, for example:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例故意保持简单，但当你开始为生产环境开发实际的自定义类型时，应该添加文档字符串来描述该类型及其参数的功能，例如：
- en: '[PRE57]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Validation
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证
- en: 'You can use parameter validation to generate useful error messages when someone
    tries to pass bad values to the resource. For example, you could validate that
    the directory where the repo is to be created actually exists:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用参数验证来生成有用的错误消息，当有人试图向资源传递无效值时。例如，你可以验证存储库创建目录是否实际存在：
- en: '[PRE58]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You can also specify the list of allowed values that the parameter can take:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以指定该参数可以接受的值的列表：
- en: '[PRE59]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Creating your own providers
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你自己的提供者
- en: In the previous section, we created a new custom type called `gitrepo` and told
    Puppet that it takes two parameters, `source` and `path`. However, so far, we
    haven't told Puppet how to actually check out the repo; in other words, how to
    create a specific instance of this type. That's where the provider comes in.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们创建了一个新的自定义类型 `gitrepo`，并告诉 Puppet 它需要两个参数，`source` 和 `path`。但是，到目前为止，我们还没有告诉
    Puppet 如何实际检出该仓库；换句话说，就是如何创建此类型的特定实例。这时，提供者（provider）就派上用场了。
- en: 'We saw that a type will often have several possible providers. In our example,
    there is only one sensible way to instantiate a Git repo, so we''ll only supply
    one provider: `git`. If you were to generalize this type—to just repo, say—it''s
    not hard to imagine creating several different providers depending on the type
    of repo, for example, `git`, `svn`, `cvs`, and so on.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到一个类型通常会有多个可能的提供者。在我们的示例中，实例化 Git 仓库只有一种合理的方法，所以我们只提供一个提供者：`git`。如果你要将此类型通用化——比如叫做仓库（repo）——可以很容易地想象，根据仓库的类型创建多个不同的提供者，例如
    `git`、`svn`、`cvs` 等等。
- en: How to do it...
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We'll add the `git` provider, and create an instance of a `gitrepo` resource
    to check that it all works. You'll need Git installed for this to work, but if
    you're using the Git-based manifest management setup described in [Chapter 2](ch02.html
    "Chapter 2. Puppet Infrastructure"), *Puppet Infrastructure*, we can safely assume
    that Git is available.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加 `git` 提供者，并创建一个 `gitrepo` 资源实例来检查是否一切正常。为了让它工作，你需要安装 Git，但如果你正在使用在[第2章](ch02.html
    "第2章. Puppet基础设施")中描述的基于 Git 的清单管理设置，*Puppet基础设施*，我们可以安全地假设 Git 是可用的。
- en: 'Create the file `modules/cookbook/lib/puppet/provider/gitrepo/git.rb` with
    the following contents:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文件 `modules/cookbook/lib/puppet/provider/gitrepo/git.rb`，内容如下：
- en: '[PRE60]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Modify your `site.pp` file as follows:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式修改你的 `site.pp` 文件：
- en: '[PRE61]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Run Puppet:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Puppet：
- en: '[PRE62]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: How it works...
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Custom providers can live in any module, in a `lib/puppet/provider/TYPE_NAME`
    subdirectory in a file named after the provider. (The provider is the actual program
    that is run on the system; in our example, the program is Git and the provider
    is in `modules/cookbook/lib/puppet/provider/gitrepo/git.rb`. Note that the name
    of the module is irrelevant.)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义提供程序可以存放在任何模块中，位于 `lib/puppet/provider/TYPE_NAME` 子目录下，并命名为提供程序的名称。（提供程序是实际在系统上运行的程序；在我们的示例中，程序是
    Git，而提供程序位于 `modules/cookbook/lib/puppet/provider/gitrepo/git.rb`。请注意，模块的名称并不重要。）
- en: 'After an ntitial require line in `git.rb`, we tell Puppet to register a new
    provider for the `gitrepo` type with the following line:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `git.rb` 的初始 `require` 语句后，我们告诉 Puppet 使用以下语句注册 `gitrepo` 类型的新提供程序：
- en: '[PRE63]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'When you declare an instance of the `gitrepo` type in your manifest, Puppet
    will first of all check whether the instance already exists, by calling the `exists?`
    method on the provider. So we need to supply this method, complete with code to
    check whether an instance of the `gitrepo` type already exists:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在清单中声明 `gitrepo` 类型的实例时，Puppet 会首先检查该实例是否已经存在，通过调用提供程序的 `exists?` 方法。所以我们需要提供这个方法，并编写代码来检查
    `gitrepo` 类型的实例是否已经存在：
- en: '[PRE64]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This is not the most sophisticated implementation; it simply returns `true`
    if a directory exists matching the `path` parameter of the instance. A better
    implementation of `exists?` might check, for example, whether there is a `.git`
    subdirectory and that it contains valid Git metadata. But this will do for now.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是最复杂的实现；它仅仅在存在与实例的 `path` 参数匹配的目录时返回 `true`。更好的 `exists?` 实现可能会检查，例如，是否存在
    `.git` 子目录，并且它包含有效的 Git 元数据。但现在这样已经足够。
- en: If `exists?` returns `true`, then Puppet will take no further action because
    the specified resource exists (as far as Puppet knows). If it returns `false`,
    Puppet assumes the resource doesn't yet exist, and will try to create it by calling
    the provider's `create` method.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `exists?` 返回 `true`，那么 Puppet 将不再采取任何进一步的操作，因为指定的资源已经存在（至少 Puppet 是这么认为的）。如果返回
    `false`，Puppet 假设资源尚不存在，并会尝试通过调用提供程序的 `create` 方法来创建它。
- en: 'Accordingly, we supply some code for the `create` method that calls the `git
    clone` command to create the repo:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们提供一些代码给 `create` 方法，它调用 `git clone` 命令来创建仓库：
- en: '[PRE65]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The method has access to the instance's parameters, which we need to know where
    to check out the repo from, and which directory to create it in. We get this by
    looking at `resource[:source]` and `resource[:path]`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法可以访问实例的参数，我们需要了解从哪里检出代码仓库，并且在哪个目录下创建它。我们通过查看 `resource[:source]` 和 `resource[:path]`
    来获得这些信息。
- en: There's more...
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: You can see that custom types and providers in Puppet are very powerful. In
    fact, they can do anything—at least, anything that Ruby can do. If you are managing
    some parts of your infrastructure with complicated `define` statements and `exec`
    resources, you may want to consider replacing these with a custom type. However,
    as stated previously, it's worth looking around to see if someone else has already
    done this before implementing your own.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，Puppet 中的自定义类型和提供程序非常强大。事实上，它们可以做任何事情——至少是 Ruby 可以做的任何事情。如果你正在使用复杂的 `define`
    语句和 `exec` 资源来管理基础设施的某些部分，你可能想考虑用自定义类型来替代它们。然而，正如前面所说，在实现自己的之前，值得四处看看，看看是否有人已经做过类似的事情。
- en: 'Our example was very simple, and there is much more to learn about writing
    your own types. If you''re going to distribute your code for others to use, or
    even if you aren''t, it''s a good idea to include tests with it. puppetlabs has
    a useful page on the interface between custom types and providers:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例非常简单，关于编写自定义类型还有很多内容需要学习。如果你打算将代码分发给别人使用，或者即使不打算分发，包含测试代码也是一个好主意。puppetlabs
    有一个关于自定义类型与提供程序接口的有用页面：
- en: '[http://docs.puppetlabs.com/guides/custom_types.html](http://docs.puppetlabs.com/guides/custom_types.html)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.puppetlabs.com/guides/custom_types.html](http://docs.puppetlabs.com/guides/custom_types.html)'
- en: 'on implementing providers:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 关于实现提供程序：
- en: '[http://docs.puppetlabs.com/guides/provider_development.html](http://docs.puppetlabs.com/guides/provider_development.html)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.puppetlabs.com/guides/provider_development.html](http://docs.puppetlabs.com/guides/provider_development.html)'
- en: 'and a complete worked example of developing a custom type and provider, a little
    more advanced than that presented in this book:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 以及一个完整的实例，展示了开发自定义类型和提供程序的过程，比书中展示的内容稍微复杂一些：
- en: '[http://docs.puppetlabs.com/guides/complete_resource_example.html](http://docs.puppetlabs.com/guides/complete_resource_example.html)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.puppetlabs.com/guides/complete_resource_example.html](http://docs.puppetlabs.com/guides/complete_resource_example.html)'
- en: Creating custom functions
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义函数
- en: If you've read the recipe *Using GnuPG to encrypt secrets* in [Chapter 4](ch04.html
    "Chapter 4. Working with Files and Packages"), *Working with Files and Packages*,
    then you've already seen an example of a custom function (in that example, we
    created a `secret` function, which shelled out to GnuPG). Let's look at `custom`
    functions in a little more detail now and build an example.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经阅读过[第4章](ch04.html "第4章 工作与文件和软件包")中的*使用GnuPG加密秘密*，*工作与文件和软件包*，那么你应该已经见过一个自定义函数的例子（在那个例子中，我们创建了一个`secret`函数，调用了GnuPG）。现在我们更详细地了解`custom`函数，并构建一个示例。
- en: How to do it...
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'If you''ve read the recipe *Distributing cron jobs efficiently* in [Chapter
    6](ch06.html "Chapter 6. Managing Resources and Files"), *Managing Resources and
    Files*, you might remember that we used the `inline_template` function to set
    a random time for cron jobs to run, based on the hostname of the node. In this
    example, we''ll take that idea and turn it into a custom function called `random_minute`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经阅读过[第6章](ch06.html "第6章 管理资源与文件")中的*高效分发cron任务*，*管理资源与文件*，你可能还记得我们使用了`inline_template`函数根据节点的主机名设置随机时间来运行cron任务。在这个例子中，我们将这个想法转化为一个名为`random_minute`的自定义函数：
- en: 'Create the file `modules/cookbook/lib/puppet/parser/functions/random_minute.rb`
    with the following contents:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文件`modules/cookbook/lib/puppet/parser/functions/random_minute.rb`，并包含以下内容：
- en: '[PRE66]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Modify your `site.pp` file as follows:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式修改你的`site.pp`文件：
- en: '[PRE67]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Run Puppet:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Puppet：
- en: '[PRE68]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Check `crontab` with the following command:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查`crontab`：
- en: '[PRE69]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: How it works...
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Custom functions can live in any module, in the `lib/puppet/parser/functions`
    subdirectory in a file named after the function (in our example, `random_minute.rb`).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义函数可以存在于任何模块中，存放在`lib/puppet/parser/functions`子目录中的一个文件里，文件名与函数名相同（在我们的例子中是`random_minute.rb`）。
- en: 'The function code goes inside a `module ... end` block like this:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 函数代码放在一个`module ... end`块中，如下所示：
- en: '[PRE70]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We then call `newfunction` to declare our new function, passing the name (`:random_minute`)
    and the type of function (`:rvalue`):'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用`newfunction`来声明我们的新函数，传递名称（`:random_minute`）和函数类型（`:rvalue`）：
- en: '[PRE71]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `:rvalue` bit simply means that this function returns a value.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`:rvalue`部分仅表示此函数返回一个值。'
- en: 'Finally, the function code itself is as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，函数代码本身如下：
- en: '[PRE72]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `lookupvar` function lets you access facts and variables by name; in this
    case, `hostname` to get the name of the node we're running on. We use the Ruby
    `sum` method to get the numeric sum of the characters in this string, and then
    perform integer division modulo 60 to make sure the result is in the range `0..59`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`lookupvar`函数让你通过名称访问事实和变量；在这个例子中，使用`hostname`来获取我们运行的节点名称。我们使用Ruby的`sum`方法获取字符串中字符的数值总和，然后进行整数除法取模60，以确保结果在`0..59`的范围内。'
- en: There's more...
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can, of course, do a lot more with custom functions. In fact, anything
    you can do in Ruby, you can do in a custom function. You also have access to all
    the facts and variables that are in scope at the point in the Puppet manifest
    where the function is called, by calling `lookupvar` as shown in the example.
    You can also work on arguments, for example, a general purpose hashing function
    that takes two arguments: the size of the hash table and optionally the thing
    to hash. Create `modules/cookbook/lib/puppet/parser/functions/hashtable.rb` with
    the following contents:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以通过自定义函数做更多的事情。实际上，任何你能在Ruby中做的事情，都可以在自定义函数中做。你还可以访问在Puppet清单中函数被调用时作用域内的所有事实和变量，通过调用`lookupvar`就像示例中展示的那样。你还可以操作参数，例如创建一个通用的哈希函数，它接受两个参数：哈希表的大小和可选的哈希内容。创建`modules/cookbook/lib/puppet/parser/functions/hashtable.rb`，并包含以下内容：
- en: '[PRE73]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now we''ll create a test for our `hashtable` function and alter `site.pp` as
    follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将为`hashtable`函数创建一个测试，并按如下方式修改`site.pp`：
- en: '[PRE74]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, run Puppet and observe the values that are returned:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行Puppet并观察返回的值：
- en: '[PRE75]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Our simple definition quickly grew when we added the ability to add arguments.
    As with all programming, care should be taken when working with arguments to ensure
    that you do not have any error conditions. In the preceding code, we specifically
    looked for the situation where the size variable was 0, to avoid a divide by zero
    error.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的简单定义在我们增加了参数功能后迅速增长。与所有编程一样，在处理参数时要特别小心，确保没有错误情况。在之前的代码中，我们专门检查了`size`变量为0的情况，以避免除零错误。
- en: 'To find out more about what you can do with custom functions, see the puppetlabs
    website:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于自定义函数的内容，请参阅puppetlabs网站：
- en: '[http://docs.puppetlabs.com/guides/custom_functions.html](http://docs.puppetlabs.com/guides/custom_functions.html)'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.puppetlabs.com/guides/custom_functions.html](http://docs.puppetlabs.com/guides/custom_functions.html)'
- en: Testing your puppet manifests with rspec-puppet
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用rspec-puppet测试你的Puppet清单
- en: It would be great if we could verify that our Puppet manifests satisfy certain
    expectations without even having to run Puppet. The `rspec-puppet` tool is a nifty
    tool to do this. Based on RSpec, a testing framework for Ruby programs, `rspec-puppet`
    lets you write test cases for your Puppet manifests that are especially useful
    to catch regressions (bugs introduced when fixing another bug), and refactoring
    problems (bugs introduced when reorganizing your code).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能验证我们的Puppet清单是否满足某些预期，而不必运行Puppet，那将是极好的。`rspec-puppet`是一个很棒的工具，可以实现这一目标。基于RSpec，一个Ruby程序的测试框架，`rspec-puppet`让你为Puppet清单编写测试用例，特别有助于捕捉回归问题（修复另一个bug时引入的bug）和重构问题（重组代码时引入的bug）。
- en: Getting ready
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Here's what you'll need to do to install `rspec-puppet`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是安装`rspec-puppet`时你需要做的步骤：
- en: 'Run the following commands:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE76]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: How to do it...
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let's create an example class, `thing`, and write some tests for it.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个示例类`thing`，并为其编写一些测试。
- en: 'Define the `thing` class:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`thing`类：
- en: '[PRE77]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Run the following commands:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE78]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Create the file `spec/classes/thing_spec.rb` with the following contents:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文件`spec/classes/thing_spec.rb`，并写入以下内容：
- en: '[PRE79]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Run the following commands:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE80]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: How it works...
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `rspec-puppet-init` command creates a framework of directories for you to
    put your specs (test programs) in. At the moment, we're just interested in the
    `spec/classes` directory. This is where you'll put your class specs, one per class,
    named after the class it tests, for example, `thing_spec.rb`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`rspec-puppet-init`命令为你创建一个目录框架，以便你将你的测试程序（specs）放入其中。现在，我们只关心`spec/classes`目录。这里是你将放置每个类的测试文件的地方，每个文件以类名命名，例如，`thing_spec.rb`。'
- en: 'The `spec` code itself begins with the following statement, which sets up the
    RSpec environment to run the specs:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`spec`代码本身以以下语句开始，设置了运行测试的RSpec环境：'
- en: '[PRE81]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Then, a `describe` block follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，跟着一个`describe`块：
- en: '[PRE82]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The `describe` identifies the class we're going to test (`thing`) and wraps
    the list of assertions about the class inside a `do .. end` block.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe`标识了我们要测试的类（`thing`），并将关于该类的断言列表放入一个`do .. end`块中。'
- en: 'Assertions are our stated expectations of the `thing` class. For example, the
    first assertion is the following:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 断言是我们对`thing`类的预期。例如，第一个断言如下：
- en: '[PRE83]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The `create_class` assertion is used to ensure that the named class is actually
    created. The next line:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_class`断言用于确保命名的类确实被创建。接下来的行：'
- en: '[PRE84]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `contain_package` assertion means what it says: the class should contain
    a package resource named `thing`.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`contain_package`断言意味着它字面上的意思：该类应该包含一个名为`thing`的包资源。'
- en: 'Next, we test for the existence of the `thing` service:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们测试`thing`服务的存在：
- en: '[PRE85]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The preceding code actually contains two assertions. First, that the class
    contains a `thing` service:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码实际上包含了两个断言。首先，类包含一个`thing`服务：
- en: '[PRE86]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Second, that the service has an `ensure` attribute with the value `running`:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，服务具有一个`ensure`属性，值为`running`：
- en: '[PRE87]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'You can specify any attributes and values you want using the `with` method,
    as a comma-separated list. For example, the following code asserts several attributes
    of a `file` resource:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`with`方法指定任何你想要的属性和值，作为逗号分隔的列表。例如，以下代码断言了一个`file`资源的多个属性：
- en: '[PRE88]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'In our `thing` example, we need to only test that the file `thing.conf` is
    present, using the following code:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`thing`示例中，我们只需要测试文件`thing.conf`是否存在，使用以下代码：
- en: '[PRE89]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'When you run the `rake spec` command, `rspec-puppet` will compile the relevant
    Puppet classes, run all the specs it finds, and display the results:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行`rake spec`命令时，`rspec-puppet`将编译相关的Puppet类，运行它找到的所有测试，并显示结果：
- en: '[PRE90]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'As you can see, we defined the file in our test as `/etc/things.conf` but the
    file in the manifests is `/etc/thing.conf`, so the test fails. Edit `thing_spec.rb`
    and change `/etc/things.conf to /etc/thing.conf`:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们在测试中定义的文件是`/etc/things.conf`，但清单中的文件是`/etc/thing.conf`，因此测试失败。编辑`thing_spec.rb`，将`/etc/things.conf`改为`/etc/thing.conf`：
- en: '[PRE91]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now run rspec again:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次运行rspec：
- en: '[PRE92]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: There's more...
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are many conditions you can verify with rspec. Any resource type can be
    verified with `contain_<resource type>`(title). In addition to verifying your
    classes will apply correctly, you can also test functions and definitions by using
    the appropriate subdirectories within the spec directory (classes, defines, or
    functions).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 rspec，你可以验证许多条件。任何资源类型都可以通过 `contain_<资源类型>`(标题) 进行验证。除了验证你的类是否能正确应用外，你还可以通过在
    spec 目录内使用相应的子目录（类、定义或函数）来测试函数和定义。
- en: You can find more information about `rspec-puppet`, including complete documentation
    for the assertions available and a tutorial, at [http://rspec-puppet.com/](http://rspec-puppet.com/).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [http://rspec-puppet.com/](http://rspec-puppet.com/) 上找到更多关于 `rspec-puppet`
    的信息，包括可用断言的完整文档和教程。
- en: When you want to start testing how your code applies to nodes, you'll need to
    look at another tool, beaker. Beaker works with various virtualization platforms
    to create temporary virtual machines to which Puppet code is applied. The results
    are then used for acceptance testing of the Puppet code. This method of testing
    and developing at the same time is known as **Test-driven development** (**TDD**).
    More information about beaker is available on the GitHub site at [https://github.com/puppetlabs/beaker](https://github.com/puppetlabs/beaker).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想开始测试你的代码如何应用于节点时，你需要使用另一个工具——Beaker。Beaker 与各种虚拟化平台配合，创建临时虚拟机，并将 Puppet 代码应用到这些虚拟机上。然后，结果将用于
    Puppet 代码的验收测试。这种一边开发一边测试的方法被称为 **测试驱动开发**（**TDD**）。有关 Beaker 的更多信息，请访问 GitHub
    上的 [https://github.com/puppetlabs/beaker](https://github.com/puppetlabs/beaker)。
- en: See also
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Checking your manifests with puppet-lint* recipe in [Chapter 1](ch01.html
    "Chapter 1. Puppet Language and Style"), *Puppet Language and Style*
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章 Puppet 语言与风格")中的 *使用 puppet-lint 检查你的清单* 示例，*Puppet 语言与风格*'
- en: Using librarian-puppet
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 librarian-puppet
- en: When you begin to include modules from the forge in your Puppet infrastructure,
    keeping track of which versions you installed and ensuring consistency between
    all your testing areas can become a bit of a problem. Luckily, the tools we will
    discuss in the next two sections can bring order to your system. We will first
    begin with librarian-puppet, which uses a special configuration file named Puppetfile
    to specify the source location of your various modules.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始在 Puppet 基础设施中包含来自 Forge 的模块时，跟踪你安装的版本并确保所有测试区域的一致性可能会变得有些棘手。幸运的是，我们将在接下来的两节中讨论的工具可以为你的系统带来秩序。我们首先将介绍
    librarian-puppet，它使用一个名为 Puppetfile 的特殊配置文件来指定各种模块的源位置。
- en: Getting ready
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll install librarian-puppet to work through the example.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将安装 librarian-puppet 来完成这个示例。
- en: 'Install `librarian-puppet` on your Puppet master, using Puppet of course:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Puppet 在 Puppet 主机上安装 `librarian-puppet`，当然是通过 Puppet 安装：
- en: '[PRE93]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Tip
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are working in a masterless environment, install `librarian-puppet` on
    the machine from which you will be managing your code. Your gem install may fail
    if the Ruby development packages are not available on your master; install the
    `ruby-dev` package to fix this issue (use Puppet to do it).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个无主机环境中工作，请在你将管理代码的机器上安装 `librarian-puppet`。如果 Ruby 开发包在主机上不可用，你的 gem 安装可能会失败；安装
    `ruby-dev` 包可以解决这个问题（使用 Puppet 来安装）。
- en: How to do it...
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We''ll use librarian-puppet to download and install a module in this example:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用 librarian-puppet 下载并安装一个模块：
- en: 'Create a working directory for yourself; librarian-puppet will overwrite your
    modules directory by default, so we''ll work in a temporary location for now:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为自己创建一个工作目录；librarian-puppet 默认会覆盖你的模块目录，因此我们暂时将在临时位置工作：
- en: '[PRE94]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Create a new Puppetfile with the following contents:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Puppetfile，内容如下：
- en: '[PRE95]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Note
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Alternatively, you can use `librarian-puppet init` to create an example Puppetfile
    and edit it to match our example:'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另外，你可以使用 `librarian-puppet init` 来创建一个示例 Puppetfile，并编辑它以匹配我们的示例：
- en: '[PRE96]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Now, run librarian-puppet to download and install the `puppetlabs-stdlib` module
    in the `modules` directory:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行 librarian-puppet 来下载并安装 `puppetlabs-stdlib` 模块到 `modules` 目录：
- en: '[PRE97]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: How it works...
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first line of the `Puppetfile` makes the `Puppetfile` appear to be a Ruby
    source file. These are completely optional but coerces editors into treating the
    file as though it was written in Ruby (which it is):'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`Puppetfile` 的第一行让 `Puppetfile` 看起来像一个 Ruby 源代码文件。这些完全是可选的，但它强迫编辑器将该文件当作 Ruby
    文件来处理（事实上它就是 Ruby 文件）：'
- en: '[PRE98]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We next define where the Puppet Forge is located; you may specify an internal
    Forge here if you have a local mirror:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们定义 Puppet Forge 的位置；如果你有本地镜像，也可以在这里指定一个内部 Forge：
- en: '[PRE99]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Now, we added a line to include the `puppetlabs-stdlib` module:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们添加了一行以包括 `puppetlabs-stdlib` 模块：
- en: '[PRE100]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'With the `Puppetfile` in place, we ran `librarian-puppet` and it downloaded
    the module from the URL given in the Forge line. As the module was downloaded,
    `librarian-puppet` created a `Puppetfile.lock` file, which includes the location
    used as source and the version number for the downloaded module:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 有了 `Puppetfile` 后，我们运行了 `librarian-puppet`，它从 Forge 行中提供的 URL 下载了模块。当模块下载时，`librarian-puppet`
    创建了一个 `Puppetfile.lock` 文件，其中包含作为源使用的位置和下载模块的版本号：
- en: '[PRE101]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: There's more...
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `Puppetfile` allows you to pull in modules from sources other than the forge.
    You may use a local Git url or even a GitHub url to download modules that are
    not on the Forge. More information on librarian-puppet can be found on the GitHub
    website at [https://github.com/rodjek/librarian-puppet](https://github.com/rodjek/librarian-puppet).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`Puppetfile` 允许你从除 Forge 以外的来源拉取模块。你可以使用本地 Git URL，甚至是 GitHub URL，来下载那些不在 Forge
    上的模块。关于 librarian-puppet 的更多信息可以在 GitHub 网站上找到：[https://github.com/rodjek/librarian-puppet](https://github.com/rodjek/librarian-puppet)。'
- en: Note that librarian-puppet will create the modules directory and remove any
    modules you placed in there by default. Most installations using librarian-puppet
    opt to place their local modules in a `/local` subdirectory (`/dist` or `/companyname`
    are also used).
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，librarian-puppet 会创建模块目录并默认删除你放入其中的任何模块。大多数使用 librarian-puppet 的安装选择将本地模块放在
    `/local` 子目录中（`/dist` 或 `/companyname` 也常用）。
- en: In the next section, we'll talk about r10k, which goes one step further than
    librarian and manages your entire environment directory.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论 r10k，它比 librarian 更进一步，管理整个环境目录。
- en: Using r10k
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 r10k
- en: The `Puppetfile` is a very good format to describe which modules you wish to
    include in your environment. Building upon the `Puppetfile` is another tool, **r10k**.
    r10k is a total environment management tool. You can use r10k to clone a local
    Git repository into your `environmentpath` and then place the modules specified
    in your `Puppetfile` into that directory. The local Git repository is known as
    the master repository; it is where r10k expects to find your `Puppetfile`. r10k
    also understands Puppet environments and will clone Git branches into subdirectories
    of your `environmentpath`, simplifying the deployment of multiple environments.
    What makes r10k particularly useful is its use of a local cache directory to speed
    up deployments. Using a configuration file, `r10k.yaml`, you can specify where
    to store this cache and also where your master repository is held.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`Puppetfile` 是一种非常好的格式，用于描述你希望在环境中包含哪些模块。在 `Puppetfile` 的基础上，另一个工具是 **r10k**。r10k
    是一个完整的环境管理工具。你可以使用 r10k 将本地 Git 仓库克隆到你的 `environmentpath` 中，然后将 `Puppetfile` 中指定的模块放入该目录。这个本地
    Git 仓库被称为主仓库；r10k 期望在此找到你的 `Puppetfile`。r10k 还理解 Puppet 环境，并会将 Git 分支克隆到 `environmentpath`
    的子目录中，从而简化多个环境的部署。r10k 特别有用的一点是它使用本地缓存目录来加速部署。通过配置文件 `r10k.yaml`，你可以指定缓存的存储位置以及主仓库的位置。'
- en: Getting ready
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll install r10k on our controlling machine (usually the master). This is
    where we will control all the modules downloaded and installed.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在控制机器（通常是主机）上安装 r10k。这将是我们控制所有已下载和已安装模块的地方。
- en: 'Install r10k on your puppet master, or on whichever machine you wish to manage
    your `environmentpath` directory:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 Puppet 主机上安装 r10k，或者在你希望管理 `environmentpath` 目录的任何机器上安装：
- en: '[PRE102]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Make a new copy of your Git repository (optional, do this on your Git server):'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Git 仓库副本（可选，建议在你的 Git 服务器上进行）：
- en: '[PRE103]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Check out the new Git repository (on your local machine) and move the existing
    modules directory to a new location. We''ll use `/local` in this example:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的本地机器上检出新的 Git 仓库，并将现有的模块目录移动到新的位置。在本例中，我们使用 `/local`：
- en: '[PRE104]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: How to do it...
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We'll create a Puppetfile to control r10k and install modules on our master.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个 `Puppetfile` 来控制 r10k 并在我们的主机上安装模块。
- en: 'Create a `Puppetfile` into the new Git repository with the following contents:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的 Git 仓库中创建一个包含以下内容的 `Puppetfile`：
- en: '[PRE105]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Add the `Puppetfile` to your new repository:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Puppetfile` 添加到你的新仓库中：
- en: '[PRE106]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Back to your master, create `/etc/r10k.yaml` with the following contents:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到你的主机，创建 `/etc/r10k.yaml` 文件，内容如下：
- en: '[PRE107]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Run r10k to have the `/etc/puppet/environments` directory populated (hint:
    create a backup of your `/etc/puppet/environments` directory first):'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行r10k以填充`/etc/puppet/environments`目录（提示：首先备份你的`/etc/puppet/environments`目录）：
- en: '[PRE108]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Verify that your `/etc/puppet/environments` directory has a production subdirectory.
    Within that directory, the `/local` directory will exist and the modules directory
    will have all the modules listed in the `Puppetfile`:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认你的`/etc/puppet/environments`目录下有一个`production`子目录。在该目录内，`/local`目录将存在，并且模块目录中会列出`Puppetfile`中所有的模块：
- en: '[PRE109]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: How it works...
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We started by creating a copy of our Git repository; this was only done to preserve
    the earlier work and is not required. The important thing to remember with r10k
    and librarian-puppet is that they both assume they are in control of the `/modules`
    subdirectory. We need to move our modules out of the way and create a new location
    for the modules.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个Git仓库的副本；这样做只是为了保留之前的工作，并不是必须的。需要记住的重要事项是，r10k和librarian-puppet都假设它们控制着`/modules`子目录。我们需要将模块移开，并为模块创建一个新的位置。
- en: In the `r10k.yaml` file, we specified the location of our new repository. When
    we ran r10k, it first downloaded this repository into its local cache. Once the
    Git repository is downloaded locally, r10k will go through each branch and look
    for a `Puppetfile` within the branch. For each `branch/Puppetfile` combination,
    the modules specified within are downloaded first to the local cache directory
    (`cachedir`) and then into the `basedir`, which was given in `r10k.yaml`.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在`r10k.yaml`文件中，我们指定了新仓库的位置。当我们运行r10k时，它首先将这个仓库下载到本地缓存中。一旦Git仓库被下载到本地，r10k会遍历每个分支，并查找该分支中的`Puppetfile`。对于每个`branch/Puppetfile`组合，里面指定的模块首先下载到本地缓存目录（`cachedir`），然后下载到`r10k.yaml`中指定的`basedir`。
- en: There's more...
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: You can automate the deployment of your environments using `r10k`. The command
    we used to run `r10k` and populate our environments directory can be easily placed
    inside a Git hook to automatically update your environment. There is also a **marionette
    collective** (**mcollective**) plugin ([https://github.com/acidprime/r10k](https://github.com/acidprime/r10k)),
    which can be used to have `r10k` run on an arbitrary set of servers.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`r10k`来自动化部署你的环境。我们用来运行`r10k`并填充我们的环境目录的命令，可以轻松地放入Git钩子中，自动更新你的环境。还有一个**marionette
    collective**（**mcollective**）插件（[https://github.com/acidprime/r10k](https://github.com/acidprime/r10k)），可以让`r10k`在任意一组服务器上运行。
- en: Using either of these tools will help keep your site consistent, even if you
    are not taking advantage of the various modules available on the Forge.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些工具中的任何一个将有助于保持你的网站一致，即使你没有利用Forge上可用的各种模块。
