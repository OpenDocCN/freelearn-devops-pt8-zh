- en: Chapter 6. Fundamentals of Managing Servers with Chef and Puppet
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。使用 Chef 和 Puppet 管理服务器的基础知识
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方：
- en: Getting started (notions and tools)
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 入门（概念和工具）
- en: Installing the Chef Development kit and Puppet Collections
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Chef 开发工具包和 Puppet 集合
- en: Creating a free hosted server Chef account and a Puppet server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个免费的托管服务器 Chef 帐户和一个 Puppet 服务器
- en: Automatically bootstrapping a Chef client and a Puppet agent
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动引导 Chef 客户端和 Puppet 代理
- en: Installing packages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装软件包
- en: Managing services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理服务
- en: Managing files, directories, and templates
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理文件，目录和模板
- en: Handling dependencies
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理依赖关系
- en: More dynamic code using notifications
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通知实现更动态的代码
- en: Centrally sharing data using a Chef data bag and Hiera with Puppet
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Chef 数据包和 Puppet 中的 Hiera 集中共享数据
- en: Creating functional roles
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建功能角色
- en: Managing external Chef cookbooks and Puppet modules
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理外部 Chef cookbooks 和 Puppet 模块
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Chef is an open source tool used to automate the configuration of systems and
    it integrates well with most IaaS such as Amazon Web Services, OpenStack, or Google
    Cloud. Using Chef, we write infrastructure code in Ruby that describes how every
    aspect of the system is expected to behave according to a number of conditions,
    then apply it through various client tools to ensure the defined state is applied.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Chef 是一个用于自动化系统配置的开源工具，与大多数 IaaS（如Amazon Web Services，OpenStack或Google Cloud）很好地集成。使用
    Chef，我们在 Ruby 中编写基础设施代码，描述系统的每个方面预期如何根据多种条件行为，然后通过各种客户端工具应用它，以确保应用定义的状态。
- en: In this chapter, you'll discover the essentials of managing servers using Chef
    code with the **Chef Development Kit** (**Chef DK**). You'll learn how to bootstrap
    a working Chef environment on a new server, how to install packages and manage
    services, how easy it is to generate dynamic configurations through files and
    templates, create useful functional roles, centrally share data to dynamically
    generate content, and show how to articulate dependencies between services while
    helping them notify each other of their state, so the whole deployment chain works
    in order. We'll also have an introduction on easily managing those dependencies,
    that will give an insight of how to deal with more complex infrastructures managed
    by Chef.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解使用**Chef开发工具包**（**Chef DK**）管理服务器的基本知识。您将学习如何在新服务器上引导工作中的 Chef 环境，如何安装软件包和管理服务，如何通过文件和模板生成动态配置，创建有用的功能角色，集中共享数据以动态生成内容，并展示如何表达服务之间的依赖关系，帮助它们互相通知其状态，使整个部署链有序工作。我们还将介绍如何轻松管理这些依赖关系，这将揭示如何处理由
    Chef 管理的更复杂的基础设施。
- en: To illustrate all those features, throughout the chapter we will build a classic
    **LAMP** (**Linux**, **Apache**, **MySQL**, **PHP**) server on CentOS 7.x, from
    scratch, 100% automated with Chef. This way, we'll go through all the features
    while progressively building our end project—a working LAMP server with external
    dependencies on the latest community MySQL 5.7 release, and more features.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明所有这些特性，在本章中，我们将从头开始在 CentOS 7.x 上构建一个经典的**LAMP**（**Linux**，**Apache**，**MySQL**，**PHP**）服务器，完全自动化，使用
    Chef。这样，我们将逐步构建我们的最终项目——一个带有外部依赖关系的工作LAMP服务器，最新社区 MySQL 5.7 版本，以及更多功能。
- en: All recipes are based on Chef. However, when possible, we'll try to show how
    things work similarly with Puppet, Chef's direct alternative.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的配方都基于 Chef。然而，在可能的情况下，我们将尝试展示与 Puppet 类似工作的方式，作为 Chef 的直接替代。
- en: Getting started (notions and tools)
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门（概念和工具）
- en: Chef is a very complex system, with a lot of notions and vocabulary that can
    be very discouraging at first. In this chapter, we'll go through all the most
    important notions, so it can also serve as a quick cheat sheet or reminder.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Chef 是一个非常复杂的系统，有许多概念和术语，一开始可能会令人望而却步。在本章中，我们将介绍所有最重要的概念，因此它也可以作为一个快速查阅表或提醒。
- en: Running Chef
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行 Chef
- en: 'Chef can be used in multiple ways, the most important are the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Chef 可以以多种方式使用，最重要的方式如下：
- en: '**Client/server mode**: An agent runs on every managed client, regularly getting
    updates from the server, and applying them. In this mode, all Chef code is distributed
    from the Chef server.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端/服务器模式**：每个托管客户端上都运行一个代理，定期从服务器获取更新并应用它们。在此模式下，所有 Chef 代码都从 Chef 服务器分发。'
- en: 'Chef-Solo: In this mode, the need for a Chef server is removed at the cost
    of less features, including important ones such as search, API, persistent storage
    of nodes information, and more. All Chef code needs to be sent over in some way
    to be applied manually.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chef-Solo：在这种模式下，Chef 服务器的需求被去除，但代价是失去了一些功能，包括搜索、API、节点信息的持久存储等重要功能。所有 Chef
    代码需要以某种方式传输，并手动应用。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Other modes exist, such as Chef Zero, but they are beyond the scope of this
    book.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 还存在其他模式，例如 Chef Zero，但它们超出了本书的范围。
- en: The multi-platform client is written in Ruby, while its server counterpart is
    written in Erlang. The Chef server is open source (Apache License at the time
    of this writing) and everyone can host it, and the company behind Chef is also
    proposing their own hosted version, with added features and support.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 多平台客户端是用 Ruby 编写的，而其服务器端则是用 Erlang 编写的。Chef 服务器是开源的（在撰写本书时采用 Apache 许可证），任何人都可以自行托管，Chef
    背后的公司也提供了他们自己的托管版本，附加了更多功能和支持。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A Chef server is a combination of many technologies such as PostgreSQL, RabbitMQ,
    Redis, Nginx, and so on. Think about maintenance, backup, and performance before
    deploying your own.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Chef 服务器是多种技术的组合，如 PostgreSQL、RabbitMQ、Redis、Nginx 等。考虑到维护、备份和性能，部署自己的服务器时需要特别留意。
- en: Chef plugins
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Chef 插件
- en: Chef is also highly modular, with a great number of plugins available either
    directly from Chef, vendors, or the community. Plugins range from IaaS support
    such as AWS, OpenStack, VMware, or Digital Ocean to hardware management from Dell,
    HP, or IPMI interfaces, team workflow integration, or system-related concerns
    such as logs handling, security, and other similar features.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Chef 也具有高度的模块化，提供大量插件，这些插件要么来自 Chef 本身，要么来自供应商或社区。插件包括 IaaS 支持，如 AWS、OpenStack、VMware
    或 Digital Ocean，到硬件管理，如 Dell、HP 或 IPMI 接口，团队工作流集成，或与系统相关的事务，如日志处理、安全性以及其他类似功能。
- en: Chef organizations
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Chef 组织
- en: At the very top of a Chef hierarchy, we find an *organization*. Nothing can
    be shared between organizations and this is usually where is defined a *company*,
    different *business units*, or even deliberately isolated corporate *departments*.
    It's really up to everyone to know what has to be shared with whom to know what
    the Chef organization will be.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Chef 层次结构的最顶端，我们会找到一个*组织*。不同组织之间不能共享资源，通常这里会定义一个*公司*、不同的*业务单元*，甚至是故意隔离的企业*部门*。这实际上是每个人需要了解什么需要与谁共享，以便知道
    Chef 组织将是什么样子的。
- en: Chef nodes
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Chef 节点
- en: A node, in Chef terminology, is anything managed by Chef, be it physical or
    virtual, and every node has a number of characteristics or parameters that we'll
    set or change during the lifetime of the node.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Chef 的术语中，节点是指任何由 Chef 管理的东西，无论是物理的还是虚拟的，每个节点都有一些特征或参数，这些特征或参数将在节点的生命周期中被设置或更改。
- en: Chef environments
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Chef 环境
- en: Every node runs inside an environment. Environments are usually matching notions
    such as *development*, *staging*, or *production*, but it's not uncommon to see
    creative uses to manage different applications or other groups of interest. Environments
    also have a set of characteristics set.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点都运行在一个环境中。环境通常对应一些概念，如*开发*、*预生产*或*生产*，但也不乏创新用法来管理不同的应用程序或其他兴趣小组。环境还有一套已设置的特征。
- en: Chef roles
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Chef 角色
- en: Roles are usually functional and generic, more than centered around a product.
    For example, we'll see a *database* role way more often than a *MySQL* role. Other
    roles can be *monitoring-server* or *loadbalancer*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 角色通常是功能性和通用的，而不是围绕某个产品进行组织的。例如，我们会比看到*MySQL*角色更多看到*数据库*角色。其他角色可以是*监控服务器*或*负载均衡器*。
- en: Chef resources
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Chef 资源
- en: 'This is the single most important notion in Chef: a resource is any part of
    a system to be set in a desired state. This includes a package to be installed
    or removed, a service to be enabled or started, a file to be generated from a
    template, a user to be created or banned, and other expected elements of a system.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Chef 中最重要的概念：资源是任何需要被设置为目标状态的系统部分。这包括需要安装或移除的软件包、需要启用或启动的服务、从模板生成的文件、需要创建或禁用的用户以及系统中的其他预期元素。
- en: Chef recipes
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Chef 配方
- en: Recipes are simply plain Ruby files including a number of Chef resources describing
    a coherent desired state, such as a package to be installed, its configuration
    file written, and a service to be restarted.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 配方实际上就是普通的 Ruby 文件，其中包含一些 Chef 资源，这些资源描述了一个连贯的目标状态，比如需要安装的软件包、配置文件的编写和需要重启的服务。
- en: Chef cookbooks
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Chef 食谱
- en: Chef cookbooks are used to group many recipes under a coherent set, as well
    as every other file required to make it work. An example cookbook can be *mysql*,
    and two recipes from this cookbook can be *mysql::server* to manage the server,
    and *mysql::client* to manage a client.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Chef烹饪书用于将多个食谱组合成一个一致的集合，以及使其正常工作的所有其他文件。一个示例烹饪书可以是*mysql*，而这个烹饪书中的两个食谱可以是*mysql::server*来管理服务器，以及*mysql::client*来管理客户端。
- en: Chef run list
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Chef运行列表
- en: A *run list* is a list of roles or recipes that a node has to apply. This is
    sent by the Chef server by request from the chef client.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*运行列表*是节点必须应用的角色或食谱的列表。这是由Chef服务器根据chef客户端的请求发送的。'
- en: There's more…
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Puppet is a configuration tool published by Puppet Labs, and is an alternative
    to Chef.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet是由Puppet Labs发布的配置工具，是Chef的替代品。
- en: Puppet can also work in a standalone mode like Chef, but we will focus on a
    client/server architecture.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet也可以像Chef一样在独立模式下工作，但我们将重点介绍客户端/服务器架构。
- en: 'The Puppet infrastructure is mainly composed of:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet基础设施主要由以下部分组成：
- en: A Puppet server acting as a main configuration server, which contains all the
    configuration code
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个作为主配置服务器的Puppet服务器，包含所有的配置代码
- en: A Puppet agent running on all infrastructure nodes, applying configurations
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个运行在所有基础设施节点上的Puppet代理，应用配置
- en: Communication between agents and the server is done through HTTPS, and Puppet
    has its own PKI for the server certificate and for client certificates (client
    certificates are used to authenticate nodes to the server).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 代理与服务器之间的通信通过HTTPS进行，Puppet有自己的PKI用于服务器证书和客户端证书（客户端证书用于认证节点到服务器）。
- en: Puppet has its own **Domain Specific Language** (**DSL**). As for Chef, Puppet
    is using resources for installing packages, managing services, creating files,
    and more. A Puppet piece of code is called a **manifest**, and is a file with
    a `.pp` extension. The code is structured using modules. For example, we can imagine
    an `apache` module containing resources for Apache installation and service management.
    We can also have a `mysql` module for the MySQL server, with its own resources.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet拥有自己的**领域特定语言**（**DSL**）。至于Chef，Puppet使用资源来安装软件包、管理服务、创建文件等。Puppet中的一段代码叫做**清单**，它是一个`.pp`扩展名的文件。代码通过模块进行结构化。例如，我们可以想象一个`apache`模块，包含用于Apache安装和服务管理的资源。我们还可以有一个`mysql`模块，用于MySQL服务器，并包含它自己的资源。
- en: There is also a main manifest, outside any module, which is the list of nodes
    of the infrastructure. For each node, we can specify which module(s) to use to
    perform the complete node installation. When a node is requesting its configuration
    from the server, the server compiles a *catalog* of this node, and the Puppet
    agent applies this catalog.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个主清单，位于任何模块之外，它是基础设施节点的列表。对于每个节点，我们可以指定使用哪些模块来执行完整的节点安装。当一个节点从服务器请求其配置时，服务器会编译该节点的*目录*，然后Puppet代理应用这个目录。
- en: We can write our own modules or use existing modules from GitHub of Puppet Forge.
    Puppet Forge hosts a lot of community modules, and some of them are supported
    by Puppet Labs.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写自己的模块，或使用来自GitHub和Puppet Forge的现有模块。Puppet Forge托管了大量社区模块，其中一些由Puppet
    Labs支持。
- en: In this chapter, we will first write our own code in order to learn some basics
    of the Puppet DSL. We will then use a module from Puppet Forge.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先编写自己的代码，以学习一些Puppet DSL的基础知识。然后，我们将使用来自Puppet Forge的模块。
- en: Installing the Chef Development kit and Puppet Collections
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Chef开发工具包和Puppet集合
- en: The Chef ecosystem is as rich as Chef itself is complex; there's a myriad of
    tools filling almost every imaginable task we can think of. Chef being written
    in Ruby, a lot of those tools are also written in Ruby and over the years, the
    usual dependency hell between tools, plugins, code, and various Ruby versions
    led to a simple solution—the Chef DK. The Chef DK also brings a nice selection
    of the best tools and environments that work well together.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Chef生态系统的丰富程度与Chef本身的复杂性一样；有成千上万的工具，几乎填补了我们能想到的每一个任务。由于Chef是用Ruby编写的，所以很多这些工具也都是用Ruby编写的，多年来，工具、插件、代码和各种Ruby版本之间的依赖地狱导致了一个简单的解决方案——Chef
    DK。Chef DK还带来了一些很好的工具和环境，这些工具和环境能够很好地协同工作。
- en: We'll see how to install the Chef DK and quickly describe what it includes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何安装Chef DK，并快速描述它包含的内容。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The current Chef DK version is 1.1.16.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的Chef DK版本是1.1.16。
- en: Getting ready
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To work through this recipe, you will need the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个食谱，你将需要以下内容：
- en: An Internet connection
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个互联网连接
- en: A physical or virtual machine
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台物理机或虚拟机
- en: How to do it…
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The Chef DK can be downloaded from [https://downloads.chef.io/chef-dk/](https://downloads.chef.io/chef-dk/).
    There''re versions for most platforms: Debian, Red Hat-based systems, Ubuntu,
    and Windows. Simply download the package corresponding to your platform and install
    it. For example, using a recent Fedora, and installing the Red Hat package, the
    installation goes like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Chef DK 可以从 [https://downloads.chef.io/chef-dk/](https://downloads.chef.io/chef-dk/)
    下载。大多数平台都有对应的版本：Debian、基于 Red Hat 的系统、Ubuntu 和 Windows。只需下载与你的平台相对应的安装包并安装。例如，在使用最新版
    Fedora 系统，并安装 Red Hat 包时，安装过程如下：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Verify the installation worked as expected:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 验证安装是否按预期工作：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That's it! Everything we need to start coding Chef recipes is there.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们开始编写 Chef 配方所需的一切都已准备好。
- en: Chef DK contents
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Chef DK 内容
- en: 'The Chef DK includes a selection of the best tools, including the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Chef DK 包含了一些最好的工具，包括以下内容：
- en: '**Chef**: A workflow tool'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Chef**：一个工作流工具'
- en: '**Berkshelf**: A cookbook dependency manager that does a lot more than that'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Berkshelf**：一个做得比管理食谱依赖项更多的工具'
- en: '**Test Kitchen**: A full featured integration tests framework'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Test Kitchen**：一个功能齐全的集成测试框架'
- en: '**ChefSpec**: easy unit testing of Chef code'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ChefSpec**：用于 Chef 代码的简易单元测试'
- en: '**FoodCritic**: static code analysis for quality and consistency'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FoodCritic**：用于质量和一致性的静态代码分析'
- en: The Chef DK also includes all the standard Chef commands (`chef-solo` or `chef-client`
    to apply cookbooks on nodes, or `knife` to manipulate Chef resources on the developer's
    workstation, among other tools).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Chef DK 还包含所有标准的 Chef 命令（例如，使用 `chef-solo` 或 `chef-client` 在节点上应用食谱，或使用 `knife`
    操作开发者工作站上的 Chef 资源，以及其他工具）。
- en: How it works…
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The whole Chef environment, as well as its dependencies is deployed under `/opt/chefdk`.
    The package we installed created symlinks from this directory to `/usr/bin` which
    is on the `$PATH`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 整个 Chef 环境及其依赖项都部署在 `/opt/chefdk` 下。我们安装的包在该目录下创建了符号链接到 `/usr/bin`，该路径已在 `$PATH`
    中：
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This way of packaging software includes all its dependencies, and as Chef relies
    heavily on Ruby, the Chef DK ships with an embedded version that does not conflict
    with a Ruby version that might already be installed on your system:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这种软件打包方式包括了所有依赖项，由于 Chef 强烈依赖 Ruby，因此 Chef DK 内嵌了一个 Ruby 版本，这个版本与系统中可能已安装的 Ruby
    版本不会发生冲突：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There's more…
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: Starting from Puppet 4.x, Puppet Labs is providing repositories for both agent
    and server packages. These repositories are called **Puppet Collections**. As
    for Chef, provided packages are shipped with an Embedded Ruby version.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Puppet 4.x 开始，Puppet Labs 提供了用于代理和服务器软件包的仓库。这些仓库被称为 **Puppet Collections**。至于
    Chef，提供的包内嵌了 Ruby 版本。
- en: All examples from this book have been developed with Puppet 4.8 (open source
    edition). Packages can be downloaded from [https://docs.puppet.com/puppet/4.8/puppet_collections.html](https://docs.puppet.com/puppet/4.8/puppet_collections.html).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有示例都使用 Puppet 4.8（开源版本）开发。软件包可以从 [https://docs.puppet.com/puppet/4.8/puppet_collections.html](https://docs.puppet.com/puppet/4.8/puppet_collections.html)
    下载。
- en: First of all you need to install the `puppet-agent` package from *Puppet Collections*
    on your workstation. Even if we won't be managing it using Puppet, these packages
    will install some commands necessary for upcoming examples.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要在工作站上安装来自 *Puppet Collections* 的 `puppet-agent` 包。即使我们不会使用 Puppet 管理它，这些包也会安装一些在接下来的示例中需要的命令。
- en: 'Once the package is installed, all files are deployed under `/opt/puppetlabs`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了该包，所有文件都将部署在 `/opt/puppetlabs` 下：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For an easier use of the Embedded Ruby version, you need to add `/opt/puppetlabs/puppet/bin`
    to the `$PATH` environment variable. For example, on Linux systems, this can be
    done by appending the following line in the `.bashrc` file located in your home
    directory:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更方便地使用嵌入式 Ruby 版本，你需要将 `/opt/puppetlabs/puppet/bin` 添加到 `$PATH` 环境变量中。例如，在
    Linux 系统上，可以通过在家目录中的 `.bashrc` 文件中添加以下行来实现：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: See also
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'The Chef documentation on installing the Chef DK: [https://docs.chef.io/install_dk.html](https://docs.chef.io/install_dk.html)'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chef DK 安装文档：[https://docs.chef.io/install_dk.html](https://docs.chef.io/install_dk.html)
- en: 'The Chef documentation on the Chef DK: [https://docs.chef.io/release/devkit/](https://docs.chef.io/release/devkit/)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chef DK 的 Chef 文档：[https://docs.chef.io/release/devkit/](https://docs.chef.io/release/devkit/)
- en: Creating a free hosted server Chef account and a Puppet server
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个免费的托管服务器 Chef 账户和 Puppet 服务器
- en: In the preferred Chef client/server mode, we need a Chef server to centralize
    all the information and action. We can build our own, either for testing purposes
    or for production use (with the maintenance overhead that goes with it), or we
    can use *Hosted Chef*, the Chef server hosted by the company who wrote Chef. You'll
    learn here how to create a free Hosted Chef account, so we can start coding with
    Chef as soon as possible and not worry about the server part. After this first
    step, we'll download the Chef *Start Kit*, an archive containing a fully working
    Chef repository, with a sample role and cookbook we can use right away—and that's
    what we'll do by sending this sample cookbook to the server using our first `knife`
    command.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在首选的 Chef 客户端/服务器模式中，我们需要一个 Chef 服务器来集中管理所有信息和操作。我们可以自己搭建一个服务器，无论是用于测试还是生产（当然这会有维护开销），或者我们可以使用由
    Chef 开发公司托管的*Hosted Chef*服务器。这里你将学习如何创建一个免费的 Hosted Chef 账户，这样我们就可以尽快开始使用 Chef
    编程，而无需担心服务器部分。完成这第一步后，我们将下载 Chef *入门套件*，这是一个包含完整工作 Chef 仓库的压缩包，内含示例角色和食谱，我们可以直接使用——我们将通过发送这个示例食谱到服务器，使用第一个`knife`命令。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Remember: `knife` is the command to use from the developer''s workstation to
    manipulate information and resources on the Chef server. The `knife` command is
    never used on a Chef node.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：`knife`是开发人员从工作站使用的命令，用于操作 Chef 服务器上的信息和资源。`knife`命令从未在 Chef 节点上使用。
- en: Getting ready
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To work through this recipe, you will need the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个配方，你将需要以下内容：
- en: An Internet connection
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要一个互联网连接
- en: A working Chef DK installation on the workstation
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在工作站上安装一个可用的 Chef DK
- en: How to do it…
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these steps for Creating a free hosted server Chef account and a Puppet
    server:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请按照以下步骤创建免费的托管服务器 Chef 账户以及 Puppet 服务器：
- en: Go to [https://manage.chef.io/signup](https://manage.chef.io/signup).
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[https://manage.chef.io/signup](https://manage.chef.io/signup)。
- en: Fill in the details, use a valid e-mail address, and validate.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写相关信息，使用有效的电子邮件地址并进行验证。
- en: Click on the link in the e-mail to validate your account.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击电子邮件中的链接以验证你的账户。
- en: Create a password you remember.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个你能记住的密码。
- en: Create a new Chef organization.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Chef 组织。
- en: Download the *Starter Kit*.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载*入门套件*。
- en: 'Uncompress the Starter Kit somewhere safe:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将入门套件解压到一个安全的位置：
- en: '[PRE6]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Verify the connection to Hosted Chef using the `knife` command and request,
    for example, the list of the users (this will return you user):'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`knife`命令验证与 Hosted Chef 的连接，并请求，例如，列出所有用户（这将返回你的用户）：
- en: '[PRE7]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Upload the initial `starter` cookbook, still using the `knife` command:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上传初始的`starter`食谱，仍然使用`knife`命令：
- en: '[PRE8]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There's more…
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'There''s no hosted Puppet server offering. We need to deploy our own Puppet
    server. To simulate a small infrastructure, we will use Vagrant with Ubuntu boxes
    (for more information about Vagrant, please refer to [Chapter 1](ch01.html "Chapter 1. Vagrant
    Development Environments"), Vagrant Development Environment). Let''s start with
    a single node infrastructure, with only a Puppet server. Here is our Vagrantfile:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 没有提供托管的 Puppet 服务器服务。我们需要部署自己的 Puppet 服务器。为了模拟一个小型基础架构，我们将使用 Vagrant 和 Ubuntu
    虚拟机（有关 Vagrant 的更多信息，请参阅[第 1 章](ch01.html "第 1 章 Vagrant 开发环境")，Vagrant 开发环境）。我们从一个单节点基础架构开始，仅包含一个
    Puppet 服务器。以下是我们的 Vagrantfile：
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This Vagrant file relies on the `vagrant-hostmaster` plugin. If you don't already
    have it, you will need to install it manually using `vagrant plugin install vagrant-hostmanager`.
    This Vagrant plugin is used to create host entries in `/etc/hosts` in managed
    boxes and in your workstation. A shared folder will be used to edit code directly
    from your workstation.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Vagrant 文件依赖于`vagrant-hostmaster`插件。如果你还没有安装该插件，你需要手动使用`vagrant plugin install
    vagrant-hostmanager`来安装它。这个 Vagrant 插件用于在托管的虚拟机和工作站中的`/etc/hosts`文件中创建主机条目。将使用共享文件夹直接从工作站编辑代码。
- en: 'The `puppet_master.sh` provisioning script is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`puppet_master.sh`配置脚本如下：'
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this example, we are using a bundled Puppet server from the *Puppet Collections*
    repository provided by Puppet Labs. For simplicity and following recipes in this
    chapter, the auto-signing feature has been enabled. This means that when a Puppet
    node is contacting the server for the first time, a CSR is generated on the node
    and the Puppet server automatically signs it: subsequent requests will be authenticated
    and secured.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用的是来自 Puppet Labs 的*Puppet Collections*仓库中的捆绑 Puppet 服务器。为了简化操作并遵循本章中的配方，我们启用了自动签名功能。这意味着，当
    Puppet 节点第一次连接服务器时，节点会生成一个 CSR（证书签名请求），并且 Puppet 服务器会自动签署它：随后的请求将被认证和加密。
- en: 'Let''s create the shared folder and start Vagrant:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建共享文件夹并启动 Vagrant：
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We now have an Ubuntu Puppet server listening on `192.168.50.10`, with FQDN
    `puppet.pomes.pro`. A short name puppet is also available, and has been populated
    by the `vagrant-hostmanager` plugin.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个监听在 `192.168.50.10` 上的 Ubuntu Puppet 服务器，FQDN 为 `puppet.pomes.pro`。一个简短的名称
    puppet 也已可用，并由 `vagrant-hostmanager` 插件填充。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Depending on your `sudo` configuration, Vagrant may ask you for your password.
    This is requested by the `vagrant-hostmanager` plugin in order to create entries
    in the `/etc/hosts` file of your workstation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的`sudo`配置，Vagrant 可能会要求你输入密码。这是由 `vagrant-hostmanager` 插件请求的，用于在你的工作站的`/etc/hosts`文件中创建条目。
- en: Automatically bootstrapping a Chef client and a Puppet agent
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动引导 Chef 客户端和 Puppet 代理
- en: The first thing we want to do when working with Chef is to get the Chef client
    actually bootstrapped on the targeted remote server. For the Chef client to be
    able to apply Chef code, it first needs to be configured and registered on the
    Chef server. Thankfully, this can be very easily done.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始使用 Chef 时，首先要做的事情是确保 Chef 客户端已经在目标远程服务器上启动。为了让 Chef 客户端能够应用 Chef 代码，它首先需要在
    Chef 服务器上进行配置和注册。幸运的是，这个过程非常简单。
- en: Getting ready
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'To work through this recipe, you will need the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个食谱，你需要以下内容：
- en: A remote server, with a user with SSH access
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台有 SSH 访问权限的远程服务器和用户
- en: A working Chef DK installation on the workstation
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作站上需要有一个有效的 Chef DK 安装
- en: How to do it…
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Let''s say we already have a server running somewhere available with a user.
    The minimal command line we can build is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经有一个在某个地方运行的服务器，并且有一个可用的用户。我们可以构建的最小命令行如下：
- en: The IP or FQDN of the host we want to configure (`1.2.3.4`)
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要配置的主机的 IP 或 FQDN（`1.2.3.4`）
- en: The name under which to register the node on the Chef server (`my_node_hostname`)
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Chef 服务器上注册节点的名称（`my_node_hostname`）
- en: The username to use to connect to the server (`sudoer` if not root).
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于连接到服务器的用户名（如果不是 root，则使用 `sudoer`）。
- en: 'Navigate to the Chef repository on your workstation:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作站上导航到 Chef 仓库：
- en: '[PRE12]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now let''s remotely install the Chef client on the remote host from your workstation,
    using an example `vagrant` user:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从工作站上通过远程方式在远程主机上安装 Chef 客户端，以一个示例的`vagrant`用户为例：
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will first download the latest available Chef version and install it. Then
    it will execute an initial `chef-client` run to register the node on the Chef
    server under the specified name. Here it will stop.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这将首先下载最新版本的 Chef 并安装它。然后，它将执行一次初始的`chef-client`运行，将节点在指定的名称下注册到 Chef 服务器。到这里将停止。
- en: If we want to run a cookbook right after bootstrap (and we probably want to),
    just use the `-r` option to add cookbooks to the run list, so they are executed
    right away. Let's use the `starter` cookbook we uploaded earlier in this chapter,
    but feel free to use any other cookbook you may have already synchronized on the
    Chef server.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望在引导完成后立即运行一个 cookbook（我们大概会想这样做），只需使用 `-r` 选项将 cookbooks 添加到运行列表，这样它们会立即执行。我们可以使用本章之前上传的
    `starter` cookbook，但也可以使用任何其他你可能已经同步到 Chef 服务器上的 cookbook。
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There's more…
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'Using Puppet, we need to install the Puppet agent, once our node is created.
    Let''s add a new node into the Vagrantfile we previously used for the Puppet server:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Puppet，在创建节点后我们需要安装 Puppet 代理。让我们在之前用于 Puppet 服务器的 Vagrantfile 中添加一个新节点：
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, there is now another shell script `puppet_node.sh` used for
    the provisioning of this new node:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，现在有另一个 shell 脚本 `puppet_node.sh` 用于新节点的配置：
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We now also have an Ubuntu Puppet node with FQDN `web.pomes.pro` with IP `192.168.50.11`.
    By default, the Puppet agent is looking for a server named puppet—that's why this
    name has been defined as an alias to the puppet server.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在还拥有一个 Ubuntu Puppet 节点，其 FQDN 为 `web.pomes.pro`，IP 地址为 `192.168.50.11`。默认情况下，Puppet
    代理会寻找名为 puppet 的服务器——这就是为什么这个名称被定义为 Puppet 服务器的别名。
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Puppet agent has been explicitly stopped; during examples, we will start
    it on demand to see all changes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 代理已经被明确停止；在示例过程中，我们将根据需要启动它，以查看所有更改。
- en: Installing packages
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装软件包
- en: We need some packages for our server. Now our server is configured to use Chef
    and talk to a Chef server, let's install a few packages such as the Apache server,
    PHP, and MariaDB to build a classic LAMP server on a CentOS 7.2 server.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为服务器安装一些软件包。现在我们的服务器已经配置为使用 Chef 并与 Chef 服务器通信，接下来让我们安装一些软件包，如 Apache 服务器、PHP
    和 MariaDB，在 CentOS 7.2 服务器上搭建经典的 LAMP 服务器。
- en: Getting ready
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'To work through this recipe, you will need the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个食谱，你需要以下内容：
- en: A working Chef DK installation on the workstation
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作站上安装了可用的 Chef DK
- en: A working Chef client configuration on the remote host
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程主机上的工作 Chef 客户端配置
- en: How to do it…
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'To install a package on a Red Hat-based system, we''d use either `yum` (until
    CentOS 7) or `dnf` (for Fedora after version 22). As we''re using a CentOS 7 server,
    the Apache2 HTTP server package name is `httpd`, (it''s `apache2` on Debian-based
    systems). Manually, we would have typed the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要在基于 Red Hat 的系统上安装软件包，我们将使用`yum`（直到 CentOS 7）或`dnf`（Fedora 22 及其之后版本）。由于我们使用的是
    CentOS 7 服务器，Apache2 HTTP 服务器包的名称是`httpd`（在基于 Debian 的系统中是`apache2`）。手动安装时，我们会输入以下内容：
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let's see how this translates into a repeatable process with a Chef cookbook.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这如何转化为一个可重复的过程，使用 Chef 食谱。
- en: Generating an empty Apache cookbook
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成一个空的 Apache 食谱
- en: 'Let''s start by creating an empty cookbook from inside the Chef repository
    `cookbooks` folder to install Apache2 using the `chef` command:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 Chef 仓库的`cookbooks`文件夹中开始创建一个空的食谱，使用`chef`命令安装 Apache2：
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now we need to tell Chef to install a package using the `package` resource.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要告诉 Chef 使用`package`资源安装一个软件包。
- en: 'Open that `apache/recipes/default.rb` file and type in the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`apache/recipes/default.rb`文件并输入以下内容：
- en: '[PRE19]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'That''s the most basic way we can tell Chef to install a package. This will
    do the `install` action by default. To be a little bit more comprehensive, we
    can use the full block to do the same:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们告诉 Chef 安装软件包的最基本方法。默认情况下，这将执行`install`操作。为了更加全面一些，我们可以使用完整的代码块来做同样的事：
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Uploading the cookbook
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上传食谱
- en: 'Still from inside the Chef repository, we now need to upload this new `apache`
    cookbook to the Chef server, so our servers can access it. To do this, we use
    the `knife` command on our workstation:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在 Chef 仓库内，我们现在需要将这个新的`apache`食谱上传到 Chef 服务器，以便我们的服务器可以访问它。为此，我们在工作站上使用`knife`命令：
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We just uploaded our first cookbook on the Chef server!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚在 Chef 服务器上上传了我们的第一个食谱！
- en: 'Let''s confirm the cookbook is available remotely on the Chef server:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确认食谱已经在 Chef 服务器上远程可用：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Applying the cookbook
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用食谱
- en: 'Now we have the `apache` cookbook remotely available, let''s tell the Chef
    server that our particular node has to run it. Two options here are as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经远程获得了`apache`食谱，让我们告诉 Chef 服务器，特定的节点必须运行它。这里有两个选项：
- en: From the Chef server UI, select the host and click on **Edit** on the **Run
    List** box, then drag and drop the correct cookbook name on the **Current Run
    List** column:![Applying the cookbook](img/B05671_06_01.jpg)
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Chef 服务器 UI 中，选择主机并点击**编辑**按钮，在**运行列表**框中，然后将正确的食谱名称拖放到**当前运行列表**列中：![应用食谱](img/B05671_06_01.jpg)
- en: 'From the `knife` CLI on the workstation, run the following:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从工作站的`knife`命令行界面，运行以下命令：
- en: '[PRE23]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Either way, we just told the Chef server to apply the `apache` cookbook on
    this particular server. Let''s launch the Chef client on our remote node:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，我们刚刚告诉 Chef 服务器在这台特定的服务器上应用`apache`食谱。让我们在远程节点上启动 Chef 客户端：
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Chef just installed the Apache HTTP server package for us! If we launch the
    Chef client, it won''t install it again, as it knows it''s already there (look
    at the largely different execution times):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Chef 已经为我们安装了 Apache HTTP 服务器包！如果我们启动 Chef 客户端，它不会再次安装，因为它知道已经安装了（看看执行时间的巨大差异）：
- en: '[PRE25]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Verify if the package is really installed:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 验证软件包是否真的安装了：
- en: '[PRE26]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Creating a MariaDB cookbook
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 MariaDB 食谱
- en: 'Let''s use our knowledge to create a MariaDB cookbook the same way we just
    deployed Apache, from the Chef repository:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用我们的知识，像部署 Apache 一样从 Chef 仓库中创建一个 MariaDB 食谱：
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We want to install two packages: `mariadb` for the client and the libraries,
    and `mariadb-server` for the server. Add the following on the `mariadb/recipes/default.rb`
    file:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要安装两个包：`mariadb`用于客户端和库，`mariadb-server`用于服务器。在`mariadb/recipes/default.rb`文件中添加以下内容：
- en: '[PRE28]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Alternatively, as we''re writing plain Ruby, let''s rewrite it in a more idiomatic
    way:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，由于我们正在编写纯 Ruby 代码，让我们以更符合习惯的方式重写它：
- en: '[PRE29]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Upload the cookbook from your workstation:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 从工作站上传食谱：
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add the `mariadb` cookbook to the remote node''s run list from your workstation:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 从工作站将`mariadb`食谱添加到远程节点的运行列表中：
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run the Chef client on the remote host:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在远程主机上运行 Chef 客户端：
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Verify that the MariaDB package is correctly installed:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 验证 MariaDB 包是否正确安装：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Creating a PHP cookbook
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个 PHP 食谱
- en: 'Let''s reuse our knowledge to create a cookbook that will install the packages
    needed for PHP support:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们复用我们的知识，创建一个食谱来安装 PHP 支持所需的软件包：
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s add our Chef code that will install the following three packages: the
    `php`, `php-cli`, and `php-mysql` packages (respectively for PHP support, command
    line, and PHP/MySQL support) in the `cookbooks/php/recipes/default.rb` file:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加 Chef 代码，在 `cookbooks/php/recipes/default.rb` 文件中安装以下三个包：`php`、`php-cli`
    和 `php-mysql` 包（分别支持 PHP、命令行和 PHP/MySQL 支持）：
- en: '[PRE35]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Upload this new `php` cookbook from your workstation:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 从工作站上传这个新的 `php` cookbook：
- en: '[PRE36]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add the `php` cookbook to the remote node''s run list from your workstation:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 从工作站将 `php` cookbook 添加到远程节点的运行列表：
- en: '[PRE37]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Run the Chef client on the remote node:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在远程节点上运行 Chef 客户端：
- en: '[PRE38]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We now know the very basics of deploying cookbooks and installing packages on
    a remote node, using Chef!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经掌握了部署 cookbooks 和在远程节点上安装包的基本知识，使用 Chef！
- en: There's more…
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'Using Puppet, a package installation is done using the `package` resource directive.
    The following example shows how to install an Apache 2.x server on Ubuntu systems:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Puppet，通过 `package` 资源指令进行包的安装。以下示例展示了如何在 Ubuntu 系统上安装 Apache 2.x 服务器：
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To deploy a LAMP server on the box `web.pomes.pro`, we need Apache2, PHP, and
    the MariaDB server. In order to do a real example, perform the following steps:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 `web.pomes.pro` 服务器上部署 LAMP 服务器，我们需要 Apache2、PHP 和 MariaDB 服务器。为了做一个真实的示例，请执行以下步骤：
- en: Start Vagrant with the Vagrantfile from the previous recipe.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用上一节的 Vagrantfile 启动 Vagrant。
- en: 'Go into the `puppetcode` directory, which is the shared folder between your
    workstation and the Puppet server: `cd puppetcode`'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入 `puppetcode` 目录，这是工作站与 Puppet 服务器之间的共享文件夹：`cd puppetcode`
- en: 'We are about to create three modules (`apache`, `php`, and `mariadb`), so let''s
    create a minimalist module layout for them:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建三个模块（`apache`、`php` 和 `mariadb`），因此让我们为它们创建一个简洁的模块布局：
- en: '[PRE40]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create a `module/apache/manifests/init.pp` manifest file with the following
    content:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `module/apache/manifests/init.pp` 清单文件，内容如下：
- en: '[PRE41]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create a `module/php/manifests/init.pp` manifest file with the following content:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `module/php/manifests/init.pp` 清单文件，内容如下：
- en: '[PRE42]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create a `module/mariadb/manifests/init.pp` manifest file with the following
    content:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `module/mariadb/manifests/init.pp` 清单文件，内容如下：
- en: '[PRE43]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, create the main manifest `manifests/site.pp`, with the following content:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建主要的清单 `manifests/site.pp`，内容如下：
- en: '[PRE44]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'That''s it! With a few lines of code, all necessary binaries will be installed.
    We can now apply changes, using `puppet agent --test`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！只需几行代码，所有必要的二进制文件就会被安装。现在我们可以使用 `puppet agent --test` 应用更改：
- en: '[PRE45]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike what you might think, the `--test` option does apply changes. This option
    is used to test code immediately after a change and implies other options such
    as `--no-daemonize`, `--onetime`, and `--verbose`. If you need to do only a dry-run,
    you can use the `--noop` option combined with `–test`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 与你想象的不同，`--test` 选项确实会应用更改。此选项用于在更改后立即测试代码，并且包含其他选项，如 `--no-daemonize`、`--onetime`
    和 `--verbose`。如果你只需要进行干运行（dry-run），可以使用 `--noop` 选项并结合 `–test` 使用。
- en: See also
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'The Chef `package` resource documentation: [https://docs.chef.io/resource_package.html](https://docs.chef.io/resource_package.html)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Chef `package` 资源文档: [https://docs.chef.io/resource_package.html](https://docs.chef.io/resource_package.html)'
- en: 'The Puppet package resource documentation: [https://docs.puppet.com/puppet/4.8/types/package.html](https://docs.puppet.com/puppet/4.8/types/package.html)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Puppet 包资源文档: [https://docs.puppet.com/puppet/4.8/types/package.html](https://docs.puppet.com/puppet/4.8/types/package.html)'
- en: Managing services
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理服务
- en: We've seen how to install system packages using the `package` resource. In this
    section, you'll discover how to manage system services, using a resource named
    `service`. We'll continue to build the LAMP server we started in the previous
    section by managing the Apache HTTP and MariaDB services right from Chef. This
    way we'll be able to manage any available service.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用 `package` 资源安装系统包。在本节中，你将学习如何使用名为 `service` 的资源来管理系统服务。我们将继续在上一节中开始构建的
    LAMP 服务器，通过 Chef 来管理 Apache HTTP 和 MariaDB 服务。这样，我们就可以管理任何可用的服务。
- en: Getting ready
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To work through this recipe, you will need the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此食谱，你需要以下内容：
- en: A working Chef DK installation on the workstation
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在工作站上安装一个正常工作的 Chef DK
- en: A working Chef client configuration on the remote host
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在远程主机上安装并配置一个正常工作的 Chef 客户端
- en: The Chef code from the previous recipe
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上一节中的 Chef 代码
- en: How to do it…
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'The structure of the service resource is very similar to the `package` resource.
    We want to do two actions with our services: **enable** them at boot and **start**
    them right away. This translates into a simple Chef resource with an array of
    actions:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`service`资源的结构与`package`资源非常相似。我们希望对服务执行两个操作：**启用**它们在启动时运行，并**立即启动**它们。这转换为一个简单的Chef资源，包含一系列操作：'
- en: '[PRE46]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Enabling and starting Apache service
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用并启动Apache服务
- en: 'Add this `service` resource to the `apache/recipes/default.rb` file, just after
    the `package` resource:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 将此`service`资源添加到`apache/recipes/default.rb`文件中，紧接在`package`资源之后：
- en: '[PRE47]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Bump the cookbook version number on the `apache/metatada.rb` file:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在`apache/metadata.rb`文件中更新食谱版本号：
- en: '[PRE48]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This way, the Chef server will always keep version `0.1.0` with only the package
    installation, and a new version `0.2.0`, with the service support. We'll also
    be able to easily rollback to a previously running version.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，Chef服务器将始终保持版本`0.1.0`，只包含软件包安装，而新版本`0.2.0`则包括服务支持。我们还可以轻松回滚到先前运行的版本。
- en: Note
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When the Chef client runs, it always downloads and applies the latest version
    by default. It's advised to fix (or pin) versions where appropriate—especially
    in production.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当Chef客户端运行时，它默认总是下载并应用最新版本。建议在适当情况下固定（或锁定）版本——特别是在生产环境中。
- en: 'Upload the new cookbook version:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 上传新的食谱版本：
- en: '[PRE49]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now we have both versions of the cookbook available on the Chef server:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个版本的食谱都可用在Chef服务器上：
- en: '[PRE50]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Apply on the remote host:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在远程主机上应用：
- en: '[PRE51]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Verify the Apache service is indeed running:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 验证Apache服务是否确实在运行：
- en: '[PRE52]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You can also navigate to the site's IP address in HTTP to see the default page
    displayed.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过HTTP访问站点的IP地址，查看显示的默认页面。
- en: Enabling and starting the MariaDB service
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用并启动MariaDB服务
- en: 'Do exactly the same for MariaDB''s `mariadb` service in `mariadb/recipes/default.rb`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 对`mariadb/recipes/default.rb`中的MariaDB的`mariadb`服务执行完全相同的操作：
- en: '[PRE53]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Don''t forget to also bump the cookbook version in `mariadb/metadata.rb`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在`mariadb/metadata.rb`中也更新食谱版本：
- en: '[PRE54]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Send the updated cookbook to the Chef server:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 将更新后的食谱发送到Chef服务器：
- en: '[PRE55]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Apply the new cookbook:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 应用新的食谱：
- en: '[PRE56]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Confirm the MariaDB service is now running:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 确认MariaDB服务现在正在运行：
- en: '[PRE57]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Confirm we can access the MariaDB server from the node:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 确认我们可以从节点访问MariaDB服务器：
- en: '[PRE58]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We've just covered how to handle a system service using Chef, so you now know
    how to easily and repeatedly deploy packages and manage the corresponding service.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚介绍了如何使用Chef管理系统服务，现在你知道如何轻松且反复地部署软件包并管理相应的服务。
- en: There's more…
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Using Puppet, services are also managed with a dedicated resource directive.
    Using the previous example, we now need to ensure that the corresponding services
    are running.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Puppet时，服务也通过专门的资源指令进行管理。使用前面的示例，我们现在需要确保相应的服务正在运行。
- en: 'This resource needs to be added on both Apache and MariaDB modules. The new
    manifest for the Apache module is:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这个资源需要在Apache和MariaDB模块中都添加。Apache模块的新清单是：
- en: '[PRE59]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The new manifest for the MariaDB module is:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: MariaDB模块的新清单是：
- en: '[PRE60]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `ensure=>running` property is used to check the service is running (and
    will start it if needed), and `enable=>true` is used to start the service at boot.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`ensure=>running`属性用于检查服务是否正在运行（如果需要则启动它），而`enable=>true`用于在启动时启动服务。'
- en: Note
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The name of the service used in the service resource is the same as used in
    a root shell to stop/start/reload the service.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在`service`资源中使用的服务名称与在根Shell中停止/启动/重载服务时使用的名称相同。
- en: See also
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'The Chef `service` resource documentation: [https://docs.chef.io/resource_service.html](https://docs.chef.io/resource_service.html)'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chef `service`资源文档：[https://docs.chef.io/resource_service.html](https://docs.chef.io/resource_service.html)
- en: 'The Chef `metadata.rb` resource documentation: [https://docs.chef.io/config_rb_metadata.html](https://docs.chef.io/config_rb_metadata.html)'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chef `metadata.rb`资源文档：[https://docs.chef.io/config_rb_metadata.html](https://docs.chef.io/config_rb_metadata.html)
- en: 'The Puppet `service` resource documentation: [https://docs.puppet.com/puppet/4.8/types/service.html](https://docs.puppet.com/puppet/4.8/types/service.html)'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet `service`资源文档：[https://docs.puppet.com/puppet/4.8/types/service.html](https://docs.puppet.com/puppet/4.8/types/service.html)
- en: Managing files, directories, and templates
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理文件、目录和模板
- en: A very useful Chef feature is the ability to manage files right from the Chef
    code. Either plain files can be copied or dynamic files can be generated through
    templates. We'll leverage this feature to create an example PHP test file and
    dynamically generate Apache VirtualHosts for our LAMP server, so you'll know how
    to reuse it anywhere else.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Chef 的一个非常有用的功能是能够直接通过 Chef 代码管理文件。可以复制普通文件，或通过模板生成动态文件。我们将利用这个功能来创建一个示例 PHP
    测试文件，并动态生成 Apache 虚拟主机配置，用于我们的 LAMP 服务器，这样你就可以在其他地方复用它。
- en: Getting ready
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To work through this recipe, you will need the following:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此配方，你需要以下内容：
- en: A working Chef DK installation on the workstation
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作站上的有效 Chef DK 安装
- en: A working Chef client configuration on the remote host
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程主机上的工作 Chef 客户端配置
- en: Optionally, the Chef code from the previous recipes
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的，之前食谱中的 Chef 代码
- en: How to do it…
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We''ll manage two different kinds of files in two different ways: a static
    file and a dynamic file generated from a template, so the most common usage is
    covered.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以两种不同的方式管理两种不同的文件：一个静态文件和一个从模板生成的动态文件，以便涵盖最常见的用例。
- en: Managing a simple static file
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理一个简单的静态文件
- en: 'Let''s begin by creating a basic PHP file that will only display the `phpinfo()`
    result. This is done using the simple `file` resource with the file path as argument,
    giving its content inline. Other optional properties of the `file` resource include
    ownership information or the file mode. Add a `file` resource to the `php/recipes/default.rb`
    recipe:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建一个基本的 PHP 文件，它将仅显示 `phpinfo()` 结果。这是通过简单的 `file` 资源实现的，使用文件路径作为参数，内容直接写在其中。`file`
    资源的其他可选属性包括文件的所有者信息或文件权限。将一个 `file` 资源添加到 `php/recipes/default.rb` 配方中：
- en: '[PRE61]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Don''t forget to bump the version in `php/metadata.rb`:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了在 `php/metadata.rb` 中更新版本号：
- en: '[PRE62]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Upload the new cookbook from your workstation:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 从你的工作站上传新的食谱：
- en: '[PRE63]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Deploy using the Chef client on the remote node:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 使用远程节点上的 Chef 客户端进行部署：
- en: '[PRE64]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: If you now navigate to [http://node-hostname/phpinfo.php](http://node-hostname/phpinfo.php),
    you'll see the PHP information displayed.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在访问 [http://node-hostname/phpinfo.php](http://node-hostname/phpinfo.php)，你将看到
    PHP 信息被展示出来。
- en: This is the most static way of shipping a plain file.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这是发布普通文件的最静态方式。
- en: Managing dynamic files and directories from a template
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从模板中管理动态文件和目录
- en: Let's now create a generic Apache virtual host to fully control what we'll do
    with our LAMP server, and not just live with the default configuration shipped
    with our Linux distribution. We want the website's root folder to be `/var/www/<sitename>`
    and the configuration file will live under `/etc/httpd/conf.d/<sitename>.conf`.
    We'll ship a sample HTML index file as well, to validate we're running the correct
    virtual host.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个通用的 Apache 虚拟主机，以便全面控制 LAMP 服务器的配置，而不仅仅是使用我们 Linux 发行版自带的默认配置。我们希望网站的根文件夹是
    `/var/www/<sitename>`，配置文件将位于 `/etc/httpd/conf.d/<sitename>.conf`。我们还将发布一个示例 HTML
    索引文件，以验证我们是否正在运行正确的虚拟主机。
- en: 'Start by generating a new recipe in the Apache cookbook using the `chef` command,
    to manage a default Virtual Host:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用 `chef` 命令在 Apache 食谱中生成一个新食谱，以管理默认的虚拟主机：
- en: '[PRE65]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: A new file named `apache/recipes/virtualhost.rb` is now created.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建了一个名为 `apache/recipes/virtualhost.rb` 的新文件。
- en: 'To store the name of our virtual host, let''s create an `attribute`. An attribute
    is similar to a persisting node setting, declared in a cookbook in a file under
    the `attribute` directory, and can then be overridden by many mechanisms that
    we''ll later discover. Start by generating an attributes file using the `chef`
    command:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储我们的虚拟主机名称，我们来创建一个 `attribute`。属性类似于持久化的节点设置，它在一个食谱中声明，并存放在 `attribute` 目录下的文件中，之后可以通过许多机制进行覆盖，这些机制我们将稍后学习。首先，使用
    `chef` 命令生成一个属性文件：
- en: '[PRE66]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This will create a new file under `apache/attributes/default.rb`. To set the
    `sitename` attribute with default value of `defaultsite`, add the following in
    this file:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新文件，位于 `apache/attributes/default.rb`。要设置默认值为 `defaultsite` 的 `sitename`
    属性，请在此文件中添加以下内容：
- en: '[PRE67]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To create a new directory, let''s use a resource named `directory` in the `apache/recipes/virtualhost.rb`
    file, with standard access rights. Note the Ruby `#{node["sitename"]}` syntax
    to access a node attribute from inside a string that will be recurring from now
    on:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新目录，我们可以使用位于 `apache/recipes/virtualhost.rb` 文件中的名为 `directory` 的资源，并设置标准的访问权限。注意
    Ruby 语法 `#{node["sitename"]}`，它用于从字符串内访问节点属性，从现在开始将会频繁使用：
- en: '[PRE68]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Let''s reuse the `file` resource to create a basic `index.html` file with a
    simple string such as `Hello from Chef!` or whatever you find more appealing,
    in the `apache/recipes/virtualhost.rb` file:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新利用 `file` 资源，在 `apache/recipes/virtualhost.rb` 文件中创建一个基本的 `index.html`
    文件，文件内容可以是类似 `Hello from Chef!` 的简单字符串，或者是你认为更合适的内容：
- en: '[PRE69]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Let''s once again use the `chef` generator to create a new template for our
    Apache virtual host configuration file:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次使用 `chef` 生成器来创建一个新的模板，用于我们的 Apache 虚拟主机配置文件：
- en: '[PRE70]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This will create a template under `apache/templates/` named `virtuahost.erb`.
    This is a standard **ERB** (short for **Embedded Ruby**) template. This template
    file will contain the virtual host Apache configuration for our site.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个位于 `apache/templates/` 下名为 `virtuahost.erb` 的模板。这是一个标准的 **ERB**（**嵌入式
    Ruby**）模板。这个模板文件将包含我们站点的虚拟主机 Apache 配置。
- en: Let's start by populating the content of this ERB with a minimal Apache configuration
    file, using a new `website` variable that we'll set in a minute.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从用一个最小的 Apache 配置文件填充这个 ERB 文件开始，使用一个新的 `website` 变量，我们稍后会设置它。
- en: Note
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A variable in an ERB template is prefixed with the `@` character.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ERB 模板中，变量以 `@` 字符作为前缀。
- en: '[PRE71]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This way, the whole configuration is dynamic; we'll be able to instantiate this
    cookbook for any site name of our choice and it will be dedicated to it.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，整个配置是动态的；我们可以为任何我们选择的站点名称实例化这个食谱，并且它将专门为该站点服务。
- en: 'Now let''s use the `template` resource to generate a file from the template
    we just created, in the `apache/recipes/virtualhost.rb` file. This resource takes
    a `source` parameter, which is the template file we just created, and the variables
    to be injected. In our case, we want to inject the value of the `sitename` attribute,
    so it can be accessed by the template as `@website`:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用 `template` 资源，从我们刚刚创建的模板生成一个文件，位于 `apache/recipes/virtualhost.rb` 文件中。这个资源接受一个
    `source` 参数，即我们刚刚创建的模板文件，以及需要注入的变量。在我们的例子中，我们希望注入 `sitename` 属性的值，这样模板就可以通过 `@website`
    访问它：
- en: '[PRE72]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Don''t forget to bump the cookbook version in `apache/metadata.rb`:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了在 `apache/metadata.rb` 中更新食谱版本：
- en: '[PRE73]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Upload the cookbook to Chef server from the workstation:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 从工作站上传食谱到 Chef 服务器：
- en: '[PRE74]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Add the newly-created recipe to the remote node run list:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 将新创建的食谱添加到远程节点的运行列表中：
- en: '[PRE75]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Apply the new cookbook on the remote host:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在远程主机上应用新的食谱：
- en: '[PRE76]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Restart the Apache server manually to take the changes into account (be sure
    we''ll automate that in the next pages):'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 手动重启 Apache 服务器，以便让更改生效（放心，我们会在接下来的页面中自动化这个过程）：
- en: '[PRE77]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Verify that the served page is the one we added:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 验证所提供的页面是否是我们添加的那个：
- en: '[PRE78]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Good job! We've just covered how to manage files, directories, as well as dynamic
    templates, using pure Ruby code with Chef.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！我们刚刚讲解了如何使用 Chef 的纯 Ruby 代码管理文件、目录以及动态模板。
- en: There's more…
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容……
- en: 'Now that we have a LAMP server with Puppet, let''s create a virtual host! Our
    goals are as follows:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了一个配置了 Puppet 的 LAMP 服务器，让我们创建一个虚拟主机吧！我们的目标如下：
- en: Removing the default virtual host provided by Ubuntu
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除 Ubuntu 提供的默认虚拟主机
- en: Creating our own virtual host, with a specific `DocumentRoot` and dedicated
    log files
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们自己的虚拟主机，指定 `DocumentRoot` 和专用的日志文件
- en: Deploying a simple PHP page displaying the result of the function `phpinfo()`
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署一个简单的 PHP 页面，显示 `phpinfo()` 函数的结果。
- en: These three operations will be done using the `file` directive.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个操作将通过 `file` 指令完成。
- en: 'On Ubuntu, we need to remove the default website in order to have virtual hosting
    up and running. This can be done easily in the Apache manifest; a `file` directive
    for the deletion of `/etc/apache2/site-enabled/000-default.conf` will remove the
    symlink and will disable the site:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu 上，我们需要移除默认的网站，以便让虚拟主机正常运行。这可以在 Apache 清单中轻松完成；通过 `file` 指令删除 `/etc/apache2/site-enabled/000-default.conf`，这将移除符号链接并禁用该站点：
- en: '[PRE79]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now let''s create the code for the virtual host generation. The creation of
    a new virtual host must be done in `/etc/apache2/sites-available`, and will be
    generated from a template. Two languages are available:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为虚拟主机生成创建代码。新虚拟主机的创建必须在 `/etc/apache2/sites-available` 中进行，并将从模板生成。有两种语言可用：
- en: ERB for Embedded Ruby.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ERB 用于嵌入式 Ruby。
- en: EPP for Embedded Puppet (Puppet 4 and higher). Let's choose this one.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EPP 用于嵌入式 Puppet（Puppet 4 及以上版本）。让我们选择这个。
- en: 'Our EPP template will use two parameters: the site name and the document root.
    Let''s create a `vhost.epp` file in the `modules/apache/templates` directory:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 EPP 模板将使用两个参数：站点名称和文档根目录。让我们在 `modules/apache/templates` 目录中创建一个 `vhost.epp`
    文件：
- en: '[PRE80]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Now we need to instantiate this template. The best way is to think about something
    we could reuse as many times as needed (in case we would like to add more sites).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要实例化这个模板。最佳的做法是思考一些我们可以根据需要多次重用的东西（以防我们想要添加更多的站点）。
- en: We previously used a class statement, but each `class` in Puppet can be used
    only once per catalog (remember, a catalog is the result of the compilation for
    a node). Fortunately, the `define` statement is used to define a block of code
    that can be used multiple times.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用了一个`class`语句，但Puppet中的每个`class`在编译过程中每个清单中只能使用一次（记住，清单是节点编译的结果）。幸运的是，`define`语句用于定义一个可以多次使用的代码块。
- en: 'So let''s define a file, `module/apache/manifest/vhost.pp` that will use such
    a statement:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们定义一个文件，`module/apache/manifest/vhost.pp`，它将使用这样的语句：
- en: '[PRE81]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The website name and the document root are the two parameters for our `apache::vhost`
    statement and are passed to the `epp` function along with the template file name
    in the first `file` directive.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 网站名称和文档根目录是我们`apache::vhost`语句的两个参数，并作为第一个`file`指令中与模板文件名一起传递给`epp`函数。
- en: On Ubuntu, to enable a site, a link must be created in `/etc/apache2/site-enabled`;
    the second `file` directive will handle it.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu中，要启用一个站点，必须在`/etc/apache2/site-enabled`中创建一个链接；第二个`file`指令将处理这一操作。
- en: 'Finally, we need to deploy our PHP file under the `DocumentRoot` directory.
    This can be done directly in the main manifest using `file` directives to create
    the `DocumentRoot` directory and the file itself:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在`DocumentRoot`目录下部署我们的PHP文件。这可以直接在主清单中使用`file`指令来创建`DocumentRoot`目录和文件本身：
- en: '[PRE82]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We can now run the Puppet agent again. For now, we need to restart Apache manually
    in order to have our virtual host running (as for Chef, we''ll automate this in
    the next pages):'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以再次运行Puppet代理。暂时，我们需要手动重启Apache，以便我们的虚拟主机能够运行（至于Chef，我们将在接下来的页面中自动化这一过程）：
- en: '[PRE83]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Now you should see the phpinfo page on `http://web.pomes.pro`
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能在`http://web.pomes.pro`看到phpinfo页面。
- en: See also
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'The Chef documentation on attributes: [https://docs.chef.io/attributes.html](https://docs.chef.io/attributes.html)'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chef文档中的属性：[https://docs.chef.io/attributes.html](https://docs.chef.io/attributes.html)
- en: 'The Chef documentation on the directory resource: [https://docs.chef.io/resource_directory.html](https://docs.chef.io/resource_directory.html)'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chef文档中的目录资源：[https://docs.chef.io/resource_directory.html](https://docs.chef.io/resource_directory.html)
- en: 'The Chef documentation on the file resource: [https://docs.chef.io/resource_file.html](https://docs.chef.io/resource_file.html)'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chef文档中的文件资源：[https://docs.chef.io/resource_file.html](https://docs.chef.io/resource_file.html)
- en: 'The Chef documentation on the template resource: [https://docs.chef.io/resource_template.html](https://docs.chef.io/resource_template.html)'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chef文档中的模板资源：[https://docs.chef.io/resource_template.html](https://docs.chef.io/resource_template.html)
- en: 'The Puppet `file` resource documentation: [https://docs.puppet.com/puppet/4.8/types/file.html](https://docs.puppet.com/puppet/4.8/types/file.html)'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet `file`资源文档：[https://docs.puppet.com/puppet/4.8/types/file.html](https://docs.puppet.com/puppet/4.8/types/file.html)
- en: 'Using templates with Puppet: [https://docs.puppet.com/puppet/4.8/lang_template.html](https://docs.puppet.com/puppet/4.8/lang_template.html)'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Puppet模板：[https://docs.puppet.com/puppet/4.8/lang_template.html](https://docs.puppet.com/puppet/4.8/lang_template.html)
- en: Handling dependencies
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理依赖关系
- en: A very nifty feature of Chef is the ability to include recipes from one cookbook
    with another. This way, we can create cookbooks with a purpose, like a product
    or an end result. An example of such a cookbook could be an application cookbook
    named *MyCloudApp*, with calls to, or inclusions of, other cookbooks such as Apache,
    MySQL, or any other cookbook it might need.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: Chef的一个非常巧妙的功能是能够从一个食谱中包含另一个食谱。通过这种方式，我们可以创建具有特定目的的食谱，比如一个产品或一个最终结果。例如，这样的食谱可以是一个名为*MyCloudApp*的应用程序食谱，里面包含对其他食谱（如Apache、MySQL等）的调用或引用。
- en: Until now, we added recipe after recipe to the run list of our host. This is
    not optimal, and less than desirable when managing a lot of nodes. The idea here
    is to create a new cookbook dedicated to an imaginary MySite application, that
    will reference and depend on all the other recipes, so we can only load this MySite
    cookbook and be done with it.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一个接一个地将食谱添加到我们主机的运行列表中。这并不理想，特别是在管理大量节点时不太方便。这里的想法是创建一个新的食谱，专门用于一个假想的MySite应用程序，这个食谱会引用并依赖于所有其他食谱，这样我们只需要加载这个MySite食谱，就能完成所有操作。
- en: Getting ready
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To work through this recipe, you will need the following:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行这个教程，你需要以下内容：
- en: A working Chef DK installation on the workstation
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作站上安装了Chef DK
- en: A working Chef client configuration on the remote host
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程主机上有效的Chef客户端配置
- en: Optionally, the Chef code from the previous recipes
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地，来自前一个食谱的Chef代码
- en: How to do it…
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点……
- en: 'We know we want to create a new cookbook named `mysite` so we can centralize
    everything related to making this application work in the same place. Let''s use
    the `chef` command to do that:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们想创建一个新的食谱，命名为`mysite`，以便将与使这个应用程序运行相关的所有内容集中在同一个地方。让我们使用`chef`命令来实现这一点：
- en: '[PRE84]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'To include a recipe from another cookbook with our default recipe, we''ll use
    the `include_recipe` method in `mysite/recipes/default.rb`:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的默认食谱中包含来自另一个食谱的内容，我们将使用`include_recipe`方法，位于`mysite/recipes/default.rb`中：
- en: '[PRE85]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This is telling Chef to load and execute the content of each recipe.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Chef加载并执行每个食谱的内容。
- en: 'For Chef to know where this is to be found, we need to create a dependency
    to those cookbooks. This is done in the `mysite/metadata.rb` file:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Chef知道这个位置在哪里，我们需要创建对这些食谱的依赖关系。可以在`mysite/metadata.rb`文件中完成：
- en: '[PRE86]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now, our MySite cookbook has a nice dependency graph: to fully work, it needs
    Apache, MariaDB, and PHP. The recipe details what exactly to run.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的MySite食谱有了一个不错的依赖关系图：为了完全工作，它需要Apache、MariaDB和PHP。这个食谱详细列出了需要运行的内容。
- en: 'Since we have a dedicated cookbook for our app, let''s try to add some customization
    to it. Remember the default `sitename` attribute in the `apache` cookbook? Let''s
    override it to match our own value by adding the following at the top of the file,
    just before the apache recipes inclusion:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有一个专门为我们的应用程序制作的食谱，让我们尝试为其添加一些自定义。还记得`apache`食谱中的默认`sitename`属性吗？让我们通过在文件顶部（在apache食谱包含之前）添加以下内容来覆盖它，以匹配我们自己的值：
- en: '[PRE87]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Upload the cookbook to the Chef server:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 将食谱上传到Chef服务器：
- en: '[PRE88]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Remove previous recipes from our node''s run list using `knife node run_list
    remove <node name> <recipe name>`:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`knife node run_list remove <node name> <recipe name>`从节点的运行列表中移除之前的食谱：
- en: '[PRE89]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The node''s run list is now empty. Simply add the new `mysite` cookbook that
    includes everything it needs to run:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的运行列表现在为空。只需添加新的`mysite`食谱，它包含了运行所需的一切：
- en: '[PRE90]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The next Chef client run won't change anything, but it will be much easier to
    manage in the future!
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 下次Chef客户端运行时不会更改任何内容，但将来管理起来会更容易！
- en: There's more…
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'Using puppet, a module can be used in other modules. Based on previous examples,
    we could think about a `mysite` module, with the following manifest:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Puppet时，模块可以在其他模块中使用。根据之前的示例，我们可以考虑一个`mysite`模块，具有以下清单：
- en: '[PRE91]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The main manifest of our node would be as follows:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们节点的主要清单如下所示：
- en: '[PRE92]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: See also
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'The Chef documentation on attributes: [https://docs.chef.io/attributes.html](https://docs.chef.io/attributes.html)'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chef文档关于属性的说明：[https://docs.chef.io/attributes.html](https://docs.chef.io/attributes.html)
- en: 'The Chef cookbook `metadata.rb` documentation: [https://docs.chef.io/config_rb_metadata.html](https://docs.chef.io/config_rb_metadata.html)'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chef食谱`metadata.rb`文档：[https://docs.chef.io/config_rb_metadata.html](https://docs.chef.io/config_rb_metadata.html)
- en: More dynamic code using notifications
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用通知的更动态的代码
- en: Wouldn't it be great if Chef knew how and what to restart automatically when
    a change arises? In a previous example, we added a new virtual host to our node,
    and we had to manually restart Apache to take the change into account. Luckily,
    there's a mechanism named *notifications* in Chef, that helps trigger an action,
    when a resource changes. This way, changing a virtual host can trigger a restart
    of the Apache HTTP server automatically.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Chef知道在发生变化时如何以及需要重启什么，自动完成重启，这不是很好吗？在之前的示例中，我们向节点添加了一个新的虚拟主机，并且我们不得不手动重启Apache以使更改生效。幸运的是，Chef中有一个名为*notifications*的机制，当资源发生变化时，它可以帮助触发一个操作。通过这种方式，改变虚拟主机可以自动触发Apache
    HTTP服务器的重启。
- en: Getting ready
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To work through this recipe, you will need the following:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个食谱，你需要以下内容：
- en: A working Chef DK installation on the workstation
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作站上有效的Chef DK安装
- en: A working Chef client configuration on the remote host
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程主机上有效的Chef客户端配置
- en: The Chef code from the previous recipes
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自前一个食谱的Chef代码
- en: How to do it…
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点……
- en: 'We''ll start from the `apache` cookbook we''ve left in its 0.3.0 version. Bump
    it right now to `0.4.0` so we''re starting fresh in `apache/metadata.rb`:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`apache`食谱开始，继续使用其0.3.0版本。现在将其版本提升到`0.4.0`，以便在`apache/metadata.rb`中从头开始：
- en: '[PRE93]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Every resource can notify another resource to do something when its state changes,
    and any resource can also subscribe to a change of state from another resource.
    In our case, we''d like our `template` resource to notify the `httpd` system service
    to restart when the Virtual Host template changes, so we''re sure the change is
    automatically taken into account. The httpd service is coming from the default
    Apache recipe, so it’s better to include it right now in the `apache/recipes/virtualhost.rb`
    file, so we’re sure this particular recipe works alone and not by side-effect
    of a previous inclusion:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 每个资源都可以在其状态变化时通知另一个资源执行某些操作，任何资源也可以订阅另一个资源的状态变化。在我们的案例中，我们希望 `template` 资源在虚拟主机模板变化时通知
    `httpd` 系统服务重新启动，这样可以确保更改会自动生效。httpd 服务来自默认的 Apache 配方，因此最好现在就在 `apache/recipes/virtualhost.rb`
    文件中包含它，这样我们可以确保这个特定的配方独立工作，而不是通过之前的包含副作用产生效果：
- en: include_recipe 'apache::default'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: include_recipe 'apache::default'
- en: 'In the `apache/recipes/virtualhost.rb` file, add the following highlighted
    notification section:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `apache/recipes/virtualhost.rb` 文件中，添加以下突出显示的通知部分：
- en: '[PRE94]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Note
  id: totrans-432
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By default, actions are *delayed* at the end of the Chef run. If we need an
    action to take place immediately, at the risk of breaking the state of the system,
    we can add the `:immediately` timer at the end of the line.
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，操作会在 Chef 运行结束时*延迟*执行。如果我们希望操作立即发生，尽管有可能会破坏系统状态，我们可以在行末加上 `:immediately`
    定时器。
- en: 'To validate it''s working, we need to change something in our Virtual Host
    template in `apache/templates/virtualhost.erb`. For this example, I simply set
    the local IP the node is listening to, but feel free to adapt to your own case:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证其工作原理，我们需要更改 `apache/templates/virtualhost.erb` 中的某些内容。在这个示例中，我只是设置了节点正在监听的本地
    IP，但你可以根据自己的情况进行调整：
- en: '[PRE95]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Now upload the updated cookbook (we''ve already bumped it):'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在上传更新后的食谱（我们已经更新了它）：
- en: '[PRE96]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Run the Chef client on the node and see the magic happen:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在节点上运行 Chef 客户端，看看魔法是如何发生的：
- en: '[PRE97]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The cool thing is we can even see a diff of the change in the logs so we always
    know what's changed, as well as see the `httpd` service being reloaded after the
    change happened.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们甚至可以在日志中看到更改的差异，这样我们始终知道发生了什么更改，还可以看到 `httpd` 服务在更改发生后被重新加载。
- en: Our system is now perfectly dynamic and can reload its configuration at will
    at every change.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的系统现在完全动态化，并且可以在每次变化时随意重新加载其配置。
- en: There's more…
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Puppet has exactly the same feature, using the `notify` attribute. When the
    content of `/etc/apache2/sites-enabled` is modified, Apache configuration needs
    to be reloaded.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 具有完全相同的功能，使用 `notify` 属性。当 `/etc/apache2/sites-enabled` 的内容被修改时，Apache
    配置需要重新加载。
- en: Let's change our Apache manifest to do this.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改 Apache 清单来实现这一点。
- en: 'Apache configuration needs to be reloaded when the default vhost is removed,
    so we need to modify `modules/apache/manifests/init.pp` with the corresponding
    `notify` attribute:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 当删除默认虚拟主机时，需要重新加载 Apache 配置，因此我们需要在 `modules/apache/manifests/init.pp` 中修改相应的
    `notify` 属性：
- en: '[PRE98]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The same logic applies for the virtual host creation (`modules/apache/manifests/vhost.pp`):'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的逻辑适用于虚拟主机创建（`modules/apache/manifests/vhost.pp`）：
- en: '[PRE99]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Let''s try to run the Puppet agent on fresh Vagrant boxes, we will see that
    the two modifications will schedule a configuration reload, that will be done
    at the end of the Puppet Agent run. (refer to the lines with `Scheduling refresh
    of Service[apache2]` and `Triggered ''refresh'' from 2 events`):'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在全新的 Vagrant 虚拟机上运行 Puppet Agent，我们将看到这两项修改会安排重新加载配置，这将在 Puppet Agent 运行结束时执行。（参考包含
    `Scheduling refresh of Service[apache2]` 和 `Triggered 'refresh' from 2 events`
    的行）：
- en: '[PRE100]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Now we can access the phpinfo page at `http://web.pomes.pro` without manually
    restarting Apache.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以访问 `http://web.pomes.pro` 上的 phpinfo 页面，而无需手动重启 Apache。
- en: See also
  id: totrans-452
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'The Chef documentation for notifications: [https://docs.chef.io/resource_common.html#notifications](https://docs.chef.io/resource_common.html#notifications)'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chef 的通知文档：[https://docs.chef.io/resource_common.html#notifications](https://docs.chef.io/resource_common.html#notifications)
- en: 'The Chef documentation for subscribes: [https://docs.chef.io/resource_common.html#subscribes](https://docs.chef.io/resource_common.html#subscribes)'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chef 的订阅文档：[https://docs.chef.io/resource_common.html#subscribes](https://docs.chef.io/resource_common.html#subscribes)
- en: 'The Puppet notify resource documentation: [https://docs.puppet.com/puppet/4.8/types/notify.html](https://docs.puppet.com/puppet/4.8/types/notify.html)'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet 的通知资源文档：[https://docs.puppet.com/puppet/4.8/types/notify.html](https://docs.puppet.com/puppet/4.8/types/notify.html)
- en: Centrally sharing data using a Chef data bag and Hiera with Puppet
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Chef 数据包和 Puppet 的 Hiera 中央共享数据
- en: Now we have the basics of our LAMP infrastructure up and running, let's secure
    it a little by creating an `htaccess` file with a few authorized users in it.
    To achieve this, we could use different techniques, but the *data bag* feature
    in Chef is pretty convenient for our objective. A data bag is simply data in a
    JSON file stored on the Chef server, that can be searched from the cookbooks.
    It's especially useful for storing data that need to be accessed globally from
    a central point (such as users, service credentials, version numbers, URLs, even
    feature flags, and other similar features depending on your usage).
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经搭建好了 LAMP 基础设施，让我们通过创建一个 `htaccess` 文件并在其中添加一些授权用户来对其进行一定的安全加固。为了实现这个目标，我们可以使用不同的技术，但
    Chef 中的 *数据包* 功能对我们的目标非常方便。数据包就是存储在 Chef 服务器上的 JSON 文件中的数据，可以从食谱中进行搜索。它特别适合存储需要从中心点全局访问的数据（例如用户、服务凭据、版本号、URL，甚至功能标志和其他类似的功能，具体取决于你的使用场景）。
- en: Getting ready
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To work through this recipe, you will need the following:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个食谱，你需要以下内容：
- en: A working Chef DK installation on the workstation
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作站上的 Chef DK 安装
- en: A working Chef client configuration on the remote host
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程主机上的工作 Chef 客户端配置
- en: The Chef code from the previous recipes
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前面食谱中的 Chef 代码
- en: How to do it…
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Our objective is to create two users—John and Mary. Here''s a table of the
    required information:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是创建两个用户——John 和 Mary。以下是所需信息的表格：
- en: '| User | Password | Hash |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '| 用户 | 密码 | 哈希值 |'
- en: '| --- | --- | --- |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| John | `p4ssw0rd` | `$apr1$AUI2Y5pj$0v0PaSlLfc6QxZx1Vx5Se` |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '| John | `p4ssw0rd` | `$apr1$AUI2Y5pj$0v0PaSlLfc6QxZx1Vx5Se` |'
- en: '| Mary | `s3cur3` | `$apr1$eR7H0C5r$OrhOQUTXfUEIdvWyeGGGy/` |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '| Mary | `s3cur3` | `$apr1$eR7H0C5r$OrhOQUTXfUEIdvWyeGGGy/` |'
- en: Note
  id: totrans-469
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'To generate the encrypted passwords, you can use the simple `htpasswd` utility:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成加密的密码，你可以使用简单的 `htpasswd` 工具：
- en: '[PRE101]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'We want to store that piece of information (username and password), inside
    a single entity: this is the data bag. Let''s name it `webusers`, and we''ll store
    our users under this directory.'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想将这些信息（用户名和密码）存储在一个实体中：这就是数据包。我们将其命名为 `webusers`，并将用户信息存储在该目录下。
- en: 'Let''s create this directory inside our Chef repository for our revision control
    system (RCS, like git):'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 Chef 仓库中创建这个目录，以便于我们的版本控制系统（RCS，例如 git）：
- en: '[PRE102]'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'To create the data bag entry on the Chef server, use the following `knife`
    command:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在 Chef 服务器上创建数据包条目，请使用以下 `knife` 命令：
- en: '[PRE103]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'As we know, an entry is simple JSON structured data. Let''s write the content
    of our data bag for our user John, in `data_bags/webusers/john.json`:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们所知，条目是简单的 JSON 结构化数据。让我们将用户 John 的数据包内容写入 `data_bags/webusers/john.json`：
- en: '[PRE104]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Let's do the same for Mary in `data_bags/webusers/mary.json`
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也要在 `data_bags/webusers/mary.json` 中对 Mary 进行相同操作
- en: '[PRE105]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Now let''s send this data on the Chef server using the `knife` command:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们使用 `knife` 命令将这些数据发送到 Chef 服务器：
- en: '[PRE106]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Note
  id: totrans-483
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can see the current entries in the data bag using the knife command:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `knife` 命令查看数据包中的当前条目：
- en: '[PRE107]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Now the data is globally available from the Chef server, how do we access it
    dynamically from inside our code? This is where the `search` feature in Chef is
    useful to create dynamically generated content.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据在 Chef 服务器上全局可用，我们如何从代码内部动态访问它呢？这就是 Chef 中的 `search` 功能有用的地方，它可以帮助我们创建动态生成的内容。
- en: 'Before starting any work in the `mysite` cookbook, let''s bump the version
    in `mysite/metadata.rb` so we''re sure not to break anything:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始 `mysite` 食谱中的任何工作之前，让我们先在 `mysite/metadata.rb` 中更新版本号，确保不会破坏任何内容：
- en: '[PRE108]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Let''s create a new recipe named `htaccess.rb` under the `mysite` cookbook
    so we can create both the `htaccess` file under `/etc/httpd/htaccess` (this is
    an arbitrary location, adaptable to your needs) and the Apache configuration file
    under the web root:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `mysite` 食谱下创建一个新的食谱，命名为 `htaccess.rb`，以便我们可以创建 `/etc/httpd/htaccess` 下的
    `htaccess` 文件（这是一个任意位置，可以根据需要进行调整），并在 web 根目录下创建 Apache 配置文件：
- en: '[PRE109]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'To have our entries automatically populated in the `htaccess` file, we''ll
    have to iterate through all existing entries. This is done using the `search`
    in Chef, specifying the data bag, and the scope to search (in our case, everything).
    This is simply added in the `mysite/recipes/htaccess.rb` file:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使我们的条目自动填充到 `htaccess` 文件中，我们必须遍历所有现有条目。这是通过 Chef 中的 `search` 来完成的，指定数据包和搜索范围（在我们的情况下是所有内容）。这只是简单地添加到
    `mysite/recipes/htaccess.rb` 文件中：
- en: '[PRE110]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'This variable, `users`, will then be passed to the template file to generate
    the content, like we did previously—except this time we have multiple entries,
    not just one. We''re using the `htpasswd.erb` file as a source, that we''ll create
    in a moment:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个变量`users`将被传递到模板文件中，生成内容，就像我们之前做的那样——不过这次我们有多个条目，而不仅仅是一个。我们将使用`htpasswd.erb`文件作为源文件，稍后会创建它：
- en: '[PRE111]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Generate a new template for the `htpasswd` file, using the `chef` command:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`chef`命令生成一个新的`htpasswd`文件模板：
- en: '[PRE112]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Inside this ERB file in `mysite/templates/htpasswd.erb`, enter the following:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mysite/templates/htpasswd.erb`中的这个ERB文件中，输入以下内容：
- en: '[PRE113]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The `.each` method loops around the `users` variable that we passed through
    the template, iterates on `user`, and extracts our two values of interest: `id`
    and `htpasswd`.'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`.each`方法循环遍历我们通过模板传递的`users`变量，依次迭代`user`，并提取我们感兴趣的两个值：`id`和`htpasswd`。'
- en: 'While we''re at it, let''s create the template for the `.htaccess` file under
    our web root folder:'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此过程中，让我们为`.htaccess`文件创建模板，放在我们的网站根目录下：
- en: '[PRE114]'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Its content is the most basic we can find:'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它的内容是我们能找到的最基础的：
- en: '[PRE115]'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Note
  id: totrans-504
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There's currently no variable in this template. As I know, files most often
    end up being dynamic, I always prefer to start them as templates, even if content
    is currently static. It's very likely that in the near future we'll want to use
    a variable for `AuthUserFile`.
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目前这个模板中没有变量。因为我知道文件通常最终会变得动态，我总是倾向于将它们作为模板开始，即使当前内容是静态的。很有可能在不久的将来，我们会想为`AuthUserFile`使用变量。
- en: 'Back to our `mysite/recipes/htaccess.rb` recipe, let''s add the template we
    just created:'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到我们的`mysite/recipes/htaccess.rb`食谱，接下来我们添加刚刚创建的模板：
- en: '[PRE116]'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Don''t forget the last step: we have to call this new recipe from our main,
    `default.rb` recipe! In `mysite/recipes/default.rb`, include our new recipe, so
    it gets picked up by the client:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了最后一步：我们必须从主食谱`default.rb`中调用这个新食谱！在`mysite/recipes/default.rb`中包含我们的新食谱，这样客户端就会加载它：
- en: '[PRE117]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Just upload the new version of the cookbook:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 只需上传新版的食谱即可：
- en: '[PRE118]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: After you've run `chef-client` on your node, the site will be protected and
    users `mary` and `john` will be able to use basic HTTP authentication.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的节点上运行完`chef-client`后，网站将会被保护，用户`mary`和`john`将能够使用基本的HTTP认证。
- en: There's more…
  id: totrans-513
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: With Puppet, we can do it using Hiera. Hiera can be seen as datastore keeping
    site information out of manifests. Hiera can be customized in the way data is
    stored, but this will be out of the scope of this chapter; we will use default
    configuration.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Puppet时，我们可以通过Hiera来实现。Hiera可以看作是一个数据存储库，将站点信息保存在清单之外。Hiera可以定制数据的存储方式，但这超出了本章的范围；我们将使用默认配置。
- en: 'First of all, we need to define the data in Hiera. This will be done by creating
    `web.pomes.pro.yaml` in the Hiera tree:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在Hiera中定义数据。这将通过在Hiera树中创建`web.pomes.pro.yaml`来完成：
- en: '[PRE119]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: This file now contains an array of hashes for authorized users, for the node
    `web.pomes.pro`.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件现在包含了授权用户的哈希数组，适用于节点`web.pomes.pro`。
- en: 'From the main manifest, we need to look up our Hiera data using the following
    code:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 从主清单文件中，我们需要使用以下代码查找Hiera数据：
- en: '[PRE120]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Now it''s easy to generate the password file using a new `apache::htpasswd`
    `define` statement, that we need to create in `modules/apache/manifests/htpasswd.pp`:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很容易使用新的`apache::htpasswd` `define`语句生成密码文件，我们需要在`modules/apache/manifests/htpasswd.pp`中创建它：
- en: '[PRE121]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'For the corresponding template, this time, let''s try an ERB template in `modules/apache/templates/htpasswd.erb`:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的模板这次我们使用一个ERB模板，位于`modules/apache/templates/htpasswd.erb`：
- en: '[PRE122]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'From the main manifest, we can now create the password file:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 从主清单文件中，我们现在可以创建密码文件：
- en: '[PRE123]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'We also need to create a `.htaccess` file. Let''s create a new `apache::htaccess`
    statement in `modules/apache/manifests/htaccess.pp`:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要创建一个`.htaccess`文件。让我们在`modules/apache/manifests/htaccess.pp`中创建一个新的`apache::htaccess`语句：
- en: '[PRE124]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The associated template in `modules/apache/templates/htaccess.erb` is:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 关联的模板文件位于`modules/apache/templates/htaccess.erb`：
- en: '[PRE125]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'From the main manifest, we can now create the `.htaccess` file:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 从主清单文件中，我们现在可以创建`.htaccess`文件：
- en: '[PRE126]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'As a result, here is the main manifest of the `web.pomes.pro` node:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，以下是`web.pomes.pro`节点的主清单文件：
- en: '[PRE127]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: After running the Puppet agent, `http://web.pomes.pro` will now ask you for
    a login/password.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Puppet代理后，`http://web.pomes.pro`现在会要求你输入登录名和密码。
- en: See also
  id: totrans-535
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'The Chef documentation on data bags: [https://docs.chef.io/data_bags.html](https://docs.chef.io/data_bags.html)'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于数据包的Chef文档：[https://docs.chef.io/data_bags.html](https://docs.chef.io/data_bags.html)
- en: 'Puppet Hiera: [https://docs.puppet.com/hiera/3.2/](https://docs.puppet.com/hiera/3.2/)'
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet Hiera：[https://docs.puppet.com/hiera/3.2/](https://docs.puppet.com/hiera/3.2/)
- en: Creating functional roles
  id: totrans-538
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建功能性角色
- en: Until now, we have created cookbooks based on a particular technology. We created
    a cookbook for MariaDB, one for Apache HTTPd, and one for our app (including all
    the dependencies). What about the role of each of those infrastructure elements?
    A *database* role can include what is now running our database (MariaDB), but
    maybe tomorrow it can run something else (migrate back to MySQL, or switch to
    PostgreSQL). As roles in Chef have a dedicated run list, it's common to see a
    role include the product recipes, and everything related to it, think monitoring
    for example. Roles can do a lot more, like overriding attributes or have different
    run lists for each environment. Here, we'll create two generic *database* and
    *webserver* roles that might be simply reused later for another project that just
    need those services and a *mysite* role, that will include the two other roles.
    A role can include other roles as well as recipes. This way, the role for mysite
    will be enough to run our infrastructure, from a functional point of view.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经基于特定技术创建了食谱。我们为MariaDB创建了一个食谱，为Apache HTTPd创建了一个食谱，也为我们的应用程序（包括所有依赖项）创建了一个食谱。那么这些基础设施元素各自的角色是什么呢？一个*数据库*角色可以包括目前运行我们数据库的MariaDB，但也许明天它可以运行其他内容（迁移回MySQL，或切换到PostgreSQL）。由于Chef中的角色有专门的运行列表，通常可以看到一个角色包括产品食谱及与之相关的所有内容，比如监控。例如，角色可以做更多的事情，比如覆盖属性或为每个环境提供不同的运行列表。在这里，我们将创建两个通用的*数据库*和*webserver*角色，稍后可能会简单地在另一个仅需要这些服务的项目中复用它们，以及一个*mysite*角色，它将包括这两个角色。角色可以包括其他角色以及食谱。这样，从功能角度来看，mysite角色就足够运行我们的基础设施了。
- en: Getting ready
  id: totrans-540
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To work through this recipe, you will need the following:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此配方，您需要以下内容：
- en: A working Chef DK installation on the workstation
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作站上的Chef DK安装
- en: A working Chef client configuration on the remote host
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程主机上的Chef客户端配置
- en: The Chef code from the previous recipes
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前面食谱中的Chef代码
- en: How to do it…
  id: totrans-545
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'Follow these steps for creating functional roles:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 创建功能性角色的步骤：
- en: 'We can write roles in plain JSON or in Ruby. Let''s try Ruby for our `webserver`
    role in `roles/webserver.rb`. It requires a name, a description, and a run list.
    That''s the bare minimum:'
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用普通的JSON或Ruby来编写角色。让我们尝试在`roles/webserver.rb`中为`webserver`角色使用Ruby。它需要一个名称、描述和运行列表。这是最基本的要求：
- en: '[PRE128]'
  id: totrans-548
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Let''s do the same for our `database` role; we currently want to use our `mariadb`
    cookbook. So let''s write it in `roles/database.rb`:'
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的`database`角色做同样的事情；目前我们想使用我们的`mariadb`食谱。所以让我们把它写入`roles/database.rb`：
- en: '[PRE129]'
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Finally, let''s write the `mysite` role, that will include a webserver, a database,
    as well as its own cookbook, in `roles/mysite.rb`:'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们写下`mysite`角色，它将包括一个webserver、一个数据库以及它自己的食谱，写入`roles/mysite.rb`：
- en: '[PRE130]'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Send the roles to the Chef server using the `knife` command:'
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`knife`命令将角色发送到Chef服务器：
- en: '[PRE131]'
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Now, either edit your current node''s run list (if you have one) to use only
    this role (`role[mysite]`), or if you''re about to bootstrap the server; adding
    the `-r "role[mysite]"` option will bootstrap Chef on the node as well as execute
    Chef with this run list:'
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以编辑当前节点的运行列表（如果有的话），只使用这个角色（`role[mysite]`），或者如果您要为服务器引导系统，添加`-r "role[mysite]"`选项将引导Chef并执行带有此运行列表的Chef：
- en: '[PRE132]'
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: We'll now be free to add more complex features to our role in the future!
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以自由地为我们的角色添加更复杂的功能！
- en: There's more…
  id: totrans-558
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容……
- en: 'Puppet does not provide a role feature. However, this can be done by adding
    a level of abstraction using the *role and profile* design pattern. In this pattern:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet没有提供角色功能。不过，可以通过使用*角色和配置文件*设计模式来添加一层抽象。在此模式中：
- en: A *role* is a class defining a behavior (For example, a web server). This class
    needs to include all needed *profiles* to create the role.
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*角色*是定义行为的类（例如，web服务器）。这个类需要包括创建该角色所需的所有*配置文件*。'
- en: A *profile* is a class used to manage the underlying technology (For example,
    by installing Apache)
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*配置文件*是用于管理基础技术的类（例如，安装Apache）。'
- en: In the main manifest, nodes are only using *roles*.
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主清单中，节点只使用*角色*。
- en: Using this pattern, it is easier to refactor only *profiles* classes when the
    technology needs to be changed.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此模式，当技术需要更改时，只重构*配置文件*类就更容易了。
- en: See also
  id: totrans-564
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: 'The Chef documentation on roles: [https://docs.chef.io/roles.html](https://docs.chef.io/roles.html)'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chef关于角色的文档：[https://docs.chef.io/roles.html](https://docs.chef.io/roles.html)
- en: Managing external Chef cookbooks and Puppet modules
  id: totrans-566
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理外部Chef食谱和Puppet模块
- en: 'Up till now, we''ve written our own cookbooks, which are fairly simple in their
    current state. Chances are, we''ll expect a lot more complicated setups in our
    real life infrastructure. To help us, there''re two kinds of external cookbooks
    we can use: community-backed cookbooks and *official* cookbooks, written and maintained
    by the Chef team directly. To browse available cookbooks, navigate to the Chef
    Supermarket (think of it as a store for cookbooks): [https://supermarket.chef.io/](https://supermarket.chef.io/).'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经编写了自己的 cookbook，它们在当前状态下相当简单。实际上，我们可能会在真实的基础设施中遇到更复杂的配置。为了帮助我们，有两种外部
    cookbook 我们可以使用：社区支持的 cookbook 和由 Chef 团队直接编写和维护的 *官方* cookbook。要浏览可用的 cookbook，请访问
    Chef Supermarket（可以把它看作是一个 cookbook 商店）：[https://supermarket.chef.io/](https://supermarket.chef.io/)。
- en: The thing is, our life will become increasingly complicated with all those cookbooks
    downloaded here and there, each of them having dependencies of their own. Fortunately,
    the Chef DK ships with a superb utility for this use case—Berkshelf.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，随着我们下载的 cookbook 越来越多，它们每一个都有各自的依赖项，我们的生活会变得越来越复杂。幸运的是，Chef DK 配备了一个非常适合这个用例的工具——Berkshelf。
- en: Berkshelf allows us to declare cookbook dependencies, versions and locations
    in a single file, and in a single command, upload everything needed to run our
    cookbook.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: Berkshelf 允许我们在一个文件中声明 cookbook 的依赖项、版本和位置，并通过一条命令上传运行 cookbook 所需的所有内容。
- en: In this section, we'll migrate away from our distribution's MariaDB default
    and unconfigured package, to a fully configured MySQL 5.7—and that workflow is
    pretty close to everyday life using Chef in production.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将从发行版默认的、未配置的 MariaDB 包迁移到一个完全配置的 MySQL 5.7——这个工作流非常接近生产环境中使用 Chef 的日常生活。
- en: Getting ready
  id: totrans-571
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To work through this recipe, you will need the following:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个配方，你需要以下内容：
- en: A working Chef DK installation on the workstation
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在工作站上安装一个正常工作的 Chef DK
- en: A working Chef client configuration on the remote host
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程主机上配置好的 Chef 客户端
- en: The Chef code from the previous recipes
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之前配方中的 Chef 代码
- en: How to do it…
  id: totrans-576
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s start by discovering how Berkshelf works. Under the `cookbooks/mysite/`
    directory, we find a file named `Berksfile` (if you didn''t create the cookbook
    with the `chef` utility, create the file manually). As Berkshelf works per cookbook,
    we''ll declare all our cookbook dependencies to run this particular cookbook here,
    which in our case, happens to be currently all local. In this `Berksfile`, enter
    the following:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从了解 Berkshelf 的工作方式开始。在 `cookbooks/mysite/` 目录下，我们找到一个名为 `Berksfile` 的文件（如果你没有使用
    `chef` 工具创建 cookbook，请手动创建该文件）。由于 Berkshelf 是按 cookbook 工作的，我们将在此处声明所有要运行该特定 cookbook
    的依赖项，在我们的例子中，当前所有依赖项都是本地的。在这个 `Berksfile` 中，输入以下内容：
- en: '[PRE133]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'This tells us three important things:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们三件重要的事情：
- en: Where to find unknown cookbooks (on the official supermarket, we can replace
    with our own internal supermarket if we run one)
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何找到未知的 cookbooks（在官方的 supermarket 上，我们可以使用我们自己的内部 supermarket，如果我们运行一个的话）
- en: 'Where to find dependencies: in our cookbook''s metadata file'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到依赖项的位置：在我们 cookbook 的 metadata 文件中
- en: 'Where each of those cookbooks reside: in our case, the local relative path'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 cookbook 存放的位置：在我们的例子中，是本地相对路径
- en: 'Bump the `mysite` cookbook version in `metadata.rb` so we don''t mess with
    our previous work, and, from the `mysite` cookbook directory, upload all our cookbook''s
    dependencies at once:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `metadata.rb` 中更新 `mysite` cookbook 的版本，这样我们就不会干扰之前的工作，然后在 `mysite` cookbook
    目录下，一次性上传我们所有 cookbook 的依赖项：
- en: '[PRE134]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Now we start to realize how faster it is than manual uploading all the cookbooks
    one by one!
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始意识到，它比手动逐一上传所有 cookbook 要快得多！
- en: Using the official MySQL cookbook and its dependencies with Berkshelf
  id: totrans-586
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用官方的 MySQL cookbook 及其依赖项与 Berkshelf
- en: 'As we already know, we didn''t make any special configuration with MariaDB;
    we just installed it from our distribution''s repositories. This needs to change!
    We want a full-fledged MySQL deployment. Looking at the Chef Supermarket, we notice
    an official MySQL cookbook maintained by the Chef team, currently at version 8.0.4:
    [https://supermarket.chef.io/cookbooks/mysql](https://supermarket.chef.io/cookbooks/mysql).
    It seems to do wonders; there are many configuration options, and many other things.
    Pages and pages of tested, reliable code ready to use! Good.'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，我们没有对 MariaDB 做任何特殊配置；我们只是从发行版的仓库中安装了它。这个需要改变！我们想要一个完整的 MySQL 部署。在查看 Chef
    Supermarket 时，我们注意到有一个官方的 MySQL cookbook 由 Chef 团队维护，目前是版本 8.0.4：[https://supermarket.chef.io/cookbooks/mysql](https://supermarket.chef.io/cookbooks/mysql)。它看起来做得很好，有很多配置选项，还有很多其他的功能。页面和页面的经过测试的、可靠的代码可以直接使用！不错。
- en: 'By reading the README file, it is stated that it needs two other cookbooks
    as dependencies—`selinux` and `yum-mysql-community`. The first one to work around
    SELinux temporarily, and the second one to manage the official MySQL community
    repository for RHEL. We could solve those dependencies by hand, but we have a
    better idea: use the `Berksfile`!'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 README 文件的描述，必须使用两个其他 cookbook 作为依赖项——`selinux` 和 `yum-mysql-community`。第一个是为了临时绕过
    SELinux，第二个用于管理 RHEL 的官方 MySQL 社区仓库。我们可以手动解决这些依赖项，但我们有一个更好的主意：使用 `Berksfile`！
- en: 'Let''s start by replacing our dependency on our own `mariadb` cookbook with
    this cookbook, in `mysite/Berksfile`:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `mysite/Berksfile` 开始，将我们对自己 `mariadb` cookbook 的依赖替换为这个 cookbook：
- en: 'Find the following code:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 查找以下代码：
- en: '[PRE135]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Replace the previous code with the following:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换先前的代码：
- en: '[PRE136]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: This way, we ensure we'll ever only run this particular cookbook version (8.0.4)
    and not a new one that might break things in production.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以确保始终只运行这个特定版本的 cookbook（8.0.4），而不会运行可能在生产环境中导致问题的新版本。
- en: 'Then add the following two dependencies from the `mysql` cookbook:'
  id: totrans-595
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从 `mysql` cookbook 中添加以下两个依赖项：
- en: '[PRE137]'
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: In this case, we declared a dependency on any version of the `selinux` cookbook,
    the latest being the default, and a loose constraint on any minor revision of
    the `yum-mysql-community` 1.0 cookbook.
  id: totrans-597
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，我们声明了对任何版本的 `selinux` cookbook 的依赖，默认使用的是最新版本，并且对 `yum-mysql-community`
    1.0 cookbook 的任何次要修订进行了宽松的约束。
- en: 'In the cookbooks `mysite/metadata.rb` file, do the same and replace the `mariadb`
    dependency with the three new ones:'
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 cookbook 的 `mysite/metadata.rb` 文件中，做相同的操作，并将 `mariadb` 依赖项替换为三个新的依赖项：
- en: '[PRE138]'
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Run the `berks` command from inside the cookbook directory to grab the new
    cookbook dependencies:'
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 cookbook 目录中运行 `berks` 命令，获取新的 cookbook 依赖项：
- en: '[PRE139]'
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Great! It automatically downloaded our dependencies. Upload them all now:'
  id: totrans-602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 很好！它已自动下载我们的依赖项。现在上传它们：
- en: '[PRE140]'
  id: totrans-603
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Let''s now create a new recipe named `mysql` under our `mysite` cookbook, so
    we can deploy the MySQL we need for our application. In our case, we want the
    latest and greatest MySQL 5.7 with the admin password: `super_secure_password`.'
  id: totrans-604
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们在 `mysite` cookbook 下创建一个新的配方，命名为 `mysql`，以便为我们的应用部署所需的 MySQL。在我们的例子中，我们需要的是最新的
    MySQL 5.7，管理员密码为：`super_secure_password`。
- en: 'Start by bumping the cookbook''s version in `metadata.rb` to a minor version:'
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 `metadata.rb` 文件中将 cookbook 的版本提升到次要版本：
- en: '[PRE141]'
  id: totrans-606
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Now generate the new `mysql` recipe so we can use it:'
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在生成新的 `mysql` 配方，以便我们可以使用它：
- en: '[PRE142]'
  id: totrans-608
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'In the newly-created `mysite/recipes/mysql.rb` file, start by including the
    new recipes described as needed by the documentation:'
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建的 `mysite/recipes/mysql.rb` 文件中，首先包括文档中描述的所需新配方：
- en: '[PRE143]'
  id: totrans-610
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Then, still following the documentation, just add the following block to fully
    deploy MySQL 5.7 on the default port (TCP/`3306`):'
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按照文档说明，添加以下代码块，以便在默认端口（TCP/`3306`）上完全部署 MySQL 5.7：
- en: '[PRE144]'
  id: totrans-612
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Note
  id: totrans-613
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: What happened here is that the official `mysql` cookbook didn't make anything
    inside the cookbooks. It, in fact, extended Chef functionalities by offering a
    `mysql_service` resource. In Chefspeak, it is called **LWRP** (**Lightweight Resources
    and Providers**).
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里发生的情况是，官方的 `mysql` cookbook 并没有在 cookbook 中创建任何内容。事实上，它通过提供一个 `mysql_service`
    资源扩展了 Chef 的功能。在 Chef 的术语中，这称为 **LWRP**（**轻量级资源和提供者**）。
- en: 'Finally, remove the reference to the `mariadb` recipe from the default `mysite`
    recipe in `mysite/recipe/default.rb`, and replace it with a call to the new `mysql`
    recipe:'
  id: totrans-615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，删除默认 `mysite` 配方中对 `mariadb` 配方的引用，并将其替换为对新 `mysql` 配方的调用：
- en: '[PRE145]'
  id: totrans-616
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Including dependencies in a role
  id: totrans-617
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在角色中包含依赖项
- en: 'To fully match our environment with what we just did in the cookbook, let''s
    remove the call to the old `mariadb` cookbook from the `database` role, and as
    there''s no recipe to call (as we said, this cookbook is just extending Chef functionality),
    let''s instead add the two cookbook dependencies as stated in the documentation
    in `roles/database.rb`:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的环境与 cookbook 中所做的完全匹配，让我们从 `database` 角色中删除对旧的 `mariadb` cookbook 的调用，且由于没有配方可调用（如我们所说，这个
    cookbook 只是扩展了 Chef 功能），让我们改为添加文档中所述的两个 cookbook 依赖项，在 `roles/database.rb` 中进行更改：
- en: '[PRE146]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Upload the updated role using the `knife` command:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `knife` 命令上传更新后的角色：
- en: '[PRE147]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Our node running the `mysite` role, calling the database role will be alright.
    If we did choose to run only nodes with a call to the `mysite::default` recipe,
    it will also work.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行 `mysite` 角色的节点，调用数据库角色将没有问题。如果我们选择只运行包含 `mysite::default` 配方的节点，它也会正常工作。
- en: Uploading cookbook dependencies using Berkshelf
  id: totrans-623
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Berkshelf 上传 cookbook 依赖项
- en: 'Now navigate to the `mysite` cookbook directory and use the `upload` feature
    from Berkshelf, so it will upload all necessary cookbooks at once:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 现在导航到`mysite`食谱目录，并使用Berkshelf中的`upload`功能，这样它将一次性上传所有必要的食谱：
- en: '[PRE148]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Note
  id: totrans-626
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: With Berkshelf, dependencies of the dependencies are uploaded as well!
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Berkshelf时，依赖项的依赖项也会被上传！
- en: Testing MySQL deployment
  id: totrans-628
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试MySQL部署
- en: 'Run the chef-client on the node, and when the process is done, ensure we can
    connect to the local MySQL server using the supplied password:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 在节点上运行chef-client，完成后确保我们可以使用提供的密码连接到本地MySQL服务器：
- en: '[PRE149]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: There's more…
  id: totrans-631
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'With Puppet, there is also a lot of code ready to use. We can use modules from
    Puppet Forge or GitHub for example. Modules hosted on Puppet Forge can be searched
    using the `puppet module search` command:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Puppet时，也有很多现成的代码可以使用。我们可以使用Puppet Forge或GitHub上的模块。例如，可以使用`puppet module
    search`命令搜索Puppet Forge上的模块：
- en: '[PRE150]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'We can install one of them:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以安装其中之一：
- en: '[PRE151]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: By default, installation is done in a hidden folder under the home directory.
    We can see that the MySQL module from Puppet Labs depends on two other modules.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，安装会在主目录下的隐藏文件夹中进行。我们可以看到Puppet Labs的MySQL模块依赖于另外两个模块。
- en: Several tools can be used to manage packages; r10k is one of them. It can also
    manage environments (such as staging, development, production), but we will focus
    on package management in this chapter.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用多种工具来管理软件包，r10k就是其中之一。它还可以管理环境（如staging、development、production），但我们本章将重点讨论软件包管理。
- en: 'The first thing we need is to install r10k. In previous examples, we edited
    code directly on our workstation in a shared folder used by Vagrant, so we need
    to install r10k directly on our workstation:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是安装r10k。在之前的示例中，我们直接在Vagrant使用的共享文件夹中的工作站上编辑代码，因此我们需要直接在工作站上安装r10k：
- en: '[PRE152]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'r10k is using a file named `Puppetfile` in which we declare all necessary modules.
    Here is an example of `Puppetfile`:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: r10k使用一个名为`Puppetfile`的文件，在其中声明所有必要的模块。以下是`Puppetfile`的示例：
- en: '[PRE153]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Unfortunately at the time of writing, r10k does not support dependencies, so
    we need to discover and add them in the `Puppetfile`. We can discover dependencies
    manually by installing modules using `puppet module install` as we did earlier.
    However, this is not very handy, and fortunately we can use external tools such
    as [https://github.com/rnelson0/puppet-generate-puppetfile](https://github.com/rnelson0/puppet-generate-puppetfile).
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在写作时，r10k不支持依赖项，因此我们需要在`Puppetfile`中发现并添加它们。我们可以通过使用`puppet module install`手动安装模块来发现依赖项，就像我们之前所做的那样。不过，这不是很方便，幸运的是，我们可以使用外部工具，例如[https://github.com/rnelson0/puppet-generate-puppetfile](https://github.com/rnelson0/puppet-generate-puppetfile)。
- en: 'Let''s install it:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装它：
- en: '[PRE154]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'So now, let''s discover dependencies for the Puppet Labs MySQL module:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们发现Puppet Labs MySQL模块的依赖关系：
- en: '[PRE155]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: We now have all dependencies.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经拥有了所有的依赖关系。
- en: Now suppose we want to use our previous example, using the code we made for
    Apache, and the official Puppet Labs MySQL package.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要使用之前的示例，使用我们为Apache编写的代码和官方的Puppet Labs MySQL包。
- en: 'To do so, let''s adjust the `Puppetfile` in order to download the official
    Mysql module from Puppet Labs and keep our existing modules. We need to inform
    r10k which modules are *local*. If we don''t, r10k will perform a complete installation
    after removing all the content in the modules directory. Here is the `Puppetfile`:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，让我们调整`Puppetfile`，以便下载Puppet Labs的官方Mysql模块，并保留我们现有的模块。我们需要通知r10k哪些模块是*本地的*。如果不这样做，r10k将在删除模块目录中的所有内容后进行完整安装。以下是`Puppetfile`：
- en: '[PRE156]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Now we need to run r10k to install packages:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要运行r10k来安装软件包：
- en: '[PRE157]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Let''s modify the main manifest to use the official MySQL package; we need
    to remove the reference to our MariaDB module, and use the class provided by the
    official MySQL package:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改主清单以使用官方的MySQL包；我们需要删除对MariaDB模块的引用，并使用官方MySQL包提供的类：
- en: '[PRE158]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Let''s start a fresh Vagrant setup. After applying Puppet, we can now use the
    MySQL server with the root credentials we specified in the main manifest:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始一个全新的Vagrant设置。在应用Puppet之后，我们现在可以使用我们在主清单中指定的root凭证连接MySQL服务器：
- en: '[PRE159]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: If needed, you can browse the online documentation of this module to create
    custom databases and grants.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，你可以浏览该模块的在线文档来创建自定义数据库和权限。
- en: See also
  id: totrans-658
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'The Chef documentation on roles: [https://docs.chef.io/roles.html](https://docs.chef.io/roles.html)'
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chef关于角色的文档：[https://docs.chef.io/roles.html](https://docs.chef.io/roles.html)
- en: 'The Chef Supermarket: [https://supermarket.chef.io/](https://supermarket.chef.io/)'
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chef超市：[https://supermarket.chef.io/](https://supermarket.chef.io/)
- en: 'The Berkshelf documentation: [http://berkshelf.com/](http://berkshelf.com/)'
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Berkshelf 文档: [http://berkshelf.com/](http://berkshelf.com/)'
- en: 'MySQL cookbook source on GitHub: [https://github.com/chef-cookbooks/mysql](https://github.com/chef-cookbooks/mysql)'
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'MySQL 食谱源代码在 GitHub 上: [https://github.com/chef-cookbooks/mysql](https://github.com/chef-cookbooks/mysql)'
- en: 'Puppet r10k: [https://github.com/puppetlabs/r10k](https://github.com/puppetlabs/r10k)'
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Puppet r10k: [https://github.com/puppetlabs/r10k](https://github.com/puppetlabs/r10k)'
- en: 'The Puppet Labs MySQL module on Puppet Forge: [https://forge.puppet.com/puppetlabs/mysql](https://forge.puppet.com/puppetlabs/mysql)'
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Puppet Labs MySQL 模块在 Puppet Forge 上: [https://forge.puppet.com/puppetlabs/mysql](https://forge.puppet.com/puppetlabs/mysql)'
