- en: Chapter 4. Working with Files and Packages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章：处理文件和软件包
- en: '|   | *"A writer has the duty to be good, not lousy; true, not false; lively,
    not dull; accurate, not full of error."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"作家的职责是做好，不是做得差；真实，不是虚假；生动，不是乏味；准确，不是充满错误的。"* |   |'
- en: '|   | --*E.B. White* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*E.B. White* |'
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下方案：
- en: Making quick edits to config files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速编辑配置文件
- en: Editing INI style files with puppetlabs-inifile
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用puppetlabs-inifile编辑INI风格的文件
- en: Using Augeas to reliably edit config files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Augeas可靠地编辑配置文件
- en: Building config files using snippets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代码片段构建配置文件
- en: Using ERB templates
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ERB模板
- en: Using array iteration in templates
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模板中使用数组迭代
- en: Using EPP templates
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用EPP模板
- en: Using GnuPG to encrypt secrets
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GnuPG加密机密数据
- en: Installing packages from a third-party repository
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从第三方仓库安装软件包
- en: Comparing package versions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较软件包版本
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we'll see how to make small edits to files, how to make larger
    changes in a structured way using the **Augeas** tool, how to construct files
    from concatenated snippets, and how to generate files from templates. We'll also
    learn how to install packages from additional repositories, and how to manage
    those repositories. In addition, we'll see how to store and decrypt secret data
    with Puppet.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何对文件进行小范围编辑，如何使用**Augeas**工具以结构化的方式进行更大范围的更改，如何从拼接的代码片段构建文件，以及如何从模板生成文件。我们还将学习如何从附加的仓库安装软件包，并管理这些仓库。此外，我们将学习如何使用Puppet存储和解密机密数据。
- en: Making quick edits to config files
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速编辑配置文件
- en: When you need to have Puppet change a particular setting in a config file, it's
    common to simply deploy the whole file with Puppet. This isn't always possible,
    though; especially if it's a file that several different parts of your Puppet
    manifest may need to modify.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要让Puppet修改配置文件中的某个特定设置时，通常的做法是直接通过Puppet部署整个文件。然而，这并不总是可行，尤其是当这是一个Puppet清单的多个部分可能需要修改的文件时。
- en: What would be useful is a simple recipe to add a line to a config file if it's
    not already present, for example, adding a module name to `/etc/modules` to tell
    the kernel to load that module at boot. There are several ways to do this, the
    simplest is to use the `file_line` type provided by the `puppetlabs-stdlib` module.
    In this example, we install the `stdlib` module and use this type to append a
    line to a text file.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的做法是提供一个简单的方案，向配置文件中添加一行（如果该行尚不存在）。例如，向`/etc/modules`添加模块名称，以便在启动时让内核加载该模块。有几种方法可以做到这一点，最简单的是使用`puppetlabs-stdlib`模块提供的`file_line`类型。在这个例子中，我们安装了`stdlib`模块并使用该类型向文本文件追加一行。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Install the `puppetlabs-stdlib` module using puppet:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Puppet安装`puppetlabs-stdlib`模块：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This installs the module from the forge into my user's puppet directory; to
    install into the system directory, run the command as root or use `sudo`. For
    the purpose of this example, we'll continue working as our own user.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将模块从forge安装到我的用户Puppet目录；如果要安装到系统目录中，可以以root身份运行命令或使用`sudo`。为了方便本示例，我们将继续作为当前用户操作。
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Using the `file_line` resource type, we can ensure that a line exists or is
    absent in a config file. Using `file_line` we can quickly make edits to files
    without controlling the entire file.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`file_line`资源类型，我们可以确保某一行在配置文件中存在或不存在。使用`file_line`我们可以快速对文件进行编辑，而无需控制整个文件。
- en: 'Create a manifest named `oneline.pp` that will use `file_line` on a file in
    `/tmp`:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`oneline.pp`的清单文件，该文件将使用`file_line`对`/tmp`中的文件进行操作：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Run `puppet apply` on the `oneline.pp` manifest:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`oneline.pp`清单上运行`puppet apply`：
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now verify that `/tmp/cookbook` contains the line we defined:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在验证`/tmp/cookbook`是否包含我们定义的那一行：
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works…
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We installed the `puppetlabs-stdlib` module into the default module path for
    Puppet, so when we ran `puppet apply`, Puppet knew where to find the `file_line`
    type definition. Puppet then created the `/tmp/cookbook` file if it didn't exist.
    The line `Hello World!` was not found in the file, so Puppet added the line to
    the file.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`puppetlabs-stdlib`模块安装到了Puppet的默认模块路径中，因此当我们运行`puppet apply`时，Puppet知道去哪里找到`file_line`类型的定义。然后，Puppet会在`/tmp/cookbook`文件不存在时创建该文件。由于文件中没有找到`Hello
    World!`这一行，Puppet将这行添加到文件中。
- en: There's more…
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: We can define more instances of `file_line` and add more lines to the file;
    we can have multiple resources modifying a single file.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义更多的`file_line`实例，并向文件中添加更多行；我们可以让多个资源修改同一个文件。
- en: 'Modify the `oneline.pp` file and add another `file_line` resource:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`oneline.pp`文件并添加另一个`file_line`资源：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now apply the manifest again and verify whether the new line is appended to
    the file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次应用清单并验证新行是否已追加到文件中：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `file_line` type also supports pattern matching and line removal as we''ll
    show you in the following example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`file_line`类型也支持模式匹配和行删除，正如我们将在下面的示例中展示的：'
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Verify the contents of `/tmp/cookbook` before your Puppet run:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行Puppet之前，验证`/tmp/cookbook`的内容：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Apply the updated manifest:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 应用更新后的清单：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Verify that the line has been removed and the goodbye line has been replaced:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 验证该行已被删除，且“goodbye”行已被替换：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Editing files with `file_line` works well if the file is unstructured. Structured
    files may have similar lines in different sections that have different meanings.
    In the next section, we'll show you how to deal with one particular type of structured
    file, a file using **INI syntax**.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`file_line`编辑文件对于结构简单的文件效果很好。结构化文件可能在不同部分有相似的行，但其含义不同。在接下来的部分中，我们将向你展示如何处理一种特定类型的结构化文件——使用**INI语法**的文件。
- en: Editing INI style files with puppetlabs-inifile
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用puppetlabs-inifile编辑INI风格的文件
- en: INI files are used throughout many systems, Puppet uses INI syntax for the `puppet.conf`
    file. The `puppetlabs-inifile` module creates two types, `ini_setting` and `ini_subsetting`,
    which can be used to edit INI style files.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: INI文件在许多系统中都有使用，Puppet在`puppet.conf`文件中使用INI语法。`puppetlabs-inifile`模块创建了两种类型，`ini_setting`和`ini_subsetting`，它们可以用来编辑INI风格的文件。
- en: Getting ready
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Install the module from the forge as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式从Forge安装模块：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'In this example, we will create a `/tmp/server.conf` file and ensure that the
    `server_true` setting is set in that file:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个`/tmp/server.conf`文件，并确保该文件中设置了`server_true`：
- en: 'Create an `initest.pp` manifest with the following contents:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`initest.pp`清单，内容如下：
- en: '[PRE11]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Apply the manifest:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用清单：
- en: '[PRE12]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Verify the contents of the `/tmp/server.conf` file:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证`/tmp/server.conf`文件的内容：
- en: '[PRE13]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The `inifile` module defines two types, `ini_setting` and `ini_subsetting`.
    Our manifest defines an `ini_setting` resource that creates a server = true setting
    within the main section of the `ini` file. In our case, the file didn't exist,
    so Puppet created the file, then created the `main` section, and finally added
    the setting to the `main` section.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`inifile`模块定义了两种类型，`ini_setting`和`ini_subsetting`。我们的清单定义了一个`ini_setting`资源，它在`ini`文件的主部分中创建了一个`server
    = true`设置。在我们的例子中，文件不存在，所以Puppet创建了该文件，然后创建了`main`部分，最后将设置添加到`main`部分。'
- en: There's more...
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'Using `ini_subsetting`, you can have several resources added to a setting.
    For instance, our `server.conf` file has a server''s line, we could have each
    node append its own hostname to a server''s line. Add the following to the end
    of the `initest.pp` file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ini_subsetting`，你可以将多个资源添加到一个设置中。例如，我们的`server.conf`文件中有一行server，我们可以让每个节点将其主机名追加到这行server后面。将以下内容添加到`initest.pp`文件的末尾：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Apply the manifest:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 应用清单：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now temporarily change your hostname and rerun Puppet:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在临时更改你的主机名并重新运行Puppet：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Tip
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When working with INI syntax files, using the `inifile` module is an excellent
    choice.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理INI语法文件时，使用`inifile`模块是一个极好的选择。
- en: If your configuration files are not in INI syntax, another tool, Augeas, can
    be used. In the following section, we will use `augeas` to modify files.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的配置文件不是INI语法格式，可以使用另一个工具Augeas。在接下来的部分中，我们将使用`augeas`来修改文件。
- en: Using Augeas to reliably edit config files
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Augeas可靠地编辑配置文件
- en: Sometimes it seems like every application has its own subtly different config
    file format, and writing regular expressions to parse and modify all of them can
    be a tiresome business.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候似乎每个应用程序都有自己微妙不同的配置文件格式，而编写正则表达式来解析和修改这些文件可能是件乏味的事。
- en: Thankfully, Augeas is here to help. Augeas is a system that aims to simplify
    working with different config file formats by presenting them all as a simple
    tree of values. Puppet's Augeas support allows you to create `augeas` resources
    that can make the required config changes intelligently and automatically.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 幸好有Augeas来帮忙。Augeas是一个旨在简化不同配置文件格式处理的系统，它将所有文件呈现为一个简单的值树。Puppet对Augeas的支持允许你创建`augeas`资源，这些资源能够智能且自动地进行所需的配置更改。
- en: How to do it…
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these steps to create an example `augeas` resource:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个示例`augeas`资源：
- en: 'Modify your `base` module as follows:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式修改你的`base`模块：
- en: '[PRE17]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run Puppet:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Puppet：
- en: '[PRE18]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Check whether the setting has been correctly applied:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查设置是否已正确应用：
- en: '[PRE19]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'We declare an `augeas` resource named `enable-ip-forwarding`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个名为`enable-ip-forwarding`的`augeas`资源：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We specify that we want to make changes in the file `/etc/sysctl.conf`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定希望在文件`/etc/sysctl.conf`中进行更改：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next we specify the lens to use on this file. Augeas uses files called lenses
    to translate a configuration file into an object representation. Augeas ships
    with several lenses, they are located in `/usr/share/augeas/lenses` by default.
    When specifying the lens in an `augeas` resource, the name of the lens is capitalized
    and has the `.lns` suffix. In this case, we will specify the `Sysctl` lens as
    follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们指定要在该文件上使用的镜头。Augeas 使用名为“镜头”的文件，将配置文件转换为对象表示。Augeas 默认附带多个镜头，位于`/usr/share/augeas/lenses`目录。指定`augeas`资源中的镜头时，镜头名称会被大写并带有`.lns`后缀。在本例中，我们将指定`Sysctl`镜头，具体如下：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `changes` parameter specifies the changes we want to make. Its value is
    an array, because we can supply several changes at once. In this example, there
    is only change, so the value is an array of one element:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`changes`参数指定我们希望进行的更改。它的值是一个数组，因为我们可以一次提供多个更改。在这个示例中，只有一个更改，因此其值是一个包含一个元素的数组：'
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In general, Augeas changes take the following form:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，Augeas的更改形式如下：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this case, the setting will be translated into a line like this in `/etc/sysctl.conf`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，设置将在`/etc/sysctl.conf`中被翻译为如下所示的一行：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There's more…
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: I've chosen `/etc/sysctl.conf` as the example because it can contain a wide
    variety of kernel settings and you may want to change these settings for all sorts
    of different purposes and in different Puppet classes. You might want to enable
    IP forwarding, as in the example, for a router class but you might also want to
    tune the value of `net.core.somaxconn` for a load-balancer class.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择`/etc/sysctl.conf`作为示例，因为它可以包含多种内核设置，你可能希望出于各种不同的目的以及在不同的Puppet类中更改这些设置。比如在示例中，你可能希望为路由器类启用IP转发，但你也可能希望为负载均衡器类调整`net.core.somaxconn`的值。
- en: This means that simply puppetizing the `/etc/sysctl.conf` file and distributing
    it as a text file won't work because you might have several different and conflicting
    versions depending on the setting you want to modify. Augeas is the right solution
    here because you can define `augeas` resources in different places, which modify
    the same file and they won't conflict.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着仅仅将`/etc/sysctl.conf`文件以文本文件形式传递并分发是行不通的，因为根据你要修改的设置，可能会有多个不同且冲突的版本。在这里，Augeas是一个正确的解决方案，因为你可以在不同的位置定义`augeas`资源，这些资源会修改同一个文件，且它们不会发生冲突。
- en: For more information about using Puppet and Augeas, see the page on the Puppet
    Labs website [http://projects.puppetlabs.com/projects/1/wiki/Puppet_Augeas](http://projects.puppetlabs.com/projects/1/wiki/Puppet_Augeas).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何使用Puppet和Augeas的更多信息，请参阅Puppet Labs网站上的页面[http://projects.puppetlabs.com/projects/1/wiki/Puppet_Augeas](http://projects.puppetlabs.com/projects/1/wiki/Puppet_Augeas)。
- en: Another project that uses Augeas is **Augeasproviders**. Augeasproviders uses
    Augeas to define several types. One of these types is `sysctl`, using this type
    you can make sysctl changes without knowing how to write the changes in Augeas.
    More information is available on the forge at [https://forge.puppetlabs.com/domcleal/augeasproviders](https://forge.puppetlabs.com/domcleal/augeasproviders).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使用Augeas的项目是**Augeasproviders**。Augeasproviders使用Augeas定义了几种类型。其一是`sysctl`类型，使用此类型可以在不需要了解如何在Augeas中编写更改的情况下进行sysctl更改。有关更多信息，请访问[https://forge.puppetlabs.com/domcleal/augeasproviders](https://forge.puppetlabs.com/domcleal/augeasproviders)。
- en: Learning how to use Augeas can be a little confusing at first. Augeas provides
    a command line tool, `augtool`, which can be used to get acquainted with making
    changes in Augeas.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始学习如何使用Augeas可能有点令人困惑。Augeas 提供了一个命令行工具`augtool`，可以用来熟悉在Augeas中进行更改。
- en: Building config files using snippets
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用片段构建配置文件
- en: Sometimes you can't deploy a whole config file in one piece, yet making line
    by line edits isn't enough. Often, you need to build a config file from various
    bits of configuration managed by different classes. You may run into a situation
    where local information needs to be imported into the file as well. In this example,
    we'll build a config file using a local file as well as snippets defined in our
    manifests.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你不能将整个配置文件一次性部署，而逐行编辑又不够。通常，你需要从由不同类管理的各种配置片段中构建配置文件。你可能还会遇到需要将本地信息导入到文件中的情况。在这个示例中，我们将使用本地文件以及我们在清单中定义的片段来构建配置文件。
- en: Getting ready
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Although it's possible to create our own system to build files from pieces,
    we'll use the puppetlabs supported `concat` module. We will start by installing
    the `concat` module, in a previous example we installed the module to our local
    machine. In this example, we'll modify the Puppet server configuration and download
    the module to the Puppet server.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以创建自己的系统从各个部分构建文件，但我们将使用 Puppetlabs 支持的 `concat` 模块。我们将从安装 `concat` 模块开始，在之前的示例中我们将模块安装到了本地机器中。在这个示例中，我们将修改
    Puppet 服务器配置，并将模块下载到 Puppet 服务器。
- en: 'In your Git repository create an `environment.conf` file with the following
    contents:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 Git 仓库中创建一个 `environment.conf` 文件，内容如下：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create the public directory and download the module into that directory as
    follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 创建公共目录并将模块下载到该目录，方法如下：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now add the new modules to our Git repository:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将新模块添加到我们的 Git 仓库中：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then push to our Git server:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后推送到我们的 Git 服务器：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Now that we have the `concat` module available on our server, we can create
    a `concat` container resource in our `base` module:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在服务器上可用 `concat` 模块，我们可以在 `base` 模块中创建一个 `concat` 容器资源：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a `concat::fragment` module for the header of the new file:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为新文件的头部创建一个`concat::fragment`模块：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create a `concat::fragment` that includes a local file:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含本地文件的`concat::fragment`：
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create a `concat::fragment` module that will go at the end of the file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个将在文件末尾的 `concat::fragment` 模块：
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'On the node, create `/etc/hosts.allow.local` with the following contents:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在节点上，创建 `/etc/hosts.allow.local`，内容如下：
- en: '[PRE34]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Run Puppet to have the file created:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Puppet 以创建文件：
- en: '[PRE35]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Verify the contents of the new file as:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 验证新文件的内容如下：
- en: '[PRE36]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The `concat` resource defines a container that will hold all the subsequent
    `concat::fragment` resources. Each `concat::fragment` resource references the
    `concat` resource as the target. Each `concat::fragment` also includes an `order`
    attribute. The `order` attribute is used to specify the order in which the fragments
    are added to the final file. Our `/etc/hosts.allow` file is built with the header
    line, the contents of the local file, and finally the `in.tftpd` line we defined.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`concat` 资源定义了一个容器，将包含所有随后的 `concat::fragment` 资源。每个 `concat::fragment` 资源都将
    `concat` 资源作为目标。每个 `concat::fragment` 还包括一个 `order` 属性。`order` 属性用于指定将片段添加到最终文件的顺序。我们的
    `/etc/hosts.allow` 文件由头行、本地文件的内容以及我们定义的 `in.tftpd` 行组成。'
- en: Using ERB templates
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ERB 模板
- en: While you can deploy config files easily with Puppet as simple text files, templates
    are much more powerful. A template file can do calculations, execute Ruby code,
    or reference the values of variables from your Puppet manifests. Anywhere you
    might deploy a text file using Puppet, you can use a template instead.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以像简单的文本文件一样使用 Puppet 部署配置文件，但模板更为强大。模板文件可以进行计算、执行 Ruby 代码，或引用 Puppet 清单中的变量值。你可以在任何使用
    Puppet 部署文本文件的地方，使用模板代替。
- en: 'In the simplest case, a template can just be a static text file. More usefully,
    you can insert variables into it using the ERB (embedded Ruby) syntax. For example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，模板可以只是一个静态文本文件。更有用的是，你可以使用 ERB（嵌入式 Ruby）语法将变量插入其中。例如：
- en: '[PRE37]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If the template is used in a context where the variable `$name` contains `Zaphod
    Beeblebrox`, the template will evaluate to:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模板在一个变量 `$name` 包含 `Zaphod Beeblebrox` 的上下文中使用，那么模板将评估为：
- en: '[PRE38]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This simple technique is very useful to generate lots of files that only differ
    in the values of one or two variables, for example, virtual hosts, and for inserting
    values into a script such as database names and passwords.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的技术对于生成大量仅在一个或两个变量值上有所不同的文件非常有用，例如虚拟主机，并且可以将值插入到脚本中，比如数据库名称和密码。
- en: How to do it…
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'In this example, we''ll use an ERB template to insert a password into a backup
    script:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用一个 ERB 模板将密码插入到备份脚本中：
- en: 'Create the file `modules/admin/templates/backup-mysql.sh.erb` with the following
    contents:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文件 `modules/admin/templates/backup-mysql.sh.erb`，内容如下：
- en: '[PRE39]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Modify your `site.pp` file as follows:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照如下方式修改你的 `site.pp` 文件：
- en: '[PRE40]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Run Puppet:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Puppet：
- en: '[PRE41]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Check whether Puppet has correctly inserted the password into the template:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 Puppet 是否正确地将密码插入模板：
- en: '[PRE42]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How it works…
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Wherever a variable is referenced in the template, for example `<%= @mysql_password
    %>`, Puppet will replace it with the corresponding value, `secret`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中引用的每个变量，例如 `<%= @mysql_password %>`，Puppet 将用相应的值 `secret` 替换它。
- en: There's more…
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'In the example, we only used one variable in the template, but you can have
    as many as you like. These can also be facts:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们只使用了一个变量，但你可以根据需要使用多个变量。它们也可以是事实：
- en: '[PRE43]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Or Ruby expressions:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 或者是 Ruby 表达式：
- en: '[PRE44]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Or any Ruby code you want:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 或者是你想要的任何 Ruby 代码：
- en: '[PRE45]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: See also
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Using GnuPG to encrypt secrets* recipe in this chapter
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *使用 GnuPG 加密机密信息* 配方
- en: '[https://docs.puppetlabs.com/guides/templating.html](https://docs.puppetlabs.com/guides/templating.html)'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.puppetlabs.com/guides/templating.html](https://docs.puppetlabs.com/guides/templating.html)'
- en: Using array iteration in templates
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在模板中使用数组迭代
- en: In the previous example, we saw that you can use Ruby to interpolate different
    values in templates depending on the result of an expression. But you're not limited
    to getting one value at a time. You can put lots of them in a Puppet array and
    then have the template generate some content for each element of the array using
    a loop.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们看到你可以使用 Ruby 根据表达式的结果在模板中插入不同的值。但是，你并不局限于一次插入一个值。你可以将多个值放入 Puppet
    数组中，然后通过循环让模板为数组中的每个元素生成内容。
- en: How to do it…
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'Follow these steps to build an example of iterating over arrays:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤构建一个数组迭代的示例：
- en: 'Modify your `site.pp` file as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式修改你的 `site.pp` 文件：
- en: '[PRE46]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create the file `modules/base/templates/addresslist.erb` with the following
    contents:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文件 `modules/base/templates/addresslist.erb`，并写入以下内容：
- en: '[PRE47]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Run Puppet:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Puppet：
- en: '[PRE48]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Check the contents of the generated file:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查生成文件的内容：
- en: '[PRE49]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works…
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In the first line of the template, we reference the array `ipaddresses`, and
    call its `each` method:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板的第一行，我们引用了数组 `ipaddresses`，并调用了它的 `each` 方法：
- en: '[PRE50]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In Ruby, this creates a loop that will execute once for each element of the
    array. Each time round the loop, the variable `ip` will be set to the value of
    the current element.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 中，这会创建一个循环，每次迭代都会执行一次，并且每次循环时，变量 `ip` 会被设置为当前元素的值。
- en: 'In our example, the `ipaddresses` array contains three elements, so the following
    line will be executed three times, once for each element:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，`ipaddresses` 数组包含三个元素，因此接下来的行将执行三次，每次针对一个元素：
- en: '[PRE51]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This will result in three output lines:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成三行输出：
- en: '[PRE52]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The final line ends the loop:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行结束循环：
- en: '[PRE53]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the first and last lines end with `-%>` instead of just `%>` as we
    saw before. The effect of the `-` is to suppress the new line that would otherwise
    be generated on each pass through the loop, giving us unwanted blank lines in
    the file.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第一行和最后一行以 `-%>` 结束，而不是我们之前看到的 `%>`。`-` 的作用是抑制每次循环时生成的新行，这样就不会在文件中产生不必要的空行。
- en: There's more…
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'Templates can also iterate over hashes, or arrays of hashes:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 模板还可以对哈希或哈希数组进行迭代：
- en: '[PRE54]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: See also
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Using ERB templates* recipe in this chapter
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *使用 ERB 模板* 配方
- en: Using EPP templates
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 EPP 模板
- en: EPP templates are a new feature in Puppet 3.5 and newer versions. EPP templates
    use a syntax similar to ERB templates but are not compiled through Ruby. Two new
    functions are defined to call EPP templates, `epp`, and `inline_epp`. These functions
    are the EPP equivalents of the ERB functions `template` and `inline_template`,
    respectively. The main difference with EPP templates is that variables are referenced
    using the Puppet notation, `$variable` instead of `@variable`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: EPP 模板是 Puppet 3.5 及更新版本中的新特性。EPP 模板使用类似于 ERB 模板的语法，但不通过 Ruby 编译。定义了两个新函数来调用
    EPP 模板，`epp` 和 `inline_epp`。这两个函数分别是 ERB 函数 `template` 和 `inline_template` 的 EPP
    等效函数。EPP 模板的主要区别是，变量是使用 Puppet 语法引用的，`$variable` 而不是 `@variable`。
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'Create an EPP template in `~/puppet/epp-test.epp` with the following content:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `~/puppet/epp-test.epp` 中创建一个 EPP 模板，内容如下：
- en: '[PRE55]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Create an `epp.pp` manifest, which uses the `epp` and `inline_epp` functions:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `epp.pp` 清单，使用 `epp` 和 `inline_epp` 函数：
- en: '[PRE56]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Apply the manifest making sure to use the future parser (the future parser
    is required for the `epp` and `inline_epp` functions to be defined):'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用清单时，请确保使用未来解析器（未来解析器是定义 `epp` 和 `inline_epp` 函数所必需的）：
- en: '[PRE57]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Verify that the template worked as intended:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证模板是否按预期工作：
- en: '[PRE58]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: How it works...
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Using the future parser, the `epp` and `inline_epp` functions are defined. The
    main difference between EPP templates and ERB templates is that variables are
    referenced in the same way they are within Puppet manifests.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用未来解析器，定义了 `epp` 和 `inline_epp` 函数。EPP 模板与 ERB 模板的主要区别在于，变量是以与 Puppet 清单中相同的方式进行引用的。
- en: There's more...
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'Both `epp` and `inline_epp` allow for variables to be overridden within the
    function call. A second parameter to the function call can be used to specify
    values for variables used within the scope of the function call. For example,
    we can override the value of `$message` with the following code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`epp`和`inline_epp`都允许在函数调用中重写变量。函数调用的第二个参数可以用于为函数作用域内使用的变量指定值。例如，我们可以用以下代码重写`$message`的值：'
- en: '[PRE59]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now when we run Puppet and verify the output we see that the value of `$message`
    has been overridden:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行 Puppet 并验证输出时，我们看到`$message`的值已被重写：
- en: '[PRE60]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Using GnuPG to encrypt secrets
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GnuPG 加密机密信息
- en: We often need Puppet to have access to secret information, such as passwords
    or crypto keys, for it to configure systems properly. But how do you avoid putting
    such secrets directly into your Puppet code, where they're visible to anyone who
    has read access to your repository?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常需要 Puppet 访问机密信息，例如密码或加密密钥，以便它能够正确配置系统。但如何避免将这些机密信息直接放入 Puppet 代码中呢？这样会导致任何具有读取权限的人都能看到这些信息。
- en: It's a common requirement for third-party developers and contractors to be able
    to make changes via Puppet, but they definitely shouldn't see any confidential
    information. Similarly, if you're using a distributed Puppet setup like that described
    in [Chapter 2](ch02.html "Chapter 2. Puppet Infrastructure"), *Puppet Infrastructure*,
    every machine has a copy of the whole repo, including secrets for other machines
    that it doesn't need and shouldn't have. How can we prevent this?
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方开发人员和承包商通常需要通过 Puppet 进行更改，但他们绝对不应看到任何机密信息。类似地，如果您使用的是如[第2章](ch02.html "第2章.
    Puppet基础设施")所描述的分布式 Puppet 设置，*Puppet基础设施*，那么每台机器都有整个仓库的副本，其中包括它不需要且不应拥有的其他机器的机密信息。我们如何防止这种情况发生？
- en: One answer is to encrypt the secrets using the **GnuPG** tool, so that any secret
    information in the Puppet repo is undecipherable (for all practical purposes)
    without the appropriate key. Then we distribute the key securely to the people
    or machines that need it.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方法是使用**GnuPG**工具加密机密信息，以便在没有适当密钥的情况下，Puppet 仓库中的任何机密信息都无法被解密（在实际操作中）。然后，我们将密钥安全地分发给需要它的人或机器。
- en: Getting ready
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First you''ll need an encryption key, so follow these steps to generate one.
    If you already have a GnuPG key that you''d like to use, go on to the next section.
    To complete this section, you will need to install the gpg command:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要一个加密密钥，请按照以下步骤生成一个。如果您已经有一个想要使用的 GnuPG 密钥，可以跳过此部分，进入下一节。要完成此部分，您需要安装 gpg
    命令：
- en: 'Use `puppet` resource to install gpg:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`puppet`资源安装 gpg：
- en: '[PRE61]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Tip
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You may need to use gnupg2 as the package name, depending on your target OS.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据目标操作系统的不同，您可能需要使用 gnupg2 作为包名称。
- en: 'Run the following command. Answer the prompts as shown, except to substitute
    your name and e-mail address for mine. When prompted for a passphrase, just hit
    *Enter*:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令。按照提示回答问题，除了将我的名字和电子邮件地址替换为您的信息。当系统提示输入密码短语时，直接按*Enter*：
- en: '[PRE62]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Hit enter twice here to have an empty passphrase
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里按两次回车以设置空的密码短语
- en: '[PRE63]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You may see a message like this if your system is not configured with a source
    of randomness:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您的系统没有配置随机源，您可能会看到类似这样的消息：
- en: '[PRE64]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In this case, install and start a random number generator daemon such as `haveged`
    or `rng-tools`. Copy the gpg key you just created into the `puppet` user''s account
    on your Puppet master:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，安装并启动一个随机数生成守护进程，如`haveged`或`rng-tools`。将刚刚创建的 gpg 密钥复制到 Puppet 主机上`puppet`用户的账户中：
- en: '[PRE65]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: How to do it...
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: With your encryption key installed on the `puppet` user's keyring (the key generation
    process described in the previous section will do this for you), you're ready
    to set up Puppet to decrypt secrets.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的加密密钥安装在`puppet`用户的密钥环中（上一节描述的密钥生成过程会为您完成这项工作）时，您已经准备好配置 Puppet 来解密机密信息。
- en: 'Create the following directory:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下目录：
- en: '[PRE66]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Create the file `modules/admin/lib/puppet/parser/functions/secret.rb` with
    the following contents:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文件`modules/admin/lib/puppet/parser/functions/secret.rb`，并添加以下内容：
- en: '[PRE67]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Create the file `secret_message` with the following contents:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文件`secret_message`，并添加以下内容：
- en: '[PRE68]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Encrypt this file with the following command (use the e-mail address you supplied
    when creating the GnuPG key):'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令加密此文件（使用您在创建 GnuPG 密钥时提供的电子邮件地址）：
- en: '[PRE69]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Move the resulting encrypted file into your Puppet repo:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生成的加密文件移动到 Puppet 仓库中：
- en: '[PRE70]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Remove the original (plaintext) file:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除原始的（明文）文件：
- en: '[PRE71]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Modify your `site.pp` file as follows:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式修改您的`site.pp`文件：
- en: '[PRE72]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Run Puppet:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Puppet：
- en: '[PRE73]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: How it works...
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First, we''ve created a custom function to allow Puppet to decrypt the secret
    files using GnuPG:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个自定义函数，允许 Puppet 使用 GnuPG 解密秘密文件：
- en: '[PRE74]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The preceding code creates a function named `secret` that takes a file path
    as an argument and returns the decrypted text. It doesn''t manage encryption keys
    so you need to ensure that the `puppet` user has the necessary key installed.
    You can check this with the following command:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个名为`secret`的函数，该函数接受一个文件路径作为参数并返回解密后的文本。它不管理加密密钥，因此您需要确保`puppet`用户已安装必要的密钥。您可以通过以下命令检查：
- en: '[PRE75]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Having set up the `secret` function and the required key, we now encrypt a
    message to this key:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好`secret`函数和所需的密钥后，我们现在为该密钥加密一条消息：
- en: '[PRE76]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This creates an encrypted file that can only be read by someone with access
    to the secret key (or Puppet running on a machine that has the secret key).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这会创建一个加密文件，只有拥有密钥访问权限的人（或者在已安装密钥的机器上运行 Puppet 的人）才能读取。
- en: 'We then call the `secret` function to decrypt this file and get the contents:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用`secret`函数解密此文件并获取内容：
- en: '[PRE77]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: There's more...
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'You should use the `secret` function, or something like it, to protect any
    confidential data in your Puppet repo: passwords, AWS credentials, license keys,
    even other secret keys such as SSL host keys.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该使用`secret`函数，或类似的功能，来保护您 Puppet 仓库中的任何机密数据：密码、AWS 凭证、许可证密钥，甚至其他秘密密钥如 SSL
    主机密钥。
- en: You may decide to use a single key, which you push to machines as they're built,
    perhaps as part of a bootstrap process like that described in the *Bootstrapping
    Puppet with Bash* recipe in [Chapter 2](ch02.html "Chapter 2. Puppet Infrastructure"),
    *Puppet Infrastructure*. For even greater security, you might like to create a
    new key for each machine, or group of machines, and encrypt a given secret only
    for the machines that need it.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以决定使用一个单一的密钥，并在构建机器时将其推送到机器上，或许可以作为引导过程的一部分，像[第 2 章](ch02.html "第 2 章. Puppet
    基础设施")中的*使用 Bash 引导 Puppet*食谱所描述的那样。为了更高的安全性，您可能会为每台机器或机器组创建一个新的密钥，并仅针对需要它的机器加密给定的秘密。
- en: For example, your web servers might need a certain secret that you don't want
    to be accessible on any other machine. You could create a key for web servers,
    and encrypt the data only for this key.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您的 web 服务器可能需要某个秘密信息，而您不希望该信息在其他任何机器上可以访问。您可以为 web 服务器创建一个密钥，并仅针对该密钥加密数据。
- en: If you want to use encrypted data with Hiera, there is a GnuPG backend for Hiera
    available at [http://www.craigdunn.org/2011/10/secret-variables-in-puppet-with-hiera-and-gpg/](http://www.craigdunn.org/2011/10/secret-variables-in-puppet-with-hiera-and-gpg/).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用加密数据与 Hiera 配合使用，可以使用一个 Hiera 的 GnuPG 后端，详情见 [http://www.craigdunn.org/2011/10/secret-variables-in-puppet-with-hiera-and-gpg/](http://www.craigdunn.org/2011/10/secret-variables-in-puppet-with-hiera-and-gpg/)。
- en: See also
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Configuring Hiera* recipe in [Chapter 2](ch02.html "Chapter 2. Puppet Infrastructure"),
    *Puppet Infrastructure*
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 2 章](ch02.html "第 2 章. Puppet 基础设施")中的*配置 Hiera*食谱，*Puppet 基础设施*'
- en: The *Storing secret data with hiera-gpg* recipe in [Chapter 2](ch02.html "Chapter 2. Puppet
    Infrastructure"), *Puppet Infrastructure*
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 2 章](ch02.html "第 2 章. Puppet 基础设施")中的*使用 hiera-gpg 存储秘密数据*食谱，*Puppet 基础设施*'
- en: Installing packages from a third-party repository
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从第三方仓库安装软件包
- en: 'Most often you will want to install packages from the main distribution repo,
    so a simple package resource will do:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的是，您会希望从主分发仓库安装软件包，因此一个简单的软件包资源就足够了：
- en: '[PRE78]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Sometimes, you need a package that is only found in a third-party repository
    (an Ubuntu PPA, for example), or it might be that you need a more recent version
    of a package than that provided by the distribution, which is available from a
    third party.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能需要一个仅在第三方仓库中找到的软件包（例如 Ubuntu PPA），或者您可能需要比分发版提供的更近期的包版本，而这些版本可以从第三方获取。
- en: On a manually-administered machine, you would normally do this by adding the
    repo source configuration to `/etc/apt/sources.list.d` (and, if necessary, a gpg
    key for the repo) before installing the package. We can automate this process
    easily with Puppet.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在手动管理的机器上，通常通过将仓库源配置添加到`/etc/apt/sources.list.d`（如有必要，还需添加仓库的 gpg 密钥）来进行操作，然后再安装软件包。我们可以通过
    Puppet 很容易地自动化此过程。
- en: How to do it…
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In this example, we''ll use the popular Percona APT repo (Percona is a MySQL
    consulting firm who maintain and release their own specialized version of MySQL,
    more information is available at [http://www.percona.com/software/repositories](http://www.percona.com/software/repositories)):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用流行的 Percona APT 仓库（Percona 是一家 MySQL 咨询公司，他们维护并发布自己专门的 MySQL 版本，更多信息请访问
    [http://www.percona.com/software/repositories](http://www.percona.com/software/repositories)）：
- en: 'Create the file `modules/admin/manifests/percona_repo.pp` with the following
    contents:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文件 `modules/admin/manifests/percona_repo.pp`，并添加以下内容：
- en: '[PRE79]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Modify your `site.pp` file as follows:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式修改你的 `site.pp` 文件：
- en: '[PRE80]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Run Puppet:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Puppet：
- en: '[PRE81]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: How it works…
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'In order to install any Percona package, we first need to have the repository
    configuration installed on the machine. This is why the `percona-server-server-5.5`
    package (Percona''s version of the standard MySQL server) requires the `admin::percona_repo`
    class:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装任何 Percona 包，我们首先需要在机器上安装仓库配置。这就是为什么 `percona-server-server-5.5` 包（Percona
    版本的标准 MySQL 服务器）需要 `admin::percona_repo` 类的原因：
- en: '[PRE82]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'So, what does the `admin::percona_repo` class do? It:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`admin::percona_repo` 类做了什么呢？它：
- en: Installs the Percona APT key with which the packages are signed
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Percona APT 密钥，安装包将使用该密钥进行签名
- en: Configures the Percona repo URL as a file in `/etc/apt/sources.list.d`
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Percona 仓库 URL 配置为 `/etc/apt/sources.list.d` 中的文件
- en: Runs `apt-get update` to retrieve the repo metadata
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 `apt-get update` 来检索仓库的元数据
- en: Adds an APT pin configuration in `/etc/apt/preferences.d`
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `/etc/apt/preferences.d` 中添加 APT pin 配置
- en: 'First of all, we install the APT key:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们安装 APT 密钥：
- en: '[PRE83]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The `unless` parameter checks the output of `apt-key list` to make sure that
    the Percona key is not already installed, in which case we need not do anything.
    Assuming it isn''t, the `command` runs:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`unless` 参数检查 `apt-key list` 的输出，以确保 Percona 密钥尚未安装，如果已经安装，就不需要执行任何操作。如果没有安装，`command`
    命令将执行：'
- en: '[PRE84]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This command retrieves the key from the GnuPG keyserver, exports it in the ASCII
    format, and pipes this into the `apt-key add` command, which adds it to the system
    keyring. You can use a similar pattern for most third-party repos that require
    an APT signing key.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令从 GnuPG 密钥服务器获取密钥，以 ASCII 格式导出并将其传递给 `apt-key add` 命令，从而将其添加到系统密钥链中。对于大多数需要
    APT 签名密钥的第三方仓库，可以使用类似的模式。
- en: 'Having installed the key, we add the repo configuration:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 安装密钥后，我们添加仓库配置：
- en: '[PRE85]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Then run `apt-get update` to update the system''s APT cache with the metadata
    from the new repo:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行 `apt-get update`，用新仓库的元数据更新系统的 APT 缓存：
- en: '[PRE86]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Finally, we configure the APT pin priority for the repo:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为仓库配置 APT pin 优先级：
- en: '[PRE87]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: This ensures that packages installed from the Percona repo will never be superseded
    by packages from somewhere else (the main Ubuntu distro, for example). Otherwise,
    you could end up with broken dependencies and be unable to install the Percona
    packages automatically.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以确保从 Percona 仓库安装的包永远不会被其他地方（例如主 Ubuntu 发行版）安装的包所替代。否则，你可能会遇到依赖关系损坏的问题，无法自动安装
    Percona 包。
- en: There's more...
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容……
- en: 'The APT package framework is specific to the Debian and Ubuntu systems. There
    is a forge module for managing apt repos, [https://forge.puppetlabs.com/puppetlabs/apt](https://forge.puppetlabs.com/puppetlabs/apt).
    If you''re on a Red Hat or CentOS-based system, you can use the `yumrepo` resources
    to manage RPM repositories directly:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: APT 包框架特定于 Debian 和 Ubuntu 系统。对于管理 apt 仓库，有一个 forge 模块，[https://forge.puppetlabs.com/puppetlabs/apt](https://forge.puppetlabs.com/puppetlabs/apt)。如果你使用的是
    Red Hat 或 CentOS 系统，可以直接使用 `yumrepo` 资源来管理 RPM 仓库：
- en: '[http://docs.puppetlabs.com/references/latest/type.html#yumrepo](http://docs.puppetlabs.com/references/latest/type.html#yumrepo)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.puppetlabs.com/references/latest/type.html#yumrepo](http://docs.puppetlabs.com/references/latest/type.html#yumrepo)'
- en: Comparing package versions
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较包版本
- en: 'Package version numbers are odd things. They look like decimal numbers, but
    they''re not: a version number is often in the form of `2.6.4`, for example. If
    you need to compare one version number with another, you can''t do a straightforward
    string comparison: `2.6.4` would be interpreted as greater than `2.6.12`. And
    a numeric comparison won''t work because they''re not valid numbers.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 包版本号是一个奇怪的东西。它们看起来像十进制数，但实际上并不是：版本号通常是类似 `2.6.4` 的形式。例如，如果你需要比较两个版本号，你不能直接进行字符串比较：`2.6.4`
    会被解读为大于 `2.6.12`。而且数值比较也行不通，因为它们并不是有效的数字。
- en: 'Puppet''s `versioncmp` function comes to the rescue. If you pass two things
    that look like version numbers, it will compare them and return a value indicating
    which is greater:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 的 `versioncmp` 函数来解救了。如果你传递两个看起来像版本号的东西，它会比较它们并返回一个值，指示哪个更大：
- en: '[PRE88]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'returns:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: 0 if A and B are equal
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 A 和 B 相等，则返回 0
- en: Greater than 1 if A is higher than B
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 A 大于 B，则返回大于 1
- en: Less than 0 if A is less than B
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 A 小于 B，则返回小于 0
- en: How to do it…
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Here''s an example using the `versioncmp` function:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 `versioncmp` 函数的示例：
- en: 'Modify your `site.pp` file as follows:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式修改你的 `site.pp` 文件：
- en: '[PRE89]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Run Puppet:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Puppet：
- en: '[PRE90]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now change the value of `$app_version`:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在更改 `$app_version` 的值：
- en: '[PRE91]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Run Puppet again:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行 Puppet：
- en: '[PRE92]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: How it works…
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We've specified that the minimum acceptable version (`$min_version`) is `1.2.10`.
    So, in the first example, we want to compare it with `$app_version` of `1.2.2`.
    A simple alphabetic comparison of these two strings (in Ruby, for example) would
    give the wrong result, but `versioncmp` correctly determines that `1.2.2` is less
    than `1.2.10` and alerts us that we need to upgrade.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定了最小可接受版本（`$min_version`）是 `1.2.10`。因此，在第一个示例中，我们要将其与 `$app_version` 的 `1.2.2`
    进行比较。简单的字母顺序比较这两个字符串（例如在 Ruby 中）会得出错误的结果，但 `versioncmp` 正确地判断 `1.2.2` 小于 `1.2.10`，并提醒我们需要升级。
- en: In the second example, `$app_version` is now `1.2.14`, which `versioncmp` correctly
    recognizes as greater than `$min_version` and so we get the message **Version
    OK**.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，`$app_version` 现在是 `1.2.14`，`versioncmp` 正确地识别它大于 `$min_version`，因此我们得到了消息
    **版本正常**。
