- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: OpenShift Pipelines – Tekton
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenShift Pipelines – Tekton
- en: 'So far in this book, we’ve already discussed the challenges related to the
    current hybrid cloud world and covered aspects regarding the OpenShift architecture
    and deployment. Now, we are going to shift gears and bring you an exciting DevOps-related
    feature: **OpenShift Pipelines**!'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了与当前混合云世界相关的挑战，并介绍了 OpenShift 架构和部署的相关内容。现在，我们将转换话题，带来一个令人兴奋的 DevOps
    相关功能：**OpenShift Pipelines**！
- en: OpenShift Pipelines is a Kubernetes-native **continuous integration and continuous
    delivery** (**CI/CD**) tool based on the Tekton open source project, which is
    included at *no additional cost with Red Hat’s OpenShift subscription*. In this
    chapter, we will walk you through it and learn how to install and use it. By doing
    this, you will understand how it can be helpful in your DevOps pipelines and automation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift Pipelines 是一个 Kubernetes 原生的 **持续集成与持续交付**（**CI/CD**）工具，基于 Tekton
    开源项目，并且在 *Red Hat OpenShift 订阅中无需额外费用*。在本章中，我们将带你逐步了解如何安装和使用它。通过学习，你将明白它如何在 DevOps
    流水线和自动化中发挥作用。
- en: After [*Chapter 5*](B18015_05.xhtml#_idTextAnchor090), *OpenShift Deployment*,
    you should have an OpenShift cluster working in your environment. We will use
    that cluster in this chapter to implement some exercises. If you don’t have an
    OpenShift cluster available, then you can use **CodeReady Containers** (**CRC**)
    as a lab. Here, you can run an OpenShift cluster locally and quickly using an
    all-in-one VM.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 5 章*](B18015_05.xhtml#_idTextAnchor090)，*OpenShift 部署* 后，你应该在环境中有一个正在运行的
    OpenShift 集群。我们将在本章中使用该集群来实现一些练习。如果你没有可用的 OpenShift 集群，你可以使用 **CodeReady Containers**（**CRC**）作为实验室。在这里，你可以使用一个全功能的虚拟机快速本地运行
    OpenShift 集群。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What is OpenShift Pipelines?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 OpenShift Pipelines？
- en: Installing OpenShift Pipelines
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 OpenShift Pipelines
- en: Creating a Tekton pipeline from scratch
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从零开始创建 Tekton 流水线
- en: Using triggers with GitHub webhooks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GitHub Webhook 触发器
- en: Fixing the failed PipelineRun due to YAML issues
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复由于 YAML 问题导致的 PipelineRun 失败
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As we mentioned previously, OpenShift Pipelines is a Kubernetes native application
    and, as such, is a lightweight tool that uses **Custom Resource Definitions**
    (**CRDs**) to extend the OpenShift API’s functionalities. In the upcoming sections,
    you will see that the installation is fairly simple and only involves installing
    an operator – a *“Next, Next, Finish”* sort of experience. To be able to install
    it and run the exercises in this chapter, you only need an OpenShift cluster with
    the following available resources:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，OpenShift Pipelines 是一个 Kubernetes 原生应用，因此它是一个轻量级工具，使用 **自定义资源定义**（**CRDs**）来扩展
    OpenShift API 的功能。在接下来的章节中，你将看到安装过程非常简单，只需要安装一个 Operator——一种 *“下一步，下一步，完成”* 的体验。要能够安装并运行本章中的练习，你只需要一个具有以下可用资源的
    OpenShift 集群：
- en: 2 vCPUs
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 vCPU
- en: 2 GB of RAM
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 GB RAM
- en: 'If you don’t have an OpenShift cluster available to use, we recommend that
    you try CRC to spin up a cluster locally on your machine. To use CRC, you need
    to have the following system requirements on your workstation:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有可用的 OpenShift 集群，我们建议你尝试 CRC（CodeReady Containers），在你的机器上本地启动一个集群。要使用 CRC，你需要在工作站上满足以下系统要求：
- en: 4 physical CPU cores (AMD64 or Intel 64)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 个物理 CPU 核心（AMD64 或 Intel 64）
- en: 9 GB of free memory
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 9 GB 可用内存
- en: 35 GB of storage space
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 35 GB 存储空间
- en: 'One of the following operating systems:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下操作系统之一：
- en: Windows (Windows 10 Fall Creators Update or later)
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows（Windows 10 Fall Creators 更新版或更高版本）
- en: macOS (10.14 Mojave or later)
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: macOS（10.14 Mojave 或更高版本）
- en: Linux (Red Hat Enterprise Linux/CentOS 7.5 or later and on the latest two stable
    Fedora releases)
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux（Red Hat Enterprise Linux/CentOS 7.5 或更高版本，以及最新两个稳定版 Fedora 发行版）
- en: Linux (Ubuntu 18.04 LTS or newer and Debian 10 or newer *are not officially*
    supported and may require you to manually set up the host machine
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux（Ubuntu 18.04 LTS 或更新版本以及 Debian 10 或更新版本 *未正式支持*，可能需要你手动设置主机）
- en: The source code used in this chapter is available at [https://github.com/PacktPublishing/OpenShift-Multi-Cluster-Management-Handbook/tree/main/chapter09](https://github.com/PacktPublishing/OpenShift-Multi-Cluster-Management-Handbook/tree/main/chapter09).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用的源代码可在 [https://github.com/PacktPublishing/OpenShift-Multi-Cluster-Management-Handbook/tree/main/chapter09](https://github.com/PacktPublishing/OpenShift-Multi-Cluster-Management-Handbook/tree/main/chapter09)
    中获取。
- en: 'In this section, we will demonstrate how to install and use CRC using a Linux
    (Fedora) workstation. Please refer to the following site to find out more about
    the installation process on Windows or macOS: [https://crc.dev/crc/](https://crc.dev/crc/).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将演示如何使用 Linux（Fedora）工作站安装和使用 CRC。有关 Windows 或 macOS 上安装过程的更多信息，请参考以下网站：[https://crc.dev/crc/](https://crc.dev/crc/)。
- en: What Is a CRD?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 CRD？
- en: A CRD is a Kubernetes resource that allows you to expand the Kubernetes APIs
    by defining custom entities. A CRD is composed of a name and a schema that specify
    the API’s properties.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: CRD（自定义资源定义）是一个 Kubernetes 资源，它允许你通过定义自定义实体来扩展 Kubernetes API。CRD 由一个名称和一个指定
    API 属性的模式组成。
- en: Installing and using CRC
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和使用 CRC
- en: 'The CRC installation process is simple – you need to have the following packages
    installed in your box:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: CRC 安装过程很简单——你需要在你的系统中安装以下软件包：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To install CRC, follow these steps:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 CRC，请按照以下步骤操作：
- en: Download the latest release of CRC for your platform at [https://console.redhat.com/openshift/create/local](https://console.redhat.com/openshift/create/local).
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[https://console.redhat.com/openshift/create/local](https://console.redhat.com/openshift/create/local)下载适合你平台的CRC最新版本。
- en: Extract the contents of the archive.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取存档文件的内容。
- en: In a terminal, go to the path where you extracted the archive.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，进入你提取存档文件的路径。
- en: 'Run the following command to set up CRC:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以设置 CRC：
- en: '[PRE1]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you want to set up parameters, such as the amount of CPU and memory that’s
    available for CRC, run the following code:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想设置一些参数，例如可供 CRC 使用的 CPU 和内存数量，请运行以下代码：
- en: '[PRE2]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Start CRC by running the following command:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令启动 CRC：
- en: '[PRE3]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It is going to take up to 20 minutes to completely start the cluster. At the
    end of the process, you will see a screen similar to the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 完全启动集群可能需要最多 20 分钟。完成后，你将看到类似以下的屏幕：
- en: '![Figure 9.1 – CRC startup ](img/B18015_09_01.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – CRC 启动](img/B18015_09_01.jpg)'
- en: Figure 9.1 – CRC startup
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – CRC 启动
- en: Now that you have CRC or any other OpenShift cluster up and running, we are
    ready to introduce OpenShift Pipelines and learn what you can do with it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经启动了 CRC 或其他 OpenShift 集群，我们准备介绍 OpenShift Pipelines，并了解你可以用它做些什么。
- en: What is OpenShift Pipelines?
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 OpenShift Pipelines？
- en: Now that you already have a lab environment, let’s start our engines and drive
    through OpenShift Pipelines! As we mentioned previously, OpenShift Pipelines is
    Red Hat’s implementation of the Tekton open source project. Let’s learn what Tekton
    is and how it differs from other CI/CD pipeline tools on the market.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了一个实验环境，让我们启动引擎，驶向 OpenShift Pipelines！正如我们之前提到的，OpenShift Pipelines 是
    Red Hat 对 Tekton 开源项目的实现。让我们了解一下 Tekton 是什么，它与市场上其他 CI/CD 流水线工具有何不同。
- en: What is Tekton?
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 Tekton？
- en: Tekton provides a framework for creating Kubernetes native CI/CD pipelines quickly
    and easily. It uses CRDs to extend the Kubernetes APIs functionalities and add
    some custom objects that are used to implement CI/CD pipelines. You can also integrate
    Tekton with industry-standard CI/CD pipeline tools such as Jenkins, GitLab CI,
    and any others to use the best technology for each case.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Tekton 提供了一个框架，使得快速且轻松地创建 Kubernetes 原生的 CI/CD 流水线成为可能。它通过 CRD 扩展了 Kubernetes
    API 功能，并添加了一些自定义对象，用于实现 CI/CD 流水线。你还可以将 Tekton 与行业标准的 CI/CD 流水线工具（如 Jenkins、GitLab
    CI 等）集成，以便为每种情况选择最佳技术。
- en: Tekton is a part of the **Continuous Delivery Foundation**, which is sponsored
    by huge companies such as AWS, Red Hat, Google, Netflix, and many others. This
    is usually a good indication that a project will have a long life and stability
    – an important factor for an enterprise’s investment decisions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Tekton 是 **持续交付基金会** 的一部分，该基金会得到了 AWS、Red Hat、Google、Netflix 等大型公司的支持。这通常是一个项目有长期生命力和稳定性的好兆头——这是企业在做投资决策时的重要因素。
- en: Main benefits
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主要优点
- en: 'Using Tekton can bring you many benefits, such as the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Tekton 可以为你带来许多好处，具体包括以下几点：
- en: Tekton can be considered as a serverless CI/CD pipeline system that consumes
    resources on demand using isolated containers, which likely reduce the infrastructure
    or cloud costs associated with the CI/CD tool.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tekton 可以看作是一个无服务器的 CI/CD 流水线系统，通过按需消耗资源并使用隔离的容器，从而可能减少与 CI/CD 工具相关的基础设施或云端成本。
- en: It is tightly integrated with Kubernetes, working as an extension of it using
    CRDs. This means that you don’t need to spend time and resources with complex
    integrations between the CI/CD tools and OpenShift.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与 Kubernetes 紧密集成，作为 Kubernetes 的扩展通过 CRD（自定义资源定义）进行工作。这意味着你无需在 CI/CD 工具与 OpenShift
    之间进行复杂的集成，节省时间和资源。
- en: Both the aforementioned aspects also mean that you will not need additional
    human resources to deploy, support, and maintain the CI/CD tool.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述两个方面还意味着，你不需要额外的人力资源来部署、支持和维护 CI/CD 工具。
- en: As a Kubernetes native tool, you can define and run pipelines by applying a
    simple YAML file to Kubernetes (the same way you would do to create a Pod, Service,
    Or Deployment). This makes Tekton easy to use and integrate with other tools for
    complex pipelines that are composed of several components (legacy VMs, containers,
    microservices, and so on).
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一个 Kubernetes 原生工具，你可以通过将一个简单的 YAML 文件应用于 Kubernetes 来定义和运行管道（这与创建 Pod、Service
    或 Deployment 的方式相同）。这使得 Tekton 易于使用，并能与其他工具集成，以便构建由多个组件（传统虚拟机、容器、微服务等）组成的复杂管道。
- en: By integrating Tekton with **Argo CD**, you can have a really powerful stack
    in which Tekton resides on the *continuous integration* side while Argo CD is
    responsible for the *continuous delivery* side. We will look at Argo CD in detail
    in [*Chapter 10*](B18015_10.xhtml#_idTextAnchor204), *OpenShift GitOps – Argo
    CD*.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将 Tekton 与 **Argo CD** 集成，你可以构建一个非常强大的技术栈，在这个栈中，Tekton 位于 *持续集成* 侧，而 Argo
    CD 负责 *持续交付* 侧。我们将在 [*第 10 章*](B18015_10.xhtml#_idTextAnchor204) 中详细讨论 Argo CD，*OpenShift
    GitOps – Argo CD*。
- en: It is a true open source solution that’s backed by a strong foundation, which
    is good evidence that it will be supported and evolve for years to come.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个真正的开源解决方案，背后有强大的基础支持，这是它将得到持续支持并在未来几年发展的有力证据。
- en: Tekton components
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tekton 组件
- en: 'In this section, we will walk through each of the Tekton components. In a nutshell,
    the main Tekton components are as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将逐一介绍每个 Tekton 组件。简而言之，主要的 Tekton 组件如下：
- en: '**Tekton Pipelines**: It is composed of several CRDs, which are the building
    blocks for developing and running CI/CD pipelines.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tekton 管道**：它由多个 CRD 组成，这些 CRD 是开发和运行 CI/CD 管道的构建块。'
- en: '**Tekton Triggers**: These are objects that listen to events and trigger a
    pipeline or task. They are often used to run a pipeline after a pull or push request
    in a GitHub repository.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tekton 触发器**：这些是监听事件并触发管道或任务的对象。它们通常用于在 GitHub 仓库中的拉取或推送请求后运行管道。'
- en: '`tkn`) to interact with Tekton.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tkn`) 与 Tekton 交互。'
- en: '**Tekton Catalog**: A community-driven repository of tasks ready to be used
    in your pipelines.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tekton 目录**：一个由社区驱动的任务仓库，任务可以直接在你的管道中使用。'
- en: '**Tekton Operator**: This is used to easily install, manage, and remove Tekton
    from a Kubernetes cluster.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tekton 操作员**：用于轻松地从 Kubernetes 集群中安装、管理和移除 Tekton。'
- en: Concepts
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概念
- en: 'To learn Tekton, you need to understand some concepts first:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习 Tekton，你需要先理解一些概念：
- en: '**Step**: An action that has a set of inputs and produces a set of outputs.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤**：一个包含输入集并产生输出集的操作。'
- en: '**Task**: A set of structured steps required to run a specific task, such as
    cloning a GitHub repository or building source code.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务**：一组结构化的步骤，用于执行特定任务，例如克隆 GitHub 仓库或构建源代码。'
- en: '**Pipeline**: A set of structured tasks that composes a CI/CD pipeline.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管道**：一组结构化任务，组成一个 CI/CD 管道。'
- en: '**TaskRun**: This object represents the instantiation of a task. While the
    task is the generic definition of it, a TaskRun defines the input parameters and
    the other components that are needed to run it.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TaskRun**：这个对象代表任务的实例化。任务是其通用定义，而 TaskRun 则定义了输入参数及运行该任务所需的其他组件。'
- en: '**PipelineRun**: This is similar to a TaskRun, but for pipelines.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PipelineRun**：这类似于 TaskRun，但用于管道。'
- en: To dive into these concepts, we will cover an example where we will build and
    run a meaningful pipeline.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了深入理解这些概念，我们将通过一个示例，构建并运行一个有意义的管道。
- en: Installing OpenShift Pipelines
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 OpenShift Pipelines
- en: The installation process is really simple, as you will see in the following
    steps.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程非常简单，正如你将在以下步骤中看到的那样。
- en: Prerequisites
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前提条件
- en: You must have access to the OpenShift cluster with cluster-admin permissions.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你必须具有集群管理员权限才能访问 OpenShift 集群。
- en: Installation
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装
- en: 'Follow these steps:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: Access the **OpenShift Web Console** from the administrator’s perspective.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从管理员视角访问 **OpenShift Web 控制台**。
- en: 'Navigate to **Operators** | **OperatorHub**:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航至 **Operators** | **OperatorHub**：
- en: '![Figure 9.2 – OperatorHub ](img/B18015_09_02.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – OperatorHub](img/B18015_09_02.jpg)'
- en: Figure 9.2 – OperatorHub
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – OperatorHub
- en: 'Search for `OpenShift Pipelines` using the *Filter by keyword* box:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 *按关键词过滤* 框搜索 `OpenShift Pipelines`：
- en: '![Figure 9.3 – Red Hat OpenShift Pipelines on OperatorHub ](img/B18015_09_03.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – OperatorHub 中的 Red Hat OpenShift Pipelines](img/B18015_09_03.jpg)'
- en: Figure 9.3 – Red Hat OpenShift Pipelines on OperatorHub
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – Red Hat OpenShift Pipelines 在 OperatorHub 上
- en: 'Click on the **Red Hat OpenShift Pipelines** tile and then the **Install**
    button to see the **Install Operator** screen:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Red Hat OpenShift Pipelines**图标，然后点击**安装**按钮，进入**安装操作符**界面：
- en: '![Figure 9.4 – Installing OpenShift Pipelines ](img/B18015_09_04.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 安装 OpenShift Pipelines](img/B18015_09_04.jpg)'
- en: Figure 9.4 – Installing OpenShift Pipelines
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 安装 OpenShift Pipelines
- en: Now, select `openshift-operators` namespace and permits the operator to install
    OpenShift Pipelines instances in any target namespace.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，选择 `openshift-operators` 命名空间并允许操作符在任何目标命名空间中安装 OpenShift Pipelines 实例。
- en: Select **Automatic** or **Manual** for the upgrade’s **Approval Strategy**.
    If you go for **Automatic**, upgrades will be performed automatically by the **Operator
    Lifecycle Manager** (**OLM**) as soon as they are released by Red Hat, while if
    you go for **Manual**, you need to approve it before it’s applied.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**自动**或**手动**作为升级的**批准策略**。如果选择**自动**，升级将在**操作符生命周期管理器**（**OLM**）发布后自动执行；而如果选择**手动**，则需要在应用之前批准它。
- en: Select an **Update channel option**. The stable channel is recommended as it
    contains the latest stable and *supported* version of the operator.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**更新频道选项**。推荐选择稳定频道，因为它包含最新的稳定且*受支持*版本的操作符。
- en: 'Click the **Install** button:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**安装**按钮：
- en: '![Figure 9.5 – Installing the operator ](img/B18015_09_05.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – 安装操作符](img/B18015_09_05.jpg)'
- en: Figure 9.5 – Installing the operator
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 安装操作符
- en: 'Wait up to 5 minutes until you see the following message:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待最多 5 分钟，直到看到以下消息：
- en: '![Figure 9.6 – Operator installed ](img/B18015_09_06.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6 – 操作符已安装](img/B18015_09_06.jpg)'
- en: Figure 9.6 – Operator installed
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – 操作符已安装
- en: Once you have installed OpenShift Pipelines, we recommend that you install the
    `tkn` CLI to help with ordinary tasks. Let’s learn how to install the `tkn` CLI.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 OpenShift Pipelines 后，我们建议您安装 `tkn` CLI 来帮助完成常见任务。让我们学习如何安装 `tkn` CLI。
- en: Installing the tkn CLI
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 tkn CLI
- en: '`tkn` is a CLI that makes it easier to work with Tekton. Through it, you can
    manage (list, delete, describe, get logs, and so on) tasks, pipelines, triggers,
    and all the available Tekton objects.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`tkn` 是一个 CLI 工具，它使得与 Tekton 的工作变得更加容易。通过它，您可以管理（列出、删除、描述、获取日志等）任务、流水线、触发器以及所有可用的
    Tekton 对象。'
- en: 'To install the `tkn` CLI, follow these steps:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 `tkn` CLI，请按照以下步骤操作：
- en: 'Download tkn from the URL link provided after you click the *question mark*
    icon of your OpenShift Web Console, as shown here:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 `tkn`，方法是点击 OpenShift Web 控制台中的*问号*图标后提供的 URL 链接，如下所示：
- en: '![Figure 9.7 – Help menu | Command line tools ](img/B18015_09_07.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7 – 帮助菜单 | 命令行工具](img/B18015_09_07.jpg)'
- en: Figure 9.7 – Help menu | Command line tools
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – 帮助菜单 | 命令行工具
- en: 'Download the client for your workstation:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载适用于您的工作站的客户端：
- en: '![Figure 9.8 – tkn download links ](img/B18015_09_08.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – tkn 下载链接](img/B18015_09_08.jpg)'
- en: Figure 9.8 – tkn download links
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – tkn 下载链接
- en: 'After downloading it to your machine, you need to decompress it and add it
    to your path:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载到您的机器后，您需要解压并将其添加到路径中：
- en: '[PRE4]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If everything went well, you will see the output below by running `tkn version`.
    Ignore the warning message you will see that specifies the pipeline version; it
    is an expected message as we haven’t logged any OpenShift clusters yet:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，运行 `tkn version` 后将看到以下输出。忽略警告消息，它会提示流水线版本；这是预期中的消息，因为我们还没有登录任何 OpenShift
    集群：
- en: '[PRE5]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that you have installed OpenShift Pipelines and `tkn`, let’s use them to
    create a pipeline from scratch. In the next section, we will learn about Tekton’s
    main concepts while taking a practical approach.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经安装了 OpenShift Pipelines 和 `tkn`，让我们利用它们从零开始创建一个流水线。在接下来的章节中，我们将通过实际操作学习
    Tekton 的主要概念。
- en: Creating a Tekton pipeline from scratch
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从零开始创建 Tekton 流水线
- en: 'In this section, we will create a Tekton pipeline from scratch so that we can
    learn from it. We are going to use a sample from our GitHub repository: [https://github.com/PacktPublishing/OpenShift-Multi-Cluster-Management-Handbook](https://github.com/PacktPublishing/OpenShift-Multi-Cluster-Management-Handbook).
    To practice the concepts we will cover here, fork this repository to your GitHub
    account and follow the instructions provided in this chapter.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从零开始创建一个 Tekton 流水线，以便我们从中学习。我们将使用我们 GitHub 仓库中的一个示例：[https://github.com/PacktPublishing/OpenShift-Multi-Cluster-Management-Handbook](https://github.com/PacktPublishing/OpenShift-Multi-Cluster-Management-Handbook)。为了实践我们将在此覆盖的概念，请将此仓库分叉到您的
    GitHub 账户，并按照本章中的说明进行操作。
- en: 'The pipeline that we will work on is simple but helpful. It will consist of
    the following tasks:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要处理的流水线很简单，但很有帮助。它将由以下任务组成：
- en: '![Figure 9.9 – Build and deploy pipeline ](img/B18015_09_09.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.9 – 构建和部署流水线](img/B18015_09_09.jpg)'
- en: Figure 9.9 – Build and deploy pipeline
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 构建和部署流水线
- en: In the next few sections, you will learn how to use Tasks, TaksRuns, Pipelines,
    and PipelineRuns, which are Tekton’s main objects.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个章节中，你将学习如何使用 Tasks、TaskRuns、Pipelines 和 PipelineRuns，这些是 Tekton 的主要对象。
- en: Tasks
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务
- en: 'To create this pipeline, you need to understand the foundational concept of
    a task. As we mentioned previously, a task provides a set of structured steps
    for performing a certain action, such as cloning a GitHub repository or building
    source code. Now, let’s go deeper and learn about some important aspects of it.
    The first important aspect that you need to understand is the task scope, which
    defines whether you need to use a Task or a ClusterTask:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个流水线，你需要理解任务的基础概念。如前所述，任务提供了一组结构化的步骤来执行某个特定的操作，例如克隆 GitHub 仓库或构建源代码。现在，让我们更深入地了解它的一些重要方面。你需要理解的第一个重要方面是任务范围，它定义了你是否需要使用
    Task 还是 ClusterTask：
- en: '**Task**: A task is only available within a specific namespace. You will usually
    use tasks for actions that apply specifically to a certain application.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务**：任务仅在特定的命名空间中可用。你通常会使用任务来执行特定于某个应用程序的操作。'
- en: '**ClusterTask**: This is identical to a task but can be used in any namespace.
    They are usually used with generic actions that can be applied to any application.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ClusterTask**：这与任务相同，但可以在任何命名空间中使用。它们通常用于可以应用于任何应用程序的通用操作。'
- en: 'In our example, we will use Tasks and ClusterTasks to understand how they work
    and the differences between them. A Task has the following elements. We will use
    these in our example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将使用 Tasks 和 ClusterTasks 来理解它们是如何工作的以及它们之间的区别。一个任务包含以下元素，我们将在示例中使用它们：
- en: '**Parameters**: The parameters that are required to run the task.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数**：运行任务所需的参数。'
- en: '**Resources**: This includes the input or output resources that are supplied
    by **PipelineResources** objects. We recommend that you use workspaces instead
    of PipelineResources since they are more difficult to troubleshoot, making tasks
    less reusable and more limited than workspaces. Due to that, we won’t be using
    PipelineResources in our example.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源**：这包括由 **PipelineResources** 对象提供的输入或输出资源。我们建议你使用工作空间而不是 PipelineResources，因为后者更难以排查故障，使任务的重用性降低，限制更多。因此，我们在示例中不会使用
    PipelineResources。'
- en: '**Steps**: This is where you define the actions that will be performed in a
    task. You need to use a container image to run the actions.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤**：在这里你定义将在任务中执行的操作。你需要使用一个容器镜像来运行这些操作。'
- en: '**Workspaces**: This is an artifact that’s used to define a commonly shared
    storage volume between different tasks in a pipeline. Workspaces can be used for
    different purposes, such as sharing data between different tasks, a mount point
    for configurations (using ConfigMaps), credentials, and sensitive data (with secrets),
    and also to store reusable artifacts that have been shared between different tasks
    and pipelines. Workspaces are also helpful for caching artifacts to speed up builds
    and other jobs.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作空间**：这是一个用于定义流水线中不同任务之间共享存储卷的工件。工作空间可以用于不同的目的，例如在不同任务之间共享数据、配置的挂载点（使用 ConfigMaps）、凭证和敏感数据（使用
    Secrets），以及存储在不同任务和流水线之间共享的可重用工件。工作空间对于缓存工件以加速构建和其他作业也非常有用。'
- en: '**Results**: These are string result variables that can be passed to other
    tasks in a pipeline.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结果**：这些是字符串类型的结果变量，可以传递给流水线中的其他任务。'
- en: In our sample pipeline, we are going to reuse our existing tasks for the GitHub
    clone and build the source code. The last two tasks we will look at will be custom
    ones that we will create specifically for our pipeline.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例流水线中，我们将重用现有的任务来克隆 GitHub 仓库并构建源代码。最后两个任务我们将专门为流水线创建的自定义任务。
- en: Reusing tasks
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重用任务
- en: First, let’s learn how to search for and reuse tasks to build a pipeline.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们学习如何搜索和重用任务来构建流水线。
- en: The first place where you can look for existing tasks is your local OpenShift
    cluster. When you install OpenShift Pipelines, several `tkn` CLI or the OpenShift
    UI.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个可以查看现有任务的地方是你的本地 OpenShift 集群。当你安装 OpenShift Pipelines 时，多个 `tkn` CLI 或 OpenShift
    UI 中会包含这些任务。
- en: 'The following code shows how to use `tkn`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何使用 `tkn`：
- en: '[PRE6]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following is some example output:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例输出：
- en: '[PRE7]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To do the same using the OpenShift UI, go to `tkn` CLI:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 OpenShift UI 执行相同操作，请转到 `tkn` CLI：
- en: '![Figure 9.10 – ClusterTasks for reuse ](img/B18015_09_10.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.10 – 可重用的 ClusterTasks](img/B18015_09_10.jpg)'
- en: Figure 9.10 – ClusterTasks for reuse
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – 可重用的 ClusterTasks
- en: Another great tool to look for and reuse existing tasks is **Tekton Hub**. We
    will use it shortly to extend our sample and validate our YAML files using the
    **YAML Lint** tool.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个寻找并重用现有任务的好工具是 **Tekton Hub**。我们稍后将使用它来扩展我们的示例，并使用 **YAML Lint** 工具验证我们的
    YAML 文件。
- en: Notes
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: '**Tekton Hub** is a web portal where you can get reusable assets from Tekton
    Catalog. It can be accessed at [https://hub.tekton.dev/](https://hub.tekton.dev/).'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tekton Hub** 是一个 Web 门户，您可以在其中获取 Tekton Catalog 中的可重用资产。可以通过 [https://hub.tekton.dev/](https://hub.tekton.dev/)
    访问。'
- en: '**YAML Lint** is a tool that validates YAML file syntax, checking indentation,
    trailing spaces, and many other possible issues. Go to [https://yamllint.readthedocs.io/en/stable/](https://yamllint.readthedocs.io/en/stable/)
    to learn more.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**YAML Lint** 是一个工具，用于验证 YAML 文件的语法，检查缩进、尾随空格以及其他许多可能的问题。了解更多信息，请访问 [https://yamllint.readthedocs.io/en/stable/](https://yamllint.readthedocs.io/en/stable/)。'
- en: 'Using the ClusterTasks, we have decided to reuse the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ClusterTasks，我们决定重用以下内容：
- en: '`git-clone`: To clone the source code from the GitHub repository'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git-clone`：从 GitHub 仓库克隆源代码'
- en: '`buildah`: To build the source code and generate a container image as a result'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buildah`：构建源代码并生成容器镜像。'
- en: Now, let’s learn how to create a custom task for when you need something specific.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何为需要特定功能时创建一个自定义任务。
- en: Creating a new (custom) task
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个新的（自定义）任务
- en: 'Defining a new task is as simple as creating a pod or deployment. For our example,
    we need to create three new tasks:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个新任务和创建一个 Pod 或部署一样简单。对于我们的示例，我们需要创建三个新任务：
- en: '`apply-manifests`: This task will be responsible for applying some K8s manifest
    files that will deploy the application.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply-manifests`：该任务将负责应用一些 K8s manifest 文件，这些文件将部署应用程序。'
- en: '`update-deployment`: This task will update the deployment, replacing the container
    image with the one that has been built in the previous tasks.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update-deployment`：该任务将更新部署，用构建任务中生成的容器镜像替换现有镜像。'
- en: '`check-app-health`: This task checks the application pod’s status and the URL
    to validate whether the application is accessible.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`check-app-health`：该任务检查应用程序 Pod 的状态和 URL，验证应用程序是否可以访问。'
- en: 'Let’s create these tasks, explore their content, and learn from them:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建这些任务，查看它们的内容，并从中学习：
- en: '[PRE8]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code, we have highlighted some parts with numbers. Let’s take
    a look:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们用数字标出了某些部分。让我们来看看：
- en: '**[1]**: An object of this kind defines a new Tekton task.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[1]**: 这种对象定义了一个新的 Tekton 任务。'
- en: '**[2]**: The task’s name.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[2]**: 任务的名称。'
- en: '`git-clone` task (the first task).'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git-clone` 任务（第一个任务）。'
- en: '**[4]**: The parameters that are required for the task to run.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[4]**: 运行任务所需的参数。'
- en: '**[5]**: The steps that are performed with the task.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[5]**: 执行任务时所执行的步骤。'
- en: '`step` commands.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`step` 命令。'
- en: '**[7]**: The commands that will perform the desired action – in this case,
    applying the k8s manifests.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[7]**: 执行所需操作的命令 —— 在本例中，应用 k8s manifest 文件。'
- en: 'Now that we have looked at the task’s structure, let’s create it in our sample
    environment and run it using another object – **TestRun**:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了任务的结构，让我们在示例环境中创建它，并使用另一个对象 —— **TestRun** 来运行它：
- en: 'Create a new project for our example:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的示例创建一个新项目：
- en: '[PRE9]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, check if the pipeline’s service account has been created automatically:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，检查管道的服务帐户是否已自动创建：
- en: '[PRE10]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create the `apply-manifest` task in the `pipelines-sample` namespace:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `pipelines-sample` 命名空间中创建 `apply-manifest` 任务：
- en: '[PRE11]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Using `tkn` confirm that the task has been created:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `tkn` 确认任务已创建：
- en: '[PRE12]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let’s create other custom tasks (`update-image-version` and `check-route-health`):'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建其他自定义任务（`update-image-version` 和 `check-route-health`）：
- en: '[PRE13]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that we have created our custom tasks, let’s learn how to run and test them
    using a `TaskRun` object.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了自定义任务，让我们学习如何使用 `TaskRun` 对象来运行和测试它们。
- en: TaskRun
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TaskRun
- en: Our task needs a persistent volume to store the source code from GitHub. As
    such, before we run TaskRun, we need to create a **PersistentVolumeClaim**. Note
    that you need to have a **StorageClass** to provision a **PersistentVolume** automatically
    for you. If you don’t have one, the PersistentVolumeClaim will be *Pending*, waiting
    for the PersistentVolume to be created manually.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务需要一个持久卷来存储来自GitHub的源代码。因此，在运行TaskRun之前，我们需要创建一个**PersistentVolumeClaim**。请注意，你需要一个**StorageClass**来自动为你提供**PersistentVolume**。如果没有，PersistentVolumeClaim将处于*待定*状态，等待手动创建PersistentVolume。
- en: 'Run the following command to create the PersistentVolumeClaim:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以创建PersistentVolumeClaim：
- en: '[PRE14]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, we must create two TaskRuns. In the first, we will use the `git-clone`
    ClusterTask to clone the GitHub repository and store it in the workspace that
    uses a PersistentVolume. In the second, we will use the custom task that we created
    previously, which deploys the application by applying some manifests (the `apply-manifests`
    task).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须创建两个TaskRuns。在第一个中，我们将使用`git-clone`集群任务克隆GitHub仓库，并将其存储在使用持久卷的工作区中。在第二个中，我们将使用之前创建的自定义任务，通过应用一些清单（`apply-manifests`任务）来部署应用。
- en: 'The following code shows the structure of a TaskRun:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了一个TaskRun的结构：
- en: '[PRE15]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let’s look at this code in more detail:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这段代码：
- en: '`TaskRun` object'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TaskRun`对象'
- en: '**[2]**: The name of the task that will be run'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[2]**：将要运行的任务名称'
- en: '`ClusterTask` but can be omitted for regular tasks'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClusterTask`，但对于常规任务可以省略'
- en: '**[4]**: Parameter values to be used during the task’s execution'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[4]**：在任务执行过程中使用的参数值'
- en: '**[5]**: Workspaces to be used'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[5]**：要使用的工作区'
- en: 'Run the following command to apply the `TaskRun` object:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以应用`TaskRun`对象：
- en: '[PRE16]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once you have created the `git-clone` object, you can look at the logs using
    the following `tkn` command:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了`git-clone`对象，就可以使用以下`tkn`命令查看日志：
- en: '[PRE17]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, run `apply-manifests` using the following TaskRun:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用以下的TaskRun运行`apply-manifests`：
- en: '[PRE18]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Check the logs, as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 查看日志，如下所示：
- en: '[PRE19]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With that, you have learned how to run a particular task using a `TaskRun` object.
    You also know how to reuse and create a custom task. We will use this knowledge
    to create our first pipeline.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个，你已经学会了如何使用`TaskRun`对象运行特定任务。你也知道如何重用并创建自定义任务。我们将利用这些知识来创建我们的第一个管道。
- en: Pipelines
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管道
- en: In this section, we will create our first meaningful pipeline! I like to compare
    a pipeline’s design to a LEGO® set, in which you need to have all the pieces at
    hand before assembling it. If the LEGO set is too big to assemble at once, you
    need to break it into smaller blocks of meaningful parts. In our pipeline, the
    *LEGO pieces* are the **tasks** that we have already built and the ones we will
    reuse. We have all we need, so *let’s assemble our LEGO set*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将创建我们的第一个有意义的管道！我喜欢把管道的设计比作一个乐高®玩具套件，在组装之前，你需要手头有所有的零件。如果乐高套件太大，无法一次性组装完成，你需要将它分解成更小、更有意义的部分。在我们的管道中，*乐高零件*是我们已经构建的任务以及我们将要重用的任务。我们已经拥有所需的一切，那么*让我们组装我们的乐高套件*吧。
- en: 'We will use our example to understand how to define a pipeline object. The
    first part of any pipeline is its metadata:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过我们的示例来理解如何定义一个管道对象。任何管道的第一部分是其元数据：
- en: '[PRE20]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The next part is its specification (`spec`), which is composed of the following
    items:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分是它的规格（`spec`），包括以下项目：
- en: '**Workspaces**: This is a shared workspace that’s required to store the source
    code and any other pipeline artifacts that need to be passed between the tasks:'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作区**：这是一个共享工作区，用于存储源代码和需要在任务之间传递的其他管道工件：'
- en: '[PRE21]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Parameters**: These are the input parameters that are required to run the
    pipeline:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数**：这些是运行管道所需的输入参数：'
- en: '[PRE22]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`taskRef` (the reference to the task that will be used), as follows:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`taskRef`（将使用的任务的引用），如下所示：'
- en: '[PRE23]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For `kind` attribute within the `taskRef` group, like so:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`taskRef`组中的`kind`属性，如下所示：
- en: '[PRE24]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can find the complete pipeline at [https://github.com/PacktPublishing/OpenShift-Multi-Cluster-Management-Handbook/blob/main/chapter06](https://github.com/PacktPublishing/OpenShift-Multi-Cluster-Management-Handbook/blob/main/chapter06).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/PacktPublishing/OpenShift-Multi-Cluster-Management-Handbook/blob/main/chapter06](https://github.com/PacktPublishing/OpenShift-Multi-Cluster-Management-Handbook/blob/main/chapter06)找到完整的管道。
- en: 'Now, we are ready to create our pipeline. To do so, run the following command:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备创建我们的管道。为此，运行以下命令：
- en: '[PRE25]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now that we have defined our pipeline, let’s run it!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的管道，让我们运行它吧！
- en: PipelineRun
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PipelineRun
- en: 'There are multiple ways to run the pipeline: through the OpenShift Console
    UI, using `tkn`, or by creating and applying a PipelineRun object manually. At
    the end of the day, no matter how you run it, a PipelineRun will always be created
    (the only difference is that the PipelineRun is created automatically for you
    when you use `tkn` or the web UI). For didactic reasons, we will do this using
    a `PipelineRun` object to learn about and understand it.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以运行流水线：通过 OpenShift 控制台 UI、使用 `tkn`，或者手动创建并应用 PipelineRun 对象。归根结底，无论你使用哪种方式，都会创建一个
    PipelineRun（唯一的区别是，当你使用 `tkn` 或 Web UI 时，PipelineRun 会自动为你创建）。为了教学目的，我们将通过使用 `PipelineRun`
    对象来学习和理解它。
- en: 'The following code shows our `PipelineRun` object:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了我们的 `PipelineRun` 对象：
- en: '[PRE26]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let’s look at this code in more detail:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看一下这段代码：
- en: '`PipelineRun` object'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PipelineRun` 对象'
- en: '**[2]**: The pipeline to be run'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[2]**：要运行的流水线'
- en: '**[3]**: The parameter values to be used with the pipeline'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[3]**：将与流水线一起使用的参数值'
- en: '**[4]**: The workspace’s definition'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[4]**：工作空间的定义'
- en: 'Apply the `PipelineRun` object and check the logs to see the pipeline’s execution:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 `PipelineRun` 对象并检查日志，查看流水线的执行情况：
- en: '[PRE27]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With that, you have custom tasks and a pipeline that has been tested and is
    working already. Now, let’s make it even better by using a trigger to run this
    pipeline automatically when a Git push occurs in the repository.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你就有了自定义任务和已经经过测试并正常工作的流水线。现在，我们通过使用触发器，在仓库中发生 Git 推送时自动运行这个流水线，进一步提升它的效果。
- en: Using triggers with GitHub webhooks
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GitHub Webhook 触发器
- en: 'In a CI/CD workflow, it is typical to use an event, such as a pull or push
    request on Git, to trigger a new pipeline run. With Tekton, you use **EventListeners**
    to listen for events and run one or more triggers. There are some out-of-the-box
    event processors, named **Interceptors**, for the following platforms:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CI/CD 工作流中，通常使用某个事件（如 Git 上的拉取或推送请求）来触发新的流水线运行。在 Tekton 中，你可以使用**EventListeners**来监听事件并运行一个或多个触发器。针对以下平台，提供了一些现成的事件处理器，称为**拦截器**：
- en: '**GitHub**: This allows you to validate and filter GitHub webhooks.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitHub**：这允许你验证和筛选 GitHub Webhook。'
- en: '**GitLab**: The same as the previous point but for GitLab.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitLab**：与之前提到的内容类似，不过是针对 GitLab 的设置。'
- en: '**Bitbucket**: The same as the previous points for Bitbucket.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bitbucket**：与之前提到的 Bitbucket 的设置相同。'
- en: '**CEL**: This allows you to use **Common Expression Language** (**CEL**) to
    filter and modify payloads.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CEL**：这允许你使用 **通用表达式语言**（**CEL**）来筛选和修改有效负载。'
- en: '**Webhook**: This allows you to process any webhook payload and apply any business
    logic to it.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Webhook**：这允许你处理任何 Webhook 有效负载并应用任何业务逻辑。'
- en: In our example, we will use a GitHub interceptor to process a webhook, filter
    push events, and trigger the pipeline we created previously. You can also implement
    your custom interceptors by implementing an object named `ClusterInterceptors`.
    Check out the links in the *Further reading* section if you need to create a ClusterInterceptor
    or use any interceptor other than the GitHub one that we will use in our example.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将使用 GitHub 拦截器来处理 Webhook，筛选推送事件，并触发我们之前创建的流水线。你还可以通过实现一个名为 `ClusterInterceptors`
    的对象来实现自定义拦截器。如果你需要创建 ClusterInterceptor 或使用除 GitHub 以外的任何拦截器，请查看“进一步阅读”部分中的链接。
- en: Note that the GitHub webhook requires a publicly accessible URL to send the
    HTTP webhook posts. Due to that, you will need an OpenShift cluster with a public
    IP and domain that can be accessed from the internet. That said, in this case,
    you will not be able to use CRC to test Tekton triggers using GitHub webhooks
    unless you make your CRC URL routes public on the internet.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，GitHub Webhook 需要一个公开可访问的 URL 来发送 HTTP Webhook 请求。因此，你需要一个具有公网 IP 和域名的 OpenShift
    集群，能够从互联网上访问。也就是说，在这种情况下，除非你将 CRC URL 路由公开到互联网上，否则无法使用 CRC 来测试 Tekton 触发器与 GitHub
    Webhook。
- en: What is CEL?
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 CEL？
- en: CEL is a simple but fast and portable language for expression evaluation. Created
    and maintained by some Google engineers, it is an open source project that was
    released under the Apache License and used with many Google projects and services.
    For more information, go to [https://opensource.google/projects/cel](https://opensource.google/projects/cel).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: CEL 是一种简单但快速且可移植的表达式评估语言。由一些谷歌工程师创建并维护，它是一个开源项目，已根据 Apache 许可证发布，并广泛应用于谷歌的许多项目和服务中。欲了解更多信息，请访问
    [https://opensource.google/projects/cel](https://opensource.google/projects/cel)。
- en: 'Besides the **EventListener**, a Tekton trigger is composed of several other
    objects:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 **EventListener**，Tekton 触发器还由其他几个对象组成：
- en: '**Trigger**: This defines which action will be performed after the EventListener
    detects a new event.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Trigger**：这定义了在 EventListener 检测到新事件后将执行的操作。'
- en: '**TriggerTemplate**: This specifies a blueprint of objects that will be applied
    as a result of the trigger, usually using a PipelineRun object, which, in turn,
    will run a pipeline.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TriggerTemplate**：这指定了作为触发器结果应用的对象蓝图，通常使用 PipelineRun 对象，该对象将运行一个管道。'
- en: '**TriggerBinding**: This defines the field data that will be extracted from
    the event payload to be used with the associated PipelineRun.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TriggerBinding**：这定义了将从事件负载中提取的字段数据，用于与相关的 PipelineRun 一起使用。'
- en: '**ClusterTriggerBinding**: This is the same as the TriggerBinding but cluster-scoped.
    It can be reused among different namespaces.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ClusterTriggerBinding**：这与 TriggerBinding 相同，但它是集群范围的。可以在不同命名空间之间重用。'
- en: 'The following objects will be used in our example:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 以下对象将用于我们的示例：
- en: '![Figure 9.11 – Tekton Trigger objects ](img/B18015_09_11.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.11 – Tekton 触发器对象](img/B18015_09_11.jpg)'
- en: Figure 9.11 – Tekton Trigger objects
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – Tekton 触发器对象
- en: Now, let’s put this into practice! You have already created the tasks and pipeline
    in your lab, so let’s create the trigger objects that will use the existing pipeline.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将其付诸实践！你已经在实验室中创建了任务和管道，接下来让我们创建将使用现有管道的触发器对象。
- en: TriggerBinding
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TriggerBinding
- en: '**TriggerBinding** will parse the data that’s been extracted from the GitHub
    payload, as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**TriggerBinding** 将解析从 GitHub 负载中提取的数据，如下所示：'
- en: '[PRE28]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let’s look at this code in more detail:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这段代码：
- en: '`TriggerBinding` object'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TriggerBinding` 对象'
- en: '**[2]**: The parameters that will be assigned according to the payload data
    fields'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[2]**：将根据负载数据字段分配的参数。'
- en: 'Use the following command to create the TriggerBinding:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建 TriggerBinding：
- en: '[PRE29]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The next object we need to create is `TriggerTemplate`. Let’s take a look.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建的下一个对象是 `TriggerTemplate`。让我们来看看。
- en: TriggerTemplate
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TriggerTemplate
- en: '`TriggerTemplate` will create a PipelineRun that executes our sample pipeline:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`TriggerTemplate` 将创建一个 PipelineRun 来执行我们的示例管道：'
- en: '[PRE30]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let’s look at this code in more detail:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这段代码：
- en: '`TriggerTemplate` object'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TriggerTemplate` 对象'
- en: '`TriggerBinding` object'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TriggerBinding` 对象'
- en: '**[3]**: The objects that will be created as a result of the trigger'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[3]**：作为触发器结果将创建的对象。'
- en: 'Use the following command to create the `TriggerTemplate` object:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建 `TriggerTemplate` 对象：
- en: '[PRE31]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Finally, we can create the `Trigger` object, which uses all the objects we have
    created.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以创建 `Trigger` 对象，它将使用我们已经创建的所有对象。
- en: Trigger
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Trigger
- en: 'The `Trigger` object will be the glue between the GitHub interceptor, `TriggerBinding`,
    and `TriggerTemplate`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`Trigger` 对象将作为 GitHub 拦截器、`TriggerBinding` 和 `TriggerTemplate` 之间的连接：'
- en: '[PRE32]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let’s look at this code in more detail:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这段代码：
- en: '`Trigger` object.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trigger` 对象。'
- en: '**[2]**: The list of event interceptors to be used to trigger the actions.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[2]**：将用于触发操作的事件拦截器列表。'
- en: '**[3]**: The interceptor from GitHub.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[3]**：来自 GitHub 的拦截器。'
- en: '**[4]**: The secret that’s been configured in the GitHub webhook.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[4]**：在 GitHub webhook 中配置的 secret。'
- en: '**[5]**: The trigger event types that Tekton will react to. In this case, it
    will be GitHub “push” events.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[5]**：Tekton 将响应的触发事件类型。在此情况下，它将是 GitHub 的“push”事件。'
- en: '`TriggerBinding` object that will be used with this trigger.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将与此触发器一起使用的 `TriggerBinding` 对象。
- en: '`TriggerTemplate` object that will be used with this trigger.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将与此触发器一起使用的 `TriggerTemplate` 对象。
- en: 'The following code shows an example of the GitHub secret (**[4]**):'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了 GitHub secret 的示例 (**[4]**)：
- en: '[PRE33]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Use the following command to create the secret and trigger:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建 secret 和触发器：
- en: '[PRE34]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The last object we need to create to put the trigger into practice is `EventListener`.
    Let’s take a look.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建的最后一个对象是 `EventListener`，它将使触发器生效。让我们来看看。
- en: EventListener
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EventListener
- en: 'Finally, we need to create an **EventListener** object that will listen for
    HTTP requests and be used with the GitHub webhook configuration. We will learn
    how to configure the GitHub webhook soon:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要创建一个 **EventListener** 对象，它将监听 HTTP 请求并与 GitHub webhook 配置一起使用。我们很快就会学习如何配置
    GitHub webhook：
- en: '[PRE35]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let’s look at this code in more detail:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这段代码：
- en: '`EventListener` object'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventListener` 对象'
- en: '`EventListener` object is sensitized'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventListener` 对象已激活'
- en: 'Run the following command to create the `EventListener` object:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令来创建 `EventListener` 对象：
- en: '[PRE36]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`EventListener` will create a service on OpenShift that you need to expose
    externally. The route URL that’s generated will be used during the GitHub webhook
    configuration:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventListener` 会在 OpenShift 上创建一个服务，你需要将其暴露到外部。生成的路由 URL 将在 GitHub webhook
    配置过程中使用：'
- en: '[PRE37]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, we are ready to configure a new GitHub webhook that will use the `EventListener`
    object we just created to fire Tekton’s trigger.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备配置一个新的 GitHub webhook，它将使用我们刚刚创建的 `EventListener` 对象来触发 Tekton 的 trigger。
- en: Creating a GitHub webhook
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 GitHub webhook
- en: 'To create a webhook, you need to fork our GitHub repository. If you haven’t
    forked it yet, do so now in your personal GitHub account: [https://github.com/PacktPublishing/OpenShift-Multi-Cluster-Management-Handbook](https://github.com/PacktPublishing/OpenShift-Multi-Cluster-Management-Handbook).'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建 webhook，你需要 fork 我们的 GitHub 仓库。如果你还没有 fork，可以在你的个人 GitHub 账户中现在就进行：[https://github.com/PacktPublishing/OpenShift-Multi-Cluster-Management-Handbook](https://github.com/PacktPublishing/OpenShift-Multi-Cluster-Management-Handbook)。
- en: 'Open the GitHub forked repository and go to **Settings** | **Webhook**. On
    the following page, click on the **Add webhook** button:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 GitHub fork 的仓库并进入 **Settings** | **Webhook**。在接下来的页面上，点击 **Add webhook**
    按钮：
- en: '![Figure 9.12 – Adding a webhook on GitHub ](img/B18015_09_12.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.12 – 在 GitHub 上添加 webhook](img/B18015_09_12.jpg)'
- en: Figure 9.12 – Adding a webhook on GitHub
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – 在 GitHub 上添加 webhook
- en: 'Fill out the form by providing the following information:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 填写表单并提供以下信息：
- en: '**Payload URL**: The route URL we created in the previous section. You can
    get this URL by running the following command:'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Payload URL**：我们在前一部分创建的路由 URL。你可以通过运行以下命令获取此 URL：'
- en: '[PRE38]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`application/json`.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application/json`。'
- en: '`tekton`):'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tekton`):'
- en: '![Figure 9.13 – Adding a webhook on GitHub ](img/B18015_09_13.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.13 – 在 GitHub 上添加 webhook](img/B18015_09_13.jpg)'
- en: Figure 9.13 – Adding a webhook on GitHub
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13 – 在 GitHub 上添加 webhook
- en: 'After a few seconds, you should see a green check mark next to the webhook
    we created:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，你应该能看到我们创建的 webhook 旁边出现一个绿色的勾号：
- en: '![Figure 9.14 – Webhook added ](img/B18015_09_14.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.14 – 已添加 webhook](img/B18015_09_14.jpg)'
- en: Figure 9.14 – Webhook added
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.14 – 已添加 webhook
- en: Now that we have our `Trigger` objects from the Tekton side and the webhook
    configured on GitHub, let’s test it!
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经在 Tekton 侧配置了 `Trigger` 对象，并在 GitHub 上配置了 webhook，接下来进行测试！
- en: Testing the Tekton trigger
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 Tekton trigger
- en: 'Run a `commit` and push the trigger to the webhook event, like so:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `commit` 并将 trigger 推送到 webhook 事件，如下所示：
- en: '[PRE39]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Access the `push` command has been run:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 访问已运行 `push` 命令：
- en: '![Figure 9.15 – PipelineRun on Red Hat ](img/B18015_09_15.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.15 – 在 Red Hat 上的 PipelineRun](img/B18015_09_15.jpg)'
- en: Figure 9.15 – PipelineRun on Red Hat
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.15 – 在 Red Hat 上的 PipelineRun
- en: Congratulations – you have successfully created a CI/CD pipeline on Tekton and
    ran it automatically after a Git push event using a trigger! To wrap up this chapter,
    we will enhance our pipeline by adding a validation task for YAML files using
    the YAML linter tool.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你！你已经成功在 Tekton 上创建了一个 CI/CD 管道，并在 Git push 事件触发后自动运行了它！为了总结本章内容，我们将通过使用 YAML
    linter 工具添加一个 YAML 文件验证任务来增强我们的管道。
- en: 'To do so, let’s use Tekton Hub to find a reusable task. Go to [https://hub.tekton.dev/](https://hub.tekton.dev/)
    and search for YAML using the search box at the top right of the screen:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将使用 Tekton Hub 查找一个可重用的任务。访问 [https://hub.tekton.dev/](https://hub.tekton.dev/)，并在屏幕右上角的搜索框中搜索
    YAML：
- en: '![Figure 9.16 – Tekton Hub ](img/B18015_09_16.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.16 – Tekton Hub](img/B18015_09_16.jpg)'
- en: Figure 9.16 – Tekton Hub
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.16 – Tekton Hub
- en: 'Click the **YAML linter** task to find the instructions on how to install and
    use it:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **YAML linter** 任务以查看如何安装和使用它的说明：
- en: '![Figure 9.17 – YAML linter ](img/B18015_09_17.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.17 – YAML linter](img/B18015_09_17.jpg)'
- en: Figure 9.17 – YAML linter
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.17 – YAML linter
- en: 'This time, we will use the **Pipeline Builder** page to add the YAML linter
    task. To do so, access the OpenShift UI and select the **Developer** console:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们将使用 **Pipeline Builder** 页面来添加 YAML linter 任务。为此，访问 OpenShift UI 并选择 **Developer**
    控制台：
- en: '![Figure 9.18 – Developer console ](img/B18015_09_18.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.18 – 开发者控制台](img/B18015_09_18.jpg)'
- en: Figure 9.18 – Developer console
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.18 – 开发者控制台
- en: 'Now, perform the following steps:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行以下步骤：
- en: 'Access the `build-and-deploy` pipeline:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 `build-and-deploy` 管道：
- en: '![Figure 9.19 – The Pipelines menu ](img/B18015_09_19.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.19 – Pipelines 菜单](img/B18015_09_19.jpg)'
- en: Figure 9.19 – The Pipelines menu
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.19 – Pipelines 菜单
- en: 'Now, click the **Actions** button and then **Edit Pipeline**:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击 **Actions** 按钮，然后点击 **Edit Pipeline**：
- en: '![Figure 9.20 – The build-and-deploy pipeline ](img/B18015_09_20.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.20 – 构建和部署管道](img/B18015_09_20.jpg)'
- en: Figure 9.20 – The build-and-deploy pipeline
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.20 – 构建和部署管道
- en: 'On the following screen, click on the **fetch-repository** box and then the
    **+** sign next to it:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接下来的屏幕上，点击 **fetch-repository** 框，然后点击它旁边的 **+** 按钮：
- en: '![Figure 9.21 – The Pipeline builder feature ](img/B18015_09_21.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.21 – 流水线构建器功能](img/B18015_09_21.jpg)'
- en: Figure 9.21 – The Pipeline builder feature
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.21 – 流水线构建器功能
- en: 'Select the `yaml lint`, and click the **Install and add** button:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `yaml lint`，然后点击 **安装并添加** 按钮：
- en: '![Figure 9.22 – Adding a new task using the Pipeline builder feature ](img/B18015_09_22.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.22 – 使用流水线构建器功能添加新任务](img/B18015_09_22.jpg)'
- en: Figure 9.22 – Adding a new task using the Pipeline builder feature
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.22 – 使用流水线构建器功能添加新任务
- en: 'The new task should have been added. You should see an exclamation mark next
    to it:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新任务应该已经添加。你应该能看到它旁边有一个感叹号：
- en: '![Figure 9.23 – Adding a new task using the Pipeline builder feature ](img/B18015_09_23.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.23 – 使用流水线构建器功能添加新任务](img/B18015_09_23.jpg)'
- en: Figure 9.23 – Adding a new task using the Pipeline builder feature
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.23 – 使用流水线构建器功能添加新任务
- en: 'Now, click it and input `./sample-go-app/clouds-api/k8s` as the `shared-workspace`
    as the **Workspaces** group:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击它并输入 `./sample-go-app/clouds-api/k8s` 作为 **Workspaces** 组中的 `shared-workspace`：
- en: '![Figure 9.24 – Setting the yaml-lint task’s parameters ](img/B18015_09_24.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.24 – 设置 yaml-lint 任务的参数](img/B18015_09_24.jpg)'
- en: Figure 9.24 – Setting the yaml-lint task’s parameters
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.24 – 设置 yaml-lint 任务的参数
- en: Now, click on **Save**.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击 **保存**。
- en: 'At this point, our pipeline has a new step that validates the YAML content
    of our Kubernetes manifest files. To test our previous change, let’s run it from
    the same web UI. To do so, click the **Actions** menu from the **Pipeline details**
    screen and select the **Start** action:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，我们的流水线有了一个新步骤，用于验证 Kubernetes 清单文件的 YAML 内容。为了测试我们之前的更改，让我们从相同的 Web UI 中运行它。为此，请点击
    **Pipeline details** 屏幕上的 **Actions** 菜单，并选择 **Start** 动作：
- en: '![Figure 9.25 – Running the pipeline from the Developer console ](img/B18015_09_25.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.25 – 从开发者控制台运行流水线](img/B18015_09_25.jpg)'
- en: Figure 9.25 – Running the pipeline from the Developer console
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.25 – 从开发者控制台运行流水线
- en: Fill out the form by using the following values and click `clouds-api`
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下值填写表单并点击 `clouds-api`：
- en: '**git-url**: <Your forked repository>'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**git-url**: <Your forked repository>'
- en: '`main`'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main`'
- en: '`image-registry.openshift-image-registry.svc:5000/pipelines-sample/clouds-api`'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`image-registry.openshift-image-registry.svc:5000/pipelines-sample/clouds-api`'
- en: '`./sample-go-app/clouds-api/`'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`./sample-go-app/clouds-api/`'
- en: '`VolumeClaimTemplate`:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`VolumeClaimTemplate`：'
- en: '![Figure 9.26 – PipelineRun parameters ](img/B18015_09_26.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.26 – PipelineRun 参数](img/B18015_09_26.jpg)'
- en: Figure 9.26 – PipelineRun parameters
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.26 – PipelineRun 参数
- en: 'Check the `PipelineRun` object on the following screen. You will get an error
    regarding the new **yaml-lint** task we added:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查以下屏幕上的 `PipelineRun` 对象，你会看到关于我们添加的新 **yaml-lint** 任务的错误：
- en: '![Figure 9.27 – PipelineRun failed due to YAML linter validations ](img/B18015_09_27.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.27 – 因 YAML linter 校验失败而导致的 PipelineRun 失败](img/B18015_09_27.jpg)'
- en: Figure 9.27 – PipelineRun failed due to YAML linter validations
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.27 – 因 YAML linter 校验失败而导致的 PipelineRun 失败
- en: 'Click the **yaml-lint** step and check out the logs to find the issue:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **yaml-lint** 步骤并查看日志以找到问题：
- en: '![Figure 9.28 – PipelineRun failed due to YAML linter validations ](img/B18015_09_28.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.28 – 因 YAML linter 校验失败而导致的 PipelineRun 失败](img/B18015_09_28.jpg)'
- en: Figure 9.28 – PipelineRun failed due to YAML linter validations
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.28 – 因 YAML linter 校验失败而导致的 PipelineRun 失败
- en: As you can see, the YAML linter detected errors in some YAML files. Those errors
    are expected and have been prepared especially for you to simulate what a real
    CI/CD pipeline looks like. Now, practice the skills you’ve just acquired to fix
    those errors and get the pipeline working again (or look at the solution in the
    next section)!
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，YAML linter 检测到了一些 YAML 文件中的错误。这些错误是预期中的，特别为你准备，以模拟真实的 CI/CD 流水线。现在，运用你刚刚学到的技能，修复这些错误并重新让流水线工作起来（或者查看下一节的解决方案）！
- en: Fixing the failed PipelineRun due to YAML issues
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复由于 YAML 问题导致的 PipelineRun 失败
- en: 'To get your pipeline working again, follow these steps:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你的流水线重新工作，按照以下步骤操作：
- en: Add `---` to the first line of all the YAML files in the`./sample-go-app/clouds-api/k8s`
    folder.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `./sample-go-app/clouds-api/k8s` 文件夹中的所有 YAML 文件的第一行添加 `---`。
- en: 'Fix the indentation of the `kustomization.yaml` file by adding two spaces at
    the beginning of all the lines after `resources`, like so:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修正 `kustomization.yaml` 文件的缩进，在 `resources` 后面的所有行前添加两个空格，如下所示：
- en: '[PRE40]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Add a new line at the end of the `service.yaml` file.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `service.yaml` 文件的末尾添加一行。
- en: 'Commit and push the changes:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交并推送更改：
- en: '[PRE41]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: A new PipelineRun should be triggered automatically and complete.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的 PipelineRun 应该自动触发并完成。
- en: Summary
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we dived into Tekton, from installing it on OpenShift to using
    it. You learned how to create custom tasks, reuse existing ones, build a pipeline,
    and then run it. You also learned how to set a trigger to run the pipeline when
    a push event occurs in your GitHub repository. The objects you have seen in this
    chapter are the main ones you will use to create most Tekton pipelines.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们深入了解了 Tekton，从在 OpenShift 上安装到使用它。你学习了如何创建自定义任务、重用现有任务、构建流水线并运行它。你还学习了如何设置触发器，在你的
    GitHub 仓库中发生推送事件时运行流水线。本章中介绍的对象是你在创建大多数 Tekton 流水线时将使用的主要对象。
- en: In the next chapter, we will bring more power to your CI/CD process by adding
    **Argo CD** and **GitOps** to your pipelines. We will also start looking at ways
    to deploy applications into multiple clusters at once. Let’s get started and take
    a deeper dive into OpenShift GitOps!
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将通过将**Argo CD**和**GitOps**添加到你的流水线中，进一步增强你的 CI/CD 流程。我们还将开始探索如何将应用程序一次性部署到多个集群中。让我们开始，并深入了解
    OpenShift GitOps！
- en: Further reading
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'If you want to learn more about what we covered in this chapter, check out
    the following references:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于本章内容的信息，可以查看以下参考资料：
- en: '*OpenShift Pipelines official documentation:* [https://docs.openshift.com/container-platform/4.9/cicd/pipelines/understanding-openshift-pipelines.html](https://docs.openshift.com/container-platform/4.9/cicd/pipelines/understanding-openshift-pipelines.html)'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*OpenShift Pipelines 官方文档:* [https://docs.openshift.com/container-platform/4.9/cicd/pipelines/understanding-openshift-pipelines.html](https://docs.openshift.com/container-platform/4.9/cicd/pipelines/understanding-openshift-pipelines.html)'
- en: '*Tekton official documentation:* [https://tekton.dev/docs/](https://tekton.dev/docs/)'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Tekton 官方文档:* [https://tekton.dev/docs/](https://tekton.dev/docs/)'
- en: '*How to create custom interceptors using* **ClusterInterceptor**: [https://tekton.dev/docs/triggers/clusterinterceptors/](https://tekton.dev/docs/triggers/clusterinterceptors/)'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如何使用**ClusterInterceptor**创建自定义拦截器:* [https://tekton.dev/docs/triggers/clusterinterceptors/](https://tekton.dev/docs/triggers/clusterinterceptors/)'
- en: '*Tekton Hub (a collection of reusable tasks):* [https://hub.tekton.dev/](https://hub.tekton.dev/)'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Tekton Hub（可重用任务集合）:* [https://hub.tekton.dev/](https://hub.tekton.dev/)'
