- en: Separation of Code and Data with Hiera
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Hiera 实现代码与数据的分离
- en: Working through the first seven chapters, you have used the basic structural
    elements of Puppet in numerous examples and contexts. There has been a quick demonstration
    of the more advanced language features, and you should have a good idea of what
    distinguishes the manifest writing process in Puppet 4 from those of the earlier
    releases.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前七章的学习中，你已经在多个示例和场景中使用了 Puppet 的基本结构元素。你也对更高级的语言特性有了快速的了解，并应该对 Puppet 4 中的清单编写过程与早期版本之间的区别有了清晰的认识。
- en: For all their expressive power, manifests do have some limitations. A manifest
    that is designed by the principles taught up to this point mixes logic with data.
    Logic is not only evident in control structures, such as `if` and `else`, but
    it also emerges from the network of classes and defines that include and instantiate
    one another.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管清单文件具有强大的表达能力，但它们确实有一些局限性。一个按照目前所学原则设计的清单文件将逻辑与数据混合。逻辑不仅体现在控制结构中（如`if`和`else`），它还出现在类和定义的网络中，这些类和定义相互包含和实例化。
- en: 'However, you cannot configure a machine by just including some generic classes.
    Many properties of a given system are individual and must be passed as parameters.
    This can have maintenance implications for a manifest that must accommodate a
    large number of nodes. This chapter will teach you how to bring order back to
    such complex code bases. In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅仅包含一些通用类是无法配置一台机器的。给定系统的许多属性都是个别的，必须作为参数传递。这对于必须容纳大量节点的清单文件可能会带来维护上的问题。本章将教你如何在这种复杂的代码基础上恢复秩序。在本章中，我们将涵盖以下主题：
- en: Understanding the need for separate data storage
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解需要独立的数据存储
- en: Building hierarchical data structures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建层次化数据结构
- en: Fetching data from classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从类中获取数据
- en: Debugging data lookups
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试数据查找
- en: Managing resources from data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据管理资源
- en: Data in modules and environments
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块和环境中的数据
- en: Understanding the need for separate data storage
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解需要独立的数据存储
- en: Looking back at what you have implemented during this book so far, you have
    managed to create some very versatile code that did very useful things in an automatic
    fashion. Your nodes can distribute entries for `/etc/hosts` among themselves.
    They register each other's public SSH key for authentication. A node can automatically
    register itself to a central Cacti server.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾你在本书中迄今为止的实现，你已经创建了一些非常通用的代码，能够以自动化的方式完成非常有用的任务。你的节点可以在它们之间分发 `/etc/hosts`
    的条目。它们为彼此注册公钥以进行身份验证。一个节点可以自动注册到中央 Cacti 服务器。
- en: Thanks to Facter, Puppet has the information that allows the effortless handling
    of these use cases. Many configuration items are unique to each node only because
    they refer to a detail (such as an IP address or a generated key) that is already
    defined. Sometimes, the required configuration data can only be found on a remote
    machine, which Puppet handles through exported resources. Such manifest designs
    that can rely on facts are very economical. The information has already been gathered,
    and a single class can most likely behave correctly for many or all of your nodes,
    and can manage a common task in a graceful manner.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 Facter，Puppet 拥有能够轻松处理这些使用案例的信息。许多配置项对于每个节点都是唯一的，因为它们引用的是已经定义的细节（如 IP 地址或生成的密钥）。有时，所需的配置数据只能在远程机器上找到，而
    Puppet 通过导出资源来处理此问题。这种可以依赖事实的清单设计非常经济。信息已经收集完成，一个类很可能能够正确地处理你的多个或所有节点，并且能够优雅地管理一个共同的任务。
- en: 'However, some configuration tasks have to be performed individually for each
    node, and these can incorporate settings that are rather arbitrary and not directly
    derived from the node''s existing properties:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一些配置任务必须为每个节点单独执行，这些任务可能包含一些相当任意的设置，并非直接来自节点的现有属性：
- en: In a complex MySQL replication setup that spans multiple servers, each participant
    requires a unique server ID. Duplicates must be prevented under any circumstances,
    so randomly generating the ID numbers is not safe
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个跨多个服务器的复杂 MySQL 复制设置中，每个参与者都需要一个唯一的服务器 ID。必须在任何情况下避免重复，因此随机生成 ID 号是不安全的
- en: Some of your networks might require regular maintenance jobs to be run from
    `cron`. Puppet should define a starting time for each machine to prevent the overlapping
    of the runs on any two machines
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的一些网络可能需要定期从`cron`运行维护任务。Puppet 应该为每台机器定义一个启动时间，以防止两个机器的运行时间重叠
- en: In server operations, you have to perform the monitoring of the disk space usage
    on all systems. Most disks should generate early warnings so that there is time
    to react. However, other disks will be expected to be almost full most of the
    time, and should have a much higher warning threshold
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器操作中，你必须监控所有系统的磁盘空间使用情况。大多数磁盘应当生成早期警告，以便有时间作出反应。然而，其他磁盘大多数时间应该接近满载，并且应该有一个更高的警告阈值。
- en: When custom-built systems and software are managed through Puppet, they are
    also likely to require this type of micromanagement for each instance. The examples
    here represent only a tiny slice of the things that Puppet must manage explicitly
    and independently.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过 Puppet 管理定制的系统和软件时，它们也可能需要对每个实例进行这种微观管理。这里的示例仅代表 Puppet 必须显式和独立管理的事务中的一小部分。
- en: Consequences of defining data in the manifest
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在清单中定义数据的后果
- en: 'There are a number of ways in which a Puppet manifest can approach this problem
    of micromanagement. The most direct way is to define whole sets of classes one
    for each individual node:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 清单有多种方法来解决这种微观管理问题。最直接的方法是为每个单独的节点定义一整套类：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is a very high-maintenance solution for the following reasons:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个需要大量维护的解决方案，原因如下：
- en: The individual classes can become quite elaborate because all required `mysql`
    class parameters have to be used in each one
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各个类可能会变得相当复杂，因为每个类中必须使用所有必需的 `mysql` 类参数。
- en: There is much redundancy among the parameters that are, in fact, identical across
    all nodes
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数之间存在大量冗余，实际上它们在所有节点中是相同的。
- en: The individually different values can be hard to spot, and must be carefully
    kept unique throughout the whole collection of classes
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单独不同的值可能很难识别，必须小心保持它们在整个类集合中的唯一性。
- en: This is only really feasible by keeping these classes close together, which
    might conflict with other organizational principles of your code base
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这只有通过将这些类保持在一起才真正可行，这可能与代码库的其他组织原则相冲突。
- en: 'In short, this is a brute-force approach that introduces its own share of cost.
    A more economic approach would be to pass the values that are different among
    nodes (and only those!) to a wrapper class:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这是一种暴力解决方案，它带来了自身的成本。一个更经济的方法是将节点之间不同的值（仅限这些！）传递给一个包装类：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This wrapper can declare the `mysql` class in a generic fashion, thanks to
    the individual parameter value per node:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包装类可以以通用方式声明 `mysql` 类，因为每个节点的参数值是独立的：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is much better because it eliminates the redundancy and its impact on maintainability.
    The wrinkle is that the `node` blocks can become quite messy with parameter assignments
    for many different subsystems. Explanatory comments contribute to the wall of
    text that each `node` block can become.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做要好得多，因为它消除了冗余及其对可维护性的影响。问题在于，`node` 块可能会变得相当杂乱，因为涉及到许多不同子系统的参数赋值。解释性注释进一步增加了每个
    `node` 块可能成为的文字墙。
- en: You can take this a step further by defining lookup tables in hash variables,
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以进一步扩展，通过在哈希变量中定义查找表。
- en: 'outside of any `node` or `class`, on the global scope:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何 `node` 或 `class` 之外，在全局范围内：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This alleviates the need to declare any variables in `node` blocks. The classes
    look up the values directly from the hash:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这减少了在 `node` 块中声明任何变量的需求。类直接从哈希中查找这些值：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is pretty sophisticated, and is actually close to the even better way that
    you will learn about later in this chapter. Note that this approach still retains
    a leftover possibility of redundancy. Some configuration values are likely to
    be identical among all nodes that belong to one group, but are unique to each
    group (for example, preshared keys of any variety).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当复杂，实际上接近本章稍后你将学习的更好方法。请注意，这种方法仍然保留了冗余的可能性。某些配置值在属于同一组的所有节点之间可能是相同的，但对于每个组来说是唯一的（例如，各种类型的预共享密钥）。
- en: 'This requires that all servers in the hypothetical `xndp12` cluster contain
    some key-value pairs that are identical for all members:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这要求假设的 `xndp12` 集群中的所有服务器包含一些对于所有成员都是相同的键值对：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is not ideal, but let's stop here. There is no point in worrying about
    even more elaborate ways to sort configuration data into recursive hash structures.
    Such solutions will quickly grow very difficult to understand and maintain anyway.
    The silver bullet is an external database that holds all individual and shared
    values. Before I go into the details of using Hiera for just this purpose, let's
    discuss the general ideas of hierarchical data storage.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不理想，但我们先停在这里。没有必要再担心更复杂的方式来将配置数据排序到递归的哈希结构中。这样的解决方案会迅速变得难以理解和维护。有效的解决方案是一个外部数据库，保存所有单独的和共享的值。在我详细介绍如何使用
    Hiera 来实现这一目的之前，让我们先讨论一下层次数据存储的一般概念。
- en: Building hierarchical data structures
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建层次结构数据结构
- en: In the previous section, we reduced the data problem to a simple need for key-value
    pairs that are specific to each node under Puppet management. Puppet and its manifests
    then serve as the engine that generates actual configuration from these minimalistic
    bits of information.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们将数据问题简化为对每个 Puppet 管理节点特定的键值对的需求。Puppet 及其清单作为引擎，根据这些简化的信息生成实际的配置。
- en: 'A simplistic approach to this problem is an `ini` style configuration file
    that has a section for each node that sets values for all configurable keys. Shared
    values will be declared in one or more general sections:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种简化方法是使用`ini`风格的配置文件，它为每个节点提供一个设置所有可配置键值的部分。共享值将在一个或多个通用部分中声明：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Rails applications customarily do something similar and store their configuration
    in a YAML format. The user can define different environments, such as `production`,
    `staging`, and `testing`. The values that are defined per environment override
    the global setting values.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Rails 应用程序通常会做类似的事情，并将它们的配置存储在 YAML 格式中。用户可以定义不同的环境，如`生产`、`预发布`和`测试`。每个环境中定义的值会覆盖全局设置值。
- en: This is quite close to the type of hierarchical configuration that Puppet allows
    through its Hiera binding. The hierarchies that the aforementioned Rails applications
    and `ini` files achieve through configuration environments are quite flat there
    is a global layer and an overlay for specialized configuration. With Hiera and
    Puppet, a single configuration database will typically handle whole clusters of
    machines and entire networks of such clusters. This implies the need for a more
    elaborate hierarchy.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 Puppet 通过 Hiera 绑定允许的层次结构配置非常相似。上述 Rails 应用程序和`ini`文件通过配置环境实现的层次结构相当简单，只有一个全局层和一个用于专业配置的覆盖层。而使用
    Hiera 和 Puppet 时，一个配置数据库通常会处理整台机器群集和整个机器群集的网络。这就意味着需要一个更复杂的层次结构。
- en: 'Hiera allows you to define your own hierarchical layers. There are some typical,
    proven examples, which are found in many configurations out there:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Hiera 允许你定义自己的层次结构层。有一些典型的、经过验证的示例，这些示例可以在许多配置中找到：
- en: The `common` layer holds default values for all agents
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`公共`层保存所有代理的默认值'
- en: A `location` layer can override some values in accordance with the data center
    that houses each respective node
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`位置`层可以根据托管每个节点的数据中心覆盖某些值'
- en: Each agent machine typically fills a distinct `role` in your infrastructure,
    such as `wordpress_appserver` or `puppetdb_server`
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每台代理机器通常在你的基础设施中扮演一个不同的`角色`，例如`wordpress_appserver`或`puppetdb_server`
- en: Some configurations are specific to each single `machine`
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些配置是特定于每台`机器`的
- en: For example, consider the configuration of a hypothetical reporting client.
    Your `common` layer will hold lots of presets, such as default verbosity settings,
    the transport compression option, and other choices that should work for most
    machines. On the `location` layer, you ensure that each machine checks in to the
    respective local server reporting should not use WAN resources.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个假设的报告客户端的配置。你的`公共`层将保存许多预设值，如默认的详细程度设置、传输压缩选项以及其他适用于大多数机器的选择。在`位置`层，你确保每台机器都检查到相应的本地服务器，报告时不应使用
    WAN 资源。
- en: Settings per role are perhaps the most interesting part. They allow fine-grained
    settings that are specific to a class of servers. Perhaps your application servers
    should monitor their memory consumption in very close intervals. For the database
    servers, you will want a closer view of hard drive operations and performance.
    For your Puppet servers, there might be special plugins that gather specific data.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 每个角色的设置可能是最有趣的部分。它们允许针对特定服务器类别的精细设置。也许您的应用服务器应当以非常短的时间间隔监控其内存消耗。对于数据库服务器，您可能希望更密切地观察硬盘操作和性能。对于
    Puppet 服务器，可能需要特殊插件来收集特定数据。
- en: The `machine` layer is very useful in declaring any exceptions to the rule.
    There are always some machines that require special treatment for one reason or
    another. With a top hierarchy layer that holds data for each single agent, you
    get full control over all the data that an agent uses.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`machine` 层在声明规则的任何例外时非常有用。总有一些机器因某种原因需要特殊处理。通过一个顶层层次结构，它为每个代理存储数据，从而使您完全控制代理使用的所有数据。'
- en: These ideas are still quite abstract, so let's finally look at the actual application
    of Hiera.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念仍然相当抽象，因此我们最后来看看 Hiera 的实际应用。
- en: Configuring Hiera
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Hiera
- en: The support for retrieving data values from Hiera has been built into Puppet
    since version 3\. All you need in order to get started is a `hiera.yaml` file
    in the configuration directory.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Puppet 3 版本起，已内置支持从 Hiera 中检索数据值。您需要做的就是在配置目录中放置一个 `hiera.yaml` 文件。
- en: Of course, the location and name of the configuration is customizable, as is
    almost everything that is related to configuration. Look for the `hiera_config`
    setting.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，配置的位置和名称是可定制的，几乎与配置相关的所有内容都可以定制。请查看 `hiera_config` 设置。
- en: 'As the filename extension suggests, the configuration is in the YAML format
    and contains a hash with keys for the backends, the hierarchy, and backend-specific
    settings. The keys are noted as Ruby symbols with a leading colon:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如文件名扩展名所示，配置采用 YAML 格式，并包含一个哈希值，哈希中的键对应后端、层次结构和特定后端的设置。键使用 Ruby 符号表示，并以冒号开头：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that the value of `:backends` is actually a single-element array. You can
    pick multiple backends. The significance will be explained later. The `:hierarchy`
    value contains a list of the actual layers that were described earlier. Each entry
    is the name of a data source. When Hiera retrieves a value, it searches each data
    source in turn. The `%{}` expression allows you to access the values of Puppet
    variables. Use only facts or global scope variables here; anything else will make
    Hiera's behavior quite confusing.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`:backends` 的值实际上是一个单元素数组。您可以选择多个后端。稍后会解释其意义。`:hierarchy` 的值包含先前描述的实际层次结构的列表。每个条目都是数据源的名称。当
    Hiera 检索一个值时，它会依次搜索每个数据源。`%{}` 表达式允许您访问 Puppet 变量的值。这里只能使用事实或全局作用域变量；其他变量将使 Hiera
    的行为变得非常混乱。
- en: Finally, you will need to include configurations for each of your backends.
    The preceding configuration uses the YAML backend only, so there is only a hash
    for `:yaml` with the one supported `:datadir` key. This is where Hiera will expect
    to find YAML files with data. For each data source, the `datadir` can contain
    one `.yaml` file. As the names of the sources are dynamic, you will typically
    create more than four or five data source files. Let's create some examples before
    we have a short discussion on the combination of multiple backends.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要为每个后端包含配置。上述配置只使用了 YAML 后端，因此只有一个 `:yaml` 的哈希，里面包含一个支持的 `:datadir` 键。这是
    Hiera 期望找到包含数据的 YAML 文件的位置。对于每个数据源，`datadir` 可以包含一个 `.yaml` 文件。由于源的名称是动态的，通常会创建四个或五个以上的数据源文件。在我们简短讨论多个后端的组合之前，让我们先创建一些示例。
- en: Hiera version 5 was released with Puppet 4.9\. This new version of Hiera uses
    another layout of the configuration file and offers more flexibility. We will
    first introduce Hiera 3, prior to explaining the setup, migration, and additional
    features of Hiera 5, as most of the basic concepts are identical.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Hiera 5 在 Puppet 4.9 中发布。Hiera 的新版本使用了另一种配置文件的布局，并提供了更多的灵活性。在解释 Hiera 5 的设置、迁移和额外功能之前，我们将首先介绍
    Hiera 3，因为大多数基本概念是相同的。
- en: Storing Hiera data
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储 Hiera 数据
- en: 'The backend of your Hiera setup determines how you have to store your configuration
    values. For the YAML backend, you fill `datadir` with files that each hold a hash
    of values. Let''s put some elements of the reporting engine configuration into
    the example hierarchy:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 Hiera 配置的后端决定了你如何存储配置值。对于 YAML 后端，你需要将 `datadir` 填充为包含每个值哈希的文件。让我们将一些报告引擎配置元素放入示例层次结构中：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The values in `common.yaml` are defaults that are used for all agents. They
    are at the broad base of the hierarchy. Values that are specific to a `location`
    or `role` apply to smaller groups of your agents. For example, the database servers
    of the `postgres` role should run some special reporting plugins:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`common.yaml` 中的值是适用于所有代理的默认值。它们位于层次结构的广泛基础处。特定于某个 `location` 或 `role` 的值适用于你的代理的小组。例如，`postgres`
    角色的数据库服务器应该运行一些特殊的报告插件：'
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'On such a high layer, you can also override the values from the lower layers.
    For example, a role-specific data source, such as `role/postgres.yaml`, can set
    a value for `reporting::server_port` as well. The layers are searched from the
    most to the least specific, and the first value is used. This is why it is a good
    idea to have a node-specific data source at the top of the hierarchy. On this
    layer, you can override any value for each agent. In this example, the reporting
    node can use the loopback interface to reach itself:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在如此高的层次上，你还可以覆盖低层次的值。例如，特定于角色的数据源，如 `role/postgres.yaml`，也可以为 `reporting::server_port`
    设置一个值。层次结构会从最具体到最不具体进行搜索，并使用第一个值。这就是为什么在层次结构的最上层有一个特定于节点的数据源是个好主意。在这一层，你可以为每个代理覆盖任何值。在这个例子中，报告节点可以使用回环接口访问自己：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Each agent receives a patchwork of configuration values according to the concrete
    YAML files that make up its specific hierarchy.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 每个代理根据构成其特定层次结构的具体 YAML 文件接收一个配置值的拼贴。
- en: Don't worry if all this feels a bit overwhelming; there are more examples in
    this chapter. Hiera also has the charming characteristic of seeming rather complicated
    on paper, but it feels very natural and intuitive once you try using it yourself.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一切让你感到有些不知所措，不用担心；本章还有更多的示例。Hiera 也有一个迷人的特点，表面看起来似乎很复杂，但一旦你自己尝试使用，它会感觉非常自然且直观。
- en: Choosing your backends
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择你的后端
- en: 'There are two built-in backends: YAML and JSON. This chapter will focus on
    YAML, because it''s a very convenient and efficient form of data notation. The
    JSON backend is very similar to YAML. It looks for data in `.json` files instead
    of `.yaml` for each data source; these files use a different data notation format.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个内置的后端：YAML 和 JSON。本章将重点介绍 YAML，因为它是一种非常方便且高效的数据表示形式。JSON 后端与 YAML 非常相似。它查找
    `.json` 文件中的数据，而不是每个数据源的 `.yaml` 文件；这些文件使用不同的数据表示格式。
- en: The use of multiple backends should never be truly necessary. In most cases,
    a well thought-out hierarchy will suffice for your needs. With a second backend,
    data lookup will traverse your hierarchy once per backend. This means that the
    lowest level of your primary backend will rank higher than any layer from additional
    backends.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个后端通常不是真正必要的。在大多数情况下，精心设计的层次结构足以满足你的需求。使用第二个后端时，数据查找将针对每个后端遍历一次你的层次结构。这意味着主后端的最低层将高于任何附加后端的层次。
- en: In some cases, it might be worthwhile to add another backend just to get the
    ability to define even more basic defaults in an alternative location perhaps
    a distributed filesystem or a source control repository with different commit
    privileges.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，添加另一个后端可能是值得的，这样可以在不同的位置（比如分布式文件系统或具有不同提交权限的源代码控制库）定义更基础的默认值。
- en: Also, note that you can add custom backends to Hiera, so these might also be
    sensible choices for secondary or even tertiary backends. A Hiera backend is written
    in Ruby, like the Puppet plugins. The details of creating such a backend are beyond
    the scope of this book.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，你可以为 Hiera 添加自定义后端，因此这些也可能是二级甚至三级后端的合理选择。Hiera 后端是用 Ruby 编写的，就像 Puppet
    插件一样。创建这种后端的详细过程超出了本书的范围。
- en: A particularly popular backend plugin is `eyaml`, available through the `hiera-eyaml`
    Ruby gem. This backend allows you to incorporate encrypted strings in your YAML
    data. Puppet decrypts the data upon retrieval.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特别受欢迎的后端插件是 `eyaml`，可以通过 `hiera-eyaml` Ruby gem 获得。这个后端允许你在 YAML 数据中加入加密字符串。Puppet
    在检索时解密数据。
- en: With Puppet 5, the eyaml plugin is already part of the Puppet build OS packages.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puppet 5 中，eyaml 插件已经成为 Puppet 构建操作系统包的一部分。
- en: You have studied the theory of storing data in Hiera at length, so it's finally
    time to see how to make use of this in Puppet.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经深入学习了在 Hiera 中存储数据的理论，现在终于到了看看如何在 Puppet 中使用它的时机。
- en: Fetching data from classes
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从类中获取数据
- en: 'Looking up a key value in Hiera is easy. Puppet comes with a very straightforward
    function for this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Hiera 中查找键值是很简单的。Puppet 提供了一个非常直接的函数来实现这一点：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Whenever the compiler encounters such a call in the manifest of the current
    agent node, it triggers a search in the hierarchy. The specific data sources are
    determined by the hierarchy in your `hiera.yaml` file. It will almost always rely
    on fact values provided by the agent to make flexible data source selections.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 每当编译器在当前代理节点的清单中遇到这样的调用时，它会触发层级结构中的搜索。具体的数据源由你的 `hiera.yaml` 文件中的层级结构决定。它几乎总是依赖于代理提供的事实值来进行灵活的数据源选择。
- en: 'If the named key cannot be found in the agent''s hierarchy, the master aborts
    the catalog compilation with an error. To prevent this, it is often sensible to
    supply a default value with the lookup:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在代理的层级结构中找不到指定的键，主节点会中止目录编译并报告错误。为了防止这种情况，通常建议为查找提供一个默认值：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this case, Puppet uses an empty array if the hierarchy mentions no plugins.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果层级结构没有提到插件，Puppet 会使用一个空数组。
- en: On the other hand, you can purposefully omit the default value. Just as with
    `class` and `define` parameters, this signals that the Hiera value is required.
    If the user fails to supply it, Puppet will abort the manifest compilation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，你也可以故意省略默认值。就像 `class` 和 `define` 参数一样，这表示 Hiera 值是必需的。如果用户未提供该值，Puppet
    将中止清单编译。
- en: Working with simple values
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用简单值
- en: 'You have seen how to invoke the `hiera` function for value retrieval. There
    is really not more to it than what you have seen in the previous section, except
    for an optional parameter. It allows you to include an additional layer at the
    top of your hierarchy. If the key is found in the named data source, it will override
    the result from the regular hierarchy:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到如何调用 `hiera` 函数来检索值。实际上，除了一个可选参数外，除了你在前一节中看到的内容，没有更多的复杂性。这个可选参数允许你在层级结构的顶部增加一个额外的层次。如果在指定的数据源中找到该键，它将覆盖常规层级的结果：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If the `reporting::plugins` key is found in the `global-overrides` data source,
    the value is taken from there. Otherwise, the normal hierarchy is searched.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 `global-overrides` 数据源中找到 `reporting::plugins` 键，则从该位置获取值。否则，会搜索常规层级结构。
- en: 'Generally, assigning the retrieved value to a manifest variable is quite common.
    However, you can also invoke the `hiera` function in other useful contexts, such
    as the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，将检索到的值分配给清单变量是非常常见的。然而，你也可以在其他有用的上下文中调用 `hiera` 函数，如下所示：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The lookup result can be handed to a resource directly as a parameter value.
    This is an example of how to allow Hiera to define a specific IP address per machine
    that should be used for a specific service. It acts as a simple way to manually
    override Facter's assumptions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 查找结果可以直接作为参数值传递给资源。这是一个示例，展示了如何允许 Hiera 为每台机器定义一个特定的 IP 地址，用于某个特定服务。它作为一种简单的方式来手动覆盖
    Facter 的假设。
- en: 'It is generally safer to store Hiera lookup results in a variable first. This
    allows you to check their data type. In Puppet 3, you need to use an `assert`
    function from the `stdlib` module. Puppet 4 has an operator for this purpose:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，将 Hiera 查找结果先存储在一个变量中更为安全。这可以让你检查它们的数据类型。在 Puppet 3 中，你需要使用来自 `stdlib` 模块的
    `assert` 函数。Puppet 4 有一个为此目的设计的操作符：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Another frequent occurrence is a parameter default that is made dynamic through
    a Hiera lookup:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的情况是通过 Hiera 查找使参数默认值变得动态：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For `logrotate::config` resources that are declared with an explicit parameter
    value, the Hiera value is ignored:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于声明了显式参数值的 `logrotate::config` 资源，Hiera 值会被忽略：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This can be a little confusing. Still, the pattern adds some convenience. Most
    agents can rely on the default. The hierarchy allows you to tune this default
    on multiple levels of granularity.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能有点让人困惑。不过，这种模式带来了一些便利。大多数代理可以依赖于默认设置。层级结构允许你在多个粒度级别上调优这个默认值。
- en: Binding class parameter values automatically
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动绑定类参数值
- en: The concept of parameterized classes might have gotten a somewhat tarnished
    reputation, judging from our coverage of it so far. It allegedly makes it difficult
    to include classes from multiple places in the manifest, or silently allows it
    under shifting circumstances. While that is `true`, you can avoid these issues
    by relying on Hiera for your class parameterization needs.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从目前为止的介绍来看，参数化类的概念可能已经有些不太好的声誉。它被认为使得在清单中包含来自多个地方的类变得困难，或者在变化的情况下默默地允许这种做法。虽然这是`正确的`，但你可以通过依赖
    Hiera 来满足你的类参数化需求，从而避免这些问题。
- en: Since Puppet's version 3.2, it has been possible to choose the values for any
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Puppet 3.2 版本开始，用户可以选择任何值
- en: 'class''s parameters right in the Hiera data. Whenever you include a class that
    has any parameters, Puppet will query Hiera to find a value for each of them.
    The keys must be named after the class and parameter names, joined by a double
    colon. Remember the `cacti` class from [Chapter 5](3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml),
    *Combining Classes, Configuration Files, and Extensions into Modules.* It had
    a `$redirect` parameter. To define its value in Hiera, add the `cacti::redirect`
    key:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 类的参数可以直接在 Hiera 数据中定义。每当你包含一个有参数的类时，Puppet 会查询 Hiera 为每个参数找到一个值。键必须以类名和参数名命名，并用双冒号连接。记住我们在[第五章](3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml)中提到的
    `cacti` 类，*将类、配置文件和扩展结合成模块*。它有一个 `$redirect` 参数。要在 Hiera 中定义其值，请添加 `cacti::redirect`
    键：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Some classes have very elaborate interfaces the `apache` class from the Puppet
    Labs Apache module accepts 70 parameters at the time of writing this. If you need
    many of those, you can put them into the target machine's dedicated YAML file
    as one coherent block of keys with values. It will be quite readable because the
    `apache::` prefixes line up.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有些类有非常复杂的接口，例如 Puppet Labs 的 Apache 模块中的 `apache` 类，在写本文时，它接受 70 个参数。如果你需要其中很多参数，可以将它们作为一个统一的键值块放入目标机器的专用
    YAML 文件中。这会很容易阅读，因为 `apache::` 前缀对齐了。
- en: You don't save any lines compared to specifying the parameters right in the
    manifest, but at least the wall of options will not get in your way while you're
    programming in your manifests, you separated data from code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 相比于直接在清单中指定参数，你并不会节省任何行数，但至少在编写清单时，选项墙不会妨碍你，你将数据与代码分离。
- en: 'The point that is perhaps the most redeeming for class parameterization is
    that each key is independent in your hierarchy. Many parameters can most likely
    be defined for many or all of your machines. Clusters of application servers can
    share some settings (if your hierarchy includes a layer on which they are grouped
    together), and you can override parameters for single machines as you see fit:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 或许类参数化最值得称赞的一点是，在你的层级结构中，每个键都是独立的。许多参数很可能可以为你的大部分或所有机器定义。应用服务器的集群可以共享一些设置（如果你的层级结构中包含了它们被分组在一起的层级），你也可以根据需要覆盖单台机器的参数：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding example prepares your site to use the Puppet certificates for
    HTTPS. This is a good choice for internal services, because trust to the Puppet
    CA can be easily established, and the certificates are available on all agent
    machines. The third parameter, `purge_configs`, prevents the module from obliterating
    any existing Apache configuration that is not under Puppet's management.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例为你的网站准备了使用 Puppet 证书来支持 HTTPS。这对于内部服务是一个不错的选择，因为可以轻松建立对 Puppet CA 的信任，而且证书在所有代理机器上都可用。第三个参数`purge_configs`可以防止该模块摧毁任何不在
    Puppet 管理下的现有 Apache 配置。
- en: 'Let''s see an example of a more specific hierarchy layer that overrides this
    setting:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个更具体的层级示例，它会覆盖这个设置：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: On machines that have the `httpsec` role, the Apache configuration should be
    purged so that it matches the managed configuration completely. The hierarchy
    of such machines also defines some additional values that are not defined in the
    `common` layer. The SSL settings from `common` remain untouched.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在拥有 `httpsec` 角色的机器上，应该清除 Apache 配置，以确保它完全匹配受管理的配置。这些机器的层级结构还定义了一些在 `common`
    层级中未定义的附加值。`common` 中的 SSL 设置保持不变。
- en: 'A specific machine''s YAML can override keys from either layer if need be:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，特定机器的 YAML 文件可以覆盖任意层级的键：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: All these settings require no additional work. They take effect automatically,
    provided that the `apache` class from the `puppetlabs-apache` module is included.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些设置不需要额外的工作。只要包含了 `puppetlabs-apache` 模块中的 `apache` 类，它们就会自动生效。
- en: For some users, this might be the only way in which Hiera is employed on their
    master, which is perfectly valid. You can even design your manifests specifically
    to expose all configurable items as class parameters. However, keep in mind that
    another advantage of Hiera is that any value can be retrieved from many different
    places in your manifest.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些用户而言，这可能是他们的主服务器上唯一使用 Hiera 的方式，这是完全有效的。你甚至可以专门设计清单，将所有可配置项作为类参数暴露出来。然而，记住
    Hiera 的另一个优势是，可以从清单中的许多不同位置检索任何值。
- en: 'For example, if your firewalled servers are reachable through dedicated NAT
    ports, you will want to add those ports to each machine''s Hiera data. The manifest
    can export this value not only to the firewall server itself, but also to external
    servers that use it in scripts and configurations to reach the exporting machine:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的防火墙服务器可以通过专用的 NAT 端口访问，你将希望将这些端口添加到每台机器的 Hiera 数据中。清单不仅可以将该值导出到防火墙服务器本身，还可以导出到外部服务器，以便它们在脚本和配置中使用该值来访问导出机器：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The values will most likely be defined on different hierarchical layers. `nat_port`
    is agent-specific and can only be defined in the `%{::fqdn}` (or `%{::clientcert}`
    for better security) derived data source. `nat_ip` will probably be identical
    for all servers in the same cluster. They might share a server role. `firewall_segment`
    could well be identical for all servers that share the same location:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值很可能会在不同的层次结构中定义。`nat_port` 是特定于代理的，只能在 `%{::fqdn}`（或为了更好的安全性，可以使用 `%{::clientcert}`）派生的数据源中定义。`nat_ip`
    可能对同一集群中的所有服务器都是相同的。它们可能共享相同的服务器角色。`firewall_segment` 可能对所有共享相同位置的服务器都是相同的：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As previously mentioned, some of this data will be helpful in other contexts
    as well. Assume that you deploy a script through a defined type. The script sends
    messages to remote machines. The destination address and port are passed to the
    defined type as parameters. Each node that should be targeted can export this
    script resource:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，部分数据在其他上下文中也会有所帮助。假设你通过定义的类型部署了一个脚本。该脚本会向远程机器发送消息。目标地址和端口作为参数传递给定义的类型。每个需要作为目标的节点可以导出该脚本资源：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It would be impractical to do all this in one class that takes the port and
    address as parameters. You would want to retrieve the same value from within different
    classes or even modules, each taking care of the respective exports.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些功能放在一个接收端口和地址作为参数的类中是不切实际的。你可能希望从不同的类甚至模块中检索相同的值，每个类或模块负责各自的导出。
- en: Handling hashes and arrays
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理哈希和数组
- en: Some examples in this chapter defined array values in Hiera. The good news is
    that retrieving arrays and hashes from Hiera is not at all different from retrieving
    simple strings, numbers, or Boolean values. The `hiera` function will return all
    these values, which are ready for use in the manifest.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的一些示例在 Hiera 中定义了数组值。好消息是，从 Hiera 中检索数组和哈希值与检索简单的字符串、数字或布尔值没有任何不同。`hiera`
    函数会返回所有这些值，这些值已准备好在清单中使用。
- en: There are two more functions that offer special handling for such values; the
    `hiera_array` and `hiera_hash` functions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个函数提供了对这些值的特殊处理：`hiera_array` 和 `hiera_hash` 函数。
- en: The presence of these functions can be somewhat confusing. New users might assume
    that these are required whenever retrieving hashes or arrays from the hierarchy.
    When inheriting Puppet code, it can be a good idea to double-check that these
    derived functions are actually used correctly in a given context.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的存在可能会让人感到困惑。新用户可能会误以为在从层次结构中检索哈希或数组时，必须使用这些函数。在继承 Puppet 代码时，检查这些派生函数是否在特定上下文中正确使用是个好主意。
- en: 'When the `hiera_array` function is invoked, it gathers all named values from
    the whole hierarchy and merges them into one long array that comprises all elements
    that were found. Take the example of the distributed firewall configuration once
    more. Each node should be able to export a list of rules that open ports for public
    access. The manifest for this would be completely driven by Hiera:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `hiera_array` 函数时，它会从整个层次结构中收集所有命名的值，并将它们合并成一个长数组，包含所有找到的元素。再以分布式防火墙配置为例。每个节点应该能够导出一个开放端口以供公共访问的规则列表。该清单完全由
    Hiera 驱动：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Please note that the title `200 NAT ports` does not allude to the number of
    ports, but just adheres to the naming conventions for `firewall` resources. The
    numeric prefix makes it easy to maintain order. Also, note the seemingly nonsensical
    default value of `false` for the `site::net::nat_ip` key in the `if` clause. This
    forms a useful pattern, though the resource should only be exported if `public_ip`
    is defined for the respective node.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，标题`200 NAT端口`并不是指端口的数量，而只是遵循了`firewall`资源的命名约定。数字前缀使得维护顺序变得更容易。此外，请注意`if`子句中`site::net::nat_ip`键的默认值`false`看似不合逻辑。虽然该资源只有在为相应节点定义了`public_ip`时才会导出，但这形成了一个有用的模式。
- en: 'Care must be taken if `false` or the empty string is a conceivable value for
    the key in question. In this case, the `if` clause will ignore that value. In
    such cases, you should use a well-defined comparison instead:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`false`或空字符串是该键可能的值，则必须小心。在这种情况下，`if`子句将忽略该值。在这种情况下，您应该使用明确的比较：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The hierarchy can then hold ports on several layers:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 层次结构可以在多个层次上持有端口：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The SSH port should be available for all nodes that get a public address. Note
    that this value is not an array itself. This is fine Hiera will include scalar
    values in the resulting list without any complaints:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: SSH端口应该对所有获得公共地址的节点可用。请注意，这个值本身不是一个数组。没关系，Hiera会将标量值包含在结果列表中而不发出任何警告：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Standalone web application servers present their HTTP and HTTPS ports to
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 独立的Web应用服务器会暴露它们的HTTP和HTTPS端口
- en: 'the public:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 公共：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The testing instance for your new cloud service should expose a range of ports
    for custom services. If it has the `webserver` role (somehow), it will lead to
    an export of ports `22`, `80`, and `443`, as well as its individually chosen list.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 新的云服务的测试实例应该暴露一系列自定义服务的端口。如果它具有`webserver`角色（以某种方式），它将导致端口`22`、`80`和`443`的导出，以及它单独选择的端口列表。
- en: When designing such a construct, keep in mind that the array merge is only ever
    cumulative. There is no way to exclude values that were added in lower layers
    from the final result. In this example, you will have no opportunity to disable
    the SSH port `22` for any given machine. You should take good care when adding
    common values.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计这种结构时，请记住，数组合并永远只是累积性的。无法从最终结果中排除在较低层次添加的值。在这个例子中，你将无法为任何给定的机器禁用SSH端口`22`。添加常见值时需要特别小心。
- en: 'A similar alternative lookup function exists for hashes. The `hiera_hash` function
    also traverses the whole hierarchy and constructs a hash by merging all hashes
    it finds under the given Hiera key from all hierarchy layers. Hash keys in higher
    layers overwrite those from lower layers. All values must be hashes. Strings,
    arrays, or other data types are not allowed in this case:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希值也有类似的查找函数。`hiera_hash`函数也会遍历整个层次结构，并通过合并它在所有层次上找到的所有哈希来构建一个哈希。较高层次的哈希键会覆盖较低层次的哈希键。在这种情况下，所有值必须是哈希。字符串、数组或其他数据类型在此情况下不允许：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'These are the default settings for `haproxy` at the lowest hierarchy level.
    On web servers, the daemon should run as the general web service user:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是`haproxy`在最低层次上的默认设置。在Web服务器上，守护进程应该作为通用的Web服务用户运行：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When retrieved using `hiera('haproxy_settings')`, this will just evaluate to
    the hash, `{'user'=>'www-data','group'=>'www-data'}`. The hash at the role-specific
    layer completely overrides the default settings.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`hiera('haproxy_settings')`时，这将只评估为哈希值`{'user'=>'www-data','group'=>'www-data'}`。角色特定层次上的哈希完全覆盖了默认设置。
- en: 'To get all values, create a merger using `hiera_hash(''haproxy_settings'')`
    instead. The result is likely to be more useful:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取所有值，请改用`hiera_hash('haproxy_settings')`创建一个合并器。结果可能更有用：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The limitations are similar to those of `hiera_array`. Keys from any hierarchy
    level cannot be removed; they can only be overwritten with different values. The
    end result is quite similar to what you would get from replacing the hash with
    a group of keys:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 限制与`hiera_array`类似。任何层次结构级别的键都无法删除；只能用不同的值覆盖它们。最终结果与将哈希替换为一组键非常相似：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you opt to do this, the data can also be easily fitted to a class that can
    bind these values to parameters automatically. Preferring flat structures can,
    therefore, be beneficial. Defining hashes in Hiera is still generally worthwhile,
    as the next section explains. [https://docs.puppetlabs.com/references/latest/function.html#createresources](https://docs.puppetlabs.com/references/latest/function.html#createresources) originally
    been conceived for. Hiera can serve as a basic ENC.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择这样做，数据也可以很容易地适配到一个类中，该类可以自动将这些值绑定到参数上。因此，优先使用平面结构可能是有益的。正如下一节所解释的那样，在 Hiera
    中定义哈希仍然是值得的。[https://docs.puppetlabs.com/references/latest/function.html#createresources](https://docs.puppetlabs.com/references/latest/function.html#createresources)
    最初是为此设计的。Hiera 可以作为一个基础的 ENC。
- en: Choosing between manifest and Hiera designs
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在清单和 Hiera 设计之间进行选择
- en: You can now move most of the concrete configuration to the data storage.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以将大多数具体配置转移到数据存储中。
- en: Classes can be included from the manifest or through Hiera. Puppet looks up
    parameter values in the hierarchy, and you can flexibly distribute the configuration
    values there in order to achieve the desired result for each node with minimal
    effort and redundancy.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以从清单中或通过 Hiera 包含。Puppet 在层级中查找参数值，你可以灵活地将配置值分配到那里，以便为每个节点实现所需的结果，最大限度地减少工作量和冗余。
- en: 'This does not mean that you don''t write actual manifest code anymore. The
    manifest is still the central pillar of your design. You will often need logic
    that uses the configuration data as input. For example, there might be classes
    that should only be included if a certain value is retrieved from Hiera:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着你不再编写实际的清单代码。清单仍然是你设计的核心支柱。你将经常需要使用配置数据作为输入的逻辑。例如，可能会有一些类，只有从 Hiera 中检索到某个特定值时才应该包含：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you try and rely on Hiera exclusively, you will have to add `nginx` to the
    `classes` array at all places in the hierarchy that set the `use_caching_proxy`
    flag to `true`. This is prone to mistakes. What's worse is that the flag can be
    overridden from `true` to `false` at a more specific layer, but the `nginx` element
    cannot be removed from an array that is retrieved by `hiera_include`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仅仅依赖 Hiera，你将需要在所有设置 `use_caching_proxy` 标志为 `true` 的层级中，将 `nginx` 添加到 `classes`
    数组。这很容易出错。更糟糕的是，这个标志可以在更具体的层级上被覆盖为 `false`，但是 `nginx` 元素不能从通过 `hiera_include`
    检索的数组中移除。
- en: It is important to keep in mind that the manifest and data should complement
    each other. You should primarily build manifests and add lookup function calls
    at opportune places. Defining flags and values in Hiera should allow you (or the
    user of your modules) to alter the behavior of the manifest. The data should not
    be the driver of the catalog composition, except for places in which you replace
    large numbers of static resources with large data structures.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，清单和数据应当相辅相成。你应该主要构建清单，并在合适的位置添加查找函数调用。在 Hiera 中定义标志和值应当允许你（或模块的用户）更改清单的行为。数据不应当是目录编排的驱动因素，除非是在你用大量数据结构替换大量静态资源的地方。
- en: Debugging data lookups
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试数据查找
- en: As you can see from the preceding example, the data that contributes to the
    complete configuration of any module can be rather dispersed throughout the set
    of your data sources. It can be challenging to determine where the respective
    values are retrieved from for any given agent node. It can be frustrating to trace
    data sources to find out why a change at some level will not take effect for some
    of your agents.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从前面的例子中看到的那样，贡献到任何模块的完整配置的数据可能会分散在你的数据源集合中。这使得确定每个代理节点从哪个位置检索相应的值变得具有挑战性。追踪数据源找出某些层级的更改为什么不会对某些代理生效，可能会让人感到沮丧。
- en: 'To help make the process more transparent, Hiera comes with a command-line
    tool called `hiera`. Invoking it is simple:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助使这一过程更加透明，Hiera 附带了一个名为 `hiera` 的命令行工具。调用它很简单：
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It retrieves a given key using the specified configuration from `hiera.yaml`.
    Make sure that you use the same Hiera configuration as Puppet.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用 `hiera.yaml` 中指定的配置检索给定的键。确保你使用与 Puppet 相同的 Hiera 配置。
- en: 'Of course, this can only work sensibly if Hiera selects the same data sources
    as the compiler, which uses fact values to form a concrete hierarchy. These required
    facts can be given right on the command line as the final parameters:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，只有当 Hiera 选择与编译器相同的数据源时，这才是合理的，编译器使用事实值来形成具体的层级。这些必需的事实可以作为最终参数直接在命令行上提供：
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This prints the `demo::atoms` value of the specified server to the console.
    The fact values can also be retrieved from a YAML file or other alternative sources.
    Use `hiera --help` to get information about the available scenarios.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将指定服务器的 `demo::atoms` 值打印到控制台。事实值也可以从 YAML 文件或其他替代来源中获取。使用 `hiera --help`
    以获取可用场景的信息。
- en: 'Make sure that you add the `-d` (or `--debug`) flag in order to get helpful
    information about the traversal of the hierarchy:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 确保添加 `-d`（或 `--debug`）标志，以便获取有关遍历层级结构的有用信息：
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Hiera 5 allows for another way of debugging data lookups. We will cover Hiera
    5 later in this chapter.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Hiera 5 提供了另一种调试数据查找的方法。我们将在本章稍后介绍 Hiera 5。
- en: Managing resources from data
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从数据管理资源
- en: You can now move configuration settings to Hiera and dedicate your manifest
    to logic. This works seamlessly as far as classes and their parameters are concerned,
    because class parameters automatically retrieve their values from Hiera. For configuration
    that requires you to instantiate resources, you still need to write the full manifests
    and add manual lookup function calls.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以将配置设置移到 Hiera 并将你的清单专注于逻辑部分。就类及其参数而言，这一过程非常顺畅，因为类参数会自动从 Hiera 获取其值。对于需要实例化资源的配置，你仍然需要编写完整的清单并添加手动查找函数调用。
- en: For example, an Apache web server requires some global settings, but the interesting
    parts of its configuration are typically performed in virtual host configuration
    files. Puppet models them with defined resource types. If you want to configure
    an `iptables` firewall, you have to declare lots of resources of the `firewall`
    type (available through the `puppetlabs-firewall` module).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Apache 网络服务器需要一些全局设置，但其配置的有趣部分通常在虚拟主机配置文件中完成。Puppet 通过定义的资源类型来建模它们。如果你想配置
    `iptables` 防火墙，你必须声明大量的 `firewall` 类型资源（通过 `puppetlabs-firewall` 模块提供）。
- en: Such elaborate resources can clutter up your manifest, yet they mostly represent
    data. There is no inherent logic to many firewall rules (although sometimes a
    set of rules is derived from one or several key values). Virtual hosts often stand
    for themselves as well, with little or no relation to configuration details that
    are relevant to other parts of the setup.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这类复杂的资源可能会使你的清单变得杂乱无章，但它们大多只是数据而已。许多防火墙规则没有内在的逻辑（尽管有时一组规则是从一个或多个关键值推导出来的）。虚拟主机通常也代表自己，与其他部分的配置细节关系较少或没有关系。
- en: 'Puppet comes with yet another function that allows you to move whole sets of
    such resources to Hiera data. The pattern is straightforward: a group of resources
    of the same type are represented by a hash. The keys are resource titles, and
    the values are yet another layer of hashes with key-value pairs for attributes:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 还提供了另一个函数，允许你将整组此类资源移到 Hiera 数据中。模式很简单：同类型的资源通过哈希表示。键是资源标题，值是另一个包含属性键值对的哈希层：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This YAML data represents two `service` resources. To make Puppet add them
    as actual resources to the catalog, use the iterator function from Puppet 4:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 YAML 数据表示两个 `service` 资源。要使 Puppet 将它们作为实际资源添加到目录中，请使用 Puppet 4 中的迭代器函数：
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Within older Puppet code, one will most likely find the usage of the `create_resources`
    function:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧版 Puppet 代码中，你很可能会找到使用 `create_resources` 函数的情况：
- en: '[PRE40]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The first argument is the name of the resource type, and the second must be
    the hash of actual resources. There are some more aspects to this technique, but
    do note that, with Puppet 4, it is no longer necessary to rely on the `create_resources`
    function.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是资源类型的名称，第二个参数必须是实际资源的哈希。这个技术还有一些其他方面，但请注意，使用 Puppet 4 后，不再需要依赖 `create_resources`
    函数。
- en: It's useful to be aware of the basics of it anyway. It is still in broad use
    for existing manifests, and it is still the most compact way of converting data
    into resources. To learn more, refer to the online documentation at [https://docs.puppetlabs.com/references/latest/function.html#createresources](https://docs.puppetlabs.com/references/latest/function.html#createresources).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，了解它的基本原理还是很有用的。它仍然在现有的清单中广泛使用，并且是将数据转换为资源的最简洁方式。欲了解更多信息，请参考在线文档 [https://docs.puppetlabs.com/references/latest/function.html#createresources](https://docs.puppetlabs.com/references/latest/function.html#createresources)。
- en: 'The Puppet 4 iterator has a few advantages over the `create_resources` approach:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 4 的迭代器相比 `create_resources` 方法有一些优势：
- en: You can perform data transformations, such as adding a prefix to string values,
    or deriving additional attribute values
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以执行数据转换，例如为字符串值添加前缀，或推导额外的属性值。
- en: Each iteration can do more than just creating one resource per inner hash, for
    example, including required classes
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次迭代不仅仅是创建一个资源，例如，还可以包括所需的类。
- en: You can devise a data structure that deviates from the strict expectancies of
    `create_resources`
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以设计一个偏离 `create_resources` 严格预期的数据结构。
- en: The manifest is more clear and intuitive, especially to uninitiated readers
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清单更加清晰和直观，特别是对于没有经验的读者。
- en: For creating many simple resources (such as the services in the preceding example),
    you might wish to avoid `create_resource` in Puppet 4 manifests. Just keep in
    mind that if you don't take advantage of doing so, you can keep the manifest more
    succinct by sticking to `create_resources` after all.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于创建许多简单资源（例如前面示例中的服务），您可能希望避免在 Puppet 4 清单中使用 `create_resource`。请记住，如果不利用这一点，您仍然可以通过坚持使用
    `create_resources` 来保持清单简洁。
- en: 'Puppet 4 comes with a useful tool to generate YAML data that is suitable for
    `create_resources`. With the following command, you can make Puppet emit service
    type resources that represent the set of available services on the local system,
    along with their current property values:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 4 提供了一个有用的工具来生成适用于 `create_resources` 的 YAML 数据。使用以下命令，您可以让 Puppet 输出代表本地系统中可用服务及其当前属性值的服务类型资源：
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `-y` switch selects a YAML output instead of Puppet DSL.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`-y` 选项选择 YAML 输出，而不是 Puppet DSL。'
- en: 'In theory, these techniques allow you to move almost all your code to Hiera
    data (the next section discusses how desirable that really is). There is one more
    feature that goes one step further in this direction:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，这些技术允许您将几乎所有代码移动到 Hiera 数据中（下一节将讨论这到底有多可取）。还有一个功能进一步推动了这一方向：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This call gathers values from all over the hierarchy; just the same as `hiera_array`.
    The resulting array is interpreted as a list of class names. All these named classes
    are included. This allows for some additional consolidation in your manifest:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用从整个层级结构中收集值；就像`hiera_array`一样。结果数组被解释为类名的列表。所有这些命名的类都会被包含。这允许您在清单中进行一些额外的合并：
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You can possibly even use `hiera_include` to declare these classes outside of
    any `node` block. The data will then affect all nodes. Additionally, from some
    distinct classes, you might also declare other classes via `hiera_include`, whose
    names are stored under a different Hiera key.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以使用 `hiera_include` 在任何 `node` 块之外声明这些类。数据将影响所有节点。此外，您还可以通过 `hiera_include`
    声明一些不同的类，其名称存储在不同的 Hiera 键下。
- en: The ability to enumerate classes for each node to include is what Puppet's **External
    Node Classifiers** (**ENCs**) had originally been conceived for. Hiera can serve
    as a basic ENC thanks to the `hiera_include` function. This is most likely preferred
    over writing a custom ENC. However, it should be noted that some open source ENCs,
    such as Foreman, are quite powerful and can add much more convenience; as a result,
    Hiera has not supplanted the concept as a whole.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个节点列举要包含的类，正是 Puppet 的**外部节点分类器**（**ENCs**）最初的设计目的。得益于`hiera_include`函数，Hiera
    可以作为一个基本的 ENC。与编写自定义 ENC 相比，这种方法通常更受欢迎。然而，需要注意的是，一些开源 ENC，如 Foreman，功能强大，并能带来更多的便利；因此，Hiera
    并没有完全取代这一概念。
- en: The combination of these tools opens some ways for you to shrink your manifests
    to their essential parts and configure your machines gracefully through Hiera.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具的组合为您提供了一些方法，可以将清单缩小到其核心部分，并通过 Hiera 优雅地配置您的机器。
- en: Hiera version 5
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hiera 版本 5
- en: 'Hiera 5 was released with Puppet 4.9\. Earlier Puppet 4 releases had Hiera
    4 bundled. The main difference between older Hiera and Hiera 5 is the concept
    of multilayered Hiera hierarchies:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Hiera 5 是与 Puppet 4.9 一同发布的。早期的 Puppet 4 版本捆绑了 Hiera 4。旧版 Hiera 与 Hiera 5 之间的主要区别是多层次
    Hiera 层级结构的概念：
- en: The first layer is the module layer. Hiera 5 allows you to use Hiera data in
    modules by specifying a Hiera 5 config version `hiera.yaml` file inside the module
    root
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一层是模块层。Hiera 5 允许您通过在模块根目录中指定一个 Hiera 5 配置版本的 `hiera.yaml` 文件，在模块中使用 Hiera
    数据。
- en: The second layer is the environment layer where you place a `hiera.yaml` file
    inside the environment root
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二层是环境层，您可以将 `hiera.yaml` 文件放置在环境根目录中。
- en: The last layer is the main layer, where `hiera.yaml` resides in `/etc/puppetlabs/puppet/hiera.yaml`.
    This was the only layer available in older Hiera versions.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一层是主层，其中 `hiera.yaml` 位于 `/etc/puppetlabs/puppet/hiera.yaml`。这是旧版 Hiera 中唯一的层。
- en: The main layer is no longer considered best practice, and exists for compatibility
    reasons. Everybody is encouraged to migrate data from the main layer to the environment
    layer.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 主层不再被认为是最佳实践，存在的原因是为了兼容性。大家都被鼓励将数据从主层迁移到环境层。
- en: With Hiera 5, the configuration file has completely different content. It is
    still a YAML style file, but backends are no longer globally configured but put
    into the hierarchy level. This allows you to specify different backends for different
    Hiera hierarchies.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Hiera 5 中，配置文件的内容完全不同。它仍然是 YAML 风格的文件，但后端不再全局配置，而是放入层级结构中。这允许你为不同的 Hiera 层级指定不同的后端。
- en: 'Let''s convert the `hiera.yaml` file from Hiera 3 to Hiera 5:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 `hiera.yaml` 文件从 Hiera 3 转换为 Hiera 5：
- en: '[PRE44]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Transform this file to the Hiera 5 `.yaml` file:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件转换为 Hiera 5 `.yaml` 文件：
- en: '[PRE45]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Besides this, it is possible to configure the Hiera lookup behavior by adding
    `lookup_options` keys to your Hiera data. On each data lookup, Hiera 5 will first
    check for the `lookup_options` key and will then use this information to look
    up the desired data. But how should Hiera know which layer to use?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，还可以通过向 Hiera 数据中添加 `lookup_options` 键来配置 Hiera 查找行为。在每次数据查找时，Hiera 5 会首先检查
    `lookup_options` 键，并使用此信息来查找所需的数据。但是，Hiera 应该如何知道使用哪一层呢？
- en: With Hiera 3 we used the `hiera`, `hiera_array`, or `hiera_hash` function to
    retrieve data. With Hiera 5, these functions have been replaced by a single lookup
    function.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Hiera 3 中，我们使用 `hiera`、`hiera_array` 或 `hiera_hash` 函数来检索数据。而在 Hiera 5 中，这些函数被单一的
    lookup 函数替代。
- en: '`hiera` (key) gets converted to lookup(key)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hiera`（键）转换为 lookup（键）'
- en: '`hiera_array` (key) gets converted to lookup(key, array, unique)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hiera_array`（键）转换为 lookup（键，数组，唯一）'
- en: '`hiera_hash` (key) gets converted to lookup(key, hash, hash)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hiera_hash`（键）转换为 lookup（键，哈希，哈希）'
- en: 'The automatic data lookup from classes works without any further changes. Another
    change with Hiera 5 is the way we debug Hiera data lookups. Puppet now has the
    puppet lookup interface. Remember the Hiera cli tool:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 从类中自动查找数据无需进一步的更改。Hiera 5 的另一个变化是我们调试 Hiera 数据查找的方式。Puppet 现在具有 Puppet lookup
    接口。记住 Hiera 的命令行工具：
- en: '[PRE46]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now we can use the Puppet lookup cli:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用 Puppet lookup 命令行工具：
- en: '[PRE47]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The main difference is that Puppet lookup uses facts stored on the Puppet master
    instead of adding each used fact on cli. Besides this, there is an additional
    option `--explain`, which replaces the debug option from Hiera cli.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于 Puppet lookup 使用存储在 Puppet 主机上的事实，而不是在命令行中添加每个使用的事实。除此之外，还有一个额外的选项 `--explain`，它取代了
    Hiera 命令行工具中的调试选项。
- en: When using Puppet lookup with the `--explain` option, the output also shows
    the lookup for the merge behavior.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Puppet lookup 时，带 `--explain` 选项，输出还会显示合并行为的查找。
- en: 'Describing all of the new features, especially the paths and globbing possibilities
    and the configuration of Hiera lookup behavior inside Hiera, is beyond the scope
    of this book:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 描述所有新特性，尤其是路径和通配符的可能性，以及如何在 Hiera 内部配置 Hiera 查找行为，超出了本书的范围：
- en: '![](img/1706dbd4-a78d-4735-a7fc-1e0c1d0c36a0.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1706dbd4-a78d-4735-a7fc-1e0c1d0c36a0.png)'
- en: '[http://www.craigdunn.org/2012/05/239/](http://www.craigdunn.org/2012/05/239/),
    and the design has since been adopted by many users.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.craigdunn.org/2012/05/239/](http://www.craigdunn.org/2012/05/239/)，该设计后来被许多用户采用。'
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Hiera is a tool that stores and retrieves data in a hierarchical fashion. Each
    retrieval uses a distinct data source from each hierarchy layer and traverses
    your hierarchy from the most to the least specific level. The hierarchy is defined
    by the user as an array in a YAML file.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Hiera 是一个以层次结构方式存储和检索数据的工具。每次检索都会使用来自每个层级的不同数据源，并从最具体的层级遍历到最不具体的层级。层级由用户在 YAML
    文件中作为数组定义。
- en: Puppet has Hiera support built in, and you can use it to separate data from
    code. From manifests, you will mainly perform lookups through the `hiera` function.
    In most cases, the respective entries will rely on fact values.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 内置了 Hiera 支持，你可以用它来将数据与代码分离。在清单中，你主要通过 `hiera` 函数执行查找。在大多数情况下，相应的条目将依赖于事实值。
- en: Another common way to employ Hiera through Puppet is to name the Hiera keys
    in the `<class-name>::<parameter-name>` format. When including a parameterized
    class, Puppet will look for such keys in Hiera. If the manifest does not supply
    a parameter value, Puppet automatically binds the value from Hiera to the respective
    parameter.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Puppet使用Hiera的另一种常见方式是以`<class-name>::<parameter-name>`格式命名Hiera键。当包含一个带参数的类时，Puppet会在Hiera中查找这些键。如果清单未提供参数值，Puppet会自动将Hiera中的值绑定到相应的参数。
- en: Manifests that boast large numbers of static resources can be cleaned up by
    converting the declarations to hashes and using the `create_resources` or `each`
    function to declare resources from the data.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有大量静态资源的清单可以通过将声明转换为哈希，并使用`create_resources`或`each`函数从数据中声明资源来进行清理。
- en: Hiera 5 offers a broad set of new functionality, including data in modules and
    data in environments. This chapter gave you guidance on how to migrate data to
    Hiera 5.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Hiera 5提供了一整套新的功能，包括模块中的数据和环境中的数据。本章向你提供了如何将数据迁移到Hiera 5的指导。
- en: Within [Chapter 9](0a0cf4b0-23fa-48fd-abf9-77ed851bb581.xhtml), *Puppet Roles
    and Profiles*, we will discuss how modules and node classification should work
    together, and how to automatically build and deploy a Puppet code environment.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](0a0cf4b0-23fa-48fd-abf9-77ed851bb581.xhtml)，《Puppet角色和配置文件》中，我们将讨论模块和节点分类如何协同工作，以及如何自动构建和部署Puppet代码环境。
