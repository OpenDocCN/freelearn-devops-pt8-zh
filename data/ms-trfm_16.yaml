- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Already Provisioned? Strategies for Importing Existing Environments
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 已经配置过？导入现有环境的策略
- en: The previous nine chapters of this book have focused on implementing new cloud
    architectures across multiple clouds using multiple cloud computing paradigms.
    Now, we’re going to shift gears a bit and focus on how to work with existing environments.
    Unfortunately, sometimes (actually, a lot of the time), the cloud environments
    that you will manage weren’t originally provisioned using **Infrastructure-as-Code**
    (**IaC**) using via Terraform. They could’ve been provisioned using other tools,
    or even manually provisioned, and now you’re trying to consolidate your cloud
    operations using Terraform.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书前九章主要集中于如何使用多种云计算范式，在多个云平台上实现新的云架构。现在，我们将稍微调整一下方向，重点讨论如何处理现有环境。不幸的是，有时（实际上是很多时候），你所管理的云环境并不是最初通过**基础设施即代码**（**IaC**）使用Terraform进行配置的。它们可能是通过其他工具配置的，甚至是手动配置的，现在你正试图使用Terraform整合你的云操作。
- en: 'The chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Importing individual resources
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入单个资源
- en: Identifying resources to import
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别需要导入的资源
- en: Importing existing environments
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入现有环境
- en: Best practices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Importing individual resources
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入单个资源
- en: Terraform supports two ways of importing resources into state. One is inherently
    imperative and procedural and is typically executed outside of a GitOps process
    using Terraform’s **Command Line Interface** (**CLI**). There is also another,
    newer option that allows us to declare import operations in code and follow our
    standard GitFlow process to shepherd these changes into production.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform支持两种导入资源到状态中的方式。一种方式本质上是命令式和程序化的，通常在GitOps流程之外，使用Terraform的**命令行界面**（**CLI**）执行。还有另一种更新的方式，允许我们在代码中声明导入操作，并按照标准的GitFlow流程将这些更改推送到生产环境。
- en: The import command
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入命令
- en: 'The `import` command allows you to import an existing resource that has already
    been provisioned outside of Terraform by some other means:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`命令允许你导入一个已经通过其他方式（而非Terraform）配置好的现有资源：'
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `Terraform import` command ([https://developer.hashicorp.com/terraform/cli/commands/import](https://developer.hashicorp.com/terraform/cli/commands/import))
    takes two key parameters. The various options fall outside of the scope of this
    book. I recommend that you check the documentation for more details on all of
    the available options.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`Terraform import`命令（[https://developer.hashicorp.com/terraform/cli/commands/import](https://developer.hashicorp.com/terraform/cli/commands/import)）有两个关键参数。各种选项超出了本书的范围。我建议你查阅文档，了解所有可用选项的详细信息。'
- en: The first parameter, the address of the resource within the Terraform code base,
    is crucial. It’s the same reference that we use to access resources in our Terraform
    workspace. Unlike when we’re in the HashiCorp Configuration Language code base,
    we’re not limited by the current Terraform module’s scope. The address follows
    your Terraform provider’s naming convention. For instance, you’d need the resource
    type and object reference to import a virtual machine.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数，即Terraform代码库中资源的地址，非常关键。它是我们用来访问Terraform工作区中资源的相同引用。与我们在HashiCorp配置语言代码库中工作时不同，我们不再受到当前Terraform模块范围的限制。该地址遵循你的Terraform提供者的命名约定。例如，你需要资源类型和对象引用才能导入一个虚拟机。
- en: The second parameter is the resource’s unique identifier on the target cloud
    platform. This unique identifier will look very different between different clouds.
    In the next section, we’ll look at how this differs for each cloud platform.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是资源在目标云平台上的唯一标识符。不同云平台之间，这个唯一标识符会有很大不同。在接下来的部分中，我们将看到每个云平台之间的差异。
- en: The `import` command is great for individual resources that might have failed
    due to transient issues during a `terraform apply`. If you had to import an entire
    solution, it would be extremely tedious to put together an `import` command for
    every resource. Even a simple virtual machine might consist of a dozen or so resources.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`命令非常适合用于在`terraform apply`过程中由于临时问题失败的单个资源。如果你需要导入整个解决方案，那么为每个资源编写一个`import`命令将会非常繁琐。即使是一个简单的虚拟机，也可能包含十多个资源。'
- en: Import block
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入块
- en: The `import` command is useful and available, but it requires you to introduce
    change to your IaC code base through outside influence from a human operator through
    the command line. The import block was introduced in version 1.5.0 of Terraform
    to allow these changes to be made through source code changes, which is important
    to maintaining a GitFlow process. This, in turn, is a key component of a GitOps
    model.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`命令很有用且可用，但它需要通过命令行通过人工操作来对你的IaC代码库进行更改。导入块是在Terraform 1.5.0版本中引入的，它允许通过源代码更改来完成这些更改，这对于维持GitFlow流程至关重要。这反过来是GitOps模型的关键组成部分。'
- en: 'Rather than executing a command using the Terraform CLI, you’ll need to embed
    an import block in your code base that looks like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用Terraform CLI执行命令不同，你需要在代码库中嵌入一个像这样的导入块：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It looks very similar to the parameters of the `import` command but it utilizes
    the existing context in which you execute Terraform. It also uses HashiCorp Configuration
    Language to define the import action.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来与`import`命令的参数非常相似，但它利用你执行Terraform时所处的现有上下文。它还使用HashiCorp配置语言（HCL）来定义导入操作。
- en: 'This technique not only allows us to perform state management operations as
    part of our GitOps process but also streamlines the process. Importing resources
    only requires two pull requests: the first to introduce the import blocks for
    the resources we wish to import, and the second to remove the import blocks after
    a successful `Terraform Apply`, when the resources are imported into Terraform
    state.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术不仅允许我们将状态管理操作作为GitOps流程的一部分进行，还简化了这个过程。导入资源只需要两个拉取请求：第一个是引入我们希望导入的资源的导入块，第二个是在成功执行`Terraform
    Apply`后删除导入块，当资源被导入到Terraform状态中时。
- en: Importing multiple resources
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入多个资源
- en: The `Import` command and the import block support importing resources using
    the `for_each` and `count` meta-arguments.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`Import`命令和导入块支持使用`for_each`和`count`元参数导入资源。'
- en: 'To import resources provisioned with a `for_each` block, you simply need to
    define a `map` with the unique identifiers for the resources you wish to import:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入通过`for_each`块配置的资源，你只需要定义一个包含你希望导入的资源唯一标识符的`map`：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The import block’s unique identifier will come from this `map` that you define.
    Then, use a matching `for_each` in the import block, which references your resource
    block using the same `map` and references the corresponding resource using `each.key`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 导入块的唯一标识符将来自你定义的`map`。然后，在导入块中使用匹配的`for_each`，该`for_each`引用与你的资源块相同的`map`，并通过`each.key`引用相应的资源：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Likewise, when importing resources provisioned using the `count` meta-argument,
    we must declare an array with unique identifiers:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当导入通过`count`元参数配置的资源时，我们必须声明一个包含唯一标识符的数组：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we can use the `count` meta-argument on the import block and iterate
    across it just as we do with the resource block:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在导入块上使用`count`元参数，并像处理资源块一样进行迭代：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Using the `import` command is a bit more difficult. You’ll need to execute
    a `terraform import` command for each item within the map, referencing the correct
    `key` and mapping it to the corresponding value:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`import`命令稍微复杂一些。你需要为`map`中的每个项目执行`terraform import`命令，引用正确的`key`并将其映射到相应的值：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A similar technique is used for importing resources that are provisioned using
    `count`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似的技巧导入通过`count`配置的资源：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When working with `for_each` provisioned resources, we need to execute the `terraform
    import` command for each item within the array and manually correlate the index
    with the correct unique identifier.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理`for_each`配置的资源时，我们需要为数组中的每个项目执行`terraform import`命令，并手动将索引与正确的唯一标识符关联。
- en: Although it is technically possible through some pretty advanced bash scripting,
    the recommended approach is to use the import block within the HashiCorp Configuration
    Language, as this is much easier and less error-prone to implement.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通过一些高级的bash脚本技术可以实现，但推荐的方法是使用HashiCorp配置语言中的导入块，因为这种方法更容易实现且更不容易出错。
- en: 'We have examined the imperative and declarative ways of importing existing
    resources into Terraform using the `import` command and the import block, respectively.
    Now, let’s examine how to identify the correct unique identifier for each of our
    existing resources across the three cloud platforms we have covered in this book:
    **Amazon Web Services** (**AWS**), Microsoft Azure, and Google Cloud Platform.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经分别研究了通过 `import` 命令和导入块将现有资源导入 Terraform 的命令式和声明式方法。现在，让我们研究如何在本书中覆盖的三个云平台——**Amazon
    Web Services**（**AWS**）、Microsoft Azure 和 Google Cloud Platform——中识别每个现有资源的正确唯一标识符。
- en: Identifying resources to import
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定要导入的资源
- en: Just as there were subtle differences in each of the cloud architectures we
    developed in the previous chapters of this book, the way in which existing resources
    are imported into Terraform is affected by the structural and not-so-subtle differences
    between the cloud platforms.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在本书前几章中我们开发的每种云架构之间存在细微差别一样，现有资源导入到 Terraform 的方式也受到了云平台之间结构性和不太明显差异的影响。
- en: AWS
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AWS
- en: 'The naming convention used by AWS for EC2 instances tends to look like this:
    `i-abcd1234`. It typically consists of two components: the prefix and the identifier,
    with the prefix varying across AWS services.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 对 EC2 实例的命名约定通常是这样的：`i-abcd1234`。它通常由两个组件组成：前缀和标识符，前缀在不同的 AWS 服务之间有所不同。
- en: The `i-` prefix indicates that this is an `vol-` for volumes or `sg-` for security
    groups.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`i-` 前缀表示这是一个 `vol-`（卷）或 `sg-`（安全组）。'
- en: In this case, the `abcd1234` identifier is a unique identifier for the instance.
    AWS usually assigns a hexadecimal string to each instance to differentiate it
    from other resources. This naming convention helps users and AWS services identify
    and reference resources within the AWS ecosystem. You’ll need to recognize the
    correct unique identifier for whatever resource you are trying to import into
    Terraform from AWS and the other cloud platforms.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`abcd1234` 标识符是实例的唯一标识符。AWS 通常为每个实例分配一个十六进制字符串，以区分它与其他资源。这种命名约定帮助用户和
    AWS 服务在 AWS 生态系统内识别和引用资源。你需要识别正确的唯一标识符，以便将资源从 AWS 及其他云平台导入 Terraform。
- en: 'When using the import command on AWS, it would look like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AWS 的导入命令时，它看起来是这样的：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The corresponding import block would look like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的导入块看起来像这样：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It’s important to understand the distinction between the address, which is the
    internal object reference within Terraform, and the unique identifier, which is
    the external reference to the resource on the target cloud platform. This understanding
    will help you navigate the import process more effectively.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 理解地址和唯一标识符之间的区别非常重要。地址是 Terraform 内部的对象引用，而唯一标识符是目标云平台上资源的外部引用。这一理解将帮助你更有效地导航导入过程。
- en: Azure
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure
- en: 'In Azure, the unique identifier is called the **Azure resource ID**. It takes
    on a radically different format that is composed using several different landmarks
    in a cloud resource’s location within Azure. It follows a structured format that
    includes several components: the subscription, the resource group, the resource
    provider, a resource type, and a localized resource name:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure 中，唯一标识符称为 **Azure 资源 ID**。它采用一种完全不同的格式，使用 Azure 中云资源位置的多个不同地标来构建。它遵循一个结构化的格式，包含几个组件：订阅、资源组、资源提供者、资源类型和本地化的资源名称：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For example, the Azure resource ID for an Azure virtual machine would look
    like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Azure 虚拟机的 Azure 资源 ID 看起来像这样：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this example, we can see the concrete values for each component of the resource
    ID’s path:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们可以看到资源 ID 路径中每个组件的具体值：
- en: '`00000000-0000-0000-0000-000000000000` GUID for the subscription.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`00000000-0000-0000-0000-000000000000` 订阅的 GUID。'
- en: '`rg-foo`.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rg-foo`。'
- en: '`Microsoft.Compute` is the resource provider for Azure compute services, which
    includes Azure virtual machines.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.Compute` 是 Azure 计算服务的资源提供者，其中包括 Azure 虚拟机。'
- en: '`virtualMachines` is used for an Azure virtual machine. Together, the resource
    provider and the resource type create a fully qualified Azure resource type: `Microsoft.Compute\virtualMachines`.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virtualMachines` 用于 Azure 虚拟机。资源提供者与资源类型结合，创建一个完全限定的 Azure 资源类型：`Microsoft.Compute\virtualMachines`。'
- en: '`vmfoo001`.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vmfoo001`。'
- en: 'Each resource type within a resource provider has subtypes as well. These are
    delimited with additional slashes (such as a virtual machine extension: `Microsoft.Compute/virtualMachines/{vm-name}/extensions/{extension-name}`).
    This naming convention for Azure resource ID uses a resource path strategy instead
    of AWS’s prefix and unique identifier strategy. As a result, Azure resource IDs
    can get rather long, but they do have a sensible way in which they can be deconstructed
    to gather valuable information about the deployment context of a particular resource,
    making additional lookups unnecessary.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 每个资源提供者中的资源类型也有子类型。这些子类型通过额外的斜杠分隔（例如虚拟机扩展：`Microsoft.Compute/virtualMachines/{vm-name}/extensions/{extension-name}`）。Azure
    的资源 ID 命名约定使用了资源路径策略，而不是像 AWS 那样使用前缀和唯一标识符策略。因此，Azure 的资源 ID 可能会相当长，但它们确实有一种合理的方式来解构，从而收集关于特定资源部署上下文的有价值信息，避免了额外的查找。
- en: 'When using the import command on Azure, it would look like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Azure 上使用导入命令时，命令如下所示：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The corresponding import block would look like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的导入块如下所示：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It’s important to remember that the address is the internal object reference
    within Terraform. The unique identifier is the external reference to the resource
    on the target cloud platform.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，地址是 Terraform 中的内部对象引用。唯一标识符是指向目标云平台上资源的外部引用。
- en: Google Cloud Platform
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Google Cloud Platform
- en: 'In Google Cloud, the unique identifier for a resource is called the **resource
    path**, and like Azure, it is composed of some important landmarks in the cloud
    resource’s location within Google Cloud. These landmarks differ from Azure’s due
    to the structural differences between the two platforms and other design considerations:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Google Cloud 中，资源的唯一标识符称为 **资源路径**，就像在 Azure 中一样，它由 Google Cloud 中资源位置的一些重要标志组成。这些标志与
    Azure 的不同，因为两个平台的结构差异以及其他设计考虑：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For example, the Google resource path for a Google compute instance would look
    like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Google 计算实例的 Google 资源路径如下所示：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this example, we see the concrete values for each component of the resource
    path:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们看到了资源路径中每个组件的具体值：
- en: '`proj-foo`.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proj-foo`。'
- en: '**Zone**: This indicates the physical location of the resource within a Google
    Cloud region and zone.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区域**：这表示资源在 Google Cloud 区域和可用区内的物理位置。'
- en: '`vmfoo001`.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vmfoo001`。'
- en: While Google Cloud does have higher-level organizational structures, such as
    the Google Cloud organization and the folders within that organization, a resource
    path only includes the Google Cloud project ID. This is similar to Azure’s resource
    ID, which includes the Azure subscription and resource group, as these are logical
    containers of the resource within the platform. Google opted for a more simplistic
    path by only including the project ID. A major difference between Google Cloud’s
    resource path and Azure’s resource ID is the inclusion of the zone within the
    resource path. The zone indicates the resource’s physical location within one
    of Google Cloud’s regions. Azure’s resource ID only includes logical structures
    such as subscription, resource group, resource provider, and type, not physical
    locations such as Azure regions or availability zones.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Google Cloud 确实具有更高层次的组织结构，如 Google Cloud 组织及其下的文件夹，但资源路径只包括 Google Cloud
    项目 ID。这类似于 Azure 的资源 ID，它包括 Azure 订阅和资源组，因为这些是平台中资源的逻辑容器。Google 选择了更简化的路径，只包含项目
    ID。Google Cloud 资源路径与 Azure 资源 ID 之间的一个主要区别是，Google 资源路径中包括了区域信息。区域表示资源在 Google
    Cloud 区域中的物理位置。Azure 的资源 ID 仅包括逻辑结构，如订阅、资源组、资源提供者和类型，不包括诸如 Azure 区域或可用区这样的物理位置。
- en: 'When using the import command on Google Cloud Platform, it would look like
    this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Google Cloud Platform 上使用导入命令时，命令如下所示：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The corresponding import block would look like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的导入块如下所示：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It’s important to remember that the address is the internal object reference
    within Terraform and the unique identifier is the external reference to the resource
    on the target cloud platform.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，地址是 Terraform 中的内部对象引用，唯一标识符是指向目标云平台上资源的外部引用。
- en: Now that we know a bit about how to identify the existing resources and the
    unique identifiers that we need to map to the resources defined within our code
    base, we are fully equipped to start manually importing resources into our Terraform
    code. However, is this the only way? Is there potentially a more cost-effective
    or time-sensitive approach that would allow us to import resources en masse? In
    the next section, we’ll explore some tools that allow us to find and import existing
    resources and generate their corresponding Terraform code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经了解了一些关于如何识别现有资源以及需要映射到我们代码库中定义的资源的唯一标识符的信息，我们完全准备好开始手动导入资源到我们的 Terraform
    代码中。然而，这真的是唯一的方法吗？是否有一种更具成本效益或时间敏感性的方法，能够让我们批量导入资源？在下一部分中，我们将探索一些工具，帮助我们找到并导入现有资源，并生成相应的
    Terraform 代码。
- en: Importing existing environments
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入现有环境
- en: As we saw in the previous sections of this chapter, Terraform contains extensive
    import mechanisms that allow us to import individuals and a multitude of existing
    resources into our Terraform code base. These tools can help us overcome transient
    errors that result in orphaned resources that need to be managed with an existing
    Terraform code base and Terraform state file.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面的部分所看到的，Terraform 包含了广泛的导入机制，这些机制允许我们将单个资源和大量现有资源导入到我们的 Terraform 代码库中。这些工具可以帮助我们克服暂时性错误，避免产生需要通过现有
    Terraform 代码库和 Terraform 状态文件管理的孤立资源。
- en: However, what happens when we don’t have any Terraform code written and many
    existing resources already provisioned within our cloud landscape? Manually reverse
    engineering all the Terraform code from scratch doesn’t seem like a useful way
    to spend our days. That’s why there are tools that help automate this process!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们没有编写任何 Terraform 代码，并且许多现有资源已经在云环境中配置好时，如何处理呢？从头开始手动反向工程所有 Terraform 代码似乎不是一个有用的时间投入方式。这就是为什么会有工具来帮助自动化这个过程！
- en: In this section, we’ll examine a couple of the most popular open-source tools
    for solving this problem.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将检查解决这个问题的几个最流行的开源工具。
- en: Terraformer
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Terraformer
- en: '**Terraformer** is an open-source tool developed by Google that helps with
    the process of importing existing cloud infrastructure into Terraform configuration
    and state. It supports various cloud providers, including the ones we’ve explored
    in this book. Naturally, Google Cloud is well-supported, including its main competitors
    (AWS and Azure), but a myriad of other Terraform providers also have support.
    Unlike the built-in capabilities of Terraform, this tool was designed to generate
    Terraform code and state based on the existing resources spread across your cloud
    landscape.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**Terraformer** 是由 Google 开发的一个开源工具，帮助将现有的云基础设施导入到 Terraform 配置和状态中。它支持多种云服务提供商，包括我们在本书中探索过的那些。当然，Google
    Cloud 得到了很好的支持，包括它的主要竞争对手（AWS 和 Azure），但许多其他 Terraform 提供商也得到了支持。与 Terraform 内建功能不同，这个工具的设计目的是根据分布在云环境中的现有资源生成
    Terraform 代码和状态。'
- en: This tool, and others like it, works by leveraging the cloud provider’s REST
    APIs in order to gather information about the various resources that have already
    been provisioned. You just need to point it in the right direction and give it
    some guardrails in order to narrow its field of vision. You simply pick up the
    resources that you want to bundle together into the same Terraform workspace and
    state file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具以及类似的工具，通过利用云提供商的 REST API 来收集有关已配置的各种资源的信息。你只需要将其指向正确的方向，并为其设置一些限制，以便缩小其视野范围。你只需选择想要打包在同一个
    Terraform 工作区和状态文件中的资源。
- en: 'The key command line arguments that allow you to scope Terraformer to just
    the resources you are interested in are resource types, regions, and tags. Depending
    on the provider, there may be limitations in resource type support, so it is best
    to check the current list of supported resources by using the following command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 允许你将 Terraformer 限定为仅处理你感兴趣的资源的关键命令行参数包括资源类型、区域和标签。根据提供商的不同，可能会存在资源类型支持的限制，因此最好使用以下命令检查当前支持的资源列表：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will help you inform how you will query the particular cloud platform.
    For example, when importing resources from AWS, we can determine that `s3` and
    `ec2_instance` are supported resource types:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将帮助你了解如何查询特定的云平台。例如，在从 AWS 导入资源时，我们可以确定 `s3` 和 `ec2_instance` 是支持的资源类型：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'On Azure, we’ll be using Azure-specific resource types and will often use the
    `--resource-group` argument to specify this Azure-specific logical structure to
    import resources:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure上，我们将使用Azure特定的资源类型，并经常使用`--resource-group`参数来指定这种Azure特定的逻辑结构以导入资源：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Likewise, on Google Cloud, we’ll use the Google Cloud Project, which is the
    logical structure that corresponds to Azure resource groups, to narrow the field:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在Google Cloud上，我们将使用Google Cloud项目，这是对应于Azure资源组的逻辑结构，以缩小领域：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Tags play an important role, as they provide a very fine-grained way to import
    exactly what we want into our Terraform workspaces:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 标签起着重要作用，因为它们提供了一种非常精细的方式来将我们想要的内容导入到我们的Terraform工作空间中：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can specify a very specific collection of tags that we pre-seed in our environments
    to get the most efficiency during the import process.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定一组非常具体的标签，这些标签我们预先在我们的环境中设置，以在导入过程中获得最高效率。
- en: The Azure Export Tool
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure导出工具
- en: There are other commercial and platform-specific tools that might do a better
    job than general-purpose tools like Google’s Terraformer. One example of this
    is the `azurerm` provider and the `azapi` provider, which are two Terraform providers
    that can be used to provision and manage Azure resources.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他商业和平台特定的工具，可能比像Google的Terraformer这样的通用工具做得更好。其中一个例子是`azurerm`提供者和`azapi`提供者，这两个Terraform提供者可以用来配置和管理Azure资源。
- en: Like Terraformer, the Azure Export Tool has several mechanisms for querying
    existing resources that should be included in the code generation process. It
    supports additional import options, such as a subscription-wide import, and eliminates
    the need to specify resource types. This can help speed up the process for Azure
    code generation by using a combination of `azurerm` and `azapi` providers. Since
    the `azapi` provider enables full support of every Azure resource, there are no
    resource type-based compatibility concerns that can’t be filled by using the `azapi`
    provider as a poly-fill when the `azurerm` resources are unavailable.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与Terraformer一样，Azure导出工具有几种查询现有资源的机制，应包括在代码生成过程中。它支持其他导入选项，如全订阅导入，并消除了指定资源类型的需求。这可以通过使用`azurerm`和`azapi`提供者的组合来加快Azure代码生成过程。由于`azapi`提供者支持每个Azure资源的完全支持，因此在`azurerm`资源不可用时，它可以作为多功能填充使用，而不会出现基于资源类型的兼容性问题。
- en: 'The command to import all the resources within a given Azure resource group
    would simply be as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 导入给定Azure资源组内所有资源的命令将简单地如下所示：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It can be run in an interactive or non-interactive mode. The interactive mode
    allows the end user to review the resources that will be imported and mapped to
    their corresponding references in the Terraform code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以在交互模式或非交互模式下运行。交互模式允许最终用户查看将被导入并映射到其相应引用的资源在Terraform代码中的资源。
- en: While the Azure Export Tool isn’t as widely known as the Terraformer project,
    it does have some interesting features that are useful within the context of Azure
    and the broader Terraform community as well. One example is the **append** feature
    that allows you to perform targeted code generation and append existing resources
    into an existing Terraform workspace.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Azure导出工具不像Terraformer项目那样广为人知，但它确实在Azure和更广泛的Terraform社区中有一些有趣的功能。例如，**附加**功能允许您执行有针对性的代码生成，并将现有资源附加到现有的Terraform工作空间中。
- en: Limitations
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制
- en: The allure of an efficient code generation tool for IaC and Terraform is very
    real. However, it is not without its limitations and common pitfalls that you
    should be aware of when venturing into this territory.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一个高效的基础设施即代码（IaC）和Terraform代码生成工具的吸引力确实存在。但是，在涉足这一领域时，你应该意识到它并非没有局限性和常见陷阱。
- en: 'The biggest challenges with code generation tools for Terraform are not unique
    problems within the realm of Terraform and IaC, but ones that affect the approach
    of reverse engineering or code generation in general. Code that is generated using
    reverse engineering tools often lacks the craftsmanship that handwritten code
    has engrained within it from day one. This can result in not only functional defects
    that need to be ferreted out but also countless occurrences of code quality and
    readability issues that need to be resolved before the code base can really be
    used for its intended purpose: to maintain cloud environments via IaC.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 的代码生成工具面临的最大挑战，并非 Terraform 和 IaC 领域独有的问题，而是普遍存在于逆向工程或代码生成方法中的问题。使用逆向工程工具生成的代码通常缺乏手写代码从一开始就融入的工艺感。这不仅可能导致功能缺陷需要排查，还可能出现无数的代码质量和可读性问题，这些问题必须在代码库真正用于其预期目的（即通过
    IaC 维护云环境）之前解决。
- en: One functional problem that often crops up in imported Terraform code bases
    is over-zealously defined explicit dependencies using the `depends_on` meta-argument.
    The `depends_on` clause is a valuable tool for resolving implicit dependencies
    between resources that Terraform can’t otherwise pick up automatically. However,
    in most cases, an explicit definition of these dependencies between resources
    is unnecessary, adds additional bloat and complexity to the code base, and can
    be detrimental to readability.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入的 Terraform 代码库中，常见的一个功能性问题是过度定义的显式依赖关系，使用了 `depends_on` 元数据参数。`depends_on`
    子句是解决 Terraform 无法自动识别的资源之间隐式依赖关系的有价值工具。然而，在大多数情况下，显式定义这些资源之间的依赖关系是没有必要的，会增加代码库的冗余和复杂性，还会影响代码的可读性。
- en: Another example is that when the resource configuration is extracted from the
    cloud platform, its values are largely imported as hard-coded values that are
    scattered across all the resources declared. This creates an immediate backlog
    of technical debt to rationalize related constant values and extract a sane and
    then desirable set of input variables that can be used to define relevant configuration
    settings.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是，当从云平台提取资源配置时，其值通常作为硬编码值导入，这些值分散在所有声明的资源中。这会立即产生技术债务，需对相关常量值进行合理化处理，并提取一组合理且理想的输入变量，以便用于定义相关的配置设置。
- en: Lastly, there are often write-only attributes on Terraform resources that will
    not be returned by the cloud platform’s REST APIs because they contain sensitive
    or secret information. This is by design to protect against secret leakage and
    would not be a problem if the resource was originally provisioned from Terraform,
    as those sensitive values would be stored in the state. However, this creates
    a bit of a refactoring process because it means that in most cases, your Terraform
    code base will not pass `terraform validate`, let alone `terraform plan`, without
    errors that need to be resolved.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Terraform 资源上常常存在仅可写属性，这些属性不会通过云平台的 REST API 返回，因为它们包含敏感或机密信息。出于保护机密信息泄露的设计考虑，这是正常现象。如果该资源最初是通过
    Terraform 配置的，这就不是问题，因为这些敏感值会存储在状态文件中。然而，这会带来一定的重构过程，因为在大多数情况下，你的 Terraform 代码库将无法通过
    `terraform validate`，更不用说 `terraform plan`，因为会有需要解决的错误。
- en: Running `plan` immediately after you generate the code and import the resources
    can help you pick up on subtle differences and irregularities in the import process.
    This can happen, as the terraform code generation is far from 100% accurate.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成代码并导入资源后立即运行 `plan`，有助于发现导入过程中可能存在的细微差异和不规则之处。这是有可能发生的，因为 Terraform 代码生成的准确度远未达到
    100%。
- en: As we can see, there are some pretty good options in the realm of tools that
    can automate the code generation and terraform state file creation of large landscapes
    of cloud resources across the multitude of Terraform providers available, including
    the three major cloud platforms that we focused on in this book. However, while
    code generation can expedite some parts of the process, it can also bring its
    own challenges that need to be addressed. In the next section, we’ll weigh the
    tradeoffs and discuss some best practices and alternatives for bringing existing
    environments under Terraform management.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在工具领域中，有一些相当不错的选项可以自动化大规模云资源的代码生成和 Terraform 状态文件创建，包括我们在本书中重点讨论的三大云平台。然而，虽然代码生成可以加快过程中的某些部分，但它也可能带来需要解决的挑战。在下一节中，我们将权衡取舍，并讨论一些最佳实践和替代方案，用于将现有环境纳入
    Terraform 管理。
- en: Best practices
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: We’ve looked at the built-in capabilities within Terraform to import individual
    resources and at how we can identify the existing resources that we want to import
    on different cloud platforms. We recognized some of the limitations of the built-in
    capabilities and looked at 3rd party alternatives that offer options of importing
    entire environments en masse, as well as the current limitations of such options.
    Now, we’ll look at best practices for how and when to use these different approaches
    to import existing resources and environments to bring them under the management
    of Terraform.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过 Terraform 内置的能力，能够导入单个资源，并且了解了如何识别在不同云平台上要导入的现有资源。我们认识到内置功能的一些局限性，并且看了
    3rd party 替代方案，这些替代方案提供了批量导入整个环境的选项，以及这些选项的当前局限性。现在，我们将探讨最佳实践，如何以及何时使用这些不同的方法将现有资源和环境导入并纳入
    Terraform 管理。
- en: Blast radius
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 爆炸半径
- en: When importing existing resources and bringing them under management using Terraform,
    it’s important to think carefully about the organization of those resources and
    how you want to compartmentalize them into working IaC solutions in the long term.
    This is the design principle of minimizing the **blast radius** of your Terraform
    modules. When we are importing resources, we are essentially establishing the
    boundaries of our root modules or Terraform workspaces.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入现有资源并将其纳入 Terraform 管理时，仔细思考这些资源的组织方式以及你希望如何将它们划分为长期有效的 IaC 解决方案是很重要的。这就是最小化**爆炸半径**的设计原则。当我们导入资源时，实际上是在确定我们根模块或
    Terraform 工作空间的边界。
- en: This is the ideal time to perform this design, as the workspaces have yet to
    be organized. It’s important to think this through, as it will affect how easy
    it is to manage, update, and replicate parts of your infrastructure, depending
    on how you group resources together.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是进行此设计的理想时机，因为工作空间尚未组织好。考虑清楚这一点很重要，因为它会影响你如何管理、更新和复制基础架构的部分内容，这取决于你如何将资源分组。
- en: You should consider the function that the resources will play and who will be
    responsible for managing them. Suppose a central team is responsible for maintaining
    a certain part of the architecture. In that case, you may want to consider organizing
    these resources together within the same Terraform workspace to make it easier
    to control access and reduce friction between teams.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该考虑资源将要发挥的功能以及谁负责管理它们。假设一个中央团队负责维护架构中的某个部分，那么你可能希望考虑将这些资源组织到同一个 Terraform
    工作空间内，以便更容易控制访问并减少团队之间的摩擦。
- en: Use tags to narrow your resource filter as you use Terraformer or other tools
    to generate code within your Terraform workspaces. Pre-seeding the cloud resources
    with tags that are fit for purpose will help you maximize the effectiveness of
    the Terraform import tools you use. This is especially important in AWS, where
    you lack logical containers for resources like those that are present on Azure
    and Google Cloud with resource groups and projects, respectively.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Terraformer 或其他工具在 Terraform 工作空间中生成代码时，使用标签来缩小资源筛选范围。为云资源预先添加合适用途的标签，将有助于你最大化使用
    Terraform 导入工具的效果。这一点在 AWS 中尤为重要，因为与 Azure 和 Google Cloud 上的资源组和项目不同，AWS 缺乏类似的资源逻辑容器。
- en: Sometimes moving slowly is moving fast
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有时，慢慢移动就是快速前进
- en: As an alternative to using an import tool to import resources on masse, you
    could use a lightweight technique using built-in import tools. This process is
    a bit tedious, but moving slowly sometimes allows you to be more purposeful and
    thoughtful. This process involves simply using querying techniques to identify
    the resources that you plan on importing and then scaffolding them using the most
    bare-bones Terraform resource definition. This resource definition is merely a
    placeholder and is very unlikely to match the configuration of the previously
    provisioned resource—but that’s not the point.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用导入工具批量导入资源的替代方法，你可以使用一种轻量级的技术，利用内建的导入工具。这个过程有点繁琐，但有时缓慢推进让你能够更加有目的和深思熟虑。这一过程仅仅涉及使用查询技术来识别你计划导入的资源，然后使用最基本的
    Terraform 资源定义将它们搭建起来。这个资源定义只是一个占位符，很可能与之前配置的资源的配置不匹配——但这并不是重点。
- en: The point is to import the existing resource into the state and then run a `terraform
    plan` to determine the configuration differences. You can then use the resulting
    plan to adjust the resource definition’s configuration in code to match the output
    from the plan until there are no more changes required.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于将现有资源导入状态，然后运行`terraform plan`来确定配置差异。接着，你可以使用生成的计划来调整资源定义的配置，以匹配计划输出，直到不再需要任何更改。
- en: With this approach, you are taking the opposite approach to bulk tool-based
    import. Rather than wielding a machete and traipsing through the jungle, you wield
    a scalpel and make extremely thoughtful cuts. You will have to manually configure
    it, but it will give you a more systematic and step-by-step understanding of the
    components you are importing and bringing under management. This deeper understanding
    can help you identify dependencies and flaws in your design that might get swept
    under the rug when following a bulk import process.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，你是在采取与批量工具导入相反的策略。与其挥舞砍刀穿越丛林，不如挥舞手术刀，做出极其细致的切割。你需要手动配置它，但这将让你对所导入并纳入管理的组件有一个更系统化、一步步的理解。这种更深入的理解可以帮助你识别出在批量导入过程中可能被忽略的依赖关系和设计缺陷。
- en: Blue/green deployment
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 蓝绿部署
- en: Another option is to consider alternatives to importation. Importing is a messy
    and very error-prone business. If you have critical infrastructure that was manually
    provisioned, you might want to consider replacing it with newly provisioned environments
    that are already under Terraform management.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是考虑替代导入的方法。导入是一个繁琐且容易出错的过程。如果你有一些手动配置的关键基础设施，你可能想要考虑用已经由 Terraform 管理的新环境替换它们。
- en: This approach is called a **blue/green deployment**. It is a well-known release
    management strategy whereby the existing **blue** environment is replaced through
    the construction of a new **green** environment. After the green environment is
    fully tested and ready to go, we perform a cutover operation to transition from
    the blue environment to the green environment.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法被称为**蓝绿部署**。这是一种广为人知的发布管理策略，通过构建一个新的**绿**环境来替换现有的**蓝**环境。在绿环境经过全面测试并准备就绪后，我们执行切换操作，从蓝环境切换到绿环境。
- en: You can set up new environments and transition workloads and applications into
    those. This will allow you to have a clean separation between environments that
    were provisioned manually without proper governance in place and those for which
    you followed best practices. Slowly transition your workloads, a piece at a time,
    to the new well-organized environment until the legacy environment is simply shut
    off.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以设置新环境，并将工作负载和应用程序迁移到其中。这将允许你在手动配置且没有适当治理的环境与遵循最佳实践的环境之间实现清晰的分离。你可以逐步地、一步一步地将工作负载迁移到新的有序环境，直到旧环境完全关闭。
- en: Using code generators will likely produce code of extremely poor quality that
    will require extensive refactoring. While some of this will be simple input variable
    extraction, moving resources into modules will become extremely tedious as the
    complexity of the environment increases. The effort to perform an import, refactor,
    and transform process might actually be greater than writing from scratch and
    cutting over gradually.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代码生成器可能会产生质量极差的代码，需要大量重构。虽然其中一些只是简单的输入变量提取，但随着环境复杂性的增加，将资源移入模块将变得异常繁琐。执行导入、重构和转换的工作量实际上可能比从零开始编写代码并逐步切换还要大。
- en: When you weigh the cost of putting the legacy environment into a “keep the lights
    on” mode while you build out the new world order, this allows your organization
    to maintain some normalcy and slowly adapt to the change of using IaC-managed
    environments over time rather than in one fell swoop.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当你权衡将遗留环境置于“保持灯火通明”模式的成本时，同时构建新的世界秩序，这样可以让你的组织在保持一定常态的同时，逐渐适应使用 IaC 管理环境的变化，而不是一蹴而就。
- en: In this section, we discussed some important rules of thumb for importing existing
    resources and environments under Terraform management. If you plan on performing
    bulk imports, first recognize the limitations of the tool that you will use and
    build in ample time for refactoring. Most importantly, make sure that you narrow
    the focus by defining a focused blast radius around your deployments.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了一些在 Terraform 管理下导入现有资源和环境的重要经验法则。如果你计划进行批量导入，首先要认识到你将使用的工具的局限性，并为重构预留充足的时间。最重要的是，通过定义一个集中的爆炸半径来缩小关注范围，围绕你的部署进行管理。
- en: If combing through a mountain of junk code and cleaning it all up through extensive
    refactoring doesn’t sound like your cup of tea, consider moving slowly by either
    reconstructing the environment through a highly focused step-by-step import process
    or going all the way and planning a blue/green deployment. My preferred method
    is blue/green, but you must carefully assess the impact on production environments
    to determine whether this is the best option for you.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果翻遍一大堆杂乱的代码并通过广泛重构清理它们听起来不太符合你的兴趣，可以考虑通过高度集中的逐步导入过程慢慢重建环境，或者直接进行蓝绿部署。我的首选方法是蓝绿部署，但你必须仔细评估对生产环境的影响，以确定这是否是最适合你的选择。
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at Terraform’s built-in capabilities for importing
    existing resources into Terraform state using imperative and declarative approaches.
    While the built-in import capabilities lack any sort of code generation, we looked
    at a few open source tools that analyzed existing environments and generated HashiCorp
    Configuration Language code to manage the resources and provide for them to be
    imported into the state. We discussed the relevant trade-offs between these different
    import techniques and when to consider each, which should help you decide the
    best course of action for your organization and teams. In the next chapter, we’ll
    look at how to manage and operate existing environments using Terraform.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 Terraform 内置的现有资源导入 Terraform 状态的能力，采用命令式和声明式的方法。尽管内置的导入功能缺乏任何形式的代码生成，但我们也介绍了一些开源工具，这些工具分析现有环境并生成
    HashiCorp 配置语言（HCL）代码来管理资源，并将其导入到状态中。我们讨论了这些不同导入技术的相关权衡以及何时考虑使用它们，这将帮助你为组织和团队决定最佳的行动方案。在下一章中，我们将讨论如何使用
    Terraform 管理和操作现有环境。
