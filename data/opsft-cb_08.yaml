- en: Chapter 8. OpenShift for Python Developers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章：针对 Python 开发者的 OpenShift
- en: 'This chapter presents a number of recipes that will help you to get started
    with Python web application development on OpenShift. This chapter contains the
    following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了一些配方，帮助你开始在 OpenShift 上进行 Python Web 应用开发。本章包含以下配方：
- en: Creating your first Python application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你的第一个 Python 应用程序
- en: Managing Python application dependencies
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理 Python 应用程序的依赖关系
- en: Creating and deploying Flask web applications using Python and PostgreSQL cartridges
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 和 PostgreSQL 模块创建和部署 Flask 网络应用程序
- en: Enabling hot deployment for Python applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用 Python 应用程序的热部署
- en: Forcing a clean Python virtual environment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制清除 Python 虚拟环境
- en: Accessing an application's Python virtual environment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问应用程序的 Python 虚拟环境
- en: Using Gevent with Python applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Python 应用程序中使用 Gevent
- en: Installing a custom Python package
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装自定义 Python 包
- en: Using the .htaccess file to configure Apache
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 .htaccess 文件配置 Apache
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Python is a general-purpose, high-level, easy-to-use, popular programming language.
    It is an interpreted language that emphasizes source code readability using strict
    indentation to determine code blocks. Python is very commonly used as a scripting
    language, but it is also very popular in the web application development and scientific
    computing world. There are various powerful web application frameworks, such as
    Django, Flask, Bottle, and Tornado, available to help developers build awesome
    web applications using the Python programming language.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种通用的高级编程语言，易于使用且非常流行。它是一种解释型语言，强调源代码的可读性，通过严格的缩进来确定代码块。Python 通常用作脚本语言，但它在
    Web 应用开发和科学计算领域也非常受欢迎。Python 拥有许多强大的 Web 应用框架，如 Django、Flask、Bottle 和 Tornado，帮助开发者使用
    Python 编程语言构建出色的 Web 应用程序。
- en: 'OpenShift provides Python web developers with a hosting platform to deploy
    their web applications. At the time of writing this book, it supports three versions
    of Python—2.6, 2.7, and 3.3\. You can view all the available Python versions by
    running the following command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift 为 Python Web 开发者提供了一个托管平台，用于部署他们的 Web 应用程序。在撰写本书时，OpenShift 支持三种版本的
    Python——2.6、2.7 和 3.3。你可以通过运行以下命令查看所有可用的 Python 版本：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The *Creating your first Python application* recipe will help you take your
    first steps toward developing Python applications on OpenShift. OpenShift supports
    Apache with the `mode_wsgi` HTTP server module ([https://code.google.com/p/modwsgi/](https://code.google.com/p/modwsgi/))
    to run your Python web applications. Python applications can choose any of the
    supported versions and run within a virtualenv tool. A virtualenv tool is an isolated
    and private copy of your Python installation, which will be only used for that
    project without affecting the system's global Python installation. The *Accessing
    an application's Python virtual environment* recipe will show you how to access
    the virtual environment by connecting to the application gear using SSH.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*创建你的第一个 Python 应用程序* 配方将帮助你迈出在 OpenShift 上开发 Python 应用程序的第一步。OpenShift 支持
    Apache 和 `mode_wsgi` HTTP 服务器模块（[https://code.google.com/p/modwsgi/](https://code.google.com/p/modwsgi/)）来运行你的
    Python Web 应用程序。Python 应用程序可以选择任何受支持的版本，并在虚拟环境工具（virtualenv）中运行。虚拟环境工具是你 Python
    安装的隔离和私有副本，它只会用于该项目，而不会影响系统的全局 Python 安装。*访问应用程序的 Python 虚拟环境* 配方将教你如何通过 SSH 连接到应用程序的设备，访问虚拟环境。'
- en: We will also cover various ways in which you can manage application dependencies
    in Python applications. You can use `requirements.txt` or `setup.py` or both to
    manage application dependencies. This will be covered in the *Managing Python
    application dependencies* recipe.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍在 Python 应用程序中管理应用依赖关系的不同方法。你可以使用 `requirements.txt` 或 `setup.py` 或两者结合来管理应用的依赖关系。这将会在*管理
    Python 应用程序依赖关系*配方中进行讲解。
- en: The example application in this chapter will be developed using the Flask web
    framework and PostgreSQL database. I choose Flask because of its popularity and
    ease of use. You can use any other web framework, such as Bottle, web2py, and
    Django. The *Creating and deploying Flask web applications using Python and PostgreSQL
    cartridges* recipe will cover step-by-step how to write Flask web applications
    on OpenShift. All the source code is available on the OpenShift-Cookbook GitHub
    organization ([https://github.com/OpenShift-Cookbook](https://github.com/OpenShift-Cookbook)).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例应用程序将使用 Flask Web 框架和 PostgreSQL 数据库进行开发。我选择 Flask 是因为它的流行和易用性。你也可以使用其他任何
    Web 框架，如 Bottle、web2py 和 Django。*使用 Python 和 PostgreSQL 插件创建和部署 Flask Web 应用程序*
    这一部分将逐步讲解如何在 OpenShift 上编写 Flask Web 应用程序。所有源代码都可以在 OpenShift-Cookbook GitHub
    组织中找到 ([https://github.com/OpenShift-Cookbook](https://github.com/OpenShift-Cookbook))。
- en: It is also feasible to use a standalone WSGI server, such as Gevent or Gunicorn,
    with OpenShift Python applications. The *Using Gevent with Python applications*
    recipe will cover this in detail.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用独立的 WSGI 服务器，如 Gevent 或 Gunicorn，也可以与 OpenShift Python 应用程序一起使用。*在 Python
    应用程序中使用 Gevent* 这一部分将详细讲解这一内容。
- en: If you want to run the examples on your local machine, please install Python,
    pip, and virtualenv. pip is a command-line tool to install and manage Python packages.
    The instructions to install Python for your operating system can be found at [http://docs.python-guide.org/en/latest/index.html](http://docs.python-guide.org/en/latest/index.html).
    Instructions to install pip can be found at [http://pip.readthedocs.org/en/latest/installing.html](http://pip.readthedocs.org/en/latest/installing.html).
    Finally, you can install virtualenv on your machine by following the instructions
    mentioned at [http://docs.python-guide.org/en/latest/dev/virtualenvs/](http://docs.python-guide.org/en/latest/dev/virtualenvs/).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在本地机器上运行示例，请安装 Python、pip 和 virtualenv。pip 是一个用于安装和管理 Python 包的命令行工具。你可以在
    [http://docs.python-guide.org/en/latest/index.html](http://docs.python-guide.org/en/latest/index.html)
    查找为你的操作系统安装 Python 的说明。在 [http://pip.readthedocs.org/en/latest/installing.html](http://pip.readthedocs.org/en/latest/installing.html)
    可以找到安装 pip 的说明。最后，你可以通过参考 [http://docs.python-guide.org/en/latest/dev/virtualenvs/](http://docs.python-guide.org/en/latest/dev/virtualenvs/)
    中提到的说明，在你的机器上安装 virtualenv。
- en: This chapter assumes that you are comfortable with the Python web development
    basics, OpenShift application basics, and how to work with OpenShift database
    cartridges. In case you are not comfortable with these topics, I recommend that
    you first read [Chapter 3](part0041_split_000.html#page "Chapter 3. Creating and
    Managing Applications"), *Creating and Managing Applications*, through [Chapter
    6](part0079_split_000.html#page "Chapter 6. Using MongoDB and Third-party Database
    Cartridges with OpenShift Applications"), *Using MongoDB and Third-party Database
    Cartridges with OpenShift Applications*, before continuing with this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设你已经熟悉 Python Web 开发基础、OpenShift 应用程序基础，以及如何使用 OpenShift 数据库插件。如果你对这些主题不太熟悉，建议你先阅读
    [第 3 章](part0041_split_000.html#page "Chapter 3. Creating and Managing Applications")，*创建和管理应用程序*，以及
    [第 6 章](part0079_split_000.html#page "Chapter 6. Using MongoDB and Third-party
    Database Cartridges with OpenShift Applications")，*在 OpenShift 应用程序中使用 MongoDB
    和第三方数据库插件*，然后再继续阅读本章内容。
- en: Creating your first Python application
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的第一个 Python 应用程序
- en: In this recipe, you will learn how to create an OpenShift Python application
    using the rhc command-line tool. We will create a Python 3.3 application and then
    understand the template application created by OpenShift.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何使用 rhc 命令行工具创建一个 OpenShift Python 应用程序。我们将创建一个 Python 3.3 应用程序，然后了解
    OpenShift 创建的模板应用程序。
- en: Getting ready
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To walk through this recipe, you will need the rhc command-line client installed
    on your machine. Please refer to the *Installing the OpenShift rhc command-line
    client* recipe in [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting
    Started with OpenShift"), *Getting Started with OpenShift*, for details.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本节的操作，你需要在你的机器上安装 rhc 命令行客户端。有关详细信息，请参考 [第 1 章](part0014_split_000.html#page
    "Chapter 1. Getting Started with OpenShift")，*开始使用 OpenShift* 中的 *安装 OpenShift
    rhc 命令行客户端* 部分。
- en: How to do it…
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Perform the following steps to create your first Python application:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤，创建你的第一个 Python 应用程序：
- en: Open a new command-line terminal, and change the directory to a convenient location
    where you want to create the application.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的命令行终端，并将目录切换到你希望创建应用程序的方便位置。
- en: 'To create a new Python 3.3 application, run the following command:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个新的 Python 3.3 应用程序，请运行以下命令：
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can replace Python 3.3 with Python 2.6 or Python 2.7 to create applications
    that use the respective Python versions.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以用 Python 2.6 或 Python 2.7 替换 Python 3.3，来创建使用相应 Python 版本的应用程序。
- en: Open your favorite web browser, and go to `http://myapp-{domain-name}.rhcloud.com`
    to view the application. Please replace `{domain-name}` with your OpenShift account
    domain name. You will see the OpenShift template application in your browser as
    follows:![How to do it…](img/00103.jpeg)
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你最喜欢的网页浏览器，访问 `http://myapp-{domain-name}.rhcloud.com` 来查看应用程序。请将 `{domain-name}`
    替换为你的 OpenShift 账户域名。你将看到如下所示的 OpenShift 模板应用程序：![如何操作…](img/00103.jpeg)
- en: How it works…
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: When you run the `rhc create-app` command, OpenShift broker will receive the
    request and will initiate the application creation process. The application creation
    process was explained in detail in the *Creating an OpenShift application using
    the rhc command-line client* recipe in [Chapter 3](part0041_split_000.html#page
    "Chapter 3. Creating and Managing Applications"), *Creating and Managing Applications*.
    To run your Python applications, OpenShift needs to know the Python version you
    want to use. In step 2, you specified that OpenShift should create a Python 3.3
    application with `myapp` as the application name. OpenShift will use these details
    along with a few defaults to create the `myapp` application. The defaults include
    a small gear size, non-scalable application, and the use of the current directory
    to clone the Git repository. To run Python-3.3-based web applications, OpenShift
    will install Python 3.3 language runtime and configure the Apache server with
    the `mod_wsgi` module. The `mod_wsgi` module provides an implementation of the
    **Web Server Gateway Interface** (**WSGI**) specification, allowing the Apache
    web server to host Python web applications that support the Python WSGI interface.
    The WSGI specification describes a simple interface between web servers and web
    applications or frameworks for the Python programming language. Most of the popular
    web frameworks ([http://wsgi.readthedocs.org/en/latest/frameworks.html](http://wsgi.readthedocs.org/en/latest/frameworks.html))
    in the Python community support the WSGI interface. This makes it very easy for
    developers to run their choice of framework on OpenShift, as it provides the Apache
    `mod_wsgi` deployment environment.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行 `rhc create-app` 命令时，OpenShift 经纪人将接收请求并启动应用程序创建过程。应用程序创建过程在 [第 3 章](part0041_split_000.html#page
    "Chapter 3. Creating and Managing Applications") *创建和管理应用程序* 的 *使用 rhc 命令行客户端创建
    OpenShift 应用程序* 一节中有详细说明。要运行你的 Python 应用程序，OpenShift 需要知道你希望使用的 Python 版本。在步骤
    2 中，你指定了 OpenShift 应该创建一个 Python 3.3 应用程序，并将 `myapp` 作为应用程序名称。OpenShift 将使用这些信息以及一些默认值来创建
    `myapp` 应用程序。默认值包括小型机种、不可扩展的应用程序，并使用当前目录来克隆 Git 仓库。要运行基于 Python-3.3 的网络应用程序，OpenShift
    将安装 Python 3.3 语言运行时，并配置 Apache 服务器与 `mod_wsgi` 模块。`mod_wsgi` 模块提供了 **Web 服务器网关接口**（**WSGI**）规范的实现，使
    Apache 网络服务器能够托管支持 Python WSGI 接口的 Python 网络应用程序。WSGI 规范描述了 Web 服务器与 Web 应用程序或框架之间的简单接口，适用于
    Python 编程语言。Python 社区中大多数流行的 Web 框架（[http://wsgi.readthedocs.org/en/latest/frameworks.html](http://wsgi.readthedocs.org/en/latest/frameworks.html)）都支持
    WSGI 接口。这使得开发人员可以轻松地在 OpenShift 上运行他们选择的框架，因为它提供了 Apache `mod_wsgi` 部署环境。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can also run Python web applications on alternative Python web servers,
    such as Gevent. This will be covered in the *Using Gevent with Python applications*
    recipe.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在其他 Python 网络服务器上运行 Python 网络应用程序，例如 Gevent。有关内容将在 *使用 Gevent 与 Python 应用程序*
    这一食谱中介绍。
- en: Apart from installing Python and configuring Apache with `mod_wsgi`, every OpenShift
    application uses virtualenv and pip to manage application dependencies. A virtualenv
    tool is an isolated and private copy of your Python installation, which will be
    only used for that project without affecting the system's global Python installation.
    You can install packages in a virtualenv tool using pip, and virtualenv will ensure
    the application has access only to the package that it needs. Another advantage
    of virtual environments is that they don't require administrative rights.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了安装 Python 并使用 `mod_wsgi` 配置 Apache，每个 OpenShift 应用程序都使用 virtualenv 和 pip 来管理应用程序的依赖关系。virtualenv
    工具是你 Python 安装的一个隔离和私有副本，仅用于该项目，不会影响系统的全局 Python 安装。你可以使用 pip 在 virtualenv 工具中安装包，virtualenv
    将确保应用程序只访问它所需的包。虚拟环境的另一个优点是它们不需要管理员权限。
- en: 'Now, let''s look at the template application created by OpenShift as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 OpenShift 创建的模板应用程序，如下所示：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The template application has three files—`requirements.txt`, `wsgi.py`, and
    `setup.py`—apart from the `.openshift` and `.git` directories. We have already
    talked about `.openshift` and `.git` in the *Creating an OpenShift application
    using the rhc command-line client* recipe in [Chapter 3](part0041_split_000.html#page
    "Chapter 3. Creating and Managing Applications"), *Creating and Managing Applications*,
    so I will not cover them here. Let''s talk about the three application files one
    by one:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 模板应用程序有三个文件——`requirements.txt`、`wsgi.py` 和 `setup.py`，此外还有 `.openshift` 和 `.git`
    目录。我们在 [第3章](part0041_split_000.html#page "第3章 创建和管理应用程序")的 *使用 rhc 命令行客户端创建 OpenShift
    应用程序* 章节中已经讨论过 `.openshift` 和 `.git`，所以这里就不再赘述。接下来，我们逐个讨论这三个应用程序文件：
- en: '`requirements.txt`: The `requirements.txt` file is used to specify libraries
    that your application depends on. The pip package manager will install all the
    application dependencies mentioned in `requirements.txt`. This is a regular text
    file with one dependency per line. The format is `[package name]==[package version]`.
    The sample `requirements.txt` file is shown as follows:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requirements.txt`：`requirements.txt` 文件用于指定应用程序依赖的库。pip 包管理器将安装 `requirements.txt`
    中列出的所有应用程序依赖项。这是一个普通的文本文件，每行列出一个依赖项。格式为 `[package name]==[package version]`。下面是一个示例
    `requirements.txt` 文件：'
- en: '[PRE3]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`setup.py`: The `setup.py` file allows developers to more easily build and
    distribute python packages that will be imported as dependencies by other projects.
    It allows you to specify project-specific metadata, such as name and description,
    as well as specify dependencies. The sample `setup.py` file is shown as follows:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup.py`：`setup.py` 文件使开发人员能够更轻松地构建和分发 Python 包，这些包将被其他项目作为依赖项导入。它允许你指定项目特定的元数据，如名称和描述，并指定依赖项。下面是一个示例
    `setup.py` 文件：'
- en: '[PRE4]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`wsgi.py`: The `wsgi.py` file is a WSGI-compatible application created by OpenShift.
    This file is mandatory if you want to use the Apache `mod_wsgi` server to host
    your Python web application. This file contains the code `mod_wsgi` module, which
    will execute on startup to get the application object. The application object
    is a callable that takes two parameters—`environ` and `start_response`. The `environ`
    parameter is a dictionary containing environment variables, and `start_response`
    is a callable that takes two required parameters: `status` and `response_headers`.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wsgi.py`：`wsgi.py` 文件是由 OpenShift 创建的一个 WSGI 兼容的应用程序文件。如果你想使用 Apache `mod_wsgi`
    服务器来托管 Python Web 应用程序，则该文件是必需的。这个文件包含了 `mod_wsgi` 模块的代码，启动时会执行该代码以获取应用程序对象。应用程序对象是一个可调用的对象，接受两个参数——`environ`
    和 `start_response`。`environ` 参数是一个字典，包含了环境变量，而 `start_response` 是一个可调用对象，接受两个必需的参数：`status`
    和 `response_headers`。'
- en: 'You can check the exact version of Python running inside the application gear
    by running the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令来检查应用程序环境中运行的 Python 的确切版本：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There's more...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: By default, a Python application expects `wsgi.py` to be available at the application's
    root directory. If you want to change the directory layout and use a different
    location for `wsgi.py`, you can set the `OPENSHIFT_PYTHON_WSGI_APPLICATION` environment
    variable to specify a different location, as shown in the following command. You
    can view the list of available environment variables for a Python application
    at [https://access.redhat.com/documentation/en-US/OpenShift_Online/2.0/html/User_Guide/Python_Environment_Variables.html](https://access.redhat.com/documentation/en-US/OpenShift_Online/2.0/html/User_Guide/Python_Environment_Variables.html).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Python 应用程序期望 `wsgi.py` 文件位于应用程序的根目录。如果你想更改目录结构并为 `wsgi.py` 设置不同的位置，可以通过设置
    `OPENSHIFT_PYTHON_WSGI_APPLICATION` 环境变量来指定一个不同的位置，如下所示。你可以在 [https://access.redhat.com/documentation/en-US/OpenShift_Online/2.0/html/User_Guide/Python_Environment_Variables.html](https://access.redhat.com/documentation/en-US/OpenShift_Online/2.0/html/User_Guide/Python_Environment_Variables.html)
    查看 Python 应用程序的环境变量列表。
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: See also
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Managing Python application dependencies* recipe
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*管理 Python 应用程序依赖* 章节'
- en: The *Enabling hot deployment for Python applications* recipe
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*启用 Python 应用程序的热部署* 章节'
- en: The *Creating and deploying Flask web applications using Python and PostgreSQL
    cartridges* recipe
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Python 和 PostgreSQL 套件创建和部署 Flask Web 应用程序* 章节'
- en: Managing Python application dependencies
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理 Python 应用程序依赖
- en: OpenShift gives the Python developer two options to specify their application
    dependencies. You can specify application dependencies either in the `install_requires`
    element in `setup.py`, in `requirements.txt`, or both. When dependencies are specified
    in both the `setup.py` and `requirements.txt` files, OpenShift will install all
    the libraries mentioned in both the files. The `setup.py` file is required when
    you want to distribute your library as a package that others can use. All the
    packages listed on PyPi need to have the `setup.py` script in their root directory.
    As you do not want to distribute your web applications as a package, there is
    no need to use the `setup.py` file. I recommend that you use `requirements.txt`
    for your OpenShift applications. The reason why `setup.py` exists is that OpenShift
    initially only supported `setup.py` and later added support for the `requirements.txt`
    file. So to make sure that the existing application continues to work on OpenShift,
    we need to support both the options. In this recipe, you will learn how to use
    `requirements.txt` to specify application dependencies. The source code of the
    application created in this recipe is available on GitHub ([https://github.com/OpenShift-Cookbook/chapter8-recipe2](https://github.com/OpenShift-Cookbook/chapter8-recipe2)).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift为Python开发者提供了两种指定应用程序依赖关系的方式。您可以在`setup.py`文件中的`install_requires`元素、`requirements.txt`文件中，或两者中指定应用程序依赖关系。当依赖关系在`setup.py`和`requirements.txt`文件中同时指定时，OpenShift将安装这两个文件中列出的所有库。当您想将库作为包分发给他人使用时，`setup.py`文件是必需的。PyPi上的所有包都需要在其根目录中包含`setup.py`脚本。由于您不打算将您的Web应用程序作为包分发，因此不需要使用`setup.py`文件。我建议您为OpenShift应用程序使用`requirements.txt`。`setup.py`之所以存在，是因为OpenShift最初仅支持`setup.py`，后来才添加了对`requirements.txt`文件的支持。因此，为了确保现有的应用程序在OpenShift上继续正常运行，我们需要支持这两种方式。在本食谱中，您将学习如何使用`requirements.txt`来指定应用程序依赖关系。此食谱中创建的应用程序源代码可以在GitHub上找到（[https://github.com/OpenShift-Cookbook/chapter8-recipe2](https://github.com/OpenShift-Cookbook/chapter8-recipe2)）。
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is based on the assumption that you have read the *Creating your
    first Python application* recipe. To walk through this recipe, you will need the
    rhc command-line client installed on your machine. Please refer to the *Installing
    the OpenShift rhc command-line client* recipe in [Chapter 1](part0014_split_000.html#page
    "Chapter 1. Getting Started with OpenShift"), *Getting Started with OpenShift*,
    for details. This recipe will require you to have virtualenv installed on your
    machine. You can install virtualenv on your machine by following the instructions
    mentioned at [http://docs.python-guide.org/en/latest/dev/virtualenvs/](http://docs.python-guide.org/en/latest/dev/virtualenvs/).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱假设您已经阅读了*创建您的第一个 Python 应用程序*食谱。为了跟随本食谱，您需要在您的机器上安装rhc命令行客户端。请参考[第1章](part0014_split_000.html#page
    "第1章. OpenShift入门")中的*安装OpenShift rhc命令行客户端*食谱，了解详细信息。本食谱还要求您在机器上安装virtualenv。您可以通过访问[http://docs.python-guide.org/en/latest/dev/virtualenvs/](http://docs.python-guide.org/en/latest/dev/virtualenvs/)中的说明来安装virtualenv。
- en: How to do it…
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Perform the following steps to build a `Hello World` Flask web application
    that will demonstrate how you can work with application dependencies:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来构建一个`Hello World` Flask Web应用程序，演示如何处理应用程序依赖关系：
- en: 'Open a new command-line terminal, and run the following command to create a
    new Python application:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的命令行终端，并运行以下命令来创建一个新的Python应用程序：
- en: '[PRE7]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you want to create Python 2.6 or Python 2.7 applications, use `python-2.6`
    or `python-2.7` as the web cartridge name instead of `python-3.3`.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您想创建Python 2.6或Python 2.7应用程序，请使用`python-2.6`或`python-2.7`作为Web cartridge名称，而不是`python-3.3`。
- en: 'Change the directory to `myapp`, and delete the `setup.py` file as follows:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将目录切换到`myapp`，并按如下方式删除`setup.py`文件：
- en: '[PRE8]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create a new virtual environment by running the following command:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令创建一个新的虚拟环境：
- en: '[PRE9]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Before you can work with the virtual environment, you have to activate it.
    To activate the virtual environment, run the following command:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始使用虚拟环境之前，您需要先激活它。要激活虚拟环境，请运行以下命令：
- en: '[PRE10]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once you have activated virtualenv, you can begin installing modules without
    affecting the system''s default Python interpreter. Install the Flask module by
    running the following command:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活virtualenv后，您可以开始安装模块，而不会影响系统的默认Python解释器。通过运行以下命令安装Flask模块：
- en: '[PRE11]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a new Python file named `hello.py` in the `myapp` directory, and populate
    it with the following code:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `myapp` 目录中创建一个名为 `hello.py` 的新 Python 文件，并在其中填入以下代码：
- en: '[PRE12]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To run this application on your local machine, run the following command:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在本地机器上运行此应用程序，请运行以下命令：
- en: '[PRE13]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next, open your favorite web browser, and go to `http://127.0.0.1:5000`. You
    will see **Hello World!** displayed in the browser.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开你喜欢的 Web 浏览器，访问 `http://127.0.0.1:5000`。你将看到浏览器中显示 **Hello World!**。
- en: 'To deploy this application on OpenShift, we have to declare all the dependencies
    in `requirements.txt`. The following command will write all of your application
    dependencies in `requirements.txt`:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将此应用程序部署到 OpenShift，我们需要在 `requirements.txt` 中声明所有依赖项。以下命令将把所有应用程序的依赖项写入 `requirements.txt`
    文件：
- en: '[PRE14]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding command will populate `requirements.txt` with all the application
    dependencies. This includes transitive dependencies as well. The `requirements.txt`
    file will look as shown in the following code:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述命令会将所有应用程序依赖项添加到 `requirements.txt` 文件中。这也包括传递性依赖项。`requirements.txt` 文件将如下所示：
- en: '[PRE15]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please make sure that the distribute version is 0.7.3, as earlier versions do
    not work with Python 3.3\. Earlier versions of the distribute are not compatible
    with Python 3.3, so you might face trouble if you use them.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请确保 distribute 的版本是 0.7.3，因为早期版本与 Python 3.3 不兼容。如果使用早期版本的 distribute，你可能会遇到问题。
- en: 'Also, we have to update the `wsgi.py` file to load the Flask application instead
    of the default one created by OpenShift. Delete all the content in the `wsgi.py`
    file, and replace it with the one shown in the following code:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们需要更新 `wsgi.py` 文件，以便加载 Flask 应用程序，而不是 OpenShift 默认创建的应用程序。在 `wsgi.py` 文件中删除所有内容，并用以下代码替换：
- en: '[PRE16]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a new file named `.gitignore` in the `myapp` directory, and add the
    `venv` directory to be ignored. We do not want to push the virtual environment
    to OpenShift; OpenShift will create the virtual environment based on the dependencies
    mentioned in the `requirements.txt` file. The `.gitignore` file is created as
    follows:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `myapp` 目录中创建一个名为 `.gitignore` 的新文件，并将 `venv` 目录添加到忽略列表中。我们不希望将虚拟环境推送到 OpenShift；OpenShift
    会根据 `requirements.txt` 文件中列出的依赖关系来创建虚拟环境。`.gitignore` 文件的内容如下：
- en: '[PRE17]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now commit the code to the local repository, and then push changes to application
    gear. OpenShift will install all the packages specified in the `requirements.txt`
    file and make them available to the application via the virtual environment as
    follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将代码提交到本地仓库，然后将更改推送到应用程序 gear。OpenShift 会安装 `requirements.txt` 文件中指定的所有包，并通过虚拟环境将它们提供给应用程序，具体操作如下：
- en: '[PRE18]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, you can see the application running at `http://myapp-{domain-name}.rhcloud.com`.
    Please replace `{domain-name}` with your application domain name. You will see
    **Hello World** in your browser.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以在 `http://myapp-{domain-name}.rhcloud.com` 查看应用程序运行情况。请将 `{domain-name}`
    替换为你的应用程序域名。你将在浏览器中看到 **Hello World**。
- en: How it works…
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: In the previous steps, you created a simple Flask framework web application
    that uses `requirements.txt` to specify application dependencies. Flask is a micro
    web framework for the Python programming language. It is an easy-to-learn framework
    with extensive documentation, which can be found at [http://flask.pocoo.org/docs](http://flask.pocoo.org/docs).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的步骤中，你创建了一个简单的 Flask 框架 Web 应用程序，该应用程序使用 `requirements.txt` 来指定应用程序的依赖项。Flask
    是 Python 编程语言的一个微型 Web 框架。它是一个易于学习的框架，且文档齐全，文档可以在 [http://flask.pocoo.org/docs](http://flask.pocoo.org/docs)
    找到。
- en: In step 1, you created a Python 3.3 application with the name `myapp`. Read
    the *Creating your first Python application* recipe to understand the Python application
    created by OpenShift. As you will use `requirement.txt` to specify application
    dependencies, you deleted the `setup.py` file in step 2\. If you wish, you can
    keep the `setup.py` file and specify your application metadata in it. The application
    metadata includes the name, description, version, and so on, of the application.
    I recommend that you specify application dependencies in only one file to avoid
    dependency hell ([http://en.wikipedia.org/wiki/Dependency_hell](http://en.wikipedia.org/wiki/Dependency_hell)).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 步中，你创建了一个名为 `myapp` 的 Python 3.3 应用程序。请阅读 *创建你的第一个 Python 应用程序* 配方，了解 OpenShift
    创建的 Python 应用程序。由于你将使用 `requirement.txt` 来指定应用程序依赖项，因此在第 2 步中删除了 `setup.py` 文件。如果愿意，你可以保留
    `setup.py` 文件，并在其中指定应用程序的元数据。应用程序元数据包括应用程序的名称、描述、版本等。我建议你仅在一个文件中指定应用程序依赖项，以避免出现依赖地狱
    ([http://en.wikipedia.org/wiki/Dependency_hell](http://en.wikipedia.org/wiki/Dependency_hell))。
- en: Step 3 created a new virtual environment using the Python 3.3 interpreter. To
    use a virtual environment, you have to first activate it using the command shown
    in step 4\. The virtual environment is the ideal way to work with Python applications,
    as it avoids polluting the system global Python installation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 第 3 步使用 Python 3.3 解释器创建了一个新的虚拟环境。要使用虚拟环境，你必须首先使用第 4 步中显示的命令激活它。虚拟环境是处理 Python
    应用程序的理想方式，因为它避免了污染系统全局的 Python 安装。
- en: You installed the Flask web framework using pip in step 5, as we are going to
    develop a web application that uses this framework. The Flask framework will be
    installed in the virtual environment and will become available to your application.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你在第 5 步使用 pip 安装了 Flask web 框架，因为我们将开发一个使用该框架的 web 应用程序。Flask 框架将被安装在虚拟环境中，并将可供你的应用程序使用。
- en: 'In step 6, you created a new Python file named `hello.py` and added the source
    code for the `Hello World` application. The code shown in step 6 does the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 6 步，你创建了一个新的 Python 文件 `hello.py`，并添加了 `Hello World` 应用程序的源代码。第 6 步中显示的代码执行了以下操作：
- en: In line 1, you imported the `Flask` class from the `flask` module.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 1 行，你从 `flask` 模块中导入了 `Flask` 类。
- en: In line 2, you created an instance of the `Flask` class. This instance will
    be that of the WSGI application.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 2 行，你创建了一个 `Flask` 类的实例。这个实例将成为 WSGI 应用程序的实例。
- en: Then, you defined a route for the root (`/`) URL. The route tells the Flask
    framework that it should invoke the `index()` function when a request is made
    to the root URL. The `index()` function will simply render **Hello World!** in
    the browser.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，你为根目录（`/`）URL 定义了一个路由。该路由告诉 Flask 框架，当请求根 URL 时，应该调用 `index()` 函数。`index()`
    函数将简单地在浏览器中渲染 **Hello World!**。
- en: Finally, if the name of the application module is equal to `'__main__`', the
    development server will be launched. The `__name__ == '__main__'` expression is
    used to ensure the development server is started only when the script is executed
    directly using the `python hello.py` command.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果应用程序模块的名称等于 `'__main__'`，开发服务器将启动。`__name__ == '__main__'` 表达式用于确保只有在直接使用
    `python hello.py` 命令执行脚本时，开发服务器才会启动。
- en: Step 7 started the development web server by executing the `hello.py` script.
    This will start the development server and launch the Flask application.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第 7 步通过执行 `hello.py` 脚本启动了开发 web 服务器。这将启动开发服务器并启动 Flask 应用程序。
- en: In step 8, you used the `pip freeze` command to add all the dependencies to
    the `requirements.txt` file. OpenShift will download all the dependencies mentioned
    in this file and populate the application virtual environment with them. OpenShift
    uses Apache `mod_wsgi` to run your Python applications. The entry point of `mod_wsgi`
    is the `wsgi.py` file. This file should contain the code that will provide the
    application object on startup. In step 9, you replaced the content of the `wsgi.py`
    file so that it uses the Flask application object instead of the application object
    created by the template.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 8 步，你使用 `pip freeze` 命令将所有依赖项添加到 `requirements.txt` 文件中。OpenShift 将下载该文件中提到的所有依赖项，并将它们填充到应用程序的虚拟环境中。OpenShift
    使用 Apache 的 `mod_wsgi` 来运行你的 Python 应用程序。`mod_wsgi` 的入口点是 `wsgi.py` 文件。这个文件应该包含在启动时提供应用程序对象的代码。在第
    9 步，你替换了 `wsgi.py` 文件的内容，使其使用 Flask 应用程序对象，而不是模板创建的应用程序对象。
- en: 'Finally, you committed the code to the local Git repository and pushed the
    code to the OpenShift application gear. OpenShift will first stop the Apache server,
    download all the dependencies mentioned in the `requirements.txt` file inside
    a virtual environment, and then finally start the Apache server. The part of the
    `git push` output is shown as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将代码提交到本地 Git 仓库，并将代码推送到 OpenShift 应用程序环境中。OpenShift 首先会停止 Apache 服务器，下载
    `requirements.txt` 文件中提到的所有依赖项并将它们安装到虚拟环境中，然后最终启动 Apache 服务器。`git push` 输出的一部分如下所示：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There's more...
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: If you want to use `setup.py` instead of `requirements.txt`, you can delete
    `requirement.txt` or keep it empty and specify all the requirements under the
    `install_requires` element, as shown in the following code. The full source code
    of the application is available on GitHub at [https://github.com/OpenShift-Cookbook/chapter8-recipe2-setup.py](https://github.com/OpenShift-Cookbook/chapter8-recipe2-setup.py).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望使用 `setup.py` 而不是 `requirements.txt`，可以删除 `requirements.txt` 文件，或者保持为空，并在
    `install_requires` 元素下指定所有依赖项，如下所示。应用程序的完整源代码可以在 GitHub 上查看：[https://github.com/OpenShift-Cookbook/chapter8-recipe2-setup.py](https://github.com/OpenShift-Cookbook/chapter8-recipe2-setup.py)。
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: See also
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Creating your first Python application* recipe
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建你的第一个 Python 应用* 这个配方'
- en: The *Enabling hot deployment for Python applications* recipe
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*启用 Python 应用的热部署* 这个配方'
- en: The *Creating and deploying Flask web applications using Python and PostgreSQL
    cartridges* recipe
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Python 和 PostgreSQL 插件创建和部署 Flask 网络应用* 这个配方'
- en: Creating and deploying Flask web applications using Python and PostgreSQL cartridges
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Python 和 PostgreSQL 插件创建和部署 Flask 网络应用
- en: In this recipe, you will develop a simple job portal application using the Python
    Flask web framework ([http://flask.pocoo.org/](http://flask.pocoo.org/)) and the
    PostgreSQL database. I have chosen Flask because it is a very easy-to-use and
    popular web framework. You can run any web framework, such as Django, Bottle,
    Zope, and Tornado, on OpenShift. The example application will allow users to post
    job openings and view a list of all the persisted jobs in the system. These two
    functionalities will be exposed using the two REST endpoints. The source code
    for this recipe is available on GitHub at [https://github.com/OpenShift-Cookbook/chapter8-jobstore-simple](https://github.com/OpenShift-Cookbook/chapter8-jobstore-simple).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，你将使用 Python Flask 网络框架（[http://flask.pocoo.org/](http://flask.pocoo.org/)）和
    PostgreSQL 数据库开发一个简单的职位门户应用。我选择 Flask 是因为它是一个非常易于使用且流行的网络框架。你可以在 OpenShift 上运行任何网络框架，如
    Django、Bottle、Zope 和 Tornado。示例应用将允许用户发布职位空缺并查看系统中所有已保存职位的列表。这两个功能将通过两个 REST 端点提供。此配方的源代码可在
    GitHub 上找到：[https://github.com/OpenShift-Cookbook/chapter8-jobstore-simple](https://github.com/OpenShift-Cookbook/chapter8-jobstore-simple)。
- en: Getting ready
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is based on the assumption that you have read previous recipes in
    this chapter. To walk through this recipe, you will need the rhc command-line
    client installed on your machine. Please refer to the *Installing the OpenShift
    rhc command-line client* recipe in [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting
    Started with OpenShift"), *Getting Started with OpenShift*, for details. Also,
    if you want to run the application on your local machine, you will need to have
    Python, pip, and virtualenv installed on your machine. Please refer to the introduction
    section for links to installation instructions for respective software.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方假设你已经阅读了本章前面的配方。要执行此配方，你需要在计算机上安装 rhc 命令行客户端。有关详细信息，请参考 [第 1 章](part0014_split_000.html#page
    "第 1 章：OpenShift 入门") 中的 *安装 OpenShift rhc 命令行客户端* 配方。此外，如果你想在本地机器上运行应用，你需要安装
    Python、pip 和 virtualenv。请参考引言部分获取安装说明的链接。
- en: How to do it…
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'To create the application, perform the following steps:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建应用，执行以下步骤：
- en: 'Open a new command-line terminal, and navigate to a convenient location where
    you want to create the application. Create a new Python 2.7 and PostgreSQL 9.2
    OpenShift application, and type the following command:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的命令行终端，并导航到你希望创建应用的便捷位置。创建一个新的 Python 2.7 和 PostgreSQL 9.2 OpenShift 应用，并输入以下命令：
- en: '[PRE21]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After the application is created, change the directory to `jobstore`, and delete
    the `setup.py` file:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建应用后，切换到 `jobstore` 目录，并删除 `setup.py` 文件：
- en: '[PRE22]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Also, create a `.gitignore` file, and add the following to it:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时，创建一个 `.gitignore` 文件，并将以下内容添加到其中：
- en: '[PRE23]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a new virtual environment for the `jobstore` application. Run the following
    command to create the virtual environment, and then activate it:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `jobstore` 应用创建一个新的虚拟环境。运行以下命令创建虚拟环境，然后激活它：
- en: '[PRE24]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now that the virtual environment is activated, you can install the application
    dependencies. This application uses the Flask web framework. To install the dependencies
    in the virtual environment, run the following command:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在虚拟环境已激活，你可以安装应用的依赖项。此应用使用 Flask 网络框架。要在虚拟环境中安装依赖项，运行以下命令：
- en: '[PRE25]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create a new file named `jobstore.py`, which will house the application source
    code. The following code is a simple Flask application that renders an `index.html`
    file when a request is made to the root URL:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `jobstore.py` 的新文件，用于存放应用的源代码。以下代码是一个简单的 Flask 应用，当请求根 URL 时，它会渲染一个 `index.html`
    文件：
- en: '[PRE26]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the previous code, the index route will render `index.html` when a request
    is made to the root URL. By default, Flask looks for templates in the `templates`
    directory inside the application folder. The `render_template()` function provided
    by the Flask framework integrates the Jinja 2 template engine with the application.
    To make sure this code works, create a new directory named `templates` in the
    application source code repository as follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在之前的代码中，索引路由将在请求根 URL 时渲染 `index.html`。默认情况下，Flask 会在应用程序文件夹内的 `templates` 目录中查找模板。Flask
    框架提供的 `render_template()` 函数将 Jinja 2 模板引擎集成到应用程序中。为了确保此代码能正常工作，在应用程序源代码仓库中创建一个名为
    `templates` 的新目录，如下所示：
- en: '[PRE27]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, create a new `index.html` file inside the `templates` directory, and add
    the following content to it:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `templates` 目录中创建一个新的 `index.html` 文件，并添加以下内容：
- en: '[PRE28]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can test the application when you start the Python server by running the
    following command:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令来启动 Python 服务器，测试应用程序：
- en: '[PRE29]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To view the application, go to `http://127.0.0.1:5000/` in your favorite browser.
    You will see `index.html` rendered in your browser.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看应用程序，打开你喜欢的浏览器，访问 `http://127.0.0.1:5000/`。你将看到浏览器中渲染的 `index.html`。
- en: 'The main responsibility of this application is to store the job data in the
    database. Python has support functionalities for various database frameworks that
    makes it very easy to work with a variety of databases. Among them, SQLAlchemy
    is the most popular and powerful relational database framework that supports various
    RDBMS backends. To use SQLAlchemy with Flask applications, you have to first install
    the Flask SQLAlchemy extension. The Flask SQLAlchemy extension simplifies working
    with SQLAlchemy inside Flask applications. To install Flask SQLAlchemy, run the
    following `pip` command:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该应用程序的主要职责是将工作数据存储到数据库中。Python 为多种数据库框架提供了支持功能，使得操作各种数据库变得非常容易。其中，SQLAlchemy
    是最受欢迎且功能强大的关系型数据库框架，支持多种 RDBMS 后端。要在 Flask 应用程序中使用 SQLAlchemy，你首先需要安装 Flask SQLAlchemy
    扩展。Flask SQLAlchemy 扩展简化了在 Flask 应用程序中使用 SQLAlchemy 的工作。要安装 Flask SQLAlchemy，可以运行以下
    `pip` 命令：
- en: '[PRE30]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now that you have installed the Flask SQLAlchemy extension, the next task is
    to write the configuration code so that the `jobstore` application can connect
    to the PostgreSQL database. Add the following content to `jobstore.py`. You can
    view the full source code on GitHub at [https://github.com/OpenShift-Cookbook/chapter8-jobstore-simple/blob/master/jobstore.py](https://github.com/OpenShift-Cookbook/chapter8-jobstore-simple/blob/master/jobstore.py).
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经安装了 Flask SQLAlchemy 扩展，下一步是编写配置代码，以便 `jobstore` 应用程序能够连接到 PostgreSQL 数据库。将以下内容添加到
    `jobstore.py` 中。你可以在 GitHub 上查看完整的源代码：[https://github.com/OpenShift-Cookbook/chapter8-jobstore-simple/blob/master/jobstore.py](https://github.com/OpenShift-Cookbook/chapter8-jobstore-simple/blob/master/jobstore.py)。
- en: '[PRE31]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding code, you added two configuration options to the Flask application
    configuration object. `SQLALCHEMY_DATABASE_URI` points to the database connection
    URL. OpenShift exposes the PostgreSQL database connection URL using the `OPENSHIFT_POSTGRESQL_DB_URL`
    environment variable. The `SQLALCHEMY_COMMIT_ON_TEARDOWN` option enables automatic
    commits of database changes at the end of each request. Finally, you instantiated
    the `db` object from the `SQLAlchemy` class, passing it the application object.
    This `db` object provides access to all the database-related functionalities.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的代码中，你向 Flask 应用程序配置对象添加了两个配置选项。`SQLALCHEMY_DATABASE_URI` 指向数据库连接 URL。OpenShift
    使用 `OPENSHIFT_POSTGRESQL_DB_URL` 环境变量公开 PostgreSQL 数据库连接 URL。`SQLALCHEMY_COMMIT_ON_TEARDOWN`
    选项启用在每个请求结束时自动提交数据库更改。最后，你实例化了来自 `SQLAlchemy` 类的 `db` 对象，并将应用程序对象传递给它。这个 `db`
    对象提供了所有与数据库相关的功能。
- en: 'Next, you will write a model class to represent the `Job` table in the PostgreSQL
    database. The model represents a persistent entity stored in the database. The
    `db` instance that we got in step 7 provides a base class that a model can extend.
    Apart from this, the `db` object also provides helper functions to define the
    structure of a model class. The `Job` model is shown as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你将编写一个模型类来表示 PostgreSQL 数据库中的 `Job` 表。模型表示存储在数据库中的持久化实体。我们在第 7 步中获得的 `db`
    实例提供了一个可以扩展的基类。除此之外，`db` 对象还提供了帮助函数来定义模型类的结构。`Job` 模型如下所示：
- en: '[PRE32]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `__tablename__` variable is used to define the name of the table in the
    database. The `db.Column()` function is used to define the class variables that
    will be mapped to columns in the database table. You also defined a couple of
    helper functions that will help convert to and from JSON. These methods will be
    useful when we build the REST API.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`__tablename__` 变量用于定义数据库中表的名称。`db.Column()` 函数用于定义类变量，这些变量将映射到数据库表中的列。你还定义了几个帮助函数，帮助进行
    JSON 转换。这些方法在我们构建 REST API 时将非常有用。'
- en: 'Now you will write a couple of REST endpoints that will expose a couple of
    functionalities. The first endpoint will allow users to list all the jobs inside
    the database, and the second endpoint will allow users to create a new job. The
    REST endpoints are shown as follows:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你将编写几个 REST 端点来暴露一些功能。第一个端点将允许用户列出数据库中的所有职位，第二个端点将允许用户创建一个新职位。REST 端点如下所示：
- en: '[PRE33]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the previous code, the `all_jobs()` function queries the database for all
    the `Job` rows. The result from the database is converted to JSON and returned
    to the user. The `jsonify()` function is provided by Flask and creates a response
    with the JSON representation and the `application/json` MIME type.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，`all_jobs()` 函数从数据库中查询所有的 `Job` 行。数据库返回的结果被转换为 JSON 格式并返回给用户。`jsonify()`
    函数是 Flask 提供的，它会创建一个带有 JSON 表示和 `application/json` MIME 类型的响应。
- en: The `post_job()` function first converts the JSON request to the `Job` object
    and then writes it to the database. Finally, it returns the persisted job to the
    user.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`post_job()` 函数首先将 JSON 请求转换为 `Job` 对象，然后将其写入数据库。最后，它会将持久化的职位返回给用户。'
- en: 'As discussed in the *Managing Python application dependencies* recipe, you
    have to update the `wsgi.py` file to load the Flask application instead of the
    default created by OpenShift. Delete all the content in the `wsgi.py` file, and
    replace it with the one shown in the following code:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如在 *管理 Python 应用程序依赖项* 章节中讨论的，你必须更新 `wsgi.py` 文件，以加载 Flask 应用程序，而不是 OpenShift
    默认创建的应用程序。删除 `wsgi.py` 文件中的所有内容，并用以下代码替换：
- en: '[PRE34]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The last thing to do before we can deploy the application is specify the dependencies
    in `requirements.txt`. Run the following command to populate the application `requirements.txt`
    file:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们部署应用程序之前，最后一步是指定 `requirements.txt` 中的依赖项。运行以下命令来填充应用程序的 `requirements.txt`
    文件：
- en: '[PRE35]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, commit the code and push the application changes to the application gear
    as follows:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，提交代码并将应用程序更改推送到应用程序 gear，如下所示：
- en: '[PRE36]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The application will be up and running at `http://jobstore-{domain-name}.rhcloud.com`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序将在 `http://jobstore-{domain-name}.rhcloud.com` 启动并运行。
- en: 'To test the REST endpoints, you could use cURL. To create a new `Job` instance,
    run the following cURL command:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试 REST 端点，你可以使用 cURL。要创建一个新的 `Job` 实例，请运行以下 cURL 命令：
- en: '[PRE37]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To view all the jobs, you can run the following cURL command:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看所有的职位，可以运行以下 cURL 命令：
- en: '[PRE38]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works…
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: In the previous steps, you created a Python web application and deployed it
    on OpenShift. From steps 1 through 4, you first created a new Python 2.7 OpenShift
    application, created a virtual environment for the project, and finally activated
    the virtual environment. The application uses the Python Flask framework, so you
    installed it using pip in step 5.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的步骤中，你创建了一个 Python Web 应用程序并将其部署到 OpenShift。从步骤 1 到 4，你首先创建了一个新的 Python 2.7
    OpenShift 应用程序，为项目创建了一个虚拟环境，并最终激活了虚拟环境。该应用程序使用 Python Flask 框架，因此你在步骤 5 中通过 pip
    安装了它。
- en: 'In steps 6 through 8, you created a Flask web application that renders the
    `index.html` file. The code shown in step 4 does the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 6 到 8 中，你创建了一个 Flask Web 应用程序，该应用程序渲染 `index.html` 文件。步骤 4 中显示的代码执行了以下操作：
- en: You imported all the required classes and functions.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你导入了所有必需的类和函数。
- en: 'Then, you created an instance of the `Flask` class. The only required argument
    is the name of the main module or package of the application. The correct value
    is `__name__` in most cases.     Then, you defined a route for the root URL using the `app.route` decorator. A
    route allows you to bind HTTP requests to function calls based on the URL requested.
    The index function will render `index.html` in the browser.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，你创建了一个 `Flask` 类的实例。唯一需要的参数是应用程序的主模块或包的名称。在大多数情况下，正确的值是 `__name__`。接着，你使用
    `app.route` 装饰器为根 URL 定义了一个路由。路由允许你根据请求的 URL 将 HTTP 请求绑定到函数调用。`index` 函数将在浏览器中渲染
    `index.html` 文件。
- en: Finally, if the name of the application module is equal to `'_ _main_ _`', the
    development server is launched. The `__name__ == '__main__'` expression is used
    to ensure the development server is started only when the script is executed directly
    using the `python jobstore.py` command. You tested the application on your local
    machine in step 10.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果应用模块的名称等于`'__main__'`，则启动开发服务器。`__name__ == '__main__'`表达式用于确保只有在通过`python
    jobstore.py`命令直接执行脚本时，才启动开发服务器。你在第10步中在本地机器上测试了该应用程序。
- en: 'In steps 11 through 14, you first installed the Flask SQLAlchemy extension
    and then did the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11至第14步中，你首先安装了Flask SQLAlchemy扩展，然后执行了以下操作：
- en: First, you imported the `SQLAlchemy` class from the `Flask-SQLAlchemy` extension.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，你从`Flask-SQLAlchemy`扩展中导入了`SQLAlchemy`类。
- en: Then, you configured the URL of the application database using `SQLALCHEMY_DATABASE_URI`
    in the Flask configuration object. You also used another useful option, `SQLALCHEMY_COMMIT_ON_TEARDOWN`,
    to configure the automatic commits of the database changes at the end of each
    request.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接着，你使用Flask配置对象中的`SQLALCHEMY_DATABASE_URI`配置了应用数据库的URL。你还使用了另一个有用的选项`SQLALCHEMY_COMMIT_ON_TEARDOWN`，配置了在每个请求结束时自动提交数据库更改。
- en: Next, you created an instance of the `SQLAlchemy` class that provides access
    to all the SQLAlchemy APIs.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，你创建了一个`SQLAlchemy`类的实例，该实例提供对所有SQLAlchemy API的访问。
- en: Then, you defined the `Job` model class using the SQLAlchemy API. The `company`
    class extends the `db.Model` base class and uses the `db.Column` constructor to
    define the structure of the model class. The `__tablename__` variable is used
    to define the name of the table in the database.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接着，你使用SQLAlchemy API定义了`Job`模型类。`company`类继承了`db.Model`基类，并使用`db.Column`构造函数定义了模型类的结构。`__tablename__`变量用于定义数据库中表的名称。
- en: Finally, you defined a couple of helper functions that will help convert to
    and from JSON. These methods will be useful when we build the REST API.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，你定义了一些辅助函数，帮助在JSON与其他格式之间转换。这些方法在我们构建REST API时非常有用。
- en: 'In step 15, you defined REST endpoints for the `Job` model class. The code
    listing shown in step 15 does the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在第15步中，你为`Job`模型类定义了REST端点。第15步中的代码列表执行了以下操作：
- en: When a user makes a `GET` request to `/api/v1/jobs`, the `all_jobs()` function
    is invoked. The function finds all the jobs using the SQLAlchemy API, iterates
    over the result set, and then converts it into JSON.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户向`/api/v1/jobs`发送`GET`请求时，将调用`all_jobs()`函数。该函数通过SQLAlchemy API查找所有的工作记录，遍历结果集，然后将其转换为JSON格式。
- en: When a user makes a `POST` request to `/api/v1/jobs`, a new job is created.
    The JSON data is exposed as the `request.json` Python dictionary. Then, the `request.json`
    dictionary is converted into the `Job` object using the `from_json` method. The
    data is then persisted into the database using the `db.session` API.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户向`/api/v1/jobs`发送`POST`请求时，将创建一个新工作。JSON数据作为`request.json` Python字典暴露出来。然后，`request.json`字典通过`from_json`方法转换为`Job`对象。数据随后通过`db.session`
    API持久化到数据库中。
- en: In step 16, you replaced the content of the `wsgi.py` file so that it uses the
    Flask application object instead of the application object created by the template.
    Finally, you committed the code to your local Git repository and then pushed the
    changes to the OpenShift application gear. Once deployed, you can go to `http://jobstore-{domain-name}.rhcloud.com`
    and work with the application.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在第16步中，你替换了`wsgi.py`文件的内容，使其使用Flask应用对象，而不是模板中创建的应用对象。最后，你将代码提交到本地Git仓库，然后将更改推送到OpenShift应用程序设备。一旦部署完成，你可以访问`http://jobstore-{domain-name}.rhcloud.com`并使用该应用程序。
- en: There's more
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'You can do all the previously performed steps with just a single command. The
    Git repository mentioned in the command contains the source code for this recipe
    as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过一个命令完成之前执行的所有步骤。命令中提到的Git仓库包含此食谱的源代码，如下所示：
- en: '[PRE39]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: See also
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: The *Creating your first Python application* recipe
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建你的第一个Python应用程序*食谱'
- en: The *Enabling hot deployment for Python applications* recipe
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为Python应用程序启用热部署*食谱'
- en: Enabling hot deployment for Python applications
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Python应用程序启用热部署
- en: Every time you make a change to your application source code and push the changes
    to the OpenShift application gear Git repository, OpenShift first stops your gear
    (which stops all the cartridges installed on the gear), copies the source code
    from your application Git repository to `app-root/runtime/repo`, performs a build,
    prepares the artifact, and finally starts your gear (which starts all the cartridges).
    This process takes time and does not suit rapid development and deployment. To
    enable rapid development and faster deployments, OpenShift supports hot deployment.
    Hot deployment means that you can deploy your changes without the need to restart
    all the application cartridges.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你修改应用程序源代码并将更改推送到 OpenShift 应用程序服务器的 Git 仓库时，OpenShift 首先会停止你的服务器（这会停止所有安装在服务器上的组件），然后将源代码从应用程序
    Git 仓库复制到 `app-root/runtime/repo`，进行构建，准备工件，最后启动服务器（这会启动所有组件）。这个过程需要时间，不适合快速开发和部署。为了实现快速开发和更快速的部署，OpenShift
    支持热部署。热部署意味着你可以在不需要重启所有应用程序组件的情况下部署你的更改。
- en: In this recipe, you will learn how you can enable hot deployment for Python
    applications.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，你将学习如何为 Python 应用程序启用热部署。
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This recipe will work with all the three supported Python versions.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程适用于所有三个支持的 Python 版本。
- en: How to do it…
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Perform the following steps to enable hot deployment for your application:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤为你的应用程序启用热部署：
- en: 'Create a new Python application using the source code developed in the previous
    recipe as follows:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前面教程中开发的源代码，创建一个新的 Python 应用程序，方法如下：
- en: '[PRE40]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Open the `hello.py` file, and update `Hello World!` to `Hello from OpenShift`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `hello.py` 文件，并将 `Hello World!` 更新为 `Hello from OpenShift`。
- en: To enable hot deployment, create an empty file named `hot_deploy` under the
    `.openshift/markers` directory. This file is called the marker file, as this does
    not contain any content. On the *nix machine, you can create a new file by executing
    the following command. On a Windows machine, you can use file explorer to create
    a new file.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启用热部署，在 `.openshift/markers` 目录下创建一个名为 `hot_deploy` 的空文件。这个文件被称为标记文件，因为它不包含任何内容。在
    *nix 系统中，你可以通过执行以下命令来创建一个新文件。在 Windows 系统中，你可以使用文件资源管理器创建一个新文件。
- en: '[PRE41]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Add the file to the Git repository, and then commit and push changes to the
    application gear as shown in the following code:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件添加到 Git 仓库，然后提交并推送更改到应用程序服务器，如以下代码所示：
- en: '[PRE42]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the `git push` logs, you will see a message that cartridges are not stopped
    because hot deployment is enabled as follows:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `git push` 日志中，你会看到一条信息，说明因为启用了热部署，所以组件没有停止，如下所示：
- en: '[PRE43]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now open the application URL in your favorite web browser, and you will see
    the change deployed without a restart.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在你喜欢的网页浏览器中打开应用程序 URL，你会看到更改已部署而无需重启。
- en: How it works…
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The presence of the `hot_deploy` marker file informs OpenShift that you want
    to do hot deployment. Before stopping and starting the application cartridges,
    OpenShift checks for the existence of the `hot_deploy` marker file. If the `hot_deploy`
    marker file exists, OpenShift will not stop the cartridges, and changes will be
    deployed without cartridge restart. Hot deployment is ideal for development, and
    I recommend that you should always use it during development.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`hot_deploy` 标记文件的存在告知 OpenShift 你想要进行热部署。在停止并重新启动应用程序组件之前，OpenShift 会检查 `hot_deploy`
    标记文件是否存在。如果 `hot_deploy` 标记文件存在，OpenShift 将不会停止组件，且更改将无需重启组件就会部署。热部署非常适合开发过程，我建议你在开发过程中始终使用它。'
- en: Note
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you set new environment variables with hot deployment enabled or install
    new cartridges, you have to restart the application to allow the server to pick
    the new environment variables.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你启用了热部署并设置了新的环境变量或安装了新的组件，你需要重启应用程序，以便服务器能读取新的环境变量。
- en: See also
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: The *Forcing a clean Python virtual environment* recipe
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*强制清理 Python 虚拟环境* 教程'
- en: The *Accessing an application's Python virtual environment* recipe
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*访问应用程序的 Python 虚拟环境* 教程'
- en: Forcing a clean Python virtual environment
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制清理 Python 虚拟环境
- en: The first time you push your changes to the application gear, pip will download
    all the dependencies mentioned in `setup.py` or `requirements.txt` and populate
    the virtual environment with these dependencies. On every successive push, OpenShift
    will reuse the dependencies and will only download new dependencies mentioned
    in `setup.py` or `requirements.txt`. This makes the application build faster,
    as it does not have to download dependencies on every `git push`. There are scenarios,
    such as a corrupt virtual environment, where you will like to recreate the virtual
    environment and download all the dependencies again. In this recipe, you will
    learn how you can force OpenShift to recreate the virtual environment.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次将更改推送到应用程序 gear 时，pip 会下载 `setup.py` 或 `requirements.txt` 中提到的所有依赖项，并用这些依赖项填充虚拟环境。在随后的每次推送中，OpenShift
    会重用已有的依赖项，仅下载 `setup.py` 或 `requirements.txt` 中提到的新依赖项。这样可以加快应用程序的构建速度，因为它不必在每次
    `git push` 时都下载依赖项。有些情况下，比如虚拟环境损坏，你可能希望重新创建虚拟环境并重新下载所有依赖项。在本配方中，你将学习如何强制 OpenShift
    重新创建虚拟环境。
- en: Getting ready
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is based on the assumption that you have read the previous recipes
    in this chapter. To step through this recipe, you will need the rhc command-line
    client installed on your machine. Please refer to the *Installing the OpenShift
    rhc command-line client* recipe in [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting
    Started with OpenShift"), *Getting Started with OpenShift*, for details.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方假设你已经阅读了本章中的前几个配方。要按步骤操作本配方，你需要在机器上安装 rhc 命令行客户端。有关详细信息，请参阅 [第 1 章](part0014_split_000.html#page
    "第 1 章：OpenShift 入门")中的 *安装 OpenShift rhc 命令行客户端* 配方。
- en: How to do it…
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Recreate the application you developed in the *Creating and deploying Flask
    web applications using Python and PostgreSQL cartridges* recipe by running the
    following command:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令，重新创建你在 *使用 Python 和 PostgreSQL 托管环境创建和部署 Flask Web 应用程序* 配方中开发的应用程序：
- en: '[PRE44]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Create a marker file named `force_clean_build` in the application''s `.openshift/markers`
    directory. On *nix machines, you can use the `touch` command as follows:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序的 `.openshift/markers` 目录中创建一个名为 `force_clean_build` 的标记文件。在 *nix 系统上，你可以使用
    `touch` 命令，如下所示：
- en: '[PRE45]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Commit the file, and push the changes to the OpenShift application gear. From
    now on, every `git push` will do a clean deployment. This is demonstrated using
    the following commands:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交该文件，并将更改推送到 OpenShift 应用程序的 gear。从现在开始，每次 `git push` 都会进行干净的部署。可以通过以下命令来演示：
- en: '[PRE46]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works…
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The presence of the `force_clean_build` marker file informs OpenShift that
    you want to do a clean build. When you do a `git push`, OpenShift will first recreate
    the virtual environment, activate the environment, and finally download all the
    dependencies using the pip package manager. You will see the following log message
    in the `git push` logs:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`force_clean_build` 标记文件的存在通知 OpenShift 你希望进行干净的构建。当你执行 `git push` 时，OpenShift
    会首先重新创建虚拟环境，激活环境，最后使用 pip 包管理器下载所有依赖项。你将在 `git push` 的日志中看到以下日志消息：'
- en: '[PRE47]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: See also
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Enabling hot deployment for Python applications* recipe
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*启用 Python 应用程序的热部署* 配方'
- en: The *Forcing a clean Python virtual environment* recipe
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*强制清除 Python 虚拟环境* 配方'
- en: Accessing an application's Python virtual environment
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问应用程序的 Python 虚拟环境
- en: By now, you will be aware that every OpenShift Python application has a virtual
    environment associated with it. Your application will only be able to use the
    dependencies available in the virtual environment. In this recipe, you will learn
    how to access the virtual environment of your OpenShift Python application.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经意识到，每个 OpenShift Python 应用程序都有一个与之关联的虚拟环境。你的应用程序只能使用虚拟环境中可用的依赖项。在本配方中，你将学习如何访问
    OpenShift Python 应用程序的虚拟环境。
- en: Getting ready
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is based on the assumption that you have read previous recipes in
    this chapter. To walk through this recipe, you will need the rhc command-line
    client installed on your machine. Please refer to the *Installing the OpenShift
    rhc command-line client* recipe in [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting
    Started with OpenShift"), *Getting Started with OpenShift*, for details. Also,
    if you want to run the application on your local machine, you will need to have
    Python, pip, and virtualenv installed on your machine. Please refer to the introduction
    section for links to installation instructions for the respective software.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方假设你已经阅读了本章之前的配方。要按照此配方操作，你需要在机器上安装 rhc 命令行客户端。详情请参阅[第 1 章](part0014_split_000.html#page
    "Chapter 1. Getting Started with OpenShift")中的*安装 OpenShift rhc 命令行客户端*配方，*OpenShift
    入门*部分。此外，如果你想在本地机器上运行该应用，你需要在机器上安装 Python、pip 和 virtualenv。安装说明可以在引言部分找到相关链接。
- en: How to do it…
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Perform the following steps to access the Python application virtual environment:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以访问 Python 应用的虚拟环境：
- en: 'Recreate the application you developed in the *Creating and deploying Flask
    web applications using Python and PostgreSQL cartridges* recipe by running the
    following command:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令，重新创建你在*使用 Python 和 PostgreSQL 托管 Flask Web 应用程序*配方中开发的应用：
- en: '[PRE48]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Change the directory to `jobstore`, and then SSH into the application gear by
    executing the `rhc ssh` command.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`jobstore`目录，然后通过执行`rhc ssh`命令 SSH 进入应用服务器。
- en: 'To access the virtual environment, run the following command:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要访问虚拟环境，运行以下命令：
- en: '[PRE49]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Once you are inside the virtual environment, you can manually download the new
    dependencies using pip. To install a command-line utility called **Yolk**, run
    the following command. Yolk can list packages installed within an environment.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦进入虚拟环境，你可以使用 pip 手动下载新的依赖包。要安装名为**Yolk**的命令行工具，运行以下命令。Yolk 可以列出在环境中安装的包。
- en: '[PRE50]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: To list all the installed packages in this virtual environment, run the following
    command. Only part of the output is shown here for brevity.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要列出该虚拟环境中所有已安装的包，运行以下命令。为简洁起见，这里仅展示部分输出。
- en: '[PRE51]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How it works…
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: You created a new Python application in step 1 and then connected to the application
    gear using SSH in step 2 when you used the `rhc ssh` command. The location of
    the virtual environment is available as an environment variable, `$VIRTUAL_ENV`.
    You activated the virtual environment in step 3 so that you can use it. Finally,
    in step 4, you installed a package using the `pip` command manually. After installation,
    the package becomes available to the application.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你在第 1 步中创建了一个新的 Python 应用，并在第 2 步中使用 `rhc ssh` 命令通过 SSH 连接到应用服务器。虚拟环境的位置作为环境变量
    `$VIRTUAL_ENV` 可用。在第 3 步中，你激活了虚拟环境以便使用它。最后，在第 4 步中，你手动使用 `pip` 命令安装了一个包。安装后，包就可以供应用使用了。
- en: See also
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Enabling hot deployment for Python applications* recipe
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为 Python 应用启用热部署*配方'
- en: The *Forcing a clean Python virtual environment* recipe
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*强制清理 Python 虚拟环境*配方'
- en: Using Gevent with Python applications
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Gevent 运行 Python 应用程序
- en: So far in this chapter, you have used Apache with `mod_wsgi` to run your Python
    applications. It is also possible to run other standalone WSGI servers, such as
    Gevent and Gunicorn, with OpenShift. In this recipe, you will learn how to use
    Gevent to run your Python applications. Gevent is a coroutine-based Python networking
    library that uses greenlet to provide a high-level, synchronous API on top of
    the libevent event loop. The source code for this repository is on GitHub at [https://github.com/OpenShift-Cookbook/chapter8-gevent-recipe](https://github.com/OpenShift-Cookbook/chapter8-gevent-recipe).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，你已经使用 Apache 配合`mod_wsgi`来运行你的 Python 应用程序。也可以使用 OpenShift 运行其他独立的
    WSGI 服务器，如 Gevent 和 Gunicorn。在本配方中，你将学习如何使用 Gevent 来运行你的 Python 应用程序。Gevent 是一个基于协程的
    Python 网络库，使用 greenlet 提供了一个基于 libevent 事件循环之上的高层同步 API。该仓库的源代码可以在 GitHub 上找到，地址是
    [https://github.com/OpenShift-Cookbook/chapter8-gevent-recipe](https://github.com/OpenShift-Cookbook/chapter8-gevent-recipe)。
- en: Getting ready
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is based on the assumption that you have read the previous recipes
    in this chapter. To step through this recipe, you will need the rhc command-line
    client installed on your machine. Please refer to the *Installing the OpenShift
    rhc command-line client* recipe in [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting
    Started with OpenShift"), *Getting Started with OpenShift*, for details. Also,
    if you want to run the application on your local machine, you will need to have
    Python, pip, and virtualenv installed on your machine. Please refer to the introduction
    section for links to installation instructions for the respective software.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱假设你已经阅读了本章前面的食谱。要执行此食谱，你需要在你的机器上安装rhc命令行客户端。有关详细信息，请参阅[第1章](part0014_split_000.html#page
    "Chapter 1. Getting Started with OpenShift")中*安装OpenShift rhc命令行客户端*的食谱，*开始使用OpenShift*。此外，如果你想在本地机器上运行应用程序，你需要在机器上安装Python、pip和virtualenv。有关这些软件安装说明的链接，请参考介绍部分。
- en: How to do it…
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Perform the following steps to use Gevent''s standalone WSGI server to run
    OpenShift Python applications:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤，使用Gevent的独立WSGI服务器运行OpenShift Python应用程序：
- en: 'Open a new command-line terminal, and run the following command to create a
    new Python 2.7 application:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的命令行终端，并运行以下命令以创建一个新的Python 2.7应用程序：
- en: '[PRE52]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If you want to create Python 2.6 or Python 3.3 applications, use Python 2.6
    and Python 3.3 respectively.
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你想创建Python 2.6或Python 3.3应用程序，请分别使用Python 2.6和Python 3.3。
- en: 'Change the directory to `myapp`, and delete the `setup.py` and `wsgi.py` files
    as follows:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`myapp`目录，并删除`setup.py`和`wsgi.py`文件，如下所示：
- en: '[PRE53]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Create a new virtual environment by running the following command:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令创建一个新的虚拟环境：
- en: '[PRE54]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Before you can work with the virtual environment, you have to activate it.
    To activate the virtual environment, run the following command:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你可以使用虚拟环境之前，必须先激活它。要激活虚拟环境，请运行以下命令：
- en: '[PRE55]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Once you have activated virtualenv, you can begin installing modules without
    affecting the system''s default Python interpreter. Install the Flask module by
    running the following command:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你激活了virtualenv，就可以开始安装模块，而不会影响系统默认的Python解释器。通过运行以下命令来安装Flask模块：
- en: '[PRE56]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Create a new Python file named `hello.py` in the `myapp` directory, and populate
    it with the following code:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`myapp`目录中创建一个名为`hello.py`的新Python文件，并用以下代码填充它：
- en: '[PRE57]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Next, install the Gevent library, as we want to use it to run our application,
    as follows:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，安装Gevent库，因为我们希望使用它来运行我们的应用程序，如下所示：
- en: '[PRE58]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Create a new file named `app.py`, and add the following code to it:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`app.py`的新文件，并添加以下代码：
- en: '[PRE59]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To deploy this application on OpenShift, we have to declare all the dependencies
    in `requirements.txt`. The following command will write all of your application
    dependencies in `requirements.txt`:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将此应用程序部署到OpenShift，我们需要在`requirements.txt`中声明所有依赖项。以下命令会将所有应用程序依赖项写入`requirements.txt`文件：
- en: '[PRE60]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The previous command will populate `requirements.txt` with all the application
    dependencies. This includes transitive dependencies as well. The `requirements.txt`
    file is shown as follows:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上一个命令会将所有应用程序的依赖项填充到`requirements.txt`文件中。这包括传递依赖项。`requirements.txt`文件如下所示：
- en: '[PRE61]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Create a new file named `.gitignore` in the `myapp` directory, and add the
    `venv` directory to be ignored. We do not want to push the virtual environment
    to OpenShift, as OpenShift will create the one based on the dependencies mentioned
    in the `requirements.txt` file. The `.gitignore` file is shown as follows:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`myapp`目录中创建一个名为`.gitignore`的新文件，并将`venv`目录添加到忽略列表中。我们不希望将虚拟环境推送到OpenShift，因为OpenShift会根据`requirements.txt`文件中提到的依赖项创建一个虚拟环境。`.gitignore`文件如下所示：
- en: '[PRE62]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now commit the code to the local repository, and then push changes to the application
    gear. OpenShift will install all the packages specified in `requirements.txt`
    and make them available to the application via the virtual environment, as follows:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将代码提交到本地仓库，然后将更改推送到应用程序gear。OpenShift将安装`requirements.txt`中指定的所有包，并通过虚拟环境使它们对应用程序可用，如下所示：
- en: '[PRE63]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now, open the web application URL in your favorite browser to see the application
    in action. You will be greeted by the **Hello World** text in your browser.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开你喜欢的浏览器，访问Web应用程序的URL，查看应用程序的运行效果。你将在浏览器中看到**Hello World**文本。
- en: How it works…
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In steps 1 through 6, you created a simple Flask web application as explained
    in the *Managing Python application dependencies* recipe. As we will use Gevent
    to run this application, you installed the Gevent library in step 7\. In step
    8, you created a new Python file, `app.py`. If the user does not use the default
    `wsgi.py` file or WSGI endpoint configured using the `OPENSHIFT_PYTHON_WSGI_APPLICATION`
    environment variable, OpenShift uses the server configured in the `app.py` file
    to serve your application. This Python file should have the name `app` and exist
    under the `app` root directory. The code in `app.py` first activates the virtual
    environment and then starts the Gevent WSGI server at `$OPENSHIFT_PYTHON_IP` and
    `$OPENSHIFT_PYTHON_PORT`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 到第 6 步中，你创建了一个简单的 Flask web 应用程序，如 *管理 Python 应用程序依赖项* 这道菜谱中所述。由于我们将使用
    Gevent 来运行此应用程序，你在第 7 步安装了 Gevent 库。在第 8 步，你创建了一个新的 Python 文件 `app.py`。如果用户没有使用默认的
    `wsgi.py` 文件或通过 `OPENSHIFT_PYTHON_WSGI_APPLICATION` 环境变量配置的 WSGI 端点，OpenShift
    将使用 `app.py` 文件中配置的服务器来提供服务。此 Python 文件应命名为 `app` 并存在于 `app` 根目录下。`app.py` 文件中的代码首先激活虚拟环境，然后在
    `$OPENSHIFT_PYTHON_IP` 和 `$OPENSHIFT_PYTHON_PORT` 启动 Gevent WSGI 服务器。
- en: In step 9, you used the `pip freeze` command to add all the dependencies in
    the `requirements.txt` file. OpenShift will download all the dependencies mentioned
    in this file and populate the application's virtual environment with them.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 9 步中，你使用 `pip freeze` 命令将所有依赖项添加到 `requirements.txt` 文件中。OpenShift 将下载此文件中提到的所有依赖项，并将它们填充到应用程序的虚拟环境中。
- en: 'Finally, you committed the code to the local Git repository and pushed the
    code to the OpenShift application gear. OpenShift will use the Gevent WSGI server
    to run your application. You will see a line, as shown in the following command-line
    output, in the `git push` logs. The following line clearly tells you that OpenShift
    is using the server configured in `app.py`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将代码提交到本地 Git 仓库，并将其推送到 OpenShift 应用程序的 gear 上。OpenShift 将使用 Gevent WSGI
    服务器来运行你的应用程序。在 `git push` 的日志中，你将看到如下命令行输出的一行。以下这一行清楚地告诉你，OpenShift 正在使用 `app.py`
    中配置的服务器：
- en: '[PRE64]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: There's more...
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Similarly, you can use the Tornado web server to serve your Python web applications.
    Uninstall the Gevent and greenlet libraries, and then install the Tornado library:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你也可以使用 Tornado web 服务器来提供 Python web 应用程序。卸载 Gevent 和 greenlet 库，然后安装 Tornado
    库：
- en: '[PRE65]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Update the `requirements.txt` file with dependencies by running the `pip freeze
    > requirements.txt` command.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行 `pip freeze > requirements.txt` 命令，将依赖项更新到 `requirements.txt` 文件中。
- en: 'In the `app.py` file, replace the Gevent code with the following code:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `app.py` 文件中，将 Gevent 代码替换为以下代码：
- en: '[PRE66]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Now your application will use the Tornado web server.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的应用程序将使用 Tornado web 服务器。
- en: See also
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Creating your first Python application* recipe
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建你的第一个 Python 应用程序* 这道菜谱'
- en: The *Creating and deploying Flask web applications using Python and PostgreSQL
    cartridges* recipe
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Python 和 PostgreSQL 托管 Flask web 应用程序的创建与部署* 这道菜谱'
- en: Installing a custom Python package
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装自定义 Python 包
- en: Most of the time, your application dependencies can be downloaded from PyPi
    using pip, but there are times when your application needs to depend on custom
    libraries that do not exist in the PyPi index. In this recipe, you will learn
    how to use custom Python packages with your OpenShift Python applications. The
    source code for this recipe is on GitHub at [https://github.com/OpenShift-Cookbook/chapter8-custom-package-recipe](https://github.com/OpenShift-Cookbook/chapter8-custom-package-recipe).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，你的应用程序依赖项可以通过 pip 从 PyPi 下载，但有时应用程序需要依赖于一些在 PyPi 索引中不存在的自定义库。在这道菜谱中，你将学习如何在
    OpenShift Python 应用程序中使用自定义 Python 包。此菜谱的源代码可在 GitHub 上找到：[https://github.com/OpenShift-Cookbook/chapter8-custom-package-recipe](https://github.com/OpenShift-Cookbook/chapter8-custom-package-recipe)。
- en: Getting ready
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is based on the assumption that you have read the previous recipes
    in this chapter. To walk through this recipe, you will need the rhc command-line
    client installed on your machine. Please refer to the *Installing the OpenShift
    rhc command-line client* recipe in [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting
    Started with OpenShift"), *Getting Started with OpenShift*, for details. Also,
    if you want to run the application on your local machine, you will need to have
    Python, pip, and virtualenv installed on your machine. Please refer to the introduction
    section for links to installation instructions for the respective software.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱基于假设你已经阅读了本章前面的食谱。要完成此食谱，你需要在机器上安装rhc命令行客户端。有关详细信息，请参见[第1章](part0014_split_000.html#page
    "Chapter 1. Getting Started with OpenShift")中的*安装OpenShift rhc命令行客户端*食谱，*OpenShift入门*。此外，如果你想在本地机器上运行应用程序，你需要安装Python、pip和virtualenv。有关安装相应软件的链接，请参见介绍部分。
- en: How to do it…
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Open a new command-line terminal, and run the following command to create a
    new Python 2.7 application:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的命令行终端，并运行以下命令创建一个新的Python 2.7应用程序：
- en: '[PRE67]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: If you want to create Python 2.6 or Python 3.3 applications, use Python 2.6
    and Python 3.3 respectively.
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你想创建Python 2.6或Python 3.3应用程序，分别使用Python 2.6和Python 3.3。
- en: 'Change the directory to `myapp`, and delete the `setup.py` file as follows:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`myapp`目录，并按如下方式删除`setup.py`文件：
- en: '[PRE68]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Also, create a `.gitignore` file to ignore the virtual environment artifacts
    and Python-compiled files as follows:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时，创建一个`.gitignore`文件，以忽略虚拟环境的产物和Python编译文件，如下所示：
- en: '[PRE69]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Add the following lines to it:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向其中添加以下行：
- en: '[PRE70]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Create a new virtual environment and activate it by running the following commands:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的虚拟环境并通过运行以下命令激活它：
- en: '[PRE71]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Once you have activated virtualenv, you can begin installing modules without
    affecting the system''s default Python interpreter. Install the Flask module by
    running the following command:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦激活了虚拟环境，你就可以开始安装模块，而不会影响系统的默认Python解释器。通过运行以下命令安装Flask模块：
- en: '[PRE72]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Create a new directory named `libs` in the application root, as shown in the
    following code. The `libs` directory will be used to store your custom packages:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序根目录中创建一个名为`libs`的新目录，如下代码所示。`libs`目录将用于存储你的自定义包：
- en: '[PRE73]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now, we will create a custom package named `msgs` in the `libs` directory.
    To create a custom package, perform the following steps:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在`libs`目录中创建一个名为`msgs`的自定义包。要创建自定义包，请执行以下步骤：
- en: Create an `msgs` directory inside the `libs` directory.
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`libs`目录中创建一个`msgs`目录。
- en: Create an empty file named `__init__.py` inside the `msgs` directory.
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`msgs`目录中创建一个名为`__init__.py`的空文件。
- en: 'Create another file named `hello.py` inside the `msgs` directory, and place
    the following code inside it:'
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`msgs`目录中创建另一个名为`hello.py`的文件，并将以下代码放入其中：
- en: '[PRE74]'
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Next, create a new Python file named `myapp.py` in the `myapp` directory, and
    populate it with the following code. This simple Flask application will use the
    `msgs` package. Have a look at the following code:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`myapp`目录中创建一个名为`myapp.py`的新Python文件，并用以下代码填充它。这个简单的Flask应用程序将使用`msgs`包。看一下以下代码：
- en: '[PRE75]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now, you need to update the `wsgi.py` file to load the Flask application instead
    of the default created by OpenShift. Delete all the content in the `wsgi.py` file,
    and replace it with the following code:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你需要更新`wsgi.py`文件，以加载Flask应用程序，而不是OpenShift默认创建的应用程序。删除`wsgi.py`文件中的所有内容，并用以下代码替换：
- en: '[PRE76]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'To deploy this application on OpenShift, we have to declare all the dependencies
    in `requirements.txt`. The following command will write all of your application
    dependencies in `requirements.txt`:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在OpenShift上部署此应用程序，我们必须在`requirements.txt`中声明所有依赖项。以下命令将把你的所有应用程序依赖项写入`requirements.txt`：
- en: '[PRE77]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now, commit the code to the local repository, and then push changes to the
    application gear. OpenShift will install all the packages specified in `requirements.txt`
    and make them available to the application via the virtual environment:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将代码提交到本地仓库，然后将更改推送到应用程序的gear。OpenShift将安装`requirements.txt`中指定的所有软件包，并通过虚拟环境使它们可用于应用程序：
- en: '[PRE78]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Now, open the web application URL in your favorite browser to see the application
    in action. You will be greeted by the **Hello World** text in your browser.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在你喜欢的浏览器中打开Web应用程序的URL，查看应用程序的实际效果。你将看到浏览器中显示的**Hello World**文本。
- en: How it works…
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In the preceding steps, you learned how to use the `libs` directory to store
    your custom packages. The `libs` directory is an example of how OpenShift uses
    convention over configuration. The phrase *convention over configuration* means
    that if you follow certain conventions, you do not have to write the configuration
    code. OpenShift follows a convention that all the packages in the `libs` directory
    should be placed in the path so that your application can use them. In step 6,
    you created a custom package named `msgs` in the `libs` directory, and without
    any configuration, your application could access the package.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的步骤中，你已经学习了如何使用 `libs` 目录来存储自定义包。`libs` 目录是 OpenShift 如何使用约定优于配置的一个示例。短语
    *约定优于配置* 意味着，如果你遵循某些约定，就不需要编写配置代码。OpenShift 遵循一个约定，即所有在 `libs` 目录中的包应该放置在路径中，以便你的应用程序能够使用它们。在第
    6 步中，你在 `libs` 目录中创建了一个名为 `msgs` 的自定义包，并且没有任何配置的情况下，你的应用程序可以访问这个包。
- en: There's more…
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Now, let''s suppose that you want to use the `mydeps` directory to store your
    custom packages. For your application to work, you have to write code in your
    application to add the `mydeps` directory to the system path. Adding two lines
    in the application''s `wsgi.py` file can solve this problem. The full application
    source code is on GitHub at [https://github.com/OpenShift-Cookbook/chapter8-custom-package-mydeps-recipe](https://github.com/OpenShift-Cookbook/chapter8-custom-package-mydeps-recipe).
    Have a look at the following code:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你想使用 `mydeps` 目录来存储你的自定义包。为了使应用程序正常工作，你需要在应用程序中编写代码，将 `mydeps` 目录添加到系统路径中。在应用程序的
    `wsgi.py` 文件中添加两行代码可以解决这个问题。完整的应用程序源代码可以在 GitHub 上找到，地址是 [https://github.com/OpenShift-Cookbook/chapter8-custom-package-mydeps-recipe](https://github.com/OpenShift-Cookbook/chapter8-custom-package-mydeps-recipe)。看看以下代码：
- en: '[PRE79]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The previous two lines will add the `mydeps` directory to the application's
    system path.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行将 `mydeps` 目录添加到应用程序的系统路径中。
- en: See also
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Creating your first Python application* recipe
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建你的第一个 Python 应用程序* 食谱'
- en: The *Creating and deploying Flask web applications using Python and PostgreSQL
    cartridges* recipe
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Python 和 PostgreSQL 套件创建和部署 Flask web 应用程序* 食谱'
- en: Using the .htaccess file to configure Apache
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 .htaccess 文件配置 Apache
- en: By now, you will be aware that OpenShift uses Apache with `mod_wsgi` to serve
    your web applications. In this recipe, you will learn to use the `.htaccess` and
    `.htpasswd` files to configure the Apache web server for the HTTP basic authentication.
    The GitHub repository for this recipe is [https://github.com/OpenShift-Cookbook/chapter8-htaccess-recipe](https://github.com/OpenShift-Cookbook/chapter8-htaccess-recipe).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经意识到 OpenShift 使用 Apache 配合 `mod_wsgi` 来为你的 web 应用程序提供服务。在这个食谱中，你将学习如何使用
    `.htaccess` 和 `.htpasswd` 文件来配置 Apache web 服务器以启用 HTTP 基本身份验证。此食谱的 GitHub 仓库是
    [https://github.com/OpenShift-Cookbook/chapter8-htaccess-recipe](https://github.com/OpenShift-Cookbook/chapter8-htaccess-recipe)。
- en: Getting ready
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is based on the assumption that you have read the previous recipes
    in this chapter. To walk through this recipe, you will need the rhc command-line
    client installed on your machine. Please refer to the *Installing the OpenShift
    rhc command-line client* recipe in [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting
    Started with OpenShift"), *Getting Started with OpenShift*, for details.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱假设你已经阅读了本章前面的食谱。为了执行本食谱，你需要在你的机器上安装 rhc 命令行客户端。有关详细信息，请参阅[第1章](part0014_split_000.html#page
    "第1章. 使用 OpenShift 入门")中的 *安装 OpenShift rhc 命令行客户端* 食谱，*使用 OpenShift 入门*。
- en: How to do it…
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Perform the following steps to enable the HTTP basic authentication:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以启用 HTTP 基本身份验证：
- en: 'Create a new Python 2.7 application using the rhc command-line tool:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 rhc 命令行工具创建一个新的 Python 2.7 应用程序：
- en: '[PRE80]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Change the directory to `myapp`, and create two files, `.htaccess` and `.htpasswd`,
    in the `myapp` directory. If you are using a *nix machine, you can use the `touch`
    command. On a Windows machine, you can use file explorer to create files. Have
    a look at the following commands:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 `myapp` 目录，并在该目录下创建两个文件，`.htaccess` 和 `.htpasswd`。如果你使用的是 *nix 系统，可以使用 `touch`
    命令。在 Windows 系统上，你可以使用文件资源管理器来创建文件。以下是相关命令：
- en: '[PRE81]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'In `.htaccess`, copy and paste the content as shown in the following code:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `.htaccess` 文件中，复制并粘贴以下代码内容：
- en: '[PRE82]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Replace `$OPENSHIFT_REPO_DIR` with the `$OPENSHIFT_REPO_DIR` location of your
    application. To get the value of `$OPENSHIFT_REPO_DIR`, run the following command:'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将 `$OPENSHIFT_REPO_DIR` 替换为你的应用程序所在的 `$OPENSHIFT_REPO_DIR` 路径。要获取 `$OPENSHIFT_REPO_DIR`
    的值，可以运行以下命令：
- en: '[PRE83]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The `.htpasswd` file is used to store username and password credentials. To
    generate a new username and password, you can use the online generator at [http://www.htaccesstools.com/htpasswd-generator/](http://www.htaccesstools.com/htpasswd-generator/).
    For this recipe, the username and password combination is `admin` and `password`
    respectively. Place the content generated by the online tool in the `.htpasswd`
    file. My `.htpasswd` file looks as follows:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.htpasswd` 文件用于存储用户名和密码凭据。要生成新的用户名和密码，你可以使用在线生成器 [http://www.htaccesstools.com/htpasswd-generator/](http://www.htaccesstools.com/htpasswd-generator/)。在这个方案中，用户名和密码分别是`admin`和`password`。将在线工具生成的内容放入`.htpasswd`文件中。我的`.htpasswd`文件如下所示：'
- en: '[PRE84]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Commit the code, and push the changes to the application gear:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交代码，并将更改推送到应用程序配件：
- en: '[PRE85]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: After the application is deployed, open the application URL in your favorite
    web browser. This time, you will be greeted by a pop up asking you to enter the
    username and password, as shown in the following screenshot:![How to do it…](img/00104.jpeg)
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署应用程序后，在你最喜欢的网页浏览器中打开应用程序的 URL。这时，你将看到一个弹出窗口，要求你输入用户名和密码，如下图所示：![如何操作…](img/00104.jpeg)
- en: After entering the `admin`/`password` combination, you will be able to enter
    your web application.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`admin`/`password`组合后，你将能够进入你的网页应用程序。
- en: How it works…
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: This recipe is another example of the flexibility that OpenShift offers to the
    application developers. There are a couple of ways you can configure the Apache
    web server. One way to configure the Apache web server is to update the main configuration
    file, usually named `httpd.conf`. OpenShift does not allow users to update the
    `httpd.conf` file. OpenShift allows users to configure the Apache web server via
    the `.htaccess` file. The `.htaccess` file provides a way to make configuration
    changes on a per-directory basis. This file can contain one or more configuration
    directives. These directives will then be applied to the directory in which the
    `.htaccess` file exists and all its subdirectories.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方案是 OpenShift 提供给应用程序开发人员的灵活性的另一个例子。有几种方法可以配置 Apache Web 服务器。一种方法是更新主配置文件，通常名为`httpd.conf`。但是，OpenShift
    不允许用户更新`httpd.conf`文件。OpenShift 允许用户通过 `.htaccess` 文件配置 Apache Web 服务器。`.htaccess`
    文件提供了一种按目录进行配置更改的方法。此文件可以包含一个或多个配置指令。这些指令将应用于`.htaccess`文件所在的目录及其所有子目录。
- en: In step 1, you created a new Python 2.7 application with the name `myapp`. Then,
    in step 2, you created a couple of files—`.htaccess` and `.htpasswd`—in the `myapp`
    directory. In step 3, you updated the content of the `.htaccess` file with the
    HTTP basic authentication configuration. You can learn more from the documentation
    at [http://httpd.apache.org/docs/2.2/howto/auth.html](http://httpd.apache.org/docs/2.2/howto/auth.html).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 步中，你创建了一个名为`myapp`的 Python 2.7 应用程序。然后，在第 2 步中，你在`myapp`目录中创建了两个文件—`.htaccess`和`.htpasswd`。在第
    3 步中，你更新了`.htaccess`文件的内容，添加了 HTTP 基本认证配置。你可以通过文档 [http://httpd.apache.org/docs/2.2/howto/auth.html](http://httpd.apache.org/docs/2.2/howto/auth.html)
    了解更多内容。
- en: Next, in step 4, you generated content for the `.htpasswd` file using an online
    `.htpasswd` generator. You placed the content generated by generator in the `.htpasswd`
    file and then committed all the changes in step 5\. On successful deployment,
    you opened the application URL in the browser in step 6\. You were asked to enter
    the `admin`/`password` username/password credentials. On entering the valid username/password
    combination, you were allowed to enter the application in step 7.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在第 4 步中，你使用在线 `.htpasswd` 生成器生成了`.htpasswd`文件的内容。你将生成器生成的内容放入`.htpasswd`文件中，然后在第
    5 步中提交了所有更改。成功部署后，在第 6 步中，你在浏览器中打开了应用程序 URL。系统要求你输入`admin`/`password`的用户名/密码凭据。输入有效的用户名/密码组合后，你就可以进入应用程序，在第
    7 步中顺利登录。
- en: See also
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: The *Creating your first Python application* recipe
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建你的第一个 Python 应用程序* 方案'
- en: The *Creating and deploying Flask web applications using Python and PostgreSQL
    cartridges* recipe
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Python 和 PostgreSQL 托盘创建和部署 Flask Web 应用程序* 方案'
