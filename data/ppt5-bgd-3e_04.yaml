- en: Chapter 4. Understanding Puppet resources
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章：理解 Puppet 资源
- en: '|   | *Perplexity is the beginning of knowledge.* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *困惑是知识的开始。* |   |'
- en: '|   | --*Khalil Gibran* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*哈里勒·吉布兰* |'
- en: 'We''ve already met three important types of Puppet resources: `package`, `file`,
    and `service`. In this chapter, we''ll learn more about these, plus other important
    resource types for managing users, groups, SSH keys, cron jobs, and arbitrary
    commands.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经遇到过三种重要的 Puppet 资源类型：`package`、`file` 和 `service`。在本章中，我们将进一步了解这些资源类型，以及用于管理用户、组、SSH
    密钥、定时任务和任意命令的其他重要资源类型。
- en: '![Understanding Puppet resources](img/B08880_04_01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![理解 Puppet 资源](img/B08880_04_01.jpg)'
- en: Files
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件
- en: 'We saw in [Chapter 2](ch02.html "Chapter 2. Creating your first manifests"),
    *Creating your first manifests* that Puppet can manage files on a node using the
    `file` resource, and we looked at an example which sets the contents of a file
    to a particular string using the `content` attribute. Here it is again (`file_hello.pp`):'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](ch02.html "第2章：创建你的第一个清单") *创建你的第一个清单* 中看到，Puppet 可以使用 `file` 资源管理节点上的文件，并且我们查看了一个示例，该示例使用
    `content` 属性将文件内容设置为特定字符串。这里是该示例的再次展示（`file_hello.pp`）：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The path attribute
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: path 属性
- en: We've seen that every Puppet resource has a title (a quoted string followed
    by a colon). In the `file_hello` example, the title of the `file` resource is
    `'/tmp/hello.txt'`. It's easy to guess that Puppet is going to use this value
    as the path of the created file. In fact, `path` is one of the attributes you
    can specify for a `file`, but if you don't specify it, Puppet will use the title
    of the resource as the value of `path`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，每个 Puppet 资源都有一个标题（一个带引号的字符串后跟一个冒号）。在 `file_hello` 示例中，`file` 资源的标题是
    `'/tmp/hello.txt'`。很容易猜测，Puppet 将使用此值作为创建文件的路径。事实上，`path` 是你可以为 `file` 指定的属性之一，但如果你没有指定，Puppet
    将使用资源的标题作为 `path` 的值。
- en: Managing whole files
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理整个文件
- en: 'While it''s useful to be able to set the contents of a file to a short text
    string, most files we''re likely to want to manage will be too large to include
    directly in our Puppet manifests. Ideally, we would put a copy of the file in
    the Puppet repo, and have Puppet simply copy it to the desired place in the filesystem.
    The `source` attribute does exactly that (`file_source.pp`):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然能够将文件的内容设置为简短的文本字符串很有用，但我们可能希望管理的大多数文件都太大，无法直接包含在 Puppet 清单中。理想情况下，我们会将文件的副本放在
    Puppet 仓库中，并让 Puppet 将其复制到文件系统中的指定位置。`source` 属性正是实现这一功能的（`file_source.pp`）：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To try this example with your Vagrant box, run the following commands:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的 Vagrant box 上尝试这个示例，请运行以下命令：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: (From now on, I won't give you explicit instructions on how to run the examples;
    just apply them in the same way using `sudo puppet apply` as shown here. All the
    examples in this book are in the `examples/` directory of the GitHub repo, and
    I'll give you the name of the appropriate file for each example, such as `file_source.pp`.)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: （从现在开始，我不会再给出如何运行示例的明确说明；只需按照这里所示的方式使用 `sudo puppet apply` 即可。书中的所有示例都位于 GitHub
    仓库的 `examples/` 目录中，我会为每个示例提供相应的文件名，例如 `file_source.pp`。）
- en: Tip
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Why do we have to run `sudo puppet apply` instead of just `puppet apply`? Puppet
    has the permissions of the user who runs it, so if Puppet needs to modify a file
    owned by `root`, it must be run with `root`'s permissions (which is what `sudo`
    does). You will usually run Puppet as `root` because it needs those permissions
    to do things like installing packages, modifying config files owned by `root`,
    and so on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们必须运行 `sudo puppet apply` 而不是直接运行 `puppet apply`？Puppet 拥有运行它的用户的权限，因此如果
    Puppet 需要修改一个由 `root` 拥有的文件，它必须以 `root` 的权限运行（这正是 `sudo` 的作用）。你通常会以 `root` 用户身份运行
    Puppet，因为它需要这些权限来执行诸如安装软件包、修改由 `root` 拥有的配置文件等任务。
- en: 'The value of the `source` attribute can be a path to a file on the node, as
    here, or an HTTP URL, as in the following example (`file_http.pp`):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`source` 属性的值可以是节点上某个文件的路径，如这里所示，或是一个 HTTP URL，如以下示例所示（`file_http.pp`）：'
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Although this is a handy feature, bear in mind that every time you add an external
    dependency like this to your Puppet manifest, you're adding a potential point
    of failure.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个非常方便的功能，但请记住，每次你将这样的外部依赖添加到 Puppet 清单时，实际上是在添加一个潜在的故障点。
- en: Tip
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Wherever you can, use a local copy of a file instead of having Puppet fetch
    it remotely every time. This particularly applies to software which needs to be
    built from a tarball downloaded from a website. If possible, download the tarball
    and serve it from a local webserver or file server. If this isn't practical, using
    a caching proxy server can help save time and bandwidth when you're building a
    large number of nodes.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，使用文件的本地副本，而不是每次都让 Puppet 从远程获取文件。这尤其适用于需要从网站下载 tarball 构建的软件。如果可能，下载
    tarball 并通过本地 Web 服务器或文件服务器提供它。如果这不可行，使用缓存代理服务器可以在构建大量节点时节省时间和带宽。
- en: Ownership
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 所有权
- en: 'On Unix-like systems, files are associated with an **owner**, a **group**,
    and a set of **permissions** to read, write, or execute the file. Since we normally
    run Puppet with the permissions of the `root` user (via `sudo`), the files Puppet
    manages will be owned by that user:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在类 Unix 系统中，文件与一个 **所有者**、一个 **组** 和一组 **权限**（用于读取、写入或执行文件）相关联。由于我们通常以 `root`
    用户的权限（通过 `sudo`）运行 Puppet，Puppet 管理的文件将由该用户拥有：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Often, this is just fine, but if we need the file to belong to another user
    (for example, if that user needs to be able to write to the file), we can express
    this by setting the `owner` attribute (`file_owner.pp`):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这已经足够了，但如果我们需要文件属于其他用户（例如，如果该用户需要能够写入该文件），我们可以通过设置 `owner` 属性来表达这一点（`file_owner.pp`）：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can see that Puppet has created the file and its owner has been set to
    `ubuntu`. You can also set the group ownership of the file using the `group` attribute
    (`file_group.pp`):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，Puppet 已创建文件，并且其所有者已设置为 `ubuntu`。您还可以使用 `group` 属性设置文件的组所有权（`file_group.pp`）：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that this time we didn't specify either a `content` or `source` attribute
    for the file, but simply `ensure => present`. In this case, Puppet will create
    a file of zero size.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这次我们没有为文件指定 `content` 或 `source` 属性，而是简单地设置 `ensure => present`。在这种情况下，Puppet
    将创建一个大小为零的文件。
- en: Permissions
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 权限
- en: 'Files on Unix-like systems have an associated **mode** which determines access
    permissions for the file. It governs read, write, and execute permissions for
    the file''s owner, any user in the file''s group, and other users. Puppet supports
    setting permissions on files using the `mode` attribute. This takes an octal value
    (base 8, indicated by a leading 0 digit), with each digit representing a field
    of 3 binary bits: the permissions for owner, group, and other, respectively. In
    the following example, we use the `mode` attribute to set a mode of `0644` ("read
    and write for the owner, read-only for the group, and read-only for other users")
    on a file (`file_mode.pp`):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在类 Unix 系统中，文件具有一个关联的 **模式**，该模式决定了对文件的访问权限。它控制文件所有者、文件所在组的用户以及其他用户的读取、写入和执行权限。Puppet
    支持使用 `mode` 属性设置文件的权限。该属性接受一个八进制值（以 0 开头的数字表示），每个数字代表 3 个二进制位字段：分别表示所有者、组和其他用户的权限。在以下示例中，我们使用
    `mode` 属性将文件的模式设置为 `0644`（"所有者可读写，组和其他用户只能读取"）（`file_mode.pp`）：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will be quite familiar to experienced system administrators, as the octal
    values for file permissions are exactly the same as those understood by the Unix
    `chmod` command. For more information, run the command `man chmod`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于经验丰富的系统管理员来说是非常熟悉的，因为文件权限的八进制值与 Unix 的 `chmod` 命令所理解的完全相同。欲了解更多信息，请运行命令 `man
    chmod`。
- en: Directories
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目录
- en: 'Creating or managing permissions on a **directory** is a common task, and Puppet
    uses the `file` resource to do this too. If the value of the `ensure` attribute
    is `directory`, the file will be a directory (`file_directory.pp`):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 创建或管理 **目录** 的权限是一个常见任务，Puppet 也使用 `file` 资源来完成此操作。如果 `ensure` 属性的值为 `directory`，则文件将是一个目录（`file_directory.pp`）：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As with regular files, you can use the `owner`, `group`, and `mode` attributes
    to control access to directories.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规文件一样，您可以使用 `owner`、`group` 和 `mode` 属性来控制对目录的访问。
- en: Trees of files
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件树
- en: 'We''ve already seen that Puppet can copy a single file to the node, but what
    about a whole directory of files, possibly including subdirectories (known as
    a **file tree**)? The `recurse` attribute will take care of this (`file_tree.pp`):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 Puppet 可以将单个文件复制到节点，但如果是一个包含子目录的整个文件夹（称为 **文件树**）呢？`recurse` 属性将处理这个问题（`file_tree.pp`）：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When `recurse` is `true`, Puppet will copy all the files and directories (and
    their subdirectories) in the source directory (`/examples/files/config_dir/` in
    this example) to the target directory (`/etc/config_dir/`).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当`recurse`为`true`时，Puppet会将源目录（在本例中为`/examples/files/config_dir/`）中的所有文件和目录（及其子目录）复制到目标目录（`/etc/config_dir/`）。
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If the target directory already exists and has files in it, Puppet will not
    interfere with them, but you can change this behavior using the `purge` attribute.
    If this is `true`, Puppet will delete any files and directories in the target
    directory which are not present in the source directory. Use this attribute with
    care.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标目录已经存在且其中包含文件，Puppet将不会干涉它们，但你可以使用`purge`属性来改变此行为。如果`purge`为`true`，Puppet将删除目标目录中任何未出现在源目录中的文件和目录。使用此属性时请谨慎。
- en: Symbolic links
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 符号链接
- en: 'Another common requirement for managing files is to create or modify a **symbolic
    link** (known as a **symlink**, for short). You can have Puppet do this by setting
    `ensure => link` on the `file` resource and specifying the `target` attribute
    (`file_symlink.pp`):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的文件管理需求是创建或修改**符号链接**（简称**symlink**）。你可以通过在`file`资源上设置`ensure => link`并指定`target`属性（`file_symlink.pp`）来让Puppet完成此操作：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Packages
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件包
- en: We've already seen how to install a package using the `package` resource, and
    this is all you need to do with most packages. However, the `package` resource
    has a few extra features which may be useful.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用`package`资源安装软件包，这对于大多数软件包来说足够了。然而，`package`资源还有一些额外的功能，可能会很有用。
- en: Uninstalling packages
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 卸载软件包
- en: 'The `ensure` attribute normally takes the value `installed` in order to install
    a package, but if you specify `absent` instead, Puppet will **remove** the package
    if it happens to be installed. Otherwise, it will take no action. The following
    example will remove the `apparmor` package if it''s installed (`package_remove.pp`):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`ensure`属性通常会取值`installed`来安装软件包，但如果你指定`absent`，Puppet将**移除**已安装的软件包，否则将不采取任何行动。以下示例将在`apparmor`软件包已安装的情况下将其移除（`package_remove.pp`）：'
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By default, when Puppet removes packages, it leaves in place any files managed
    by the package. To purge all the files associated with the package, use `purged`
    instead of `absent`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当Puppet移除软件包时，会保留软件包管理的任何文件。要删除与软件包相关的所有文件，请使用`purged`而不是`absent`。
- en: Installing specific versions
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装特定版本
- en: 'If there are multiple versions of a package available to the system''s package
    manager, specifying `ensure => installed` will cause Puppet to install the default
    version (usually the latest). But, if you need a specific version, you can specify
    that version string as the value of `ensure`, and Puppet will install that version
    (`package_version.pp`):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统的软件包管理器提供了多个版本的包，指定`ensure => installed`将使Puppet安装默认版本（通常是最新版本）。但是，如果你需要特定版本，你可以将该版本字符串指定为`ensure`的值，Puppet将安装该版本（`package_version.pp`）：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It's a good idea to specify an exact version whenever you manage packages with
    Puppet, so that all the nodes will get the same version of a given package. Otherwise,
    if you use `ensure => installed`, they will just get whatever version was current
    at the time they were built, leading to a situation where different nodes have
    different package versions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Puppet管理软件包时，最好指定确切的版本，以确保所有节点都安装相同版本的软件包。否则，如果你使用`ensure => installed`，它们将只安装构建时当前的版本，从而导致不同的节点安装了不同版本的软件包。
- en: When a newer version of the package is released, and you decide it's time to
    upgrade to it, you can update the version string specified in the Puppet manifest
    and Puppet will upgrade the package everywhere.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当软件包发布新版本时，如果你决定升级，你可以更新Puppet清单中指定的版本字符串，Puppet会在所有地方升级该软件包。
- en: Installing the latest version
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装最新版本
- en: On the other hand, if you specify `ensure => latest` for a package, Puppet will
    make sure that the latest available version is installed *every time the manifest
    is applied*. When a new version of the package becomes available, it will be installed
    automatically on the next Puppet run.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你为软件包指定`ensure => latest`，Puppet会确保每次应用清单时都安装最新的版本。当软件包有新版本发布时，下一次Puppet运行时会自动安装。
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This is not generally what you want when using a package repository that's not
    under your control (for example, the main Ubuntu repository). It means that packages
    will be upgraded at unexpected times, which may break your application (or at
    least result in unplanned downtime). A better strategy is to tell Puppet to install
    a specific version which you know works, and test upgrades in a controlled environment
    before rolling them out to production.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用不在你控制下的包仓库（例如 Ubuntu 主仓库）时，这通常不是你想要的行为。这意味着包会在意外的时间进行升级，可能会导致应用崩溃（或者至少导致计划外的停机）。更好的策略是告诉
    Puppet 安装你知道可以正常工作的特定版本，并在受控环境中测试升级，之后再将其应用到生产环境中。
- en: 'If you maintain your own package repository and control the release of new
    packages to it, `ensure => latest` can be a useful feature: Puppet will update
    a package as soon as you push a new version to the repo. If you are relying on
    upstream repositories, such as the Ubuntu repositories, it''s better to manage
    the version number directly by specifying an explicit version as the value of
    `ensure`.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你维护自己的包仓库并控制新包的发布，`ensure => latest` 是一个有用的功能：Puppet 会在你向仓库推送新版本时立即更新包。如果你依赖上游仓库，比如
    Ubuntu 仓库，最好通过直接指定版本号来管理版本，而不是使用 `ensure`。
- en: Installing Ruby gems
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Ruby gems
- en: 'Although the `package` resource is most often used to install packages using
    the normal system package manager (in the case of Ubuntu, that''s APT), it can
    install other kinds of packages as well. Library packages for the Ruby programming
    language are known as **gems**. Puppet can install Ruby gems for you using the
    `provider => gem` attribute (`package_gem.pp`):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `package` 资源通常用于通过普通的系统包管理器（在 Ubuntu 中是 APT）安装包，它也可以安装其他类型的包。Ruby 编程语言的库包被称为
    **gems**。Puppet 可以通过 `provider => gem` 属性为你安装 Ruby gems（`package_gem.pp`）：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`puppet-lint` is a Ruby gem and therefore we have to specify `provider => gem`
    for this package so that Puppet doesn''t think it''s a standard system package
    and try to install it via APT. Since the `gem` provider is not available unless
    Ruby is installed, we install the `ruby` package first, then the `puppet-lint`
    gem.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`puppet-lint` 是一个 Ruby gem，因此我们必须为这个包指定 `provider => gem`，以防 Puppet 把它当作标准的系统包并试图通过
    APT 安装。由于 `gem` 提供者只有在安装 Ruby 后才可用，我们首先安装 `ruby` 包，然后安装 `puppet-lint` gem。'
- en: 'The `puppet-lint` tool, by the way, is a good thing to have installed. It will
    check your Puppet manifests for common style errors and make sure they comply
    with the official Puppet style guide. Try it now:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，`puppet-lint` 工具是一个很有用的工具。它会检查你的 Puppet 清单文件是否存在常见的样式错误，并确保它们符合官方 Puppet
    风格指南。现在就试试吧：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this example, `puppet-lint` is warning you that the `=>` arrows are not
    lined up vertically, which the style guide says they should be:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`puppet-lint` 警告你 `=>` 箭头没有垂直对齐，风格指南规定它们应该是垂直对齐的：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When `puppet-lint` produces no output, the file is free of lint errors.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `puppet-lint` 不产生任何输出时，说明文件没有 lint 错误。
- en: Installing gems in Puppet's context
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Puppet 环境中安装 gems
- en: Puppet itself is written at least partly in Ruby, and makes use of several Ruby
    gems. To avoid any conflicts with the version of Ruby and gems which the node
    might need for other applications, Puppet packages its own version of Ruby and
    associated gems under the `/opt/puppetlabs/` directory. This means you can install
    (or remove) whichever system version of Ruby you like and Puppet will not be affected.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 本身至少部分是用 Ruby 编写的，并且使用了多个 Ruby gem。为了避免与节点可能需要的 Ruby 版本及其他应用所需 gem 的冲突，Puppet
    将自己的 Ruby 版本和相关 gem 打包到 `/opt/puppetlabs/` 目录下。这意味着你可以安装（或移除）任意系统版本的 Ruby，而 Puppet
    不会受到影响。
- en: However, if you need to install a gem to extend Puppet's capabilities in some
    way, then doing it with a `package` resource and `provider => gem` won't work.
    That is, the gem will be installed, but only in the system Ruby context, and it
    won't be visible to Puppet.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你需要安装一个 gem 来扩展 Puppet 的某些功能，使用 `package` 资源和 `provider => gem` 是无法工作的。也就是说，gem
    会被安装，但仅在系统的 Ruby 环境中，并且 Puppet 无法看到它。
- en: 'Fortunately, the `puppet_gem` provider is available for exactly this purpose.
    When you use this provider, the gem will be installed in Puppet''s context (and,
    naturally, won''t be visible in the system context). The following example demonstrates
    how to use this provider (`package_puppet_gem.pp`):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`puppet_gem` 提供者正是为这个目的而存在的。当你使用这个提供者时，gem 会安装到 Puppet 的环境中（自然，它不会在系统环境中显示）。以下示例展示了如何使用这个提供者（`package_puppet_gem.pp`）：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Tip
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'To see the gems installed in Puppet''s context, use Puppet''s own version of
    the `gem` command with the following path:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看Puppet上下文中安装的gem，可以使用Puppet自己版本的`gem`命令，路径如下：
- en: '`/opt/puppetlabs/puppet/bin/gem list`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`/opt/puppetlabs/puppet/bin/gem list`'
- en: Using ensure_packages
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`ensure_packages`
- en: To avoid potential package conflicts between different parts of your Puppet
    code or between your code and third-party modules, the Puppet standard library
    provides a useful wrapper for the `package` resource, called `ensure_packages()`.
    We'll cover this in detail in [Chapter 7](ch07.html "Chapter 7. Mastering modules"),
    *Mastering modules*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免Puppet代码的不同部分之间，或者你的代码与第三方模块之间可能发生的包冲突，Puppet标准库提供了一个有用的`package`资源的包装器，叫做`ensure_packages()`。我们将在[第7章](ch07.html
    "第7章. 掌握模块")中详细介绍，*掌握模块*。
- en: Services
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: 'Although services are implemented in a number of varied and complicated ways
    at the operating system level, Puppet does a good job of abstracting away most
    of this with the `service` resource and exposing just the two attributes of services
    which you most commonly need to manage: whether they''re running (`ensure`) and
    whether they start at boot time (`enable`). We covered the use of these in [Chapter
    2](ch02.html "Chapter 2. Creating your first manifests"), *Creating your first
    manifests*, and most of the time, you won''t need to know any more about `service`
    resources.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管操作系统级别的服务实现方式多种多样且复杂，Puppet通过`service`资源很好地抽象化了大部分内容，并只暴露了你最常用的两个服务属性：服务是否正在运行（`ensure`）以及是否在启动时启动（`enable`）。我们在[第2章](ch02.html
    "第2章. 创建你的第一个清单")中介绍了这些内容，*创建你的第一个清单*，而且大多数情况下，你不需要知道更多关于`service`资源的内容。
- en: However, you'll occasionally encounter services which don't play well with Puppet,
    for a variety of reasons. Sometimes, Puppet is unable to detect that the service
    is already running and keeps trying to start it. Other times, Puppet may not be
    able to properly restart the service when a dependent resource changes. There
    are a few useful attributes for `service` resources which can help resolve these
    problems.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你偶尔会遇到一些服务由于各种原因与Puppet不兼容。有时，Puppet无法检测到服务已经在运行，并且一直尝试启动它。其他时候，当一个依赖资源发生变化时，Puppet可能无法正确重启服务。对于`service`资源，有一些有用的属性可以帮助解决这些问题。
- en: The hasstatus attribute
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`hasstatus`属性'
- en: When a `service` resource has the attribute `ensure => running` attribute, Puppet
    needs to be able to check whether the service is, in fact, running. The way it
    does this depends on the underlying operating system. On Ubuntu 16 and later,
    for example, it runs `systemctl is-active SERVICE`. If the service is packaged
    to work with `systemd`, that should be just fine, but in many cases, particularly
    with older software, it may not respond properly.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当`service`资源具有`ensure => running`属性时，Puppet需要能够检查该服务是否实际上正在运行。它的实现方式取决于底层操作系统。例如，在Ubuntu
    16及更高版本中，它会运行`systemctl is-active SERVICE`。如果该服务是以`systemd`工作方式打包的，那么这应该没问题，但在许多情况下，尤其是对于旧的软件，它可能无法正常响应。
- en: 'If you find that Puppet keeps attempting to start the service on every Puppet
    run, even though the service is running, it may be that Puppet''s default service
    status detection isn''t working. In this case, you can specify the `hasstatus
    => false` attribute for the service (`service_hasstatus.pp`):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现Puppet在每次运行时都试图启动服务，即使该服务已经在运行，可能是Puppet的默认服务状态检测无法正常工作。在这种情况下，你可以为该服务指定`hasstatus
    => false`属性（`service_hasstatus.pp`）：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When `hasstatus` is false, Puppet knows not to try to check the service status
    using the default system service management command, and instead, will look in
    the process table for a running process which matches the name of the service.
    If it finds one, it will infer that the service is running and take no further
    action.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当`hasstatus`为false时，Puppet知道不需要使用默认的系统服务管理命令来检查服务状态，而是会在进程表中查找与服务名称匹配的正在运行的进程。如果找到了，Puppet将推断该服务正在运行，并且不会采取进一步的行动。
- en: The pattern attribute
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`pattern`属性'
- en: Sometimes, when using `hasstatus => false`, the service name as defined in Puppet
    doesn't actually appear in the process table, because the command that provides
    the service has a different name. If this is the case, you can tell Puppet exactly
    what to look for using the `pattern` attribute.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当使用`hasstatus => false`时，Puppet中定义的服务名称实际上并不会出现在进程表中，因为提供该服务的命令有一个不同的名称。如果是这种情况，你可以通过`pattern`属性告诉Puppet具体应该查找什么。
- en: 'If `hasstatus` is `false` and `pattern` is specified, Puppet will search for
    the value of `pattern` in the process table to determine whether or not the service
    is running. To find the pattern you need, you can use the `ps` command to see
    the list of running processes:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`hasstatus`为`false`并且指定了`pattern`，Puppet将会在进程表中搜索`pattern`的值，以判断服务是否正在运行。为了找到你需要的模式，你可以使用`ps`命令查看正在运行的进程列表：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Find the process you''re interested in and pick a string which will match only
    the name of that process. For example, if it''s `ntpd`, you might specify the
    `pattern` attribute as `ntpd` (`service_pattern.pp`):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 查找你感兴趣的进程，并选择一个仅与该进程名称匹配的字符串。例如，如果是`ntpd`，你可以将`pattern`属性指定为`ntpd`（`service_pattern.pp`）：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The hasrestart and restart attributes
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: hasrestart和restart属性
- en: 'When a service is notified (for example, if a `file` resource uses the `notify`
    attribute to tell the service its config file has changed, a common pattern which
    we looked at in [Chapter 2](ch02.html "Chapter 2. Creating your first manifests"),
    *Creating your first manifests*), Puppet''s default behavior is to stop the service,
    then start it again. This usually works, but many services implement a `restart`
    command in their management scripts. If this is available, it''s usually a good
    idea to use it: it may be faster or safer than stopping and starting the service.
    Some services take a while to shut down properly when stopped, for example, and
    Puppet may not wait long enough before trying to restart them, so that you end
    up with the service not running at all.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务被通知时（例如，如果一个`file`资源使用`notify`属性告知服务其配置文件已更改，这是我们在[第二章](ch02.html "第二章：创建你的第一个清单")，*创建你的第一个清单*中看到的常见模式），Puppet的默认行为是先停止服务，然后重新启动它。通常这样做有效，但许多服务在其管理脚本中实现了`restart`命令。如果该命令可用，通常使用它是个好主意：它可能比停止并启动服务更快或更安全。例如，一些服务在停止时需要花费一定时间才能正确关闭，而Puppet可能没有等足够的时间就尝试重启它们，这样就可能导致服务根本没有运行。
- en: 'If you specify `hasrestart => true` for a service, then Puppet will try to
    send a `restart` command to it, using whatever service management command is appropriate
    for the current platform (`systemctl`, for example, on Ubuntu). The following
    example shows the use of `hasrestart` (`service_hasrestart.pp`):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为一个服务指定了`hasrestart => true`，那么Puppet会尝试发送一个`restart`命令，使用当前平台适当的服务管理命令（例如，在Ubuntu上是`systemctl`）。以下示例展示了`hasrestart`的使用（`service_hasrestart.pp`）：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To further complicate things, the default system service `restart` command
    may not work, or you may need to take certain special actions when the service
    is restarted (disabling monitoring notifications, for example). You can specify
    any `restart` command you like for the service using the `restart` attribute (`service_custom_restart.pp`):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的是，默认的系统服务`restart`命令可能无法工作，或者在重启服务时可能需要执行某些特殊操作（例如禁用监控通知）。你可以使用`restart`属性（`service_custom_restart.pp`）为服务指定任何你喜欢的`restart`命令：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example, the `restart` command writes a message to a log file before
    restarting the service in the usual way, but it could, of course, do anything
    you need it to. Note that the `restart` command is only used when Puppet restarts
    the service (generally because it was notified by a change to some config file).
    It's not used when starting the service from a stopped state. If Puppet finds
    the service has stopped and needs to start it, it will use the normal system service
    start command.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`restart`命令会在重新启动服务之前，向日志文件写入一条消息，但它当然可以做你需要的任何事情。注意，`restart`命令仅在Puppet重启服务时使用（通常是因为服务收到了某个配置文件更改的通知）。如果Puppet发现服务已经停止并需要启动它，它将使用正常的系统服务启动命令，而不是使用`restart`命令。
- en: In the extremely rare event that the service cannot be stopped or started using
    the default service management command, Puppet also provides the `stop` and `start`
    attributes so that you can specify custom commands to stop and start the service,
    just the same way as with the `restart` attribute. If you need to use either of
    these, though, it's probably safe to say that you're having a bad day.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在极为罕见的情况下，如果无法通过默认的服务管理命令停止或启动服务，Puppet还提供了`stop`和`start`属性，允许你指定自定义命令来停止和启动服务，和`restart`属性的使用方式一样。不过，如果你需要使用这些命令，可能可以安全地说你今天运气不好。
- en: Users
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户
- en: A user on Unix-like systems does not necessarily correspond to a human person
    who logs in and types commands, although it sometimes does. A user is simply a
    named entity that can own files and run commands with certain permissions and
    that may or may not have permission to read or modify other users' files. It's
    very common, for sound security reasons, to run each service on a system with
    its own user account. This simply means that the service runs with the identity
    and permissions of that user.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 类Unix系统中的用户不一定对应于登录并输入命令的具体人，尽管有时确实是。用户只是一个命名实体，可以拥有文件并以特定权限运行命令，可能具有或不具有读取或修改其他用户文件的权限。出于良好的安全考虑，为每个系统服务创建一个独立的用户账户是很常见的做法。这意味着该服务以该用户的身份和权限运行。
- en: For example, a web server will often run as the `www-data` user, which exists
    solely to own files the web server needs to read and write. This limits the danger
    of a security breach via the web server, because the attacker would only have
    the `www-data` user's permissions, which are very limited, rather than the `root`
    user's, which can modify any aspect of the system. It is generally a bad idea
    to run services exposed to the public Internet as the `root` user. The service
    user should have only the minimum permissions it needs to operate the service.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，web 服务器通常以`www-data`用户身份运行，该用户仅用于拥有 web 服务器需要读取和写入的文件。这限制了通过 web 服务器发生安全漏洞的风险，因为攻击者只能拥有`www-data`用户的权限，该权限非常有限，而不是`root`用户的权限，后者可以修改系统的任何方面。通常，作为`root`用户运行暴露于公共互联网的服务是一个不好的主意。服务用户应该只拥有操作该服务所需的最小权限。
- en: Given this, an important part of system configuration involves creating and
    managing users, and Puppet's `user` resource provides a model for doing just that.
    Just as we saw with packages and services, the details of implementation and the
    commands used to manage users vary widely from one operating system to another,
    but Puppet provides an abstraction which hides those details behind a common set
    of attributes for users.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，系统配置的一个重要部分是创建和管理用户，而 Puppet 的`user`资源为此提供了一个模型。正如我们在包和服务中看到的，实施细节和管理用户的命令在不同操作系统之间有很大的差异，但
    Puppet 提供了一个抽象，隐藏了这些细节，通过一组通用的用户属性来管理。
- en: Creating users
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户
- en: 'The following example shows a typical `user` and `group` declaration in Puppet
    (`user.pp`):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了 Puppet 中典型的`user`和`group`声明（`user.pp`）：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The user resource
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户资源
- en: The title of the resource is the username (login name) of the user; in this
    example, `hsing-hui`. The `ensure => present` attribute says that the user should
    exist on the system.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 资源的标题是用户的用户名（登录名）；在这个例子中是`hsing-hui`。`ensure => present`属性表示该用户应当存在于系统中。
- en: The `uid` attribute needs a little more explanation. On Unix-like systems, each
    user has an individual numerical id, known as the **uid**. The text name associated
    with the user is merely a convenience for those (mere humans, for example) who
    prefer strings to numbers. Access permissions are in fact based on the uid and
    not the username.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`uid`属性需要更多的解释。在类Unix系统中，每个用户都有一个唯一的数字标识符，称为**uid**。与用户关联的文本名称仅仅是为了方便那些（比如人类）更喜欢字符串而非数字的情况。访问权限实际上是基于uid而不是用户名的。'
- en: Tip
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Why set the `uid` attribute? Often, when creating users manually, we don't specify
    a uid, so the system will assign one automatically. The problem with this is that
    if you create the same user (`hsing-hui`, for example) on three different nodes,
    you may end up with three different uids. This would be fine as long as you have
    never shared files between nodes, or copied data from one place to another. But
    in fact, this happens all the time, so it's important to make sure that a given
    user's uid is the same across all the nodes in your infrastructure. That's why
    we specify the `uid` attribute in the Puppet manifest.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要设置`uid`属性？通常，当手动创建用户时，我们没有指定uid，系统会自动分配一个。这样做的问题是，如果在三个不同的节点上创建相同的用户（例如`hsing-hui`），可能会得到三个不同的uid。只要从未在节点之间共享文件或从一个地方复制数据到另一个地方，这不会成为问题。但实际上，这种情况经常发生，因此确保每个用户的uid在基础设施中的所有节点上都相同是很重要的。这就是为什么我们在
    Puppet 清单中指定`uid`属性的原因。
- en: The `home` attribute sets the user's home directory (this will be the current
    working directory when the user logs in, if she does log in, and also the default
    working directory for cron jobs that run as the user).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`home`属性设置用户的主目录（如果用户登录，该目录将是当前工作目录，且为以该用户身份运行的 cron 任务的默认工作目录）。'
- en: The `shell` attribute specifies the command-line shell to run when the user
    logs in interactively. For humans, this will generally be a user shell, such as
    `/bin/bash` or `/bin/sh`. For service users, such as `www-data`, the shell should
    be set to `/usr/sbin/nologin` (on Ubuntu systems), which does not allow interactive
    access, and prints a message saying `This account is currently not available`.
    All users who do not need to log in interactively should have the `nologin` shell.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`shell` 属性指定了用户交互式登录时要运行的命令行 shell。对于人类用户，通常是用户 shell，如 `/bin/bash` 或 `/bin/sh`。对于服务用户，如
    `www-data`，shell 应该设置为 `/usr/sbin/nologin`（在 Ubuntu 系统上），这会阻止交互式访问，并显示消息 `此账户当前不可用`。所有不需要交互式登录的用户应该使用
    `nologin` shell。'
- en: If the user needs to be a member of certain groups, you can pass the `groups`
    attribute an array of the group names (just `devs` in this example).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户需要成为某些组的成员，你可以通过 `groups` 属性传递一个包含组名的数组（在此示例中仅为 `devs`）。
- en: Although Puppet supports a `password` attribute for `user` resources, I don't
    advise you to use it. Service users don't need passwords, and interactive users
    should be logging in with SSH keys. In fact, you should configure SSH to disable
    password logins altogether (set `PasswordAuthentication no` in `sshd_config`).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Puppet 为 `user` 资源支持 `password` 属性，我不建议你使用它。服务用户不需要密码，交互式用户应使用 SSH 密钥登录。实际上，你应该配置
    SSH 完全禁用密码登录（在 `sshd_config` 中设置 `PasswordAuthentication no`）。
- en: The group resource
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组资源
- en: The title of the resource is the name of the group (`devs`). You need not specify
    a `gid` attribute but, for the same reasons as the `uid` attribute, it's a good
    idea to do so.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 资源的标题是组的名称（`devs`）。你不需要指定 `gid` 属性，但与 `uid` 属性一样，最好指定它。
- en: Managing SSH keys
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理 SSH 密钥
- en: I like to have as few interactive logins as possible on production nodes, because
    it reduces the attack surface. Fortunately, with configuration management, it
    should rarely be necessary to actually log in to a node. The most common reasons
    for needing an interactive login are for system maintenance and troubleshooting,
    and for deployment. In both cases there should be a single account named for this
    specific purpose (for example, `admin` or `deploy`), and it should be configured
    with the SSH keys of any users or systems that need to log in to it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢在生产节点上尽量减少交互式登录，因为这能减少攻击面。幸运的是，使用配置管理工具，通常不需要实际登录到节点。需要交互式登录的最常见原因是系统维护和故障排除，以及部署。在这两种情况下，应该有一个单独的账户，专门用于此目的（例如
    `admin` 或 `deploy`），并配置为具有需要登录该账户的任何用户或系统的 SSH 密钥。
- en: 'Puppet provides the `ssh_authorized_key` resource to control the SSH keys associated
    with a user account. The following example shows how to use `ssh_authorized_key`
    to add an SSH key (mine, in this instance) to the `ubuntu` user on our Vagrant
    VM (`ssh_authorized_key.pp`):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 提供了 `ssh_authorized_key` 资源来控制与用户账户关联的 SSH 密钥。以下示例展示了如何使用 `ssh_authorized_key`
    将一个 SSH 密钥（在此示例中是我的密钥）添加到我们 Vagrant 虚拟机上的 `ubuntu` 用户 (`ssh_authorized_key.pp`)：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The title of the resource is the SSH key comment, which reminds us who the
    key belongs to. The `user` attribute specifies the user account which this key
    should be authorized for. The `type` attribute identifies the SSH key type, usually
    `ssh-rsa` or `ssh-dss`. Finally, the `key` attribute sets the key itself. When
    this manifest is applied, it adds the following to the `ubuntu` user''s `authorized_keys`
    file:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 资源的标题是 SSH 密钥的注释，提醒我们这个密钥属于谁。`user` 属性指定了此密钥应被授权的用户账户。`type` 属性标识 SSH 密钥的类型，通常是
    `ssh-rsa` 或 `ssh-dss`。最后，`key` 属性设置了密钥本身。当应用此清单时，它会将以下内容添加到 `ubuntu` 用户的 `authorized_keys`
    文件中：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A user account can have multiple SSH keys associated with it, and anyone holding
    one of the corresponding private keys and its passphrase will be able to log in
    as that user.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用户账户可以关联多个 SSH 密钥，持有其中一个对应私钥及其密码短语的人将能够以该用户身份登录。
- en: Removing users
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除用户
- en: 'If you need to have Puppet remove user accounts (for example, as part of an
    employee leaving process), it''s not enough to simply remove the `user` resource
    from the Puppet manifest. Puppet will ignore any users on the system that it doesn''t
    know about, and it certainly will not remove anything it finds on the system that
    isn''t mentioned in the Puppet manifest; that would be extremely undesirable (almost
    everything would be removed). So we need to retain the `user` declaration for
    a while, but set the `ensure` attribute to `absent` (`user_remove.pp`):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要 Puppet 移除用户账户（例如，作为员工离职的流程一部分），仅仅从 Puppet 清单中删除 `user` 资源是不够的。Puppet 会忽略系统中它不了解的用户，而且它绝对不会删除任何未在
    Puppet 清单中提到的系统内容；那样做会非常不理想（几乎所有内容都会被删除）。因此，我们需要保留 `user` 声明一段时间，但将 `ensure` 属性设置为
    `absent`（`user_remove.pp`）：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once Puppet has run everywhere, you can remove the `user` resource if you like,
    but it does no harm to simply leave it in place, and in fact, it's a good idea
    to do this, unless you can verify manually that the user has been deleted from
    every affected system.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Puppet 在所有地方运行完成，你可以选择移除 `user` 资源，但完全没有必要，实际上，除非你能手动确认该用户已从所有受影响的系统中删除，否则最好保留该资源。
- en: Tip
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you need to prevent a user logging in, but want to retain the account and
    any files owned by the user, for archival or compliance purposes, you can set
    their `shell` to `/usr/sbin/nologin`. You can also remove any `ssh_authorized_key`
    resources associated with their account, and set the `purge_ssh_keys` attribute
    to `true` on the `user` resource. This will remove any authorized keys for the
    user that are not managed by Puppet.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要防止某个用户登录，但又想保留该用户的账户和所有文件（用于归档或合规性目的），你可以将其 `shell` 设置为 `/usr/sbin/nologin`。你还可以删除与该账户关联的任何
    `ssh_authorized_key` 资源，并将 `user` 资源上的 `purge_ssh_keys` 属性设置为 `true`。这将移除任何非 Puppet
    管理的授权密钥。
- en: Cron resources
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cron 资源
- en: Cron is the mechanism on Unix-like systems which runs scheduled jobs, sometimes
    known as batch jobs, at specified times or intervals. For example, system housekeeping
    tasks, such as log rotation or checking for security updates, are run from cron.
    The details of what to run and when to run it are kept in a specially formatted
    file called `crontab` (short for **cron table**).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Cron 是类 Unix 系统中用于运行定时任务的机制，有时也称为批处理任务，这些任务会在指定的时间或间隔执行。例如，系统维护任务，如日志轮换或检查安全更新，都是通过
    cron 来执行的。关于执行内容和时间的详细信息会保存在一个特殊格式的文件中，叫做 `crontab`（即 **cron 表** 的缩写）。
- en: 'Puppet provides the `cron` resource for managing scheduled jobs, and we saw
    an example of this in the `run-puppet` manifest we developed in [Chapter 3](ch03.html
    "Chapter 3. Managing your Puppet code with Git"), *Managing your Puppet code with
    Git* (`run-puppet.pp`):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 提供了 `cron` 资源来管理定时任务，我们在 [第 3 章](ch03.html "第 3 章：用 Git 管理 Puppet 代码")
    *用 Git 管理 Puppet 代码* (`run-puppet.pp`) 的清单中看到过这个例子：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The title `run-puppet` identifies the cron job (Puppet writes a comment to the
    `crontab` file containing this name to distinguish it from other manually-configured
    cron jobs). The `command` attribute specifies the command for cron to run, and
    the `hour` and `minute` specify the time (`*/15` is a cron syntax, meaning "every
    15 minutes").
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`run-puppet` 标题标识了该 cron 任务（Puppet 会在 `crontab` 文件中写入一个注释，包含该名称，以区分其他手动配置的
    cron 任务）。`command` 属性指定了 cron 执行的命令，`hour` 和 `minute` 指定了时间（`*/15` 是 cron 语法，意思是“每
    15 分钟”）。'
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about cron and the possible ways to specify the times of
    scheduled jobs, run the command `man 5 crontab`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要了解更多关于 cron 及指定定时任务时间的不同方法，可以运行命令 `man 5 crontab`。
- en: Attributes of the cron resource
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: cron 资源的属性
- en: 'The `cron` resource has a few other useful attributes which are shown in the
    following example (`cron.pp`):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`cron` 资源还有一些其他有用的属性，这些在以下示例（`cron.pp`）中展示：'
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `user` attribute specifies who should run the cron job (if none is specified,
    the job runs as `root`). If the `environment` attribute is given, it sets any
    environment variables the cron job might need. A common use for this is to email
    any output from the cron job to a specified email address, using the `MAILTO`
    variable.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`user` 属性指定了谁来运行该 cron 任务（如果没有指定，任务将作为 `root` 用户运行）。如果给定了 `environment` 属性，它会设置
    cron 任务可能需要的任何环境变量。一个常见的用途是通过 `MAILTO` 变量将 cron 任务的任何输出邮件发送到指定的邮箱地址。'
- en: As before, the `hour` and `minute` attributes set the time for the job to run,
    while you can use the `weekday` attribute to specify a particular day, or days,
    of the week. (The `monthday` attribute works the same way, and can take any range
    or array of values between 1-31 to specify the day of the month.)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`hour` 和 `minute` 属性设置作业运行的时间，而 `weekday` 属性可用于指定一周的特定日或多个日。(`monthday`
    属性也是这样工作的，并且可以取1-31之间的任何范围或数组值来指定月份的日期。)
- en: Tip
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: One important point about cron scheduling is that the default value for any
    schedule attribute is `*`, which means *all allowed values*. For example, if you
    do not specify an `hour` attribute, the cron job will be scheduled with an `hour`
    of `*`, meaning that it will run every hour. This is generally not what you want.
    If you do want it to run every hour, specify `hour => '*'` in your manifest, but
    otherwise, specify the particular hour it should run at. The same goes for `minute`.
    Accidentally leaving out the `minute` attribute and having a job run sixty times
    an hour can have amusing consequences, to say the least.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 cron 调度的一个重要点是，任何调度属性的默认值都是 `*`，这意味着 *所有允许的值*。例如，如果未指定 `hour` 属性，那么 cron
    作业将被调度为 `hour` 为 `*`，这意味着它将每小时运行一次。这通常不是您想要的。如果确实希望每小时运行一次，请在您的清单中指定 `hour =>
    '*'`，但否则，请指定应在其运行的特定小时。对于 `minute` 也是如此。意外地省略 `minute` 属性，并导致作业每小时运行六十次，可能会产生有趣的后果，至少可以这么说。
- en: Randomizing cron jobs
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机化 cron 作业
- en: If you run a cron job on many nodes, it's a good idea to make sure the job doesn't
    run everywhere at the same time. Puppet provides a built-in function `fqdn_rand()`
    to help with this; it provides a random number up to a specified maximum value,
    which will be different on each node, because the random number generator is seeded
    with the node's hostname.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在许多节点上运行一个 cron 作业，最好确保作业不会在同一时间同时运行。Puppet 提供了一个内置函数 `fqdn_rand()` 来帮助实现这一点；它提供一个随机数，最大值为指定值，因为随机数生成器是用节点的主机名种子化的，所以在每个节点上都会不同。
- en: 'If you have several such jobs to run, you can also supply a further seed value
    to the `fqdn_rand()` function, which can be any string and which will ensure that
    the value is different for each job (`fqdn_rand.pp`):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有几个这样的作业要运行，还可以向 `fqdn_rand()` 函数提供一个进一步的种子值，这可以是任何字符串，将确保该值对于每个作业都是不同的（`fqdn_rand.pp`）：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Because we gave a different string as the second argument to `fqdn_rand` for
    each cron job, it will return a different random value for each `hour` attribute.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们为每个 cron 作业的 `fqdn_rand` 的第二个参数给出了不同的字符串，它将为每个 `hour` 属性返回不同的随机值。
- en: The range of values returned by `fqdn_rand()` includes 0, but does not include
    the maximum value you specify. So, in the previous example, the values for `hour`
    will be between 0 and 23, inclusive.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`fqdn_rand()` 返回的值范围包括0，但不包括您指定的最大值。因此，在前面的示例中，`hour` 的值将在0到23之间，包括这两个值。'
- en: Removing cron jobs
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除 cron 作业
- en: Just as with `user` resources, or any type of resource, removing the resource
    declaration from your Puppet manifest does not remove the corresponding configuration
    from the node. In order to do that you need to specify `ensure => absent` on the
    resource.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 就像对待 `user` 资源或任何类型的资源一样，从 Puppet 清单中删除资源声明并不会从节点中删除相应的配置。为了做到这一点，您需要在资源上指定
    `ensure => absent`。
- en: Exec resources
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Exec 资源
- en: While the other resource types we've seen so far (`file`, `package`, `service`,
    `user`, `ssh_authorized_key`, and `cron`) have modeled some concrete piece of
    state on the node, such as a file, the `exec` resource is a little different.
    An `exec` allows you to run any arbitrary command on the node. This might create
    or modify state, or it might not; anything you can run from the command line,
    you can run via an `exec` resource.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们迄今为止看到的其他资源类型（`file`、`package`、`service`、`user`、`ssh_authorized_key` 和 `cron`）都在节点上建模了一些具体的状态，例如文件，但
    `exec` 资源有些不同。`exec` 允许您在节点上运行任意命令。这可能会创建或修改状态，也可能不会；您可以从命令行运行的任何内容，也可以通过 `exec`
    资源运行。
- en: Automating manual interaction
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化手动交互
- en: The most common use for an `exec` resource is to simulate manual interaction
    on the command line. Some older software is not packaged for modern operating
    systems, and needs to be compiled and installed from source, which requires you
    to run certain commands. The authors of some software have also not realized,
    or don't care, that users may be trying to install their product automatically
    and have install scripts which prompt for user input. This can require the use
    of `exec` resources to work around the problem.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`exec`资源最常见的用途是模拟命令行上的手动交互。一些较旧的软件并未为现代操作系统打包，需要从源代码编译和安装，这要求你运行特定的命令。有些软件的作者也没有意识到，或者根本不关心，用户可能正在尝试自动安装他们的产品，而他们的安装脚本会提示用户输入。这可能需要使用`exec`资源来解决这个问题。'
- en: Attributes of the exec resource
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`exec`资源的属性'
- en: 'The following example shows an `exec` resource for building and installing
    an imaginary piece of software (`exec.pp`):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了一个用于构建和安装虚拟软件的`exec`资源（`exec.pp`）：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The title of the resource can be anything you like, though, as usual with Puppet
    resources it must be unique. I tend to name `exec` resources after the problem
    they're trying to solve, as in this example.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 资源的标题可以是你喜欢的任何内容，不过，像往常一样，Puppet 资源必须是唯一的。我倾向于根据它们尝试解决的问题来命名`exec`资源，就像这个示例中一样。
- en: The `cwd` attribute sets the working directory where the command will be run
    (**current working directory**). When installing software, this is generally the
    software source directory.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`cwd`属性设置了执行命令的工作目录（**当前工作目录**）。在安装软件时，这通常是软件源目录。'
- en: The `command` attribute gives the command to run. This must be the full path
    to the command, but you can chain several commands together using the shell `&&`
    operator. This executes the next command only if the previous one succeeded, so
    in the example, if the `configure` command completes successfully, Puppet will
    go on to run `make install`, otherwise, it will stop with an error.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`command`属性指定要执行的命令。这个必须是命令的完整路径，但你可以使用 shell `&&` 运算符将多个命令链接在一起。只有前一个命令成功执行时，才会执行下一个命令。因此，在这个示例中，如果`configure`命令成功完成，Puppet
    将继续执行`make install`，否则它会因错误而停止。'
- en: Note
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you apply this example, Puppet will give you an error like the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你应用这个示例，Puppet 会给出类似以下的错误：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is expected because the specified command does not, in fact, exist. In
    your own manifests, you may see this error if you give the wrong path to a command,
    or if the package that provides the command hasn't been installed yet.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是预期的，因为指定的命令实际上并不存在。在你自己的清单中，如果你给命令的路径错误，或者提供命令的软件包尚未安装，你可能会看到这个错误。
- en: The `creates` attribute specifies a file which should exist after the command
    has been run. If this file is present, Puppet will not run the command again.
    This is very useful because without a `creates` attribute, an `exec` resource
    will run every time Puppet runs, which is generally not what you want. The `creates`
    attribute tells Puppet, in effect, "Run the `exec` only if this file doesn't exist."
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`creates`属性指定在命令执行后应存在的文件。如果该文件存在，Puppet 将不会再次运行该命令。这非常有用，因为如果没有`creates`属性，`exec`资源每次
    Puppet 运行时都会执行，这通常不是你想要的。`creates`属性告诉 Puppet，实际上是“只有在该文件不存在时才运行`exec`”。'
- en: Let's see how this works, imagining that this `exec` is being run for the first
    time. We assume that the `/tmp/cat-picture/` directory exists and contains the
    source of the `cat-picture-generator` application.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下它是如何工作的，假设这个`exec`是第一次运行。我们假设`/tmp/cat-picture/`目录存在，并且包含`cat-picture-generator`应用的源代码。
- en: Puppet checks the `creates` attribute and sees that the `/usr/local/bin/cat-picture-generator`
    file is not present; therefore, the `exec` resource must be run.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Puppet 检查`creates`属性，发现`/usr/local/bin/cat-picture-generator`文件不存在；因此，必须运行`exec`资源。
- en: Puppet runs the `/tmp/cat-picture-generator/configure && /usr/bin/make install`
    command. As a side effect of these commands, the `/usr/local/bin/cat-picture-generator`
    file is created.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Puppet 执行`/tmp/cat-picture-generator/configure && /usr/bin/make install`命令。这些命令的副作用是创建了`/usr/local/bin/cat-picture-generator`文件。
- en: Next time Puppet runs, it again checks the `creates` attribute. This time `/usr/local/bin/cat-picture-generator`
    exists, so Puppet does nothing.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下次 Puppet 运行时，它再次检查`creates`属性。这次`/usr/local/bin/cat-picture-generator`文件已经存在，因此
    Puppet 不做任何操作。
- en: This `exec` resource will never be applied again so long as the file specified
    in the `creates` attribute exists. You can test this by deleting the file and
    applying Puppet again. The `exec` resource will be triggered and the file recreated.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 只要 `creates` 属性中指定的文件存在，该 `exec` 资源就永远不会再次应用。你可以通过删除该文件并再次应用 Puppet 来测试此行为。`exec`
    资源将被触发并重新创建文件。
- en: Tip
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Make sure that your `exec` resources always include a `creates` attribute (or
    a similar control attribute, such as `onlyif` or `unless`, which we'll look at
    later in this chapter). Without this, the `exec` command will be run every time
    Puppet runs, which is almost certainly not what you want.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的 `exec` 资源始终包含 `creates` 属性（或类似的控制属性，如 `onlyif` 或 `unless`，我们将在本章稍后查看）。没有这个属性，`exec`
    命令将每次 Puppet 运行时都执行，这几乎肯定不是你想要的。
- en: Note that building and installing software from source is not a recommended
    practice for production systems. It's better to build the software on a dedicated
    build server (perhaps using Puppet code similar to this example), create a system
    package for it, and then use Puppet to install that package on production nodes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，从源代码构建和安装软件并不是生产系统中的推荐做法。最好在专用构建服务器上构建软件（可能使用类似本示例的 Puppet 代码），为其创建系统包，然后使用
    Puppet 在生产节点上安装该包。
- en: The user attribute
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`user` 属性'
- en: 'If you don''t specify a `user` attribute for an `exec` resource, Puppet will
    run the command as the `root` user. This is often appropriate for installing system
    software or making changes to the system configuration, but if you need the command
    to run as a particular user, specify the `user` attribute, as in the following
    example (`exec_user.pp`):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有为 `exec` 资源指定 `user` 属性，Puppet 会以 `root` 用户身份运行该命令。这通常适用于安装系统软件或更改系统配置，但如果你希望命令以特定用户身份运行，可以指定
    `user` 属性，如以下示例所示（`exec_user.pp`）：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This will run the specified command as the `ubuntu` user. The `whoami` command
    returns the name of the user running it, so when you apply this manifest, the
    file `/tmp/hello-ubuntu.txt` will be created with the following contents:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这将以 `ubuntu` 用户身份运行指定的命令。`whoami` 命令返回运行该命令的用户名，因此当你应用此清单时，文件 `/tmp/hello-ubuntu.txt`
    将被创建，内容如下：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As with the earlier example, the `creates` attribute prevents Puppet from running
    this command more than once.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的示例一样，`creates` 属性可以防止 Puppet 多次运行该命令。
- en: The onlyif and unless attributes
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`onlyif` 和 `unless` 属性'
- en: Suppose you only want an `exec` resource to be applied under certain conditions.
    For example, a command which processes incoming data files only needs to run if
    there are data files waiting to be processed. In this case, it's no good adding
    a `creates` attribute; we want the existence of a certain file to trigger the
    `exec`, not prevent it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你只希望在某些条件下应用 `exec` 资源。例如，处理传入数据文件的命令只在有数据文件等待处理时才需要运行。在这种情况下，添加 `creates`
    属性没有用；我们希望某个特定文件的存在触发 `exec`，而不是阻止它。
- en: 'The `onlyif` attribute is a good way to solve this problem. It specifies a
    command for Puppet to run, and the exit status from this command determines whether
    or not the `exec` will be applied. On Unix-like systems, commands generally return
    an exit status of zero to indicate success and a non-zero value for failure. The
    following example shows how to use `onlyif` in this way (`exec_onlyif.pp`):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`onlyif` 属性是解决此问题的好方法。它指定了一个 Puppet 要执行的命令，且该命令的退出状态决定是否应用 `exec`。在类 Unix 系统中，命令通常返回零的退出状态表示成功，非零值表示失败。以下示例展示了如何以这种方式使用
    `onlyif`（`exec_onlyif.pp`）：'
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The exact command isn't important here, but let's assume it's something that
    we would only want to run if there are any files in the `/tmp/incoming/` directory.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 精确的命令在这里并不重要，但假设它是我们只希望在 `/tmp/incoming/` 目录中有文件时运行的命令。
- en: The `onlyif` attribute specifies the check command which Puppet should run first,
    to determine whether or not the `exec` resource needs to be applied. If there
    is nothing in the `/tmp/incoming/` directory, then `ls /tmp/incoming/*` will return
    a non-zero exit status. Puppet interprets this as failure, so does not apply the
    `exec` resource.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`onlyif` 属性指定了 Puppet 首先应运行的检查命令，以确定是否需要应用 `exec` 资源。如果 `/tmp/incoming/` 目录为空，`ls
    /tmp/incoming/*` 将返回非零退出状态。Puppet 将此视为失败，因此不会应用 `exec` 资源。'
- en: On the other hand, if there are files in the `/tmp/incoming/` directory, the
    `ls` command will return success. This tells Puppet the `exec` resource must be
    applied, so it proceeds to run the `/usr/local/bin/cat-picture-generator` command
    (and we can assume this command deletes the incoming files after processing).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果`/tmp/incoming/`目录中有文件，`ls`命令将返回成功。这告诉Puppet该`exec`资源必须被应用，所以它继续执行`/usr/local/bin/cat-picture-generator`命令（我们可以假设这个命令在处理后会删除传入的文件）。
- en: You can think of the `onlyif` attribute as telling Puppet, "Run the `exec` resource
    *only if* this command succeeds."
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`onlyif`属性看作是告诉Puppet，“只有在这个命令成功的情况下，才运行`exec`资源”。
- en: The `unless` attribute is exactly the same as `onlyif` but with the opposite
    sense. If you specify a command to the `unless` attribute, the `exec` will always
    be run unless the command returns a zero exit status. You can think of `unless`
    as telling Puppet, "Run the `exec` resource *unless* this command succeeds."
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`unless`属性与`onlyif`属性完全相同，只是语义相反。如果你为`unless`属性指定一个命令，那么除非该命令返回零退出状态，否则`exec`将始终运行。你可以将`unless`看作是告诉Puppet，“除非这个命令成功，否则运行`exec`资源”。'
- en: 'When you apply your manifest, if you see an `exec` resource running every time
    which shouldn''t be, check whether it specifies a `creates`, `unless`, or `onlyif`
    attribute. If it specifies the `creates` attribute, it may be looking for the
    wrong file; if the `unless` or `onlyif` command is specified, it may not be returning
    what you expect. You can see what command is being run and what output it generates
    by running `sudo puppet apply` with the `-d` (debug) flag:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当你应用清单时，如果你看到每次都在运行一个`exec`资源，而这个资源不应该这样运行，请检查它是否指定了`creates`、`unless`或`onlyif`属性。如果它指定了`creates`属性，可能是它在寻找错误的文件；如果指定了`unless`或`onlyif`命令，可能它返回的结果与你的预期不符。你可以通过运行带有`-d`（调试）标志的`sudo
    puppet apply`命令来查看正在执行的命令以及它生成的输出：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The refreshonly attribute
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`refreshonly`属性'
- en: It's quite common to use `exec` resources for one-off commands, such as rebuilding
    a database, or setting a system-tunable parameter. These generally only need to
    be triggered once, when a package is installed, or occasionally, when a config
    file is updated. If an `exec` resource needs to run only when some other Puppet
    resource is changed, we can use the `refreshonly` attribute to do this.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`exec`资源执行一次性命令是很常见的，例如重建数据库或设置系统可调节的参数。这些通常只需要在安装软件包时触发一次，或者偶尔在更新配置文件时触发。如果一个`exec`资源只需要在某个其他Puppet资源发生变化时运行，我们可以使用`refreshonly`属性来实现这一点。
- en: 'If `refreshonly` is `true`, the `exec` will never be applied unless another
    resource triggers it with `notify`. In the following example, Puppet manages the
    `/etc/aliases` file (which maps local usernames to email addresses), and a change
    to this file triggers the execution of the command `newaliases`, which rebuilds
    the system alias database (`exec_refreshonly.pp`):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`refreshonly`为`true`，则除非另一个资源通过`notify`触发它，否则`exec`将永远不会被应用。在以下示例中，Puppet管理`/etc/aliases`文件（该文件将本地用户名映射到电子邮件地址），对该文件的更改会触发执行命令`newaliases`，该命令重建系统别名数据库（`exec_refreshonly.pp`）：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When this manifest is applied for the first time, the `/etc/aliases` resource
    causes a change to the file's contents, so Puppet sends a `notify` message to
    the `exec` resource. This causes the `newaliases` command to be run. If you apply
    the manifest again, you will see that the `aliases` file is not changed, so the
    `exec` is not run.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一次应用这个清单时，`/etc/aliases`资源会导致文件内容发生变化，因此Puppet会向`exec`资源发送一个`notify`消息。这导致执行`newaliases`命令。如果你再次应用该清单，你会看到`aliases`文件没有变化，因此`exec`没有被执行。
- en: Tip
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'While the `refreshonly` attribute is occasionally extremely useful, over-use
    of it can make your Puppet manifests hard to understand and debug, and it can
    also be rather fragile. Felix Frank makes this point in a blog post, *Friends
    Don''t Let Friends Use Refreshonly*:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`refreshonly`属性偶尔非常有用，但过度使用它会使你的Puppet清单难以理解和调试，而且也可能变得相当脆弱。Felix Frank在一篇博客文章中提出了这个观点，*朋友不要让朋友使用Refreshonly*：
- en: '"With the `exec` resource type considered the last ditch, its `refreshonly`
    parameter should be seen as especially outrageous. To make an `exec` resource
    fit into Puppet''s model better, you should use [the `creates`, `onlyif`, or `unless`]
    parameters instead." Refer to:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: “考虑到`exec`资源类型是最后的手段，它的`refreshonly`参数应该被视为尤其离谱。为了使`exec`资源更好地融入Puppet的模型，你应该使用[`creates`、`onlyif`或`unless`]参数。”请参阅：
- en: '[http://ffrank.github.io/misc/2015/05/26/friends-don''t-let-friends-use-refreshonly/](http://ffrank.github.io/misc/2015/05/26/friends-don''t-let-friends-use-refreshonly/)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://ffrank.github.io/misc/2015/05/26/friends-don''t-let-friends-use-refreshonly/](http://ffrank.github.io/misc/2015/05/26/friends-don''t-let-friends-use-refreshonly/)'
- en: Note that you don't need to use the `refreshonly` attribute in order to make
    the `exec` resource notifiable by other resources. Any resource can notify an
    `exec` resource in order to make it run; however, if you don't want it to run
    *unless* it's notified, use `refreshonly`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你不需要使用`refreshonly`属性来让`exec`资源被其他资源通知。任何资源都可以通知`exec`资源以使其运行；然而，如果你希望它*仅在*被通知时运行，可以使用`refreshonly`。
- en: Tip
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: By the way, if you actually want to manage email aliases on a node, use Puppet's
    built-in `mailalias` resource. The previous example is just to demonstrate the
    use of `refreshonly`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，如果你确实想在节点上管理电子邮件别名，请使用 Puppet 内置的`mailalias`资源。之前的示例只是为了演示如何使用`refreshonly`。
- en: The logoutput attribute
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: logoutput属性
- en: When Puppet runs shell commands via an `exec` resource, the output is normally
    hidden from us. However, if the command doesn't seem to be working properly, it
    can be very useful to see what output it produced, as this usually tells us why
    it didn't work.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Puppet 通过`exec`资源运行 shell 命令时，输出通常对我们是隐藏的。然而，如果命令似乎没有正确工作，查看它产生的输出通常非常有用，因为这通常能告诉我们为什么它没有工作。
- en: 'The `logoutput` attribute determines whether Puppet will log the output of
    the `exec` command along with the usual informative Puppet output. It can take
    three values: `true`, `false`, or `on_failure`.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`logoutput`属性决定 Puppet 是否会记录`exec`命令的输出，并与通常的信息性 Puppet 输出一起显示。它可以有三个值：`true`、`false`或`on_failure`。'
- en: If `logoutput` is set to `on_failure` (which is the default), Puppet will only
    log command output when the command fails (that is, returns a non-zero exit status).
    If you never want to see command output, set it to `false`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`logoutput`设置为`on_failure`（这是默认值），Puppet 仅在命令失败时记录命令输出（即返回非零退出状态时）。如果你不希望看到任何命令输出，可以将其设置为`false`。
- en: Sometimes, however, the command returns a successful exit status but does not
    appear to do anything. Setting `logoutput` to `true` will force Puppet to log
    the command output regardless of exit status, which should help you figure out
    what's going on.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时命令会返回成功的退出状态，但似乎没有做任何事情。将`logoutput`设置为`true`将强制 Puppet 记录命令输出，无论退出状态如何，这应该能帮助你找出问题所在。
- en: The timeout attribute
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超时属性
- en: Sometimes, commands can take a long time to run, or never terminate at all.
    By default, Puppet allows an `exec` command to run for 300 seconds, at which point
    Puppet will terminate it if it has not finished. If you need to allow a little
    longer for the command to complete, you can use the `timeout` attribute to set
    this. The value is the maximum execution time for the command in seconds.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，命令可能需要很长时间才能运行，或者根本不会终止。默认情况下，Puppet 允许`exec`命令运行 300 秒，在此期间如果命令尚未完成，Puppet
    会终止它。如果你需要允许命令稍长时间完成，可以使用`timeout`属性来设置。该值是命令最大执行时间（以秒为单位）。
- en: Setting a `timeout` value of `0` disables the automatic timeout altogether and
    allows the command to run forever. This should be the last resort, as a command
    which blocks or hangs could stop Puppet's automatic runs altogether if no timeout
    is set. To find a suitable value for `timeout`, try running the command a few
    times and choose a value which is perhaps twice as long as a typical run. This
    should avoid failures caused by slow network conditions, for example, but not
    block Puppet from running altogether.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 将`timeout`值设置为`0`会完全禁用自动超时，并允许命令无限期运行。这应当是最后的手段，因为如果没有设置超时，一个阻塞或挂起的命令可能会完全停止
    Puppet 的自动运行。为了找到合适的`timeout`值，尝试运行命令几次，并选择一个大约是典型运行时间两倍的值。这应该能避免因网络慢导致的失败，但不会完全阻止
    Puppet 运行。
- en: How not to misuse exec resources
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何避免错误使用exec资源
- en: 'The `exec` resource can do anything to the system that you could do from the
    command line. As you can imagine, such a powerful tool can be misused. In theory,
    Puppet is a declarative language: the manifest specifies the way things should
    be, and it is up to Puppet to take the necessary actions to make them so. Manifests
    are therefore what computer scientists call **idempotent**: the system is always
    in the same state after the catalog has been applied, and however many times you
    apply it, it will always be in that state.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`exec` 资源可以对系统做任何你从命令行可以做的事情。正如你可以想象的那样，像这样的强大工具可能会被滥用。理论上，Puppet 是一种声明性语言：清单指定了事物应该是什么样子，Puppet
    负责采取必要的措施使其实现。因此，清单是计算机科学家所说的**幂等**的：在应用了 catalog 后，系统始终保持在相同的状态，无论你应用多少次，它都会始终保持在这个状态。'
- en: The `exec` resource rather spoils this theoretical picture, by allowing Puppet
    manifests to have side-effects. Since your `exec` command can do anything, it
    could, for example, create a new 1 GB file on disk with a random name, and since
    this will happen every time Puppet runs, you could rapidly run out of disk space.
    It's best to avoid commands with side-effects like this. In general, there's no
    way to know from within Puppet exactly what changes to a system were caused by
    an `exec` resource.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`exec` 资源在一定程度上破坏了这个理论模型，因为它允许 Puppet 清单具有副作用。由于你的 `exec` 命令可以做任何事情，举个例子，它可能会在磁盘上创建一个新的
    1 GB 大小的文件，文件名是随机的，而由于每次 Puppet 运行时都会发生这种情况，你可能会很快耗尽磁盘空间。最好避免像这样的具有副作用的命令。通常情况下，无法从
    Puppet 内部精确知道 `exec` 资源对系统造成了哪些变化。'
- en: Commands run via `exec` are also sometimes used to bypass Puppet's existing
    resources. For example, if the `user` resource doesn't do quite what you want
    for some reason, you could create a user by running the `adduser` command directly
    from an `exec`. This is also a bad idea, since by doing this you lose the declarative
    and cross-platform nature of Puppet's built-in resources. `exec` resources potentially
    change the state of the node in a way that's invisible to Puppet's catalog.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `exec` 运行的命令有时也被用来绕过 Puppet 的现有资源。例如，如果 `user` 资源因某些原因没有完全满足你的需求，你可以通过 `exec`
    直接运行 `adduser` 命令来创建用户。这也是一个不好的做法，因为这样你就失去了 Puppet 内建资源的声明性和跨平台特性。`exec` 资源可能会以一种
    Puppet catalog 看不见的方式改变节点的状态。
- en: Tip
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'In general, if you need to manage a concrete aspect of system state which isn''t
    supported by Puppet''s built-in resource types, you should think about creating
    a custom resource type and provider to do what you want. This extends Puppet to
    add a new resource type, which you can then use to model the state of that resource
    in your manifests. Creating custom types and providers is an advanced topic and
    not covered in this book, but if you want to know more, consult the Puppet documentation:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，如果你需要管理 Puppet 内建资源类型不支持的系统状态的某个具体方面，你应该考虑创建自定义资源类型和提供程序来完成你想做的事情。这将扩展
    Puppet，添加一个新的资源类型，之后你可以在清单中使用它来建模该资源的状态。创建自定义类型和提供程序是一个高级主题，本书不涉及，但如果你想了解更多内容，可以查阅
    Puppet 文档：
- en: '[https://docs.puppet.com/guides/custom_types.html](https://docs.puppet.com/guides/custom_types.html)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.puppet.com/guides/custom_types.html](https://docs.puppet.com/guides/custom_types.html)'
- en: You should also think twice before running complex commands via `exec`, especially
    commands which use loops or conditionals. It's a better idea to put any complicated
    logic in a shell script (or, even better, in a real programming language), which
    you can then deploy and run with Puppet (avoiding, as we've said, unnecessary
    side-effects).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过 `exec` 运行复杂命令之前，你也应该三思而后行，尤其是使用了循环或条件语句的命令。一个更好的做法是将任何复杂的逻辑放在 shell 脚本中（或者更好的是放在真正的编程语言中），然后用
    Puppet 部署并运行它（避免我们之前提到的，不必要的副作用）。
- en: Tip
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As a matter of good Puppet style, every `exec` resource should have at least
    one of `creates`, `onlyif`, `unless`, or `refreshonly` specified, to stop it from
    being applied on every Puppet run. If you find yourself using `exec` just to run
    a command every time Puppet runs, make it a cron job instead.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 根据良好的 Puppet 风格，每个 `exec` 资源应该至少指定 `creates`、`onlyif`、`unless` 或 `refreshonly`
    中的一个，以防止它在每次 Puppet 运行时都被应用。如果你发现自己每次 Puppet 运行时都只是为了执行一个命令而使用 `exec`，不如将其设置为一个
    cron 任务。
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We've explored Puppet's `file` resource in detail, covering file sources, ownership,
    permissions, directories, symbolic links, and file trees. We've learned how to
    manage packages by installing specific versions, or the latest version, and how
    to uninstall packages. We've covered Ruby gems, both in the system context and
    Puppet's internal context. Along the way, we met the very useful `puppet-lint`
    tool.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们详细探索了Puppet的`file`资源，涵盖了文件源、所有权、权限、目录、符号链接和文件树。我们学会了如何通过安装特定版本或最新版本来管理软件包，以及如何卸载软件包。我们还了解了Ruby
    gems，既包括系统上下文中的，也包括Puppet内部上下文中的。在这个过程中，我们接触到了非常有用的`puppet-lint`工具。
- en: We have looked at `service` resources, including the `hasstatus`, `pattern`,
    `hasrestart`, `restart`, `stop`, and `start` attributes. We've learned how to
    create users and groups, manage home directories, shells, UIDs, and SSH authorized
    keys. We saw how to schedule, manage, and remove cron jobs.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经研究了`service`资源，包括`hasstatus`、`pattern`、`hasrestart`、`restart`、`stop`和`start`属性。我们学会了如何创建用户和组，管理主目录、shell、UID和SSH授权密钥。我们还了解了如何调度、管理和删除cron作业。
- en: Finally, we've learned all about the powerful `exec` resource, including how
    to run arbitrary commands, and how to run commands only under certain conditions,
    or only if a specific file is not present. We've seen how to use the `refreshonly`
    attribute to trigger an `exec` resource when other resources are updated, and
    we've explored the useful `logoutput` and `timeout` attributes of `exec` resources.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经了解了强大的`exec`资源，包括如何运行任意命令，以及如何在特定条件下或仅在某个文件不存在时运行命令。我们还了解了如何使用`refreshonly`属性，在其他资源更新时触发`exec`资源，并探索了`exec`资源中有用的`logoutput`和`timeout`属性。
- en: In the next chapter, we'll find out how to represent data and variables in Puppet
    manifests, including strings, numbers, Booleans, arrays, and hashes. We'll learn
    how to use variables and conditional expressions to determine which resources
    are applied, and we'll also learn about Puppet's `facts` hash and how to use it
    to get information about the system.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将了解如何在Puppet清单中表示数据和变量，包括字符串、数字、布尔值、数组和哈希。我们将学会如何使用变量和条件表达式来确定应用哪些资源，还将学习Puppet的`facts`哈希以及如何使用它获取有关系统的信息。
