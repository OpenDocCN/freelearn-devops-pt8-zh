- en: Chapter 6. Managing data with Hiera
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：使用 Hiera 管理数据
- en: '|   | *What you don''t know can''t hurt me.* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *What you don''t know can''t hurt me.* |   |'
- en: '|   | --*Edward S. Marshall* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*Edward S. Marshall* |'
- en: In this chapter, you will learn why it's useful to separate your data and code.
    You will see how to set up Puppet's built-in Hiera mechanism, how to use it to
    store and query configuration data, including encrypted secrets such as passwords,
    and how to use Hiera data to create Puppet resources.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习为什么将数据和代码分开是有用的。你将看到如何设置 Puppet 内置的 Hiera 机制，如何使用它存储和查询配置信息，包括加密的秘密信息如密码，以及如何使用
    Hiera 数据创建 Puppet 资源。
- en: '![Managing data with Hiera](img/8880_06_01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Hiera 管理数据](img/8880_06_01.jpg)'
- en: Why Hiera?
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择 Hiera？
- en: 'What do we mean by **configuration data**? There will be lots of pieces of
    information in your manifests which we can regard as configuration data: for example,
    the values of all your resource attributes. Look at the following example:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的**配置信息**是什么意思？在你的清单中会有很多我们可以视为配置信息的内容：例如，你所有资源属性的值。看下面的例子：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding manifest declares that version `5.2.0-1xenial` of the `puppet-agent`
    package should be installed. But what happens when a new version of Puppet is
    released? When you want to upgrade to it, you'll have to find this code, possibly
    deep in multiple levels of directories, and edit it to change the desired version
    number.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的清单声明了要安装版本为 `5.2.0-1xenial` 的 `puppet-agent` 包。但是当 Puppet 发布新版本时，会发生什么呢？当你想要升级时，你必须找到这段代码，可能在多个目录层级的深处，并且编辑它来改变所需的版本号。
- en: Data needs to be maintained
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据需要维护
- en: 'Multiply this by all the packages managed throughout your manifest, and there
    is there''s already a problem. But this is just one piece of data that needs to
    be maintained, and there are many more: the times of cron jobs, the email addresses
    for reports to be sent to, the URLs of files to fetch from the web, the parameters
    for monitoring checks, the amount of memory to configure for the database server,
    and so on. If these values are embedded in code in hundreds of manifest files,
    you''re setting up trouble for the future.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 将这一点乘以你在整个清单中管理的所有软件包，问题已经显现。但这只是需要维护的一部分数据，还有很多其他数据需要维护：例如，cron 任务的时间、报告发送的邮件地址、从网页上获取的文件
    URL、监控检查的参数、为数据库服务器配置的内存大小等等。如果这些值嵌入在成百上千个清单文件中的代码里，你将为未来埋下麻烦。
- en: How can you make your config data easy to find and maintain?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如何使你的配置信息更容易查找和维护？
- en: Settings depend on nodes
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置依赖于节点
- en: Mixing data with code makes it harder to find and edit that data. But there's
    another problem. What if you have two nodes to manage with Puppet, and there's
    a config value which needs to be different on each of them? For example, they
    might both have a cron job to run the backup, but the job needs to run at a different
    time on each node.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据和代码混合在一起会使得查找和编辑数据变得更加困难。但还有另一个问题。如果你有两个节点需要用 Puppet 来管理，而且有一个配置值需要在每个节点上不同怎么办？例如，它们可能都有一个
    cron 任务来运行备份，但任务需要在每个节点上不同的时间运行。
- en: How can you use different values for different nodes, without having lots of
    complicated logic in your manifest?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如何为不同的节点使用不同的值，而不在清单中加入大量复杂的逻辑？
- en: Operating systems differ
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作系统有所不同
- en: What if you have some nodes running Ubuntu 16, and some on Ubuntu 18? As you'll
    know if you've ever had to upgrade the operating system on a node, things change
    from one version to the next. For example, the name of the database server package
    might have changed from `mysql-server` to `mariadb-server`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一些节点运行 Ubuntu 16，而有些运行 Ubuntu 18呢？如果你曾经需要升级节点上的操作系统，你就会知道，从一个版本到下一个版本，许多事情都会发生变化。例如，数据库服务器包的名称可能从
    `mysql-server` 改成了 `mariadb-server`。
- en: How can you find the right value to use in your manifest depending on what operating
    system the node is running?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如何根据节点运行的操作系统找到在清单中使用的正确值？
- en: The Hiera way
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hiera 方法
- en: What we want is a kind of central database in Puppet where we can look up configuration
    settings. The data should be stored separately from Puppet code, and make it easy
    to find and edit values. It should be possible to look up values with a simple
    function call in Puppet code or templates. Further, we need to be able to specify
    different values depending on things like the hostname of the node, the operating
    system, or potentially anything else. We would also like to be able to enforce
    a particular data type for values, such as String or Boolean. The database should
    do all of this work for us, and just return the appropriate value to the manifest
    where it's needed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望的是在 Puppet 中拥有一个类似于中央数据库的地方，可以查找配置设置。数据应当与 Puppet 代码分开存储，并且使得查找和编辑值变得容易。应该能够通过
    Puppet 代码或模板中的简单函数调用来查找值。此外，我们还需要根据节点的主机名、操作系统或其他因素来指定不同的值。我们还希望能够对值强制执行特定的数据类型，如
    String 或 Boolean。数据库应当为我们完成所有这些工作，并返回需要的适当值。
- en: 'Fortunately, Hiera does exactly this. Hiera lets you store your config data
    in simple text files (actually, YAML, JSON, or HOCON files, which use popular
    structured text formats), and it looks like the following example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Hiera 正是如此操作的。Hiera 允许你将配置数据存储在简单的文本文件中（实际上是 YAML、JSON 或 HOCON 文件，这些文件使用流行的结构化文本格式），其内容如下所示：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In your manifest, you query the database using the `lookup()` function, as
    in the following example (`lookup.pp`):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的清单中，你可以使用 `lookup()` 函数查询数据库，如以下示例所示（`lookup.pp`）：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The arguments to `lookup` are the name of the Hiera key you want to retrieve
    (for example `backup_path`), and the expected data type (for example `String`).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`lookup` 的参数是你想要检索的 Hiera 键的名称（例如 `backup_path`）以及预期的数据类型（例如 `String`）。'
- en: Setting up Hiera
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Hiera
- en: Hiera needs to know one or two things before you can start using it, which are
    specified in the Hiera configuration file, named `hiera.yaml` (not to be confused
    this with Hiera data files, which are also YAML files, and we'll find about those
    later in this chapter.) Each Puppet environment has its own local Hiera config
    file, located at the root of the environment directory (for example, for the `production`
    environment, the local Hiera config file would be `/etc/puppetlabs/code/environments/production/hiera.yaml`).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用 Hiera 之前，Hiera 需要知道一两个信息，这些信息在 Hiera 配置文件中指定，文件名为 `hiera.yaml`（请不要将其与
    Hiera 数据文件混淆，后者也是 YAML 文件，我们将在本章后面了解它们）。每个 Puppet 环境都有自己的本地 Hiera 配置文件，位于环境目录的根目录下（例如，对于
    `production` 环境，本地 Hiera 配置文件的位置为 `/etc/puppetlabs/code/environments/production/hiera.yaml`）。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Hiera can also use a global config file located at `/etc/puppetlabs/puppet/hiera.yaml`,
    which takes precedence over the per-environment file, but the Puppet documentation
    recommends you only use this config layer for certain exceptional purposes, such
    as temporary overrides; all your normal Hiera data and configuration should live
    at the environment layer.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Hiera 还可以使用位于 `/etc/puppetlabs/puppet/hiera.yaml` 的全局配置文件，该文件优先于每个环境的配置文件，但
    Puppet 文档建议仅在某些特殊情况下使用此配置层，例如临时覆盖；所有常规的 Hiera 数据和配置应该保存在环境层中。
- en: 'The following example shows a minimal `hiera.yaml` file (`hiera_minimal.config.yaml`):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了一个最小的 `hiera.yaml` 文件（`hiera_minimal.config.yaml`）：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: YAML files begin with three dashes and a newline (`---`). This is part of the
    YAML format, not a Hiera feature; it's the syntax indicating the start of a new
    YAML document.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 文件以三个破折号和换行符开始（`---`）。这是 YAML 格式的一部分，而不是 Hiera 的特性；它是指示新 YAML 文档开始的语法。
- en: The most important setting in the `defaults` section is `datadir`. This tells
    Hiera in which directory to look for its data files. Conventionally, this is in
    a `data/` subdirectory of the Puppet manifest directory, but you can change this
    if you need to.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaults` 部分中最重要的设置是 `datadir`。它告诉 Hiera 在哪个目录查找数据文件。通常情况下，这些文件位于 Puppet 清单目录的
    `data/` 子目录中，但如果需要，你可以更改这个设置。'
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Large organizations may find it useful to manage Hiera data files separately
    to Puppet code, perhaps in a separate Git repo (for example, you might want to
    give certain people permission to edit Hiera data, but not Puppet manifests).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 大型组织可能会发现将 Hiera 数据文件与 Puppet 代码分开管理非常有用，例如，可以将其放在一个单独的 Git 仓库中（例如，你可能希望授予某些人编辑
    Hiera 数据的权限，但不允许编辑 Puppet 清单）。
- en: The `hierarchy` section is also interesting. This tells Hiera which files to
    read for its data and in which order. In the example only `Common defaults` is
    defined, telling Hiera to look for data in a file called `common.yaml`. We'll
    see later in this chapter what else you can do with the `hierarchy` section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`hierarchy` 部分也很有趣。它告诉 Hiera 要读取哪些文件及其顺序。在示例中，仅定义了 `Common defaults`，指示 Hiera
    在名为 `common.yaml` 的文件中查找数据。我们将在本章后面看到，您还可以在 `hierarchy` 部分做更多操作。'
- en: Adding Hiera data to your Puppet repo
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Hiera 数据添加到您的 Puppet 仓库
- en: 'Your Vagrant VM is already set up with a suitable Hiera config and the sample
    data file, in the `/etc/puppetlabs/code/environments/pbg` directory. Try it now:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 Vagrant 虚拟机已经配置好了适当的 Hiera 配置和示例数据文件，位于 `/etc/puppetlabs/code/environments/pbg`
    目录中。现在试试看：
- en: 'Run the following commands:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We haven't seen the `--environment` switch before, so it's time to briefly introduce
    Puppet environments. A Puppet **environment** is a directory containing a Hiera
    config file, Hiera data, a set of Puppet manifests—in other words, a complete,
    self-contained Puppet setup. Each environment lives in a named directory under
    `/etc/puppetlabs/code/environments`. The default environment is `production`,
    but you can use any environment you like by giving the `--environment` switch
    to the `puppet lookup` command. In the example, we are telling Puppet to use the
    `/etc/puppetlabs/code/environments/pbg` directory.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前没有看到过 `--environment` 参数，因此现在简要介绍一下 Puppet 环境。Puppet **环境**是一个包含 Hiera 配置文件、Hiera
    数据和一组 Puppet 清单的目录——换句话说，这是一个完整的、独立的 Puppet 配置。每个环境都位于 `/etc/puppetlabs/code/environments`
    下的一个命名目录中。默认环境是 `production`，但是您可以通过给 `puppet lookup` 命令传递 `--environment` 参数来使用任何您喜欢的环境。在示例中，我们告诉
    Puppet 使用 `/etc/puppetlabs/code/environments/pbg` 目录。
- en: When you come to add Hiera data to your own Puppet environment, you can use
    the example `hiera.yaml` and data files as a starting point.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将 Hiera 数据添加到自己的 Puppet 环境时，可以使用示例中的 `hiera.yaml` 和数据文件作为起点。
- en: Troubleshooting Hiera
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hiera 故障排除
- en: 'If you don''t get the result `This is a test` , your Hiera setup is not working
    properly. If you see the warning `Config file not found, using Hiera defaults`,
    check that your Vagrant box has an `/etc/puppetlabs/code/environments/pbg` directory.
    If not, destroy and re-provision your Vagrant box with:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有得到结果 `This is a test`，说明您的 Hiera 设置未正常工作。如果您看到警告 `Config file not found,
    using Hiera defaults`，请检查您的 Vagrant 虚拟机是否包含 `/etc/puppetlabs/code/environments/pbg`
    目录。如果没有，请销毁并重新配置您的 Vagrant 虚拟机，使用以下命令：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you see an error like the following, it generally indicates a problem with
    the Hiera data file syntax:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到类似以下的错误，一般意味着 Hiera 数据文件的语法存在问题：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If this is the case, check the syntax of your Hiera data files.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现这种情况，请检查您的 Hiera 数据文件的语法。
- en: Querying Hiera
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询 Hiera
- en: In Puppet manifests, you can use the `lookup()` function to query Hiera for
    the specified key (you can think of Hiera as a key-value database, where the keys
    are strings, and values can be any type).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puppet 清单中，您可以使用 `lookup()` 函数查询 Hiera 中指定的键（您可以将 Hiera 看作一个键值数据库，其中键是字符串，值可以是任何类型）。
- en: 'In general, you can use a call to `lookup()` anywhere in your Puppet manifests
    you might otherwise use a literal value. The following code shows some examples
    of this (`lookup2.pp`):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您可以在 Puppet 清单中任何可能使用文字值的地方使用 `lookup()` 调用。以下代码展示了这方面的一些示例（`lookup2.pp`）：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To apply this manifest in the example environment, run the following command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要在示例环境中应用此清单，请运行以下命令：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Typed lookups
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型化查找
- en: 'As we''ve seen, `lookup()` takes a second parameter which specifies the expected
    type of the value to be retrieved. Although this is optional, you should always
    specify it, to help catch errors. If you accidentally look up the wrong key, or
    mistype the value in the data file, you''ll get an error like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`lookup()` 函数有第二个参数，指定要检索的值的预期类型。虽然这是可选的，但您应该始终指定它，以帮助捕获错误。如果您不小心查询了错误的键，或在数据文件中错误地输入了值，您会看到类似这样的错误：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Types of Hiera data
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hiera 数据的类型
- en: 'As we''ve seen, Hiera data is stored in text files, structured using the format
    called **YAML Ain''t Markup Language**, which is a common way of organizing data.
    Here''s another snippet from our sample Hiera data file, which you''ll find at
    `/etc/puppetlabs/code/environments/pbg/data/common.yaml` on the VM:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，Hiera 数据存储在文本文件中，采用名为**YAML Ain't Markup Language**的格式进行结构化，这是组织数据的一种常见方式。以下是来自我们示例
    Hiera 数据文件的另一段代码，您可以在虚拟机的 `/etc/puppetlabs/code/environments/pbg/data/common.yaml`
    文件中找到：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There are actually three different kinds of Hiera data structures present:
    **single values**, **arrays**, and **hashes**. We''ll examine these in detail
    in a moment.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，存在三种不同类型的 Hiera 数据结构：**单一值**、**数组**和**哈希**。稍后我们将详细讨论这些内容。
- en: Single values
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一值
- en: 'Most Hiera data consists of a key associated with a single value, as in the
    previous example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Hiera 数据由一个与单一值相关联的键组成，如前面的示例所示：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The value can be any legal Puppet value, such as a String, as in this case,
    or it can be an Integer:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 值可以是任何合法的 Puppet 值，例如字符串（如本例所示），或者它也可以是整数：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Boolean values
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'You should specify Boolean values in Hiera as either `true` or `false`, without
    surrounding quotes. However, Hiera is fairly liberal in what it interprets as
    Boolean values: any of `true`, `on`, or `yes` (with or without quotes) are interpreted
    as a true value, and `false`, `off`, or `no` are interpreted as a false value.
    For clarity, though, stick to the following format:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在 Hiera 中将布尔值指定为`true`或`false`，且不加引号。然而，Hiera 对布尔值的解释较为宽松：`true`、`on`或`yes`（无论是否带引号）都会被解释为真值，而`false`、`off`或`no`则会被解释为假值。但为了清晰起见，最好遵循以下格式：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When you use `lookup()` to return a Boolean value in your Puppet code, you
    can use it as the conditional expression in, for example, an `if` statement:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Puppet 代码中使用`lookup()`返回布尔值时，可以将其用作条件表达式，例如在`if`语句中：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Arrays
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: 'Usefully, Hiera can also store an array of values associated with a single
    key:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有用的是，Hiera 也可以存储与单一键关联的值数组：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The key (`monitor_ips`) is followed by a list of values, each on its own line
    and preceded by a hyphen (`-`). When you call `lookup('monitor_ips', Array)` in
    your code, the values will be returned as a Puppet array.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 键（`monitor_ips`）后面跟着一个值的列表，每个值单独列在一行并以短横线（`-`）开头。当你在代码中调用`lookup('monitor_ips',
    Array)`时，值会作为 Puppet 数组返回。
- en: Hashes
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哈希
- en: 'As we saw in [Chapter 5](ch05.html "Chapter 5. Variables, expressions, and
    facts"), *Variables, expressions, and facts*, a hash (also called a **dictionary**
    in some programming languages) is like an array where each value has an identifying
    name (called the **key**), as in the following example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第5章](ch05.html "第5章 变量、表达式与事实")，*变量、表达式与事实*中看到的，哈希（在某些编程语言中也叫做**字典**）就像一个数组，其中每个值都有一个标识名称（称为**键**），如以下示例所示：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Each key-value pair in the hash is listed, indented on its own line. The `cobbler_config`
    hash has two keys, `manage_dhcp` and `pxe_just_once`. The value associated with
    each of those keys is `true`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希中的每对键值都会列出，并缩进在各自的行上。`cobbler_config`哈希包含两个键，`manage_dhcp`和`pxe_just_once`。与这些键关联的值是`true`。
- en: 'When you call `lookup(''cobbler_config'', Hash)` in a manifest, the data will
    be returned as a Puppet hash, and you can reference individual values in it using
    the normal Puppet hash syntax, as we saw in [Chapter 5](ch05.html "Chapter 5. Variables,
    expressions, and facts"), *Variables, expressions, and facts* (`lookup_hash.pp`):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在清单中调用`lookup('cobbler_config', Hash)`时，数据会作为 Puppet 哈希返回，你可以使用常规的 Puppet
    哈希语法引用其中的单个值，正如我们在[第5章](ch05.html "第5章 变量、表达式与事实")，*变量、表达式与事实*（`lookup_hash.pp`）中看到的那样：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since it''s very common for Hiera data to be a hash of hashes, you can retrieve
    values from several levels down in a hash by using the following "dot notation"
    (`lookup_hash_dot.pp`):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Hiera 数据常常是哈希中的哈希，你可以通过以下“点符号”(`lookup_hash_dot.pp`)从多层嵌套的哈希中检索值：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Interpolation in Hiera data
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hiera 数据中的插值
- en: 'Hiera data is not restricted to literal values; it can also include the value
    of Facter facts or Puppet variables, as in the following example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Hiera 数据不仅限于字面值；它还可以包括 Facter 事实或 Puppet 变量的值，如以下示例所示：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Anything within the `%{}` delimiters inside a quoted string is evaluated and
    interpolated by Hiera. Here, we're using the dot notation to reference a value
    inside the `$facts` hash.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 任何位于`%{}`定界符中的内容，都会被 Hiera 解析并插值。在这里，我们使用点符号引用`$facts`哈希中的一个值。
- en: Using lookup()
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用lookup()
- en: 'Helpfully, you can also interpolate Hiera data in Hiera data, by using the
    `lookup()` function as part of the value. This can save you repeating the same
    value many times, and can make your data more readable, as in the following example
    (also from `hiera_sample.yaml`):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有帮助的是，你还可以通过将`lookup()`函数作为值的一部分来在 Hiera 数据中插值。这可以避免多次重复相同的值，并使数据更易于阅读，如以下示例（也来自`hiera_sample.yaml`）所示：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is much more readable than simply listing a set of IP addresses with no
    indication of what they represent, and it prevents you accidentally introducing
    errors by updating a value in one place but not another. Use Hiera interpolation
    to make your data self-documenting.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这比单纯列出一组 IP 地址而不说明它们代表什么要易读得多，而且它可以防止你在一个地方更新值却忘记在另一个地方更新，避免引入错误。使用 Hiera 插值使你的数据自文档化。
- en: Using alias()
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 alias()
- en: 'When you use the `lookup()` function in a Hiera string value, the result is
    always a string. This is fine if you''re working with string data, or if you want
    to interpolate a Hiera value into a string containing other text. However, if
    you''re working with arrays, hashes, or Boolean values, you need to use the `alias()`
    function instead. This lets you re-use any Hiera data structure within Hiera,
    just by referencing its name:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Hiera 字符串值中使用 `lookup()` 函数时，结果总是一个字符串。如果你处理的是字符串数据，或者你想将一个 Hiera 值插入到包含其他文本的字符串中，这没问题。然而，如果你处理的是数组、哈希或布尔值，你需要使用
    `alias()` 函数。这样，你就可以通过引用其名称在 Hiera 中重用任何 Hiera 数据结构：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Don''t be fooled by the surrounding quotes: it may look as though `vpn_allow_list`
    will be a string value, but because we are using `alias()`, it will actually be
    an array, just like the value it is aliasing (`firewall_allow_list`).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被周围的引号所迷惑：看起来 `vpn_allow_list` 可能是一个字符串值，但由于我们使用了 `alias()`，它实际上将是一个数组，就像它所别名的值（`firewall_allow_list`）一样。
- en: Using literal()
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 literal()
- en: 'Because the percent character (`%`) tells Hiera to interpolate a value, you
    might be wondering how to specify a literal percent sign in data. For example,
    Apache uses the percent sign in its configuration to refer to variable names like
    `%{HTTP_HOST}`. To write values like these in Hiera data, we need to use the `literal()`
    function, which exists only to refer to a literal percent character. For example,
    to write the value `%{HTTP_HOST}` as Hiera data, we would need to write:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因为百分号字符（`%`）告诉 Hiera 进行插值，你可能会想知道如何在数据中指定字面上的百分号。例如，Apache 在其配置中使用百分号来表示像 `%{HTTP_HOST}`
    这样的变量名。要在 Hiera 数据中写入这样的值，我们需要使用 `literal()` 函数，它专门用于表示字面上的百分号字符。例如，要将值 `%{HTTP_HOST}`
    写为 Hiera 数据，我们需要写成：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can see a more complicated example in the sample Hiera data file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在示例 Hiera 数据文件中看到一个更复杂的例子：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The hierarchy
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 层次结构
- en: 'So far, we''ve only used a single Hiera data source (`common.yaml`). Actually,
    you can have as many data sources as you like. Each usually corresponds to a YAML
    file, and they are listed in the `hierarchy` section of the `hiera.yaml` file,
    with the highest-priority source first and the lowest last:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用了一个 Hiera 数据源（`common.yaml`）。实际上，你可以有任意多个数据源。每个数据源通常对应一个 YAML 文件，它们在
    `hiera.yaml` 文件的 `hierarchy` 部分列出，优先级最高的源在前，优先级最低的源在后：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In general, though, you should keep as much data as possible in the `common.yaml`
    file, simply because it's easier to find and maintain data if it's in one place,
    rather than scattered through several files.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一般来说，你应该尽可能将更多的数据保存在 `common.yaml` 文件中，因为如果数据集中在一个地方，查找和维护会更加方便，而不是分散在多个文件中。
- en: For example, if you have some Hiera data which is only used on the `monitor`
    node, you might be tempted to put it in a `nodes/monitor.yaml` file. But, unless
    it has to override some settings in `common.yaml`, you'll just be making it harder
    to find and update. Put everything in `common.yaml` that you can, and reserve
    other data sources only for overrides to common values.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你有一些只在 `monitor` 节点上使用的 Hiera 数据，你可能会倾向于将其放在 `nodes/monitor.yaml` 文件中。但是，除非它需要覆盖
    `common.yaml` 中的一些设置，否则你只是在让它更难找到和更新。将你能放入的所有内容都放进 `common.yaml`，而把其他数据源只保留用于覆盖公共值。
- en: Dealing with multiple values
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理多个值
- en: 'You may be wondering what happens if the same key is listed in more than one
    Hiera data source. For example, imagine the first source contains the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，如果同一个键出现在多个 Hiera 数据源中会发生什么。例如，假设第一个数据源包含以下内容：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Also, assume that `common.yaml` contains:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，假设 `common.yaml` 包含：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: What happens when you call `lookup('consul_node', Boolean)` with this data?
    There are two different values for `consul_node` in two different files, so which
    one does Hiera return?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当你用这些数据调用 `lookup('consul_node', Boolean)` 时，会发生什么？`consul_node` 在两个不同的文件中有两个不同的值，那么
    Hiera 会返回哪个值？
- en: The answer is that Hiera searches data sources in the order they are listed
    in the `hierarchy` section; that is to say, in priority order. It returns the
    first value found, so if there are multiple values, only the value from the first—that
    is, highest-priority— data source will be returned (that's the "hierarchy" part).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，Hiera会按照`hierarchy`部分中列出的顺序搜索数据源；也就是说，按照优先级顺序。它返回第一个找到的值，因此，如果有多个值，只有来自第一个——即优先级最高——数据源的值会被返回（这就是“层级”部分）。
- en: Merge behaviors
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并行为
- en: We said in the previous section that if there is more than one value matching
    the specified key, the first matching data source takes priority over the others.
    This is the default behavior, and this is what you'll usually want. However, sometimes
    you may want `lookup()` to return the union of all the matching values found,
    throughout the hierarchy. Hiera allows you to specify which of these strategies
    it should use when multiple values match your lookup.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一节中提到，如果有多个值匹配指定的键，第一个匹配的数据源优先于其他数据源。这是默认行为，也是你通常希望的行为。然而，有时你可能希望`lookup()`返回所有匹配值的并集，遍历整个层级。Hiera允许你指定在多个值匹配时，它应该使用哪种策略。
- en: 'This is called a **merge behavior**, and you can specify which merge behavior
    you want as the third argument to `lookup()`, after the key and data type (`lookup_merge.pp`):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为**合并行为**，你可以在`lookup()`的第三个参数中指定你希望使用的合并行为，紧跟着键和值类型（`lookup_merge.pp`）：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The default merge behavior is called `first`, and it returns only one value,
    the first found value. By contrast, the `unique` merge behavior returns all the
    values found, as a flattened array, with duplicates removed (hence `unique`).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的合并行为称为`first`，它仅返回一个值，即第一个找到的值。相对而言，`unique`合并行为会返回所有找到的值，作为一个扁平化的数组，去除重复值（因此称为`unique`）。
- en: If you are looking up hash data, you can use the `hash` merge behavior to return
    a merged hash containing all the keys and values from all matching hashes found.
    If Hiera finds two hash keys with the same name, only the value of the first will
    be returned. This is known as a **shallow merge**. If you want a deep merge (that
    is, one where matching hashes will be merged at all levels, instead of just the
    top level) use the `deep` merge behavior.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查找哈希数据，可以使用`hash`合并行为来返回一个合并后的哈希，包含所有匹配哈希中的键值对。如果Hiera找到两个具有相同名称的哈希键，则仅返回第一个的值。这被称为**浅合并**。如果你需要深度合并（即，匹配的哈希会在所有层级上进行合并，而不仅仅是顶层），请使用`deep`合并行为。
- en: If this all sounds a bit complicated, don't worry. The default merge behavior
    is probably what you want most of the time, and if you should happen to need one
    of the other behaviors instead, you can read more about it in the Puppet documentation.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一切听起来有点复杂，别担心。默认的合并行为通常是你大多数时候所需要的，如果你确实需要其他合并行为，可以在Puppet文档中找到更多信息。
- en: Data sources based on facts
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于fact的数据源
- en: 'The hierarchy mechanism lets you set common default values for all situations
    (usually in `common.yaml`), but override them in specific circumstances. For example,
    you can set a data source in the hierarchy based on the value of a Puppet fact,
    such as the hostname:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 层级机制允许你为所有情况设置通用的默认值（通常在`common.yaml`中），但可以在特定情况下覆盖这些值。例如，你可以根据Puppet fact的值在层级中设置数据源，比如主机名：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Hiera will look up the value of the specified fact and search for a data file
    with that name in the `nodes/` directory. In the previous example, if the node's
    hostname is `web1`, Hiera will look for the data file `nodes/web1.yaml` in the
    Hiera data directory. If this file exists and contains the specified Hiera key,
    the `web1` node will receive that value for its lookup, while other nodes will
    get the default value from `common`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Hiera将查找指定fact的值，并在`nodes/`目录中搜索具有该名称的数据文件。在前面的例子中，如果节点的主机名是`web1`，Hiera将会在Hiera数据目录中查找数据文件`nodes/web1.yaml`。如果该文件存在并包含指定的Hiera键，则`web1`节点将获得该值，而其他节点则会从`common`中获取默认值。
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that you can organize your Hiera data files in subdirectories under the
    main `data/` directory if you like, such as `data/nodes/`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你愿意，可以将Hiera数据文件组织在`data/`主目录下的子目录中，例如`data/nodes/`。
- en: 'Another useful fact to reference in the hierarchy is the operating system major
    version or codename. This is very useful when you need your manifest to work on
    more than one release of the operating system. If you have more than a handful
    of nodes, migrating to the latest OS release is usually a gradual process, upgrading
    one node at a time. If something has changed from one version to the next that
    affects your Puppet manifest, you can use the `os.distro.codename` fact to select
    the appropriate Hiera data, as in the following example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 层次结构中另一个有用的事实是操作系统的主要版本或代号。当你需要让清单在多个操作系统版本上工作时，这非常有用。如果你有多个节点，迁移到最新的操作系统版本通常是一个逐步的过程，每次升级一个节点。如果从一个版本到下一个版本有所变化，影响到你的
    Puppet 清单，你可以使用 `os.distro.codename` 事实来选择适当的 Hiera 数据，示例如下：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Alternatively, you can use the `os.release.major` fact:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用 `os.release.major` 事实：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For example, if your node is running Ubuntu 16.04 Xenial, Hiera will look for
    a data file named `os/xenial.yaml` (if you're using `os.distro.codename`) or `os/16.04.yaml`
    (if you're using `os.release.major`) in the Hiera data directory.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的节点正在运行 Ubuntu 16.04 Xenial，Hiera 会查找名为 `os/xenial.yaml`（如果使用 `os.distro.codename`）或
    `os/16.04.yaml`（如果使用 `os.release.major`）的数据文件，文件位于 Hiera 数据目录中。
- en: For more information about facts in Puppet, see [Chapter 5](ch05.html "Chapter 5. Variables,
    expressions, and facts"), *Variables, expressions, and facts*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Puppet 中事实的更多信息，请参见[第 5 章](ch05.html "第 5 章。变量、表达式和事实")，*变量、表达式和事实*。
- en: What belongs in Hiera?
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么应该放在 Hiera 中？
- en: What data should you put in Hiera, and what should be in your Puppet manifests?
    A good rule of thumb about when to separate data and code is to ask yourself what
    might **change** in the future. For example, the exact version of a package is
    a good candidate for Hiera data, because it's quite likely you'll need to update
    it in the future.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该将哪些数据放在 Hiera 中，哪些应该放在 Puppet 清单中？一个很好的经验法则是在考虑何时分离数据和代码时，问问自己将来可能会**变化**的是什么。例如，包的确切版本是
    Hiera 数据的一个很好的候选项，因为它很可能需要在未来进行更新。
- en: Another characteristic of data that belongs in Hiera is that it's **specific**
    to your site or company. If you take your Puppet manifest and give it to someone
    else in another company or organization, and she has to modify any values in the
    code to make it work at her site, then those values should probably be in Hiera.
    This makes it much easier to share and re-use code; all you have to do is edit
    some values in Hiera.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 属于 Hiera 的数据的另一个特点是它**特定**于你的网站或公司。如果你将 Puppet 清单交给其他公司或组织中的某个人，并且她需要修改代码中的某些值以使其在她的网站上运行，那么这些值可能应该放在
    Hiera 中。这样做可以更容易地共享和重用代码；你只需要在 Hiera 中编辑一些值。
- en: If the same data is needed in **more than one place** in your manifests, it's
    also a good idea for that data to be stored in Hiera. Otherwise, you have to either
    repeat the data, which makes it harder to maintain, or use a global variable,
    which is bad style in any programming language, and especially so in Puppet.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在多个地方都需要相同的数据，最好将该数据存储在 Hiera 中。否则，你要么不得不重复数据，这会增加维护的难度，要么使用全局变量，这在任何编程语言中都不推荐，尤其是在
    Puppet 中。
- en: If you have to change a data value when you apply your manifests on a different
    **operating system**, that's also a candidate for Hiera data. As we've seen in
    this chapter, you can use the hierarchy to select the correct value based on facts,
    such as the operating system or version.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在将清单应用到不同的**操作系统**时需要更改数据值，这也可以是 Hiera 数据的一个候选项。正如我们在本章中所看到的，你可以使用层次结构根据事实（例如操作系统或版本）选择正确的值。
- en: One other kind of data that belongs in Hiera is parameter values for classes
    and modules; we'll see more about that in [Chapter 7](ch07.html "Chapter 7. Mastering
    modules"), *Mastering modules*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 另一类属于 Hiera 的数据是类和模块的参数值；我们将在[第 7 章](ch07.html "第 7 章。掌握模块")中进一步了解，*掌握模块*。
- en: Creating resources with Hiera data
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Hiera 数据创建资源
- en: When we started working with Puppet, we created resources directly in the manifest
    using literal attribute values. In this chapter, we've seen how to use Hiera data
    to fill in the title and attributes of resources in the manifest. We can now take
    this idea one step further and create resources **directly from Hiera** queries.
    The advantage of this method is that we can create any number of resources of
    any type, based purely on data.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始使用 Puppet 时，我们是通过在清单中直接使用字面属性值来创建资源的。在这一章中，我们看到如何使用 Hiera 数据填充清单中资源的标题和属性。现在，我们可以更进一步，**直接从
    Hiera** 查询中创建资源。这种方法的优势在于，我们可以根据数据创建任何类型的资源，且数量不限。
- en: Building resources from Hiera arrays
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Hiera 数组构建资源
- en: In [Chapter 5](ch05.html "Chapter 5. Variables, expressions, and facts"), *Variables,
    expressions, and facts*, we learned how to use Puppet's `each` function to iterate
    over an array or hash, creating resources as we go. Let's apply this technique
    to some Hiera data. In our first example, we'll create some user resources from
    a Hiera array.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第五章](ch05.html "第五章：变量、表达式和事实")中，*变量、表达式和事实*，我们学习了如何使用 Puppet 的 `each` 函数来迭代数组或哈希，并在此过程中创建资源。让我们将这种技术应用到一些
    Hiera 数据中。在我们的第一个示例中，我们将从 Hiera 数组中创建一些用户资源。
- en: 'Run the following command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here''s the data we''re using (from the `/etc/puppetlabs/code/environments/pbg/data/common.yaml`
    file):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们使用的数据（来自 `/etc/puppetlabs/code/environments/pbg/data/common.yaml` 文件）：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And here''s the code which reads it and creates the corresponding user instances
    (`hiera_users.pp`):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是读取数据并创建相应用户实例的代码（`hiera_users.pp`）：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Combining Hiera data with resource iteration is a powerful idea. This short
    manifest could manage all the users in your infrastructure, without you ever having
    to edit the Puppet code to make changes. To add new users, you need only edit
    the Hiera data.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Hiera 数据与资源迭代结合起来是一个强大的想法。这个简短的清单可以管理你基础设施中的所有用户，而无需编辑 Puppet 代码来进行更改。要添加新用户，只需编辑
    Hiera 数据。
- en: Building resources from Hiera hashes
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Hiera 哈希构建资源
- en: 'Of course, real life is never quite as simple as a programming language example.
    If you were really managing users with Hiera data in this way, you''d need to
    include more data than just their names: you''d need to be able to manage shells,
    UIDs, and so on, and you''d also need to be able to remove the users if necessary.
    To do that, we will need to add some structure to the Hiera data.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，现实生活中的情况从来不会像编程语言示例那样简单。如果你真的用 Hiera 数据来管理用户，你需要包含比名字更多的数据：你需要能够管理用户的 shell、UID
    等，还需要能够在必要时删除用户。为此，我们需要为 Hiera 数据添加一些结构。
- en: 'Run the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The first difference from the previous example is that instead of the data
    being a simple array, it''s a hash of hashes:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前示例的第一个不同点是，这里数据不是简单的数组，而是哈希中的哈希：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here''s the code which processes that data (`hiera_users2.pp`):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是处理数据的代码（`hiera_users2.pp`）：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Each of the keys in the `users2` hash is a username, and each value is a hash
    of user attributes such as `uid` and `shell`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`users2` 哈希中的每个键是一个用户名，每个值是一个包含用户属性（如 `uid` 和 `shell`）的哈希。'
- en: 'When we call `each` on this hash, we specify two parameters to the loop instead
    of one:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对这个哈希调用 `each` 时，我们为循环指定了两个参数，而不是一个：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As we saw in [Chapter 5](ch05.html "Chapter 5. Variables, expressions, and facts"),
    *Variables, expressions, and facts*, when iterating over a hash, these two parameters
    receive the hash key and its value, respectively.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第五章](ch05.html "第五章：变量、表达式和事实")中看到的，*变量、表达式和事实*，在迭代哈希时，这两个参数分别接收哈希的键和值。
- en: 'Inside the loop, we create a user resource for each element of the hash:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部，我们为哈希中的每个元素创建一个用户资源：
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You may recall from the previous chapter that the `*` operator (the attribute
    splat operator) tells Puppet to treat `$attrs` as a hash of attribute-value pairs.
    So the first time round the loop, with user `katy`, Puppet will create a user
    resource equivalent to the following manifest:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得上一章中提到的 `*` 运算符（属性展开运算符），它告诉 Puppet 将 `$attrs` 视为属性-值对的哈希。因此，在第一次循环时，对于用户
    `katy`，Puppet 将创建一个等效于以下清单的用户资源：
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Every time we go round the loop with the next element of `users`, Puppet will
    create another user resource with the specified attributes.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们在循环中处理 `users` 的下一个元素时，Puppet 将使用指定的属性创建另一个用户资源。
- en: The advantages of managing resources with Hiera data
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Hiera 数据管理资源的优势
- en: 'The previous example makes it easy to manage users across your network without
    having to edit Puppet code: if you want to remove a user, for example, you would
    simply change her `ensure` attribute in the Hiera data to `absent`. Although each
    of the users happens to have the same set of attributes specified, this isn''t
    essential; you could add any attribute supported by the Puppet `user` resource
    to any user in the data. Also, if there''s an attribute whose value is always
    the same for all users, you need not list it in the Hiera data for every user.
    You can add it as a literal attribute value of the `user` resource inside the
    loop, and thus every user will have it.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例使得在网络中管理用户变得更加简便，而无需编辑 Puppet 代码：例如，如果你想删除一个用户，你只需将她的 `ensure` 属性在 Hiera
    数据中修改为 `absent`。尽管每个用户恰好都有相同的属性集，但这并非必须；你可以将 Puppet `user` 资源支持的任何属性添加到数据中的任何用户。此外，如果有一个属性的值对所有用户始终相同，则无需在每个用户的
    Hiera 数据中列出它。你可以将其作为 `user` 资源中的文字属性值添加到循环内，这样每个用户都会拥有它。
- en: 'This makes it easier to add and update users on a routine basis, but there
    are other advantages too: for example, you could write a simple web application
    which allowed HR staff to add or edit users using a browser interface, and it
    would only need to output a YAML file with the required data. This is much easier
    and more robust than trying to generate Puppet code automatically. Even better,
    you could pull user data from an LDAP or **Active Directory** (**AD**) server
    and put it into Hiera YAML format for input into this manifest.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得定期添加和更新用户变得更加容易，但也有其他优点：例如，你可以编写一个简单的 Web 应用程序，允许人力资源人员使用浏览器界面添加或编辑用户，并且它只需要输出一个包含所需数据的
    YAML 文件。这比自动生成 Puppet 代码要容易得多、也更加稳健。更好的是，你可以从 LDAP 或 **Active Directory**（**AD**）服务器中提取用户数据，并将其转换为
    Hiera YAML 格式，供该清单使用。
- en: 'This is a very powerful and flexible technique, and of course you can use it
    to manage any kind of Puppet resource: files, packages, Apache virtual hosts,
    MySQL databases—anything you can do with a resource you can do with Hiera data
    and `each`. You can also use Hiera''s override mechanism to create different sets
    of resources for different nodes, roles, or operating systems.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常强大且灵活的技术，当然你可以用它来管理任何类型的 Puppet 资源：文件、软件包、Apache 虚拟主机、MySQL 数据库——你能用资源做的任何事情都可以通过
    Hiera 数据和 `each` 来实现。你还可以使用 Hiera 的重写机制为不同的节点、角色或操作系统创建不同的资源集。
- en: However, you shouldn't over-use this technique. Creating resources from Hiera
    data adds a layer of abstraction which makes it harder to understand the code
    for anyone trying to read or maintain it. With Hiera, it can also be difficult
    to work out from inspection exactly what data the node will get in a given set
    of circumstances. Keep your hierarchy as simple as possible, and reserve the data-driven
    resources trick for situations where you have a large and variable number of resources
    which you need to update frequently. In [Chapter 11](ch11.html "Chapter 11. Orchestrating
    cloud resources"), *Orchestrating cloud resources*, we'll see how to use the same
    technique to manage cloud instances, for example.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你不应该过度使用这种技术。根据 Hiera 数据创建资源增加了一层抽象，使得任何试图阅读或维护代码的人更难理解它。使用 Hiera 时，从检查中也很难确切知道在特定情况下节点将获得哪些数据。尽量保持你的层次结构尽可能简单，并将数据驱动的资源技巧保留用于需要频繁更新的大量可变资源的场景。在[第
    11 章](ch11.html "第 11 章. 编排云资源")，*编排云资源*，我们将看到如何使用相同的技术来管理云实例。
- en: Managing secret data
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理机密数据
- en: Puppet often needs to know your secrets; for example, passwords, private keys,
    and other credentials need to be configured on the node, and Puppet must have
    access to this information. The problem is how to make sure that no-one else does.
    If you are checking this data into a Git repo, it will be available to anybody
    who has access to the repo, and if it's a public GitHub repo, everybody in the
    world can see it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 经常需要了解你的秘密；例如，密码、私钥和其他凭据需要在节点上配置，并且 Puppet 必须能够访问这些信息。问题是如何确保没有其他人能访问这些信息。如果你将这些数据提交到
    Git 仓库，它将对所有有权限访问该仓库的人可见，而如果是公共的 GitHub 仓库，任何人都能看到它。
- en: Clearly, it's essential to be able to encrypt secret data in such a way that
    Puppet can decrypt it on individual nodes where it's needed, but it's indecipherable
    to anybody who does not have the key. The popular GnuPG encryption tool is a good
    choice for this. It lets you encrypt data using a public key which can be distributed
    widely, but only someone with the corresponding private key can decrypt the information.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，能够以某种方式加密秘密数据是至关重要的，以便Puppet能够在需要的各个节点上解密它，但对没有密钥的人来说是无法解密的。流行的GnuPG加密工具是一个不错的选择，它允许您使用公开密钥加密数据，并且可以广泛分发，但只有拥有对应私钥的人才能解密信息。
- en: Hiera has a pluggable **backend** system which allows it to support various
    different ways of storing data. One such backend is called `hiera-eyaml-gpg`,
    which allows Hiera to use a GnuPG-encrypted data store. Rather than encrypting
    a whole data file, `hiera-eyaml-gpg` lets you mix encrypted and plaintext data
    in the same YAML file. That way, even someone who doesn't have the private key
    can still edit and update the plaintext values in Hiera data files, although the
    encrypted data values will be unreadable to them.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Hiera具有可插拔的**后端**系统，允许它支持多种不同的存储数据方式。一个这样的后端叫做`hiera-eyaml-gpg`，它允许Hiera使用GnuPG加密的数据存储。与加密整个数据文件不同，`hiera-eyaml-gpg`允许您在同一个YAML文件中混合加密和明文数据。这样，即使没有私钥的人也可以编辑和更新Hiera数据文件中的明文值，尽管加密的数据值对他们来说是不可读的。
- en: Setting up GnuPG
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置GnuPG
- en: 'First, we''ll need to install GnuPG and create a key pair for use with Hiera.
    The following instructions will help you do this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装GnuPG并创建一个用于Hiera的密钥对。以下说明将帮助您完成这项工作：
- en: 'Run the following command:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE40]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Once GnuPG is installed, run the following command to generate a new key pair:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦安装了GnuPG，运行以下命令生成一个新的密钥对：
- en: '[PRE41]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When prompted, select the RSA and RSA key type:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当系统提示时，选择RSA和RSA密钥类型：
- en: '[PRE42]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Select a 2,048 bit key size:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择2048位的密钥大小：
- en: '[PRE43]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Enter `0` for the key expiry time:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`0`作为密钥过期时间：
- en: '[PRE44]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When prompted for a real name, email address, and comment for the key, enter
    whatever is appropriate for your site:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当系统提示输入真实姓名、电子邮件地址和用于密钥的评论时，输入适合您网站的内容：
- en: '[PRE45]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When prompted for a passphrase, just hit *Enter* (the key can't have a passphrase,
    because Puppet won't be able to supply it).
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当系统提示输入密码短语时，直接按*Enter*（该密钥不能有密码短语，因为Puppet无法提供它）。
- en: 'It may take a few moments to generate the key, but once this is complete, GnuPG
    will print out the key fingerprint and details (yours will look different):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 生成密钥可能需要几分钟时间，但一旦完成，GnuPG会打印出密钥指纹和详细信息（您的密钥指纹会与此不同）：
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This key is now stored in your GnuPG keyring, and Hiera will be able to use
    it to encrypt and decrypt your secret data on this node. We'll see later in the
    chapter how to distribute this key to other nodes managed by Puppet.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 该密钥现在存储在您的GnuPG密钥环中，Hiera将能够在该节点上使用它来加密和解密您的秘密数据。稍后我们将看到如何将此密钥分发到Puppet管理的其他节点。
- en: Adding an encrypted Hiera source
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加一个加密的Hiera数据源
- en: 'A Hiera source using GPG-encrypted data needs a couple of extra parameters.
    Here''s the relevant section from the example `hiera.yaml` file:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GPG加密数据的Hiera源需要几个额外的参数。以下是示例`hiera.yaml`文件中的相关部分：
- en: '[PRE47]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As with normal data sources, we a have `name` and a `path` to the data file,
    but we also need to specify the `lookup_key` function, which in this case is `eyaml_lookup_key`,
    and set `options['gpg_gnupghome']` to point to the GnuPG directory, where the
    decryption key lives.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 与普通数据源一样，我们有`name`和`path`指向数据文件，但我们还需要指定`lookup_key`函数，在这种情况下是`eyaml_lookup_key`，并将`options['gpg_gnupghome']`设置为指向GnuPG目录，解密密钥存放在该目录下。
- en: Creating an encrypted secret
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建加密的秘密
- en: You're now ready to add some secret data to your Hiera store.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经准备好将一些秘密数据添加到您的Hiera存储中。
- en: 'Create a new empty Hiera data file with the following commands:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建一个新的空Hiera数据文件：
- en: '[PRE48]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Run the following command to edit the data file using the `eyaml` editor (which
    automatically encrypts the data for you when you save it). Instead of `puppet@cat-pictures.com`,
    use the email address that you entered when you created your GPG key.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令，使用`eyaml`编辑器编辑数据文件（保存时，它会自动为您加密数据）。请用您在创建GPG密钥时输入的电子邮件地址替代`puppet@cat-pictures.com`。
- en: '[PRE49]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If the system prompts you to select your default editor, choose the editor you
    prefer. If you're familiar with Vim, I recommend you choose that, but otherwise,
    you will probably find `nano` the easiest option. (You should learn Vim, but that's
    a subject for another book.)
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果系统提示你选择默认编辑器，请选择你喜欢的编辑器。如果你熟悉Vim，建议选择Vim，但如果不熟悉，你可能会发现`nano`是最简单的选择。（你应该学习Vim，但那是另一本书的内容。）
- en: 'Your selected editor will be started with the following text already inserted
    in the file:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你选择的编辑器将启动，并且以下文本已经插入到文件中：
- en: '[PRE50]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Enter the following text below the commented message, exactly as shown, including
    the beginning three hyphens:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在注释信息下方输入以下文本，完全按照显示的内容输入，包括开头的三个短横线：
- en: '[PRE51]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Save the file and exit the editor.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并退出编辑器。
- en: 'Run the following command to test that Puppet can read and decrypt your secret:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以测试Puppet是否能够读取并解密你的机密数据：
- en: '[PRE52]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How Hiera decrypts secrets
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hiera如何解密机密数据
- en: 'To prove to yourself that the secret data is actually encrypted, run the following
    command to see what it looks like in the data file on disk:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证数据确实是加密的，可以运行以下命令查看磁盘上数据文件中的内容：
- en: '[PRE53]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Of course, the actual ciphertext will be different for you, since you're using
    a different encryption key. The point is, though, the message is completely scrambled.
    GnuPG's encryption algorithms are extremely strong; even using every computer
    on Earth simultaneously, it would take (on average) many times the current age
    of the Universe to unscramble data encrypted with a 2,048-bit key. (Or, to put
    it a different way, the chances of decrypting the data within a reasonable amount
    of time are many billions to one.)
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，实际的密文会对你有所不同，因为你使用了不同的加密密钥。关键点在于，消息完全被打乱了。GnuPG的加密算法极其强大；即使同时使用地球上所有的计算机，解密使用2,048位密钥加密的数据平均需要比当前宇宙年龄多很多倍的时间。（换句话说，在合理的时间内解密数据的概率是几乎不可能的。）
- en: 'When you reference a Hiera key such as `test_secret` in your manifest, what
    happens next? Hiera consults its list of data sources configured in `hiera.yaml`.
    The first source in the hierarchy is `secret.eyaml`, which contains the key we''re
    interested in (`test_secret`). Here''s the value:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在清单中引用像`test_secret`这样的Hiera密钥时，接下来会发生什么？Hiera会查询在`hiera.yaml`中配置的数据源列表。层次结构中的第一个源是`secret.eyaml`，它包含我们感兴趣的密钥（`test_secret`）。以下是该值：
- en: '[PRE54]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `ENC` tells Hiera that this is an encrypted value, and the `GPG` identifies
    which type of encryption is being used (`hiera-eyaml` supports several encryption
    methods, of which GPG is one). Hiera calls the GPG subsystem to process the encrypted
    data, and GPG searches the keyring to find the appropriate decryption key. Assuming
    it finds the key, GPG decrypts the data and passes the result back to Hiera, which
    returns it to Puppet, and the result is the plaintext:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENC`告诉Hiera这是一个加密值，而`GPG`标识正在使用的加密类型（`hiera-eyaml`支持多种加密方法，其中GPG是其中之一）。Hiera调用GPG子系统处理加密数据，GPG在密钥环中搜索找到适当的解密密钥。如果找到密钥，GPG会解密数据并将结果传回Hiera，Hiera再返回给Puppet，最终的结果是明文：'
- en: '[PRE55]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The beauty of the system is that all of this complexity is hidden from you;
    all you have to do is call the function `lookup('test_secret', String)` in your
    manifest, and you get the answer.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的美妙之处在于所有这些复杂性都被隐藏起来；你需要做的只是调用`lookup('test_secret', String)`函数在你的清单中，然后你就能得到答案。
- en: Editing or adding encrypted secrets
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑或添加加密的机密数据
- en: 'If the secret data is stored in encrypted form, you might be wondering how
    to edit it when you want to change the secret value. Fortunately, there''s a way
    to do this. Recall that when you first entered the secret data, you used the following
    command:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果机密数据以加密形式存储，你可能会想知道当你想更改机密值时该如何编辑它。幸运的是，有方法可以做到这一点。记得当你第一次输入机密数据时，你使用了以下命令：
- en: '[PRE56]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you run the same command again, you''ll find that you''re looking at your
    original plaintext (along with some explanatory comments):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次运行相同的命令，你会发现你正在查看原始的明文（以及一些解释性注释）：
- en: '[PRE57]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You can edit the `This is a test secret` string (make sure to leave everything
    else exactly as it is, including the `DEC::GPG[]!` delimiters). When you save
    the file and close the editor, the data will be re-encrypted using your key, if
    it has changed.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编辑`This is a test secret`字符串（确保其他部分保持不变，包括`DEC::GPG[]!`分隔符）。当你保存文件并关闭编辑器时，如果密钥发生变化，数据将使用你的密钥重新加密。
- en: Don't remove the `(1)` in parentheses after `DEC`; it tells Hiera that this
    is an existing secret, not a new one. As you add more secrets to this file, they
    will be identified with increasing numbers.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 不要删除`DEC`后面括号中的`(1)`，它告诉Hiera这是一个已存在的密钥，而不是新的密钥。随着你向此文件添加更多的密钥，它们将被依次编号。
- en: 'For convenience of editing, I suggest you make a shell script, called something
    like `/usr/local/bin/eyaml_edit`, which runs the `eyaml edit` command. There''s
    an example on your Vagrant box, at `/examples/eyaml_edit.sh`, which you can copy
    to `/usr/local/bin` and edit (as before, substitute the `gpg-recipients` email
    address with the one associated with your GPG key):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便编辑，我建议你制作一个名为`/usr/local/bin/eyaml_edit`的shell脚本，用于运行`eyaml edit`命令。你可以在Vagrant盒子中的`/examples/eyaml_edit.sh`找到一个示例，复制到`/usr/local/bin`并进行编辑（像之前一样，用与你的GPG密钥关联的邮箱地址替换`gpg-recipients`）：
- en: '[PRE58]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, whenever you need to edit your secret data, you can simply run the following
    command:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当你需要编辑秘密数据时，可以简单地运行以下命令：
- en: '[PRE59]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To add a new secret, add a line like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 若要添加新的密钥，请添加一行如下所示：
- en: '[PRE60]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: When you save and quit the editor, the newly-encrypted secret will be stored
    in the data file.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当你保存并退出编辑器时，新的加密秘密将被存储在数据文件中。
- en: Distributing the decryption key
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分发解密密钥
- en: 'Now that your Puppet manifests use encrypted Hiera data, you''ll need to make
    sure that each node running Puppet has a copy of the decryption key. Export the
    key to a text file using the following command (use your key''s email address,
    of course):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的Puppet清单使用了加密的Hiera数据，你需要确保每个运行Puppet的节点都拥有解密密钥的副本。使用以下命令将密钥导出到文本文件中（当然，使用你的密钥邮箱地址）：
- en: '[PRE61]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Copy the `key.txt` file to any nodes which need the key, and run the following
    command to import it:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 将`key.txt`文件复制到需要密钥的节点，并运行以下命令导入密钥：
- en: '[PRE62]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Make sure that you delete all copies of the text file once you have imported
    the key.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在导入密钥后删除所有文本文件的副本。
- en: Note
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Important note**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: Because all Puppet nodes have a copy of the decryption key, this method only
    protects your secret data from someone who does not have access to the nodes.
    It is still considerably better than putting secret data in your manifests in
    plaintext, but it has the disadvantage that someone with access to a node can
    decrypt, modify, and re-encrypt the secret data. For improved security you should
    use a secrets management system where the node does not have the key, and Puppet
    has read-only access to secrets. Some options here include Vault, from Hashicorp,
    and Summon, from Conjur.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有Puppet节点都有解密密钥的副本，因此此方法只保护你的秘密数据不被没有访问节点权限的人获取。它仍然比将秘密数据以明文形式放入清单中要好得多，但它的缺点是，如果有人能够访问某个节点，他就可以解密、修改并重新加密秘密数据。为了提高安全性，你应该使用一个秘密管理系统，在该系统中节点没有密钥，而Puppet只能以只读方式访问秘密。一些可选的系统包括Hashicorp的Vault和Conjur的Summon。
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we've outlined some of the problems with maintaining configuration
    data in Puppet manifests, and introduced Hiera as a powerful solution. We've seen
    how to configure Puppet to use the Hiera data store, and how to query Hiera keys
    in Puppet manifests using `lookup()`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们概述了一些在Puppet清单中维护配置数据的问题，并介绍了Hiera作为一个强大的解决方案。我们已经看到如何配置Puppet使用Hiera数据存储，并且如何在Puppet清单中使用`lookup()`查询Hiera键。
- en: We've looked at how to write Hiera data sources, including string, array, and
    hash data structures, and how to interpolate values into Hiera strings using `lookup()`,
    including Puppet facts and other Hiera data, and how to duplicate Hiera data structures
    using `alias()`. We've learned how Hiera's hierarchy works, and how to configure
    it using the `hiera.yaml` file.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了如何编写Hiera数据源，包括字符串、数组和哈希数据结构，以及如何使用`lookup()`将值插入Hiera字符串，包括Puppet事实和其他Hiera数据，还了解了如何使用`alias()`复制Hiera数据结构。我们已经学习了Hiera的层级结构是如何工作的，以及如何使用`hiera.yaml`文件进行配置。
- en: We've seen how our example Puppet infrastructure is configured to use Hiera
    data, and demonstrated the process by looking up a data value in a Puppet manifest.
    In case of problems, we also looked at some common Hiera errors, and we've discussed
    rules of thumb about when to put data into Hiera.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到我们的示例Puppet基础设施是如何配置使用Hiera数据的，并通过在Puppet清单中查找数据值演示了这个过程。在出现问题时，我们还查看了一些常见的Hiera错误，并讨论了将数据放入Hiera的经验法则。
- en: We've explored using Hiera data to create resources, using an `each` loop over
    an array or hash. Finally, we've covered using encrypted data with Hiera, using
    the `hiera-eyaml-gpg` backend, and we've seen how to create a GnuPG key and use
    it to encrypt a secret value, and retrieve it again via Puppet. We've explored
    the process Hiera uses to find and decrypt secret data, developed a simple script
    to make it easy to edit encrypted data files, and outlined a basic way to distribute
    the decryption key to multiple nodes.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探索了使用 Hiera 数据创建资源的方法，使用 `each` 循环遍历数组或哈希。最后，我们介绍了如何使用加密数据与 Hiera，使用 `hiera-eyaml-gpg`
    后端，并展示了如何创建一个 GnuPG 密钥并用它加密一个秘密值，然后通过 Puppet 再次检索它。我们探讨了 Hiera 查找和解密秘密数据的过程，开发了一个简单的脚本来方便地编辑加密数据文件，并概述了一种将解密密钥分发到多个节点的基本方法。
- en: In the next chapter, we'll look at how to find and use public modules from Puppet
    Forge; how to use public modules to manage software including Apache, MySQL, and
    archive files; how to use the `r10k` tool to deploy and manage third-party modules;
    and how to write and structure your own modules.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何从 Puppet Forge 查找和使用公共模块；如何使用公共模块管理软件，包括 Apache、MySQL 和归档文件；如何使用
    `r10k` 工具部署和管理第三方模块；以及如何编写和构建自己的模块。
