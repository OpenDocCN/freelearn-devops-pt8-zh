- en: Developing Cloud Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发 Cloud Functions
- en: In this chapter, we will deliver an overview of Google Cloud Functions. It will
    provide you with a good understanding of the what, why, and how of Google Cloud
    Functions. Knowing the basis for any technology and its use case will assist with
    integration and application in the real world.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将提供 Google Cloud Functions 的概述。它将帮助您深入了解 Google Cloud Functions 的背景、原因及其工作原理。了解任何技术及其用例的基础将有助于在现实世界中进行集成和应用。
- en: To achieve this outcome, we will again build an application throughout the chapter
    to illustrate some critical aspects of Cloud Functions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一目标，我们将通过本章节构建一个应用程序，以展示 Cloud Functions 的一些关键方面。
- en: 'The topics covered in this chapter include the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题包括以下内容：
- en: Introducing Google Cloud Functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Google Cloud Functions
- en: Developing with the Functions Framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Functions Framework 进行开发
- en: Exploring the Cloud Functions workflow
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Cloud Functions 的工作流程
- en: Understanding the HTTP protocol
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 HTTP 协议
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, to complete the exercises, you will require a Google Cloud
    project or a Qwiklabs account.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，要完成练习，您将需要一个 Google Cloud 项目或一个 Qwiklabs 账户。
- en: You can find the code files of this chapter in the GitHub repository for the
    book under the `ch04` subdirectory at [https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch04](https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch04).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 书籍存储库的`ch04`子目录中找到本章的代码文件，链接为[https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch04](https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch04)。
- en: While you are going through code snippets in the book, you will notice that,
    in a few instances, a few lines from the code/outputs have been removed and replaced
    with ellipses (`...`). The use of ellipses is to show only relevant code/output.
    The complete code is available on GitHub at the preceding link.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当您阅读本书中的代码片段时，您会注意到在一些情况下，代码/输出的几行已被删除并替换为省略号（`...`）。省略号的使用是为了只展示相关的代码/输出。完整的代码可在上述链接的
    GitHub 上找到。
- en: Introducing Google Cloud Functions
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Google Cloud Functions
- en: The description of Cloud Functions on Google Cloud indicates an event-driven
    serverless compute platform. What this means is that functions are triggered either
    by HTTP endpoints or via a background service (for example, Google Cloud Storage
    or Cloud Pub/Sub and other sources within Google Cloud). Operationally, Cloud
    Functions are *single-use* pieces of code that are quick to deploy and provide
    the *glue* between multiple services. The exciting aspect of Cloud Functions is
    that they can be stitched together quite easily in the same way a traditional
    application would be. It is entirely feasible to create a couple of HTTP endpoint
    functions that link through to a Cloud Pub/Sub backend, and by keeping your service
    simple, the build can quickly complete.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cloud 上关于 Cloud Functions 的描述表明，这是一个事件驱动的无服务器计算平台。这意味着函数通过 HTTP 端点或通过后台服务（例如
    Google Cloud Storage 或 Cloud Pub/Sub 以及 Google Cloud 内的其他源）触发。在操作上，Cloud Functions
    是*单次使用*的代码片段，部署迅速，并在多个服务之间提供*粘合*。Cloud Functions 的有趣之处在于，它们可以像传统应用程序一样轻松地进行组合。例如，完全可以创建几个
    HTTP 端点函数，链接到 Cloud Pub/Sub 后端，通过保持服务简单，可以快速完成构建。
- en: While the default setting for functions is public, authentication can be enabled
    for features to secure the environment in which they operate. Cloud Functions
    are executed using a service account and are, therefore, configurable via Google
    Cloud **Identity and Access Management** (**IAM**). It is important to note that
    functions do not share memory space, which means an isolated context for each
    instance executed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然函数的默认设置是公开的，但可以为功能启用身份验证以确保其运行环境的安全性。Cloud Functions 使用服务账号执行，并可通过 Google
    Cloud **身份和访问管理**（**IAM**）进行配置。需要注意的是，函数不共享内存空间，这意味着每个执行实例都处于隔离的上下文中。
- en: Additionally, it is essential to note that functions are stateless in nature;
    they are therefore not expected to persist information within the Cloud Function.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，需要注意的是函数具有无状态性质；因此，不应期望在 Cloud Function 中保留信息。
- en: The exception to this is scenario is something like persisting a database connection
    that should be stored globally in code. Doing this means the next Cloud Function
    invocation doesn't need to introduce any additional latency retrieving the connection
    information.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个场景的例外情况是像持久化数据库连接这样的操作，这些连接应该在代码中全局存储。这样做意味着下次调用云函数时，不需要引入额外的延迟来获取连接信息。
- en: 'Further to this, the following properties are central to the DNA of Cloud Functions:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下属性是云函数DNA的核心：
- en: They operate in a secure operation context.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们在安全的操作环境中运行。
- en: They don't share memory across functions.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们在函数之间不共享内存。
- en: No state is maintained.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有状态保持。
- en: Working with Cloud Functions provides an excellent way to execute single-purpose
    Cloud Functions without needing to spend a lifetime coding an application. Further
    use cases exist and are denoted in the following section.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用云函数提供了一种极好的方式来执行单一目的的云函数，而无需耗费大量时间编写应用程序代码。更多的使用场景将在以下部分中介绍。
- en: Defining the use cases
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义使用场景
- en: As developers have become more exposed to cloud infrastructure, an exciting
    outcome is the evolution of lightweight functions. Consider the applications you
    use daily and how they have matured over time. How many of these now feature an
    HTTP endpoint that can be used independently from the application? What would
    happen if everything became an API; how cool would that be? Situations such as
    these are analogous to the processing of logs in which records were held internally
    in a proprietary format. Then someone had the bright idea to export application
    data to a centralized solution to capture information. A tipping point occurred,
    and we all adopted this typical pattern as the de-facto mechanism for the management
    of logging.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 随着开发人员对云基础设施的了解加深，一个令人兴奋的结果是轻量级函数的演变。想想你每天使用的应用程序，它们是如何随着时间的推移而发展的。现在有多少个应用程序带有可以独立于应用程序使用的HTTP端点？如果一切都变成API，那会怎样？这就像日志处理的情况，记录曾经以专有格式保存在内部。后来有人想到将应用程序数据导出到集中式解决方案来捕获信息。出现了一个转折点，我们都接受了这个典型的模式，成为了日志管理的事实标准。
- en: Back to Cloud Functions – consider how much more convenient it is to develop
    an application when you have standard solutions and patterns that can easily integrate
    with your resolution. Also, consider the level of design required upfront to ensure
    that an application retains a degree of compatibility. Working with a protocol
    such as HTTP provides a very well-understood interface that is recognized by a
    wide range of people. Having a typical frame of reference provides an excellent
    method of moving the industry forward, and HTTP provides just the vehicle for
    adoption and propagation of the development of abstracted interfaces. So, we'll
    reflect on the types of use cases that Cloud Functions are most appropriate for
    over the next couple of sections.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 回到云函数—考虑一下，当你拥有可以轻松集成的标准解决方案和模式时，开发一个应用程序会变得多么方便。同时，考虑一下为了确保应用程序保持一定的兼容性，前期需要设计多少内容。使用像HTTP这样的协议提供了一个广泛被认可的、易于理解的接口。拥有一个典型的参考框架为推动行业发展提供了极好的方法，而HTTP恰恰是推动抽象接口开发的载体。因此，在接下来的几节中，我们将讨论云函数最适合的使用场景。
- en: Processing with backend services
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理后端服务
- en: Backend serverless compute is triggered by services such as Cloud Pub/Sub and
    Cloud Storage. The scope of these services is made more interesting by the prospect
    of being able to integrate different Google Cloud services with your Cloud Functions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 后端无服务器计算由像Cloud Pub/Sub和Cloud Storage这样的服务触发。这些服务的范围因能够将不同的Google Cloud服务与云函数集成而变得更加有趣。
- en: We already know that we can use Cloud Functions for many scenarios. As outlined
    previously in the use case introduction, serverless backend processing is an excellent
    use case for this solution. In this situation, the Cloud Function design addresses
    a request to provide specific information. This request presents a particular
    signature of the service that encapsulates the information necessary to complete
    processing some arbitrary data. At the outset of this processing, the function
    responds to indicate it has completed the assigned activity. The response can
    note success or failure; however, in terms of the service, its life cycle is complete,
    and it will fade out of existence.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道可以在许多场景中使用 Cloud Functions。如前文的用例介绍所述，无服务器后端处理是这个解决方案的一个优秀应用场景。在这种情况下，Cloud
    Function 的设计旨在处理请求并提供特定信息。此请求展示了服务的特定签名，封装了完成处理一些任意数据所需的信息。在处理开始时，函数会响应并指示其已完成分配的任务。响应可以标明成功或失败；然而，就服务而言，它的生命周期已经结束，且将不再存在。
- en: Processing with real-time data
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理实时数据
- en: Another scenario that sits well with serverless compute is that of real-time
    data processing. In this situation, Cloud Functions' on-demand provisioning enables
    them to meet processing requirements for a service designed against minimal latency.
    As we discussed earlier in the book, it may be useful to understand several attributes
    before the development of a solution. The ability to quickly provision infrastructure
    in a short amount of time is a significant factor for solutions requiring real-time
    processing. Cloud Functions support a startup time of less than 2.5 seconds for
    memory allocations of less than 1,024 MB and this can be highly beneficial where
    an application requires immediate processing. As many systems move from batch
    to near real-time processing, the adoption of these types of capabilities will
    become more prevalent. Accordingly, it is therefore increasingly important to
    understand how to adapt and incorporate these patterns in the services designed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常适合无服务器计算的场景是实时数据处理。在这种情况下，Cloud Functions 的按需提供能力使其能够满足设计要求较低延迟的服务的处理需求。正如我们在本书前面所讨论的，理解几个关键属性可能对开发解决方案非常有帮助。能够在短时间内快速提供基础设施是需要实时处理的解决方案中的一个重要因素。Cloud
    Functions 支持在内存分配小于 1,024 MB 的情况下启动时间少于 2.5 秒，这在需要立即处理的应用程序中尤为有益。随着许多系统从批处理转向近实时处理，采用这些能力的情况将变得越来越普遍。因此，理解如何在设计的服务中适应并结合这些模式变得越来越重要。
- en: Beyond the example scenarios laid out in the preceding section, many other use
    cases exist. Working with Cloud Functions minimizes the work needed to integrate
    your code and removes the obligation to provide the associated infrastructure.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面章节中提到的示例场景外，还有许多其他的用例。使用 Cloud Functions 可以最大限度地减少集成代码所需的工作，并且消除了提供相关基础设施的义务。
- en: To use Cloud Functions requires very little in the way of additional knowledge
    of the backend architecture. In truth, as long as you are comfortable in one of
    the language runtimes, you can be up and running very quickly. Having said that,
    we should take the time to explain what is happening in the background and how
    you can go about extending this to meet your needs.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Cloud Functions 几乎不需要额外了解后端架构。事实上，只要你熟悉某种语言运行时环境，就可以非常快速地开始使用。尽管如此，我们仍然应该花时间解释一下后台发生了什么，以及如何扩展这些功能以满足你的需求。
- en: In the next section, we move on to cover the Functions Framework. One thing
    Google Cloud is keen to ensure is that developers get an excellent experience.
    To achieve this typically means allowing them to work in their existing environment.
    So how about being able to work locally but being still able to deploy code to
    a cloud environment?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将继续讨论函数框架。Google Cloud 极力确保开发者能够获得优秀的体验。实现这一目标通常意味着允许开发者在他们现有的环境中工作。那么，如何在本地工作同时又能够将代码部署到云环境中呢？
- en: Developing with the Functions Framework
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数框架进行开发
- en: At this point, please take a moment to consider the benefit of the Functions
    Framework we have been discussing – the various options available on Google Cloud,
    meaning we can run code in different environments. As a platform that prides itself
    as being developer-centric, allowing engineers to pick up and use their code in
    different contexts is highly advantageous.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，请花点时间考虑我们一直在讨论的 Functions Framework 的好处——Google Cloud 上的各种选项，意味着我们可以在不同的环境中运行代码。作为一个以开发者为中心的平台，允许工程师在不同的上下文中使用他们的代码是非常有利的。
- en: Introducing the Functions Framework
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Functions Framework
- en: The Functions Framework is an open source project that enables you to build
    your functions in multiple environments, for example, locally. As with any magic
    trick, the beauty is not understanding the mechanics of the illusion, but with
    how it makes you feel. In this instance, let's pull back the curtains to see how
    this particular trick is done and also what it means in terms of Cloud Functions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Functions Framework 是一个开源项目，可以让您在多种环境中构建函数，例如本地环境。就像任何魔术一样，美丽之处不在于理解幻觉的机制，而是它让你感受到的方式。在这个例子中，让我们拉开帷幕看看这个特定魔术是如何完成的，以及在
    Cloud Functions 方面意味着什么。
- en: So why do we need something like this? Well, working in a local, often highly
    customized environment provides a friendly comfort zone for developers. The context
    you are working in will be familiar, and the tools, locations, and access can
    all easily be checked and validated. There is an inherent comfort associated with
    working in this way. Moving to the cloud removes some of those psychological comforts
    from the user.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么我们需要类似这样的东西呢？嗯，在本地工作，通常是高度定制化的环境，为开发者提供了友好的舒适区。您工作的上下文将会是熟悉的，并且工具、位置和访问都可以轻松检查和验证。在这种方式下工作具有固有的舒适感。转向云端会从用户那里移除一些心理上的舒适感。
- en: 'Having the ability to work locally, despite being counter to the end objective
    of running code in the cloud, is something folks want to do. Being able to work
    across a variety of environments using Cloud Functions leads us to the Functions
    Framework. The framework is a lightweight dependency that allows developers to
    run simple interfaces in a range of settings, such as the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管与在云中运行代码的最终目标相悖，但具备在本地工作的能力是开发人员想要做的事情。能够使用 Cloud Functions 在多种环境中工作将我们带到了
    Functions Framework。这个框架是一个轻量级的依赖项，允许开发人员在一系列设置中运行简单的接口，例如以下设置：
- en: Cloud Functions
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云函数
- en: Local development
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地开发
- en: Cloud Run and Cloud Run for Anthos
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cloud Run 和 Cloud Run for Anthos
- en: Knative environments
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Knative 环境
- en: Building on the **Functions as a Service** (**FaaS**) platform for Google Cloud,
    the availability of this framework provides a simple mechanism to achieve portability
    across multiple environments. To incorporate the code is as simple as adding the
    relevant package to your project. In the next section, we will walk through a
    simple example to demonstrate its usage in a project. In the following case, we
    create a basic Node application to process some web-based information.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 建立在**函数即服务**（**FaaS**）平台上为 Google Cloud，此框架的可用性提供了跨多个环境实现可移植性的简单机制。要将代码整合到项目中，只需添加相关的包。在接下来的部分，我们将通过一个简单的示例来演示其在项目中的使用。在下面的案例中，我们创建一个基本的
    Node 应用程序来处理一些基于 web 的信息。
- en: Deploying an application locally with the Functions Framework
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地部署应用程序使用 Functions Framework
- en: 'Most developers prefer the local experience of working within a development
    environment. The Functions Framework provides Cloud Functions developers with
    the ability to continue to use this local work environment and propagate their
    code to the cloud in a seamless manner:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发人员更喜欢在开发环境中工作的本地体验。Functions Framework 为 Cloud Functions 开发人员提供了在本地工作环境中继续使用这种能力，并无缝地将其代码传播到云端的能力：
- en: First, create a directory for the example code to be built and initialize the
    environment. In my example, I have created a directory named `functions-framework`
    and will be using this to develop my code.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，为要构建的示例代码创建一个目录并初始化环境。在我的示例中，我创建了一个名为`functions-framework`的目录，并将其用于开发我的代码。
- en: It is important to note that in my local environment I am using Node v10+, as
    this is a requirement to use the Functions Framework. Also, I have npm v6.9.0
    installed on my testing machine.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，在我的本地环境中，我正在使用 Node v10+，这是使用 Functions Framework 的要求。此外，我在测试机上安装了 npm
    v6.9.0。
- en: 'To check the Node version on your environment, run the command:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查您环境中的 Node 版本，请运行以下命令：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Using an editor, create a file named `index.js` and add the following content
    to it:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用编辑器创建一个名为`index.js`的文件，并添加以下内容：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To create a template `package.json` file, run `npm init` from the command line.
    Edit the content as necessary:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个模板`package.json`文件，从命令行运行`npm init`。根据需要编辑内容：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see from the above code extract, I have the bare minimum added to
    my file.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如上面的代码片段所示，我已经在我的文件中添加了最基本的内容。
- en: 'Next, install the `functions-framework` package. My assumption here is that
    this is not already present on your local machine. To install this package, you
    will use `npm` to get the necessary package information:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，安装`functions-framework`包。我假设这个包尚未安装在你的本地机器上。要安装此包，你将使用`npm`来获取必要的包信息：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once this command has been completed, you will see that the `package.json`
    file has been updated to include reference to the Function Framework under the
    `dependencies` category, as follows:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此命令后，你会看到`package.json`文件已经更新，包含对Functions Framework的引用，位于`dependencies`类别下，如下所示：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now our environment is ready to build functions, so let's make a really simple
    application to test our environment.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的环境已经准备好构建函数了，接下来让我们创建一个非常简单的应用程序来测试我们的环境。
- en: 'With our new code, we need to tell the application to run a script when the
    application is run. In the existing `package.json`, add the following reference
    to the code to call the Functions Framework and pass a `target` function:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过我们新的代码，我们需要告诉应用程序在运行时执行一个脚本。在现有的`package.json`中，添加以下代码来调用Functions Framework并传递一个`target`函数：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Great job; we now have our `index.js` and `package.json` ready to use the Functions
    Framework.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 做得好；现在我们已经准备好使用Functions Framework的`index.js`和`package.json`文件。
- en: Run the application locally using the standard calling method `npm start` from
    the command line.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用标准的调用方法从命令行运行应用程序`npm start`，本地运行应用程序。
- en: 'Note that, in our example environment, the running application is bound to
    port `8080` over the HTTP protocol. Open your browser and access this URL, `http://localhost:8080`,
    to see the output from your application as shown in the following screenshot:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，在我们的示例环境中，运行的应用程序绑定到HTTP协议上的端口`8080`。打开浏览器并访问此URL `http://localhost:8080`，以查看应用程序的输出，截图如下所示：
- en: '![](img/1d5b8844-041a-4d42-aeb7-49a8ae0e0417.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d5b8844-041a-4d42-aeb7-49a8ae0e0417.png)'
- en: Building code to run locally on a development machine is trivial using this
    framework. However, how would this scenario differ if we wanted to deploy to the
    cloud? In the next section, we look at how to deploy code to the cloud.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个框架，在开发机器上运行本地代码是微不足道的。然而，如果我们想要部署到云端，这种场景会有什么不同呢？在下一节中，我们将探讨如何将代码部署到云端。
- en: Deploying an application to the cloud with the Functions Framework
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Functions Framework将应用程序部署到云端
- en: When migrating our local application to a cloud environment, surprisingly, there
    is little that we need to do in terms of preparation. In this example, I will
    assume you have already installed and initialized the Google Cloud SDK to enable
    you to connect and provision resources on Google Cloud.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当将本地应用程序迁移到云环境时，令人惊讶的是，在准备工作方面，我们需要做的事情很少。在这个例子中，我假设你已经安装并初始化了Google Cloud SDK，以便你能够连接和配置Google
    Cloud上的资源。
- en: 'For the sake of clarity, I will create another function that says something
    slightly different; however, you can use the same Cloud Function defined in the
    code created previously:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清晰地说明，我将创建另一个说法稍有不同的函数；不过，你可以使用之前代码中定义的相同云函数：
- en: In the `index.js` file, create a second function named `helloWorldCloud`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`index.js`文件中，创建一个名为`helloWorldCloud`的第二个函数。
- en: 'Give this new function the attributes as defined previously; however, we will
    use a different message to illustrate that a different function is called:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给这个新函数赋予之前定义的属性；不过，我们将使用不同的信息来说明调用的是不同的函数：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Save the new content for the application and test to ensure it continues to
    work as per the previous run.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存新应用程序的内容并进行测试，确保它像上次运行时一样正常工作。
- en: Run `npm start` from the command line. Remember, the only thing we have changed
    in this iteration is the code base.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行运行`npm start`。记住，我们在这个版本中唯一更改的是代码库。
- en: Running the `npm start` command allows us to browse to `localhost:8080` and
    see the message from our application.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`npm start`命令后，我们可以浏览到`localhost:8080`并看到来自我们应用程序的信息。
- en: '![](img/430a00ce-56fb-4e0f-a933-d5abc49b098c.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/430a00ce-56fb-4e0f-a933-d5abc49b098c.png)'
- en: 'Now we want to run our code base in the Cloud by deploying the Cloud Function.
    For this instance, we rely on the Cloud SDK to get our code running in a Google
    Cloud project. Run the following command:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们希望通过部署云函数在云端运行我们的代码库。在这个实例中，我们依赖Cloud SDK将我们的代码运行在Google Cloud项目中。运行以下命令：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To confirm that the information created from the source uploaded successfully,
    take a look at the running Cloud Function source code. Here, we can see it includes
    the same source code that has been archived and uploaded to Google Cloud. However
    the resulting display is showing the message specifically relating to our new
    function.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确认上传的源信息是否成功创建，请查看正在运行的云函数源代码。这里，我们可以看到它包含了与上传到Google Cloud的已归档源代码相同的内容。然而，显示结果中显示的是与我们新函数相关的消息。
- en: '![](img/1cd48c72-8399-4654-9c2d-55a2a12b9f18.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1cd48c72-8399-4654-9c2d-55a2a12b9f18.png)'
- en: At this point, we now know how to deploy code to our local environment and also
    to a Google Cloud project using Cloud Functions. But what exactly are Cloud Functions
    for and what can it do? In the next section, we go into some further details on
    the relative benefits and use cases for this service.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了如何将代码部署到本地环境，并使用云函数将其部署到Google Cloud项目中。但云函数究竟是做什么的，它能做什么呢？在下一节中，我们将进一步探讨该服务的相关好处和使用场景。
- en: Exploring the Cloud Functions workflow
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索云函数工作流
- en: So, it seems like Cloud Functions are pretty useful, and together with the Functions
    Framework, it would appear to be a match made in heaven. Besides, the overall
    approach seems very extensible, and working with other products and services within
    Google Cloud seems greatly simplified. So, if you are already in *team Google
    Cloud*, using Cloud Functions is a no-brainer.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，看来云函数非常有用，并且与函数框架结合使用时，似乎是一对天作之合。而且，这种整体方法看起来非常具有扩展性，与Google Cloud内的其他产品和服务协作也变得大大简化。所以，如果你已经在*Google
    Cloud团队*中，使用云函数显然是个明智的选择。
- en: For those of you who are not in *team Google Cloud* or may be sitting on the
    fence, there is more to this story. Serverless is a general term that has taken
    some critical feedback over the years. For most folks, serverless relates to the
    lack of requirement-driven infrastructure management when deploying code. For
    others, it means, services being available immediately and being capable of achieving
    sizing appropriate to the needs of the application used, with the ability to self-heal.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不在*Google Cloud团队*或可能持观望态度的朋友，这背后还有更多的故事。无服务器（Serverless）是一个通用术语，多年来曾受到一些批评。对大多数人来说，无服务器意味着部署代码时无需管理基础设施。对其他人来说，这意味着服务能立即可用，并能够根据应用需求进行合适的调整，并具备自愈能力。
- en: Depending on your perspective, Cloud Functions may or may not meet your needs.
    The main concern that people highlight is the time taken to deploy code. *Why
    isn't the function available immediately?*, *Why is the memory constrained?*,
    and so on – *When I use provider X, the services are available immediately, the
    memory isn't constrained, and they serve tea and cakes for every deployment!*
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的角度，云函数可能满足或不满足你的需求。人们常提到的主要问题是部署代码所花费的时间。*为什么函数不能立即可用？*，*为什么内存受到限制？*，等等——*当我使用供应商X时，服务能立即使用，内存没有限制，而且每次部署时他们还会提供茶水和蛋糕！*
- en: So before we go into the details on Cloud Functions, it feels like a good time
    to bring up what is happening behind the scenes as we deploy our code to the cloud.
    Google has laid out an excellent architecture in terms of mapping out the leading
    products regarding capability for a data processing pipeline. The data life cycle
    is useful from an architecture perspective as it outlines the produce available
    to render specific aspects of your pipeline. In terms of the common topics of
    ingestion, storage, processing, and analytics, this approach provides an exciting
    way to break down the component architecture.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解云函数之前，现在似乎是个不错的时机来讨论一下在我们将代码部署到云端时，幕后发生了什么。Google为数据处理管道的关键产品绘制了一张出色的架构图。数据生命周期从架构的角度来看非常有用，它概述了能够呈现管道中特定方面的产品。就数据摄取、存储、处理和分析这些常见主题而言，这种方法提供了一种令人兴奋的方式来分解组件架构。
- en: So how do you create a function? Let's examine this in the next section.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何创建一个函数呢？让我们在下一节中详细探讨。
- en: Cloud Function properties
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云函数属性
- en: As discussed earlier, Cloud Functions provides support for several runtimes
    on Google Cloud, including Node.js, Python, Go, Java, and Ruby. Getting started
    with Cloud Functions is as easy as accessing the Google Cloud console and selecting
    the most appropriate runtime. Each runtime includes template code that presents
    the blueprint for a primary Cloud Function plus all the ancillary system code
    necessary to get an example up and running in no time.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Cloud Functions 支持 Google Cloud 上的多种运行时，包括 Node.js、Python、Go、Java 和 Ruby。开始使用
    Cloud Functions 如同访问 Google Cloud 控制台并选择最合适的运行时一样简单。每个运行时都包括模板代码，提供了一个主要 Cloud
    Function 的蓝图以及运行该示例所需的所有辅助系统代码。
- en: A key consideration for code is how much time an algorithm will take to process
    and how much this matters. For example, if the algorithm is part of the UX, then
    any delay in processing will likely be noticeable to the end user. Asynchronous
    code permits long-lived processing actions to be offloaded from the main thread
    and executed in the background. Taking this action is key to maintaining performance
    across the application space as it provides the ability to delineate between resources
    requiring fast or slow responses.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的一个关键考虑因素是算法处理所需的时间以及这一点有多重要。例如，如果算法是用户体验的一部分，那么任何处理延迟都可能会被最终用户察觉。异步代码允许将长期的处理操作从主线程中卸载并在后台执行。采取此行动对于保持整个应用程序性能至关重要，因为它提供了在需要快速响应和缓慢响应的资源之间进行区分的能力。
- en: Besides, as you are now aware, functions are generally stateless applications
    that should not persist any information. As a general rule, this means that the
    service utilizes a short life-cycle in which data processes and the task comes
    to an end. To minimize potential latency reduce long-lived request and response
    cycles, by using asynchronous calls within code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如你现在所知道的，函数通常是无状态的应用程序，不应持久化任何信息。作为一般规则，这意味着该服务采用一个短生命周期，其中数据处理和任务完成。在代码中使用异步调用来减少长期的请求和响应周期，能够减少潜在的延迟。
- en: For stateful applications, the need to maintain information presents an issue
    in terms of the potential latency associated with the persistence of data. It
    should be clear that anything requiring the read/write cycle outside of memory
    will introduce some level of delay. Trying to minimize this delay presents an
    interesting design problem that ultimately depends on what you want to give up
    and to what degree you want to move away from the performance, loose coupling,
    data design, and so on.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有状态的应用程序，维护信息的需求在数据持久化相关的潜在延迟方面提出了问题。应该清楚，任何需要读/写周期的操作，如果不在内存中，将会引入一定的延迟。尽量减少这种延迟提出了一个有趣的设计问题，最终取决于你愿意放弃什么，以及你希望在性能、松耦合、数据设计等方面走多远。
- en: 'To call a function, the event notification mechanism on Google Cloud is a trigger.
    The trigger is an important consideration when starting out developing a Cloud
    Function. Design of a function does require some thought to determine what pieces
    are needed to deliver a suitable model. As an event-driven architecture, there
    are some options available, as indicated in the following table:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用函数，Google Cloud 上的事件通知机制是触发器。触发器是开始开发 Cloud Function 时需要考虑的重要因素。函数设计确实需要一些思考，以确定需要哪些组件来交付一个合适的模型。作为事件驱动架构，提供了一些可用的选项，如下表所示：
- en: '| **Trigger** | **Event** | **Destination** |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| **触发器** | **事件** | **目标** |'
- en: '| HTTP | HTTP | URL |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| HTTP | HTTP | URL |'
- en: '| Cloud Pub/Sub | Topic |  |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| Cloud Pub/Sub | 主题 |  |'
- en: '| Cloud Storage |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| Cloud 存储 |'
- en: Finalize/create
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成/创建
- en: Delete
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除
- en: Archive
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存档
- en: Metadata
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元数据
- en: '| Bucket |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 存储桶 |'
- en: '| Cloud Firestore |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| Cloud Firestore |'
- en: Write
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入
- en: Create
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建
- en: Update
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新
- en: Delete
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除
- en: '|  |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| Google Analytics for Firebase | Log | Log Event Name |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| Google Analytics for Firebase | 日志 | 日志事件名称 |'
- en: '| Firebase Authentication |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| Firebase 身份验证 |'
- en: Create
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建
- en: Delete
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除
- en: '|  |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| Firebase Realtime Database |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| Firebase 实时数据库 |'
- en: Write
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入
- en: Create
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建
- en: Update
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新
- en: Delete
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除
- en: '| Database |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 数据库 |'
- en: '| Firebase Remote Config | `remoteconfig.update` |  |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| Firebase 远程配置 | `remoteconfig.update` |  |'
- en: In addition to the runtime, there are also additional properties included when
    commencing creating a Cloud Function. Memory allocation is an essential consideration
    as the expectation is that the processing performed exists in-memory. Cloud Functions
    provide memory allocation from 128 KB to 2 GB that can be adjusted by the developer
    based on the requirement of the application developed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 除了运行时之外，在创建Cloud Function时还包括其他一些属性。内存分配是一个重要的考虑因素，因为预期的处理是在内存中进行的。Cloud Functions提供从128
    KB到2 GB的内存分配，开发者可以根据应用程序的需求进行调整。
- en: Before moving onto the more general options, it's worth having a brief overview
    of authentication and how this relates to Cloud Functions.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入更一般的选项之前，值得简要了解身份验证及其与Cloud Functions的关系。
- en: Authentication
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证
- en: The default authentication for Cloud Functions represents public access; that
    is, it can be accessed by anyone, anywhere. From the Cloud Functions configuration
    screen, select Allow unauthenticated invocations to create a publically exposed
    endpoint. The `allUsers` IAM setting provides public access assignment to the
    service account associated with the Cloud Function. An invocation of a function
    relies on the association of a service account. A service account is a particular
    account used for non-interactive access, as in the entrance is for another computer
    rather than a human. The user account is assigned role permission, and this is
    bound to the service. By default, Cloud Functions binds an `allUser` permission,
    but alterations before and after the creation of a function are possible.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Functions的默认身份验证代表公共访问；也就是说，任何人都可以访问。从Cloud Functions的配置屏幕中，选择允许未经身份验证的调用以创建一个公开暴露的端点。`allUsers`的IAM设置为与Cloud
    Function相关联的服务账户提供公共访问权限。函数的调用依赖于服务账户的关联。服务账户是一个用于非交互式访问的特定账户，就像入口是为另一台计算机而不是人类设计的。用户账户被分配角色权限，并绑定到服务上。默认情况下，Cloud
    Functions绑定了`allUser`权限，但在函数创建之前或之后可以进行更改。
- en: Note that the initial function designation allows adjustment through IAM settings.
    This approach brings Cloud Functions into line with other services on Google Cloud.
    Later in this book, Cloud Functions security will be discussed, and it will cover
    the configuration of service accounts concerning Cloud Functions to limit privilege.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，初始的功能指定允许通过IAM设置进行调整。这种方法使Cloud Functions与Google Cloud上的其他服务保持一致。本书后续将讨论Cloud
    Functions的安全性，并涉及与Cloud Functions相关的服务账户配置，以限制权限。
- en: For now, let's move on to the options available regarding accessing the source
    versions for a function.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论有关访问函数源版本的选项。
- en: Source control
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码管理
- en: 'Working with source code presents many challenges. Thankfully, Cloud Functions
    provides several options to integrate source code. The Cloud Functions source
    code can be accessed from the sources such as those outlined here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用源代码时会面临许多挑战。幸运的是，Cloud Functions提供了几种集成源代码的选项。可以通过以下来源访问Cloud Functions的源代码：
- en: '**Inline editor**: Create and amend the function code in the Google Cloud Console.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内联编辑器**：在Google Cloud控制台中创建和修改函数代码。'
- en: '**ZIP upload**: Upload a local ZIP file to an intermediary staging Cloud Storage
    bucket.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ZIP上传**：将本地ZIP文件上传到中介的Cloud Storage存储桶。'
- en: '**ZIP from Cloud Storage**: Use an existing ZIP file located in a Cloud Storage
    bucket.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**来自Cloud Storage的ZIP**：使用位于Cloud Storage存储桶中的现有ZIP文件。'
- en: '**Cloud Source repository**: Use source version control.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cloud Source 仓库**：使用源代码版本控制。'
- en: For a quick bout of development, the inline editor can be quite useful; however,
    it will probably make more sense to use one of the many other options when writing
    more intricate code. In most instances, you can continue to use your favorite
    editor and upload code with whichever method meets your needs.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于快速开发，内联编辑器非常有用；然而，在编写更复杂的代码时，使用其他多种选项可能更有意义。在大多数情况下，您可以继续使用自己喜欢的编辑器，并通过符合需求的任何方法上传代码。
- en: Knowing how to upload source code takes us nicely onto the next topic, that
    is, selecting a language runtime.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何上传源代码之后，我们可以顺利进入下一个话题，即选择语言运行时。
- en: Working with different runtime languages
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用不同的运行时语言
- en: Throughout the next few paragraphs, we will outline the baseline functions using
    Node, Python, and Go, and discuss the high-level differences between the various
    runtime languages.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几段中，我们将概述使用Node、Python和Go的基本函数，并讨论各种运行时语言之间的高层次差异。
- en: Node.js
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js
- en: Our discussion begins with Node.js (v10). In this template code, we can see
    that the actual function consists of a couple of lines of code. In terms of Node.js,
    the exact flavor is Express.js. Express.js is a concise framework that works in
    conjunction with Node.js to enhance functionality through additions such as routing
    middleware and HTML rendering.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的讨论从 Node.js（v10）开始。在这个模板代码中，我们可以看到实际的函数由几行代码组成。就 Node.js 而言，使用的具体框架是 Express.js。Express.js
    是一个简洁的框架，与 Node.js 配合使用，通过增加如路由中间件和 HTML 渲染等功能来增强其功能。
- en: Looking at the following example code, we can see a function definition based
    on `exports.helloWorld`. The `exports` keyword indicates the function executes
    (that is, exposed as a callable function) once deployed. Note also that the service
    to be exported takes two parameters mapped to the HTTP request and response values.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例代码中，我们可以看到一个基于 `exports.helloWorld` 的函数定义。`exports` 关键字表示该函数会在部署后执行（即，作为可调用函数暴露）。还要注意，待导出的服务需要两个参数，分别映射到
    HTTP 请求和响应的值。
- en: 'The default Google Cloud Function written in Node.js is illustrated as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 Google Cloud Function（用 Node.js 编写）如下所示：
- en: '[PRE8]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The body of the function examines the request made to determine the addition
    of a query message or message body.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 函数体检查所做的请求，以确定是否添加了查询消息或消息体。
- en: Reviewing the Express.js documentation tells us a bit more about the access
    requirement for the message assignment statement. For a GET message, we understand
    that a query can pass additional data to the function.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅 Express.js 文档让我们了解更多关于消息赋值语句的访问要求。对于 GET 消息，我们了解到查询可以将附加数据传递给函数。
- en: If not, the default message of `Hello World` will be returned in the message
    variable. Next, `res.status` is set to the value of 200 and the message variable
    added to the response. Remember from the previous discussion on HTTP response
    codes that a 200 represents a successful transaction.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，则会返回默认的 `Hello World` 消息到消息变量。接下来，`res.status` 被设置为 200 的值，并将消息变量添加到响应中。记得在前面讨论的
    HTTP 响应码中，200 表示交易成功。
- en: Python
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python
- en: The current revision of Python supported on Google Cloud is version 3.7\. From
    the example code, what we do not see is that the Flask package handles HTTP communication.
    At first glance, there is undoubtedly a lot more code present than in the example
    for Node.js.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 目前在 Google Cloud 上支持的 Python 版本是 3.7。从示例代码中我们看不到的是 Flask 包处理了 HTTP 通信。一眼看上去，Node.js
    示例中显然包含了比这更多的代码。
- en: 'To start, we define our function and can see an immediate difference in the
    naming convention. In Python, we have named our service `hello_world`, which is
    different from the sample Node.js template. Feel free to change the name to be
    consistent, but it does not ultimately matter. Ensure you use the correct name
    for the function to execute, as this can be a frustrating error to fix:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义我们的函数，并且可以看到命名约定的一个明显不同之处。在 Python 中，我们将服务命名为 `hello_world`，这与 Node.js
    示例中的命名不同。你可以自由更改名称以保持一致，但这并不影响最终结果。确保你使用正确的函数名称执行，因为这是一个可能很难修复的错误：
- en: '[PRE9]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the body of the function, we can see a call to return a JSON object. Similar
    to the Node.js Cloud Function, we check the argument for the message to indicate
    if we are to override the default message. To cover the bases, we again ensure
    this example works for both GET and POST messages. Finally, if the user has not
    added a message in the required format, we return the default message of `Hello
    World!`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们可以看到调用返回一个 JSON 对象。类似于 Node.js Cloud Function，我们检查传递的消息参数，看看是否要覆盖默认消息。为了确保兼容性，我们再次确保这个示例适用于
    GET 和 POST 消息。最后，如果用户没有按要求格式添加消息，我们将返回默认的 `Hello World!` 消息。
- en: Go
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go
- en: Go is currently supported on Google Cloud for version 1.11+. As you would expect,
    the revision compatibility is maintained as each version is released, so the recommendation
    is to maintain compatibility with newer versions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Go 目前在 Google Cloud 上支持版本 1.11 及以上。如你所料，每个版本发布时都会保持修订的兼容性，因此建议保持与新版本的兼容性。
- en: In the following example code, we import some packages to enable our application
    to perform the necessary access to HTTP and JSON. The function signature remains
    the same with request and response arguments, both used as an entry point to the
    function.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例代码中，我们导入了一些包，以使我们的应用程序能够执行必要的 HTTP 和 JSON 访问。函数签名保持不变，使用请求和响应参数，作为函数的入口。
- en: 'For the body of the function, our code will default to a standard message if
    the program does not provide one:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于函数体，如果程序未提供信息，我们的代码将默认显示标准消息：
- en: '[PRE10]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Working with Cloud Functions, we see that irrespective of the runtime language
    chosen, many of the properties are shared nonetheless. In terms of languages,
    we also observed the different forms of example code used for Node, Python, and
    Go.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Cloud Functions，我们看到，无论选择哪种运行时语言，许多属性仍然是共享的。在语言方面，我们还观察了用于Node、Python和Go的不同形式的示例代码。
- en: In terms of coding our functions, looking for design patterns will help us to
    avoid reinventing the wheel. We know a bit more about the available language runtimes
    and have seen an example of the boilerplate code associated with each one. To
    test the function, we would need a triggering event, and, in the next section,
    we will discuss an approach to this situation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写我们的函数时，寻找设计模式将帮助我们避免重复造轮子。我们了解了更多关于可用语言运行时的信息，并看到了与每个运行时相关的样板代码示例。要测试该函数，我们需要一个触发事件，在下一节中，我们将讨论这种情况的处理方法。
- en: Testing the runtime triggering event
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试运行时触发事件
- en: 'To test the function, we can craft some data with which to confirm the success
    criteria of our service. Again, Cloud Functions can assist with this task by allowing
    the entry of JSON data to be passed directly to the function at runtime in the
    testing window:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试函数，我们可以创建一些数据来确认我们服务的成功标准。同样，Cloud Functions 可以通过允许在测试窗口中直接传递JSON数据给函数来帮助完成这项任务：
- en: 'A typical URL for a cloud function will resemble syntax of the following link.
    Hitting the endpoint will access the default information associated with the Cloud
    Function:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 云函数的典型URL将类似于以下链接的语法。访问端点将访问与Cloud Function关联的默认信息：
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For the template code, we can supplant a new message by adding some additional
    information to the URL, as follows:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于模板代码，我们可以通过添加一些额外信息到URL来替换新消息，具体如下：
- en: '[PRE12]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, the `req.query` property returns an object with information,
    in this case, a message to be displayed in place of the default `Hello World!`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`req.query`属性返回一个包含信息的对象，本例中是要显示的消息，代替默认的`Hello World!`。
- en: 'If you go ahead and run this function without entering any additional parameters,
    a message of `Hello World` will be displayed and a response code of `200` generated.
    Triggering the event in this way is similar to accessing the function URL directly,
    in that no additional information will be incorporated into the query:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您继续执行此函数而不输入任何额外的参数，则将显示`Hello World`消息，并生成`200`响应代码。通过这种方式触发事件类似于直接访问函数URL，因此不会将任何其他信息合并到查询中：
- en: '| **Message** | **Triggering Event** | **Output** | **Response return code**
    |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| **消息** | **触发事件** | **输出** | **响应返回码** |'
- en: '| 1 | `{}` | `Hello World!` | `200` |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 1 | `{}` | `Hello World!` | `200` |'
- en: Alternatively, by adding some parameters to the triggering event, we can output
    a specific string when running the function.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，通过添加一些参数到触发事件，运行函数时可以输出特定的字符串。
- en: '| **Message** | **Triggering Event** | **Output** | **Response return code**
    |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| **消息** | **触发事件** | **输出** | **响应返回码** |'
- en: '| 2 | `{"message":"Yo Gabba Gabba!"}` | `Yo Gabba Gabba!` | `200` |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 2 | `{"message":"Yo Gabba Gabba!"}` | `Yo Gabba Gabba!` | `200` |'
- en: In the preceding example shown, the triggering event has a JSON string added.
    In this instance, the output to the function changes to display the string entered
    earlier. As before, the return code generated is `200`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中显示的触发事件中添加了一个JSON字符串。在这种情况下，函数的输出将更改以显示之前输入的字符串。与之前一样，生成的返回代码是`200`。
- en: Being able to test an application is fundamental to any developer workflow.
    However, it is just as essential to be able to reference the logs and application-specific
    information for monitoring purposes. To achieve this on Google Cloud, we use Stackdriver.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 能够测试应用程序对任何开发者工作流程都是基本的。然而，同样重要的是能够引用日志和应用程序特定信息以进行监控。在Google Cloud中，我们使用Stackdriver来实现这一点。
- en: Stackdriver
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Stackdriver
- en: 'Each time traffic reaches the endpoint, information relating to the Cloud Function
    will be captured automatically in Stackdriver. If you are not familiar with Stackdriver,
    it is a centralized logging and monitoring system for Google Cloud. We will discuss
    Stackdriver in greater depth later in the book in [Chapter 10](5a03622d-8dae-4385-a141-7b04988f5672.xhtml),
    *Cloud Run Labs*; however, for the time being, it is essential to know that this
    is where to access real-time information for a function. To search for function
    execution, use a filter in Stackdriver, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 每次流量到达终端时，关于云函数的信息会自动在 Stackdriver 中捕获。如果你不熟悉 Stackdriver，它是 Google Cloud 的集中式日志记录和监控系统。我们将在本书的[第
    10 章](5a03622d-8dae-4385-a141-7b04988f5672.xhtml)“*Cloud Run 实验室*”中深入讨论 Stackdriver；然而，当前要知道的是，这里是访问函数实时信息的地方。要搜索函数执行，可以在
    Stackdriver 中使用过滤器，如下所示：
- en: '| **Field** | **Example content** |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| **字段** | **示例内容** |'
- en: '| `resource.type` | `cloud_function` |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `resource.type` | `cloud_function` |'
- en: '| `resource.labels.function_name` | `function-1` |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `resource.labels.function_name` | `function-1` |'
- en: '| `resource.labels.region` | `us-central1` |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `resource.labels.region` | `us-central1` |'
- en: '| `labels.execution_id` | `4ubpvdgz7c8w` |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `labels.execution_id` | `4ubpvdgz7c8w` |'
- en: The determining factor for which runtime language to use will largely depend
    on your personal experience. I have used Node.js throughout this book as it is
    very accessible. The interface is straightforward and efficient and doesn't take
    too much head-scratching to understand the code. Of course, you may have your
    personal favorite, and, hopefully, similar packages are available in those runtime
    languages.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 选择使用哪种运行时语言的决定因素在很大程度上取决于你个人的经验。我在本书中使用了 Node.js，因为它非常易于上手。它的界面简单高效，理解代码不需要太多思考。当然，你可能有自己的最爱，且希望在那些运行时语言中也有类似的包可用。
- en: Working with the boilerplate code is the beginning of your journey, so do not
    be afraid to experiment with different approaches and techniques. In the next
    section, we provide an overview of the HTTP protocol.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板代码是你旅程的开始，所以不要害怕尝试不同的方法和技巧。在接下来的部分，我们将概述 HTTP 协议。
- en: Understanding the HTTP protocol
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 HTTP 协议
- en: In the context of our discussion on Cloud Functions, it is essential to consider
    how the HTTP protocol works—learning the necessary foundation of the API to enable
    communication between request and response.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论云函数的背景下，理解 HTTP 协议的工作原理至关重要——学习 API 的基础，以便实现请求与响应之间的通信。
- en: HTTP verbs, such as GET, PUT, POST, DELETE, and so on, provide the basis for
    the HTTP protocol to perform its various functions. The design of the contract
    is one that has generally stood the test of time as more advanced use cases have
    been more prevalent over time. Typically running over TCP, the protocol requires
    a reliable medium on which to transmit messages—utilizing a contract such as TCP
    establishes some level of resilience for the data transmission and acknowledgment
    when performing machine-to-machine communication. In terms of commonality, GET
    and POST represent the most common methods used for applications.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 动词，如 GET、PUT、POST、DELETE 等，为 HTTP 协议执行其各种功能提供了基础。这种契约的设计经过了时间的考验，随着更高级用例的出现，它变得越来越普及。通常运行在
    TCP 上，该协议需要一个可靠的媒介来传输消息——利用像 TCP 这样的契约为数据传输和机器间通信时的确认建立了一定的弹性。在常见的使用方法中，GET 和
    POST 是应用中最常用的方法。
- en: In the next section, we provide a quick overview of these methods to understand
    their use.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将简要概述这些方法，以帮助理解它们的使用。
- en: Defining GET/POST methods
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义 GET/POST 方法
- en: Accessing a web page typically uses the GET method to gather content stored
    on remote servers. Whenever you are surfing the internet and looking at the contents
    of various websites, the HTTP GET method is used to achieve this. The GET method
    is, at its most basic, an idempotent retrieval mechanism for HTTP. Think about
    the GET method as a simple retrieval mechanism, that is, *get this information
    from the remote server*. Sending this command to a remote server tells it to provide
    a message response.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 访问网页通常使用 GET 方法来获取存储在远程服务器上的内容。每当你浏览互联网并查看各种网站的内容时，HTTP GET 方法都会被用来实现这一点。GET
    方法在最基本的形式上是 HTTP 的幂等获取机制。将 GET 方法看作一个简单的获取机制，也就是*从远程服务器获取这些信息*。向远程服务器发送这个命令，它会提供一个消息响应。
- en: The GET method also allows query information to be sent to the remote server;
    however, this information is displayed as part of the URL. The message payload
    is typically served as a stream of bytes, after which the remote server will close
    the open TCP connection indicating the completion of the transaction.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: GET 方法也允许将查询信息发送到远程服务器；然而，这些信息会显示在 URL 中。消息负载通常以字节流的形式提供，之后远程服务器会关闭开放的 TCP 连接，表示事务已完成。
- en: When working with web pages, in addition to retrieving information from a website
    using the GET method, there is also the POST method. The POST method provides
    the ability to supply additional information as part of the query sent to the
    remote server. In contrast to the GET method, there is no exposure via the URL
    of query information, and the request made is non-idempotent. These attributes
    make the POST method more useful for incorporating information that should not
    disclose content via the URL and is susceptible to change. A typical use for this
    type of arrangement is web forms, in which field values are sent as part of the
    HTTP request query.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理网页时，除了使用 GET 方法从网站获取信息外，还有 POST 方法。POST 方法提供了将额外信息作为查询的一部分发送到远程服务器的能力。与 GET
    方法不同，查询信息不会通过 URL 暴露，并且请求是非幂等的。这些特性使得 POST 方法更适合用于发送不应通过 URL 曝露的内容，并且可能发生变化的信息。这类方式的典型应用是
    Web 表单，其中字段值作为 HTTP 请求查询的一部分发送。
- en: Once the request/response cycle has completed, a status code indicating the
    status of the transaction is returned. In the next topic, an overview of HTTP
    codes outlines the general categories.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦请求/响应周期完成，系统将返回一个表示事务状态的状态码。在接下来的主题中，HTTP 代码的概述将概述这些常见类别。
- en: Unmasking HTTP response codes
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解码 HTTP 响应码
- en: An HTTP response's three-digit response code indicates the success of the communication
    performed. These response codes are vital to ensure the smooth running of any
    HTTP-based application server.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 HTTP 响应的三位数响应码表示通信是否成功。这些响应码对于确保任何基于 HTTP 的应用服务器的顺利运行至关重要。
- en: 'If you have ever needed to configure or maintain a web server, the following
    information will undoubtedly be very familiar to you:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经需要配置或维护一个 Web 服务器，以下信息对你来说无疑会非常熟悉：
- en: '| **Return Value** | **Type** | **Description** |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| **返回值** | **类型** | **描述** |'
- en: '| 1xx | Information | An informational response code indicating the request
    was understood. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 1xx | 信息 | 一个信息性响应码，表示请求已被理解。 |'
- en: '| 2xx | Success | The more common method of confirming the success of the request
    is by returning this status code. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 2xx | 成功 | 确认请求成功的最常见方式是返回此状态码。 |'
- en: '| 3xx | Redirect | Redirection associated with the client request; typically
    no user interaction is required as a redirect is automatically enacted to complete
    the action. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 3xx | 重定向 | 与客户端请求相关的重定向；通常不需要用户交互，因为重定向会自动执行以完成操作。 |'
- en: '| 4xx | Client Error | A request-based error that indicates something was wrong
    with the information sent from the client to the server. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 4xx | 客户端错误 | 基于请求的错误，表示客户端发送到服务器的信息有问题。 |'
- en: '| 5xx | Server Error | An error relating to the response from the server-side
    communication has occurred, meaning the request could not be fulfilled. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 5xx | 服务器错误 | 与服务器端通信响应相关的错误，表示请求无法完成。 |'
- en: The full list of HTTP status code is maintained by the **Internet Assigned Numbers
    Authority** (**IANA**). The broad categories associated with the HTTP status code
    ensure that most situations are catered for when working in this area.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 状态码的完整列表由**互联网编号分配局**（**IANA**）维护。与 HTTP 状态码相关的广泛类别确保在处理此领域时能涵盖大多数情况。
- en: Another area that may be of use in extending your understanding is how to work
    across domains with web content. In the next section, we'll look at a concise
    overview of cross-origin resource sharing.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能对扩展理解有帮助的领域是如何跨域处理网页内容。在接下来的章节中，我们将简要概述跨域资源共享（CORS）。
- en: Working with Cross-Origin Resource Sharing (CORS)
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用跨域资源共享（CORS）
- en: Enabling CORS in the HTTP header enables a range of actions to be performed
    across domains. The addition of this provides an extra capability beyond that
    of traditional single-domain, client-to-server information exchange. As you would
    expect of the client, their responsibility is to initiate a request that includes
    indicating the method and header requirements. From a server perspective, the
    range of header properties is more numerous, allowing the achievement of a richer
    set of functionality.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTTP 头中启用 CORS 可以实现跨域执行一系列操作。添加这个功能提供了一种超越传统单域客户端与服务器信息交换的额外能力。正如你所预期的，客户端的责任是发起请求，并在请求中指明方法和头部要求。从服务器的角度来看，头部属性的范围更多，允许实现更丰富的功能集。
- en: 'An application may not always be in a situation where execution takes place
    in the same domain. For these types of situations, there is CORS, and this provides
    the ability to enable communication across domains:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用可能并不总是在同一域中执行。在这种情况下，CORS 提供了跨域通信的能力：
- en: '| **Client** | **Server** |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| **客户端** | **服务器** |'
- en: '|'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Origin
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 起源
- en: Access-Control-Request-Method
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Access-Control-Request-Method
- en: Access-Control-Request-Headers
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Access-Control-Request-Headers
- en: '|'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Access-Control-Allow-Origin
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Access-Control-Allow-Origin
- en: Access-Control-Allow-Credentials
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Access-Control-Allow-Credentials
- en: Access-Control-Expose-Headers
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Access-Control-Expose-Headers
- en: Access-Control-Max-Age
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Access-Control-Max-Age
- en: Access-Control-Allow-Methods
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Access-Control-Allow-Methods
- en: Access-Control-Allow-Headers
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Access-Control-Allow-Headers
- en: '|'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Finally, we outlined the event-driven triggers associated with Cloud Functions.
    Looking at the options, it's clear that these triggers are capable of meeting
    many of the use cases related to building systems. Thinking of events and triggers
    like *glue* or *lego* pieces is a good metaphor for the use of these components.
    When it comes to building new components or designing a serverless application,
    it is often surprising how easy it is to use these building blocks together. But
    it doesn't stop there – imagine extending beyond Google Cloud to other cloud providers
    and using their services. Serverless provides a real and exciting disruption to
    the existing design and application development process. Single-use functions
    focused on delivering a clean interface with defined inputs and outputs make for
    a more efficient delivery and maintenance experience.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们概述了与 Cloud Functions 相关的事件驱动触发器。通过查看这些选项，可以清楚地看到，这些触发器能够满足许多构建系统时相关的用例。将事件和触发器视为*胶水*或*乐高*积木是一个很好的比喻，能够帮助理解这些组件的使用。当涉及到构建新组件或设计无服务器应用时，通常令人惊讶的是这些构建块能如此轻松地协同工作。但事情并不止于此——想象一下，超越
    Google Cloud，使用其他云服务商的服务。无服务器为现有设计和应用开发过程带来了真正激动人心的变革。专注于提供清晰接口并具有明确输入和输出的单次使用功能，可以提高交付和维护效率。
- en: Working through each of the options, we discussed how each could be used to
    significant effect when building a serverless application. To achieve this, an
    adaptive type of architecture requires more than Cloud Functions, for example,
    when incorporating authentication (via Firebase), proxy access (via Cloud Endpoints),
    or temporary storage (via Google Cloud Storage). Working with best practices and
    combining different approaches isn't a one-size-fits-all affair, and you have
    the ability to utilize both open source and commercial software seamlessly, moving
    beyond the serverless platform and looking out to the broader aspects of your
    system. While serverless provides a simple method of achieving scale, introducing
    network scale in other aspects of your portfolio will still require careful planning.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 逐一讨论了每个选项时，我们讨论了如何在构建无服务器应用时充分发挥其重要作用。为了实现这一点，一种适应性的架构不仅仅需要云函数（例如，在集成认证（通过 Firebase）、代理访问（通过
    Cloud Endpoints）或临时存储（通过 Google Cloud Storage）时），还需要更多的东西。遵循最佳实践并结合不同的方法并非“一刀切”的事宜，你能够无缝地使用开源和商业软件，超越无服务器平台，关注系统的更广泛方面。虽然无服务器提供了一种实现扩展的简便方法，但在你其他部分引入网络扩展时，仍然需要仔细规划。
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we walked through a broad overview of Cloud Functions and where
    it sits within the Google Cloud Serverless portfolio. Also, we looked at a few
    tangential aspects that are relevant to the use of FaaS, such as HTTP2 and the
    data life cycle.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们概述了 Cloud Functions 的整体情况，并讨论了它在 Google Cloud 无服务器产品中的位置。此外，我们还查看了几个与使用
    FaaS 相关的边缘话题，例如 HTTP2 和数据生命周期。
- en: By exploring the runtimes and observing the associated code throughout the chapter,
    we are now aware of how to structure Cloud Functions in multiple languages. We
    also are aware of how to test and resolve issues by incorporating monitoring and
    logging into our development workflow. As you will know, Google provides a full
    array of tools and services to get you to the point where you can quickly develop
    a **minimum viable product** (**MVP**).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 通过探索运行时，并观察整章关联的代码，我们现在知道如何在多种语言中构建云函数。我们还了解到通过将监控和日志记录纳入开发工作流程，如何测试和解决问题。正如您所知，Google提供了一整套工具和服务，让您能够迅速开发**最小可行产品**（**MVP**）。
- en: In the next chapter, we will cover some more examples in greater depth. Building
    an application provides an excellent way to learn the critical elements of a serverless
    application environment.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地讨论一些示例。构建应用程序是学习无服务器应用程序环境关键要素的绝佳方式。
- en: Questions
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What port does Cloud Functions run on?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cloud Functions运行在哪个端口？
- en: What trigger is used by Cloud Pub/Sub?
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cloud Pub/Sub使用的是哪种触发器？
- en: What runtime languages are supported by Google Cloud Functions?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Google Cloud Functions支持哪些运行时语言？
- en: What is the HTTP response code for success?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功的HTTP响应代码是什么？
- en: What is the HTTP response code for a client-side error?
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端错误的HTTP响应代码是什么？
- en: What is the HTTP response code for a server-side error?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器端错误的HTTP响应代码是什么？
- en: What is the purpose of CORS?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CORS的目的是什么？
- en: How is CORS enabled?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何启用CORS？
- en: Further reading
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '**Introduction to HTTP/2**: [https://developers.google.com/web/fundamentals/performance/http2](https://developers.google.com/web/fundamentals/performance/http2)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP/2简介**：[https://developers.google.com/web/fundamentals/performance/http2](https://developers.google.com/web/fundamentals/performance/http2)'
- en: '**HTTP/2 for load balancing with Ingress**: [https://cloud.google.com/kubernetes-engine/docs/how-to/ingress-http2](https://cloud.google.com/kubernetes-engine/docs/how-to/ingress-http2)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP/2负载均衡与Ingress**：[https://cloud.google.com/kubernetes-engine/docs/how-to/ingress-http2](https://cloud.google.com/kubernetes-engine/docs/how-to/ingress-http2)'
- en: '**Functions Framework**: [https://cloud.google.com/functions/docs/functions-framework](https://cloud.google.com/functions/docs/functions-framework)'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数框架**：[https://cloud.google.com/functions/docs/functions-framework](https://cloud.google.com/functions/docs/functions-framework)'
