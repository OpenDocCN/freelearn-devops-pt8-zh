- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Connecting It All Together – GitFlow, GitOps, and CI/CD
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容连接起来——GitFlow、GitOps 和 CI/CD
- en: '**GitOps** is a contemporary approach to software development and operations
    that strives to make the management of infrastructure and applications easier
    and more efficient. It achieves this by using **Git** as the primary source of
    truth and adopting a declarative approach wherever possible. This methodology
    integrates the principles of version control and continuous delivery to optimize
    the software development life cycle and facilitate better teamwork between development
    and operations teams—and sometimes a fusion of the two disciplines into a true
    **DevOps** team.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**GitOps** 是一种现代的软件开发与运维方法，旨在使基础设施和应用管理变得更加简单高效。它通过使用 **Git** 作为主要的真实状态来源，并尽可能采用声明式方法来实现这一目标。这种方法结合了版本控制和持续交付的原则，优化软件开发生命周期，并促进开发和运维团队之间更好的协作——有时甚至将两者的职能融合成一个真正的
    **DevOps** 团队。'
- en: 'The chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Understanding key concepts of GitOps
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 GitOps 的关键概念
- en: Leveraging GitHub for source control management
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 GitHub 进行源代码管理
- en: Leveraging GitHub Actions for **continuous integration/continuous deployment**
    (**CI/CD**) pipelines
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 GitHub Actions 实现 **持续集成/持续部署**（**CI/CD**）管道
- en: Understanding key concepts of GitOps
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 GitOps 的关键概念
- en: There are many ways of implementing GitOps, and we’ll look at several in this
    chapter, but at its core, GitOps is about applying the software development life
    cycle to both application source code and infrastructure configuration—or **infrastructure
    as code** (**IaC**). The Git repository becomes the source of truth for what is
    in production, what *was* in production, and what *will* be in production soon.
    In order to do so, the Git repository will have to include configuration files,
    application code, infrastructure definitions, and deployment manifests—everything
    needed to reproduce a fully working version of the application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 GitOps 的方法有很多，我们将在本章中探讨几种，但从本质上讲，GitOps 是将软件开发生命周期应用于应用程序源代码和基础设施配置——即**基础设施即代码**（**IaC**）。Git
    仓库成为生产环境中真实状态的来源，包含了当前生产环境、*曾经*的生产环境以及*即将*投入生产的内容。为了实现这一点，Git 仓库必须包含配置文件、应用程序代码、基础设施定义和部署清单——所有必要的内容，以便重新生成一个完全可工作的应用程序版本。
- en: Declarative representations are preferred over compiled artifacts, but when
    source code is compiled into artifacts, they need to be versioned and tied back
    to a commit within the Git repository itself. Tools such as Terraform, Docker,
    and Kubernetes interpret these declarative files and automatically apply changes
    to the system to conform to the desired state.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 相较于编译后的构件，声明式表示更为优选，但当源代码被编译成构件时，需要对这些构件进行版本控制，并且与 Git 仓库中的提交关联。诸如 Terraform、Docker
    和 Kubernetes 等工具会解释这些声明式文件，并自动将变更应用到系统中，以使其符合预期状态。
- en: Any changes to the Git repository are automatically and continuously applied
    to the target environment, no matter where the environment sits in the life cycle—a
    development, staging, or production environment. This automated process ensures
    consistency and reduces the risk of manual errors.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对 Git 仓库的任何更改都会自动且持续地应用到目标环境中，无论该环境处于生命周期的哪个阶段——开发、测试还是生产环境。这个自动化过程确保了一致性，并减少了手动错误的风险。
- en: This can be achieved through a **push** or a **pull** model, which we first
    saw in the previous chapter when looking at different CI/CD pipeline approaches
    for Kubernetes-based solutions. Due to Kubernetes’s influence within the GitOps
    space, it is often a foregone conclusion that the goal is to establish a pull
    model. However, a pull model is not required to implement GitOps. There are many
    ways to implement GitOps, and each approach has distinct trade-offs that should
    be evaluated in your specific context.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过 **推送** 或 **拉取** 模型实现，前一章我们在讨论基于 Kubernetes 的解决方案的 CI/CD 管道时已经看到了这两种方法。由于
    Kubernetes 在 GitOps 领域的影响，通常情况下，我们预设的目标是建立拉取模型。然而，实现 GitOps 并不一定需要拉取模型。实现 GitOps
    的方式有很多，每种方法都有不同的权衡，应该根据你所在的具体环境进行评估。
- en: Whether you use the push model or the pull model, one of the big advantages
    of using GitOps is that it provides transparency and visibility into the changes
    made to the system by keeping a log of all deployments and updates through the
    normal source control management process. The Git commit history is transformed
    into an audit trail that makes it easier to understand what changes were made
    when they occurred, and by whom. The combination of the complete configuration
    and code to produce an end-to-end working system and a versioned copy makes it
    relatively easy to roll back to a previous state in the event of issues. Of course,
    stateful portions of your systems will likely need additional engineering to ensure
    both new deployments and rollbacks are uneventful.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用推送模型还是拉取模型，GitOps的一个主要优点是它通过在常规源代码管理过程中保留所有部署和更新的日志，提供对系统变更的透明度和可视化。Git提交历史被转化为审计追踪，使得理解何时发生了哪些变更以及由谁做出的变更变得更加容易。完整配置和代码结合生产出端到端工作的系统，并且拥有版本化的副本，这使得在遇到问题时相对容易回滚到先前的状态。当然，你系统中的有状态部分可能需要额外的工程设计，以确保新的部署和回滚都能顺利进行。
- en: Using this approach can improve software delivery processes, resulting in greater
    efficiency, reliability, and scalability while simultaneously encouraging collaboration
    between development, operations, and other teams. This is the key reason why adopting
    this approach is critical to enabling a DevOps culture within an organization.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法可以改进软件交付过程，从而提高效率、可靠性和可扩展性，同时促进开发、运维和其他团队之间的协作。这就是为何采用这种方法对推动组织内DevOps文化至关重要的关键原因。
- en: Due to the heavy reliance on Git—traditionally a software development tool—team
    members without an application development background can tend to struggle. Therefore,
    if you come from a non-developer background such as a system administrator, network
    or security engineer, or other infrastructure discipline, it’s very important
    that you take the time to learn basic Git commands and a **Gitflow** process,
    as this knowledge will be critical for you to be effective on the team.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Git的使用依赖较重——Git通常是软件开发工具——没有应用开发背景的团队成员可能会感到困难。因此，如果你来自非开发者背景，比如系统管理员、网络或安全工程师，或者其他基础设施领域，那么花时间学习基本的Git命令和**Gitflow**流程是非常重要的，因为这些知识将对你在团队中的有效性至关重要。
- en: Terraform—and tools like it—are a critical component to a GitOps toolchain as
    the use of IaC is an important pillar of this approach, but it’s important to
    remember that Terraform is often just one ingredient in the grand recipe with
    the source control and pipelining tool playing the key role in facilitating the
    process. That’s why, in this book, we’ll be setting up sophisticated architectures
    using Terraform and CI/CD pipelines to provision them. Before we can get to that,
    we need to firmly understand what a CI/CD pipeline is and how to build one, which
    is what we will look at in the next section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform及类似工具是GitOps工具链中的一个关键组成部分，因为IaC（基础设施即代码）的使用是这种方法的一个重要支柱，但必须记住，Terraform通常只是整个方案中的一个组成部分，源代码管理和管道工具在促进整个过程中的作用更为关键。这就是为什么在本书中，我们将使用Terraform和CI/CD管道来设置复杂的架构并进行配置。在我们深入探讨之前，我们需要明确理解CI/CD管道是什么以及如何构建一个，这正是我们在下一节中将要讨论的内容。
- en: Understanding CI/CD
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解CI/CD
- en: 'A CI/CD pipeline is an automated set of steps and processes that help software
    development teams build, test, and deploy their applications quickly and reliably.
    It is a fundamental component when implementing a GitOps process as it takes on
    the critical role of facilitating the continuous flow of changes from development
    to production, ensuring that new code is automatically integrated, tested, and
    delivered to end users as a working system:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD管道是一套自动化的步骤和过程，帮助软件开发团队快速且可靠地构建、测试和部署他们的应用程序。它是实现GitOps流程的基本组成部分，因为它在促进从开发到生产的持续变更流动中发挥着至关重要的作用，确保新代码被自动集成、测试，并以工作系统的形式交付给最终用户：
- en: '![Figure 6.1 – Overview of the anatomy of a CI/CD pipeline](img/B21183_06_1.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – CI/CD管道的结构概览](img/B21183_06_1.jpg)'
- en: Figure 6.1 – Overview of the anatomy of a CI/CD pipeline
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – CI/CD管道的结构概览
- en: As its very name might suggest, a CI/CD pipeline actually consists of two processes
    that are stitched together. First, the **continuous integration** pipeline, which
    is responsible for building and ensuring the built-in quality of the application
    code of the system, and second, the **continuous deployment** pipeline, which
    is responsible for deploying that application code into its environment.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名字所示，CI/CD 流水线实际上由两个过程组成，并将它们结合在一起。首先是**持续集成**流水线，负责构建和确保系统应用代码的内建质量；其次是**持续部署**流水线，负责将应用代码部署到相应环境中。
- en: 'The CI/CD pipeline aggregates these two historically distinct processes: **integration
    testing** and **deployment**. However, by combining them, it provides a systematic
    and automated approach to continuously delivering new features and bug fixes to
    users, reducing the time and risk associated with manual deployments. This, in
    turn, fosters a culture of collaboration, frequent feedback, and rapid innovation
    within development teams.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD 流水线将这两个历史上不同的过程聚合在一起：**集成测试**和**部署**。然而，通过将它们结合，它提供了一种系统化和自动化的方法，能够持续不断地将新特性和
    bug 修复交付给用户，减少了与手动部署相关的时间和风险。这反过来又促进了开发团队内的合作文化、频繁反馈和快速创新。
- en: A CI/CD pipeline that uses Terraform to provision infrastructure and deploys
    the latest code version to that infrastructure typically has two objectives. First,
    produce a version of the software that has been tested and verified to have satisfactory
    levels of built-in quality. Second, provision an environment—whatever that looks
    like—to host the application that is compatible and meets the software’s requirements
    to function correctly and efficiently. The third and final step is to deploy the
    application to that environment.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Terraform 来配置基础设施并将最新代码版本部署到该基础设施的 CI/CD 流水线通常有两个目标。首先，生成经过测试并验证具有令人满意的内建质量的软件版本；其次，配置一个环境——无论其样貌如何——来托管与软件需求兼容并能够正确高效运行的应用程序。第三步也是最后一步是将应用程序部署到该环境中。
- en: The pipeline makes no judgments about how robust your cloud architecture might
    be. Depending on your needs, you may opt to sacrifice certain qualities of your
    solution architecture for expediency or cost. The pipeline’s job is to provision
    whatever environment you tell it you need and to deploy the software to that environment,
    so once the pipeline has completed, your application is ready to accept incoming
    traffic from users.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 流水线并不会对你的云架构的稳健性做出评判。根据你的需求，你可以选择牺牲解决方案架构的某些特性来追求便捷或降低成本。流水线的工作是提供你所需的环境，并将软件部署到该环境中，因此一旦流水线完成，应用程序就准备好接受用户的访问流量。
- en: In the next section, we’ll dig deeper into the internal structure of a CI/CD
    pipeline and discuss the mechanics of what is going on along the way.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将深入探讨 CI/CD 流水线的内部结构，并讨论沿途发生的机制。
- en: Anatomy of pipeline
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流水线结构
- en: In the previous sections, we learned about the fundamental principles of GitOps
    and that the CI/CD pipeline is grounded on a version control system such as Git,
    where developers commit their code changes. We can configure a CI/CD pipeline
    to trigger when certain key events take place within the code base, such as changes
    being pushed to a specific branch.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们了解了 GitOps 的基本原理，并知道 CI/CD 流水线是基于像 Git 这样的版本控制系统建立的，开发人员在该系统中提交他们的代码更改。我们可以配置
    CI/CD 流水线，使其在代码库中发生某些关键事件时触发，例如将更改推送到特定分支。
- en: 'Once certain key events take place within the version control system, such
    as a developer pushing changes to a particular branch or path, the CI/CD pipeline
    is triggered. It will pull the latest code, build the application, and run a series
    of automated tests to verify the functionality and integrity of the application
    code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦版本控制系统中发生某些关键事件，比如开发者将更改推送到特定的分支或路径，CI/CD 流水线便会触发。它将拉取最新的代码，构建应用程序，并运行一系列自动化测试以验证应用程序代码的功能和完整性：
- en: '![Figure 6.2 – Anatomy of a CI/CD pipeline](img/B21183_06_2.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – CI/CD 流水线结构](img/B21183_06_2.jpg)'
- en: Figure 6.2 – Anatomy of a CI/CD pipeline
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – CI/CD 流水线结构
- en: Various tests, including unit tests, integration tests, and sometimes even acceptance
    tests, can be conducted to ensure that the code meets quality standards and does
    not introduce regressions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 可以进行多种测试，包括单元测试、集成测试，有时甚至是验收测试，以确保代码符合质量标准并且没有引入回归问题。
- en: '**Unit tests** operate on individual components and use mocks to isolate the
    tests’ outcomes around a single component by injecting placeholders for the component’s
    downstream dependencies:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**在单独的组件上操作，并使用模拟对象（mocks）来隔离测试结果，针对单一组件通过注入占位符来替代该组件的下游依赖项：'
- en: '![Figure 6.3 – Unit tests are isolated on a single component](img/B21183_06_3.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – 单元测试孤立于单一组件](img/B21183_06_3.jpg)'
- en: Figure 6.3 – Unit tests are isolated on a single component
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 单元测试孤立于单一组件
- en: '**Integration tests** operate across two or more components. They can use mocks
    or not, and their focus is on the reliability of interactions between components.
    Sometimes, for very intricate or complex components, you might want integration
    tests that focus on the various use cases surrounding them while keeping other
    components’ outputs predictable using mocks:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成测试**跨越两个或更多组件进行操作。它们可以使用模拟对象，也可以不使用，重点是组件间交互的可靠性。有时，对于非常复杂或复杂的组件，你可能希望进行集成测试，重点关注围绕它们的各种使用场景，同时使用模拟对象保持其他组件的输出可预测：'
- en: '![Figure 6.4 – Integration tests are focused on two or more components and
    how they interact](img/B21183_06_4.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 集成测试关注两个或更多组件及它们如何交互](img/B21183_06_4.jpg)'
- en: Figure 6.4 – Integration tests are focused on two or more components and how
    they interact
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 集成测试关注两个或更多组件及它们如何交互
- en: '**System tests** introduce real-world dependencies, such as databases or messaging
    subsystems, into the mix and allow you to achieve much more realistic coverage
    across a system without fully deploying it:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**系统测试**引入了现实世界的依赖项，如数据库或消息传递子系统，并允许你在不完全部署系统的情况下，实现跨系统的更真实的覆盖：'
- en: '![Figure 6.5 – System tests](img/B21183_06_5.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – 系统测试](img/B21183_06_5.jpg)'
- en: Figure 6.5 – System tests
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 系统测试
- en: System tests have a broader focus, often introducing real-world dependencies
    such as databases and external systems
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 系统测试的关注范围更广，通常会引入现实世界的依赖项，如数据库和外部系统
- en: 'An **end-to-end test** is one where you provide the entire host environment
    for the application—as it would be in production—and execute tests that mimic
    an actual client application or end user as closely as possible:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**端到端测试**是指提供整个应用程序的宿主环境——如同它在生产环境中的表现——并执行尽可能接近实际客户端应用程序或最终用户的测试：'
- en: '![Figure 6.6 – End-to-end tests](img/B21183_06_6.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6 – 端到端测试](img/B21183_06_6.jpg)'
- en: Figure 6.6 – End-to-end tests
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – 端到端测试
- en: End-to-end tests attempt to mimic, as closely as possible, actual end-user activity
    with the system fully operational, end to end.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试尝试尽可能真实地模拟最终用户活动，在系统完全运行的情况下，进行从头到尾的测试。
- en: It depends on the requirements of the particular application and organization,
    what kind of testing, and how much needs to be done on an application. Terraform
    can also play a crucial role in the continuous integration process by provisioning
    **just-in-time** (**JIT**) environments for system or end-to-end testing environments.
    Terraform allows you to dynamically create an environment fit for purpose, execute
    your tests, and then shut everything down.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于特定应用程序和组织的要求，需要进行什么样的测试，以及在应用程序上需要做多少工作。Terraform 还可以在持续集成过程中发挥关键作用，通过为系统或端到端测试环境提供**及时**（**JIT**）环境。Terraform
    允许你动态创建适合目的的环境，执行测试，然后关闭所有资源。
- en: Depending on the level of reliability that you want in your release process,
    you could opt for a deeper and more robust level of testing before the continuous
    deployment process is initiated.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你希望在发布过程中的可靠性水平，你可以选择在启动持续部署过程之前进行更深入、更强大的测试。
- en: After the continuous integration process is successfully completed, the application
    is packaged into a deployment package (e.g., a Docker container or a JAR file)
    that contains all the necessary dependencies and configurations and is ready to
    be deployed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在持续集成过程成功完成后，应用程序被打包成一个部署包（例如 Docker 容器或 JAR 文件），其中包含所有必要的依赖项和配置，并准备好进行部署。
- en: During the continuous deployment process, both the Git source code and this
    deployment package are used to provide the environment and deploy the package
    to the target environment. Terraform is crucial in provisioning or updating the
    required infrastructure, such as virtual machines, containers, or serverless resources.
    As we looked at in the previous chapters, Terraform can also optionally perform
    the application deployment through a pre-built virtual machine image or a Kubernetes
    deployment with pre-built container images.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在持续部署过程中，Git 源代码和部署包都会被用来提供环境并将包部署到目标环境中。Terraform 在提供或更新所需基础设施方面至关重要，如虚拟机、容器或无服务器资源。正如我们在前几章中所看到的，Terraform
    还可以选择通过预构建的虚拟机镜像或预构建的容器镜像进行应用程序的部署。
- en: After deployment, the CD pipeline can run additional verification tests to ensure
    that the application runs correctly in the target environment by utilizing health
    checks built into the application and infrastructure.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 部署完成后，CD 流水线可以运行额外的验证测试，通过应用程序和基础设施中内建的健康检查，确保应用程序在目标环境中正确运行。
- en: Regardless of the architecture, the outcome of the CD pipeline is that it applies
    environment-specific configurations—usually derived from Terraform outputs, which
    contain vital configuration details—to the artifact, thus, customizing it for
    the target environment. These configurations might include database connection
    strings, API endpoints, or other settings that differ between environments.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 无论架构如何，CD 流水线的结果是将特定环境的配置应用到工件上——这些配置通常来源于 Terraform 输出，包含重要的配置细节——从而将工件定制为目标环境。这些配置可能包括数据库连接字符串、API
    端点或其他在不同环境之间有所不同的设置。
- en: 'As you can see, Terraform plays an essential role in this process but is not
    the only player on the field. Each step in this process is equally important and
    plays a critical role in consistently releasing software with built-in quality.
    In this book, we will review three architectures and three corresponding techniques
    for deployment for each of the three paradigms of cloud hosting: virtual machines,
    containers, and serverless. These solutions will be built using GitHub as the
    source control repository and GitHub Actions as the tool we use to implement our
    CI/CD pipelines. Depending on the architecture of the software and how it is hosted
    within the environment, the deployment technique may vary.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Terraform 在这一过程中发挥着至关重要的作用，但并不是唯一的参与者。该过程中的每一步都同样重要，并在持续发布具备内建质量的软件方面发挥着关键作用。在本书中，我们将回顾三种架构以及与之对应的三种部署技术，针对三种云托管范式：虚拟机、容器和无服务器。我们将使用
    GitHub 作为源代码仓库，并使用 GitHub Actions 作为我们实现 CI/CD 流水线的工具。根据软件架构及其在环境中的托管方式，部署技术可能会有所不同。
- en: In the next section, we’ll look at the source control management aspects of
    GitOps, which include the developer workflows that add structure to our DevOps
    teams that are executing in this manner.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论 GitOps 的源代码管理方面，包括为我们的 DevOps 团队提供结构的开发者工作流，这些团队以这种方式执行任务。
- en: Leveraging GitHub for source control management
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用 GitHub 进行源代码管理
- en: GitHub is just one option for source control management software. We’ll be using
    it in this book, but it’s important for you to understand that the concepts and
    patterns implemented using GitHub are consistent no matter what source control
    provider you end up using for your projects. There may be small differences between
    the syntax and mechanisms that implement and execute pipelines, but the source
    control management system is just `git` under the hood.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 只是源代码管理软件的一种选择。在本书中我们将使用它，但你需要理解的是，无论你最终使用哪个源代码控制提供商，使用 GitHub 实现的概念和模式是一致的。尽管实现和执行流水线的语法和机制可能有所不同，但源代码管理系统在背后仍然是`git`。
- en: An important part of source control management is how to use it in a structured
    way on a team—large or small. These are conventions that your team can use so
    that you have consistent expectations across the team about how new features are
    shepherded through your development process and into production.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码管理的一个重要部分是如何在团队中——无论是大团队还是小团队——以结构化的方式使用它。这些是你们团队可以采用的约定，从而确保团队在新功能通过开发过程并最终进入生产时，能有一致的预期。
- en: Gitflow is a common model that uses a combination of well-known, long-lived,
    and consistent naming conventions for short-lived branches. As we will see in
    the next subsection, it is highly customizable and a bit of a *Choose Your Own
    Adventure*, which is why it has become one of the most common operating models
    for development teams, no matter the size.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Gitflow是一种常见的模型，使用了知名的、长期存在的、且一致的命名规范来管理短期生命周期的分支。正如我们将在下一小节中看到的，它具有高度的可定制性，稍显像是*选择你自己的冒险*，这也是它成为全球各地开发团队最常见的操作模型之一的原因，无论团队规模如何。
- en: We’ll also look at a miniature variant called GitHub flow, which is an example
    of trunk-based development. This model advocates for keeping the `main` branch
    always deployable and minimizing the use of long-lived branches. Instead of creating
    long-lived stable branches for various purposes and designs, developers work directly
    on the `main` branch using only short-lived `feature` branches that are quickly
    merged back into `main`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将了解一种名为GitHub flow的简化变体，它是基于主干开发的一个例子。该模型主张保持`main`分支始终可部署，并最小化长期存在的分支使用。开发者直接在`main`分支上工作，使用短暂的`feature`分支，快速合并回`main`，而不是为各种目的和设计创建长期存在的稳定分支。
- en: In the next section, we’ll take a closer look at Gitflow to see what the developer
    experience would look like and how it would integrate with the automation systems
    that we build using Terraform.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将更深入地了解Gitflow，看看开发者的实际体验如何，以及它如何与我们使用Terraform构建的自动化系统集成。
- en: Gitflow
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gitflow
- en: 'Gitflow is one of the most popular branching models and workflows used by development
    teams around the world. Its prolific nature has led to the development of different
    variations and adaptations to suit different development environments and teams’
    preferences. At its core, Gitflow leverages a `main` branch to indicate production
    quality code and a `develop` branch that grants development teams a safe place
    to merge and perform integration testing:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Gitflow是全球开发团队最受欢迎的分支模型和工作流之一。它的广泛应用促使了各种变体和适配的出现，以适应不同的开发环境和团队的需求。在其核心，Gitflow利用`main`分支表示生产质量的代码，`develop`分支为开发团队提供了一个安全的合并和集成测试的环境：
- en: '![Figure 6.7 – Gitflow at its simplest](img/B21183_06_7.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7 – Gitflow的最简形式](img/B21183_06_7.jpg)'
- en: Figure 6.7 – Gitflow at its simplest
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – Gitflow的最简形式
- en: In Gitflow, `main` is the main branch representing the production-ready code.
    Only code that is ready for production should live in this branch. Features that
    are under development are created by individual developers on their own `feature/*`
    branch and then merged into a shared `develop` branch that acts a bit like a staging
    environment before being merged into `main`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在Gitflow中，`main`是表示生产就绪代码的主要分支。只有准备好投入生产的代码才能存在于此分支中。处于开发中的功能由开发者在自己的`feature/*`分支上创建，随后合并到共享的`develop`分支，这个分支有点像是一个预发布环境，之后再合并到`main`。
- en: However, as mentioned before, Gitflow is highly customizable and there have
    been several extensions to this core model developed over the years with varying
    levels of adoption.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如前面所提到的，Gitflow具有高度的可定制性，多年来已经出现了几种对这个核心模型的扩展，且在不同的环境中有不同程度的采用。
- en: Sometimes, `release` branches are used for preparing and testing releases, starting
    from `develop` and merging back into both `develop` and `main`. This can give
    a team greater control over when and how they release a set of features into production.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，`release`分支用于准备和测试发布，起始于`develop`并合并回`develop`和`main`。这样可以让团队更好地控制何时以及如何将一组功能发布到生产环境。
- en: 'The real world happens fast. As a result, sometimes critical changes need to
    be made rapidly to production to fix a specific issue. That’s when `hotfix` branches
    are used by starting from `main` and merging back into both `develop` and then
    `main` once a hotfix has been fully tested:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界变化迅速。因此，有时需要快速对生产环境进行关键修改，以解决特定问题。这时，`hotfix`分支从`main`开始，经过完全测试后再合并回`develop`和`main`。
- en: '![Figure 6.8 – Gitflow extended](img/B21183_06_8.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图6.8 – Gitflow扩展版](img/B21183_06_8.jpg)'
- en: Figure 6.8 – Gitflow extended
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – Gitflow扩展版
- en: 'Gitflow is highly customizable:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Gitflow高度可定制：
- en: '`main`: Production only code (1)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main`: 仅生产代码（1）'
- en: '`release`: Release staging (2)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`release`: 发布准备（2）'
- en: '`develop`: Integrating testing (3)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`develop`: 集成测试（3）'
- en: '`feature/*`: Feature development (4)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`feature/*`: 功能开发（4）'
- en: '`hotfix/*`: Critical patches to production (5)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hotfix/*`: 生产环境的关键补丁（5）'
- en: 'Gitflow does not dictate a specific versioning scheme, but it is common to
    use semantic versioning (e.g., `{MAJOR}.{MINOR}.{PATCH}`) to indicate the significance
    of changes made in each release. Gitflow does provide a clear separation of tasks,
    making it suitable for larger teams and projects that require strict control over
    the development and release process. However, this structure can be overwhelming
    for smaller teams or experimental projects:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Gitflow 不指定特定的版本控制方案，但通常使用语义化版本（例如，`{主版本}.{次版本}.{修订版本}`）表示每个发布中所做更改的重要性。Gitflow
    提供了任务的清晰分离，适合需要严格控制开发和发布流程的大型团队和项目。然而，这种结构对于较小的团队或实验性项目可能会感到压倒性：
- en: '![Figure 6.9 – Gitflow integration with CI/CD pipelines](img/B21183_06_9.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.9 – Gitflow 与 CI/CD 流水线集成](img/B21183_06_9.jpg)'
- en: Figure 6.9 – Gitflow integration with CI/CD pipelines
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 – Gitflow 与 CI/CD 流水线集成
- en: 'The Gitflow process has several key events where automation might be triggered:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Gitflow 过程有几个关键事件可以触发自动化：
- en: '`feature/*` branch into `develop`. This often triggers a CI/CD pipeline that
    includes application code with built-in quality, unit, and integration tests.
    The merge of this pull request initiates a release pipeline that is deployed to
    the development environment.'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`feature/*` 分支合并到 `develop`。这通常会触发包括应用代码、内建质量、单元和集成测试的 CI/CD 流水线。合并此拉取请求会启动一个部署到开发环境的发布流水线。'
- en: '`develop` branch into `release`. This usually includes additional testing,
    such as system and even end-to-end tests. The merge of this pull request initiates
    a release pipeline that deploys to the staging or release environment.'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`develop` 分支合并到 `release`。这通常包括额外的测试，如系统甚至端到端测试。合并此拉取请求会启动一个部署到暂存或发布环境的发布流水线。'
- en: '`release` into `main`. This usually includes additional variations of end-to-end
    tests that check performance or load and may include upgrade or version testing.
    The merge of this pull request initiates a release pipeline that deploys to the
    production environment.'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`release` 分支合并到 `main`。这通常包括额外的端到端测试变体，检查性能或负载，并可能包括升级或版本测试。合并此拉取请求会启动一个部署到生产环境的发布流水线。'
- en: '`hotfix/*` branch into `main`. This would likely execute a smaller catalog
    of test suites but would likely include version or upgrade testing. The merge
    of this pull request initiates a release pipeline that deploys to the production
    environment.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`hotfix/*` 分支合并到 `main`。这可能执行一个较小的测试套件目录，但可能包括版本或升级测试。合并此拉取请求会启动一个部署到生产环境的发布流水线。'
- en: It’s important to point out that this is probably the most extensive configuration
    of Gitflow, but humans being humans, I’m sure somebody out there has come up with
    an even more complex incarnation of Gitflow. In the next section, let’s look at
    something a little more simple and lightweight by going back and taking a look
    at Trunk-Based Development using GitHub flow.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，这可能是 Gitflow 最复杂的配置，但是作为人类，我相信肯定有人已经提出了更复杂的 Gitflow 版本。在下一节中，让我们通过回顾
    GitHub 流程来看一些更简单、更轻量的内容。
- en: GitHub flow
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitHub 流程
- en: 'As we’ve discussed, GitHub flow is the little brother of Gitflow. It’s much
    more simple and lightweight and perfect for small teams or experimentation. It
    focuses on only one branch—`main`—with new features being introduced for individual
    `feature/*` branches. Developers create `feature` branches from `main`, work on
    their changes, and then submit pull requests to merge them back into the `main`
    branch. Releases are often tagged from `main` after thorough testing:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所讨论的，GitHub 流程是 Gitflow 的小兄弟。它更简单、更轻量，非常适合小团队或实验。它专注于仅有一个分支—`main`—新功能从个别`feature/*`分支引入。开发人员从
    `main` 创建 `feature` 分支，进行修改，然后提交拉取请求将它们合并回 `main` 分支。在彻底测试后，版本通常从 `main` 打上标签：
- en: '![Figure 6.10 – GitHub flow for small teams or experiments](img/B21183_06_10.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.10 – 适用于小团队或实验的 GitHub 流程](img/B21183_06_10.jpg)'
- en: Figure 6.10 – GitHub flow for small teams or experiments
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 – 适用于小团队或实验的 GitHub 流程
- en: The main difference is that there is no official process around creating staging
    branches such as `develop` or `release` branches where integration testing is
    performed. The responsibility for integration testing resides on the individual
    developer of the feature within their own `feature` branch—in essence, taking
    individual responsibility for their changes working in production.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的区别在于，没有官方的流程来创建像 `develop` 或 `release` 这样的阶段分支，通常在这些分支上进行集成测试。集成测试的责任由每个功能开发者在他们自己的
    `feature` 分支上承担——本质上是对他们的改动在生产环境中能否正常工作负责。
- en: This also means that we have fewer key events which a CI/CD pipeline will trigger
    from. We only have a pull request from `feature/*` into `main` and then merge
    into `main` to trigger events. Additional testing can be performed on the `feature/*`
    branches themselves or teams can optionally introduce a manual trigger for a production
    release, which allows for more time to perform testing on `main`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着我们触发 CI/CD 流水线的关键事件变少了。我们只有从 `feature/*` 分支提交到 `main` 的拉取请求，然后合并到 `main`，来触发事件。额外的测试可以在
    `feature/*` 分支上进行，或者团队可以选择为生产版本发布引入手动触发器，这样就能有更多时间在 `main` 上进行测试。
- en: As mentioned previously, GitHub flow is great for smaller teams that don’t have
    dedicated teams focused on integration testing!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，GitHub flow 非常适合没有专门负责集成测试的小团队！
- en: Each variation of Gitflow has its strengths and weaknesses, and the choice of
    workflow depends on the project’s specific needs, team size, development process,
    and the tools or platforms used for version control. It’s essential to evaluate
    the requirements and preferences of the team and project to select the most suitable
    branching model. I’ll go over a few of these options in this book in more detail,
    but for the most part, I will use GitHub Flow to keep things simple in my examples.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每种 Gitflow 变体都有其优缺点，工作流的选择取决于项目的具体需求、团队规模、开发流程以及用于版本控制的工具或平台。评估团队和项目的需求与偏好，选择最合适的分支模型是至关重要的。在本书中，我会更详细地介绍一些选项，但大多数情况下，我会使用
    GitHub Flow 来简化我的示例。
- en: Using GitHub Actions for CI/CD pipelines
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GitHub Actions 进行 CI/CD 流水线
- en: '**GitHub Actions** is a CI/CD service offered by GitHub that provides a platform
    for you to implement automation around your source control management process
    no matter what workflow you choose.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**GitHub Actions** 是 GitHub 提供的 CI/CD 服务，为你提供一个平台，可以在你选择的任何工作流中实现自动化，围绕你的源代码管理过程进行操作。'
- en: 'In order to hook into GitHub Actions, you need to define YAML files that specify
    the tasks that you want to be automated. These files are called `.github/workflows`
    directory of your source code repository. The basic anatomy of a workflow consists
    of jobs. Jobs have steps. Steps can be a simple script that you execute or something
    more complex packaged together called an action:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了挂钩到 GitHub Actions，你需要定义 YAML 文件，指定你希望自动化的任务。这些文件被称为 `.github/workflows` 目录，位于你的源代码仓库中。一个工作流的基本结构由多个
    jobs 组成。每个 job 包含多个 steps。步骤可以是你执行的简单脚本，或者是更复杂的打包在一起的 action：
- en: '[PRE0]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code has two jobs: `build` and `test`. The jobs are grouped under
    the `jobs:` section and each job has steps grouped under the `steps:` section.
    You can customize the image that your job runs on using the `runs-on` attribute.
    This allows you to specify a container image that is customized to your needs
    with the correct Linux distribution or software configuration.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码包含了两个 jobs：`build` 和 `test`。这些 jobs 被归类在 `jobs:` 部分，每个 job 下有多个 steps，归类在
    `steps:` 部分。你可以通过 `runs-on` 属性自定义 job 运行的镜像。这允许你指定一个符合需求的容器镜像，使用合适的 Linux 发行版或软件配置。
- en: By default, a step simply executes a bash script using the `run` attribute,
    but you can utilize an action by specifying the action type with the `uses` attribute.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，步骤只是通过 `run` 属性执行一个 bash 脚本，但你可以通过指定 `uses` 属性来使用一个 action。
- en: 'To execute Terraform, you simply need it installed on your agent. This can
    be done easily using an action provided by HashiCorp called `hashicorp\setup-terraform@v2`.
    The following code snippet demonstrates how to do this while specifying the specific
    version of Terraform that you want to use:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行 Terraform，你只需在代理上安装它。可以使用 HashiCorp 提供的一个名为 `hashicorp\setup-terraform@v2`
    的 action 来轻松实现。以下代码片段展示了如何在指定 Terraform 的特定版本的同时完成此操作：
- en: '[PRE1]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There are additional attributes, but they are more for edge cases and are beyond
    the scope of this book. I recommend you check out the documentation for the action
    to check out all the different options available: [https://github.com/hashicorp/setup-terraform](https://github.com/hashicorp/setup-terraform).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些属性，但它们更多是针对边缘案例，超出了本书的范围。我建议你查看该操作的文档，了解所有可用的选项：[https://github.com/hashicorp/setup-terraform](https://github.com/hashicorp/setup-terraform)。
- en: You must always store sensitive data as secrets to ensure that the data is not
    exposed in the logs. This can easily be accomplished by leveraging GitHub environments
    or other secret management services.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须始终将敏感数据存储为机密，以确保数据不会暴露在日志中。这可以通过利用 GitHub 环境或其他机密管理服务轻松实现。
- en: Virtual machine workloads
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟机工作负载
- en: When building automation pipelines that provision virtual-machine-hosted workloads,
    your toolchain should consist of something that can be used to set up the initial
    configuration of the virtual machine, provision the virtual machine, and make
    updates to the virtual machine’s configuration over time. The tools that we will
    cover in this book for these purposes are Packer, Terraform, and Ansible, respectively.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建自动化流水线以配置虚拟机托管的工作负载时，你的工具链应该包括能够设置虚拟机初始配置、配置虚拟机以及随时间推移更新虚拟机配置的工具。本书将涵盖用于这些目的的工具：Packer、Terraform
    和 Ansible。
- en: Packer build pipeline
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Packer 构建流水线
- en: As we discussed when we looked at developing Packer templates, developers write
    and commit Packer configuration files using **HashiCorp Configuration Language**
    (**HCL**) to their Git repository.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在讨论 Packer 模板开发时提到的，开发人员使用**HashiCorp 配置语言**（**HCL**）编写并提交 Packer 配置文件到其
    Git 仓库。
- en: An independent pipeline is triggered when changes are pushed to the version
    control system affecting the folder where the Packer configuration files are stored.
    Within that pipeline, Packer is utilized to build virtual machine images for each
    server role (e.g., frontend, backend, and database). Packer is configured with
    the latest configurations for each role within the application, including the
    necessary software and settings unique to each layer. After successfully building
    each image, Packer creates machine images optimized for the cloud provider of
    choice (e.g., **Amazon Machine Images** (**AMIs**) for **Amazon Web Services**
    (**AWS**) or Azure Managed Images for Azure).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当对存放 Packer 配置文件的文件夹进行更改并推送到版本控制系统时，会触发一个独立的流水线。在该流水线中，Packer 用于为每个服务器角色（例如，前端、后端和数据库）构建虚拟机镜像。Packer
    会根据应用程序中每个角色的最新配置进行配置，包括每一层独有的必要软件和设置。在成功构建每个镜像后，Packer 会创建优化后的机器镜像，适配所选云服务提供商（例如，**Amazon
    Machine Images**（**AMIs**）用于**Amazon Web Services**（**AWS**）或用于 Azure 的 Azure
    管理镜像）。
- en: Sometimes, Packer can fail due to transient issues with the virtual machine
    itself or just bugs within your script. You can use a **debug mode** within Packer
    that will allow you to pause the build process on the temporary virtual machine.
    This will allow you to connect to the machine, execute the command that failed
    manually, and troubleshoot the issues within the environment itself.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，Packer 可能会因虚拟机本身的暂时性问题或脚本中的错误而失败。你可以在 Packer 中使用**调试模式**，该模式允许你在临时虚拟机上暂停构建过程。这将允许你连接到该机器，手动执行失败的命令，并排查环境中的问题。
- en: Depending on the target cloud platform, the generated machine images are stored
    in an artifact repository or directly in the cloud provider’s image repository
    for later use by Terraform.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 根据目标云平台的不同，生成的机器镜像会被存储在制品库中，或直接存储在云服务提供商的镜像仓库中，以便 Terraform 后续使用。
- en: Terraform apply pipeline
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Terraform 应用流水线
- en: Now that the virtual machine images are published to an image repository, Terraform
    simply needs to reference the correct image in order to provision a virtual machine
    with the right one. Similar to the Packer Build Pipeline, developers commit Terraform
    configuration files to their Git repository, and a separate pipeline is triggered
    whenever changes are pushed to the folder where the Terraform configuration is
    stored.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，虚拟机镜像已发布到镜像仓库，Terraform 只需引用正确的镜像，就能为虚拟机配置合适的镜像。类似于 Packer 构建流水线，开发人员将 Terraform
    配置文件提交到其 Git 仓库，并且每当对存储 Terraform 配置文件的文件夹进行更改并推送时，都会触发一个独立的流水线。
- en: The Terraform configuration defines the network infrastructure, including subnets,
    security groups, and load balancers, needed for all the virtual machines within
    the solution. Terraform pulls the Packer-built machine images from the artifact
    repository or cloud provider’s image repository and provisions the required number
    of virtual machines for each role, setting up any load balancers necessary to
    distribute the load across multiple servers to ensure high availability and fault
    tolerance.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 配置定义了网络基础设施，包括子网、安全组和负载均衡器，所有虚拟机都需要这些资源。Terraform 从工件仓库或云提供商的镜像仓库中拉取
    Packer 构建的机器镜像，并为每个角色配置所需数量的虚拟机，设置任何必要的负载均衡器，以便在多台服务器之间分配负载，从而确保高可用性和容错性。
- en: Terraform can sometimes fail either for transient issues but also potential
    race conditions between resources that you are trying to provision that are implicitly
    dependent upon each other. We’ll go into more advanced troubleshooting scenarios
    in [*Chapter 17*](B21183_17.xhtml#_idTextAnchor700), but for now, it’s important
    to recognize that Terraform is idempotent, which means you can run it over and
    over again to reach a desired state—so, sometimes, just re-running the job can
    get you past the initial issue you faced.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 有时可能会失败，既可能是由于临时问题，也可能是因为你尝试配置的资源之间存在潜在的竞争条件，这些资源是相互依赖的。我们将在[*第 17
    章*](B21183_17.xhtml#_idTextAnchor700)中详细讨论更复杂的故障排除场景，但现在，重要的是要认识到 Terraform 是幂等的，这意味着你可以反复运行它以达到期望的状态——因此，有时候，重新运行任务就能帮助你解决最初遇到的问题。
- en: Ansible apply pipeline
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ansible 应用管道
- en: Finally, after Terraform applies the infrastructure changes and the virtual
    machines are set up using the Packer images, the environment is primed and ready.
    However, the environment is not yet fully operational as there will likely be
    certain configuration changes that need to be made specific to the environment
    that were not available during the Packer image build phase. This is what I call
    *last mile* configuration—where we put the last touches on the environment by
    applying any configuration settings only known after Terraform `apply` executes.
    There are different options for performing these last-mile configuration changes.
    You can use Terraform to dynamically configure user data to pass directly to the
    virtual machine, or you can use another tool to do the job.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 Terraform 应用基础设施更改并使用 Packer 镜像设置虚拟机后，环境已准备就绪。然而，环境尚未完全投入使用，因为可能还需要对特定于环境的配置进行一些更改，这些更改在
    Packer 镜像构建阶段无法获得。这就是我所说的*最后一公里*配置——我们通过应用在 Terraform `apply` 执行后才能得知的配置设置来对环境做最后的调整。执行这些最后一公里配置更改有不同的选择。你可以使用
    Terraform 动态配置用户数据，直接传递给虚拟机，或者使用其他工具来完成这项工作。
- en: Since most virtual machines also need some routine maintenance performed, it’s
    good to consider a configuration management tool that can make updates to your
    environment without having to shut down or reboot virtual machines by changing
    the version of the Packer image used. That’s where tools such as Ansible come
    in.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数虚拟机也需要执行一些常规维护，因此考虑使用配置管理工具是很好的，它可以在不关闭或重启虚拟机的情况下，通过更改使用的 Packer 镜像版本来更新环境。这就是像
    Ansible 这样的工具派上用场的地方。
- en: Ansible can be used as a configuration management tool to perform the last mile
    configuration on the virtual machines in addition to performing ongoing maintenance
    on the machines. Ansible scripts are applied to the deployed virtual machines
    to set environment-specific values, configure services, and perform other necessary
    tasks. In doing so, the environment is now ready for operators to perform routine
    maintenance using the already established Ansible configuration.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 可以作为配置管理工具，除了对虚拟机执行持续维护外，还可以在虚拟机上执行最后一公里配置。Ansible 脚本会应用于已部署的虚拟机，设置特定于环境的值、配置服务，并执行其他必要任务。这样，环境现在已准备好供操作员使用已建立的
    Ansible 配置执行常规维护。
- en: Like Terraform, Ansible is idempotent and can fall prey to similar transient
    errors. However, like Packer, Ansible is invoking change within the operating
    system itself. As a result, you just need to connect to one of these virtual machines
    and troubleshoot the commands that failed when Ansible executed its scripts.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Terraform 类似，Ansible 也是幂等的，并且可能会遭遇类似的暂时性错误。然而，像 Packer 一样，Ansible 会在操作系统内部进行变更。因此，你只需连接到其中一台虚拟机，排查
    Ansible 执行脚本时失败的命令。
- en: By employing this approach, a virtual-machine-based solution can efficiently
    be provisioned and operated over the lifespan of the application. This allows
    for reproducible, scalable, and automated deployments and provides the necessary
    flexibility for different environments while ensuring consistent and reliable
    setups for each role within the solution.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用这种方法，可以有效地基于虚拟机的解决方案进行配置和操作，贯穿应用的生命周期。这使得部署过程具有可复制性、可扩展性和自动化，并为不同的环境提供必要的灵活性，同时确保解决方案中每个角色的设置一致且可靠。
- en: Container workloads
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器工作负载
- en: When building automation pipelines that provision container-based workloads,
    your toolchain should consist of something that can be used to set the initial
    configuration of the various containers that need to be deployed, provision the
    Kubernetes cluster to host the containers and the underlying infrastructure that
    supports the Kubernetes cluster’s operations, and then finally provision Kubernetes
    resources to the Kubernetes control pane using Kubernetes’ REST API through a
    variety of different options.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建自动化流水线以配置容器基础的工作负载时，您的工具链应包括可以用来设置需要部署的各个容器的初始配置、配置 Kubernetes 集群以托管容器以及支持
    Kubernetes 集群操作的底层基础设施的工具，最后，通过多种选项使用 Kubernetes 的 REST API 来向 Kubernetes 控制平面配置
    Kubernetes 资源。
- en: Due to the immutability of the container images and their lightweight and speedy
    nature, it’s easy to implement sophisticated rolling updates to roll out new versions
    of the container image across existing deployments. Therefore, the mechanics around
    provisioning and maintaining container-based workloads are really about building
    new container images and referencing the desired image within your Kubernetes
    configuration to invoke an update to the deployment.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于容器镜像的不可变性及其轻量级和快速特性，实施复杂的滚动更新变得非常容易，可以在现有的部署中推出新版本的容器镜像。因此，容器基础的工作负载的配置和维护机制实际上就是构建新的容器镜像，并在
    Kubernetes 配置中引用所需的镜像，以触发部署更新。
- en: Docker build pipeline
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker 构建流水线
- en: As we discussed when we looked at the principles around Docker and how it works,
    developers write and commit Docker files using their Git repository.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在讨论 Docker 原理以及它如何工作的过程中提到的，开发者使用 Git 仓库编写并提交 Docker 文件。
- en: An independent pipeline is triggered when changes are pushed to the version
    control system, affecting the folder where the Docker configuration files are
    stored. Within that pipeline, Docker is utilized to build container images for
    each server role (e.g., frontend, backend, and database) within the application.
    Docker is configured with the latest configurations for each role within the application,
    including the necessary software and settings unique to each layer. The Docker
    image that is produced acts as our deployment package. As a result, it is versioned
    and stored in a Package repository called a container registry (which we discussed
    in [*Chapter 5*](B21183_05.xhtml#_idTextAnchor278)). Once the new Docker image
    is there, we can reference it from the Kubernetes configuration and trigger a
    deployment in Kubernetes in a myriad of ways.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当向版本控制系统推送更改并影响存储 Docker 配置文件的文件夹时，会触发一个独立的流水线。在该流水线中，Docker 用于为应用中的每个服务器角色（例如，前端、后端和数据库）构建容器镜像。Docker
    配置了每个角色的最新配置，包括每一层独有的必要软件和设置。生成的 Docker 镜像充当我们的部署包。因此，它被版本化并存储在名为容器注册表的包仓库中（我们在[*第
    5 章*](B21183_05.xhtml#_idTextAnchor278)中讨论过）。一旦新的 Docker 镜像存储完成，我们可以从 Kubernetes
    配置中引用它，并通过多种方式在 Kubernetes 中触发部署。
- en: Kubernetes manifest update pipeline
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kubernetes 清单更新流水线
- en: In this pipeline, developers modify the manifests to reference the new version
    of the Docker image that was built and published in the previous step and submit
    a pull request to update the change. The trigger we use can be either a push model
    or a pull model. If you recall, in [*Chapter 5*](B21183_05.xhtml#_idTextAnchor278),
    *Container-Based Architectures*, we discussed several different methods for implementing
    a push model in this manner. Some options use `kubectl` and Kubernetes YAML manifests,
    and others use a Helm Chart with a set of YAML manifests that have been turned
    into a more dynamic template by using Helm.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个管道中，开发人员修改清单，以引用在上一步中构建并发布的新的Docker镜像版本，并提交拉取请求以更新更改。我们使用的触发器可以是推送模型或拉取模型。如果你还记得，在[*第5章*](B21183_05.xhtml#_idTextAnchor278)《*基于容器的架构*》中，我们讨论了实现推送模型的几种不同方法。一些选项使用`kubectl`和Kubernetes
    YAML清单，另一些则使用带有一组YAML清单的Helm Chart，这些清单通过Helm转化为更动态的模板。
- en: Alternatively, using the pull model, we could use a continuous deployment agent
    hosted on the Kubernetes cluster itself, such as ArgoCD, that would pick up on
    changes within the Git repository and apply them to the cluster. Because ArgoCD
    is continuously monitoring the Git repository containing the Kubernetes manifests
    (or Helm Charts), whenever a new commit is made to the repository, it will automatically
    trigger a deployment process. ArgoCD isn’t doing any magic; it is simply using
    `kubectl apply` to apply the latest version of the manifests to the Kubernetes
    cluster.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代方案，使用拉取模型，我们可以使用托管在Kubernetes集群上的持续部署代理，例如ArgoCD，它会监控Git仓库中的更改并将其应用于集群。因为ArgoCD持续监控包含Kubernetes清单（或Helm
    Charts）的Git仓库，每当仓库中有新的提交时，它将自动触发部署过程。ArgoCD并没有做什么神奇的事情；它只是使用`kubectl apply`将最新版本的清单应用到Kubernetes集群中。
- en: Terraform apply pipeline
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Terraform应用管道
- en: As we have discussed in [*Chapter 5*](B21183_05.xhtml#_idTextAnchor278), due
    to Kubernetes architecture, the Kubernetes cluster is often a shared resource
    where multiple teams will deploy their own workloads by targeting their own namespace
    within the cluster. That’s why it’s often the case that this pipeline may be managed
    by a different team than the ones that own the Docker Build and Kubernetes Manifest
    pipelines. This pipeline is owned by the team responsible for provisioning and
    maintaining the Kubernetes cluster. Their responsibility is to ensure that the
    cluster is up and running and ready to accept deployments from ArgoCD.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第5章*](B21183_05.xhtml#_idTextAnchor278)中所讨论的，由于Kubernetes的架构，Kubernetes集群通常是一个共享资源，多个团队会通过针对集群中的各自命名空间来部署他们自己的工作负载。这也是为什么这个管道通常由与拥有Docker构建和Kubernetes清单管道的团队不同的团队来管理。这个管道由负责提供和维护Kubernetes集群的团队管理。他们的责任是确保集群正常运行，并随时准备接受ArgoCD的部署。
- en: Terraform could optionally be used to manage Kubernetes resources on the cluster,
    but as we addressed in [*Chapter 5*](B21183_05.xhtml#_idTextAnchor278), this may
    not be ideal in all situations due to team and organizational dynamics. It’s best
    to consider your specific context and make the right decision for your team and
    organization.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform可以作为可选项用于管理集群上的Kubernetes资源，但正如我们在[*第5章*](B21183_05.xhtml#_idTextAnchor278)中所讨论的，这在所有情况下可能并不理想，因为团队和组织的动态因素。在这种情况下，最好根据你的具体背景来做出适合你团队和组织的决策。
- en: In most cases, Terraform is simply used to provision the Kubernetes cluster
    and surrounding infrastructure on the cloud platform of choice. Developers will
    commit Terraform configuration files to their Git repository, and the pipeline
    is triggered whenever changes are pushed to the folder where the Terraform configuration
    is stored.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，Terraform仅用于在所选的云平台上提供Kubernetes集群和周围的基础设施。开发人员会将Terraform配置文件提交到他们的Git仓库，每当对存储Terraform配置的文件夹进行更改时，管道会被触发。
- en: This approach allows developers to focus on code development and testing without
    worrying about the underlying infrastructure and deployment process. The development
    teams can rely on an isolated environment within the Kubernetes cluster that they
    deploy to and really only need to maintain their code base and the Docker file
    used to configure their application.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使开发人员能够专注于代码开发和测试，而无需担心底层基础设施和部署过程。开发团队可以依赖Kubernetes集群中的隔离环境进行部署，实际上只需要维护他们的代码库和用于配置应用程序的Docker文件。
- en: Serverless workloads
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无服务器工作负载
- en: In serverless architecture, the deployment process can be greatly simplified.
    You typically have two main pipelines to manage the serverless framework and surrounding
    services and the actual function code themselves.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在无服务器架构中，部署过程可以大大简化。通常，您需要有两个主要的管道来管理无服务器框架及周边服务，以及实际的函数代码。
- en: Terraform apply pipeline
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Terraform 应用管道
- en: This pipeline is responsible for provisioning the underlying infrastructure
    required to support the serverless workloads. It uses Terraform to define and
    manage the infrastructure components. The pipeline may create resources such as
    load balancers, API gateways, event triggers, and other logical components that
    serve as the foundation for serverless functions. These are often lightweight
    cloud services that are extremely quick to provision.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 该管道负责为支持无服务器工作负载提供基础设施。它使用 Terraform 来定义和管理基础设施组件。管道可能会创建诸如负载均衡器、API 网关、事件触发器以及其他作为无服务器函数基础的逻辑组件。这些通常是轻量级的云服务，能够极其快速地配置。
- en: Serverless deployment pipeline
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无服务器部署管道
- en: This pipeline is responsible for deploying individual serverless functions to
    the target platform (e.g., AWS Lambda or Azure Functions). Each serverless function
    typically has its own pipeline to handle its deployment, testing, and versioning.
    This maintains autonomy between the different components and allows teams to organize
    ownership that aligns with how they manage their code base. The pipeline really
    only involves packaging the function code, defining the configuration, and deploying
    it to the cloud platform of choice.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 该管道负责将单个无服务器函数部署到目标平台（例如 AWS Lambda 或 Azure Functions）。每个无服务器函数通常都有自己的管道来处理其部署、测试和版本控制。这确保了不同组件之间的自治，并允许团队根据他们如何管理代码库来组织责任。这条管道实际上仅涉及打包函数代码、定义配置并将其部署到选定的云平台。
- en: The serverless approach simplifies the deployment and management of code, and
    developers can focus more on writing the application logic while relying on automated
    deployment pipelines to handle infrastructure provisioning and serverless function
    deployments.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器方法简化了代码的部署和管理，开发人员可以更多地专注于编写应用程序逻辑，同时依赖自动化部署管道来处理基础设施的配置和无服务器函数的部署。
- en: Terraform tools
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Terraform 工具
- en: There are a ton of tools out there to help improve Terraform code in terms of
    beauty, functionality, and maintainability. I won’t boil the ocean here but I
    will mention some critical tools that are absolutely required for any Terraform
    continuous integration process.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多工具可以帮助提升 Terraform 代码的美观性、功能性和可维护性。我不会在这里面面俱到，但我会提到一些对任何 Terraform 持续集成过程绝对必需的关键工具。
- en: Formatting
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式化
- en: During development, you should install the HashiCorp Terraform plugin for Visual
    Studio Code. This will enable a ton of helpful productivity features within your
    editor but it will also automatically execute Terraform’s built-in formatting
    function, `terraform fmt`, on saving each file. This will drastically help promote
    consistent formatting within your code base. This is a proactive approach that
    is dependent on the developer to take steps to configure their development environment
    properly.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，您应安装 HashiCorp Terraform 插件到 Visual Studio Code 中。这将启用编辑器中的大量有用的生产力功能，同时它还会在每次保存文件时自动执行
    Terraform 内置的格式化功能 `terraform fmt`。这将极大地帮助在代码库中保持一致的格式化。这是一种主动的做法，依赖开发人员采取措施正确配置他们的开发环境。
- en: In order to verify each developer is employing this technique to keep your project’s
    Terraform code neat and tidy, you need to use a linter as part of your pull request
    process. Adding `tflint` to your pull request process will help prevent poorly
    formatted code from ever making it into your `main` branch!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证每个开发人员是否采用这种技术以保持项目的 Terraform 代码整洁，您需要在拉取请求流程中使用一个代码检查工具。将 `tflint` 添加到您的拉取请求流程中将有助于防止格式不良的代码进入您的
    `main` 分支！
- en: Documentation
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文档
- en: Now that the code is formatted properly, we should generate some documentation
    for our modules. This is useful whether you are writing root modules or reusable
    modules. The `terraform-docs` tool, when pointed at a Terraform module director,
    will generate a markdown `README` file that documents the key aspects of your
    Terraform module, including version requirements for both Terraform and the providers
    you employ, as well as details on the input and output variables. This tool is
    ideal to set up as a pre-commit operation to ensure that your documentation is
    automatically generated every time the code is merged. It reads annotations that
    are built-in to HCL, such as `description`, `type`, `required`, and any default
    values.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码格式已经正确，我们应该为我们的模块生成一些文档。无论你是编写根模块还是可重用模块，这都会非常有用。当`terraform-docs`工具指向一个Terraform模块目录时，它将生成一个markdown格式的`README`文件，记录Terraform模块的关键方面，包括Terraform和所使用的提供者的版本要求，以及输入和输出变量的详细信息。这个工具非常适合设置为预提交操作，确保每次合并代码时都能自动生成文档。它会读取HCL中的注解，如`description`、`type`、`required`和任何默认值。
- en: You can read more at [https://terraform-docs.io/user-guide/introduction/](https://terraform-docs.io/user-guide/introduction/).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://terraform-docs.io/user-guide/introduction/](https://terraform-docs.io/user-guide/introduction/)了解更多。
- en: Security scanning
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全扫描
- en: '**Checkov** is a static code analyzer that can scan your Terraform plan files
    to detect security and compliance violations. It has thousands of built-in policies
    spanning many platforms but most importantly including the cloud platforms that
    we explore in this book: AWS, Azure, and Google Cloud. However, at the time of
    writing, the policy coverage is most comprehensive for AWS, with both Azure and
    Google Cloud with significantly less coverage.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**Checkov**是一个静态代码分析工具，可以扫描你的Terraform计划文件，检测安全性和合规性违规。它内置了成千上万的策略，覆盖了许多平台，最重要的是包括本书中探索的云平台：AWS、Azure和Google
    Cloud。然而，在写作时，AWS的策略覆盖最为全面，而Azure和Google Cloud的覆盖范围相对较少。'
- en: You can read more at [https://github.com/bridgecrewio/checkov](https://github.com/bridgecrewio/checkov).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/bridgecrewio/checkov](https://github.com/bridgecrewio/checkov)了解更多。
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned the basic concepts of source control management,
    including detailed breakdowns of different branching and workflow strategies that
    are used by teams large and small. We looked at how our automation systems, namely
    our CI/CD pipelines, would integrate with these processes at key events.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了源代码控制管理的基本概念，包括对大型和小型团队使用的不同分支和工作流策略的详细拆解。我们还讨论了我们的自动化系统，即CI/CD管道，如何在关键事件时与这些流程进行集成。
- en: In the next chapter, we will move conceptual knowledge and start working on
    our first solution, which is to leverage virtual machines on the first public
    cloud, AWS.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从概念知识转向实际操作，开始着手第一个解决方案，即利用第一个公共云AWS上的虚拟机。
- en: 'Part 3: Building Solutions on AWS'
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：在AWS上构建解决方案
- en: 'Armed with the conceptual knowledge of Terraform and architectural concepts
    that transcend the implementation details of the major public cloud platforms,
    we’ll explore building solutions on **Amazon Web Services** (**AWS**) with three
    cloud computing paradigms: virtual machines, containers with Kubernetes, and serverless
    with AWS Lambda.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了Terraform的概念知识和跨越主要公共云平台实现细节的架构概念后，我们将探索如何在**亚马逊云服务**（**AWS**）上构建解决方案，涵盖三种云计算范式：虚拟机、使用Kubernetes的容器以及使用AWS
    Lambda的无服务器架构。
- en: 'This part has the following chapters:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 7*](B21183_07.xhtml#_idTextAnchor365), *Getting Started on AWS –
    Building Solutions with AWS EC2*'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B21183_07.xhtml#_idTextAnchor365)，*在AWS上入门 – 利用AWS EC2构建解决方案*'
- en: '[*Chapter 8*](B21183_08.xhtml#_idTextAnchor402), *Containerize with AWS – Building
    Solutions with AWS EKS*'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B21183_08.xhtml#_idTextAnchor402)，*使用AWS容器化 – 利用AWS EKS构建解决方案*'
- en: '[*Chapter 9*](B21183_09.xhtml#_idTextAnchor446), *Go Serverless with AWS –
    Building Solutions with AWS Lambda*'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B21183_09.xhtml#_idTextAnchor446)，*使用AWS无服务器架构 – 利用AWS Lambda构建解决方案*'
