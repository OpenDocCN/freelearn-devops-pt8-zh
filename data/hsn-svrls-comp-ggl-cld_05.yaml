- en: Introducing Lightweight Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍轻量级函数
- en: Following on from a general introduction to **Google App Engine** (**GAE**),
    we can now turn our attention to fully managed event processing. In this chapter,
    we will start working with Google Compute Engine and discover how to integrate
    serverless operational management tools in our environment. More specifically,
    coverage of event processing including Cloud Functions begins here.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在简要介绍了**Google App Engine**（**GAE**）之后，我们现在可以将注意力转向完全托管的事件处理。本章中，我们将开始使用 Google
    Compute Engine，并探索如何在我们的环境中集成无服务器操作管理工具。更具体地说，事件处理的内容，包括 Cloud Functions，从这里开始。
- en: This chapter will begin with a quick overview of Cloud Scheduler and Cloud Tasks,
    which are services that provide support to Google Cloud, followed by an introduction
    to Cloud Functions, after which we will develop a small application to utilize
    these services.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将首先简要概述 Cloud Scheduler 和 Cloud Tasks，它们是为 Google Cloud 提供支持的服务，接着介绍 Cloud
    Functions，然后我们将开发一个小应用来利用这些服务。
- en: 'Throughout this chapter, we will discuss the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Operational management tools
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作管理工具
- en: Cloud Tasks and Cloud Scheduler
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cloud Tasks 和 Cloud Scheduler
- en: An introduction to Cloud Functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cloud Functions 简介
- en: Developing a Cloud Functions application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个 Cloud Functions 应用
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In order to complete the exercises in this chapter, you will require a Google
    Cloud project or a Qwiklabs account.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章中的练习，您需要一个 Google Cloud 项目或 Qwiklabs 账户。
- en: You can find the code files for this chapter in the GitHub repository for the
    book in the `ch03` subdirectory at [https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch03](https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch03).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的 GitHub 仓库中找到本章的代码文件，位置在 `ch03` 子目录下，链接为 [https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch03](https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch03)。
- en: While you are going through code snippets in the book, you will notice that,
    in a few instances, a few lines from the code/output have been removed and replaced
    with ellipses (`...`). The use of ellipses only serves to show relevant code/output.
    The complete code is available on GitHub at the preceding link.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在您阅读本书中的代码片段时，您会注意到在某些情况下，代码/输出中的几行被删除，并用省略号（`...`）替代。省略号的使用仅用于显示相关的代码/输出。完整的代码可在前面提到的
    GitHub 链接中找到。
- en: Operational management tools
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作管理工具
- en: Being capable of responding to externally generated events provides a flexible
    mechanism on which to build systems that can be easily scaled and augmented. Consider
    how you might design a solution to create a thumbnail image based on the submission
    of a graphical representation. First, we need some disk storage to hold the image,
    then we need to process the image to generate a thumbnail, and then we need some
    more disk storage to keep the output.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 能够响应外部生成的事件提供了一种灵活的机制，用于构建易于扩展和增强的系统。考虑一下，您如何设计一个解决方案，根据提交的图形表示生成缩略图。首先，我们需要一些磁盘存储来保存图像，然后我们需要处理图像以生成缩略图，最后我们需要更多的磁盘存储来保存输出。
- en: Each stage of this activity requires a state change and response. The state
    change is a notification tied to the service call to indicate the state of the
    resource; for example, an image has been deposited, a picture has changed, or
    processing has completed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的每个阶段都需要状态变化和响应。状态变化是与服务调用相关联的通知，用于指示资源的状态；例如，图像已存储，图片已更改，或者处理已完成。
- en: In the example of Cloud Functions (introduced later in this chapter), an event
    triggers a new item deposit in **Google Cloud Storage** (**GCS**). The function
    is alerted by an event trigger and can then perform a series of instructions in
    reaction to this event. At the outset of these instructions, the transformed image
    (now a thumbnail) is made available to the end user.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面介绍的 Cloud Functions 示例中，一个事件触发了在**Google Cloud Storage**（**GCS**）中新项目的存储。该函数通过事件触发器被提醒，并能在此事件的响应中执行一系列指令。在这些指令的开始阶段，转换后的图像（现在是缩略图）会提供给最终用户。
- en: At this point, having been through the earlier chapters based on GAE, you will
    already have some familiarity with Cloud Tasks. It is always important to consider
    the objective before selecting a service. Taking this step will tell you whether
    the technology is appropriate for your needs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，经过前面基于GAE的章节，你已经对Cloud Tasks有了一定的了解。选择服务之前，始终考虑目标是很重要的。采取这一步骤将帮助你判断该技术是否适合你的需求。
- en: As a result, this section will not be a detailed exploration, as these are ancillary
    services that enable serverless workloads on Google Cloud. Instead, we will include
    an overview of the critical points to provide the context and likely use cases.
    In this way, working through this section should help intelligent decisions to
    be made regarding the appropriateness of incorporating these services. In many
    instances, there will be grey areas, as well as circumstances in which there is
    no clear choice. Thankfully, these situations will be outliers, and we can, therefore,
    generalize to a large extent on how to address these rate type of circumstances.
    Our discussion begins with Cloud Tasks.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本节不会进行详细探讨，因为这些是使Google Cloud上无服务器工作负载成为可能的辅助服务。相反，我们将概述关键点，以提供背景和可能的用例。通过这种方式，处理本节内容应该有助于做出关于是否纳入这些服务的智能决策。在许多情况下，会存在模糊地带，以及没有明确选择的情况。幸运的是，这些情况会是例外，因此我们可以在很大程度上概括如何处理这种类型的情况。我们的讨论从Cloud
    Tasks开始。
- en: Cloud Tasks
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cloud Tasks
- en: We have already reviewed the benefits of using Cloud Tasks with GAE in [Chapter
    1](75f69d9a-2ac4-4f8c-9cbf-aa8928c327cb.xhtml), *Introducing App Engine* and [Chapter
    2](ff73be02-51ed-4f9a-9181-5cd14fc8bd51.xhtml), *Developing with App Engine*.
    Many of these advantages remain when working with HTTP targets, for example, decreased
    application latency by offloading long-lived requests to a worker, or minimizing
    traffic spikes in user-facing tasks.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第1章](75f69d9a-2ac4-4f8c-9cbf-aa8928c327cb.xhtml)《介绍App Engine》和[第2章](ff73be02-51ed-4f9a-9181-5cd14fc8bd51.xhtml)《使用App
    Engine进行开发》中回顾了使用Cloud Tasks与GAE的好处。许多这些优势在与HTTP目标协作时仍然存在，例如通过将长期请求卸载到工作进程来减少应用程序延迟，或者减少面向用户任务的流量峰值。
- en: Distributed tasks on Google Cloud have their service dedicated to managing the
    execution, dispatch, and delivery of jobs. The idea here is that it is preferable
    to be able to offload, isolate, and manage HTTP requests to minimize latency.
    This asynchronous workflow is especially useful when dealing with user-facing
    applications that require responsive interfaces. The message payload request made
    for the task must include POST or PUT as the HTTP method to be processed with
    this method.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式任务在Google Cloud上的服务专门用于管理任务的执行、调度和交付。其理念是，能够卸载、隔离并管理HTTP请求以最小化延迟是更可取的。这个异步工作流在处理需要响应式接口的用户面向应用时尤其有用。为任务所做的消息负载请求必须包括POST或PUT作为要处理的HTTP方法。
- en: Cloud Tasks provides several benefits beyond the advantage of asynchronously
    offloading tasks. Also, it allows the developer to configure the various properties
    associated with the transmission of data. This could include sophisticated policies
    such as the application of retries or rate limits established on any data contract
    created.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Tasks提供了除了异步卸载任务的优势之外的多个好处。此外，它还允许开发人员配置与数据传输相关的各种属性。这可能包括复杂的策略，如应用重试或在任何数据契约上设置速率限制。
- en: 'In brief, the following elements are vital characteristics of Cloud Tasks and
    provide a compelling reason to use this service:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，以下元素是Cloud Tasks的重要特性，并为使用该服务提供了有力的理由：
- en: Async task offload
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步任务卸载
- en: Configurable retry policy
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可配置的重试策略
- en: Configurable rate limit
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可配置的速率限制
- en: Deferred scheduling
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟调度
- en: Decouple services
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解耦服务
- en: Increase resilience against failure
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高对失败的抗压能力
- en: Scalable and fully managed
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展且完全托管
- en: HTTP targets
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP目标
- en: Guaranteed delivery
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保证交付
- en: Supports several popular languages
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持多种流行语言
- en: By building a queue of data elements, Cloud Tasks establishes an efficient way
    for workers to process information. Each queue is subject to rate limits, which
    determine how many tasks will be executed per queue. Due to the guaranteed delivery
    mechanism applied, there will be a retry if the response to the message published
    is not adequate for the application. In general, response codes follow HTTP norms,
    with a status code in the 2xx range indicating success.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构建一个数据元素队列，Cloud Tasks 为工人处理信息提供了一种高效的方式。每个队列都有速率限制，决定了每个队列将执行多少任务。由于应用了保证交付机制，如果发布的消息的响应不符合应用要求，则会重试。一般来说，响应代码遵循
    HTTP 规范，其中 2xx 范围的状态代码表示成功。
- en: Distributed task queues make applications more responsive when performing async
    execution. Task queues are capable of organizing and controlling requests by exploiting
    key product features such as scheduling, de-deduplication, retry policy, and version
    redirection.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式任务队列使应用程序在执行异步操作时更加响应。任务队列能够通过利用关键产品功能，如调度、去重、重试策略和版本重定向，来组织和控制请求。
- en: Decoupled services (for example, Cloud Tasks and Cloud Pub/Sub) allow for better
    structure and application scale, especially when working with microservices. In
    this instance, task handlers will reside in each dedicated service to enable the
    microservices to scale independently. Consequently, this control of the management
    of resource consumption ensures better load dynamics, resulting in smoother service
    access, for example, rate-limiting queues.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 解耦服务（例如 Cloud Tasks 和 Cloud Pub/Sub）可以提供更好的结构和应用扩展性，特别是在使用微服务时。在这种情况下，任务处理程序将驻留在每个专用服务中，以便微服务能够独立扩展。因此，资源消耗的管理控制确保了更好的负载动态，从而实现更流畅的服务访问，例如速率限制队列。
- en: Furthermore, when handling releases and incidents gracefully, requests can be
    paused, retried, and redirected to a new version. If you have worked with Cloud
    Pub/Sub, this decoupling may all sound very familiar. The main difference between
    the two services involves invocation. Cloud Tasks provides the publisher with
    the ability to control execution, that is, the endpoint. Conversely, Cloud Pub/Sub
    enables the subscriber to control message delivery.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在优雅地处理发布和事件时，请求可以暂停、重试并重定向到新版本。如果你曾使用过 Cloud Pub/Sub，那么这种解耦方式可能非常熟悉。这两种服务之间的主要区别在于调用方式。Cloud
    Tasks 使发布者能够控制执行，即端点。而 Cloud Pub/Sub 使订阅者能够控制消息传递。
- en: To learn more about the differences between these two services, read the *Choosing
    between Cloud Tasks and Pub/Sub* documentation reference at [https://cloud.google.com/tasks/docs/comp-pub-sub](https://cloud.google.com/tasks/docs/comp-pub-sub).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这两项服务之间的差异，请阅读关于*选择 Cloud Tasks 和 Pub/Sub 之间的文档*，参考链接：[https://cloud.google.com/tasks/docs/comp-pub-sub](https://cloud.google.com/tasks/docs/comp-pub-sub)。
- en: Cloud Scheduler
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cloud Scheduler
- en: Think of Cloud Scheduler as cron jobs for the cloud. If you are not familiar
    with cron jobs, they represent an easy way to schedule activities on a machine
    based on a schedule. Acting as a single pane of glass, Cloud Scheduler enables
    users to manage all their automation needs from a single place. Creating a Cloud
    Scheduler job only requires a few elements to be up and running.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Cloud Scheduler 看作是云中的 cron 作业。如果你不熟悉 cron 作业，它们代表了一种基于时间表在机器上安排活动的简单方式。作为一个统一的管理界面，Cloud
    Scheduler 使用户能够从一个地方管理他们所有的自动化需求。创建 Cloud Scheduler 作业只需少量元素即可运行。
- en: 'If you are in a situation where you wish to automate some cloud infrastructure
    operations, then this is a perfect way to achieve that outcome. As a fully managed
    service, there is a simple interface through which you can set up and configure
    your automation needs as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你处于需要自动化某些云基础设施操作的场景中，那么这是实现该目标的完美方式。作为一项完全托管的服务，Cloud Scheduler 提供了一个简单的界面，你可以通过它来设置和配置你的自动化需求，具体如下：
- en: Establish the frequency with which to run and trigger a task.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定任务运行和触发的频率。
- en: Determine how Cloud Scheduler is to be invoked (that is, Pub/Sub, App Engine
    HTTP, or HTTP).
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定如何调用 Cloud Scheduler（即 Pub/Sub、App Engine HTTP 或 HTTP）。
- en: Deploy the service and the task will be invoked automatically when the scheduled
    time occurs.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署服务后，任务将在计划时间自动触发。
- en: Consult the Cloud Scheduler console page to see the results of each invocation
    or access it via Stackdriver Logging.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 Cloud Scheduler 控制台页面查看每次调用的结果，或者通过 Stackdriver Logging 访问它。
- en: Cloud Scheduler provides a simple and effective way to run regular jobs on schedule.
    If you have ever needed to run things such as backups or download updates, you
    will already know how useful and powerful this application is. Being an enterprise-grade
    product, Cloud Scheduler provides what is essentially a cloud-based crontab. The
    beauty of this product is that it enables users to trigger jobs across existing
    Google Cloud target services. Having these integration targets available provides
    a highly reliable mechanism to ensure that tasks run on a schedule can support
    existing usage patterns.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Scheduler 提供了一种简单有效的方式来定期执行任务。如果你曾经需要运行备份或下载更新等任务，你就会知道这个应用程序有多么有用和强大。作为一款企业级产品，Cloud
    Scheduler 提供的本质上是基于云的 crontab。这个产品的魅力在于，它使用户能够在现有的 Google Cloud 目标服务中触发任务。拥有这些集成目标提供了一个高可靠性的机制，确保定期执行的任务能够支持现有的使用模式。
- en: 'In addition to this, Cloud Scheduler also provides some key elements that are
    covered in the following list:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，Cloud Scheduler 还提供了一些关键元素，下面的列表中会涵盖：
- en: Reliable delivery guaranteed that is, delivery of at least one of the job targets
    (this does come with its own complications, where ordering data may be a concern,
    similar to using a messaging solutions such as Cloud Pub/Sub).
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保证可靠的交付，即至少保证一个作业目标的交付（这确实带来了一些复杂性，例如数据排序可能成为一个问题，类似于使用诸如 Cloud Pub/Sub 之类的消息解决方案）。
- en: A wide range of service support targets such as App Engine, Cloud Pub/Sub, and
    HTTP endpoints.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持广泛的服务目标，如 App Engine、Cloud Pub/Sub 和 HTTP 端点。
- en: The retry and backoff mechanism determines a suitable retry policy for job requirements.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重试和回退机制为作业需求确定合适的重试策略。
- en: Integration with Stackdriver Logging captures information relating to the performance
    and execution of your task
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Stackdriver Logging 的集成捕获与任务执行和性能相关的信息。
- en: Supports the Unix cron formation, so your existing knowledge is transferable.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持 Unix cron 格式，因此你现有的知识是可以迁移的。
- en: So now we know all of that, we can create a quick Cloud Scheduler demonstration
    on how to use it. In the following example, Cloud Scheduler will use Cloud Pub/Sub
    to illustrate how it can interact with a defined endpoint.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我们知道了这些，我们可以快速创建一个 Cloud Scheduler 演示，展示如何使用它。在以下示例中，Cloud Scheduler 将使用
    Cloud Pub/Sub 来说明它如何与定义的端点进行交互。
- en: 'The first task is to create a Pub/Sub topic. A Pub/Sub topic will collate the
    messages ready for distribution based on allocated subscribers as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个任务是创建一个 Pub/Sub 主题。Pub/Sub 主题将根据分配的订阅者整理准备分发的消息，如下所示：
- en: From the Google Cloud Console menu, select the Pub/Sub option.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Google Cloud Console 菜单中，选择 Pub/Sub 选项。
- en: From the Pub/Sub screen, select the Create Topic menu option.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Pub/Sub 屏幕中，选择创建主题菜单选项。
- en: On the Create a topic screen, enter the Topic ID as `cron-topic`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建主题屏幕上，输入主题 ID 为`cron-topic`。
- en: 'Leave the Encryption settings at the following default option: Google-managed
    key; then select the CREATE TOPIC button:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保留加密设置为以下默认选项：Google 管理的密钥；然后选择 CREATE TOPIC 按钮：
- en: '![](img/5fe7b49d-9e9c-4062-b630-a10a077d7dea.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5fe7b49d-9e9c-4062-b630-a10a077d7dea.png)'
- en: 'Once we have a topic defined, we now need to establish a subscription to it.
    For any available messages, we will be able to use either the pull or push mechanism
    to access the data payload associated with the topic:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了主题，接下来需要为其建立订阅。对于任何可用的消息，我们可以使用拉取或推送机制来访问与主题相关的数据负载：
- en: Now we need to create a subscription for the topic, so select the Subscriptions
    option from the left-hand menu.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要为主题创建一个订阅，因此请从左侧菜单中选择订阅选项。
- en: At the top of the screen, select the CREATE SUBSCRIPTION option.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕顶部，选择 CREATE SUBSCRIPTION 选项。
- en: Enter the Subscription ID as `cron-sub`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入订阅 ID 为`cron-sub`。
- en: Enter the Topic name as `projects/<project-id>/topics/cron-topic`, replacing
    `<project-id>` with the Google Cloud project ID on your system.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入主题名称为`projects/<project-id>/topics/cron-topic`，将`<project-id>`替换为你系统中的 Google
    Cloud 项目 ID。
- en: Then select the CREATE button at the bottom of the screen.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后选择屏幕底部的 CREATE 按钮。
- en: 'Finally, we need to define the Cloud Scheduler that will use the Pub/Sub created
    earlier as an endpoint. Each time the Cloud Scheduler task invokes, it will send
    a payload to Pub/Sub:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要定义将使用之前创建的 Pub/Sub 作为端点的 Cloud Scheduler。每次 Cloud Scheduler 任务调用时，它将向
    Pub/Sub 发送负载：
- en: Select the option for Cloud Scheduler (located under Tools) and choose the CREATE
    JOB option.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 Cloud Scheduler 选项（位于工具下），然后选择 CREATE JOB 选项。
- en: 'The result should look similar to the following screen:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果应类似于以下屏幕：
- en: '![](img/3c8d6c37-3feb-4c6b-b0f1-9f3eff03786d.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c8d6c37-3feb-4c6b-b0f1-9f3eff03786d.png)'
- en: 'Complete the fields as per the following table:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写以下表格中的字段：
- en: '| **Field** | **Content** |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **字段** | **内容** |'
- en: '| Name | `cron-task` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | `cron-task` |'
- en: '| Description | `Demonstration of Cloud Scheduler on Google Cloud` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 描述 | `Google Cloud 上 Cloud Scheduler 的演示` |'
- en: '| Frequency | `* * * * *` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 频率 | `* * * * *` |'
- en: '| Time zone | United Kingdom (GMT) |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 时区 | 英国（格林威治标准时间） |'
- en: '| Target | Pub/Sub |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 目标 | Pub/Sub |'
- en: '| Topic | cron-topic |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 主题 | cron-topic |'
- en: '| Payload | `Yeah Cloud Scheduler Rocks` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 负载 | `Yeah Cloud Scheduler Rocks` |'
- en: Once you've finished filling in the preceding fields, select the CREATE button
    to add your Cloud Scheduler task to the list of active jobs.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成填写上述字段后，选择“创建”按钮，将你的 Cloud Scheduler 任务添加到活动作业列表中。
- en: 'The example code will run every minute, but for the sake of brevity, press
    the RUN NOW button. From the Cloud Scheduler Jobs page, you will see the result
    category logged as successful, and it also indicates the last time the job was
    run. If you now look at the Cloud Pub/Sub queue and click on the cron-topic, under
    the View Messages option, you can pull the payload information added in Cloud
    Scheduler. Alternatively, you can use the Cloud Shell to access Pub/Sub subscriptions
    using the `gcloud` command as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码将每分钟运行一次，但为了简洁起见，请按下“立即运行”按钮。从 Cloud Scheduler Jobs 页面，你将看到结果类别被记录为成功，并显示任务最后一次运行的时间。如果你现在查看
    Cloud Pub/Sub 队列并点击 `cron-topic`，在“查看消息”选项下，你可以获取在 Cloud Scheduler 中添加的负载信息。或者，你也可以使用
    Cloud Shell，通过以下 `gcloud` 命令访问 Pub/Sub 订阅：
- en: '[PRE0]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Congratulations! As you can see, Cloud Scheduler enables straightforward integration
    with Pub/Sub, App Engine, and HTTP.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！如你所见，Cloud Scheduler 实现了与 Pub/Sub、App Engine 和 HTTP 的简单集成。
- en: Now that we have discussed the means to initiate both tasks and scheduled activities,
    we can begin to consider more extensive system requirements for processing information
    with functions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了启动任务和调度活动的方法，接下来可以开始考虑使用功能处理信息的更广泛的系统需求。
- en: Introducing Cloud Functions
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Cloud Functions
- en: The Cloud Functions platform provides an effective way to run single-purpose
    code in the cloud. Remember that standalone services remove the need to manage
    a server or its associated runtime. The occurrence of an event notification then
    triggers single-purpose functions. The lightweight Cloud Functions platform then
    provides the basis for event-driven serverless compute.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Functions 平台提供了一种有效的方式，在云中运行单一功能的代码。记住，独立服务不需要管理服务器或其相关的运行时环境。事件通知的发生会触发单一功能。轻量级的
    Cloud Functions 平台为基于事件驱动的无服务器计算提供了基础。
- en: Building single-purpose functions that are independently called provides a highly
    available architecture for building your services. Compounding these functions
    presents an excellent way to extend cloud services. These single-purpose functions
    deliver lightweight components that, in turn, can be a more natural way to maintain
    your application. The simplicity of deployment and maintenance devoid of server
    provisioning and patch/update cycles can be an effective way to design your solution.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 构建独立调用的单一功能提供了一个高度可用的架构，用于构建你的服务。将这些功能组合起来是一种扩展云服务的优秀方式。这些单一功能提供了轻量级组件，从而为维护应用程序提供了一种更自然的方式。没有服务器配置和补丁/更新周期的部署和维护简化，可以成为设计解决方案的有效方式。
- en: The ability to connect to cloud services and interact with different interfaces
    such as webhooks, APIs, and **Internet of Things** (**IoT**) devices is desirable.
    Google has made the interface to Cloud Functions extremely simple to use; you
    can build single-purpose functions that are limited only by your imagination.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 连接云服务并与不同接口（如 Webhooks、API 以及 **物联网**（**IoT**）设备）进行交互的能力是非常理想的。Google 使得 Cloud
    Functions 的接口非常易于使用；你可以构建单一功能，唯一的限制是你的想象力。
- en: Later in the book, we will discuss how to develop code using the Functions Framework
    to create lightweight functions. The Functions Framework is an open source project
    that enables seamless compatibility across several environments (for example,
    Google Cloud Functions, Cloud Run, and Knative). For now, be aware that, when
    building functions, this approach provides an element of compatibility that enables
    you to switch between technology stacks seamlessly.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在书中的后面章节，我们将讨论如何使用Functions Framework开发代码，创建轻量级的函数。Functions Framework是一个开源项目，它可以实现跨多个环境（例如Google
    Cloud Functions、Cloud Run和Knative）的无缝兼容。目前请注意，在构建函数时，这种方法提供了一种兼容性，使你可以在技术栈之间无缝切换。
- en: 'The wide variety of scenarios in which a serverless compute platform deploys
    makes this an attractive offering. Often deployed as the glue between services
    and APIs, Cloud Functions establishes an extensible layer for anyone wishing to
    use Google Cloud in the following areas:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器计算平台广泛的应用场景使其成为一个具有吸引力的选择。通常，它作为服务和API之间的粘合剂被部署，Cloud Functions为任何希望在以下领域使用Google
    Cloud的人提供了一个可扩展的层：
- en: Real-time file processing
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时文件处理
- en: Event-driven extract, transform, and load pipelines
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件驱动的提取、转换和加载管道
- en: Serverless IoT backends
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器IoT后台
- en: Third-party integration via APIs
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过API进行第三方集成
- en: 'Typical use cases might include the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的使用场景可能包括以下内容：
- en: '**The IoT**: Serverless engagement with devices to process information via
    an event stream. Cloud Functions provide a simplistic interface that can provide
    a powerful tool with which to gather and disperse batch or real-time information
    using services such as Cloud Pub/Sub.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物联网（IoT）**：与设备的无服务器交互，通过事件流处理信息。Cloud Functions提供一个简化的接口，可以作为一个强大的工具，用于收集和分发批量或实时信息，利用像Cloud
    Pub/Sub这样的服务。'
- en: '**APIs**: HTTP triggers can design aggregated logic to respond to application
    calls. This lightweight API is perfect to abstract more complex processing in
    the event chain, such as storage or queue requirements. Building an API of this
    type can be achieved with an event-driven interface and over HTTP.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API**：HTTP触发器可以设计聚合逻辑来响应应用程序调用。这种轻量级的API非常适合抽象事件链中更复杂的处理，如存储或队列需求。构建此类API可以通过事件驱动接口和HTTP来实现。'
- en: To illustrate how to create a simple Cloud Functions application, in the next
    section, we will walk through the main steps of this process.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何创建一个简单的Cloud Functions应用程序，在下一节中，我们将详细讲解这个过程的主要步骤。
- en: Developing a Cloud Functions-based application
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发基于Cloud Functions的应用程序
- en: To help build our understanding of the services previously discussed, we will
    develop a small application to utilize these services. Our Cloud Function will
    present a simple web page, in which some web-based information displays the output.
    To illustrate the power of each of the functions previously discussed, each of
    the *Requirement* milestones in the following table will alter and improve the
    overall design incrementally.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们理解之前讨论的服务，我们将开发一个小型应用程序来利用这些服务。我们的Cloud Function将展示一个简单的网页，其中一些基于Web的信息显示输出。为了展示之前讨论的每个函数的强大功能，下面表格中的每个*需求*里程碑将逐步改变并改善整体设计。
- en: Our application will be developed with Google Cloud Functions and will display
    some information on the screen. Incidentally, if you need to host something like
    a static website, this can quickly be done by using a GCS bucket. Storage buckets
    are very versatile. For more information on how to implement them, check the documentation
    at [https://cloud.google.com/storage/docs/static-website](https://cloud.google.com/storage/docs/static-website).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将使用Google Cloud Functions进行开发，并在屏幕上显示一些信息。顺便提一下，如果你需要托管类似静态网站的内容，可以通过使用GCS存储桶快速完成。存储桶非常灵活。有关如何实现它们的更多信息，请查看文档：[https://cloud.google.com/storage/docs/static-website](https://cloud.google.com/storage/docs/static-website)。
- en: 'The application we will develop over the next couple of sections will be an
    RSS reader. Our high-level requirement is to present information from a particular
    site as an HTML web page. Our high-level requirements are as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的几个章节中开发一个RSS阅读器应用程序。我们的高级需求是将来自特定网站的信息以HTML网页的形式呈现。我们的高级需求如下：
- en: '| **Ref** | **Requirement** | **Description** |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| **参考** | **需求** | **描述** |'
- en: '| 1 | Develop a Cloud Function. | Deploy a single function application. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 开发一个Cloud Function。 | 部署一个单一函数应用。 |'
- en: '| 2 | Read content from an RSS site. | For the example, we use a BBC RSS feed.
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 从RSS网站读取内容。 | 以BBC的RSS订阅源为例。 |'
- en: '| 3 | Render data as HTML. | Present the information to be consumed as HTML.
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 将数据渲染为 HTML。 | 将需要消费的信息以 HTML 格式呈现。 |'
- en: '| 4 | Refresh the data. | Enable data to be refreshed on an automated schedule.
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 刷新数据。 | 使数据能够按照自动化的时间表刷新。 |'
- en: Now that we have all our requirements in place, we can progress to building
    our first iteration of the application.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了所有要求，可以继续构建应用程序的第一次迭代。
- en: App version 1 – introducing Cloud Functions
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序版本 1 – 引入 Cloud Functions
- en: 'In this example, we will step through the process for using Cloud Functions
    as the basis for the application. This process consists of the following steps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将一步步演示如何使用 Cloud Functions 作为应用程序的基础。这个过程包括以下步骤：
- en: '**Creating a function**: Start out with a simple Cloud Function.'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建函数**：从一个简单的 Cloud Function 开始。'
- en: '**Adding Functions Framework**: Understand how to add other libraries when
    migrating code to Cloud Shell.'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加函数框架**：了解在将代码迁移到 Cloud Shell 时如何添加其他库。'
- en: '**Deploying the resultant code**: Learn how to deploy code from the command
    line.'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**部署生成的代码**：学习如何通过命令行部署代码。'
- en: Starting with Cloud Functions is made more accessible by the fact that it provides
    template code in several languages. The inclusion of this template code is beneficial
    when starting and enables developers to quickly try out the service without having
    to spend any time setting up an environment.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Cloud Functions 开始变得更加容易，因为它提供了多种语言的模板代码。包含这些模板代码对于开始时非常有帮助，并使开发者能够快速尝试该服务，而不必花时间设置环境。
- en: When working through the high-level requirements, retrieving an RSS feed from
    an external site seems like a critical activity. This task also seems like something
    that should have an existing pattern with which to achieve the desired outcome.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理高层次需求时，从外部网站检索 RSS 源似乎是一个关键活动。这个任务看起来也像是一个已有的模式，可以用来实现所需的结果。
- en: 'As a first development step, it is always worth doing a quick scan of the internet
    for inspiration. For the identified task, there are quite a few existing packages
    capable of accessing an RSS feed. Coming up with an initial design can help us
    to think through what we want to design:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发的第一步，快速浏览一下互联网寻找灵感总是值得的。对于这个任务，有相当多现有的包能够访问 RSS 源。构思一个初步设计有助于我们思考想要设计的内容：
- en: '![](img/e5d49473-c813-44ba-b012-d1c966db899b.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5d49473-c813-44ba-b012-d1c966db899b.png)'
- en: In the preceding diagram, we can see that Cloud Functions is used to access
    the backend RSS data source. Also, users can access an HTTP endpoint to retrieve
    RSS information consumed from the backend.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示意图中，我们可以看到 Cloud Functions 被用来访问后端的 RSS 数据源。同时，用户可以访问 HTTP 端点来检索从后端获取的
    RSS 信息。
- en: The following example will use the Cloud Functions option in Google Cloud. To
    speed up the development cycle, we will use available components to build our
    application and minimize the amount of code we need to write. To handle the RSS
    feed, we will use a pre-existing package to handle all the processing. The package
    also needs to be capable of accessing elements within the RSS feed. In this example,
    I am going to use Node.js; however, feel free to use an alternative language such
    as Python or Go.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将使用 Google Cloud 中的 Cloud Functions 选项。为了加速开发周期，我们将利用现有组件来构建应用程序，并尽量减少需要编写的代码量。为了处理
    RSS 源，我们将使用一个现有的包来处理所有的处理工作。该包还需要能够访问 RSS 源中的元素。在本示例中，我将使用 Node.js；不过，你也可以使用其他语言，如
    Python 或 Go。
- en: 'At this point, we will use Cloud Console to write and deploy code to Cloud
    Functions:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们将使用 Cloud Console 来编写和部署代码到 Cloud Functions：
- en: '![](img/a0daa268-496d-459b-96bb-a48552b30d1e.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a0daa268-496d-459b-96bb-a48552b30d1e.png)'
- en: 'We begin by using the standard boilerplate code provided by Cloud Functions
    to create an application. Using this template will enable the creation of Cloud
    Functions together with different properties:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从使用 Cloud Functions 提供的标准模板代码开始，来创建一个应用程序。使用这个模板可以创建 Cloud Functions 并附加不同的属性：
- en: '![](img/d94397ed-82c6-43ff-90d8-53ee61bf5c71.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d94397ed-82c6-43ff-90d8-53ee61bf5c71.png)'
- en: 'Having selected the Cloud Functions option from Google Cloud Console and then
    opened a new Cloud Function, select Node as the runtime language to have the application
    code pre-populate with the example boilerplate code, as shown in the following
    screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 Google Cloud Console 中的 Cloud Functions 选项并打开一个新的 Cloud Function 后，选择 Node
    作为运行时语言，这样应用程序代码就会预填充示例的模板代码，如下图所示：
- en: '![](img/8430801e-6389-4d71-8ee9-0a546bec2df3.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8430801e-6389-4d71-8ee9-0a546bec2df3.png)'
- en: 'To print some arbitrary text to the console log with Cloud Functions, we can
    do the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 Cloud Functions 将一些任意文本打印到控制台日志中，我们可以执行以下操作：
- en: 'Edit the `index.js` file presented in the Cloud Functions template. We will
    start our application by amending the blueprint code provided by Google and add
    some code to perform the following task:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 Cloud Functions 模板中呈现的 `index.js` 文件。我们将通过修改 Google 提供的蓝图代码并添加一些代码来执行以下任务，来启动我们的应用程序：
- en: '[PRE1]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, we introduce the `console.log` statement, which writes
    information to the logging infrastructure. In the case of Google Cloud, this will
    be Stackdriver Logging.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们引入了 `console.log` 语句，它将信息写入日志基础设施。对于 Google Cloud 来说，这将是 Stackdriver
    Logging。
- en: To deploy the preceding code, we need to click the Create button displayed at
    the bottom of the screen.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要部署前面的代码，我们需要点击屏幕底部显示的“创建”按钮。
- en: Deploying this code results in a `helloRSS` message being returned as the HTTP
    response. In addition, the information will also be available under Stackdriver
    as this acts as a centralized repository for all captured logging.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 部署此代码会返回一个 `helloRSS` 消息作为 HTTP 响应。此外，这些信息还可以在 Stackdriver 中查看，因为它作为所有捕获日志的集中存储库。
- en: To retrieve information from Stackdriver, use a filter on `resource.type = cloud_function`
    to access specific data relating to program execution.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从 Stackdriver 获取信息，请使用 `resource.type = cloud_function` 过滤器来访问与程序执行相关的特定数据。
- en: '[Chapter 2](ff73be02-51ed-4f9a-9181-5cd14fc8bd51.xhtml), *Developing with App
    Engine*, has a section outlining the process of filtering in Stackdriver. Check
    that out if you need a reminder on how to perform this task.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[第二章](ff73be02-51ed-4f9a-9181-5cd14fc8bd51.xhtml)，*使用 App Engine 开发*，有一节内容概述了如何在
    Stackdriver 中进行过滤。如果你需要提醒如何执行这个任务，可以查看这一部分。'
- en: We now have a very basic function. To add to this in the next section, we will
    incorporate some external packages to render a view.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个非常基础的功能。为了在接下来的部分进行扩展，我们将引入一些外部包来渲染视图。
- en: App version 2 – migrating to Cloud Shell
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序版本 2 – 迁移到 Cloud Shell
- en: 'As our code becomes more complex, we should take the opportunity to move our
    development to somewhere more convenient. By convenient, I am, of course, referring
    to the command line. Now that we have seen how to use Cloud Functions from the
    console, our next step is to use Cloud Shell on Google Cloud:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的代码变得更加复杂，我们应该抓住机会将开发迁移到更便捷的地方。这里的“便捷”当然是指命令行。现在我们已经了解了如何通过控制台使用 Cloud Functions，接下来的步骤是使用
    Google Cloud 上的 Cloud Shell：
- en: '![](img/71f8f36d-9981-4694-8e2b-189bfc0e8029.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71f8f36d-9981-4694-8e2b-189bfc0e8029.png)'
- en: When we use Cloud Shell, it will provide lots of helpful tips. For example,
    in the preceding screenshot, Cloud Shell is indicating that it doesn't know which
    Google Cloud project it should be associated with. To remedy this, use the `gcloud
    config set [PROJECT_ID]` command.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 Cloud Shell 时，它会提供许多有用的提示。例如，在前面的截图中，Cloud Shell 表示它不知道应该关联哪个 Google Cloud
    项目。为了解决这个问题，可以使用 `gcloud config set [PROJECT_ID]` 命令。
- en: If you don't know the correct `PROJECT_ID` to include, you can find this information
    on the home screen of the Google Cloud Console under the Project Info heading.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道正确的 `PROJECT_ID`，可以在 Google Cloud Console 的主屏幕下的项目信息部分找到此信息。
- en: 'If you ever get stuck on any of the application code in this book, you can
    also use the code repository version link at the beginning of each chapter. Now
    that we have Cloud Shell open, follow these steps to recreate the application
    from scratch:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在本书中的任何应用程序代码上遇到困难，还可以使用每一章开始时提供的代码库版本链接。现在我们已经打开了 Cloud Shell，按照以下步骤从头开始重建应用程序：
- en: First, make a new directory for your Node code to hold your code. Let's call
    it `ch03`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，为你的 Node 代码创建一个新的目录来存放代码。我们称之为 `ch03`。
- en: In the Cloud Console, two code files, `index.js` and `package.json`, are deployed
    as part of our Cloud Function. The content of each can be observed in the Cloud
    Functions console. Using your favorite editor, we are going to recreate this application.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cloud Console 中，两个代码文件，`index.js` 和 `package.json`，作为我们 Cloud Function 的一部分进行部署。可以在
    Cloud Functions 控制台查看每个文件的内容。使用你喜欢的编辑器，我们将重新创建这个应用程序。
- en: In later chapters, we will look more closely at other options for local development
    but, for now, we will focus on how to migrate our code to Cloud Shell.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续章节中，我们将更详细地讨论本地开发的其他选项，但现在我们将专注于如何将代码迁移到 Cloud Shell。
- en: In the new directory, copy the existing function code for `index.js` from the
    Cloud Functions console window and place this into a new `index.js` file located
    within the `ch03` subdirectory in Cloud Shell.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的目录中，从云函数控制台窗口复制现有的`index.js`函数代码，并将其粘贴到位于Cloud Shell中的`ch03`子目录内的新`index.js`文件中。
- en: Do the same for the `package.json` file and you now should have two source files
    (`index.js` and `package.json`) in your `ch03` development directory.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`package.json`文件做同样的操作，现在你应该在`ch03`开发目录中拥有两个源文件（`index.js`和`package.json`）。
- en: 'In addition, we will also need to install any packages required. Let''s add
    the `functions-framework` package:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们还需要安装任何所需的包。让我们添加`functions-framework`包：
- en: '[PRE2]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you take a sneaky peek at the directory, suddenly we see more than the two
    source files we created. Don't worry about that for now. The critical thing to
    mention is the inclusion of `functions-framework` in the `package.json` configuration
    file. We will cover what this is in more detail in the next chapter on Cloud Functions.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你偷偷查看目录，会突然发现比我们创建的两个源文件还多了文件。别担心，暂时不用关心。需要提到的关键点是，`functions-framework`被包含在`package.json`配置文件中。我们将在下一章关于云函数的内容中更详细地讲解这一点。
- en: Now we have our code nicely packaged in Cloud Shell, we can do fancy things
    such as saving it to a repository to help with version control. But we will continue
    to test that the files are working as expected, which means deploying our code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的代码已经在Cloud Shell中很好地打包好了，我们可以做一些高大上的事情，例如将其保存到版本控制的仓库中。但我们将继续测试文件是否按预期工作，这意味着我们需要部署代码。
- en: 'Let''s stay in the Cloud Shell, using the following command to deploy our code:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续停留在Cloud Shell中，使用以下命令部署我们的代码：
- en: '[PRE3]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You will be asked if you want to allow unauthenticated invocations; answer Yes.
    Excellent, congratulations! You have deployed a Cloud Function named `tempest`
    from the command line! At the moment it doesn't do much, but take a bow anyway.
    Next, we are going to expand the application to do something a bit more useful.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 系统会询问是否允许未经身份验证的调用；请选择“是”。太棒了，恭喜你！你已经通过命令行部署了一个名为`tempest`的云函数！目前它的功能不多，但仍然值得庆祝。接下来，我们将扩展应用程序，让它做一些更有用的事情。
- en: App version 3 – adding a view
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用版本3 – 添加视图
- en: 'In our application, we want to extend the code to read an RSS feed. To build
    upon the existing code, we should incorporate a few additions to move closer to
    our application requirements:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们希望扩展代码以读取RSS源。为了在现有代码的基础上进行构建，我们应该加入一些改进，使其更接近我们的应用需求：
- en: Display some static content.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示一些静态内容。
- en: Utilize an HTTP response to display as HTML page.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用HTTP响应以HTML页面形式展示。
- en: 'To achieve this, we will perform the following steps:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将执行以下步骤：
- en: Introduce an NPM peer package to perform the necessary RSS interaction. A peer
    package is a Node dependency declared in the `package.json` file. Performing a
    quick search of NPM packages shows `rss-parser` as the right choice for our requirements.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引入一个NPM对等包来执行必要的RSS交互。对等包是一个在`package.json`文件中声明的Node依赖项。快速搜索NPM包后，我们发现`rss-parser`正是满足我们需求的理想选择。
- en: An advantage of using a package is that it will include all the relevant information
    about configuration. Node establishes an automatic update of the `package.json`
    file when an install completes. By adding the RSS component, we are quickly able
    to meet the requirement to read RSS feeds with a minimal amount of code.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包的一个好处是，它会包含所有关于配置的相关信息。当安装完成时，Node会自动更新`package.json`文件。通过添加RSS组件，我们能够以最少的代码快速满足读取RSS源的需求。
- en: A good practice to adopt is to check the available source code/library. We should
    never implicitly trust packages and therefore must remain vigilant when incorporating
    third-party code into our projects. Always heed vulnerabilities and warnings displayed
    that relate to security.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一项好的实践是检查可用的源代码/库。我们永远不应盲目相信包，因此在将第三方代码纳入项目时，必须保持警觉。始终留意显示的与安全相关的漏洞和警告。
- en: Looking at the `rss-parser` page on the NPM website ([https://www.npmjs.com/package/rss-parser](https://www.npmjs.com/package/rss-parser)),
    under Versions, we can see that the most current version (at the time of writing)
    is version 3.7.2\.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 查看NPM网站上的`rss-parser`页面（[https://www.npmjs.com/package/rss-parser](https://www.npmjs.com/package/rss-parser)），在版本部分，我们可以看到当前版本（写作时）是3.7.2。
- en: 'From the command line, we can install this package by issuing the following
    command:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行，我们可以通过执行以下命令来安装这个包：
- en: '[PRE4]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now by viewing the `package.json` file, we can see it has been updated to include
    the relevant package and version.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过查看`package.json`文件，我们可以看到它已被更新，以包括相关的包和版本。
- en: '[PRE5]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that the `package.json` file has been updated to incorporate `rss-parser`,
    in the JavaScript file, `index.js`, we will declare a new asynchronous function
    to do all the heavy lifting and retrieve the RSS code to output the results.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在`package.json`文件已经更新以包含`rss-parser`，在JavaScript文件`index.js`中，我们将声明一个新的异步函数来完成所有繁重的工作，并获取RSS代码以输出结果。
- en: We are using an asynchronous function as network calls may take a while to process;
    we don't want to incur an unnecessary delay in the UI processing of the request/response
    life cycle.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用异步函数，因为网络调用可能需要一段时间才能处理；我们不希望在请求/响应生命周期的UI处理上造成不必要的延迟。
- en: In this new function, we first want to introduce the `rss-parser` package ([https://www.npmjs.com/package/rss-parser](https://www.npmjs.com/package/rss-parser))
    to consume the RSS data source by declaring a new object. We also add a new background
    asynchronous function to handle the parsing of the relevant RSS feed.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新函数中，我们首先要引入`rss-parser`包（[https://www.npmjs.com/package/rss-parser](https://www.npmjs.com/package/rss-parser)），通过声明一个新对象来消费RSS数据源。我们还添加了一个新的后台异步函数，用于处理相关的RSS源解析。
- en: We don't pass back this data to the original function, `helloRSS`. Instead,
    we process all network-related activity in the `asyncBBCFeed` function.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再将数据返回给原始函数`helloRSS`，而是将所有与网络相关的活动处理交给`asyncBBCFeed`函数。
- en: 'Add the following code to `index.js` as shown as follows:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`index.js`添加以下代码，如下所示：
- en: '[PRE6]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now update the `helloRSS` function to look like the following code:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在更新`helloRSS`函数，使其如下所示：
- en: '[PRE7]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Back in Cloud Shell, deploy the updated code:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Cloud Shell，部署更新后的代码：
- en: '[PRE8]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once the code is deployed, look at the Cloud Functions interface in the Cloud
    Console. Here we can see the application has been incremented to version 2\. Go
    ahead and trigger the function to see the result of the asynchronous call we added.
    Awesome! Some lovely headlines are retrieved from the RSS feed, as shown in the
    following screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 部署代码后，查看Cloud Console中的Cloud Functions界面。在这里，我们可以看到应用程序的版本已增至2。继续触发该函数，查看我们所添加的异步调用的结果。太棒了！一些漂亮的头条已经从RSS源中提取出来，如下图所示：
- en: '![](img/812654c2-4f9f-472b-841f-052946ffa7d9.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/812654c2-4f9f-472b-841f-052946ffa7d9.png)'
- en: Working with external data sources will be an everyday use case, so it is essential
    to understand how to do this and also to think about crucial aspects of the associated
    design. Iterating to the second version of our application, we want to output
    HTML to our site. Again, this remains an everyday use case and, rather than developing
    additional code, we used an existing Node component to handle the processing for
    us. Introducing an asynchronous task will minimize the associated latency for
    network interactions.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 与外部数据源进行交互将是日常使用的一个场景，因此理解如何操作这一点非常重要，同时也要考虑相关设计的关键方面。在应用程序的第二个版本中，我们希望将HTML输出到我们的网站。同样，这仍然是一个日常使用场景，且我们没有开发额外的代码，而是使用现有的Node组件来为我们处理这一任务。引入异步任务将减少网络交互带来的延迟。
- en: Looking at the code, the HTML remains tightly coupled with the system code,
    so that needs addressing. Before embarking on that particular challenge, it's
    time to move our code from the Cloud Console to the command line. In the next
    section, we start to work with Cloud Shell exclusively.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码来看，HTML与系统代码紧密耦合，因此这需要解决。在开始解决这个特定问题之前，是时候将我们的代码从Cloud Console移到命令行了。在下一部分，我们将专注于仅使用Cloud
    Shell。
- en: App version 4 – decoupling HTML output
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用版本4 – 解耦HTML输出
- en: 'As we now know from working with Node, it means we have access to a wealth
    of packages to do cool stuff. For our application, let''s utilize a package named
    `pug` to render our HTML in a more manageable way. Decoupling the given text from
    the RSS data presents us with an opportunity to display the information in a less
    convoluted way and without having to recode significant elements of the Cloud
    Function:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们现在从使用Node中了解到的，它意味着我们可以访问大量的包来做一些酷的事情。对于我们的应用程序，我们可以使用一个名为`pug`的包，以更可管理的方式渲染HTML。将给定的文本从RSS数据中解耦，给了我们一个机会，以一种不那么复杂的方式展示信息，而无需重新编写Cloud
    Function的主要部分：
- en: 'In Cloud Shell, in line with the previous example, we need to add a new peer
    dependency to the `package.json` file:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Cloud Shell中，按照之前的示例，我们需要向`package.json`文件添加一个新的对等依赖：
- en: '[PRE9]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Pug will enable HTML previously embedded within the JavaScript to be segregated
    into a separate file:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pug 将使先前嵌入在 JavaScript 中的 HTML 被分离到一个单独的文件中：
- en: '[PRE10]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the `index.js` file, we need to add a reference to the `pug` object within
    our application:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `index.js` 文件中，我们需要在应用程序中添加对 `pug` 对象的引用：
- en: '[PRE11]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we initiate a programmatic view (that is, how the page will look) when
    rendered against our HTML output using the `index.pug` file. In the `asyncBBCFeed`
    function add the following:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在渲染 HTML 输出时，使用 `index.pug` 文件启动程序化视图（即页面渲染后的样式）。在 `asyncBBCFeed` 函数中添加以下内容：
- en: '[PRE12]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We also need to update the response object to indicate:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要更新响应对象，以指示：
- en: Successful processing
  id: totrans-189
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功处理
- en: The view to be rendered, that is, `index.pug`
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要渲染的视图，即 `index.pug`
- en: 'Interpolation of values, in our case, the `feed.items` returned from the async
    call:'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值的插值，在我们的例子中，是从异步调用返回的 `feed.items`：
- en: '[PRE13]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Finally, let's get rid of some of the boilerplate code that is no longer required
    to process the feed items.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们来去掉一些不再需要处理 feed 项目的样板代码。
- en: 'After updating the changes outlined in the preceding step, our `index.js` should
    look as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新前面步骤中概述的更改后，我们的 `index.js` 应如下所示：
- en: '[PRE14]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To render a view, we now need to create a new file named `index.pug` within
    the `view` directory and add the following to it:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了渲染视图，我们现在需要在 `view` 目录中创建一个名为 `index.pug` 的新文件，并添加以下内容：
- en: '[PRE15]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Back in Cloud Shell, deploy the updated code:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Cloud Shell，部署更新后的代码：
- en: '[PRE16]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Testing the deployed code should result in the same output as shown in the *App
    version 3 - adding a view* section previously.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 测试已部署的代码应该会产生与前面 *应用版本 3 - 添加视图* 部分中所示的相同输出。
- en: 'However, take note that our application complexity has significantly decreased.
    Also, we haven''t even needed to write much code. Once you have updated the application
    with the preceding code updates, take this opportunity to try another form of
    deployment:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意，我们的应用复杂性显著降低了。而且，我们甚至不需要写太多代码。更新应用程序以应用前面的代码更新后，借此机会尝试另一种部署方式：
- en: From the Cloud Shell, compress the contents of the development directory into
    a ZIP file.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Cloud Shell 压缩开发目录的内容到一个 ZIP 文件中。
- en: Let's make a Cloud Storage bucket in your project (bucket names need to be globally
    unique, so pick one that works for you and replace `[BUCKET_ID]` with your unique
    identifier).
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在你的项目中创建一个 Cloud Storage 存储桶（存储桶名称需要全球唯一，因此选择一个适合你的名称，并将 `[BUCKET_ID]` 替换为你的唯一标识符）。
- en: Upload the file to your bucket.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件上传到你的存储桶。
- en: From the Cloud Function interface, choose the `Create` function and select the
    ZIP file from Cloud Storage.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Cloud Function 界面，选择 `Create` 函数，并从 Cloud Storage 中选择 ZIP 文件。
- en: Select the ZIP file from the bucket location and don't forget to change the
    **function to execute** setting—we are using a function named `helloRSS`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从存储桶位置选择 ZIP 文件，并且不要忘记更改 **执行的函数** 设置——我们使用名为 `helloRSS` 的函数。
- en: Finally, select the Create option and Create a new function option for the code
    taken from the storage bucket.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，选择“创建”选项，并为从存储桶中提取的代码选择“创建新函数”选项。
- en: If you are anything like me, the joy of deploying code manually will be short-lived.
    In this case, using Cloud Build will be of interest to you.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像我一样，手动部署代码的乐趣不会持久。在这种情况下，使用 Cloud Build 会引起你的兴趣。
- en: Working with event processing provides a simple and effective mechanism to set
    up an action to be taken in response to a stimulus. In the initial revision of
    our application, we introduced Cloud Functions. Working with the template code,
    we were able to adapt the system to consume an RSS feed and output the content
    to application logs.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 与事件处理一起工作提供了一种简单有效的机制，用来设置在响应刺激时执行的动作。在我们应用的初步修订中，我们引入了 Cloud Functions。利用模板代码，我们能够将系统适配为消费
    RSS feed，并将内容输出到应用程序日志中。
- en: In the example code, I used the BBC RSS feeds site as the source material because
    it has plenty of options and is a suitably stable site on which to base a demo.
    However, feel free to replace this site with one of your choosing as long as it
    adheres to the same standard specification; this should not impact the code presented.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例代码中，我使用了 BBC RSS Feed 网站作为源材料，因为它有很多选项，且是一个足够稳定的网站，可以作为演示的基础。然而，尽管如此，你可以随意替换这个站点，只要它遵循相同的标准规范，这不应影响所展示的代码。
- en: 'Great job: working on Google Cloud provides a lot of options. In the next section,
    I will set you an optional challenge to build on all the things you have learned
    so far.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 做得很好：在 Google Cloud 上工作提供了很多选择。在下一节中，我将给你一个可选挑战，帮助你在此基础上构建你到目前为止学到的所有内容。
- en: App version 5 – extending the RSS reader
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序版本 5 – 扩展 RSS 阅读器
- en: In this final revision of the application, I am going to set you a challenge!
    Our application can already retrieve RSS feed data and display it as HTML. However,
    it would be nice to have the ability to show even more information and perhaps
    include another feed or two.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序的最终版本中，我将给你一个挑战！我们的应用程序已经可以获取 RSS 源数据并以 HTML 格式显示。然而，如果能够展示更多信息，甚至可能包括另外一个或两个源，那就更好了。
- en: 'By extending the requirements, we now have the following task list:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展需求，我们现在有了以下任务列表：
- en: '| **Ref** | **Requirement** | **Description** |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| **Ref** | **需求** | **描述** |'
- en: '| 1 | Develop a Cloud Function. | Deploy a single function application. |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 开发一个云函数。 | 部署一个单一功能的应用程序。 |'
- en: '| 2 | Read content from an RSS site. | For example, the BBC RSS feed. |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 从 RSS 网站读取内容。 | 例如，BBC 的 RSS 源。 |'
- en: '| 3 | Render data as HTML. | Present the information to be consumed as HTML.
    |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 将数据呈现为 HTML。 | 将信息以 HTML 格式呈现。 |'
- en: '| 4 | Refresh data. | Enable data to be refreshed on an automated schedule.
    |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 刷新数据。 | 使数据能够在自动化计划下进行刷新。 |'
- en: '| 5 | Read content from an RSS site. | Find another RSS site and add it to
    the application. |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 从 RSS 网站读取内容。 | 查找另一个 RSS 网站并将其添加到应用程序中。 |'
- en: '| 6 | Improve the HTML layout. | Add some images to the output and add some
    more data from an RSS feed. |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 改进 HTML 布局。 | 向输出中添加一些图片，并从 RSS 源中添加更多数据。 |'
- en: The majority of the code should already be familiar to you but don't worry if
    it is not. The point of the challenge app is to test your understanding and build
    your confidence so you can take on increasingly complex code.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分代码你应该已经非常熟悉，但如果不熟悉也不用担心。这个挑战应用的目的是测试你的理解力并建立你的信心，让你能够应对越来越复杂的代码。
- en: Remember, if you find it challenging to perform this exercise, a solution can
    be found in the book repository in the `ch03/solution` subdirectory.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你发现这个练习有挑战性，解决方案可以在书籍的代码库中的 `ch03/solution` 子目录下找到。
- en: In this example, do note that building an application within a single function
    can be viewed as an anti-pattern for serverless functions. An alternative approached
    might be to create a reader function for data access, and a presentation function
    for data rendering. This could lead to the state being migrated to other services
    such as Firestore (or even just saved to GCS). Also, the addition of a Cloud Scheduled
    job might be used to refresh the data. The refreshed data might then be stored
    in the backend, such as on Firestore. We could then use a trigger on write for
    an event-driven function to render the updated HTML, possibly even writing the
    data to GCS or some other cache. With this approach serving thousands of frontend
    requests without the slow-down associated with getting the RSS feed, we've decoupled
    our workload into small and easy-to-understand code.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，值得注意的是，构建一个单一功能的应用程序可以被视为无服务器函数的反模式。另一种方法可能是创建一个用于数据访问的读取函数，以及一个用于数据渲染的展示函数。这可能会导致状态迁移到其他服务，例如
    Firestore（甚至只是保存到 GCS）。此外，添加一个 Cloud Scheduled 任务可能用于刷新数据。刷新后的数据可以存储在后端，如 Firestore
    中。然后，我们可以使用写入触发器来触发事件驱动函数，渲染更新后的 HTML，甚至可能将数据写入 GCS 或其他缓存。采用这种方法，在没有获取 RSS 源的延迟情况下，我们可以为成千上万的前端请求提供服务，同时将工作负载解耦成小而易懂的代码。
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Throughout this chapter, you will have realized that building solutions on Google
    Cloud does not require a vast amount of knowledge to get to a **minimum viable
    product** (**MVP**). Investing time to be able to iterate over numerous revisions
    quickly is worthwhile and can lead to significant improvements in the overall
    design.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将会意识到，在 Google Cloud 上构建解决方案并不需要大量的知识就能达到一个**最小可行产品**（**MVP**）。投入时间让自己能够快速迭代多个版本是值得的，并且这能带来整体设计上的显著改进。
- en: Through this chapter, you should now have an appreciation of the nature of the
    services available. You will find it much easier to think about combining different
    products, almost like building blocks. In this regard, it is imperative, at the
    outset, to have a clear view of how the end solution should look. Taking the opportunity
    to build lightweight functions, as opposed to a monolith, can generally simplify
    the overall design; however, be sure that this is what your solution requires.
    As you will now be aware, there are many situations in which serverless event
    processing can be beneficial.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的学习，您现在应该对可用服务的性质有所了解。您会发现，将不同的产品组合在一起，几乎像积木一样，变得更加容易。在这方面，最初清晰地了解最终解决方案的样子至关重要。借此机会构建轻量级函数，而不是单体架构，通常可以简化整体设计；但一定要确保这是您的解决方案所需要的。如您现在所知，有许多场景下，无服务器事件处理是非常有益的。
- en: That concludes our initial overview of the three event processing services for
    serverless workloads. The versatility of the functions discussed fulfills a wide
    variety of use cases. When looking to design an application using these services,
    it is worth considering the desired use. Design iteration is a good thing and
    should bring about better efficiencies in your application. As we move on to more
    complex systems, having a working knowledge of the appropriate use cases and associated
    design patterns will make building systems feel more natural. In the next chapter,
    we will be turning our attention specifically to Cloud Functions. There is lots
    more to cover in terms of usage, and we also need to discuss trigger events that
    make them so useful.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对三种无服务器工作负载事件处理服务的初步概述。所讨论的功能的多功能性满足了各种不同的使用场景。在设计应用程序时，值得考虑预期的使用方式。设计迭代是件好事，应该能带来更好的效率。随着我们进入更复杂的系统，了解适当的使用场景和相关设计模式会让构建系统变得更加自然。在下一章中，我们将专注于云函数。使用方面还有很多内容需要涵盖，我们还需要讨论使它们如此有用的触发事件。
- en: Questions
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Does Cloud Tasks support rate limiting? (True or False)
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 云任务是否支持速率限制？（是或否）
- en: Describe deferred scheduling for Cloud Tasks.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述云任务的延迟调度。
- en: Does Cloud Scheduler support a retry and backoff mechanism? (True or False)
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 云调度器是否支持重试和退避机制？（是或否）
- en: Does Cloud Scheduler operate in a similar way to cron? (True or False)
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 云调度器的工作方式是否与cron类似？（是或否）
- en: What trigger do we use to deploy an HTTP endpoint?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用什么触发器来部署HTTP端点？
- en: Where does Cloud Functions send its logs?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 云函数的日志发送到哪里？
- en: What command enables Cloud Functions to be deployed from the command line?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么命令可以启用从命令行部署云函数？
- en: What is the entry point for Cloud Functions and why is it important?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 云函数的入口点是什么，为什么它很重要？
- en: Further reading
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '**Choosing between Cloud Tasks and Pub/Sub**: [https://cloud.google.com/tasks/docs/comp-pub-sub](https://cloud.google.com/tasks/docs/comp-pub-sub)'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择云任务与Pub/Sub的区别**：[https://cloud.google.com/tasks/docs/comp-pub-sub](https://cloud.google.com/tasks/docs/comp-pub-sub)'
- en: '**Static website examples and tips**: [https://cloud.google.com/storage/docs/static-website](https://cloud.google.com/storage/docs/static-website)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态网站示例与技巧**：[https://cloud.google.com/storage/docs/static-website](https://cloud.google.com/storage/docs/static-website)'
- en: '**The NPM pug package**: [https://www.npmjs.com/package/pug](https://www.npmjs.com/package/pug)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NPM pug包**：[https://www.npmjs.com/package/pug](https://www.npmjs.com/package/pug)'
- en: '**Distributed computing**: [https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式计算**：[https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing)'
