- en: Chapter 10. Controlling containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章 控制容器
- en: '|   | *The inside of a computer is as dumb as hell but it goes like mad!* |
      |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *计算机的内部运作是如此愚笨，但它的速度却快得惊人！* |   |'
- en: '|   | --*Richard Feynman* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*理查德·费曼* |'
- en: In this chapter, we'll look at the emerging topic of **containers** and see
    how it relates to configuration management. We'll see how to use Puppet to manage
    the Docker daemon, as well as images and containers, and explore some different
    strategies for managing configuration within containers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨新兴的**容器**话题，并看看它与配置管理的关系。我们将看到如何使用 Puppet 管理 Docker 守护进程，以及镜像和容器，另外还会探索在容器中管理配置的不同策略。
- en: '![Controlling containers](img/8880_10_01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![控制容器](img/8880_10_01.jpg)'
- en: Understanding containers
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解容器
- en: Although the technology behind containers is at least thirty years old, it's
    only in the last few years that containers have really taken off (to mix a metaphor).
    This is largely thanks to the rise of Docker, a software platform which makes
    it easier to create and manage containers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管容器背后的技术至少已有三十年的历史，但容器真正大规模应用还是近几年的事（为了更形象的比喻，可以说它们终于起飞了）。这主要得益于 Docker 的崛起，Docker
    是一个软件平台，使得创建和管理容器变得更加简便。
- en: The deployment problem
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署问题
- en: 'The problem that Docker solves is principally one of **software deployment**:
    that is, making it possible to install and run your software in a wide variety
    of environments with minimal effort. Let''s take a typical PHP web application,
    for example. To run the application you need at least the following to be present
    on a node:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 解决的问题主要是**软件部署**：也就是说，Docker 使得在各种环境中安装和运行软件变得轻而易举。举个例子，假设有一个典型的 PHP
    web 应用。为了运行这个应用，至少需要以下内容在节点上：
- en: PHP source code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 源代码
- en: PHP interpreter
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 解释器
- en: Its associated dependencies and libraries
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关的依赖项和库
- en: PHP modules required by your application
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序所需的 PHP 模块
- en: Compiler and build tools for building native binaries for PHP modules
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于构建 PHP 模块原生二进制文件的编译器和构建工具
- en: Web server (for example Apache)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web 服务器（例如 Apache）
- en: Module for serving PHP apps (for example, `mod_php`)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于提供 PHP 应用的模块（例如 `mod_php`）
- en: Config files for your application
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的配置文件
- en: User to run the application
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于运行应用程序的用户
- en: Directories for things such as log files, images, and uploaded data
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存放日志文件、图片和上传数据等内容的目录
- en: How do you manage all of this stuff? You can use a system package format, such
    as RPM or DEB, which uses metadata to describe its dependencies in terms of other
    packages, and scripts which can do much of the system configuration required.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何管理这些东西呢？你可以使用系统软件包格式，比如 RPM 或 DEB，这些格式使用元数据来描述它们之间的依赖关系，并且包含能够完成大部分系统配置的脚本。
- en: However, this packaging is specific to a particular version of a particular
    operating system, and a package intended for Ubuntu 18.04, for example, will not
    be installable on Ubuntu 16.04 or on Red Hat Enterprise Linux. Maintaining multiple
    packages for several popular operating systems is a large workload on top of maintaining
    the application itself.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种打包方式是特定于某个操作系统版本的。例如，为 Ubuntu 18.04 打包的程序包无法在 Ubuntu 16.04 或 Red Hat Enterprise
    Linux 上安装。为多个流行操作系统维护多个程序包，将给维护应用程序本身增加很大的工作量。
- en: Options for deployment
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署选项
- en: One way to address this problem is for the author to provide **configuration
    management** **manifests** for the software, such as a Puppet module or a Chef
    recipe to install the software. However, if the intended user of the software
    does not use a CM tool, or uses a different tool, then this is no help. Even if
    they use exactly the same version of the same tool on the same operating system,
    they may have problems integrating the third-party module with it, and the module
    itself will depend on other modules and so on. It's certainly not a turnkey solution.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方式是作者为软件提供**配置管理****清单**，比如 Puppet 模块或 Chef 配方来安装软件。然而，如果软件的预期用户没有使用
    CM 工具，或者使用了不同的工具，那么这种方式就无济于事。即使他们使用的是完全相同版本的相同工具，并且操作系统也是一样的，他们在集成第三方模块时可能仍然会遇到问题，而该模块本身又依赖于其他模块，等等。这显然不是一个即插即用的解决方案。
- en: Another option is the **omnibus package**, a package which contains everything
    the software needs to run. An omnibus package for our example PHP application
    might contain the PHP binaries and all dependencies, plus anything else the application
    needs. These are necessarily quite large packages, however, and omnibus packages
    are still specific to a particular operating system and version, and involve a
    lot of maintenance effort.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是**综合包**，它包含了软件运行所需的一切。举例来说，针对我们 PHP 应用的综合包可能包含 PHP 二进制文件及其所有依赖，还有应用程序需要的其他任何内容。然而，这些包通常非常庞大，而且综合包依然是针对特定操作系统和版本的，并且需要进行大量的维护工作。
- en: Most package managers do not provide an efficient binary update facility, so
    even the smallest update requires re-downloading the entire package. Some omnibus
    packages even include their own config management tool!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数包管理器并没有提供高效的二进制更新功能，因此即使是最小的更新也需要重新下载整个包。一些大型包甚至还包括它们自己的配置管理工具！
- en: Yet another solution is to provide an entire **virtual machine image**, such
    as a Vagrant box (the Vagrant box we've been using throughout the book is a good
    example). This contains not only the application plus dependencies and configuration,
    but the entire operating system as well. This is a fairly portable solution, since
    any platform which can run the virtual machine host software (for example, VirtualBox
    or VMware) can run the VM itself.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是提供整个**虚拟机镜像**，例如 Vagrant box（我们在本书中使用的 Vagrant box 就是一个很好的例子）。这个镜像不仅包含应用程序及其依赖和配置，还包括整个操作系统。这是一个相对便捷的解决方案，因为任何能够运行虚拟机宿主软件的平台（例如
    VirtualBox 或 VMware）都能够运行这个虚拟机。
- en: However, there is a performance penalty with virtual machines, and they also
    consume a lot of resources, such as memory and disk space, and the VM images themselves
    are large and unwieldy to move around a network.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，虚拟机存在性能损失，并且它们也消耗大量资源，如内存和磁盘空间，虚拟机镜像本身体积庞大，且在网络中移动时十分笨重。
- en: While in theory you could deploy your application by building a VM image and
    pushing it to a production VM host, and some people do this, it's far from an
    efficient method of distribution.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然理论上你可以通过构建一个虚拟机镜像并将其推送到生产环境的虚拟机主机来部署你的应用程序，一些人也确实这么做，但这远不是一种高效的分发方法。
- en: Introducing the container
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入容器
- en: In recent years many operating systems have added facilities for self-contained
    execution environments, more concisely called **containers**, in which programs
    can run natively on the CPU, but with very limited access to the rest of the machine.
    A container is like a security sandbox, where anything running inside it can access
    files and programs inside the container, but nothing else.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，许多操作系统增加了自包含执行环境的功能，更简洁地称之为**容器**，在这些环境中，程序可以直接在 CPU 上运行，但对机器其他部分的访问受到严格限制。容器就像一个安全沙箱，里面运行的任何程序只能访问容器内的文件和程序，而无法访问外部资源。
- en: This is similar in principle to a virtual machine, except that the underlying
    technology is quite different. Instead of running on a virtual processor, via
    a software emulation layer, programs in a container run directly on the underlying
    physical hardware. This makes containers a great deal more efficient than VMs.
    To put it another way, you need much less powerful hardware to run containers
    than you do for virtual machines of the same performance.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这在原理上类似于虚拟机，只是底层技术截然不同。容器中的程序不是通过虚拟处理器和软件仿真层运行，而是直接在底层物理硬件上运行。这使得容器比虚拟机更高效。换句话说，运行容器所需的硬件性能远低于运行相同性能虚拟机所需的硬件性能。
- en: A single virtual machine consumes a large amount of its host's resources, which
    means that running more than one VM on the same host can be quite demanding. By
    contrast, running a process inside a container uses no more resources than running
    the same process natively.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 单个虚拟机会消耗大量宿主机的资源，这意味着在同一主机上运行多个虚拟机可能非常消耗资源。相比之下，在容器中运行一个进程所消耗的资源与直接在宿主机上运行相同的进程所消耗的资源没有区别。
- en: Therefore, you can run a very large number of containers on a single host, and
    each is completely self-contained and has no access to either the host, or any
    other container (unless you specifically allow it). A container, at the kernel
    level, is really just a namespace. Processes running in that namespace cannot
    access anything outside it, and vice versa. All the containers on a machine use
    the host operating system's kernel, so although containers are portable across
    different Linux distributions, for example, a Linux container cannot run directly
    on a Windows host. Linux containers can, however, run on Windows using a virtualization
    layer provided by Docker for Windows.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以在单个主机上运行非常多的容器，并且每个容器都是完全自包含的，无法访问主机或任何其他容器（除非您明确允许）。容器在内核层面上其实只是一个命名空间。运行在该命名空间中的进程无法访问外部的任何内容，反之亦然。机器上的所有容器都使用主机操作系统的内核，因此，尽管容器可以在不同的
    Linux 发行版之间移植，但例如 Linux 容器不能直接在 Windows 主机上运行。不过，Linux 容器可以通过 Docker for Windows
    提供的虚拟化层在 Windows 上运行。
- en: What Docker does for containers
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 对容器的作用
- en: 'So if containers themselves are provided by the kernel, what is Docker for?
    It turns out that having an engine is not quite the same thing as having a car.
    The operating system kernel may provide the basic facilities for containerization,
    but you also need:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果容器本身是由内核提供的，Docker 是做什么的呢？事实证明，拥有一个引擎并不等于拥有一辆车。操作系统内核可能提供了容器化的基本设施，但您还需要：
- en: A specification for how to build containers
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建容器的规范
- en: A standard file format for container images
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器镜像的标准文件格式
- en: A protocol for storing, versioning, organizing, and retrieving container images
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存储、版本控制、组织和检索容器镜像的协议
- en: Software to start, run, and manage containers
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动、运行和管理容器的软件
- en: Drivers to allow network traffic to and from containers
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许容器之间网络流量传输的驱动程序
- en: Ways of communicating between containers
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器之间的通信方式
- en: Facilities for getting data into containers
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据传入容器的功能
- en: 'These need to be provided by additional software. There are in fact many software
    frontends which allow you to manage containers: Docker, OCID, CoreOS/rkt, Apache
    Mesos, LXD, VMware Photon, Windows Server Containers, and so on. However, Docker
    is by far the market leader, and currently the majority of containers in production
    are running under Docker (a recent survey put the proportion at over 90%).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些需要通过额外的软件提供。事实上，有许多软件前端可以帮助您管理容器：Docker、OCID、CoreOS/rkt、Apache Mesos、LXD、VMware
    Photon、Windows Server 容器等。然而，Docker 无疑是市场的领导者，目前生产环境中大多数容器都运行在 Docker 下（最近的一项调查显示，比例超过
    90%）。
- en: Deployment with Docker
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 部署
- en: 'The principle of deploying software with containers is very simple: the software,
    plus everything it needs to run, is inside the container **image**, which is like
    a package file, but is executable directly by the container runtime.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器部署软件的原理非常简单：软件及其运行所需的一切都包含在容器 **镜像** 中，镜像类似于一个包文件，但可以直接由容器运行时执行。
- en: 'To run the software, all you need to do is execute a command like the following
    (if you have Docker installed, try it!):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行软件，您只需执行类似下面的命令（如果您已经安装了 Docker，可以尝试一下！）：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Docker will download the specified image from your configured **registry** (this
    could be the public registry, called Docker Hub, or your own private Docker registry)
    and execute it. There are thousands of Docker images available for you to use,
    and many software companies are increasingly using Docker images as their primary
    way to deploy products.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 将从您配置的 **仓库** 中下载指定的镜像（这可以是公共仓库，称为 Docker Hub，或者是您自己的私有 Docker 仓库），并执行它。您可以使用数以千计的
    Docker 镜像，许多软件公司也越来越多地使用 Docker 镜像作为部署产品的主要方式。
- en: Building Docker containers
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 Docker 容器
- en: But where do these Docker images come from? Docker images are like an archive
    or a package file, containing the file and directory layout of all the files inside
    the container, including executable binaries, shared libraries, and config files.
    To create this image file, you use the `docker build` command.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这些 Docker 镜像来自哪里呢？Docker 镜像就像一个存档或包文件，包含容器内部所有文件的文件和目录结构，包括可执行二进制文件、共享库和配置文件。要创建这个镜像文件，您可以使用
    `docker build` 命令。
- en: '`docker build` takes a special text file called a **Dockerfile**, which specifies
    what should be in the container. Usually, a new Docker image is based on an existing
    image with a few modifications. For example, there is a Docker image for Ubuntu
    Linux, which contains a fully-installed operating system ready to run.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker build` 使用一个叫做 **Dockerfile** 的特殊文本文件，该文件指定容器中应该包含什么。通常，一个新的 Docker
    镜像是基于现有镜像，并做了一些修改。例如，有一个 Ubuntu Linux 的 Docker 镜像，它包含了一个已经完全安装的操作系统，可以直接运行。'
- en: Your Dockerfile might specify that you use the Ubuntu Docker image as a starting
    point, and then install the package `nginx`. The resulting Docker container contains
    everything that was in the stock Ubuntu image, plus the `nginx` package. You can
    now upload this image to a registry and run it anywhere using `docker run`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 Dockerfile 可能会指定使用 Ubuntu Docker 镜像作为起点，然后安装 `nginx` 包。最终的 Docker 容器包含了 Ubuntu
    镜像中的所有内容，以及 `nginx` 包。你现在可以将这个镜像上传到注册中心，并使用 `docker run` 在任何地方运行它。
- en: If you wanted to package your own software with Docker, you could choose a suitable
    base image (such as Ubuntu) and write a Dockerfile which installs your software
    onto that base image. When you build the container image with `docker build`,
    the result will be a container with your software inside it, which anyone can
    run using `docker run`. The only thing they need to install is Docker.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想用 Docker 打包自己的软件，你可以选择一个合适的基础镜像（如 Ubuntu），然后编写一个 Dockerfile，将你的软件安装到该基础镜像上。当你使用
    `docker build` 构建容器镜像时，结果将是一个包含你软件的容器，任何人都可以使用 `docker run` 运行。唯一需要安装的就是 Docker。
- en: This makes Docker a great way both for software vendors to package their products
    in an easy-installable format, and for users to try out different software quickly
    to see if it meets their needs.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得 Docker 成为一个非常适合软件供应商将产品打包成易于安装的格式的方式，同时也方便用户快速尝试不同的软件，以查看它是否满足他们的需求。
- en: The layered filesystem
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分层文件系统
- en: The Docker filesystem has a feature called **layering**. Containers are built
    up in layers, so that if something changes, only the affected layer and those
    above it need to be rebuilt. This makes it much more efficient to update container
    images once they've been built and deployed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 文件系统有一个叫做 **分层** 的特性。容器是通过分层构建的，所以如果某些内容发生变化，只有受影响的层和它之上的层需要重新构建。这使得一旦容器镜像被构建并部署后，更新镜像变得更加高效。
- en: For example, if you change one line of code in your app and rebuild the container,
    only the layer that contains your app needs to be rebuilt, along with any layers
    above it. The base image and other layers below the affected layer remain the
    same and can be re-used for the new container.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你在应用程序中更改了一行代码并重建容器，那么只有包含你应用程序的层需要重新构建，以及任何其上方的层。基础镜像和受影响层下方的其他层保持不变，并且可以被新容器重复使用。
- en: Managing containers with Puppet
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Puppet 管理容器
- en: 'There are a few things you need to be able to do to package and run software
    with Docker:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker 打包和运行软件时，你需要能够做到以下几件事：
- en: Install, configure, and manage the Docker service itself
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装、配置和管理 Docker 服务本身
- en: Build your images
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建你的镜像
- en: Rebuild images when the Dockerfile changes, or a dependency is updated
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 Dockerfile 更改或依赖项更新时，重新构建镜像
- en: Manage the running images, their data storage, and their configuration
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理运行中的镜像、它们的数据存储和配置
- en: Unless you want to make your images public, you will also need to host an image
    registry for your own images.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你希望将镜像公开，否则你还需要为自己的镜像托管一个镜像注册中心。
- en: These sound like the kinds of problems that configuration management tools can
    solve, and luckily, we have a great configuration management tool available. Oddly
    enough, while most people recognize that traditional servers need to be built
    and managed automatically by a tool such as Puppet, the same does not seem to
    be true (yet) of containers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些听起来像是配置管理工具可以解决的问题，幸运的是，我们有一个很棒的配置管理工具可用。有趣的是，虽然大多数人都认识到传统的服务器需要由像 Puppet
    这样的工具自动构建和管理，但容器似乎还没有（至少目前）面临同样的需求。
- en: The trouble is, it's so easy to make a simple container and run it that many
    people think configuration management for containers is overkill. That may be
    so when you're first trying out Docker and experimenting with simple containers,
    but when you're running complex, multi-container services in production, at scale,
    things get more complicated.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，制作并运行一个简单的容器太容易了，以至于许多人认为容器的配置管理是多余的。虽然在你首次尝试 Docker 并实验简单容器时可能如此，但当你在生产环境中运行复杂的多容器服务时，规模一大，问题就变得更加复杂。
- en: First, containerizing non-trivial applications is non-trivial. They need dependencies
    and configuration settings and data, and ways to communicate with other applications
    and services, and while Docker provides you with tools to do this, it doesn't
    do the work for you.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将非简单应用程序容器化并非简单。这些应用程序需要依赖项、配置设置和数据，还需要与其他应用程序和服务通信的方式。虽然Docker为你提供了相关工具，但它并不会为你做所有的工作。
- en: Second, you need an infrastructure to build your containers, update them, store
    and retrieve the resulting images, and deploy and manage them in production. Configuration
    management for containers is very much like configuration management for traditional
    server-based applications, except that it's happening at a slightly higher level.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你需要一个基础设施来构建容器、更新容器、存储和检索结果镜像，并在生产环境中部署和管理这些容器。容器的配置管理与传统服务器应用的配置管理非常相似，只是它发生在稍高的层次上。
- en: 'Containers are great, but they don''t do away with the need for configuration
    management tools (remember the *Law of Conservation of Pain* from [Chapter 1](ch01.html
    "Chapter 1. Getting started with Puppet"), *Getting started with Puppet*?):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 容器非常棒，但它们并不能完全取代配置管理工具的需求（还记得[第一章](ch01.html "第一章：使用Puppet入门")中提到的*痛苦守恒定律*吗？）：
- en: '*"If you save yourself pain in one place, it pops up again in another. Whatever
    cool new technology comes along, it won''t solve all our problems; at best, it
    will replace them with refreshingly different problems."*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*“如果你在某个地方避免了痛苦，它会在另一个地方再次出现。无论什么新技术出现，都无法解决我们所有的问题；顶多，它会用不同的、令人耳目一新的问题来取代它们。”*'
- en: Managing Docker with Puppet
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Puppet管理Docker
- en: Puppet can certainly install and manage the Docker service for you, just as
    it can any other software, but it can also do a lot more. It can download and
    run Docker images, build images from Dockerfiles, mount files and directories
    on the container, and manage Docker volumes and networks. We'll see how to do
    all these things in this chapter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet当然可以像管理其他软件一样为你安装和管理Docker服务，但它还能做更多的事情。它可以下载并运行Docker镜像、从Dockerfile构建镜像、挂载容器中的文件和目录，并管理Docker卷和网络。在本章中，我们将学习如何完成这些操作。
- en: Installing Docker
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Docker
- en: Before we do anything else, we'll need to install Docker on our node (using
    Puppet, of course). The `puppetlabs/docker_platform` module is ideal for this.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行其他操作之前，我们需要在节点上安装Docker（当然是使用Puppet）。`puppetlabs/docker_platform`模块非常适合这个目的。
- en: 'If you''ve already installed and run the `r10k` module management tool, as
    shown in [Chapter 7](ch07.html "Chapter 7. Mastering modules"), *Mastering modules*,
    in the *Using r10k* section, the required module will already be installed. If
    not, run the following commands to install it:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你已经安装并运行了`r10k`模块管理工具，如[第七章](ch07.html "第七章：掌握模块")中*使用r10k*部分所示，所需的模块将已经安装。如果没有，请运行以下命令来安装它：
- en: '[PRE1]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once the module is installed, all you need to do to install Docker on your
    node is to apply a manifest like the following (`docker_install.pp`):'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦模块安装完成，你只需应用如下清单（`docker_install.pp`）即可在节点上安装Docker：
- en: '[PRE2]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run the following command to apply the manifest:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以应用清单：
- en: '[PRE3]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To check that Docker is installed, run the following command (you may see a
    different version number, but that''s OK):'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查Docker是否已安装，请运行以下命令（你可能会看到不同的版本号，但没关系）：
- en: '[PRE4]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Running a Docker container
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行Docker容器
- en: In order to run a Docker container, we first of all have to download it from
    a Docker registry, which is a server that stores container images. The default
    registry is Docker Hub, the official public Docker registry.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行一个Docker容器，我们首先需要从Docker注册表中下载它，Docker注册表是一个存储容器镜像的服务器。默认的注册表是Docker Hub，官方的公共Docker注册表。
- en: 'To do this with Puppet, you can use the `docker::image` resource (`docker_image.pp`):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过Puppet实现这一点，可以使用`docker::image`资源（`docker_image.pp`）：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As with the `package` resource, if you specify `ensure => latest`, Puppet will
    check the registry every time it runs and make sure you have the latest available
    version of the image.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与`package`资源一样，如果你指定`ensure => latest`，Puppet每次运行时会检查注册表，并确保你拥有最新版本的镜像。
- en: 'To run the image you''ve just downloaded, add a `docker::run` resource to your
    manifest (`docker_run.pp`):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行刚刚下载的镜像，向清单中添加一个`docker::run`资源（`docker_run.pp`）：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Apply this manifest with the following command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令应用此清单：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `docker::run` resource tells Docker to fetch the image `bitfield/hello`
    from the local image cache and run it with the specified command, which in this
    case just loops forever printing `Hello, world`. (I told you containers were useful.)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker::run` 资源告诉 Docker 从本地镜像缓存中获取 `bitfield/hello` 镜像并运行指定的命令，在本例中，该命令会无限循环并打印
    `Hello, world`。（我告诉过你，容器非常有用。）'
- en: 'The container is now running on your node, and you can check this with the
    following command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 容器现在在你的节点上运行，你可以通过以下命令来检查：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `docker ps` command shows all currently running containers (`docker ps
    -a` will show stopped containers too), with the following information:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker ps` 命令显示所有当前正在运行的容器（`docker ps -a` 也会显示停止的容器），并提供以下信息：'
- en: The container ID, Docker's internal identifier for the container
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器 ID，Docker 对容器的内部标识符
- en: The image name (`bitfield/hello` in our example)
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像名称（在我们的示例中是 `bitfield/hello`）
- en: The currently executing command in the container
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前正在容器中执行的命令
- en: The creation time
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建时间
- en: Current status
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前状态
- en: Any ports mapped by the container
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器映射的所有端口
- en: The human-readable name of the container (which is the title we gave the `docker::run`
    resource in our manifest)
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器的可读名称（即我们在清单中为 `docker::run` 资源指定的标题）
- en: 'The container is running as a service, and we can check that with the following
    command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 容器正在作为服务运行，我们可以通过以下命令来检查：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Stopping a container
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 停止容器
- en: According to the Docker documentation, you can stop a container by running `sudo
    docker stop NAME`. However, if you try this, and then run `sudo docker ps` again,
    you'll see that the container is still running. What's that about?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Docker 文档，你可以通过运行 `sudo docker stop NAME` 来停止容器。但是，如果你尝试这样做，然后再运行 `sudo docker
    ps`，你会看到容器仍在运行。这是怎么回事？
- en: The Puppet module assumes by default that you want to run all containers as
    services; that is, to configure `systemd` to keep the container running, and to
    start it at boot time.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 模块默认假设你希望将所有容器作为服务运行；即配置 `systemd` 以保持容器运行，并在启动时启动它。
- en: 'Therefore, if you want to stop a container which is running as a service, you
    will need to do this with Puppet, by setting the `ensure` parameter on the `docker::run`
    resource to `absent`, as in the following example (`docker_absent.pp`):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你想停止作为服务运行的容器，你需要通过 Puppet 来实现，将 `docker::run` 资源的 `ensure` 参数设置为 `absent`，如下示例所示（`docker_absent.pp`）：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Alternatively, on the command line, you can use the `systemctl` command to
    stop the service:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在命令行中使用 `systemctl` 命令来停止服务：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tip
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you don't want your container to be managed as a service by `systemd`, specify
    the parameter `restart => always` to the `docker::run` resource. This tells Docker
    to restart the container automatically when it exits; so therefore Puppet does
    not need to create a `systemd` service to manage it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不希望容器由 `systemd` 作为服务管理，可以在 `docker::run` 资源中指定参数 `restart => always`。这会告诉
    Docker 在容器退出时自动重启容器；因此，Puppet 不需要创建 `systemd` 服务来管理它。
- en: Running multiple instances of a container
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行多个容器实例
- en: Of course, the true power of automation is the ability to scale. We're not limited
    to running a single instance of a given container; Puppet will happily start as
    many as you like.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，自动化的真正强大之处在于可扩展性。我们不局限于运行单个容器实例；Puppet 会非常乐意启动任意多个容器实例。
- en: 'Each `docker::run` resource must have a unique name, as with any other Puppet
    resource, so you can create them in an `each` loop, as in the following example
    (`docker_run_many.pp`):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `docker::run` 资源必须具有唯一名称，和其他 Puppet 资源一样，所以你可以在 `each` 循环中创建它们，如下示例所示（`docker_run_many.pp`）：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `range()` function comes from the `stdlib` module, and, as you might expect,
    `range(1,20)` returns the sequence of integers between 1 and 20 inclusive. We
    iterate over this sequence with the `each` function, and each time through the
    loop `$instance` is set to the next integer.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`range()` 函数来自 `stdlib` 模块，正如你可能预期的那样，`range(1,20)` 返回的是从 1 到 20（包括 20）之间的整数序列。我们使用
    `each` 函数遍历这个序列，每次循环时，`$instance` 被设置为下一个整数。'
- en: 'The `docker::run` resource title includes the value of `$instance` on each
    iteration, so each container will be uniquely named: `hello-1`, `hello-2`,...
    `hello-20`. I''ve chosen the number 20 at random, just as an example; you could
    compute the number of instances to run based on the resources available, for example
    the number of system CPUs or available memory.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker::run`资源标题在每次迭代时包含`$instance`的值，因此每个容器都会有唯一的名称：`hello-1`、`hello-2`、…
    `hello-20`。我随机选择了数字20，仅作为示例；你可以根据可用资源（例如系统的CPU数量或可用内存）计算要运行的实例数量。'
- en: Don't forget to stop these containers afterward (edit the example manifest to
    add `ensure => absent` to the `docker::run` resource and re-apply it).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了在之后停止这些容器（编辑示例清单，向`docker::run`资源添加`ensure => absent`并重新应用）。
- en: Managing Docker images
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理Docker镜像
- en: Of course, it's very useful to be able to download and run public images from
    Docker Hub or other registries, but to unlock the real power of Docker we need
    to be able to build and manage our own images too.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，从Docker Hub或其他注册中心下载和运行公共镜像是非常有用的，但要解锁Docker的真正威力，我们还需要能够构建和管理我们自己的镜像。
- en: Building images from Dockerfiles
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Dockerfiles构建镜像
- en: As we saw in the previous examples, if you don't already have the specified
    container image on your system, Puppet's `docker::image` resource will pull it
    from Docker Hub for you and save it locally.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的示例中所看到的，如果你的系统中没有指定的容器镜像，Puppet的`docker::image`资源会从Docker Hub拉取该镜像并将其保存在本地。
- en: 'The `docker::image` resource is most useful, however, for actually **building**
    Docker images. This is usually done using a Dockerfile, so here is an example
    Dockerfile we can use to build an image (`Dockerfile.hello`):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`docker::image`资源最常用的功能是**构建**Docker镜像。这通常是通过Dockerfile来完成的，下面是一个我们可以用来构建镜像的示例Dockerfile（`Dockerfile.hello`）：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `FROM` statement tells Docker what base image to start from, of the many
    public images available. `FROM scratch` would start with a completely empty container.
    `FROM library/ubuntu` would use the official Ubuntu Docker image.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM`语句告诉Docker从许多可用的公共镜像中选择一个作为基础镜像。`FROM scratch`会从一个完全空的容器开始。`FROM library/ubuntu`则会使用官方的Ubuntu
    Docker镜像。'
- en: Of course, one of the key advantages of containers is that they can be as small
    or as large as they need to be, so downloading a 188 MB image containing all of
    Ubuntu is unnecessary if you simply want to run `/bin/echo`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，容器的一个主要优势是它们可以根据需要小到多小，大到多大，因此如果你只需要运行`/bin/echo`，下载包含整个Ubuntu的188MB镜像是没有必要的。
- en: Alpine is another Linux distribution designed to be as small and lightweight
    as possible, which makes it ideal for containers. The `library/alpine` image is
    only 4 MB, forty times smaller than `ubuntu`; quite a saving. Also, if you build
    all your containers from the same base image, Docker's layer system means it only
    has to download and store the base image once.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Alpine是另一种Linux发行版，旨在尽可能小巧和轻量化，非常适合用于容器。`library/alpine`镜像仅有4MB，比`ubuntu`小四十倍；这节省了大量空间。此外，如果你从相同的基础镜像构建所有容器，Docker的分层系统意味着它只需要下载和存储基础镜像一次。
- en: Tip
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Dockerfiles can be fairly simple, as in the example, or quite complex. You
    can find out more about the Dockerfile format and commands from the Docker documentation:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile可以非常简单，如本示例，或者非常复杂。你可以通过Docker文档了解更多关于Dockerfile格式和命令的内容：
- en: '[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)'
- en: 'The following code shows how to create a Docker image from this file (`docker_build_hello.pp`):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何从这个文件创建一个Docker镜像（`docker_build_hello.pp`）：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once the `docker::image` resource has been applied, the resulting `pbg-hello`
    image will be available for you to run as a container (`docker_run_hello.pp`):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`docker::image`资源被应用，生成的`pbg-hello`镜像将可以用于以容器形式运行（`docker_run_hello.pp`）：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Managing Dockerfiles
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理Dockerfiles
- en: 'When you run your own apps in containers, or third-party apps in your own containers,
    you can manage the associated Dockerfiles with Puppet. Here''s an example of a
    simple Dockerfile which builds a container using Nginx to serve a web page with
    a friendly greeting message (`Dockerfile.nginx`):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在容器中运行自己的应用程序，或者在自己的容器中运行第三方应用程序时，你可以通过Puppet管理相关的Dockerfile。下面是一个简单的Dockerfile示例，它构建一个使用Nginx来提供带有友好问候信息的网页的容器（`Dockerfile.nginx`）：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here''s the Puppet manifest which manages this Dockerfile, and builds an image
    from it (`docker_build_nginx.pp`):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是管理此Dockerfile并从中构建镜像的Puppet清单（`docker_build_nginx.pp`）：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run the following command to apply this manifest:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以应用此清单：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Whenever the contents of the Dockerfile change, applying this manifest will
    cause the image to be rebuilt.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 每当Dockerfile的内容发生更改时，应用此清单将导致镜像被重建。
- en: Tip
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For the purposes of this example we are building and running the container on
    the same node. In practice, though, you should build your containers on a dedicated
    build node and upload the resulting images to the registry, so that your production
    nodes can download and run them.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 出于本示例的目的，我们在同一节点上构建并运行容器。然而，在实际应用中，你应该在专用的构建节点上构建容器，并将生成的镜像上传到注册表，这样生产节点就可以下载并运行它们。
- en: 'Here''s the manifest to run the container we just built (`docker_run_nginx.pp`):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行我们刚刚构建的容器的清单（`docker_run_nginx.pp`）：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Tip
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note the `pull_on_start` attribute, which tells Puppet to always download the
    latest available version of the container when starting or restarting it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`pull_on_start`属性，它告诉Puppet在启动或重新启动容器时始终下载最新版本的容器。
- en: 'If you worked through [Chapter 7](ch07.html "Chapter 7. Mastering modules"),
    *Mastering modules*, the Apache web server will be running and listening on port
    `80`, so you will need to run the following commands to remove it before applying
    this manifest:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你完成了[第7章](ch07.html "第7章 掌握模块")，*掌握模块*，Apache Web服务器将运行并监听端口`80`，因此你需要运行以下命令将其移除，然后再应用此清单：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can check that the container is working by browsing to the following URL
    on your local machine:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在本地机器上访问以下URL来检查容器是否正常工作：
- en: '`http://localhost:8080`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:8080`'
- en: You should see the text `Hello, world`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到文本`Hello, world`。
- en: Tip
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you''re using the Vagrant box, port `8080` on your local machine is automatically
    mapped to port `80` on the VM, which is then mapped by Docker to port `80` on
    the `pbg-nginx` container. If for some reason you need to change this port mapping,
    edit your Vagrantfile (in the Puppet Beginner''s Guide repo) and look for the
    following line:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Vagrant box，本地机器上的端口`8080`将自动映射到虚拟机的端口`80`，然后Docker将其映射到`pbg-nginx`容器的端口`80`。如果由于某种原因你需要更改此端口映射，请编辑你的Vagrantfile（在Puppet初学者指南仓库中）并查找以下行：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Change these settings as required, and run the following command on your local
    machine in the PBG repo directory:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需要更改这些设置，并在本地机器的PBG仓库目录中运行以下命令：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you''re not using the Vagrant box, the container''s port `80` will be exposed
    at your local port `80`, so the URL will simply appear as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用Vagrant box，容器的端口`80`将暴露在本地端口`80`上，所以URL将简单地显示如下：
- en: '`http://localhost`'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost`'
- en: Building dynamic containers
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建动态容器
- en: Although Dockerfiles are a fairly powerful and flexible way of building containers,
    they are only static text files, and very often you will need to pass information
    into the container to tell it what to do. We might call such containers—whose
    configuration is flexible and based on data available at build time—**dynamic
    containers**.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Dockerfile是一种相当强大和灵活的构建容器的方式，但它们只是静态文本文件，通常你需要将信息传递到容器中，告诉它该做什么。我们可以称这些容器为——其配置灵活并基于构建时可用的数据——**动态容器**。
- en: Configuring containers with templates
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模板配置容器
- en: One way to configure containers dynamically is to use Puppet to manage the Dockerfile
    as an EPP template (see [Chapter 9](ch09.html "Chapter 9. Managing files with
    templates"), *Managing files with templates*), and interpolate the required data
    (which could come from Hiera, Facter, or directly from Puppet code).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 配置容器的一个方法是使用Puppet管理Dockerfile作为EPP模板（参见[第9章](ch09.html "第9章 管理文件与模板")，*管理文件与模板*），并插入所需的数据（这些数据可能来自Hiera、Facter或直接来自Puppet代码）。
- en: Let's upgrade our previous `Hello, world` example to have Nginx serve any arbitrary
    text string, supplied by Puppet at build time.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们升级之前的`Hello, world`示例，让Nginx在构建时由Puppet提供任何任意的文本字符串。
- en: 'Here''s the manifest to generate the Dockerfile from a template and run the
    resulting image (`docker_template.pp`):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从模板生成Dockerfile并运行生成的镜像的清单（`docker_template.pp`）：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Apply this manifest with the following commands:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令应用此清单：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When you have applied the manifest and built the container, you will find that
    if you change the value of `message` and reapply, the container will be rebuilt
    with the updated text. The `docker::image` resource uses `notify` to tell the
    `docker::run` resource to restart the container when the image changes.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当你应用了清单并构建了容器时，你会发现如果你更改 `message` 的值并重新应用，容器将会使用更新后的文本重新构建。`docker::image`
    资源使用 `notify` 告诉 `docker::run` 资源在镜像变化时重启容器。
- en: Tip
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Templating the Dockerfile like this is a powerful technique. Since you can
    have Puppet put any arbitrary data into a Dockerfile, you can configure anything
    about the container and its build process: the base image, the list of packages
    to install, files and data that should be added to the container, and even the
    command entry point for the container.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样模板化 Dockerfile 是一种强大的技术。因为你可以让 Puppet 将任何任意数据放入 Dockerfile 中，你可以配置容器及其构建过程的任何内容：基础镜像、安装的软件包列表、应添加到容器中的文件和数据，甚至是容器的命令入口点。
- en: Self-configuring containers
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自配置容器
- en: Let's take this idea even further and use Puppet to dynamically configure a
    container which can fetch its data from Git. Instead of serving static text supplied
    at build time, we will have the container itself check out a Git repo for the
    website.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步拓展这个思路，使用 Puppet 动态配置一个可以从 Git 获取数据的容器。我们不再像构建时那样提供静态文本，而是让容器本身从 Git 仓库中检出网站内容。
- en: 'Most of the code from the previous example remains unchanged, except for the
    Dockerfile resource (`docker_website.pp`):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个示例中的大部分代码保持不变，唯一不同的是 Dockerfile 资源（`docker_website.pp`）：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The Dockerfile itself is a little more complicated, because we need to install
    Git in the container and use it to check out the supplied Git repo (`Dockerfile.website.epp`):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 本身稍微复杂一些，因为我们需要在容器中安装 Git，并使用它来检出提供的 Git 仓库（`Dockerfile.website.epp`）：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When you apply this manifest and browse to `http://localhost:8080`, you should
    see the text:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当你应用这个清单并访问`http://localhost:8080`时，你应该会看到如下文本：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Although we supplied the `git_url` parameter directly to the Dockerfile template,
    that data could of course come from anywhere, including Hiera. With this technique,
    you can build a container to serve any website simply by changing the Git URL
    passed to it.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们直接将 `git_url` 参数传递给 Dockerfile 模板，但这些数据当然可以来自任何地方，包括 Hiera。使用这种技术，你只需更改传递给它的
    Git URL 就可以构建一个容器来服务任何网站。
- en: Using the iteration pattern we saw in the `docker_run_many` example earlier
    in this chapter, you could build a set of containers like this from an array of
    `git_url` values, each serving a different website. Now we're really starting
    to exploit the power of Docker-plus-Puppet.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们在本章前面看到的 `docker_run_many` 示例中的迭代模式，你可以从一组 `git_url` 值中构建一组容器，每个容器服务一个不同的网站。现在我们真正开始发挥
    Docker 和 Puppet 的强大功能了。
- en: 'Run the following command to stop the container before going on to the next
    example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续下一个示例之前，运行以下命令停止容器：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There's one slight problem with this idea. Although it's good to have the container
    be able to serve content from a Git repo determined at build time, every time
    the container is started or restarted, it will have to run the `git clone` process
    again. This takes time, and if the repo or the network is unavailable for some
    reason, it can stop the container from working.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法有一个小问题。尽管让容器能够在构建时确定的 Git 仓库中提供内容是很好的，但每次容器启动或重启时，它都必须再次执行 `git clone` 过程。这需要时间，并且如果由于某些原因仓库或网络不可用，可能会导致容器无法正常工作。
- en: A better solution would be to serve the content from persistent storage, and
    we'll see how to do that in the next section.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的解决方案是从持久化存储中提供内容，我们将在下一节中看到如何做到这一点。
- en: Persistent storage for containers
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器的持久化存储
- en: Containers are designed to be transient; they run for a while, and then disappear.
    Anything inside the container disappears with it, including files and data created
    during the container's run. This isn't always what we want, of course. If you're
    running a database inside a container, for example, you usually want that data
    to persist when the container goes away.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 容器被设计为临时的；它们运行一段时间后就消失。容器内的任何东西都会随着容器的消失而消失，包括容器运行期间创建的文件和数据。当然，这并不是我们总是希望的结果。例如，如果你在容器中运行数据库，通常你希望容器消失后数据能够持久保存。
- en: 'There are two ways of persisting data in a container: the first is to mount
    a directory from the host machine inside the container, known as a **host-mounted
    volume**, and the second is to use what''s called a **Docker volume**. We''ll
    look at both of these in the following sections.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以在容器中持久化数据：第一种是从主机机器挂载一个目录到容器内，这种方式被称为 **主机挂载卷**；第二种是使用所谓的 **Docker 卷**。我们将在以下章节中讨论这两种方法。
- en: Host-mounted volumes
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主机挂载卷
- en: 'If you want a container to be able to access files on the host machine''s filesystem
    (such as application code that you''re working on and you want to test, for example),
    the easiest way to do that is to mount a directory from the host on the container.
    The following example shows how to do this (`docker_mount.pp`):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望容器能够访问主机机器的文件系统上的文件（例如，你正在工作的应用程序代码，且希望进行测试），最简单的方法是将主机上的目录挂载到容器中。以下示例演示了如何做到这一点（`docker_mount.pp`）：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `volumes` attribute specifies an array of volumes to attach to the container.
    If the volume is of the form `HOST_PATH:CONTAINER_PATH`, Docker will assume you
    want to mount the directory `HOST_PATH` on the container. The path inside the
    container will be `CONTAINER_PATH`. Any files which already exist in the mounted
    directory will be accessible to the container, and anything the container writes
    to the directory will still be available once the container has stopped.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`volumes` 属性指定了要附加到容器的卷的数组。如果卷的形式是 `HOST_PATH:CONTAINER_PATH`，Docker 会假定你想要将主机上的目录
    `HOST_PATH` 挂载到容器中，容器中的路径将是 `CONTAINER_PATH`。挂载目录中已经存在的任何文件将对容器可访问，容器写入该目录的任何内容，在容器停止后仍然可用。'
- en: If you apply this example manifest, the container will mount the host machine's
    `/tmp/container_data/` directory (this will be created if it doesn't exist) as
    `/mnt/data/` in the container.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用此示例清单，容器将挂载主机机器的 `/tmp/container_data/` 目录（如果该目录不存在，将会创建）到容器中的 `/mnt/data/`。
- en: The `command` attribute tells the container to write the string `Hello, world`
    to the file `/mnt/data/hello.txt`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`command` 属性告诉容器将字符串 `Hello, world` 写入文件 `/mnt/data/hello.txt`。'
- en: 'Run the following command to apply this manifest:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以应用此清单：
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The container will start, write the data, and then exit. If all has gone well,
    you''ll see that the file `/tmp/container_data/hello.txt` is now present and contains
    the data written by the container:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 容器将启动，写入数据，然后退出。如果一切顺利，你会看到文件 `/tmp/container_data/hello.txt` 现在已经存在，并包含容器写入的数据：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Host-mounted volumes are very useful when a container needs to access or share
    data with applications running on the host machine. For example, you could use
    a host-mounted volume with a container which runs syntax checks, lint, or continuous
    integration tests on your source code directory.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 主机挂载的卷在容器需要访问或与主机机器上运行的应用程序共享数据时非常有用。例如，你可以使用一个主机挂载的卷，与一个容器一起运行语法检查、代码检查或持续集成测试，针对你的源代码目录进行操作。
- en: However, containers using host-mounted volumes are not portable, and they rely
    on a specific directory being present on the host machine. You can't specify a
    host-mounted volume in a Dockerfile, so you can't publish a container which relies
    on one. While host-mounted volumes can be useful for testing and development,
    a better solution in production is to use Docker volumes.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用主机挂载卷的容器不可移植，它们依赖于主机机器上存在特定的目录。你无法在 Dockerfile 中指定主机挂载卷，因此你不能发布一个依赖于主机挂载卷的容器。尽管主机挂载卷在测试和开发中可能很有用，但在生产环境中，更好的解决方案是使用
    Docker 卷。
- en: Docker volumes
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 卷
- en: A more portable way of adding persistent storage to containers is to use a **Docker
    volume**. This is a persistent data object which lives in Docker's storage area
    and can be attached to one or more containers.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一种为容器添加持久存储的更具移植性的方法是使用 **Docker 卷**。这是一种持久的数据对象，存储在 Docker 的存储区域内，并可以附加到一个或多个容器。
- en: 'The following example shows how to use `docker::run` to start a container with
    a Docker volume (`docker_volume.pp`):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何使用 `docker::run` 启动一个带有 Docker 卷（`docker_volume.pp`）的容器：
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Tip
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `volumes` attribute is a little different from the previous example. It
    has the form `VOLUME_NAME:CONTAINER_PATH`, which tells Docker that this is not
    a host-mounted volume, but a Docker volume named `VOLUME_NAME`. If the value before
    the colon is a path, Docker assumes you want to mount that path from the host
    machine, but otherwise, it assumes you want to mount a Docker volume with the
    specified name.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`volumes`属性与前面的例子稍有不同。它的形式为`VOLUME_NAME:CONTAINER_PATH`，这告诉 Docker 这不是一个主机挂载卷，而是一个名为`VOLUME_NAME`的
    Docker 卷。如果冒号前的值是路径，Docker 假定你想从主机机器挂载该路径，否则，它假定你想挂载一个具有指定名称的 Docker 卷。'
- en: As in the previous example, the container's `command` argument writes a message
    to a file on the mounted volume.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，容器的`command`参数将消息写入挂载卷上的文件。
- en: 'If you apply this manifest, once the container has exited, you can see that
    the volume is still present by running the following command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你应用此清单，一旦容器退出，你可以运行以下命令查看卷是否仍然存在：
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: A Docker volume is a good way to store data that you need to keep even when
    the container is not running (a database, for example). It's also a good way to
    make data available to containers without having to load it into each container
    every time it starts.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 卷是一种存储数据的好方式，即使容器不运行时也需要保留这些数据（例如数据库）。它也是一种让数据对容器可用的好方式，无需每次容器启动时都加载数据。
- en: In the website example earlier in the chapter, instead of each container checking
    out its own copy of the Git repo, you could check out the repo into a Docker volume,
    and then have each container mount this volume when it starts.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早些时候的 Web 网站示例中，与你让每个容器检出自己的 Git 仓库副本不同，你可以将仓库检出到一个 Docker 卷中，然后让每个容器在启动时挂载该卷。
- en: 'Let''s test that idea with the following manifest (`docker_volume2.pp`):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下清单（`docker_volume2.pp`）测试这个想法：
- en: '[PRE34]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is the same `nginx` container we used earlier in the chapter, which serves
    whatever is in its `/usr/share/nginx/html` directory as a website.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在本章早些时候使用的相同`nginx`容器，它将其`/usr/share/nginx/html`目录中的内容作为网站提供。
- en: The `volumes` attribute tells the container to mount the `pbg-volume` volume
    on `/usr/share/nginx/html`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`volumes`属性告诉容器将`pbg-volume`卷挂载到`/usr/share/nginx/html`。'
- en: 'Run the following commands to apply this manifest:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以应用此清单：
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If everything works as we expect, we should able to browse to the following
    URL on the local machine: `http://localhost:8080/`'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切按预期工作，我们应该能够在本地机器上浏览以下 URL：`http://localhost:8080/`
- en: 'We should see the following text:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到以下文本：
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is a very powerful feature of containers. They can read, write, and modify
    data created by other containers, maintain persistent storage of their own, and
    share data with other running containers, all using volumes.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这是容器的一个非常强大的功能。它们可以读取、写入和修改由其他容器创建的数据，保持自己的持久化存储，并通过卷与其他正在运行的容器共享数据。
- en: A common pattern for running applications in Docker is to use multiple, communicating
    containers, each providing a single specific service. For example, a web application
    might use an Nginx container to serve an application to users, while storing its
    session data in a MySQL container mounting a persistent volume. It could also
    use a linked Redis container as an in-memory key-value store.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 中运行应用程序的常见模式是使用多个相互通信的容器，每个容器提供一个特定的服务。例如，一个 Web 应用程序可能使用 Nginx 容器向用户提供应用程序，同时将会话数据存储在一个
    MySQL 容器中，该容器挂载了一个持久化卷。它还可以使用链接的 Redis 容器作为内存中的键值存储。
- en: Apart from sharing data via volumes, though, how do these containers actually
    communicate over the network? We'll see the answer to that in the next section.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过卷共享数据之外，这些容器如何通过网络进行通信呢？我们将在下一节看到答案。
- en: Networking and orchestration
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络与调度
- en: 'We started off the chapter by saying that containers are completely self-contained,
    and have no access to each other, even if they''re running on the same host. But
    to run real applications, we need containers to communicate. Fortunately, there
    is a way to do this: the **Docker network**.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章开始时说过，容器是完全自包含的，彼此之间没有访问权限，即使它们在同一主机上运行。但为了运行真正的应用程序，我们需要容器之间进行通信。幸运的是，有一种方法可以做到这一点：**Docker
    网络**。
- en: Connecting containers
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接容器
- en: 'A Docker network is like a private chat room for containers: all the containers
    inside the network can talk to each other, but they can''t talk to containers
    outside it or in other networks, and vice versa. All you need to do is have Docker
    create a network, give it a name, and then you can start containers inside that
    network and they will be able to talk to each other.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Docker网络就像是容器的私人聊天室：网络内的所有容器可以相互通信，但它们不能与网络外或其他网络中的容器通信，反之亦然。你只需要让Docker创建一个网络，给它命名，然后就可以在这个网络内启动容器，容器们就能相互通信。
- en: Let's develop an example to try this out. Suppose we want to run the Redis database
    inside a container, and send data to it from another container. This is a common
    pattern for many applications.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开发一个示例来试验一下。假设我们想在容器中运行Redis数据库，并从另一个容器向其发送数据。这是许多应用程序的常见模式。
- en: In our example, we're going to create a Docker network, and start two containers
    inside it. The first container is a public Docker Hub image that will run the
    Redis database server. The second container will install the Redis client tool,
    and write some data to the Redis server container. Then, to check it worked, we
    can try to read the data back from the server.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将创建一个Docker网络，并在其中启动两个容器。第一个容器是一个公共的Docker Hub镜像，将运行Redis数据库服务器。第二个容器将安装Redis客户端工具，并将一些数据写入Redis服务器容器。然后，为了检查是否成功，我们可以尝试从服务器读取数据。
- en: 'Run the following command to apply the Docker network example manifest:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令应用Docker网络示例清单：
- en: '[PRE37]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If everything worked as it should, our Redis database should now contain a piece
    of data named `message` containing a friendly greeting, proving that we've passed
    data from one container to another over the Docker network.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切按预期工作，我们的Redis数据库现在应该包含一个名为`message`的字段，里面有一条友好的问候信息，证明我们已经通过Docker网络将数据从一个容器传输到另一个容器。
- en: 'Run the following command to connect to the client container and check that
    this is the case:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令连接到客户端容器并检查情况：
- en: '[PRE38]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'So how does it all work? Let''s take a look at the example manifest. First
    of all, we create the network for the two containers to run in, using the `docker_network`
    resource in Puppet (`docker_network.pp`):'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 那么它是如何工作的呢？让我们看看示例清单。首先，我们使用Puppet中的`docker_network`资源（`docker_network.pp`）为两个容器创建网络：
- en: '[PRE39]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, we run the Redis server container, using the public `redis:4.0.1-alpine`
    image.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们运行Redis服务器容器，使用公开的`redis:4.0.1-alpine`镜像。
- en: '[PRE40]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Did you notice that we supplied the `net` attribute to the `docker::run` resource?
    This specifies the Docker network that the container should run in.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到我们为`docker::run`资源提供了`net`属性吗？这指定了容器应该运行的Docker网络。
- en: Next, we build a container which has the Redis client (`redis-cli`) installed
    so that we can use it to write some data to the Redis container.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们构建一个安装了Redis客户端（`redis-cli`）的容器，这样我们就可以用它向Redis容器写入一些数据。
- en: 'Here''s the Dockerfile for the client container (`Dockerfile.pbg-demo`):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这是客户端容器的Dockerfile（`Dockerfile.pbg-demo`）：
- en: '[PRE41]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We build this container in the usual way using `docker::image`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过常规方式使用`docker::image`构建这个容器：
- en: '[PRE42]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Finally, we run an instance of the client container with `docker::run`, passing
    in a command to `redis-cli` to write some data to the other container.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`docker::run`运行客户端容器的实例，并传入一个命令给`redis-cli`，将一些数据写入另一个容器。
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As you can see, this container also has the attribute `net => 'pbg-net'`. It
    will therefore run in the same Docker network as the `pbg-redis` container, so
    the two containers will be able to talk to each other.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个容器也有`net => 'pbg-net'`属性。因此，它将在与`pbg-redis`容器相同的Docker网络中运行，两个容器将能够互相通信。
- en: 'When the container starts, the `command` attribute calls `redis-cli` with the
    following command:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器启动时，`command`属性调用`redis-cli`并执行以下命令：
- en: '[PRE44]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `-h pbg-redis` argument tells Redis to connect to the host `pbg-redis`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`-h pbg-redis`参数告诉Redis连接到主机`pbg-redis`。'
- en: Note
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: How does using the `pbg-redis` name connect to the right container? When you
    start a container inside a network, Docker automagically configures DNS lookups
    within the container to find other containers in the network by name. When you
    reference a container name (the title of the container's `docker::run` resource,
    which in our example is `pbg-redis`), Docker will route the network connection
    to the right place.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pbg-redis`名称是如何连接到正确的容器的？当你在网络中启动一个容器时，Docker 会自动配置容器内的 DNS 查找，以便通过名称找到网络中的其他容器。当你引用一个容器名称（即容器的`docker::run`资源的标题，在我们的例子中是`pbg-redis`）时，Docker
    会将网络连接路由到正确的位置。
- en: The command `set message "Hello, world"` creates a Redis key named `message`,
    and gives it the value `"Hello, world"`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 命令`set message "Hello, world"`创建了一个名为`message`的 Redis 键，并赋值为`"Hello, world"`。
- en: 'We now have all the necessary techniques to containerize a real application:
    using Puppet to manage multiple containers, built from dynamic data, pushed to
    a registry, updated on demand, communicating over the network, listening on ports
    to the outside world, and persisting and sharing data via volumes.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有了容器化一个真实应用所需的所有技术：使用 Puppet 管理多个容器，这些容器由动态数据构建，推送到注册表，按需更新，通过网络通信，监听外部端口，并通过卷持久化和共享数据。
- en: Container orchestration
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器编排
- en: We've seen a number of ways to manage individual containers in this chapter,
    but the question of how to provision and manage containers at scale, and across
    multiple hosts—what we call container **orchestration**—remains.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到了一些管理单个容器的方法，但如何在大规模和跨多个主机上配置和管理容器——我们称之为容器**编排**——的问题仍然存在。
- en: 'For example, if your app runs in a container, you probably won''t be running
    just one instance of the container: you need to run multiple instances, and route
    and load-balance traffic to them. You also need to be able to distribute your
    containers across multiple hosts, so that the application is resilient against
    the failure of any individual container host.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的应用运行在容器中，你可能不会仅仅运行一个容器实例：你需要运行多个实例，并将流量路由和负载均衡到它们。你还需要能够将容器分布到多个主机上，以便应用能够抵御任何单个容器主机的故障。
- en: What is orchestration?
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是编排？
- en: When running containers across a distributed cluster, you also need to be able
    to deal with issues such as networking between containers and hosts, failover,
    health monitoring, rolling out updates, service discovery, and sharing configuration
    data between containers via a key-value database.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当在分布式集群中运行容器时，你还需要能够处理诸如容器和主机之间的网络连接、故障转移、健康监控、滚动更新、服务发现以及通过键值数据库在容器间共享配置数据等问题。
- en: 'Although container orchestration is a broad task, and different tools and frameworks
    focus on different aspects of it, the core requirements of orchestration include:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管容器编排是一个广泛的任务，不同的工具和框架侧重于它的不同方面，但编排的核心要求包括：
- en: '**Scheduling**: Running a container on the cluster and deciding which containers
    to run on which hosts to provide a given service'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调度**：在集群中运行容器，并决定将哪些容器运行在哪些主机上，以提供给定的服务。'
- en: '**Cluster management**: Monitoring and marshalling the activity of containers
    and hosts across the cluster, and adding or removing hosts'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集群管理**：监控和调度集群中容器和主机的活动，并添加或删除主机。'
- en: '**Service discovery**: Giving containers the ability to find and connect to
    the services and data they need to operate'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务发现**：赋予容器找到并连接它们所需的服务和数据的能力。'
- en: What orchestration tools are available?
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有哪些编排工具可用？
- en: Google's Kubernetes and Docker's Swarm are both designed to orchestrate containers.
    Another product, Apache Mesos, is a cluster management framework which can operate
    on different kinds of resources, including containers.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌的 Kubernetes 和 Docker 的 Swarm 都是为容器编排而设计的。另一个产品，Apache Mesos，是一个集群管理框架，可以在不同类型的资源上操作，包括容器。
- en: Most containers in production today are running under one of these three orchestration
    systems. Kubernetes has been around the longest and has the biggest user base,
    but Swarm, though a relatively new arrival, is part of the official Docker stack,
    so it is being rapidly adopted.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 今天大多数生产环境中的容器都在这三种编排系统之一下运行。Kubernetes 存在时间最久，且拥有最大的用户基础，而 Swarm 虽然是一个相对较新的工具，但它是
    Docker 官方堆栈的一部分，因此正迅速被采纳。
- en: 'Because all these products are necessarily rather complicated to set up and
    operate, there is also the option of **Platform-as-a-Service** (**PaaS**) orchestration:
    essentially, running your containers on a managed cloud platform. **Google Container
    Engine** (**GKE**) is Kubernetes as a service; Amazon''s **EC2 Container Service**
    (**ECS**) is a proprietary, Kubernetes-like system.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有这些产品都必然需要相对复杂的设置和操作，因此也有 **平台即服务**（**PaaS**）编排的选项：本质上，就是在托管的云平台上运行你的容器。**Google
    容器引擎**（**GKE**）是作为服务的 Kubernetes；亚马逊的 **EC2 容器服务**（**ECS**）是一个类似于 Kubernetes 的专有系统。
- en: As yet, Puppet integration with container orchestrators is somewhat limited
    and at an early stage, though, given the popularity of containers, this is likely
    to advance rapidly. There is some elementary support for generating Kubernetes
    configuration from Puppet resources, and some for managing Amazon ECS resources,
    but it's fair to say that automating container orchestration at scale with Puppet
    is so far still in its infancy. Watch this space, however.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Puppet 与容器编排器的集成仍然相对有限，处于初期阶段。不过，考虑到容器的流行，这一领域很可能会迅速发展。目前，Puppet 支持从 Puppet
    资源生成 Kubernetes 配置，以及管理 Amazon ECS 资源，但可以公平地说，使用 Puppet 在规模化的容器编排自动化方面仍处于起步阶段。不过，值得关注这一领域的动态。
- en: Running Puppet inside containers
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器中运行 Puppet。
- en: 'If a container can contain a whole operating system, such as Ubuntu, you might
    be wondering: "can''t I just run Puppet inside the container?"'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个容器可以包含整个操作系统，例如 Ubuntu，你可能会想：“我能不能直接在容器内部运行 Puppet？”
- en: 'You can, and some people do take this approach to managing containers. It also
    has a number of advantages:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样做，而且有些人确实采用了这种管理容器的方法。这种方法也有不少优点：
- en: You can use your existing Puppet manifests, or Forge modules; no need to write
    complex Dockerfiles
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用现有的 Puppet 清单或 Forge 模块；无需编写复杂的 Dockerfile。
- en: Puppet will keep the container continuously updated; no need to rebuild when
    something changes
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet 会持续保持容器更新；当某些内容发生变化时，无需重新构建。
- en: 'Of course, there are a few disadvantages too:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也有一些缺点：
- en: Installing Puppet inflates the image size considerably, and pulls in all sorts
    of dependencies
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Puppet 会显著增加镜像大小，并且会拉入各种依赖项。
- en: Running Puppet slows down the build process, and also consumes resources in
    the running container
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中运行 Puppet 会减慢构建过程，并消耗容器中的资源。
- en: There are also some hybrid options, such as running Puppet in the container
    during the build stage, and then removing Puppet and its dependencies, plus any
    intermediate build artifacts, before saving the final image.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些混合选项，例如在构建阶段在容器中运行 Puppet，然后在保存最终镜像之前，移除 Puppet 及其依赖项，以及任何中间构建产物。
- en: Puppet's `image_build` module is a promising new way of building containers
    directly from Puppet manifests, and I expect to see rapid progress in this space
    in the near future.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 的 `image_build` 模块是一个有前景的新方法，可以直接从 Puppet 清单构建容器，我预计在不久的将来这一领域会有快速进展。
- en: Are containers mini VMs or single processes?
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器是迷你虚拟机还是单一进程？
- en: Which option you favor probably depends on your basic approach to containers.
    Do you see them as mini-virtual machines, not too different from the servers you're
    already managing? Or do you see them as transient, lightweight, single-process
    wrappers?
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你倾向于哪种选择，可能取决于你对容器的基本看法。你是否将它们视为迷你虚拟机，和你当前管理的服务器没有太大区别？还是你认为它们是临时的、轻量级的、单进程的包装？
- en: If you treat containers as mini-VMs, you'll probably want to run Puppet in your
    containers, in the same way as you do on your physical and virtual servers. On
    the other hand, if you think a container should just run a single process, it
    doesn't seem appropriate to run Puppet in it. With single-process containers there's
    very little to configure.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你把容器当作迷你虚拟机来对待，你可能会想在容器内运行 Puppet，就像在物理和虚拟服务器上运行 Puppet 一样。另一方面，如果你认为容器只应该运行单一的进程，那么在容器中运行
    Puppet 似乎不太合适。对于单进程的容器，几乎没有什么可配置的内容。
- en: I can see arguments in favor of the mini-VM approach. For one thing, it makes
    it much easier to transition your existing applications and services to containers;
    instead of running them in a VM, you just move the whole thing (application, support
    services, and database) into a container, along with all your current management
    and monitoring tools.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以理解支持迷你虚拟机方法的观点。首先，这使得将现有的应用程序和服务迁移到容器变得更加容易；你无需将它们运行在虚拟机中，而是直接将整个应用程序、支持服务和数据库连同当前的管理和监控工具一起移入容器。
- en: 'However, while this is a valid approach, it doesn''t really make the most of
    the inherent advantages of containers: small image sizes, quick deployment, efficient
    rebuilding, and portability.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，虽然这是一个有效的方法，但它并没有真正发挥容器固有优势的最大作用：小的镜像大小、快速部署、高效重建和可移植性。
- en: Configuring containers with Puppet
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Puppet 配置容器
- en: 'Personally, I''m a container minimalist: I think the container should contain
    only what it needs to do the job. Therefore, I prefer to use Puppet to manage,
    configure, and build my containers from the outside, rather than from the inside,
    and that''s why I''ve used that approach in this chapter.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 就个人而言，我是一个容器极简主义者：我认为容器应该只包含完成工作所需的内容。因此，我更喜欢从外部使用 Puppet 来管理、配置和构建我的容器，而不是从内部管理，这也是我在本章中采用这种方法的原因。
- en: That means generating Dockerfiles from templates and Hiera data, as we've seen
    in the examples, as well as templating config files which the container needs.
    You can have the Dockerfile copy these files into the container during the build,
    or mount individual files and directories from the host onto the container.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着生成来自模板和 Hiera 数据的 Dockerfile，如我们在示例中所看到的，以及模板化容器所需的配置文件。你可以让 Dockerfile
    在构建过程中将这些文件复制到容器中，或者将主机上的单个文件和目录挂载到容器中。
- en: As we've seen, a good way to handle shared data is to have Puppet write it into
    a Docker volume or a file on the host which is then mounted (usually read-only)
    by all running containers.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，处理共享数据的一个好方法是让 Puppet 将其写入 Docker 卷或主机上的文件，然后由所有正在运行的容器挂载（通常是只读的）。
- en: The advantage of this is that you don't need to rebuild all your containers
    following a config change. You can simply have Puppet write the changes to the
    config volume, and trigger each container to reload its configuration using a
    `docker::exec` resource, which executes a specified command on a running container.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的好处是，在配置更改后，你不需要重新构建所有容器。你只需让 Puppet 将更改写入配置卷，并使用 `docker::exec` 资源触发每个容器重新加载其配置，该资源在正在运行的容器上执行指定命令。
- en: Containers need Puppet too
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器也需要 Puppet
- en: 'At the risk of laboring a point, containerization is not an alternative to
    using configuration management tools such as Puppet. In fact, the need for configuration
    management is even greater, because you not only have to build and configure the
    containers themselves, but also store, deploy, and run them: all of which requires
    an infrastructure.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 以免重复强调，容器化并不是使用像 Puppet 这样的配置管理工具的替代方案。事实上，对配置管理的需求更大，因为你不仅需要构建和配置容器本身，还需要存储、部署和运行它们：所有这些都需要基础设施。
- en: As usual, Puppet makes this sort of task easier, more pleasant, and—most importantly—more
    scalable.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，Puppet 让这类任务变得更容易、更愉快，而且——最重要的是——更具可扩展性。
- en: Summary
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've examined some of the problems associated with software
    deployment, some of the options for solving them, and the advantages of the container
    solution. We've briefly introduced the basics of container technology and Docker,
    in particular, and seen that containers are another kind of configuration management
    problem which Puppet can help solve.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了与软件部署相关的一些问题，解决这些问题的部分方案，以及容器解决方案的优势。我们简要介绍了容器技术的基础，特别是 Docker，并了解到容器是另一种配置管理问题，而
    Puppet 可以帮助解决这些问题。
- en: We've installed the `docker_platform` module, and used it to set up Docker on
    our VM, and build and run simple Docker containers. We've seen how to automatically
    rebuild the container image when the underlying Dockerfile changes, and how to
    use Puppet to configure a Dockerfile dynamically at build time.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们安装了 `docker_platform` 模块，并使用它在我们的虚拟机上设置了 Docker，构建并运行了简单的 Docker 容器。我们看到，当底层
    Dockerfile 更改时，如何自动重建容器镜像，并了解如何在构建时使用 Puppet 动态配置 Dockerfile。
- en: We've introduced the topic of persistent storage for containers, including host-mounted
    volumes and Docker volumes, and how to manage these with Puppet. We've set up
    a Docker network with two communicating containers exchanging data over network
    ports.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了容器的持久化存储话题，包括主机挂载卷和 Docker 卷，并讨论了如何使用 Puppet 来管理这些存储。我们设置了一个 Docker 网络，包含两个通过网络端口交换数据的通信容器。
- en: We've looked at the advantages and disadvantages of running Puppet inside containers,
    as opposed to using Puppet to configure and build containers from the outside,
    and also suggested a hybrid strategy where Puppet manages configuration data on
    a volume attached to running containers.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分析了在容器内部运行 Puppet 相比于使用 Puppet 从外部配置和构建容器的优缺点，还提出了一种混合策略，即 Puppet 管理附加到运行中容器的卷上的配置数据。
- en: Finally, we've covered some of the issues involved in container orchestration,
    and introduced some of the most popular platforms and frameworks available.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经讨论了容器编排中涉及的一些问题，并介绍了当前最受欢迎的一些平台和框架。
- en: In the next chapter, we'll learn how to use Puppet to manage cloud computing
    resources, with an in-depth example developing a software-defined Amazon EC2 infrastructure.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习如何使用 Puppet 管理云计算资源，并通过一个深入的示例来开发一个软件定义的 Amazon EC2 基础设施。
