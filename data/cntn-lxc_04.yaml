- en: Chapter 4. LXC Code Integration with Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 LXC 与 Python 的代码集成
- en: This chapter will introduce you to the Python bindings provided by both the
    LXC and libvirt APIs. We'll explore which container functionalities are possible
    and which are not, using the upstream `lxc-dev` and `python-libvirt` packages
    on Ubuntu and the `lxc-devel` and `libvirt-python` packages on CentOS.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍 LXC 和 libvirt API 提供的 Python 绑定。我们将探索哪些容器功能是可能的，哪些是不可能的，使用 Ubuntu 上的上游
    `lxc-dev` 和 `python-libvirt` 包以及 CentOS 上的 `lxc-devel` 和 `libvirt-python` 包。
- en: To gain the most out of this chapter, some knowledge of Python is required.
    If you are a developer, this chapter is probably the most important one for you.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用本章内容，需要具备一定的 Python 知识。如果你是开发者，本章可能是最重要的一章。
- en: 'In this chapter, we''ll cover the following topics in this order:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将按以下顺序涵盖以下主题：
- en: Building and managing containers using the `lxc` Python bindings
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `lxc` Python 绑定构建和管理容器
- en: Creating and orchestrating containers using the libvirt Python bindings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 libvirt Python 绑定创建和编排容器
- en: Using LXC as a backend for development and testing with Vagrant
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 LXC 作为 Vagrant 开发和测试的后端
- en: Developing a simple frontend RESTful API to LXC, using the Bottle micro framework
    and the `lxc` libraries
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个简单的前端 RESTful API 来与 LXC 交互，使用 Bottle 微框架和 `lxc` 库
- en: LXC Python bindings
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LXC Python 绑定
- en: LXC comes with stable C API and Python bindings for both Python 2.x and 3.x
    versions. Let's explore some of the functionalities that are available to us using
    Python 2.7.6, by writing a code that will cover most of the features provided
    by the userspace tools we saw in earlier chapters.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: LXC 提供稳定的 C API 和 Python 绑定，支持 Python 2.x 和 3.x 版本。让我们通过编写一个代码来探索一些功能，这些功能覆盖了我们在前几章中看到的用户空间工具所提供的大多数功能，使用
    Python 2.7.6 版本。
- en: Installing the LXC Python bindings and preparing the development environment
    on Ubuntu and CentOS
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Ubuntu 和 CentOS 上安装 LXC Python 绑定并准备开发环境
- en: Let's start by installing all the necessary packages that will allow us to write
    a functioning Python code. This includes the LXC API libraries and a Python development
    environment with `ipython` and `virtualenv`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从安装所有必需的包开始，这些包将使我们能够编写功能完整的 Python 代码，包括 LXC API 库和带有 `ipython` 和 `virtualenv`
    的 Python 开发环境。
- en: 'To prepare an Ubuntu host, run the following commands:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要准备一个 Ubuntu 主机，请运行以下命令：
- en: '[PRE0]'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding commands will ensure we are running the latest Ubuntu packages,
    along with tools such as `pip`, to install and manage Python packages, and the
    `ipython` tool for interactive programming in Python. On CentOS, install the following
    packages to provide the same functionality:'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述命令将确保我们运行的是最新的 Ubuntu 包，并包含诸如 `pip` 这样的工具，用于安装和管理 Python 包，以及用于 Python 交互式编程的
    `ipython` 工具。在 CentOS 上，安装以下软件包以提供相同的功能：
- en: '[PRE1]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'At this point, let''s create a Linux bridge for the containers to connect to
    later on:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此阶段，让我们为容器创建一个 Linux 桥接，以便后续连接：
- en: '[PRE2]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For the examples in this chapter, we are going to use a separate Python virtual
    environment to keep the dependency requirements for our project separate. We can
    do this by utilizing the `virtualenv` package.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于本章中的示例，我们将使用一个单独的 Python 虚拟环境，以保持项目的依赖项要求独立。我们可以通过使用 `virtualenv` 包来实现。
- en: 'Let''s install it first with `pip`:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先通过 `pip` 安装它：
- en: '[PRE3]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, let''s create a working directory for our project and activate the virtual
    environment:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们为项目创建一个工作目录并激活虚拟环境：
- en: '[PRE4]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With the virtual environment activated, let''s install the Python LXC API bindings
    package and list what is present in our development environment using `pip`:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活虚拟环境后，让我们安装 Python LXC API 绑定包，并使用 `pip` 列出开发环境中的内容：
- en: '[PRE5]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With this, we have all the required packages, libraries, and tools for creating
    and using LXC containers with Python. Let's have some fun writing Python code!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们已经具备了所有必需的包、库和工具，可以使用 Python 创建和使用 LXC 容器。让我们写点 Python 代码，享受乐趣吧！
- en: Building our first container with Python
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用 Python 构建我们的第一个容器
- en: 'Let''s start the `ipython` tool and import the LXC library we installed earlier:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动 `ipython` 工具并导入之前安装的 LXC 库：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we need to create the `container` object using the `Container` class
    and by specifying a name:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用 `Container` 类并指定一个名称来创建 `container` 对象：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that we have a `container` object, we can use the `create` method to build
    our first container.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了 `container` 对象，可以使用 `create` 方法来构建我们的第一个容器。
- en: 'The `container.create()` method definition along with the explanation for each
    parameter is as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`container.create()` 方法的定义以及每个参数的解释如下：'
- en: '**Definition**: `container.create(self, template=None, flags=0, args=())`,
    creates a new `rootfs` for the container. The Following is a description of the
    parameters:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义**：`container.create(self, template=None, flags=0, args=())`，为容器创建一个新的
    `rootfs`。以下是各个参数的说明：'
- en: '`template`: This parameter must be a valid template name in order to be passed.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template`：此参数必须是一个有效的模板名称，才能被传递。'
- en: '`flags`: This is optional. It is an integer representing the optional create
    flags to be passed.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`：这是可选的。它是一个整数，表示要传递的可选创建标志。'
- en: '`args`: This is optional. It is a tuple of arguments to pass to the template.
    It can also be provided as a dictionary.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`args`：这是可选的。它是一个元组，包含要传递给模板的参数。也可以提供为字典形式。'
- en: 'Creating an Ubuntu container is as easy as running the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 Ubuntu 容器就像运行以下代码一样简单：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: An output of `True` indicates that the operation was successful in defining
    the container.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 输出 `True` 表示操作成功地定义了容器。
- en: Gathering container information with Python
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Python 收集容器信息
- en: Now that we've built our first LXC container, let's examine a few of its properties.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了第一个 LXC 容器，让我们来检查它的一些属性。
- en: 'First, let''s check the container''s name:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，检查一下容器的名称：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Also check its state:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以检查其状态：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s list all containers currently present on the host OS:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列出当前主机操作系统上所有的容器：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding `containers()` method returns a tuple containing the container
    names. In this case, just the single container we've just built.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的 `containers()` 方法返回一个包含容器名称的元组。在此例中，就是我们刚刚构建的唯一一个容器。
- en: 'By default, when we build LXC containers with the userspace tools such as `lxc-create`,
    the root filesystem and the configuration file are located in `/var/lib/lxc/containername/`.
    Let''s see where the root filesystem for the container we built is, by calling
    the `get_config_path()` and `get_config_item()` methods on the `container` object:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当我们使用用户空间工具如 `lxc-create` 构建 LXC 容器时，根文件系统和配置文件位于 `/var/lib/lxc/containername/`。让我们通过调用
    `get_config_path()` 和 `get_config_item()` 方法来查看我们构建的容器的根文件系统位置：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: From the output of the `get_config_path()` method, we can observe that the default
    LXC config location is the same as the one if the `lxc-create` command was used
    to build the container.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `get_config_path()` 方法的输出中，我们可以观察到默认的 LXC 配置位置与使用 `lxc-create` 命令构建容器时的配置位置相同。
- en: In the preceding code example, we also passed the `lxc.rootfs` configuration
    option to the `get_config_item()` method to obtain the root filesystem location,
    which is also in line with the default, if using the command line tools.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们还将 `lxc.rootfs` 配置选项传递给 `get_config_item()` 方法，以获取根文件系统的位置，这也与默认设置一致，假如使用命令行工具的话。
- en: 'We can pass various configuration parameters to the `get_config_item()` method
    to obtain the container''s current settings. Let''s query for the `memory.limit_in_bytes`
    option:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以传递不同的配置参数给 `get_config_item()` 方法，以获取容器的当前设置。让我们查询一下 `memory.limit_in_bytes`
    选项：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To list all available methods and variables on the `container` object we created,
    in `ipython`, type `container` and press the ***Tab*** key once. To get more information
    about a method, function, or variable, type its name followed by question mark,
    for example, `container.get_ips?`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出我们创建的 `container` 对象上所有可用的方法和变量，在 `ipython` 中，输入 `container` 然后按一次 ***Tab***
    键。要获取关于方法、函数或变量的更多信息，可以输入其名称后加上问号，例如 `container.get_ips?`。
- en: You can experiment further by opening the container's configuration file as
    shown from the preceding output and pass it as a parameter to the `get_config_item()`
    method.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以进一步尝试，打开容器的配置文件，如前面输出所示，并将其作为参数传递给 `get_config_item()` 方法。
- en: 'To obtain the IP configuration of our container, we can call the `get_ips()`
    method with no arguments, as the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取容器的 IP 配置信息，我们可以调用 `get_ips()` 方法，无需任何参数，如下所示：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Since the container is not running and no memory limits have been applied, the
    output is an empty string and an empty tuple, respectively. Working with a stopped
    container is not very interesting; let's explore what we can do in Python with
    a running container.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于容器没有运行，并且没有应用内存限制，因此输出分别是空字符串和空元组。与停止的容器一起工作不是特别有趣；让我们探索一下如何在 Python 中操作一个正在运行的容器。
- en: Starting containers, applying changes, and listing configuration options with
    Python
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动容器、应用更改并使用 Python 列出配置选项
- en: 'Let''s check if the container is running by printing the value of the running
    Boolean on the `container` object:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过打印 `container` 对象上运行布尔值的值来检查容器是否正在运行：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To start the container, we can use the `start()` method. The docstring for
    that method reads as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动容器，我们可以使用 `start()` 方法。该方法的文档字符串如下所示：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Start the container and return `True` on success. When set, `useinit` will
    make LXC use `lxc-init` to start the container. The container can be started in
    the foreground with `daemonize=False`. All `fds` may also be closed by passing
    `close_fds=True`. Looks easy enough. Let''s start our container by daemonizing
    it and not using the `lxc-init` manager, but the Python interpreter instead:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 启动容器并在成功时返回 `True`。当设置 `useinit` 时，LXC 会使用 `lxc-init` 启动容器。容器可以通过 `daemonize=False`
    在前台启动。所有 `fds` 也可以通过传递 `close_fds=True` 来关闭。看起来很简单。让我们通过守护进程方式启动容器，并且不使用 `lxc-init`
    管理器，而是使用 Python 解释器：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Just as earlier, an output of `True` indicates that the operation was executed
    successfully. Let''s use the `wait()` method to wait for the container to reach
    the `RUNNING` state, or to timeout in 5 seconds:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，`True` 的输出表示操作成功执行。让我们使用 `wait()` 方法来等待容器达到 `RUNNING` 状态，或者在 5 秒内超时：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output indicates that the container is now running. Let''s double-check
    by printing the values of the running and state variables:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表明容器现在正在运行。让我们通过打印运行状态和状态变量的值来再次确认：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In a separate terminal, let''s use the LXC userspace tools to examine the container
    we built with the Python library:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个独立的终端中，让我们使用 LXC 用户空间工具来检查我们用 Python 库构建的容器：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The output of the `lxc-ls` command confirms what the `container.state` variable
    returned.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`lxc-ls` 命令的输出确认了 `container.state` 变量的返回值。'
- en: 'Let''s obtain the PID of the container in our Python shell:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Python shell 中获取容器的 PID：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The PID in this case is `4688`; we can confirm if it matches what''s currently
    running on the host system by executing the following command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此时的 PID 是 `4688`；我们可以通过执行以下命令来确认它是否与当前在主机系统上运行的进程匹配：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: No real surprises here. Notice how the main process that started the container's
    `init` system is `python` and not `lxc-init`, because that is what we passed as
    an argument to the `start()` method earlier.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么惊讶的。注意，启动容器 `init` 系统的主进程是 `python` 而不是 `lxc-init`，因为我们在 `start()` 方法中传递的就是
    Python。
- en: 'Now that our container is running, we can get some more information from it.
    Let''s start by obtaining its IP address:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的容器已经启动，我们可以从中获取更多信息。让我们从获取其 IP 地址开始：
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The result is a tuple, containing the IP addresses of all interfaces for the
    container, in this case just one IP.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个元组，包含容器所有接口的 IP 地址，在本例中只有一个 IP 地址。
- en: 'We can programmatically attach to the container and run commands just like
    we saw in the [Chapter 3](ch03.html "Chapter 3. Command-Line Operations Using
    Native and Libvirt Tools"), *Command-line Operations Using Native and Libvirt
    Tools*, with the `lxc-attach` command, by invoking the `attach_wait()` method,
    as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像在[第3章](ch03.html "Chapter 3. Command-Line Operations Using Native and Libvirt
    Tools")，*使用本地和 Libvirt 工具的命令行操作*中看到的那样，通过调用 `attach_wait()` 方法，使用 `lxc-attach`
    命令以编程方式附加到容器并运行命令，代码如下：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `attach_wait()` method takes a function as its argument, in the preceding
    example, the built-in `lxc.attach_run_command`, but it can be any other function
    in Python that you wrote. We also specified a list consisting of the command we
    want to execute and its arguments.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`attach_wait()` 方法将一个函数作为参数，在前面的示例中是内置的 `lxc.attach_run_command`，但它也可以是你编写的任何其他
    Python 函数。我们还指定了一个包含我们要执行的命令及其参数的列表。'
- en: 'We can also specify the namespace context the command should run in. For example,
    to list all files in the container''s mount namespace designated by the `CLONE_NEWNS`
    flag, we can pass the `namespaces` parameter:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以指定命令应在哪个命名空间上下文中运行。例如，要列出容器挂载命名空间中所有的文件（该命名空间由 `CLONE_NEWNS` 标志指定），我们可以传递
    `namespaces` 参数：
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can run commands by specifying multiple `namespaces` flags. In the next
    example, we list all processes in the container by explicitly specifying the mount
    and process namespaces with the `CLONE_NEWNS` and `CLONE_NEWPID` flags, respectively:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过指定多个 `namespaces` 标志来运行命令。在下一个示例中，我们通过明确指定挂载和进程命名空间（分别使用 `CLONE_NEWNS`
    和 `CLONE_NEWPID` 标志），列出容器中的所有进程：
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Using the `set_config_item()` and `get_config_item()` methods, we can apply
    configuration changes and query them on a running container. To demonstrate this,
    let''s specify a memory limit for the container and then obtain the newly set
    value:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `set_config_item()` 和 `get_config_item()` 方法，我们可以对运行中的容器应用配置更改并查询它们。为了演示这一点，让我们为容器指定一个内存限制，然后获取新设置的值：
- en: '[PRE27]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding changes will not persist when a container restarts; to make the
    changes permanent, we can write them in the configuration file using the `append_config_item()`
    and `save_config()` methods:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 上述更改在容器重启时不会持久化；为了使更改永久生效，我们可以使用 `append_config_item()` 和 `save_config()` 方法将它们写入配置文件：
- en: '[PRE28]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To verify this, the `lxc.cgroup.memory.limit_in_bytes` parameter was saved
    in the configuration file; let''s examine it:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证这一点，`lxc.cgroup.memory.limit_in_bytes` 参数已经保存在配置文件中；让我们检查它：
- en: '[PRE29]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The last line in the configuration file is the one we appended with the two
    Python calls.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件中的最后一行是我们用两个 Python 调用追加的那一行。
- en: 'In addition to the `set_config_item()` method, the Python bindings also provide
    the `set_cgroup_item()` and `get_cgroup_item()` methods for specifically manipulating
    the cgroup parameters. Let''s set and get the same `memory.limit_in_bytes` option
    using those two calls:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `set_config_item()` 方法外，Python 绑定还提供了 `set_cgroup_item()` 和 `get_cgroup_item()`
    方法，用于专门操作 cgroup 参数。让我们使用这两个方法设置并获取相同的 `memory.limit_in_bytes` 选项：
- en: '[PRE30]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Changing container state with Python
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Python 更改容器状态
- en: 'In [Chapter 3](ch03.html "Chapter 3. Command-Line Operations Using Native and
    Libvirt Tools"), *Command-Line Operations Using Native and Libvirt Tools*, we
    saw how to freeze and unfreeze LXC containers to preserve their state using the
    `lxc-freeze` and `lxc-unfreeze` commands. We can do the same with the `freeze()`
    and `unfreeze()` methods. To freeze the container, execute the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](ch03.html "第 3 章：使用原生和 Libvirt 工具进行命令行操作")，*使用原生和 Libvirt 工具进行命令行操作*中，我们看到了如何使用
    `lxc-freeze` 和 `lxc-unfreeze` 命令冻结和解冻 LXC 容器，以保存其状态。我们可以使用 `freeze()` 和 `unfreeze()`
    方法做到这一点。要冻结容器，执行以下命令：
- en: '[PRE31]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Check the status as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式检查状态：
- en: '[PRE32]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can examine the cgroup file as well, to confirm the change took place:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以检查 cgroup 文件，以确认更改已发生：
- en: '[PRE33]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To unfreeze the container and check the new state, call the `unfreeze()` method:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要解冻容器并检查新状态，请调用 `unfreeze()` 方法：
- en: '[PRE34]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Stopping containers with Python
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Python 停止容器
- en: 'The Python bindings provide a convenient way of stopping containers with the
    `stop()` method. Let''s stop our container and check its state:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Python 绑定提供了一个方便的方式来停止容器，使用 `stop()` 方法。让我们停止容器并检查其状态：
- en: '[PRE35]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, list all the containers on the host:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，列出主机上的所有容器：
- en: '[PRE36]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Cloning containers with Python
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Python 克隆容器
- en: 'With the container in a `STOPPED` state, let''s run the `clone()` method and
    create a copy:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 容器处于 `STOPPED` 状态时，让我们运行 `clone()` 方法并创建一个副本：
- en: '[PRE37]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing the available containers with the `list_containers()` method on the
    `lxc` object, we get a tuple:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `list_containers()` 方法列出 `lxc` 对象上的可用容器，我们得到一个元组：
- en: '[PRE38]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To confirm on the host OS, execute the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要在主机操作系统上确认，请执行以下操作：
- en: '[PRE39]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To find where the root filesystem for the cloned container is, we can call
    the `get_config_item()` method on the new `container` object:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到克隆容器的根文件系统位置，我们可以在新的 `container` 对象上调用 `get_config_item()` 方法：
- en: '[PRE40]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Two directories now exist in the default container path:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在默认的容器路径下存在两个目录：
- en: '[PRE41]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, let''s start the cloned container and ensure it''s running:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们启动克隆的容器并确保它正在运行：
- en: '[PRE42]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Destroying containers with Python and cleaning up the virtual environment
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Python 销毁容器并清理虚拟环境
- en: 'Before we can remove or destroy containers in Python, just like with the command
    line tools, we need to stop them first:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够在 Python 中移除或销毁容器之前，像命令行工具一样，我们需要先停止它们：
- en: '[PRE43]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Invoke the `destroy()` method on the `container` object to delete the root
    filesystem and free all resources used by it:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `container` 对象上调用 `destroy()` 方法，以删除根文件系统并释放它所使用的所有资源：
- en: '[PRE44]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'List the containers through the `list_containers()` method to now return an
    empty tuple:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `list_containers()` 方法列出容器，此时返回一个空元组：
- en: '[PRE45]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Lastly, let''s deactivate the Python virtual environment we created earlier
    – note that the files will still be present on the disk:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们停用之前创建的 Python 虚拟环境——注意，文件仍然会保留在磁盘上：
- en: '[PRE46]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Libvirt Python bindings
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Libvirt Python 绑定
- en: In [Chapter 3](ch03.html "Chapter 3. Command-Line Operations Using Native and
    Libvirt Tools"), *Command-Line Operations Using Native and Libvirt Tools*, we
    explored an alternative way of working with LXC through the use of the libvirt
    userspace tools. Libvirt provides Python bindings that we can use to write applications,
    with the main benefit of uniformity with other virtualization technologies. It's
    quite convenient to write Python applications for KVM, XEN, and LXC using just
    one common library.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](ch03.html "第 3 章：使用原生和 Libvirt 工具的命令行操作")，*使用原生和 Libvirt 工具的命令行操作*，我们探讨了通过使用
    libvirt 用户空间工具处理 LXC 的替代方法。Libvirt 提供了 Python 绑定，我们可以用它来编写应用程序，主要的好处是与其他虚拟化技术的一致性。使用一个通用的库来编写
    KVM、XEN 和 LXC 的 Python 应用程序非常方便。
- en: In this section, we are going to explore some of the Python methods provided
    by the libvirt library to create and control LXC containers.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 libvirt 库提供的一些 Python 方法，用于创建和控制 LXC 容器。
- en: Installing the libvirt Python development packages
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 libvirt Python 开发包
- en: Let's start by installing the required packages and starting the service.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先安装所需的包并启动服务。
- en: 'On Ubuntu, run the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu 上，运行以下命令：
- en: '[PRE47]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'On CentOS, the library and the service are named differently:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CentOS 上，库和服务的名称不同：
- en: '[PRE48]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Since libvirt does not provide templates to work with, we need to create our
    own root filesystem:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 libvirt 不提供模板来使用，我们需要创建自己的根文件系统：
- en: '[PRE49]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Activate the Python virtual environment and start the interpreter:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 激活 Python 虚拟环境并启动解释器：
- en: '[PRE50]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Building LXC containers with libvirt Python
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 libvirt Python 构建 LXC 容器
- en: 'It''s time to import the library and call the `open()` method to create a connection
    to the LXC driver. The argument that we pass to the `open()` method should look
    familiar – we used it in [Chapter 3](ch03.html "Chapter 3. Command-Line Operations
    Using Native and Libvirt Tools"), *Command-Line Operations Using Native and Libvirt
    Tools*, when exporting the `LIBVIRT_DEFAULT_URI` environment variable, telling
    libvirt that LXC is going to be the default virtualization driver:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是导入库并调用 `open()` 方法以创建与 LXC 驱动程序的连接的时候了。我们传递给 `open()` 方法的参数应该是熟悉的——我们在 [第
    3 章](ch03.html "第 3 章：使用原生和 Libvirt 工具的命令行操作")，*使用原生和 Libvirt 工具的命令行操作*，中使用过它，在导出
    `LIBVIRT_DEFAULT_URI` 环境变量时，告诉 libvirt LXC 将是默认的虚拟化驱动程序：
- en: '[PRE51]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'After specifying the default virtualization driver and URI, we can use the
    next two methods to return the name and path of the driver we set:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定默认虚拟化驱动程序和 URI 后，我们可以使用接下来的两个方法来返回我们设置的驱动程序的名称和路径：
- en: '[PRE52]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: To get a list of the available methods and variables on the `lxc_conn` object
    we created earlier, type `lxc_conn`. and press the ***Tab*** key. To get more
    information about a method, function, or variable, type its name followed by a
    question mark, for example, `lxc_conn.getURI?`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取我们之前创建的 `lxc_conn` 对象上的可用方法和变量列表，请输入 `lxc_conn`，然后按 ***Tab*** 键。要获取有关方法、函数或变量的更多信息，请键入其名称后加上问号，例如，`lxc_conn.getURI?`。
- en: 'We can use the `getInfo()` method to extract hardware information about the
    host node:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `getInfo()` 方法提取主机节点的硬件信息：
- en: '[PRE53]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The result is a list with the following values:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个包含以下值的列表：
- en: '| **Member** | **Description** |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| **成员** | **描述** |'
- en: '| `list[0]` | String indicating the CPU model |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `list[0]` | 指示 CPU 型号的字符串 |'
- en: '| `list[1]` | Memory size in megabytes |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `list[1]` | 以兆字节为单位的内存大小 |'
- en: '| `list[2]` | The number of active CPUs |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `list[2]` | 活跃 CPU 的数量 |'
- en: '| `list[3]` | Expected CPU frequency in MHz |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `list[3]` | 预期的 CPU 频率（单位：MHz） |'
- en: '| `list[4]` | The number of NUMA nodes, `1` for uniform memory access |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `list[4]` | NUMA 节点的数量，`1` 表示统一内存访问 |'
- en: '| `list[5]` | Number of CPU sockets per node |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `list[5]` | 每个节点的 CPU 插槽数 |'
- en: '| `list[6]` | Number of cores per socket |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `list[6]` | 每个插槽的核心数 |'
- en: '| `list[7]` | Number of threads per core |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `list[7]` | 每个核心的线程数 |'
- en: 'To build a container, we need to define it first in a XML file. Let''s use
    the following example and assign it to the `domain_xml` string variable:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建容器，我们需要先在 XML 文件中定义它。让我们使用以下示例并将其分配给 `domain_xml` 字符串变量：
- en: '[PRE54]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'With the preceding XML configuration assigned to a variable, we can use the
    `defineXML()` method to define the container. This method takes the XML definition
    as an argument and defines the container, but does not start it:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前分配给变量的 XML 配置，我们可以使用 `defineXML()` 方法来定义容器。此方法将 XML 定义作为参数并定义容器，但不会启动容器：
- en: '[PRE55]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let''s verify the container was successfully defined on the host:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证容器是否已成功在主机上定义：
- en: '[PRE56]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can use the `listDefinedDomains()` method to list all the defined but not
    the running domains, which returns a list:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`listDefinedDomains()`方法列出所有已定义但未运行的域，它返回一个列表：
- en: '[PRE57]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Starting containers and running basic operations with libvirt Python
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用libvirt Python启动容器并运行基本操作
- en: 'To start the previously defined container, we need to call the `create()` method:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动之前定义的容器，我们需要调用`create()`方法：
- en: '[PRE58]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To verify the container is running on the host, after calling the `create()`
    method, we''ll execute the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证容器是否在主机上运行，在调用`create()`方法后，我们将执行以下操作：
- en: '[PRE59]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'There are quite a few methods for obtaining information about the container.
    We can fetch the XML definition by calling the `XMLDesc()` method on the `container`
    object:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以获取容器的信息。我们可以通过在`container`对象上调用`XMLDesc()`方法来获取XML定义：
- en: '[PRE60]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let''s verify that the container is running by calling the `isAlive()` function
    that returns a Boolean:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过调用`isAlive()`函数来验证容器是否正在运行，该函数返回一个布尔值：
- en: '[PRE61]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We can obtain the container ID that should match the ID we received back by
    running the preceding `virsh` command:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以获取容器ID，该ID应与通过运行前述`virsh`命令返回的ID匹配：
- en: '[PRE62]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: No surprise here, the ID is the same.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无惊讶，ID是相同的。
- en: 'The next code snippet iterates over a list of defined containers and returns
    a list of domain objects from which we print their name, by calling the `listAllDomains()`
    method:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码片段遍历已定义容器的列表，并通过调用`listAllDomains()`方法返回域对象列表，从中打印出它们的名称：
- en: '[PRE63]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The API provides two methods to lookup a container, by name and by ID, and
    assigns it to an object variable:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: API提供了两种查找容器的方法，通过名称和ID，并将其赋值给对象变量：
- en: '[PRE64]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This is useful when we want to work with containers that already exist. The
    `container` object can now be used as usual, by calling its methods.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这在我们想要操作已存在的容器时非常有用。现在可以像平常一样使用`container`对象，通过调用其方法。
- en: Collecting container information with libvirt Python
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用libvirt Python收集容器信息
- en: 'Let''s collect information about the memory of the container. The `maxMemory()`
    method returns the maximum memory configured on the container:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们收集容器的内存信息。`maxMemory()`方法返回容器配置的最大内存：
- en: '[PRE65]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Collecting memory statistics is done with the `memoryStats()` method, which
    returns a dictionary object:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 收集内存统计信息是通过`memoryStats()`方法完成的，该方法返回一个字典对象：
- en: '[PRE66]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'When we defined our container earlier in the XML file, we specified the OS
    type of the domain to be `exe`, meaning the container will execute the specified
    binary. To obtain that on a running container, call the `OSType()` method:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在XML文件中定义容器时，我们指定了域的操作系统类型为`exe`，这意味着容器将执行指定的二进制文件。要在运行中的容器上获取该信息，可以调用`OSType()`方法：
- en: '[PRE67]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Finally, to get more information on the container, we can call the `info()`
    function:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了获取更多关于容器的信息，我们可以调用`info()`函数：
- en: '[PRE68]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The result is a list with the following values:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个包含以下值的列表：
- en: '| **Member** | **Description** |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| **成员** | **描述** |'
- en: '| `list[0]` | String indicating the state of the container |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `list[0]` | 表示容器状态的字符串 |'
- en: '| `list[1]` | Max container memory |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `list[1]` | 容器的最大内存 |'
- en: '| `list[2]` | Current memory utilization |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `list[2]` | 当前内存利用率 |'
- en: '| `list[3]` | Number of CPUs |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `list[3]` | CPU 数量 |'
- en: '| `list[4]` | CPU time |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `list[4]` | CPU 时间 |'
- en: With the container running, let's look at how we can stop it and clean up the
    environment next.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 容器启动后，让我们看看接下来如何停止它并清理环境。
- en: Stopping and deleting LXC containers with libvirt Python
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用libvirt Python停止和删除LXC容器
- en: Before we can destroy the container, let's verify its state and name.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在销毁容器之前，让我们验证一下它的状态和名称。
- en: '[PRE69]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'To stop it, call the `destroy()` method on the `container` object:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止容器，调用`container`对象上的`destroy()`方法：
- en: '[PRE70]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Let''s verify the container is not running on the host before we can delete
    it:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在删除容器之前，让我们验证容器在主机上没有运行：
- en: '[PRE71]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To delete the container, we invoke the `undefine()` method:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除容器，我们调用`undefine()`方法：
- en: '[PRE72]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Note
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's important to note that not all methods, functions, and variables are available
    to the libvirt LXC driver, even though they can be listed in the ipython interpreter
    after importing the libvirt library. This is due to the libvirt support for multiple
    hypervisors such as KVM and XEN. Keep this in mind when exploring the rest of
    the API calls.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，并非所有的方法、函数和变量都可以在libvirt LXC驱动程序中使用，即使它们在导入libvirt库后可以在ipython解释器中列出。这是由于libvirt对多个虚拟化管理程序（如KVM和XEN）的支持。在探索API调用时请记住这一点。
- en: Vagrant and LXC
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vagrant 和 LXC
- en: Vagrant is a great open source project that provides a way for building isolated
    development environments, utilizing various virtualization technologies such as
    KVM and LXC, through the use of plugins.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant 是一个优秀的开源项目，通过使用插件提供了构建隔离开发环境的方式，支持各种虚拟化技术，如 KVM 和 LXC。
- en: In this section, we are going to briefly touch on how to set up a Vagrant development
    environment using LXC for isolation.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要介绍如何使用 LXC 进行隔离，设置 Vagrant 开发环境。
- en: 'Let''s start by downloading and installing Vagrant on Ubuntu:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在 Ubuntu 上下载并安装 Vagrant 开始：
- en: '[PRE73]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Installing the package is trivial:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 安装这个软件包非常简单：
- en: '[PRE74]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'On CentOS, the steps are as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CentOS 上，步骤如下：
- en: 'Run the following command for downloading and installing Vagrant:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令以下载并安装 Vagrant：
- en: '[PRE75]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Next, create a new bridge if it does not already exist, for LXC to attach to:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，如果 LXC 尚未附加到新的桥接设备，创建一个新的桥接设备：
- en: '[PRE76]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'It''s time to install the LXC plugin:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候安装 LXC 插件了：
- en: '[PRE77]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'If all went well, list the installed Vagrant plugins:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，请列出已安装的 Vagrant 插件：
- en: '[PRE78]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'With the LXC plugin installed, create a new project directory:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装了 LXC 插件后，创建一个新的项目目录：
- en: '[PRE79]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Next, initialize a new Vagrant environment by specifying the type of box, or
    virtual machine image we are going to use. In the following example, we are going
    to use the Ubuntu Precise LXC image from the `fgremh` repository:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过指定我们将使用的盒子类型或虚拟机镜像，初始化一个新的 Vagrant 环境。在以下示例中，我们将使用来自 `fgremh` 仓库的 Ubuntu
    Precise LXC 镜像：
- en: '[PRE80]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'As the output indicates, a new `Vagrantfile` was created in the project directory:'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如输出所示，项目目录中已创建了一个新的 `Vagrantfile`：
- en: '[PRE81]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Note
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For a list of Vagrant boxes you can visit: [https://atlas.hashicorp.com/boxes/search](https://atlas.hashicorp.com/boxes/search).'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要查看 Vagrant 盒子列表，请访问：[https://atlas.hashicorp.com/boxes/search](https://atlas.hashicorp.com/boxes/search)。
- en: 'Let''s take a look at `Vagrantfile`:'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看 `Vagrantfile`：
- en: '[PRE82]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The configuration is very minimal, specifying the image that the Vagrant machine
    will use. Let''s start the container, by explicitly specifying the provider:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置非常简洁，仅指定 Vagrant 虚拟机将使用的镜像。我们通过明确指定提供程序来启动容器：
- en: '[PRE83]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'To verify that we have a running LXC container, execute the following on the
    command line:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要验证是否有正在运行的 LXC 容器，请在命令行中执行以下命令：
- en: '[PRE84]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Let''s check the status of the Vagrant machine:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查 Vagrant 虚拟机的状态：
- en: '[PRE85]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'To connect to the LXC container, run the following:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要连接到 LXC 容器，请运行以下命令：
- en: '[PRE86]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Configuring Vagrant LXC
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Vagrant LXC
- en: 'The `Vagrantfile` is very well documented, but here''s a brief example on how
    to customize the Vagrant machine by specifying the amount of memory available
    to the LXC container:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vagrantfile` 有很好的文档说明，以下是如何通过指定可用于 LXC 容器的内存量来定制 Vagrant 虚拟机的简要示例：'
- en: 'Stop the running Vagrant machine:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止正在运行的 Vagrant 虚拟机：
- en: '[PRE87]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Edit `Vagrantfile` and set the `cgroup.memory.limit_in_bytes` cgroup limit.
    The new config should looks like this:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `Vagrantfile` 并设置 `cgroup.memory.limit_in_bytes` cgroup 限制。新的配置应该如下所示：
- en: '[PRE88]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Save the file and start back the Vagrant machine:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并重新启动 Vagrant 虚拟机：
- en: '[PRE89]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Verify that the cgroup limit was applied:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证是否应用了 cgroup 限制：
- en: '[PRE90]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Finally, let''s clean up by deleting all remnants of the Vagrant machine:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们通过删除所有 Vagrant 虚拟机残留文件来清理：
- en: '[PRE91]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Putting it all together – building a simple RESTful API to LXC with Python
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容结合起来 – 使用 Python 构建一个简单的 LXC RESTful API
- en: With all the knowledge we have in hand by experimenting with the LXC bindings
    for Python earlier, we can write a simple RESTful API that will build, manage,
    and destroy LXC containers.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 通过之前实验 Python 的 LXC 绑定所掌握的所有知识，我们可以编写一个简单的 RESTful API，来构建、管理和销毁 LXC 容器。
- en: Note
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To keep the code as simple as possible, we are going to skip all error and exception
    handling and any input validation from the program.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持代码尽可能简单，我们将跳过所有错误和异常处理以及程序中的任何输入验证。
- en: 'One of the simplest Python web frameworks for building APIs is Bottle. Let''s
    install it first:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 用于构建 API 的最简单 Python Web 框架之一是 Bottle。我们先安装它：
- en: '[PRE92]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Make sure you have both the `bottle` and `lxc-python2` libraries installed
    before continuing:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保安装了 `bottle` 和 `lxc-python2` 库：
- en: '[PRE93]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Let''s open the new `lxc_api.py` file and write the following code:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 打开新创建的 `lxc_api.py` 文件并编写以下代码：
- en: '[PRE94]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The `run` class provides the `run()` call, which starts a built-in server. In
    our example, the server will be listening on localhost, port `8080`. The `get()`
    decorator links the code from the function below it to an URL path. In the preceding
    code, the `/list` path is bound to the `list()` function. Of course, you are already
    familiar with the `list_containers()` method.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`run`类提供了`run()`调用，用于启动内置服务器。在我们的示例中，服务器将监听本地主机上的`8080`端口。`get()`装饰器将下方函数中的代码链接到一个
    URL 路径。在前面的代码中，`/list`路径与`list()`函数绑定。当然，您已经熟悉了`list_containers()`方法。'
- en: 'To test this simple API frontend, save the file and execute the program:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这个简单的 API 前端，保存文件并执行程序：
- en: '[PRE95]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Tip
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you get the `socket.error: [Errno 98] Address already in use` error, there''s
    another process that is bound to port `8080`. To fix this, simply change the port
    your Python application is listening on in the `run()` method.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你遇到`socket.error: [Errno 98] Address already in use`错误，说明另一个进程已经绑定了`8080`端口。要解决此问题，只需在`run()`方法中更改
    Python 应用程序监听的端口。'
- en: 'In a separate terminal window, execute the following:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个独立的终端窗口中，执行以下操作：
- en: '[PRE96]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: It's just that simple; we created an API call to list LXC containers!
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这么简单；我们创建了一个 API 调用来列出 LXC 容器！
- en: API calls to build and configure LXC containers
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于构建和配置 LXC 容器的 API 调用
- en: 'Let''s expand the functionality a bit by adding the ability to build containers.
    Edit the file and add the following function:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微扩展一下功能，添加构建容器的能力。编辑文件并添加以下函数：
- en: '[PRE97]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: We are going to use the `@post` decorator in this case and the provided `headers.get()`
    method from the `request` class to get the custom headers that will contain the
    container and template names.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将使用`@post`装饰器和`request`类提供的`headers.get()`方法来获取包含容器和模板名称的自定义头信息。
- en: Note
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a complete API reference of the Bottle framework refer to [http://bottlepy.org/docs/dev/api.html](http://bottlepy.org/docs/dev/api.html).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Bottle 框架的完整 API 参考，请参阅[http://bottlepy.org/docs/dev/api.html](http://bottlepy.org/docs/dev/api.html)。
- en: 'Save the updated file and restart the program. Let''s test the new call in
    the second terminal:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 保存更新的文件并重启程序。让我们在第二个终端中测试新的调用：
- en: '[PRE98]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We used the `--header` flags to pass the container and template names with
    `curl` as headers, using the `POST` verb. If you check the terminal where the
    application is running you can see the logs of the container being built, along
    with the HTTP route and the error code:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`--header`标志通过`curl`将容器和模板名称作为头信息传递，使用`POST`动词。如果你检查正在运行的应用程序的终端，你可以看到容器构建的日志，以及
    HTTP 路由和错误代码：
- en: '[PRE99]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Let''s use the `/list` route we defined earlier to list all containers:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用之前定义的`/list`路由来列出所有容器：
- en: '[PRE100]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Great! We can now build and list containers. Let''s create a new route that
    will start LXC. Add the following function to the `lxc_api.py` file:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们可以构建和列出容器了。让我们创建一个新路由来启动 LXC。将以下函数添加到`lxc_api.py`文件中：
- en: '[PRE101]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'We are using the `POST` decorator again and a dynamic route. The dynamic route
    consists of a name, in our example called `<name>`, which will hold whatever string
    value we pass to the route with the `curl` command. The method that is bound to
    the `container_start(name)` route also accepts a variable with the same name.
    Save the changes, restart the application, and execute the following:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用了`POST`装饰器和动态路由。动态路由由一个名称组成，在我们的示例中为`<name>`，它将保存我们通过`curl`命令传递给路由的字符串值。绑定到`container_start(name)`路由的方法也接受一个同名的变量。保存更改，重启应用程序，并执行以下操作：
- en: '[PRE102]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: We passed `api_container` in the URL, and the route we defined was able to match
    it and pass it as a variable to the `container_start` function.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 URL 中传递了`api_container`，并且我们定义的路由能够匹配它，并将其作为变量传递给`container_start`函数。
- en: 'Our simple API does not yet provide a route to get the status of a container,
    so let''s ensure it''s really running:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的简单 API 尚未提供获取容器状态的路由，所以让我们确保它确实在运行：
- en: '[PRE103]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Let''s add a `state` call to our API:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向 API 添加一个`state`调用：
- en: '[PRE104]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'This time we are using the `@get` decorator and calling the `state()` method
    on the `container` object. Let''s test the new route:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们使用了`@get`装饰器，并在`container`对象上调用了`state()`方法。让我们测试一下新路由：
- en: '[PRE105]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Now that we have a running container, let''s add the functionality to list
    its IP address:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个正在运行的容器，让我们添加列出其 IP 地址的功能：
- en: '[PRE106]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'There is nothing new to note here, so let''s see what we get back:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么新的需要注意的内容，接下来让我们看看返回的结果：
- en: '[PRE107]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'We saw how to freeze and unfreeze containers earlier in this chapter; let''s
    now add that functionality to our API:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经在本章中看到如何冻结和解冻容器；现在让我们把这个功能添加到我们的 API 中：
- en: '[PRE108]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The `POST` verb makes more sense here, since we are making changes to the state
    of the container. Let''s freeze the container and check its state:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用 `POST` 方法更为合适，因为我们正在修改容器的状态。现在让我们冻结容器并检查其状态：
- en: '[PRE109]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Finally, let''s unfreeze it with the new API call we made:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们用我们刚才创建的新的 API 调用解冻它：
- en: '[PRE110]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Next, as a conclusion, let''s write two new functions to stop and delete the
    container:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，作为结论，我们将编写两个新函数来停止和删除容器：
- en: '[PRE111]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: All the methods we've used so far, we've tested earlier in this chapter; feel
    free to refer back to their description as needed.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用的所有方法，都已经在本章中进行过测试；如有需要，请随时参考它们的描述。
- en: Cleaning up using the API calls
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 API 调用进行清理
- en: 'It''s time to clean up, by calling the `stop` API route:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是清理的时候了，通过调用 `stop` API 路由：
- en: '[PRE112]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The console with the running application should show something similar to this
    after making all the preceding API calls:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行完之前的所有 API 调用后，控制台中的运行应用程序应显示类似如下内容：
- en: '[PRE113]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Finally, let''s destroy the container:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们销毁容器：
- en: '[PRE114]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: We can easily add all the LXC Python methods we experimented with earlier, by
    following the same pattern – just remember to catch all exceptions and validate
    the input.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地添加之前实验过的所有 LXC Python 方法，只需遵循相同的模式 —— 只需记住捕获所有异常并验证输入。
- en: 'Here''s the entire program:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这是整个程序：
- en: '[PRE115]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Summary
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The bindings for Python provided by the LXC and libvirt APIs are a great way
    to programmatically create and manage LXC containers.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: LXC 和 libvirt API 提供的 Python 绑定是编程创建和管理 LXC 容器的一个好方法。
- en: In this chapter, we explored both sets of Python bindings, by writing simple
    code snippets that implement most of the functions provided by the userspace tools.
    In fact, the best way to learn about those APIs is to look at the source code
    of the command-line tools, although they are implemented in C.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过编写简单的代码片段，探索了两组 Python 绑定，这些代码实现了用户空间工具提供的大部分功能。事实上，了解这些 API 的最佳方法是查看命令行工具的源代码，尽管它们是用
    C 语言实现的。
- en: We had a brief introduction in how to provision LXC with Vagrant for testing
    your code in isolation. We ended the chapter with a working implementation of
    a simple RESTful API that uses some of the methods we explored earlier to provision,
    manage, and destroy LXC. In [Chapter 5](ch05.html "Chapter 5. Networking in LXC
    with the Linux Bridge and Open vSwitch"), *Networking in LXC with the Linux Bridge
    and Open vSwitch*, we'll explore the networking aspects of LXC, using the Linux
    bridge, Open vSwitch in NAT, and direct routing modes, and look into examples
    of how to interconnect containers and the host OS.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要介绍了如何使用 Vagrant 配置 LXC，以便在隔离的环境中测试代码。我们在本章的结尾实现了一个简单的 RESTful API，该 API
    使用我们之前探索的一些方法来配置、管理和销毁 LXC。在[第 5 章](ch05.html "第 5 章：使用 Linux 桥接和 Open vSwitch
    在 LXC 中进行网络配置")，*在 LXC 中使用 Linux 桥接和 Open vSwitch 进行网络配置*，我们将探讨 LXC 的网络方面，使用 Linux
    桥接、NAT 中的 Open vSwitch 和直接路由模式，并查看如何互联容器与宿主操作系统的示例。
