- en: Chapter 7. OpenShift for Java Developers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章：OpenShift for Java 开发者
- en: 'This chapter presents a number of recipes that show you how to get started
    with Java web application development on OpenShift. You will learn how to create
    and deploy **Java Enterprise Edition** (**Java EE**) applications on OpenShift
    using the JBoss EAP 6 and JBoss AS 7 application server cartridges. This chapter
    will also cover how to develop and host your Spring Framework applications on
    the Tomcat server. The specific recipes within this chapter are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一些示例，展示如何在 OpenShift 上开始 Java Web 应用程序开发。你将学习如何使用 JBoss EAP 6 和 JBoss AS
    7 应用程序服务器组件，在 OpenShift 上创建和部署**Java 企业版** (**Java EE**) 应用程序。本章还将涵盖如何在 Tomcat
    服务器上开发和托管 Spring 框架应用程序。本章的具体示例如下：
- en: Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JBoss EAP 和 PostgreSQL 9.2 组件创建并部署 Java EE 6 应用程序
- en: Configuring application security by defining the database login module in standalone.xml
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在 standalone.xml 中定义数据库登录模块来配置应用程序安全性
- en: Installing modules with JBoss cartridges
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JBoss 组件安装模块
- en: Managing JBoss cartridges using the management web interface and CLI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用管理 Web 界面和 CLI 管理 JBoss 组件
- en: Creating and deploying Spring applications using the Tomcat 7 cartridge
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Tomcat 7 组件创建并部署 Spring 应用程序
- en: Taking thread dumps of Java cartridges
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取 Java 组件的线程转储
- en: Choosing between Java 6 and Java 7
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Java 6 和 Java 7 之间进行选择
- en: Enabling hot deployment for Java applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Java 应用程序启用热部署
- en: Skipping the Maven build
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳过 Maven 构建
- en: Forcing a clean Maven build
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制进行干净的 Maven 构建
- en: Overriding the default Maven build command
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重写默认的 Maven 构建命令
- en: Installing the JAR file not present in the Maven central repository
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装在 Maven 中央仓库中没有的 JAR 文件
- en: Developing OpenShift Java applications using Eclipse
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Eclipse 开发 OpenShift Java 应用程序
- en: Using Eclipse System Explorer to SSH into the application gear
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Eclipse 系统资源管理器通过 SSH 连接到应用程序设备
- en: Debugging Java applications in the Cloud
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在云中调试 Java 应用程序
- en: Introduction
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter will explore how Java developers can get started with OpenShift
    to develop Java EE or Spring applications. Java is often thought of as the de
    facto open source, enterprise programming language. OpenShift supports the JBoss
    application server, which is a certified platform for Java EE 6 development. As
    an OpenShift Online user, you have access to both the community version of JBoss
    and commercial JBoss EAP 6 for free. The *Creating and deploying Java EE 6 applications
    using the JBoss EAP and PostgreSQL 9.2 cartridges* recipe will cover how to develop
    and deploy Java EE 6 applications on OpenShift. There is also a community-supported
    cartridge for WildFly, a certified Java EE 7 application server that you can use
    to deploy Java EE 7 applications. This chapter will not cover the WildFly cartridge.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨 Java 开发者如何使用 OpenShift 开始开发 Java EE 或 Spring 应用程序。Java 通常被认为是事实上的开源企业编程语言。OpenShift
    支持 JBoss 应用程序服务器，这是 Java EE 6 开发的认证平台。作为 OpenShift Online 用户，你可以免费使用 JBoss 社区版和商业版
    JBoss EAP 6。*使用 JBoss EAP 和 PostgreSQL 9.2 组件创建并部署 Java EE 6 应用程序* 的示例将展示如何在 OpenShift
    上开发和部署 Java EE 6 应用程序。此外，OpenShift 还支持 WildFly 组件，这是一个认证的 Java EE 7 应用程序服务器，你可以使用它来部署
    Java EE 7 应用程序。本章不会讨论 WildFly 组件。
- en: 'A popular alternative to Java EE development is Spring Framework. Spring developers
    normally use Apache Tomcat to host their applications. OpenShift supports two
    versions of Tomcat: Apache Tomcat 6 and Apache Tomcat 7\. The *Creating and deploying
    Spring applications using the Tomcat 7 cartridge* recipe will cover how to develop
    a Spring application and deploy it on OpenShift. Also, it is possible to run Apache
    Tomcat 8 (currently in beta) on OpenShift. You can read my blog to learn how to
    deploy Apache Tomcat 8 on OpenShift at [https://www.openshift.com/blogs/how-to-run-apache-tomcat-8-on-openshift](https://www.openshift.com/blogs/how-to-run-apache-tomcat-8-on-openshift).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流行的 Java EE 开发替代方案是 Spring 框架。Spring 开发者通常使用 Apache Tomcat 来托管他们的应用程序。OpenShift
    支持两个版本的 Tomcat：Apache Tomcat 6 和 Apache Tomcat 7。*使用 Tomcat 7 组件创建并部署 Spring 应用程序*
    的示例将展示如何开发一个 Spring 应用程序并将其部署到 OpenShift。同时，OpenShift 也可以运行 Apache Tomcat 8（目前处于测试阶段）。你可以阅读我的博客，了解如何在
    OpenShift 上部署 Apache Tomcat 8，链接：[https://www.openshift.com/blogs/how-to-run-apache-tomcat-8-on-openshift](https://www.openshift.com/blogs/how-to-run-apache-tomcat-8-on-openshift)。
- en: OpenShift uses Apache Maven to manage dependencies and build your OpenShift
    apps. All OpenShift Java applications are Maven-based applications. This chapter
    assumes that you are familiar with Apache Maven. In the event that you are not
    comfortable with Maven, then please refer to the documentation at [http://maven.apache.org/guides/getting-started/index.html](http://maven.apache.org/guides/getting-started/index.html).
    This chapter will cover various aspects of using Apache Maven with OpenShift,
    such as how to use your own JARs (not hosted on the Maven central repository)
    with OpenShift, and so on. OpenShift also allows you to use other build tools,
    such as Apache Ant and Gradle. Please refer to my blogs on Apache Ant ([https://www.openshift.com/blogs/running-ant-builds-on-openshift](https://www.openshift.com/blogs/running-ant-builds-on-openshift))
    and Gradle ([https://www.openshift.com/blogs/run-gradle-builds-on-openshift](https://www.openshift.com/blogs/run-gradle-builds-on-openshift))
    to learn how to use them with OpenShift applications.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift 使用 Apache Maven 来管理依赖并构建你的 OpenShift 应用程序。所有 OpenShift Java 应用程序都是基于
    Maven 的应用程序。本章假设你已熟悉 Apache Maven。如果你对 Maven 不太熟悉，请参考[http://maven.apache.org/guides/getting-started/index.html](http://maven.apache.org/guides/getting-started/index.html)的文档。本章将涉及使用
    Apache Maven 与 OpenShift 配合的各个方面，例如如何将你自己的 JAR（非托管于 Maven 中央仓库）与 OpenShift 一起使用等。OpenShift
    还允许你使用其他构建工具，如 Apache Ant 和 Gradle。请参考我的博客，了解如何将 Apache Ant（[https://www.openshift.com/blogs/running-ant-builds-on-openshift](https://www.openshift.com/blogs/running-ant-builds-on-openshift)）和
    Gradle（[https://www.openshift.com/blogs/run-gradle-builds-on-openshift](https://www.openshift.com/blogs/run-gradle-builds-on-openshift)）与
    OpenShift 应用程序一起使用。
- en: Almost all Java developers use an IDE to build their applications. OpenShift
    has first-class support for the Eclipse IDE. The *Developing OpenShift Java applications
    using Eclipse* recipe will walk you through a step-by-step process of creating
    and managing an application from within Eclipse. You can even SSH into the application
    gear from within Eclipse. This will be covered in the *Using Eclipse System Explorer
    to SSH into the application gear* recipe.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的 Java 开发者都会使用 IDE 来构建他们的应用程序。OpenShift 对 Eclipse IDE 提供了一流的支持。*使用 Eclipse
    开发 OpenShift Java 应用程序*这一章节将带你逐步完成从 Eclipse 内创建和管理应用程序的过程。你甚至可以直接从 Eclipse 内 SSH
    连接到应用程序的 Gear 中。这将在*使用 Eclipse 系统资源管理器通过 SSH 连接到应用程序 Gear*的章节中进行讲解。
- en: 'If you want to run the examples on your local machine, then please install
    Java 7, Apache Maven, and Eclipse. The instructions to install Java for your operating
    system can be found at [http://www.java.com/en/download/help/download_options.xml](http://www.java.com/en/download/help/download_options.xml).
    Next, instructions to install Apache Maven can be found here: [http://maven.apache.org/download.cgi#Installation](http://maven.apache.org/download.cgi#Installation).
    Finally, you can install Eclipse on your machine by following the instructions
    mentioned here: [http://wiki.eclipse.org/Eclipse/Installation](http://wiki.eclipse.org/Eclipse/Installation).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在本地机器上运行示例，请安装 Java 7、Apache Maven 和 Eclipse。你可以在[http://www.java.com/en/download/help/download_options.xml](http://www.java.com/en/download/help/download_options.xml)找到针对你的操作系统安装
    Java 的说明。接下来，关于安装 Apache Maven 的说明可以在此找到：[http://maven.apache.org/download.cgi#Installation](http://maven.apache.org/download.cgi#Installation)。最后，你可以按照此处的说明安装
    Eclipse：[http://wiki.eclipse.org/Eclipse/Installation](http://wiki.eclipse.org/Eclipse/Installation)。
- en: This chapter is based on the assumption that you know the basics of OpenShift
    application development and database cartridges. In the event that you are not
    comfortable with the basics, I will recommend that you first read [Chapter 3](part0041_split_000.html#page
    "Chapter 3. Creating and Managing Applications"), *Creating and Managing Applications*
    to [Chapter 6](part0079_split_000.html#page "Chapter 6. Using MongoDB and Third-party
    Database Cartridges with OpenShift Applications"), *Using MongoDB and Third-party
    Database Cartridges with OpenShift Applications* before continuing with this chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节假设你已经了解 OpenShift 应用程序开发和数据库 Cartridge 的基础。如果你对这些基础不太熟悉，建议你先阅读[第 3 章](part0041_split_000.html#page
    "第 3 章 创建与管理应用程序")，*创建与管理应用程序*，然后阅读[第 6 章](part0079_split_000.html#page "第 6 章
    使用 MongoDB 和第三方数据库 Cartridge 与 OpenShift 应用程序")，*使用 MongoDB 和第三方数据库 Cartridge
    与 OpenShift 应用程序*，再继续本章内容。
- en: In this chapter, we will develop a simple job portal application that will allow
    users to post job openings for a company. Users can create a company and then
    post jobs for that company. All the source code is on the *OpenShift-Cookbook*
    repository of the GitHub organization at [https://github.com/OpenShift-Cookbook](https://github.com/OpenShift-Cookbook).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开发一个简单的职位门户应用程序，允许用户为公司发布职位空缺。用户可以创建公司并为该公司发布职位。所有源代码都可以在 GitHub 组织的
    *OpenShift-Cookbook* 仓库中找到，地址是 [https://github.com/OpenShift-Cookbook](https://github.com/OpenShift-Cookbook)。
- en: Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JBoss EAP 和 PostgreSQL 9.2 cartridge 创建和部署 Java EE 6 应用程序
- en: Gone are the days when Java EE or J2EE (as it was called in the olden days)
    was considered evil. Java EE now provides a very productive environment to build
    web applications. Java EE has embraced convention over configuration and annotations,
    which means that you are no longer required to maintain XML to configure each
    and every component. In this recipe, you will learn how to build a Java EE 6 application
    and deploy it on OpenShift. This recipe assumes that you have basic knowledge
    of Java and Java EE 6\. If you are not comfortable with Java EE 6, please read
    the official tutorial at [http://docs.oracle.com/javaee/6/tutorial/doc/](http://docs.oracle.com/javaee/6/tutorial/doc/).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 曾几何时，Java EE 或 J2EE（在过去的日子里是这么称呼的）被视为邪恶的存在。如今，Java EE 提供了一个非常高效的环境来构建 Web 应用程序。Java
    EE 已经拥抱了“约定优于配置”和注解，这意味着你不再需要维护 XML 来配置每一个组件。在本篇教程中，你将学习如何构建一个 Java EE 6 应用程序，并将其部署到
    OpenShift。此教程假定你具备 Java 和 Java EE 6 的基础知识。如果你对 Java EE 6 不熟悉，请阅读官方教程，网址是 [http://docs.oracle.com/javaee/6/tutorial/doc/](http://docs.oracle.com/javaee/6/tutorial/doc/)。
- en: In this recipe, you will build a simple job portal that will allow users to
    post job openings and view a list of all the persisted jobs in the system. These
    two functionalities will be exposed using two REST endpoints.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，你将构建一个简单的职位门户，允许用户发布职位空缺，并查看系统中所有已保存职位的列表。这两个功能将通过两个 REST 端点暴露出来。
- en: The source code for the application created in this recipe is on GitHub at [https://github.com/OpenShift-Cookbook/chapter7-jobstore-javaee6-simple](https://github.com/OpenShift-Cookbook/chapter7-jobstore-javaee6-simple).
    The example application that you will build in this recipe is a simple version
    of the `jobstore` application with only a single domain class and without any
    application interface. You can get the complete `jobstore` application source
    code on GitHub as well at [https://github.com/OpenShift-Cookbook/chapter7-jobstore-javaee6](https://github.com/OpenShift-Cookbook/chapter7-jobstore-javaee6).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程中创建的应用程序的源代码可在 GitHub 上找到，地址是 [https://github.com/OpenShift-Cookbook/chapter7-jobstore-javaee6-simple](https://github.com/OpenShift-Cookbook/chapter7-jobstore-javaee6-simple)。你将在本教程中构建的示例应用程序是
    `jobstore` 应用程序的简化版本，只有一个域类，并且没有任何应用程序界面。你也可以在 GitHub 上找到完整的 `jobstore` 应用程序源代码，地址是
    [https://github.com/OpenShift-Cookbook/chapter7-jobstore-javaee6](https://github.com/OpenShift-Cookbook/chapter7-jobstore-javaee6)。
- en: Getting ready
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To complete this recipe, you will need the `rhc` command-line client installed
    on your machine. Please refer to the *Installing the OpenShift rhc command-line
    client* recipe in [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting
    Started with OpenShift"), *Getting Started with OpenShift*, for details. Also,
    you will need an IDE to work with the application code. The recommended IDE to
    work with OpenShift is Eclipse Luna, but you can also work with other IDEs, such
    as IntelliJ Idea and NetBeans. Download and install the Eclipse IDE for Java EE
    developers from the official website at [https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本教程，你需要在机器上安装 `rhc` 命令行客户端。有关详细信息，请参阅 [第 1 章](part0014_split_000.html#page
    "Chapter 1. Getting Started with OpenShift") 中的 *安装 OpenShift rhc 命令行客户端* 教程，标题为
    *开始使用 OpenShift*。此外，你还需要一个 IDE 来处理应用程序代码。推荐使用的 IDE 是 Eclipse Luna，但你也可以使用其他 IDE，如
    IntelliJ Idea 和 NetBeans。从官方网站下载并安装适用于 Java EE 开发者的 Eclipse IDE，网址是 [https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/)。
- en: How to do it…
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Perform the following steps to create the `jobstore` application:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建 `jobstore` 应用程序：
- en: 'Open a new command-line terminal, and go to a convenient location. Create a
    new JBoss EAP application by executing the following command:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的命令行终端，并进入一个方便的位置。通过执行以下命令创建一个新的 JBoss EAP 应用程序：
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding command will create a Maven project and clone it to your local
    machine.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述命令将创建一个 Maven 项目并将其克隆到你的本地机器。
- en: 'Change the directory to `jobstore`, and execute the following command to add
    the PostgreSQL 9.2 cartridge to the application:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将目录更改为`jobstore`，然后执行以下命令将PostgreSQL 9.2 cartridge添加到应用程序中：
- en: '[PRE1]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Open Eclipse and navigate to the project workspace. Then, import the application
    created in step 1 as a Maven project. To import an existing Maven project, navigate
    to **File**|**Import**|**Maven**|**Existing Maven Projects**. Then, navigate to
    the location of your OpenShift Maven application created in step 1.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Eclipse并导航到项目工作空间。然后，将步骤1中创建的应用程序作为Maven项目导入。要导入现有的Maven项目，请导航至**文件**|**导入**|**Maven**|**现有的Maven项目**。然后，导航到您在步骤1中创建的OpenShift
    Maven应用程序的位置。
- en: 'Next, update `pom.xml` to use Java 7\. The Maven project created by OpenShift
    is configured to use JDK 6\. Replace the properties with the one shown in the
    following code:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新`pom.xml`以使用Java 7。OpenShift创建的Maven项目配置为使用JDK 6。请使用以下代码替换属性：
- en: '[PRE2]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Update the Maven project to allow the changes to take effect. You can update
    the Maven project by right-clicking on the project and navigating to **Maven**|**Update
    Project**.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新Maven项目以使更改生效。可以右键单击项目，然后导航至**Maven**|**更新项目**。
- en: 'Now, let us write the domain classes for our application. Java EE uses JPA
    to define the data model and manage entities. The application has one domain class:
    `Job`. Create a new package called `org.osbook.jobstore.domain`, and then create
    a new Java class called `Job` inside it. Have a look at the following code:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写应用程序的领域类。Java EE使用JPA定义数据模型并管理实体。应用程序有一个领域类：`Job`。创建一个名为`org.osbook.jobstore.domain`的新包，然后在其中创建一个名为`Job`的新Java类。请查看以下代码：
- en: '[PRE3]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a `META-INF` folder at `src/main/resources`, and then create a `persistence.xml`
    file with the following code:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/main/resources`下创建一个`META-INF`文件夹，然后创建一个名为`persistence.xml`的文件，其中包含以下代码：
- en: '[PRE4]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, we will create the `JobService` class that will use the JPA `EntityManager`
    API to work with the database. Create a new package called `org.osbook.jobstore.services`,
    and create a new Java class as shown in the following code. It defines the `save`
    and `findAll` operations on the `Job` entity.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建`JobService`类，该类将使用JPA `EntityManager` API与数据库交互。创建一个名为`org.osbook.jobstore.services`的新包，并创建一个新的Java类，如下所示。它定义了`Job`实体上的`save`和`findAll`操作。
- en: '[PRE5]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, enable **Contexts and Dependency Injection** (**CDI**) in the `jobstore`
    application by creating a file with the name `beans.xml` in the `src/main/webapp/WEB-INF`
    directory as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`jobstore`应用程序中通过在`src/main/webapp/WEB-INF`目录下创建一个名为`beans.xml`的文件来启用**上下文和依赖注入**（**CDI**），如下所示：
- en: '[PRE6]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `jobstore` application will expose the REST JSON web service. Before you
    can write the JAX-RS resources, you have to configure JAX-RS in your application.
    Create a new package called `org.osbook.jobstore.rest` and a new class called
    `RestConfig`, as shown in the following code:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`jobstore`应用程序将公开REST JSON web服务。在编写JAX-RS资源之前，您必须在应用程序中配置JAX-RS。创建一个名为`org.osbook.jobstore.rest`的新包和一个名为`RestConfig`的新类，如下所示：'
- en: '[PRE7]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a JAX-RS resource to expose the `create` and `findAll` operations of
    `JobService` as REST endpoints as follows:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建JAX-RS资源以暴露`JobService`的`create`和`findAll`操作作为REST端点，如下所示：
- en: '[PRE8]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Commit the code, and push it to the OpenShift application as shown in the following
    commands:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示提交代码，并将其推送到OpenShift应用程序中：
- en: '[PRE9]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After the build finishes successfully, the application will be accessible at
    `http://jobstore-{domain-name}.rhcloud.com`. Please replace `domain-name` with
    your own domain name.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建成功完成后，应用程序将在`http://jobstore-{domain-name}.rhcloud.com`上访问。请将`domain-name`替换为您自己的域名。
- en: 'To test the REST endpoints, you can use `curl`. `curl` is a command-line tool
    for transferring data across various protocols. We will use it to test our REST
    endpoints. To create a new job, you will run the following `curl` command:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试REST端点，可以使用`curl`。`curl`是一个用于跨各种协议传输数据的命令行工具。我们将使用它来测试我们的REST端点。要创建一个新作业，您将运行以下`curl`命令：
- en: '[PRE10]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To view all the jobs, you can run the following `curl` command:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看所有作业，可以运行以下`curl`命令：
- en: '[PRE11]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works…
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In the preceding steps, we created a Java EE application and deployed it on
    OpenShift. In step 1, you used the `rhc create-app` command to create a JBoss
    EAP web cartridge application. The `rhc` command-line tool makes a request to
    the OpenShift broker and asks it to create a new application using the JBoss EAP
    cartridge. The anatomy of application creation was explained in the *Creating
    an OpenShift application using the rhc command-line client* recipe in [Chapter
    3](part0041_split_000.html#page "Chapter 3. Creating and Managing Applications"),
    *Creating and Managing Applications*. Every OpenShift web cartridge specifies
    a template application that will be used as the default source code of the application.
    For Java web cartridges (JBoss EAP, JBoss AS7, Tomcat 6, and Tomcat 7), the template
    is a Maven-based application. After the application is created, it is cloned to
    the local machine using Git. The directory structure of the application is shown
    in the following command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的步骤中，我们创建了一个Java EE应用程序并将其部署到OpenShift。在步骤1中，你使用`rhc create-app`命令创建了一个JBoss
    EAP Web卡片应用程序。`rhc`命令行工具向OpenShift代理发出请求，要求它使用JBoss EAP卡片创建一个新应用程序。应用程序创建的结构在[第3章](part0041_split_000.html#page
    "Chapter 3. Creating and Managing Applications")的*使用rhc命令行客户端创建OpenShift应用程序*一节中进行了说明，*创建和管理应用程序*。每个OpenShift
    Web卡片都会指定一个模板应用程序，用作应用程序的默认源代码。对于Java Web卡片（JBoss EAP、JBoss AS7、Tomcat 6和Tomcat
    7），模板是一个基于Maven的应用程序。应用程序创建后，它会通过Git克隆到本地机器。应用程序的目录结构如下所示：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see in the preceding command, apart from the `.git` and `.openshift`
    directories, this looks like a standard Maven project. OpenShift uses Maven to
    manage application dependencies and build your Java applications.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在前面的命令中所看到的，除了`.git`和`.openshift`目录外，这看起来像一个标准的Maven项目。OpenShift使用Maven来管理应用程序的依赖关系并构建你的Java应用程序。
- en: 'Let us take a look at what''s inside the `jobstore` directory to better understand
    the layout of the application:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`jobstore`目录中的内容，以更好地了解应用程序的布局：
- en: '**The src directory**: This directory contains the source code for the template
    application generated by OpenShift. You need to add your application source code
    here. The `src` folder helps in achieving source code deployment when following
    the standard Maven directory conventions.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**src目录**：该目录包含由OpenShift生成的模板应用程序的源代码。你需要在这里添加你的应用程序源代码。`src`文件夹有助于按照标准Maven目录约定实现源代码的部署。'
- en: '**The pom.xml file**: The Java applications created by OpenShift are Maven-based
    projects. So, a `pom.xml` file is required when you do source code deployment
    on OpenShift. This `pom.xml` file has a profile called `openshift`, which will
    be executed when you push code to OpenShift as shown in the following code. This
    profile will create a `ROOT` WAR file based upon your application source code.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pom.xml文件**：由OpenShift创建的Java应用程序是基于Maven的项目。因此，在OpenShift上进行源代码部署时需要一个`pom.xml`文件。此`pom.xml`文件有一个名为`openshift`的配置文件，当你将代码推送到OpenShift时，将执行此配置文件，如以下代码所示。此配置文件将基于你的应用程序源代码创建一个`ROOT`
    WAR文件。'
- en: '[PRE13]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**The deployments directory**: You should use this directory if you want to
    do binary deployments on OpenShift, that is, you want to deploy a WAR or EAR file
    directly instead of pushing the source code.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**deployments目录**：如果你想在OpenShift上进行二进制部署，即直接部署WAR或EAR文件而不是推送源代码，你应该使用此目录。'
- en: '**The .git directory**: This is a local Git repository. This directory contains
    the complete history of the repository. The `config` file in`.git/` contains the
    configuration for the repository. It defines a Git remote origin that points to
    the OpenShift application gear SSH URL. This makes sure that when you do `git
    push`, the source code is pushed to the remote Git repository hosted on your application
    gear. You can view the details of the origin Git remote by executing the following
    command:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.git目录**：这是一个本地Git仓库。该目录包含仓库的完整历史记录。`.git/`中的`config`文件包含仓库的配置。它定义了指向OpenShift应用程序齿轮SSH
    URL的Git远程源。这确保了当你执行`git push`时，源代码会被推送到托管在应用程序齿轮上的远程Git仓库。你可以通过执行以下命令查看远程Git源的详细信息：'
- en: '[PRE14]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**The .openshift directory**: This is an OpenShift-specific directory, which
    can be used for the following purposes:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.openshift目录**：这是一个OpenShift特有的目录，可以用于以下目的：'
- en: The files under the `action_hooks` subdirectory allow you to hook onto the application
    lifecycle.
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`action_hooks`子目录下的文件允许你挂钩到应用程序生命周期中。'
- en: The files under the `config` subdirectory allow you to make changes to the JBoss
    EAP configuration. The directory contains the `standalone.xml` JBoss EAP-specific
    configuration file.
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config`子目录下的文件允许你对JBoss EAP配置进行更改。该目录包含JBoss EAP特定的配置文件`standalone.xml`。'
- en: The files under the `cron` subdirectory are used when you add the cron cartridge
    to your application. This allows you to run scripts or jobs on a periodic basis.
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cron`子目录下的文件在你将cron卡带添加到应用程序时使用。这使得你可以定期运行脚本或作业。'
- en: The files under the `markers` subdirectory allow you to specify whether you
    want to use Java 6 or Java 7 or you want to do hot deploy or debug the application
    running in the Cloud, and so on.
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`markers`子目录下的文件允许你指定是否使用Java 6或Java 7，或者你是否希望进行热部署或调试在云端运行的应用程序等操作。'
- en: In step 2, you added the PostgreSQL 9.2 cartridge to the application using the
    `rhc cartridge-add` command. We will use the PostgreSQL database to store the
    `jobstore` application data. Then, in step 3, you imported the project in the
    Eclipse IDE as a Maven project. Eclipse Kepler has inbuilt support for Maven applications,
    which makes it easier to work with Maven-based applications.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2步中，你使用`rhc cartridge-add`命令将PostgreSQL 9.2卡带添加到应用程序中。我们将使用PostgreSQL数据库来存储`jobstore`应用程序的数据。接着，在第3步中，你将项目作为Maven项目导入到Eclipse
    IDE中。Eclipse Kepler内置对Maven应用程序的支持，这使得使用基于Maven的应用程序更加方便。
- en: From step 3 through step 5, you updated the project to use JDK 1.7 for the Maven
    compiler plugin. All the OpenShift Java applications use OpenJDK 7, so it makes
    sense to update the application to also use JDK 1.7 for compilation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从第3步到第5步，你更新了项目，以使用JDK 1.7作为Maven编译插件的编译器。所有的OpenShift Java应用程序都使用OpenJDK 7，因此更新应用程序以使用JDK
    1.7进行编译是合乎逻辑的。
- en: In step 6, you created the `job` domain class and annotated it with JPA annotations.
    The `@Entity` annotation marks the class as a JPA entity. An entity represents
    a table in the relational database, and each entity instance corresponds to a
    row in the table. Entity class fields represent the persistent state of the entity.
    You can learn more about JPA by reading the official documentation at [http://docs.oracle.com/javaee/6/tutorial/doc/bnbpz.html](http://docs.oracle.com/javaee/6/tutorial/doc/bnbpz.html).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6步中，你创建了`job`领域类并使用JPA注解对其进行了标注。`@Entity`注解将该类标记为JPA实体类。实体类表示关系型数据库中的一张表，每个实体实例对应表中的一行。实体类的字段表示实体的持久化状态。你可以通过阅读[http://docs.oracle.com/javaee/6/tutorial/doc/bnbpz.html](http://docs.oracle.com/javaee/6/tutorial/doc/bnbpz.html)上的官方文档，了解更多关于JPA的内容。
- en: The `@NotNull` and `@Size` annotation marks are Bean Validation annotations.
    Bean Validation is a new validation model available as a part of the Java EE 6
    platform. The `@NotNull` annotation adds a constraint that the value of the field
    must not be null. If the value is null, an exception will be raised. The `@Size`
    annotation adds a constraint that the value must match the specified minimum and
    maximum boundaries. You can learn more about Bean Validation by reading the official
    documentation at [http://docs.oracle.com/javaee/6/tutorial/doc/gircz.html](http://docs.oracle.com/javaee/6/tutorial/doc/gircz.html).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`@NotNull`和`@Size`注解是Bean验证注解。Bean验证是Java EE 6平台中的一种新验证模型。`@NotNull`注解添加了一个约束，要求字段的值不能为空。如果值为null，则会引发异常。`@Size`注解添加了一个约束，要求值符合指定的最小值和最大值边界。你可以通过阅读[http://docs.oracle.com/javaee/6/tutorial/doc/gircz.html](http://docs.oracle.com/javaee/6/tutorial/doc/gircz.html)上的官方文档，了解更多关于Bean验证的内容。'
- en: 'In JPA, entities are managed within a persistence context. Within the persistence
    context, the entity manager manages the entities. The configuration of the entity
    manager is defined in a standard configuration XML file called `persitence.xml`.
    In step 7, you created the `persistence.xml` file. The most important configuration
    option is the `jta-datasource-source` configuration tag. It points to `java:jboss/datasources/PostgreSQLDS`.
    When a user creates a JBoss EAP 6 application, then OpenShift defines a PostgreSQL
    datasource in the `standalone.xml` file. The `standalone.xml` file is a JBoss
    configuration file, which includes the technologies required by the Java EE 6
    full profile specification plus Java Connector 1.6 architecture, Java XML API
    for RESTful web services, and OSGi. Developers can override the configuration
    by making changes to the `standalone.xml` file in the `.openshift/config` location
    of your application directory. So, if you open the `standalone.xml` file in `.openshift/config/`
    in your favorite editor, you will find the following PostgreSQL datasource configuration:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JPA 中，实体在持久化上下文中进行管理。在持久化上下文中，实体管理器管理实体。实体管理器的配置在一个标准的配置 XML 文件 `persistence.xml`
    中定义。在第 7 步中，你创建了 `persistence.xml` 文件。最重要的配置选项是 `jta-datasource-source` 配置标签，它指向
    `java:jboss/datasources/PostgreSQLDS`。当用户创建 JBoss EAP 6 应用程序时，OpenShift 会在 `standalone.xml`
    文件中定义一个 PostgreSQL 数据源。`standalone.xml` 文件是一个 JBoss 配置文件，包含 Java EE 6 完整规范所需的技术以及
    Java Connector 1.6 架构、Java XML API 用于 RESTful Web 服务和 OSGi。开发人员可以通过更改应用程序目录中 `.openshift/config`
    位置的 `standalone.xml` 文件来覆盖配置。因此，如果你在你喜欢的编辑器中打开 `.openshift/config/` 中的 `standalone.xml`
    文件，你会发现以下 PostgreSQL 数据源配置：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In step 8, you created stateless **Enterprise JavaBeans** (**EJBs**) for our
    application service layer. The service classes work with the `EntityManager` API
    to perform operations on the `Job` entity.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 8 步中，你为我们的应用程序服务层创建了无状态的 **企业 JavaBeans** (**EJBs**)。服务类通过 `EntityManager`
    API 对 `Job` 实体进行操作。
- en: In step 9, you configured CDI by creating the `beans.xml` file in the `src/main/webapp/WEB-INF`
    directory. We are using CDI in our application so that we can use dependency injection
    instead of manually creating the objects ourselves. The CDI container will manage
    the bean life cycle, and the developer just has to write the business logic. To
    let the JBoss application server know that we are using CDI, we need to create
    a file called `beans.xml` in our `WEB-INF` directory. The file can be completely
    blank, but its presence tells the container that the CDI framework needs to be
    loaded.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 9 步中，你通过在 `src/main/webapp/WEB-INF` 目录下创建 `beans.xml` 文件来配置 CDI。我们在应用程序中使用
    CDI，以便能够使用依赖注入，而不是手动创建对象。CDI 容器将管理 bean 的生命周期，开发人员只需编写业务逻辑。为了让 JBoss 应用服务器知道我们在使用
    CDI，我们需要在 `WEB-INF` 目录下创建一个名为 `beans.xml` 的文件。该文件可以完全为空，但它的存在告诉容器需要加载 CDI 框架。
- en: In step 10 and step 11, you configured JAX-RS and defined the REST resources
    for the `Job` entity. You activated JAX-RS by creating a class that extends `javax.ws.rs.ApplicationPath`.
    You need to specify the base URL under which your web service will be available.
    This is done by annotating the `RestConfig` class with the `ApplicationPath` annotation.
    You used `/api/v1` as the application path.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 10 步和第 11 步中，你配置了 JAX-RS 并定义了 `Job` 实体的 REST 资源。你通过创建一个扩展 `javax.ws.rs.ApplicationPath`
    的类来激活 JAX-RS。你需要指定一个基本 URL，供你的 Web 服务使用。你通过为 `RestConfig` 类添加 `ApplicationPath`
    注解来完成此操作。你使用 `/api/v1` 作为应用程序路径。
- en: In step 12, you added and committed the changes to the local repository and
    then pushed the changes to the application gear. After the bits are pushed, OpenShift
    will stop all the cartridges and then invoke the `mvn -e clean package -Popenshift
    -DskipTests` command to build the project. Maven will build a `ROOT.war` file,
    which will be copied to the JBoss EAP `deployments` folder. After the build successfully
    finishes, all the cartridges are started. Then the new updated `ROOT.war` file
    will be deployed. You can view the running application at `http://jobstore-{domain-name}.rhcloud.com`.
    Please replace `{domain-name}` with your account domain name.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 12 步中，你将更改添加并提交到本地仓库，然后将更改推送到应用程序 gear。位文件推送后，OpenShift 会停止所有卡带，然后调用 `mvn
    -e clean package -Popenshift -DskipTests` 命令来构建项目。Maven 会构建一个 `ROOT.war` 文件，并将其复制到
    JBoss EAP 的 `deployments` 文件夹。构建成功完成后，所有卡带都会启动。然后，新的更新的 `ROOT.war` 文件将被部署。你可以通过
    `http://jobstore-{domain-name}.rhcloud.com` 查看运行中的应用程序。请将 `{domain-name}` 替换为你的账户域名。
- en: Finally, you tested the REST endpoints using `curl` in step 14.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您在第 14 步使用 `curl` 测试了 REST 端点。
- en: There's more…
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: 'You can perform all the aforementioned steps with just a single command as
    follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下单个命令执行上述所有步骤：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: See also
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: The *Configuring application security by defining the database login module
    in standalone.xml* recipe
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过在 standalone.xml 中定义数据库登录模块配置应用安全性* 配方'
- en: The *Managing JBoss cartridges using the management web interface and CLI* recipe
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用管理 Web 界面和 CLI 管理 JBoss 套件* 配方'
- en: Configuring application security by defining the database login module in standalone.xml
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过在 standalone.xml 中定义数据库登录模块配置应用安全性
- en: 'In the *Creating and deploying Java EE 6 applications using the JBoss EAP and
    PostgreSQL 9.2 cartridges* recipe, you learned how to develop a Java EE 6 application
    on OpenShift. The application allows you to create company entities and then assign
    jobs to them. The problem with the application is that it is not secured. The
    Java EE specification defines a simple, role-based security model for EJBs and
    web components. JBoss security is an extension to the application server and is
    included by default with your OpenShift JBoss applications. You can view the extension
    in the JBoss `standalone.xml` configuration file. The `standalone.xml` file exists
    in the `.openshift/config` location. The following code shows the extension:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *使用 JBoss EAP 和 PostgreSQL 9.2 套件创建和部署 Java EE 6 应用* 配方中，您学会了如何在 OpenShift
    上开发 Java EE 6 应用。该应用允许您创建公司实体并为其分配职位。此应用的问题在于它没有安全设置。Java EE 规范定义了一种简单的基于角色的安全模型，用于
    EJB 和 Web 组件。JBoss 安全性是应用服务器的扩展，并默认包含在 OpenShift JBoss 应用中。您可以在 JBoss `standalone.xml`
    配置文件中查看该扩展。`standalone.xml` 文件位于 `.openshift/config` 位置。以下代码展示了该扩展：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: OpenShift allows developers to update the `standalone.xml` configuration file
    to meet their application needs. You make a change to the `standalone.xml` configuration
    file, commit the change to the local Git repository, then push the changes to
    the OpenShift application gear. Then, after the successful build, OpenShift will
    replace the existing `standalone.xml` file with your updated configuration file
    and then finally start the server. But please make sure that your changes are
    valid; otherwise, the application will fail to start.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift 允许开发人员更新 `standalone.xml` 配置文件以满足其应用需求。您修改 `standalone.xml` 配置文件后，将更改提交到本地
    Git 仓库，并将更改推送到 OpenShift 应用服务器。然后，在成功构建后，OpenShift 会用您更新的配置文件替换现有的 `standalone.xml`
    文件，并最终启动服务器。但请确保您的更改是有效的，否则应用将无法启动。
- en: In this recipe, you will learn how to define the database login module in `standalone.xml`
    to authenticate users before they can perform any operation with the application.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，您将学习如何在 `standalone.xml` 中定义数据库登录模块，以便在用户进行任何操作之前对其进行身份验证。
- en: The source code for the application created in this recipe is on GitHub at [https://github.com/OpenShift-Cookbook/chapter7-jobstore-security](https://github.com/OpenShift-Cookbook/chapter7-jobstore-security).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方中创建的应用的源代码可以在 GitHub 上找到：[https://github.com/OpenShift-Cookbook/chapter7-jobstore-security](https://github.com/OpenShift-Cookbook/chapter7-jobstore-security)。
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: This recipe builds on the application created in the *Creating and deploying
    Java EE 6 applications using the JBoss EAP and PostgreSQL 9.2 cartridges* recipe.
    So, please refer to that recipe before continuing with this recipe.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方基于 *使用 JBoss EAP 和 PostgreSQL 9.2 套件创建和部署 Java EE 6 应用* 配方中的应用。请在继续此配方之前参考该配方。
- en: How to do it…
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Perform the following steps to add security to your web application:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤为您的 Web 应用添加安全性：
- en: 'Create the OpenShift application created in the *Creating and deploying Java
    EE 6 applications using the JBoss EAP and PostgreSQL 9.2 cartridges* recipe using
    the following command:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建 *使用 JBoss EAP 和 PostgreSQL 9.2 套件创建和部署 Java EE 6 应用* 配方中的 OpenShift
    应用：
- en: '[PRE18]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After the application creation, SSH into the application gear, and connect
    with the PostgreSQL database using the `psql` client. Then, create the following
    tables and insert the test data:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建应用后，使用 SSH 进入应用服务器，并通过 `psql` 客户端连接 PostgreSQL 数据库。然后，创建以下表格并插入测试数据：
- en: '[PRE19]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Exit from the SSH shell, and open the `standalone.xml` file in the`.openshift/config`
    directory. Update the security domain with the following code:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出 SSH shell，打开 `.openshift/config` 目录中的 `standalone.xml` 文件。使用以下代码更新安全域：
- en: '[PRE20]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create the web deployment descriptor (that is, `web.xml`) in the `src/main/webapp/WEB-INF`
    folder. Add the following content to it:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/main/webapp/WEB-INF`文件夹中创建 web 部署描述符（即`web.xml`）。将以下内容添加到该文件中：
- en: '[PRE21]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create the `login.html` file in the `src/main/webapp` directory. The `login.html`
    page will be used for user authentication. The following code shows the contents
    of this file:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/main/webapp`目录中创建`login.html`文件。`login.html`页面将用于用户身份验证。以下代码显示了该文件的内容：
- en: '[PRE22]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create an `error.html` file in the `src/main/webapp` directory. The `error.html`
    page will be shown after unsuccessful authentication. The following code shows
    the contents of this file:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/main/webapp`目录中创建一个`error.html`文件。`error.html`页面将在身份验证失败后显示。以下代码显示了该文件的内容：
- en: '[PRE23]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Commit the changes, and push them to the OpenShift application gear:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交更改并将其推送到 OpenShift 应用程序 Gear：
- en: '[PRE24]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Go to the application page at `http://jobstore-{domain-name}.rhcloud.com`, and
    you will be asked to log in before you can view the application. Use `admin@jobstore.com/admin`
    as the username-password combination to log in to the application.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问应用程序页面`http://jobstore-{domain-name}.rhcloud.com`，系统会要求您登录才能查看应用程序。使用`admin@jobstore.com/admin`作为用户名-密码组合登录应用程序。
- en: How it works…
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Let''s now understand what you did in the preceding steps. In step 1, you recreated
    the `jobstore` application we developed in the *Creating and deploying Java EE
    6 applications using the JBoss EAP and PostgreSQL 9.2 cartridges* recipe. Next,
    in step 2, you performed an SSH into the application gear and created the `USERS`
    and `USER_ROLES` tables. These tables will be used by the JBoss database login
    module to authenticate users. As our application does not have the user registration
    functionality, we created a default user for the application. Storing the password
    as a clear text string is a bad practice, so we have stored the MD5 hash of the
    password. The MD5 hash of the `admin` password is `ISMvKXpXpadDiUoOSoAfww==`.
    If you want to generate the hashed password in your application, I have included
    a simple Java class, which uses `org.jboss.crypto.CryptoUtil` to generate the
    MD5 hash of any string. The `CryptoUtil` class is part of the `picketbox` library.
    The following code depicts this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们理解您在前面步骤中做了什么。在第 1 步中，您重新创建了我们在*使用 JBoss EAP 和 PostgreSQL 9.2 Cartridge
    创建和部署 Java EE 6 应用程序*配方中开发的`jobstore`应用程序。接下来，在第 2 步中，您通过 SSH 连接到应用程序 Gear，并创建了`USERS`和`USER_ROLES`表。这些表将由
    JBoss 数据库登录模块用于身份验证。由于我们的应用程序没有用户注册功能，我们为该应用程序创建了一个默认用户。以明文字符串存储密码是一个不好的做法，因此我们存储了密码的
    MD5 哈希值。`admin`密码的 MD5 哈希值是`ISMvKXpXpadDiUoOSoAfww==`。如果您想在应用程序中生成哈希密码，我已经包含了一个简单的
    Java 类，使用`org.jboss.crypto.CryptoUtil`生成任意字符串的 MD5 哈希值。`CryptoUtil`类是`picketbox`库的一部分。以下代码展示了这一点：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In step 3, you logged out of the SSH session and updated the `standalone.xml`
    JBoss configuration file with the database login module configuration. There are
    several login module implementations available out of the box. This book will
    only talk about the database login module, as discussing all the modules is outside
    the scope of this book. You can read about all the login modules at [https://docs.jboss.org/author/display/AS7/Security+subsystem+configuration](https://docs.jboss.org/author/display/AS7/Security+subsystem+configuration).
    The database login module checks the user credentials against a relational database.
    To configure the database login module, you have to specify a few configuration
    options. The `dsJndiName` option is used to specify the application datasource.
    As we are using a configured PostgreSQL datasource for our application, you specified
    the same `dsJndiName` option value. Next, you have to specify the SQL queries
    to fetch the user and its roles. Then, you have specified that the password will
    be hashed against an MD5 hash algorithm by specifying the `hashAlgorithm` configuration.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 3 步中，您退出了 SSH 会话，并更新了`standalone.xml` JBoss 配置文件，加入了数据库登录模块的配置。现成的有多个登录模块实现。本书只会讨论数据库登录模块，其他模块的讨论超出了本书的范围。您可以在[https://docs.jboss.org/author/display/AS7/Security+subsystem+configuration](https://docs.jboss.org/author/display/AS7/Security+subsystem+configuration)查看所有登录模块的文档。数据库登录模块会将用户凭证与关系数据库进行比对。为了配置数据库登录模块，您需要指定一些配置选项。`dsJndiName`选项用于指定应用程序的数据源。由于我们为应用程序配置了
    PostgreSQL 数据源，因此您指定了相同的`dsJndiName`选项值。接下来，您需要指定用于获取用户及其角色的 SQL 查询。然后，您指定密码将通过
    MD5 哈希算法进行加密，这可以通过指定`hashAlgorithm`配置来实现。
- en: In step 4, you applied the database login module to the `jobstore` application
    by defining the security constraints in `web.xml`. This configuration will add
    a security constraint on all the web resources of the application that will restrict
    access to authenticated users with role admin. You have also configured your application
    to use FORM-based authentication. This will make sure that when unauthenticated
    users visit the website, they will be redirected to the `login.html` page created
    in step 5\. If the user enters a wrong e-mail/password combination, then they
    will be redirected to the `error.html` page created in step 6.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，你通过在`web.xml`中定义安全约束，将数据库登录模块应用到`jobstore`应用程序中。此配置将对应用程序的所有Web资源添加安全约束，限制只有具有admin角色的已认证用户才能访问。你还配置了应用程序使用基于表单的认证。这将确保当未认证的用户访问网站时，他们会被重定向到第5步中创建的`login.html`页面。如果用户输入错误的电子邮件/密码组合，则会被重定向到第6步中创建的`error.html`页面。
- en: Finally, in step 7, you committed the changes to the local Git repository and
    pushed the changes to the application gear. OpenShift will make sure that the
    JBoss EAP application server uses the updated `standalone.xml` configuration file.
    Now, the user will be asked to authenticate before they can work with the application.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第7步中，你将更改提交到本地Git仓库，并将更改推送到应用程序设备。OpenShift将确保JBoss EAP应用服务器使用更新后的`standalone.xml`配置文件。现在，用户将被要求进行身份验证，然后才能使用该应用程序。
- en: See also
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges* recipe
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用JBoss EAP和PostgreSQL 9.2 cartridges创建和部署Java EE 6应用程序*食谱'
- en: The *Installing modules with JBoss cartridges* recipe
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用JBoss cartridges安装模块*食谱'
- en: The *Managing JBoss cartridges using the management web interface and CLI* recipe
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用管理Web界面和CLI管理JBoss cartridges*食谱'
- en: Installing modules with JBoss cartridges
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JBoss cartridges安装模块
- en: From version 7 of the JBoss application server, class loading is based on the
    JBoss Modules project. In this recipe, you will learn how to install the `Twitter4J`
    library as a module on the JBoss EAP 6 cartridge. The `modules` directory under
    the JBoss server home houses all the modules installed on the application server.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从JBoss应用服务器7版本开始，类加载基于JBoss Modules项目。在此食谱中，你将学习如何在JBoss EAP 6 cartridge上将`Twitter4J`库作为模块安装。JBoss服务器主目录下的`modules`目录包含了所有安装在应用服务器上的模块。
- en: The source code for the application created in this recipe is on GitHub at [https://github.com/OpenShift-Cookbook/chapter7-recipe4](https://github.com/OpenShift-Cookbook/chapter7-recipe4).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中创建的应用程序的源代码托管在GitHub上，链接为[https://github.com/OpenShift-Cookbook/chapter7-recipe4](https://github.com/OpenShift-Cookbook/chapter7-recipe4)。
- en: Getting ready
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe builds on the application created in the *Creating and deploying
    Java EE 6 applications using the JBoss EAP and PostgreSQL 9.2 cartridges* recipe.
    So, please refer to that recipe before continuing with this recipe.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱基于*使用JBoss EAP和PostgreSQL 9.2 cartridges创建和部署Java EE 6应用程序*食谱中创建的应用程序。因此，请在继续本食谱之前，先参考该食谱。
- en: How to do it…
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Perform the following steps to install the `Twitter4J` library as a module:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤，将`Twitter4J`库作为模块安装：
- en: 'Create the OpenShift application created in the *Creating and deploying Java
    EE 6 applications using the JBoss EAP and PostgreSQL 9.2 cartridges* recipe using
    the following command:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建在*使用JBoss EAP和PostgreSQL 9.2 cartridges创建和部署Java EE 6应用程序*食谱中创建的OpenShift应用程序：
- en: '[PRE26]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To install a new module, you have to create the module path under the `.openshift/config/modules`
    directory as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装新模块，必须在`.openshift/config/modules`目录下创建模块路径，如下所示：
- en: '[PRE27]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Download the `twitter4j-core` library from [http://mvnrepository.com/artifact/org.twitter4j/twitter4j-core/3.0.5](http://mvnrepository.com/artifact/org.twitter4j/twitter4j-core/3.0.5),
    and place it under the `.openshift/config/modules/org/twitter4j/main` directory.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[http://mvnrepository.com/artifact/org.twitter4j/twitter4j-core/3.0.5](http://mvnrepository.com/artifact/org.twitter4j/twitter4j-core/3.0.5)下载`twitter4j-core`库，并将其放置在`.openshift/config/modules/org/twitter4j/main`目录下。
- en: 'Now, in the `main` folder, add a file named `module.xml`. This file contains
    the actual module definition as follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`main`文件夹中，添加一个名为`module.xml`的文件。该文件包含实际的模块定义，如下所示：
- en: '[PRE28]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, to use this module in your application, you have to first add its dependency
    in your `pom.xml` file. Make sure that the scope is provided, as the server will
    already have this dependency since you are adding it as a module:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要在你的应用程序中使用这个模块，首先必须在`pom.xml`文件中添加它的依赖。确保作用域为provided，因为服务器已经拥有这个依赖，因为你是将其作为模块添加的：
- en: '[PRE29]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Secondly, you have to update the Maven WAR plugin configuration by adding the
    `org.twitter4j` module dependency in the `META-INF/MANIFEST.MF` location:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，你需要通过在`META-INF/MANIFEST.MF`位置添加`org.twitter4j`模块依赖来更新Maven WAR插件配置：
- en: '[PRE30]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Finally, commit the changes, and push them to the application gear. Now, after
    the server restarts, JBoss will have the `twitter4j` library as a module.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，提交更改并将其推送到应用程序 gear。现在，服务器重启后，JBoss将把`twitter4j`库作为模块加载。
- en: How it works…
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In the preceding steps, you learned how to install a third-party library as
    a module. The alternative to using a third-party library is to add a compile scope
    dependency in `pom.xml` and then use the `twitter4j` library in your application.
    The advantage of using a module is that you do not have to bundle the JAR file
    with your application archive. If you are deploying multiple applications on a
    single server instance, then the server will only need one copy of the JAR file.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的步骤中，你学习了如何将第三方库安装为模块。使用第三方库的替代方法是，在`pom.xml`中添加一个编译作用域的依赖，然后在应用程序中使用`twitter4j`库。使用模块的优势在于你不需要将JAR文件与应用程序归档一起打包。如果你在单个服务器实例上部署多个应用程序，那么服务器只需要一个JAR文件的副本。
- en: After creating the application in step 1, you created a directory structure
    required to define a module inside the`.openshift/config` directory in step 2\.
    This directory is added to the module path of the JBoss EAP server associated
    with your OpenShift application. It has the same structure as the standard JBoss
    EAP `modules` directory. Inside `org.twitter4j.main`, you placed the `twitter4j-core-3.0.5.jar`
    file in step 3\. In step 4, you created a file called `module.xml` inside the
    `org.twitter4j.main` directory. The `module.xml` file is used to define a module
    and its dependencies. The module name `org.twitter4j` corresponds to the module
    attribute that you will define in your application manifest. Next, you need to
    state the path to the `twitter4j-core` library and finally, its dependencies.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步创建应用程序后，你在第二步创建了所需的目录结构，以在`.openshift/config`目录中定义一个模块。这个目录被添加到与你的OpenShift应用程序关联的JBoss
    EAP服务器的模块路径中。它与标准的JBoss EAP `modules`目录结构相同。在`org.twitter4j.main`目录中，你在第三步放置了`twitter4j-core-3.0.5.jar`文件。在第四步，你在`org.twitter4j.main`目录中创建了一个名为`module.xml`的文件。`module.xml`文件用于定义一个模块及其依赖关系。模块名称`org.twitter4j`对应于你将在应用程序清单中定义的模块属性。接下来，你需要声明`twitter4j-core`库的路径，最后是它的依赖关系。
- en: Next, in step 5, you added a provided scope dependency to the `twitter4j-core`
    library. The provided scope indicated that you expect the application container
    to provide the dependency at runtime. Also, provided dependencies are not packaged
    with web applications. This makes sure that the application archives are smaller
    in size and the application deploys faster. Also, in step 5, you updated the Maven
    WAR plugin configuration to add a dependency on the `org.twitter4j` module to
    the application archive `META-INF/MANIFEST.MF` file.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在第五步，你将`twitter4j-core`库添加为提供作用域的依赖。提供作用域表示你期望应用程序容器在运行时提供该依赖。此外，提供的依赖不会与Web应用程序一起打包。这确保了应用程序归档的体积更小，应用程序的部署速度更快。此外，在第五步，你更新了Maven
    WAR插件配置，以将对`org.twitter4j`模块的依赖添加到应用程序归档的`META-INF/MANIFEST.MF`文件中。
- en: In step 6, you committed the changes and pushed them to the application gear.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在第六步，你提交了更改并将其推送到应用程序 gear。
- en: In this recipe, I have not covered how to use the `Twitter4J` library. If you
    want to see `Twitter4J` in action, I have created an application for you, which
    will tweet after posting a job. To use the application, you have to first create
    a Twitter application. Go to [https://dev.twitter.com](https://dev.twitter.com),
    and create a new Twitter application. Give the application the read-and-write
    level access. Once you are done, create a new OpenShift application by running
    the following command. Please replace the environment variable values with your
    Twitter application values. You can find these values under the Twitter application's
    **API Keys** section.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我没有涉及如何使用`Twitter4J`库。如果您想看到`Twitter4J`的实际操作，我为您创建了一个应用程序，它将在每次发布职位后发送一条推文。要使用该应用程序，您首先需要创建一个
    Twitter 应用程序。请访问[https://dev.twitter.com](https://dev.twitter.com)，并创建一个新的 Twitter
    应用程序。为应用程序提供读写权限。完成后，运行以下命令创建一个新的 OpenShift 应用程序。请将环境变量的值替换为您自己 Twitter 应用程序的值。您可以在
    Twitter 应用程序的**API Keys**部分找到这些值。
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: After the application is successfully created, a tweet will be sent after every
    job posting.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序成功创建后，每次发布职位都会发送一条推文。
- en: See also
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges* recipe
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 JBoss EAP 和 PostgreSQL 9.2 插件创建和部署 Java EE 6 应用程序*食谱'
- en: The *Managing JBoss cartridges using the management web interface and CLI* recipe
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用管理 Web 界面和 CLI 管理 JBoss 插件*食谱'
- en: Managing JBoss cartridges using the management web interface and CLI
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用管理 Web 界面和 CLI 管理 JBoss 插件
- en: 'JBoss provides three different ways to manage the server: a web interface,
    a command-line client, and the XML configuration files. In this recipe, you will
    learn how to deploy WAR files to your JBoss cartridge using the web management
    interface and JBoss CLI.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: JBoss 提供了三种不同的方式来管理服务器：Web 界面、命令行客户端和 XML 配置文件。在这个食谱中，您将学习如何使用 Web 管理界面和 JBoss
    CLI 将 WAR 文件部署到您的 JBoss 插件。
- en: Getting ready
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To complete this recipe, you will need to have the JBoss application server
    binary on your local machine. This is required to connect with the JBoss cartridge
    using `jboss-cli`. Download the JBoss AS7 binary from the official website at
    [http://www.jboss.org/jbossas/downloads](http://www.jboss.org/jbossas/downloads).
    Extract the ZIP file, and you will find the `jboss-cli` script in the `bin` folder.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个食谱，您需要在本地计算机上拥有 JBoss 应用服务器二进制文件。这是通过`jboss-cli`连接 JBoss 插件所必需的。您可以从官方网站下载
    JBoss AS7 二进制文件，网址是[http://www.jboss.org/jbossas/downloads](http://www.jboss.org/jbossas/downloads)。解压
    ZIP 文件，您将找到`jboss-cli`脚本文件，它位于`bin`文件夹中。
- en: In this recipe, we will use the `jobstore` application that we created in the
    *Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges* recipe.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用在*使用 JBoss EAP 和 PostgreSQL 9.2 插件创建和部署 Java EE 6 应用程序*食谱中创建的`jobstore`应用程序。
- en: How to do it…
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Perform the following steps:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Open a new command-line terminal, and navigate to the directory where the `jobstore`
    application is located. Run the `rhc port-forward` command to forward the remote
    ports on your local machine:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的命令行终端，并导航到`jobstore`应用程序所在的目录。运行`rhc port-forward`命令以将远程端口转发到本地计算机：
- en: '[PRE32]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Open the management interface at `http://127.0.0.1:9990` in your favorite web
    browser. This information is available in the output of the `rhc port-forward`
    command.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您喜欢的 Web 浏览器，访问`http://127.0.0.1:9990`的管理界面。此信息可以在`rhc port-forward`命令的输出中找到。
- en: In this recipe, we will deploy the WAR file of the application we created in
    the *Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges* recipe using the JBoss management interface. Download the WAR
    file from [https://github.com/OpenShift-Cookbook/chapter7-recipe5/raw/master/ROOT.war](https://github.com/OpenShift-Cookbook/chapter7-recipe5/raw/master/ROOT.war)
    to your local machine.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用 JBoss 管理界面部署我们在*使用 JBoss EAP 和 PostgreSQL 9.2 插件创建和部署 Java EE 6
    应用程序*食谱中创建的应用程序的 WAR 文件。将 WAR 文件从[https://github.com/OpenShift-Cookbook/chapter7-recipe5/raw/master/ROOT.war](https://github.com/OpenShift-Cookbook/chapter7-recipe5/raw/master/ROOT.war)下载到您的本地计算机。
- en: After downloading the WAR file, navigate to **Runtime** | **Manage Deployments**,
    and remove the existing `ROOT.war` file by clicking on the **Remove** button as
    shown in the following screenshot. It will ask you to confirm the removal, and
    you can click on the **OK** button. Have a look at the following screenshot:![How
    to do it…](img/00062.jpeg)
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载WAR文件后，转到**运行时** | **管理部署**，通过点击**删除**按钮删除现有的`ROOT.war`文件，如下截图所示。系统会要求你确认删除操作，你可以点击**确定**按钮。请查看以下截图：![如何操作…](img/00062.jpeg)
- en: To deploy the WAR file, click on the **Add** button, and then upload the `ROOT.war`
    file from your local machine. After uploading the WAR file, you will be asked
    to verify the deployment name. Choose the default values, and click on the **Save**
    button as shown in the following screenshot:![How to do it…](img/00063.jpeg)
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要部署WAR文件，点击**添加**按钮，然后从本地计算机上传`ROOT.war`文件。上传WAR文件后，系统会要求你验证部署名称。选择默认值，并点击**保存**按钮，如下截图所示：![如何操作…](img/00063.jpeg)
- en: Uploading the WAR file does not initiate the deployment. You have to click on
    the **En/Disable** button to initiate the deployment. You will be asked to confirm
    your decision. Click on the **Confirm** button as shown in the following screenshot:![How
    to do it…](img/00064.jpeg)
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上传WAR文件并不会启动部署。你必须点击**启用/禁用**按钮来启动部署。系统会要求你确认决策。点击**确认**按钮，如下截图所示：![如何操作…](img/00064.jpeg)
- en: Now, if you go to `http://myapp-{domain-name}.rhcloud.com`, you will see your
    application deployed.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你访问`http://myapp-{domain-name}.rhcloud.com`，你会看到已部署的应用程序。
- en: 'Another way to deploy an application is via the `jboss-cli` command-line interface.
    The `jboss-cli` script can be found in your local downloaded JBoss archive `bin`
    folder. Launch the `jboss-cli` client, and you will see the message shown in the
    following command:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署应用程序的另一种方式是通过`jboss-cli`命令行接口。你可以在本地下载的JBoss压缩包的`bin`文件夹中找到`jboss-cli`脚本。启动`jboss-cli`客户端，你会看到如下命令显示的消息：
- en: '[PRE33]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To connect to the JBoss cartridge, type the `connect` command as follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要连接到JBoss卡带，请输入如下的`connect`命令：
- en: '[PRE34]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, you can check the deployed applications using the `deploy` command. Type
    `deploy`, and then press *Enter*:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以使用`deploy`命令检查已部署的应用程序。输入`deploy`，然后按*Enter*：
- en: '[PRE35]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As you can see in the preceding command, `ROOT.war` is currently deployed.
    This WAR file was deployed using the web interface. To withdraw this WAR file,
    type the `undeploy` command:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你在前面的命令中看到的，`ROOT.war`当前已部署。这个WAR文件是通过网页界面部署的。要撤销这个WAR文件的部署，输入`undeploy`命令：
- en: '[PRE36]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, if you go to `http://myapp-{domain-name}.rhcloud.com`, you will get a 404
    error as the application is not deployed.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你访问`http://myapp-{domain-name}.rhcloud.com`，你会遇到404错误，因为应用程序尚未部署。
- en: 'To deploy the application using `jboss-cli`, you can use the `deploy` command
    as shown in the following command line. Please make sure you have downloaded the
    application `ROOT.war` file as discussed in step 3\. Have a look at the following
    command:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用`jboss-cli`部署应用程序，你可以使用如下命令行中的`deploy`命令。请确保你已经按照第3步讨论的内容下载了应用程序的`ROOT.war`文件。请查看以下命令：
- en: '[PRE37]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Finally, you can see the application running at `http://myapp-{domain-name}.rhcloud.com`.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你可以在`http://myapp-{domain-name}.rhcloud.com`查看正在运行的应用程序。
- en: How it works…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In the preceding steps, you learned how to manage your application deployment
    from the JBoss web management and command-line interface. In step 1, you ran the
    `rhc port-forward` command to enable SSH port forwarding. The `rhc port-forward`
    command forwarded all the remote ports running on the application gear to your
    local machine. In the output of the `rhc port-forward` command, you can see that
    the management interface is exposed on port `9090`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的步骤中，你学习了如何通过JBoss网页管理和命令行界面管理应用程序部署。在第1步中，你运行了`rhc port-forward`命令来启用SSH端口转发。`rhc
    port-forward`命令将应用程序设备上运行的所有远程端口转发到你的本地计算机。在`rhc port-forward`命令的输出中，你可以看到管理界面暴露在`9090`端口。
- en: 'From step 3 through step 5, you saw how to connect with the web interface from
    your local machine and undeploy the existing `ROOT.war` file. The web interface
    is a **Google Web Toolkit** (**GWT**) application accessible on port `9090`. Google
    Web Toolkit is an open source set of tools that allows Java developers to write
    complex JavaScript-based web applications in Java. OpenShift only exposes port
    `8080` to the outside world; all other ports are internal to the application gear
    and can only be connected via port forwarding. This is a secure setup as no one
    from the outside world will be able to connect with your application web management
    interface, because the `rhc port-forward` command will only work if their SSH
    keys are uploaded. The web console is divided into two main tabs: the **Profile**
    and the **Runtime** tab. The **Profile** tab gives access to all the subsystem
    configurations. You can edit the configuration without fiddling with XML. For
    example, you can go to `http://127.0.0.1:9990/console/App.html#datasources` to
    edit the `datasource` configuration. The **Runtime** tab can be used to manage
    application deployment, and you used it to undeploy the WAR file in step 5\. You
    can learn more about the management interface from the documentation at [https://docs.jboss.org/author/display/AS7/Admin+Guide](https://docs.jboss.org/author/display/AS7/Admin+Guide).'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从第3步到第5步，你已经了解如何从本地机器连接到Web界面并撤销现有的`ROOT.war`文件。Web界面是一个**Google Web Toolkit**（**GWT**）应用，可以通过端口`9090`访问。Google
    Web Toolkit是一个开源工具集，允许Java开发人员用Java编写复杂的基于JavaScript的Web应用程序。OpenShift只暴露端口`8080`到外部，所有其他端口仅在应用程序gear内部可用，并且只能通过端口转发连接。这是一种安全的设置，因为外部无法连接到你的应用程序Web管理界面，因为`rhc
    port-forward`命令只有在上传了SSH密钥的情况下才有效。Web控制台分为两个主要标签：**配置文件**和**运行时**标签。**配置文件**标签提供对所有子系统配置的访问权限。你可以在不修改XML的情况下编辑配置。例如，你可以访问`http://127.0.0.1:9990/console/App.html#datasources`来编辑`datasource`配置。**运行时**标签可用于管理应用程序部署，你在第5步中使用它来撤销WAR文件的部署。你可以通过[https://docs.jboss.org/author/display/AS7/Admin+Guide](https://docs.jboss.org/author/display/AS7/Admin+Guide)了解更多关于管理界面的文档。
- en: In step 6, you uploaded the `ROOT.war` file to your JBoss cartridge. After upload,
    the deployment is listed in the **Deployments** table. The WAR file is not deployed
    by default; you have to click on the **En/Disable** button to enable the deployment
    of the application as you did in step 7.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6步中，你将`ROOT.war`文件上传到你的JBoss cartridge。上传后，部署会出现在**部署**表格中。WAR文件默认不会自动部署；你需要点击**启用/禁用**按钮来启用应用程序的部署，正如你在第7步中所做的那样。
- en: 'Another way to deploy an application is using the `jboss-cli` command-line
    interface. In step 9, you launched the `jboss-cli` script. The `jboss-cli` console
    provides a built-in autocomplete feature using the *Tab* key. At any point in
    time, you can list all the available commands using the *Tab* key as shown in
    the following command. For brevity, only part of the output is shown:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种部署应用的方法是使用`jboss-cli`命令行界面。在第9步中，你启动了`jboss-cli`脚本。`jboss-cli`控制台提供了内建的自动完成功能，可以使用*Tab*键。任何时候，你都可以通过按*Tab*键列出所有可用的命令，如以下命令所示。为了简洁，下面只显示部分输出：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In step 9, you undeployed the existing `ROOT.war` file using the `undeploy`
    command. The `undeploy` command takes the application that is already deployed
    as an argument. Finally, in step 10, you deployed the `ROOT.war` file on your
    local machine to the JBoss cartridge running on OpenShift using the `deploy` command.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在第9步中，你使用`undeploy`命令撤销了现有的`ROOT.war`文件。`undeploy`命令将已部署的应用程序作为参数。最后，在第10步中，你使用`deploy`命令将`ROOT.war`文件从本地机器部署到运行在OpenShift上的JBoss
    cartridge。
- en: See also
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Configuring application security by defining the database login module
    in standalone.xml* recipe
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过在standalone.xml中定义数据库登录模块配置应用程序安全性*的配方'
- en: The *Installing modules with JBoss cartridges* recipe
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用JBoss cartridges安装模块*的配方'
- en: Creating and deploying Spring applications using the Tomcat 7 cartridge
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Tomcat 7 cartridge创建和部署Spring应用
- en: 'Spring Framework is a very popular alternative to Java EE web development.
    Java developers around the world use Spring Framework to build their enterprise
    applications. Spring Framework is often thought of as a lightweight alternative
    to Java EE, and Java developers normally use a lightweight web container, such
    as Apache Tomcat, for deployment. At the time of this writing, OpenShift supports
    two versions of Apache Tomcat: Apache Tomcat 6 and Apache Tomcat 7\. They are
    shown using the following command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Framework 是一种非常流行的 Java EE Web 开发替代方案。全球的 Java 开发者都使用 Spring Framework
    来构建他们的企业应用程序。Spring Framework 通常被认为是 Java EE 的轻量级替代品，Java 开发者通常使用轻量级 Web 容器，如
    Apache Tomcat，进行部署。在撰写本文时，OpenShift 支持两个版本的 Apache Tomcat：Apache Tomcat 6 和 Apache
    Tomcat 7。它们可以通过以下命令显示：
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this recipe, you will learn how to develop a simple Spring Framework application
    from scratch using OpenShift's Tomcat 7 cartridge. The application exposes a REST
    endpoint. When a user makes an HTTP request to `/api/v1/ping`, then the applicaton
    will return a JSON response with the message `It works`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，您将学习如何从头开始使用 OpenShift 的 Tomcat 7 插件开发一个简单的 Spring Framework 应用程序。该应用程序公开一个
    REST 接口。当用户向 `/api/v1/ping` 发送 HTTP 请求时，应用程序将返回一个包含消息 `It works` 的 JSON 响应。
- en: The source code for the application created in this recipe is on GitHub at [https://github.com/OpenShift-Cookbook/chapter7-jobstore-spring](https://github.com/OpenShift-Cookbook/chapter7-jobstore-spring).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程中创建的应用程序源代码托管在 GitHub 上，网址为 [https://github.com/OpenShift-Cookbook/chapter7-jobstore-spring](https://github.com/OpenShift-Cookbook/chapter7-jobstore-spring)。
- en: Getting ready
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To complete this recipe, you will need the `rhc` command-line client installed
    on your machine. Please refer to the *Installing the OpenShift rhc command-line
    client* recipe in [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting
    Started with OpenShift"), *Getting Started with OpenShift*, for details.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本教程，您需要在机器上安装 `rhc` 命令行客户端。请参考[第 1 章](part0014_split_000.html#page "Chapter
    1. Getting Started with OpenShift")中的 *安装 OpenShift rhc 命令行客户端* 章节，了解详细信息。
- en: How to do it…
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'Perform the following steps to create an application using Spring Framework:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以使用 Spring Framework 创建一个应用程序：
- en: 'Open a new command-line terminal, and go to a convenient location. Create a
    new Tomcat 7 and MySQL 5.5 application by executing the following commands:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的命令行终端，并前往一个方便的位置。通过执行以下命令创建一个新的 Tomcat 7 和 MySQL 5.5 应用程序：
- en: '[PRE40]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The preceding command will create a Maven-based project and clone it to your
    local machine.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述命令将创建一个基于 Maven 的项目并将其克隆到本地机器。
- en: Open Eclipse and navigate to the project workspace. Then, import the application
    created in step 1 as a Maven application. To import an existing Maven project,
    navigate to **File**|**Import**|**Maven**|**Existing Maven Projects**. Then browse
    to the location of your OpenShift Maven application created in step 1.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Eclipse 并导航到项目工作空间。然后，将步骤 1 中创建的应用程序作为 Maven 应用程序导入。要导入现有的 Maven 项目，导航至 **File**|**Import**|**Maven**|**Existing
    Maven Projects**。然后浏览到步骤 1 中创建的 OpenShift Maven 应用程序的位置。
- en: 'Next, update `pom.xml` to use Java 7\. The Maven project created by OpenShift
    is configured to use JDK 6\. Replace the properties with the one shown in the
    following code:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新 `pom.xml` 以使用 Java 7。OpenShift 创建的 Maven 项目默认配置为使用 JDK 6。将属性替换为以下代码所示的内容：
- en: '[PRE41]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Update the Maven project to allow the changes to take effect. You can update
    the Maven project by right-clicking on the project and navigating to **Maven**|**Update
    Project**.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 Maven 项目以使更改生效。您可以通过右键单击项目并导航至 **Maven**|**Update Project** 来更新 Maven 项目。
- en: 'Add Spring Maven dependencies to your `pom.xml` file. These are the minimum
    dependencies that you need to write a REST JSON web service using Spring Framework.
    The code is as follows:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Spring Maven 依赖项添加到 `pom.xml` 文件中。这些是您使用 Spring Framework 编写 REST JSON Web
    服务所需的最低依赖项。代码如下：
- en: '[PRE42]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create a new package called `org.myapp.config`, and create a new class named
    `WebMvcConfig`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `org.myapp.config` 的新包，并创建一个名为 `WebMvcConfig` 的新类：
- en: '[PRE43]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create another configuration class in the `org.myapp.config` package. This
    `@Configuration` class will be used for defining application beans, such as `datasource`,
    and so on. This will be covered later in this recipe. The code is as follows:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `org.myapp.config` 包中创建另一个配置类。此 `@Configuration` 类将用于定义应用程序 Bean，例如 `datasource`
    等。稍后将在本教程中介绍。代码如下：
- en: '[PRE44]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'From Servlet 3.0 onwards, the `web.xml` deployment descriptor is optional.
    Prior to Servlet 3.0, we configured the Spring MVC dispatcher servlet in `web.xml`,
    but now we can programmatically configure it using `WebApplicationInitializer`.
    Create a new class called `JobStoreWebApplicationInitializer` in the `org.myapp.config`
    package as follows:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Servlet 3.0开始，`web.xml`部署描述符变为可选。在Servlet 3.0之前，我们在`web.xml`中配置了Spring MVC调度器Servlet，但现在我们可以通过`WebApplicationInitializer`进行编程配置。创建一个名为`JobStoreWebApplicationInitializer`的新类，并将其放置在`org.myapp.config`包中，具体代码如下：
- en: '[PRE45]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, we will create a simple REST resource called `PingResource`. `PingResource`
    will be invoked when a request is made to `/api/v1/ping` and will respond with
    a JSON message. Create a new class called `PingResource` in the `org.myapp.rest`
    package. Have a look at the following code:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个名为`PingResource`的简单REST资源。当请求访问`/api/v1/ping`时，`PingResource`将被调用并以JSON消息做出响应。创建一个新的类`PingResource`，并将其放置在`org.myapp.rest`包中。查看以下代码：
- en: '[PRE46]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Also, create another class called `PingResponse` as shown in the following
    code:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时，创建另一个名为`PingResponse`的类，如下所示的代码所示：
- en: '[PRE47]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Commit the changes and push them to the OpenShift application gear as follows:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交更改并将其推送到OpenShift应用程序设备，具体步骤如下：
- en: '[PRE48]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You can test the `PingResource` using a command-line tool, such as `curl`,
    or by opening the `http://myapp-{domain-name}.rhcloud.com/api/v1/ping` location
    in your favorite browser. You should see the following JSON message:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用命令行工具（如`curl`）或在浏览器中打开`http://myapp-{domain-name}.rhcloud.com/api/v1/ping`来测试`PingResource`。你应该会看到以下JSON消息：
- en: '[PRE49]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works…
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'In the preceding steps, we created a Spring application and deployed it to
    OpenShift. In step 1, you used the `rhc create-app` command to create Apache Tomcat
    7 MySQL 5.5\. Every OpenShift web cartridge specifies a template application that
    will be used as the default source code of the application. For Java-based web
    cartridges, such as JBoss EAP, JBoss AS7, Tomcat 6, and Tomcat 7, the template
    is a Maven-based application. After the application is created, the template application
    is cloned to the local machine using Git. The directory structure of the application
    is shown in the following command:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的步骤中，我们创建了一个Spring应用并将其部署到OpenShift。在第1步中，你使用`rhc create-app`命令创建了Apache
    Tomcat 7和MySQL 5.5的应用。每个OpenShift Web Cartridge都指定了一个模板应用，它将作为应用的默认源代码。对于基于Java的Web
    Cartridge（如JBoss EAP、JBoss AS7、Tomcat 6和Tomcat 7），模板是基于Maven的应用程序。创建应用后，模板应用会通过Git克隆到本地机器。应用的目录结构如下所示：
- en: '[PRE50]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As you can see in the preceding command-line output, apart from the`.git` and
    `.openshift` directories, this looks like a standard Maven project. OpenShift
    uses Maven for managing application dependencies and building your Java applications.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面命令行输出所示，除了`.git`和`.openshift`目录外，这看起来像一个标准的Maven项目。OpenShift使用Maven来管理应用程序依赖关系并构建Java应用程序。
- en: The directory structure was explained in the *Creating and deploying Java EE
    6 applications using the JBoss EAP and PostgreSQL 9.2 cartridges* recipe. Please
    refer to the recipe to get an understanding of the directory structure.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 目录结构在*使用JBoss EAP和PostgreSQL 9.2 Cartridge创建和部署Java EE 6应用程序*一文中进行了说明。请参阅该文档以了解目录结构。
- en: From step 3 through step 5, you made a few changes in `pom.xml`. You updated
    the project to use JDK 1.7 for the Maven compiler plugin. All the OpenShift Java
    applications use OpenJDK 7, so it makes sense to update the application to also
    use JDK 1.7 for compilation. Another change you made to `pom.xml` is that you
    updated the Maven WAR plugin configuration not to fail the build if `web.xml`
    is not found. Next, you added the Spring Web MVC dependencies to `pom.xml`. The
    Servlet 3.1.0 is provided, as this should exist in Apache Tomcat 7\. The `jackson-databind`
    dependency is added to convert Java objects to JSON.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 从第3步到第5步，你对`pom.xml`做了一些修改。你更新了项目，使其使用JDK 1.7作为Maven编译插件的JDK版本。所有的OpenShift
    Java应用都使用OpenJDK 7，因此将应用程序更新为使用JDK 1.7进行编译是合适的。你对`pom.xml`的另一个修改是更新了Maven WAR插件配置，以便在找不到`web.xml`时不会导致构建失败。接下来，你向`pom.xml`中添加了Spring
    Web MVC依赖。Servlet 3.1.0已提供，因为它应该存在于Apache Tomcat 7中。`jackson-databind`依赖被添加进来，用于将Java对象转换为JSON。
- en: 'From step 6 through step 8, you configured the Spring Web MVC framework programmatically.
    Normally, we configure the Spring Web MVC dispatcher servlet in `web.xml`, but
    now, we can programmatically configure it using `WebApplicationInitializer`. From
    Spring 3.1, Spring provides an implementation of the `ServletContainerInitializer`
    interface called `SpringServletContainerInitializer`. The `SpringServletContainerInitializer`
    class delegates to an implementation of `org.springframework.web.WebApplicationInitializer`
    that you provide. There is just one method that you need to implement: `WebApplicationInitializer#onStartup(ServletContext)`.
    You are handed the `ServletContext` parameter that you need to initialize.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 从第6步到第8步，您以编程方式配置了Spring Web MVC框架。通常情况下，我们在`web.xml`中配置Spring Web MVC调度程序Servlet，但现在我们可以使用`WebApplicationInitializer`进行程序化配置。从Spring
    3.1开始，Spring提供了一个`ServletContainerInitializer`接口的实现称为`SpringServletContainerInitializer`。`SpringServletContainerInitializer`类委托给您提供的`org.springframework.web.WebApplicationInitializer`的实现。您只需要实现一个方法：`WebApplicationInitializer#onStartup(ServletContext)`。您将获得需要初始化的`ServletContext`参数。
- en: From step 9 through step 11, you created a simple REST JSON resource called
    `PingResource` using Spring MVC. `PingResource` is available at the`/api/v1/ping`
    URL as defined using the `@RequestMapping` annotation.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 从第9步到第11步，您使用Spring MVC创建了一个简单的REST JSON资源`PingResource`。使用`@RequestMapping`注解将`PingResource`定义为`/api/v1/ping`URL可用。
- en: There's more…
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'You can perform all the preceding steps with just the following single command:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以仅使用以下单个命令执行所有前述步骤：
- en: '[PRE51]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: See also
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Taking thread dumps of Java cartridges* recipe
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*获取Java载体的线程转储*食谱'
- en: Taking thread dumps of Java cartridges
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取Java载体的线程转储
- en: In this recipe, you will learn how to take thread dumps of your Java cartridge
    applications. A thread dump lists all the Java threads that are currently active
    in a **Java Virtual Machine** (**JVM**). It can help you understand the state
    of every thread in the JVM at a particular point in time. It gives you a snapshot
    of exactly what's executing at a moment in time. Thread dumps are very useful
    to debug a deadlock condition or to understand resource usage.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在此食谱中，您将学习如何获取Java载体应用程序的线程转储。线程转储列出了当前在**Java虚拟机**（**JVM**）中活动的所有Java线程。它可以帮助您了解JVM中每个线程在特定时间点的状态。它为您提供了在某个时间点正在执行的确切快照。线程转储对于调试死锁条件或了解资源使用非常有用。
- en: Note
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This command will work with all the four supported Java cartridges (Apache Tomcat
    6, Apache Tomcat 7, JBoss AS7, and JBoss EAP).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令适用于所有四种支持的Java载体（Apache Tomcat 6、Apache Tomcat 7、JBoss AS7和JBoss EAP）。
- en: Getting ready
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe will request for a thread dump of the application created in the
    *Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges* recipe. So, please refer to the aforementioned recipe before continuing
    with this recipe.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 该食谱将请求创建和部署Java EE 6应用程序使用JBoss EAP和PostgreSQL 9.2载体中的应用程序的线程转储。因此，请在继续本食谱之前参考上述食谱。
- en: How to do it…
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Perform the following steps to take a thread dump of your Java application:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤获取Java应用程序的线程转储：
- en: Open a new command-line terminal, and navigate to the directory where the `jobstore`
    application is located.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的命令行终端，并导航到`jobstore`应用程序所在的目录。
- en: 'To take a thread dump of the `jobstore` application, run the following command:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取`jobstore`应用程序的线程转储，请运行以下命令：
- en: '[PRE52]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works…
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'When you run the `rhc threaddump` command, the JBoss EAP cartridge initiates
    a thread dump. It first gets the process ID of the JBoss application server and
    then runs the `kill -3 <process id>` command. The `kill -3` command sends the
    `HUP` or `BREAK` signal to the Java process. The thread dump log will be placed
    in the `jbosseap.log` file in `$OPENSHIFT_LOG_DIR/`, which you can download on
    your local machine for analysis. You can also view the logfile using the `rhc
    tail` command, as mentioned in the following command output:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`rhc threaddump`命令时，JBoss EAP载体会初始化一个线程转储。首先获取JBoss应用服务器的进程ID，然后运行`kill -3
    <process id>`命令。`kill -3`命令向Java进程发送`HUP`或`BREAK`信号。线程转储日志将放置在`$OPENSHIFT_LOG_DIR/`中的`jbosseap.log`文件中，您可以下载到本地机器进行分析。您还可以使用`rhc
    tail`命令查看日志文件，如下命令输出中所述：
- en: '[PRE53]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To download the thread dump file on your local machine, you can use the `rhc
    scp` command. The `rhc scp` command can be used to transfer files to and from
    your applications using SCP ([http://en.wikipedia.org/wiki/Secure_copy](http://en.wikipedia.org/wiki/Secure_copy)).
    Run the following command to download the `jbosseap.log` file:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本地机器上下载线程转储文件，你可以使用`rhc scp`命令。`rhc scp`命令可以用来通过SCP（[http://en.wikipedia.org/wiki/Secure_copy](http://en.wikipedia.org/wiki/Secure_copy)）传输文件到应用程序和从应用程序传输文件。运行以下命令以下载`jbosseap.log`文件：
- en: '[PRE54]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now, you can use tools, such as samurai ([http://yusuke.homeip.net/samurai/en/index.html](http://yusuke.homeip.net/samurai/en/index.html)),
    to analyze the thread dump on your local machine.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用工具，如samurai（[http://yusuke.homeip.net/samurai/en/index.html](http://yusuke.homeip.net/samurai/en/index.html)），在本地机器上分析线程转储。
- en: There's more…
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'You can also take a thread dump of the Java application using the `jps` and
    `jstack` JVM tools. To do that, perform the following steps:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`jps`和`jstack` JVM工具获取Java应用程序的线程转储。要执行此操作，请按照以下步骤进行：
- en: 'Open a command-line terminal and then SSH into the `jobstore` application gear
    as follows:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行终端，然后使用SSH连接到`jobstore`应用程序gear，如下所示：
- en: '[PRE55]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Once inside the application gear, run the `jps` utility to list all the available
    Java processes as follows:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入应用程序gear后，运行`jps`工具列出所有可用的Java进程，如下所示：
- en: '[PRE56]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `jps` utility ships with JDK and lists all the Java process IDs.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`jps`工具随JDK一起提供，用于列出所有Java进程ID。'
- en: 'The output of the `jps -l` command is as follows:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`jps -l`命令的输出如下：'
- en: '[PRE57]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, to take a thread dump of the Java process with ID `157027`, run the following
    command:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要获取ID为`157027`的Java进程的线程转储，运行以下命令：
- en: '[PRE58]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `jstack` utility is also part of JDK and is used to take a thread dump of
    a Java process.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`jstack`工具也是JDK的一部分，用于获取Java进程的线程转储。'
- en: See also
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Choosing between Java 6 and Java 7* recipe
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在Java 6和Java 7之间的选择*配方'
- en: The *Enabling hot deployment for Java applications* recipe
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为Java应用程序启用热部署*配方'
- en: The *Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges* recipe
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用JBoss EAP和PostgreSQL 9.2 cartridge创建和部署Java EE 6应用程序*配方'
- en: Choosing between Java 6 and Java 7
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Java 6和Java 7之间的选择
- en: 'OpenShift supports both Java 6 and Java 7 to run your applications. By default,
    all the Java applications use OpenJDK 7, but you can configure your application
    to use OpenJDK 6 as well. To get the exact version of your Java installation,
    you can SSH into the application gear and run the `java -version` command or run
    the following command:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift支持Java 6和Java 7来运行你的应用程序。默认情况下，所有Java应用程序使用OpenJDK 7，但你也可以配置应用程序使用OpenJDK
    6。要获取Java安装的确切版本，你可以通过SSH连接到应用程序gear并运行`java -version`命令，或运行以下命令：
- en: '[PRE59]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In this recipe, you will learn how you can choose among different supported
    versions of Java.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，你将学习如何在不同的支持的Java版本中进行选择。
- en: Note
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This recipe will work with all the four supported Java cartridges (Apache Tomcat
    6, Apache Tomcat 7, JBoss AS7, and JBoss EAP).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方适用于所有四种支持的Java cartridge（Apache Tomcat 6，Apache Tomcat 7，JBoss AS7 和 JBoss
    EAP）。
- en: How to do it…
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Perform the following steps to switch to OpenJDK 6:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以切换到OpenJDK 6：
- en: Create a new JBoss AS 7 application by running the following command. If you
    already have a Java application deployed on OpenShift, then you can use that as
    well.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令创建一个新的JBoss AS 7应用程序。如果你已经在OpenShift上部署了Java应用程序，则可以使用该应用程序。
- en: '[PRE60]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Once the application is created, you can check the default Java version by
    running the `java -version` command on the application gear as shown in the following
    command:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦应用程序创建完成，你可以通过在应用程序gear上运行`java -version`命令来检查默认的Java版本，如以下命令所示：
- en: '[PRE61]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To configure your application to use Java 6, delete a marker file called `java7`
    in the `.openshift/markers` directory as follows:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要配置应用程序使用Java 6，删除位于`.openshift/markers`目录中的名为`java7`的标记文件，如下所示：
- en: '[PRE62]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Commit the changes and push them to your application gear as follows:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交更改并将其推送到应用程序gear，如下所示：
- en: '[PRE63]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'After a successful build, run the `java -version` command again to verify that
    you are now using Java 6 as follows:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在成功构建后，再次运行`java -version`命令以验证你现在使用的是Java 6，如下所示：
- en: '[PRE64]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: How it works…
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: OpenShift uses the marker files to configure various aspects of the application,
    such as the Java version, hot deployment, debugging, and so on. The presence of
    a marker file in the `.openshift/markers` location tells OpenShift that you want
    to enable the feature. For example, every OpenShift application has a `java7`
    marker file in the `.openshift/markers` directory that informs OpenShift that
    it should use Java 7 for application deployment. When you perform code deployment
    using `git push`, OpenShift will set the `JAVA_HOME` environment variable depending
    on the Java version you want to use in your application.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift使用标记文件来配置应用程序的各种方面，例如Java版本、热部署、调试等。在`.openshift/markers`位置存在标记文件告诉OpenShift你想要启用的功能。例如，每个OpenShift应用程序在`.openshift/markers`目录中都有一个`java7`标记文件，告诉OpenShift在应用程序部署时使用Java
    7。当你使用`git push`进行代码部署时，OpenShift会根据你在应用程序中想要使用的Java版本设置`JAVA_HOME`环境变量。
- en: To use Java 6, you just deleted the `java7` marker file. This informs OpenShift
    that it should fall back to Java 6\. From now on, your application will use Java
    6.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Java 6，你只需删除`java7`标记文件。这会通知OpenShift应该回退到Java 6。从现在开始，你的应用程序将使用Java 6。
- en: See also
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Taking thread dumps of Java cartridges* recipe
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*获取Java cartridges线程转储*的步骤'
- en: The *Enabling hot deployment for Java applications* recipe
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为Java应用程序启用热部署*的步骤'
- en: Enabling hot deployment for Java applications
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Java应用程序启用热部署
- en: Every time you make a change and push it to the OpenShift application gear,
    OpenShift stops your gear (that is, all the cartridges), copies the source code
    from your application Git repo to `app-root/runtime/repo`, performs a build, prepares
    the artifact, and finally starts your gear (that is, all the cartridges). This
    process takes time and does not suit rapid development. To enable rapid development
    and faster deployment, OpenShift supports hot deployment. Hot deployment means
    that you can deploy your changes without the need to restart all the application
    cartridges.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 每次进行更改并将其推送到OpenShift应用程序齿轮时，OpenShift会停止你的齿轮（即所有的cartridges），从你的应用程序Git仓库复制源代码到`app-root/runtime/repo`，执行构建，准备构件，最后启动你的齿轮（即所有的cartridges）。这个过程需要时间，不适合快速开发。为了实现快速开发和更快的部署，OpenShift支持热部署。热部署意味着你可以在不需要重新启动所有应用程序cartridges的情况下部署你的更改。
- en: Note
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This recipe will work with all the four supported Java cartridges (Apache Tomcat
    6, Apache Tomcat 7, JBoss AS7, and JBoss EAP).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤适用于所有四种支持的Java cartridges（Apache Tomcat 6、Apache Tomcat 7、JBoss AS7和JBoss
    EAP）。
- en: How to do it…
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Perform the following steps to enable hot deployment:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以启用热部署：
- en: 'Open a new command-line terminal, and navigate to the directory where you want
    to create the application. To create a new JBoss EAP application, execute the
    following command. If you already have an OpenShift Java application, then you
    can work with that as well. Have a look at the following command:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的命令行终端，并导航到你想创建应用程序的目录。要创建一个新的JBoss EAP应用程序，请执行以下命令。如果你已经有一个OpenShift Java应用程序，那么你也可以使用它。看看以下命令：
- en: '[PRE65]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'To enable hot deployment, create a new file with the name `hot_deploy` inside
    the `.openshift/markers` directory. On *nix machines, you can create a new file
    using the `touch` command as shown in the following command. On Windows machines,
    you can use file explorer to create a new file. Have a look at the following code:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启用热部署，请在`.openshift/markers`目录下创建一个名为`hot_deploy`的新文件。在*nix机器上，你可以使用`touch`命令创建一个新文件，如下所示的命令。在Windows机器上，你可以使用文件浏览器创建一个新文件。看看以下代码：
- en: '[PRE66]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Add the new file to the Git repository index, commit it to the local repository,
    and then push the changes to the application''s remote Git repository:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件添加到Git仓库索引中，提交到本地仓库，然后将更改推送到应用程序的远程Git仓库：
- en: '[PRE67]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In the `git push` logs, you will see a message that cartridges are not stopped
    because hot deployment is enabled as follows:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`git push`日志中，你会看到一个消息，说明cartridges没有停止，因为已启用热部署，如下所示：
- en: '[PRE68]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: How it works…
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'The presence of the `hot_deploy` marker file informs OpenShift that you want
    to do hot deployment. Before stopping and starting the application cartridges,
    OpenShift checks for the existence of the `hot_deploy` marker file. For JBoss
    cartridges, hot deployment is achieved by using the JBoss deployment scanner.
    The scanner polls the `deployments` directory every 5 seconds to check for the
    existence of the WAR file. If the WAR file exists, it will undeploy the existing
    WAR file and deploy the new WAR file. You can configure the deployment scanner''s
    `scan-interval` option in `.openshift/config/standalone.xml`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`hot_deploy` 标记文件的存在会通知 OpenShift 你希望进行热部署。在停止和启动应用程序卡带之前，OpenShift 会检查 `hot_deploy`
    标记文件是否存在。对于 JBoss 卡带，热部署是通过使用 JBoss 部署扫描器来实现的。扫描器每 5 秒钟检查一次 `deployments` 目录，查看是否存在
    WAR 文件。如果 WAR 文件存在，它会卸载现有的 WAR 文件并部署新的 WAR 文件。你可以在 `.openshift/config/standalone.xml`
    中配置部署扫描器的 `scan-interval` 选项：'
- en: '[PRE69]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: When your application is using hot deploy, then your application will have downtime
    starting when the JBoss deployment scanner recognizes the new WAR file, undeploys
    the old one, and deploys the new WAR file. Your application will be back online
    once the new file is deployed.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用使用热部署时，应用程序将会有一段停机时间，停机开始于 JBoss 部署扫描器识别到新的 WAR 文件，卸载旧的文件并部署新的文件。应用程序将在新的文件部署完成后恢复上线。
- en: Hot deployment is ideal for development, and I recommend you should always use
    it during development.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 热部署非常适合开发，我建议在开发过程中始终使用它。
- en: Note
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you set new environment variables with hot deployment enabled, then you have
    to restart the application to allow the server to pick the new environment variables.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在启用热部署的情况下设置了新的环境变量，那么你必须重新启动应用程序，以便服务器能够识别新的环境变量。
- en: See also
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Taking thread dumps of Java cartridges* recipe
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*获取 Java 卡带的线程转储* 这个教程'
- en: The *Choosing between Java 6 and Java 7* recipe
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 Java 6 和 Java 7 之间选择* 这个教程'
- en: Skipping the Maven build
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跳过 Maven 构建
- en: Every OpenShift Java application is a Maven-based application. Whenever you
    run a `git push` command, a Maven build is performed, and the resulting archive
    (WAR or EAR) is deployed. There are scenarios where you don't want to do a Maven
    build with every push to the gear. These scenarios can be WAR deployment or executing
    only action hooks. In this recipe, you will learn how to skip the Maven build
    step during deployment.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 OpenShift Java 应用都是基于 Maven 的应用。每当你运行 `git push` 命令时，都会执行一个 Maven 构建，生成的归档文件（WAR
    或 EAR）会被部署。有些场景下，你可能不希望在每次推送到 Gear 时都执行 Maven 构建。这些场景包括 WAR 部署或仅执行动作钩子。在本教程中，你将学习如何在部署过程中跳过
    Maven 构建步骤。
- en: Note
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This recipe will work with all the four supported Java cartridges (Apache Tomcat
    6, Apache Tomcat 7, JBoss AS7, and JBoss EAP).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程适用于所有四个支持的 Java 卡带（Apache Tomcat 6、Apache Tomcat 7、JBoss AS7 和 JBoss EAP）。
- en: Getting ready
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To complete this recipe, you will need the `jobstore` application created in
    the *Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges* recipe. Please refer to this recipe if you don't have a running
    OpenShift application.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本教程，你需要在 *使用 JBoss EAP 和 PostgreSQL 9.2 卡带创建并部署 Java EE 6 应用程序* 中创建的 `jobstore`
    应用。如果你没有正在运行的 OpenShift 应用，请参考该教程。
- en: How to do it…
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Perform the following steps to skip the Maven build:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以跳过 Maven 构建：
- en: Open a new command-line terminal, and navigate to the directory where the `jobstore`
    application is located. If you don't have a Java OpenShift application, then you
    can recreate a new application by following the steps mentioned in the *Creating
    and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL 9.2 cartridges*
    recipe.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的命令行终端，导航到 `jobstore` 应用所在的目录。如果你没有 Java OpenShift 应用，可以按照 *使用 JBoss EAP
    和 PostgreSQL 9.2 卡带创建并部署 Java EE 6 应用程序* 中的步骤重新创建一个新应用。
- en: 'To skip a Maven build during deployment, create a marker file called `skip_maven_build`
    in the `.openshift/markers` directory. On *nix systems, you can use the `touch`
    command as shown in the following command. On Windows machines, you can use file
    explorer. Have a look at the following code:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在部署过程中跳过 Maven 构建，请在 `.openshift/markers` 目录下创建一个名为 `skip_maven_build` 的标记文件。在
    *nix 系统上，你可以使用如下命令中的 `touch` 命令。在 Windows 系统上，你可以使用文件资源管理器。请参考以下代码：
- en: '[PRE70]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Add the new file to the Git repository index, commit it to the local repository,
    and then push the changes to the application''s remote Git repository as follows:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件添加到 Git 仓库索引，提交到本地仓库，然后将更改推送到应用程序的远程 Git 仓库，如下所示：
- en: '[PRE71]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: How it works…
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'The presence of the `skip_maven_build` marker informs OpenShift that it should
    not build the application. In the `git push` command output, you will see that
    the Maven build is skipped because of the presence of the `skip_maven_build` marker
    file:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`skip_maven_build` 标记的存在通知 OpenShift 不需要构建应用程序。在 `git push` 命令的输出中，你会看到由于存在
    `skip_maven_build` 标记文件，Maven 构建被跳过：'
- en: '[PRE72]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: There's more…
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: Another way to skip the Maven build is to delete the `pom.xml` file. If there
    is no `pom.xml` file, then OpenShift does not try to build the application.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种跳过 Maven 构建的方法是删除 `pom.xml` 文件。如果没有 `pom.xml` 文件，OpenShift 就不会尝试构建应用程序。
- en: See also
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Forcing a clean Maven build* recipe
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*强制进行干净的 Maven 构建* 配方'
- en: The *Installing the JAR file not present in the Maven central repository* recipe
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安装不在 Maven 中央仓库中的 JAR 文件* 配方'
- en: The *Overriding the default Maven build command* recipe
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*覆盖默认 Maven 构建命令* 配方'
- en: Forcing a clean Maven build
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制进行干净的 Maven 构建
- en: The first time you push your changes to the application gear, Maven will download
    all the dependencies and will store those dependencies in the `.m2` directory
    under your application gear home directory. After the first push, OpenShift will
    reuse all the dependencies in the `.m2` repository and will only download new
    dependencies. This saves build time and make application deployment faster. But,
    there are a few situations when you want to do a clean build. One situation can
    be when you want to download all the latest Maven dependencies. In this recipe,
    you will learn how you can inform OpenShift to perform a clean build.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次将更改推送到应用程序 gear 时，Maven 会下载所有依赖项并将这些依赖项存储在应用程序 gear 主目录下的 `.m2` 目录中。第一次推送后，OpenShift
    将重用 `.m2` 仓库中的所有依赖项，只会下载新的依赖项。这可以节省构建时间并加快应用程序部署。但也有一些情况你需要进行干净的构建。一种情况是你希望下载所有最新的
    Maven 依赖项。在此配方中，你将学习如何通知 OpenShift 执行干净的构建。
- en: Note
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This recipe will work with all the four supported Java cartridges (Apache Tomcat
    6, Apache Tomcat 7, JBoss AS7, and JBoss EAP).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方适用于所有四个支持的 Java 套件（Apache Tomcat 6、Apache Tomcat 7、JBoss AS7 和 JBoss EAP）。
- en: Getting ready
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To complete this recipe, you will need the `jobstore` application created in
    the *Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges* recipe. Please refer to this recipe if you don't have a running
    OpenShift application.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此配方，你需要在 *使用 JBoss EAP 和 PostgreSQL 9.2 套件创建并部署 Java EE 6 应用程序* 配方中创建的 `jobstore`
    应用程序。如果你没有正在运行的 OpenShift 应用程序，请参考此配方。
- en: How to do it…
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Perform the following steps to force a clean Maven build of your Java application:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以强制进行 Java 应用程序的干净 Maven 构建：
- en: Open a new command-line terminal, and navigate to the directory where the `jobstore`
    application is located. If you don't have a Java OpenShift application, then you
    can recreate a new application by following the steps mentioned in the *Creating
    and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL 9.2 cartridges*
    recipe.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的命令行终端，导航到 `jobstore` 应用程序所在的目录。如果你没有 Java OpenShift 应用程序，可以按照 *使用 JBoss
    EAP 和 PostgreSQL 9.2 套件创建并部署 Java EE 6 应用程序* 配方中的步骤重新创建一个新的应用程序。
- en: 'To force a clean Maven build during deployment, create a marker file called
    `force_clean_build` inside the application''s`.openshift/markers` directory. On
    *nix systems, you can use the `touch` command as shown in the following command.
    On Windows machines, you can use file explorer. Have a look at the following screenshot:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在部署期间强制进行干净的 Maven 构建，请在应用程序的 `.openshift/markers` 目录中创建一个名为 `force_clean_build`
    的标记文件。在 *nix 系统上，可以使用以下命令中的 `touch` 命令。对于 Windows 系统，可以使用文件资源管理器。请查看以下截图：
- en: '[PRE73]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Add the new file to the Git repository index, commit it to the local repository,
    and then push the changes to the application''s remote Git repository as follows:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件添加到 Git 仓库索引，提交到本地仓库，然后将更改推送到应用程序的远程 Git 仓库，如下所示：
- en: '[PRE74]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: How it works…
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'The presence of the `force_clean_build` marker file informs OpenShift that
    you want to do a clean build. When you run a `git push` command, OpenShift will
    first delete the `.m2` directory and then start the build process by invoking
    the `mvn clean package -Popenshift -DskipTests` command. Maven will now download
    all the dependencies again. You will see the following log message in the `git
    push` command output. Have a look at the following command:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`force_clean_build`标记文件的存在告诉OpenShift你想进行一个干净的构建。当你运行`git push`命令时，OpenShift将首先删除`.m2`目录，然后通过调用`mvn
    clean package -Popenshift -DskipTests`命令来启动构建过程。Maven现在会重新下载所有的依赖项。你会在`git push`命令输出中看到以下日志信息。请查看以下命令：'
- en: '[PRE75]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: See also
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Forcing a clean Maven build* recipe
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*强制进行干净的Maven构建*配方'
- en: The *Installing the JAR file not present in the Maven central repository* recipe
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安装不在Maven中央仓库中的JAR文件*配方'
- en: The *Overriding the default Maven build command* recipe
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*覆盖默认的Maven构建命令*配方'
- en: Overriding the default Maven build command
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖默认的Maven构建命令
- en: OpenShift, by default, will execute the `mvn -e clean package -Popenshift -DskipTests`
    command to build the project. If you don't want to use the OpenShift Maven profile
    or want to run tests, then you have to tell OpenShift to run a different command.
    In this recipe, you will learn how you can tell OpenShift to use a different command.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，OpenShift将执行`mvn -e clean package -Popenshift -DskipTests`命令来构建项目。如果你不想使用OpenShift
    Maven配置文件，或者希望运行测试，那么你必须告诉OpenShift运行一个不同的命令。在本配方中，你将学习如何告诉OpenShift使用不同的命令。
- en: Getting ready
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To complete this recipe, you will need the `jobstore` application created in
    the *Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges* recipe. Please refer to this recipe if you don't have a running
    OpenShift application.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本配方，你需要使用*创建和部署Java EE 6应用程序，使用JBoss EAP和PostgreSQL 9.2 cartridge*配方中创建的`jobstore`应用程序。如果你没有正在运行的OpenShift应用程序，请参考该配方。
- en: How to do it…
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何执行…
- en: 'Perform the following steps to override the default Maven build command:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来覆盖默认的Maven构建命令：
- en: Open a new command-line terminal, and navigate to the directory where the `jobstore`
    application is located.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的命令行终端，并导航到`jobstore`应用程序所在的目录。
- en: 'To configure OpenShift to use a different build command, create a new environment
    variable with the name `MAVEN_ARGS`. The value of the `MAVEN_ARGS` environment
    variable is the Maven build phases you want to run, as shown in the following
    command:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要配置OpenShift使用不同的构建命令，请创建一个名为`MAVEN_ARGS`的新环境变量。`MAVEN_ARGS`环境变量的值是你希望运行的Maven构建阶段，如以下命令所示：
- en: '[PRE76]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: How it works…
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Before running the build, OpenShift first checks whether the environment variable
    called `MAVEN_ARGS` is set. It uses the phases and goals defined in this environment
    variable to create a Maven command that will be used to build the project. If
    `MAVEN_ARGS` is not set, then it will set the default value, that is, `clean package
    -Popenshift -DskipTests`, else it will use the value of the `MAVEN_ARGS` environment
    variable.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行构建之前，OpenShift首先检查名为`MAVEN_ARGS`的环境变量是否已设置。它使用该环境变量中定义的阶段和目标来创建一个Maven命令，用于构建项目。如果`MAVEN_ARGS`未设置，则会设置默认值，即`clean
    package -Popenshift -DskipTests`，否则将使用`MAVEN_ARGS`环境变量的值。
- en: 'Now, when you run the `git push` command, you will see an entry in the `git
    push` logs, as shown in the following command output:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行`git push`命令时，你将在`git push`日志中看到一条记录，如以下命令输出所示：
- en: '[PRE77]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: See also
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Forcing a clean Maven build* recipe
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*强制进行干净的Maven构建*配方'
- en: The *Installing the JAR file not present in the Maven central repository* recipe
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安装不在Maven中央仓库中的JAR文件*配方'
- en: The *Skipping the Maven build* recipe
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*跳过Maven构建*配方'
- en: Installing the JAR file not present in the Maven central repository
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装不在Maven中央仓库中的JAR文件
- en: OpenShift will download all the dependencies from the Maven central repositories
    specified in your `pom.xml` file. There are times when your application depends
    on the libraries that do not exist in any public Maven repository. In this recipe,
    you will learn how you can use the OpenShift action hooks to install a local JAR.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift将从你`pom.xml`文件中指定的Maven中央仓库下载所有的依赖项。有时候，你的应用程序依赖于在任何公共Maven仓库中都不存在的库。在本配方中，你将学习如何使用OpenShift的操作钩子来安装本地JAR文件。
- en: Getting ready
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To complete this recipe, you will need the `jobstore` application created in
    the *Creating and deploying Java EE 6 applications using the JBoss EAP and PostgreSQL
    9.2 cartridges* recipe. Please refer to this recipe if you don't have a running
    OpenShift application.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此方案，你需要在*使用JBoss EAP和PostgreSQL 9.2插件创建和部署Java EE 6应用程序* 方案中创建的`jobstore`应用程序。如果你没有正在运行的OpenShift应用程序，请参考此方案。
- en: How to do it…
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Perform the following steps to install the JAR file not present in the configured
    Maven repositories:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以安装未出现在配置的Maven仓库中的JAR文件：
- en: Open a new command-line terminal, and navigate to the directory where the `jobstore`
    application is located.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的命令行终端，并导航到`jobstore`应用程序所在的目录。
- en: Create a `lib` directory in the root of your application directory, and add
    your local JAR file here. To demonstrate this recipe, I have created a simple
    library that you can download from [https://github.com/OpenShift-Cookbook/chapter7-recipe14/raw/master/lib/simplelogger-0.0.1.jar](https://github.com/OpenShift-Cookbook/chapter7-recipe14/raw/master/lib/simplelogger-0.0.1.jar).
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序目录的根目录中创建一个`lib`目录，并将本地JAR文件添加到这里。为了演示这个方案，我创建了一个简单的库，你可以从[https://github.com/OpenShift-Cookbook/chapter7-recipe14/raw/master/lib/simplelogger-0.0.1.jar](https://github.com/OpenShift-Cookbook/chapter7-recipe14/raw/master/lib/simplelogger-0.0.1.jar)下载。
- en: 'Create a `pre_build` action hook inside the `.openshift/action_hooks` directory,
    and add the following content to it:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`.openshift/action_hooks`目录中创建一个`pre_build`操作钩子，并将以下内容添加到其中：
- en: '[PRE78]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The following command will install the JAR file to the local Maven repository
    located on the application gear:'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下命令将把JAR文件安装到位于应用程序gear上的本地Maven仓库：
- en: '[PRE79]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Make sure the `pre_build` action hook is executable. You can make the `pre_build`
    action hook script executable by running the following command:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保`pre_build`操作钩子是可执行的。你可以通过运行以下命令来使`pre_build`操作钩子脚本可执行：
- en: '[PRE80]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Add the dependency to the application''s `pom.xml` file so that your application
    can use the library in the application source code as follows:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将依赖项添加到应用程序的`pom.xml`文件中，以便你的应用程序可以在应用程序源代码中使用该库，如下所示：
- en: '[PRE81]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: How it works…
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: In step 2, you created a `lib` directory inside the application source code
    root. You downloaded the `simplelogging` library and placed it in the `lib` directory.
    Next, in step 2, you created a `pre_build` action hook that installs the `simplelogging-0.0.1.jar`
    file into the application gear's`.m2` repository. The `pre_build` script is executed
    before the build step. This means your library will be available during the build.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤2中，你在应用程序源代码的根目录内创建了一个`lib`目录。你下载了`simplelogging`库并将其放置在`lib`目录中。接下来，在步骤2中，你创建了一个`pre_build`操作钩子，它将`simplelogging-0.0.1.jar`文件安装到应用程序gear的`.m2`仓库中。`pre_build`脚本在构建步骤之前执行。这意味着你的库在构建过程中将可用。
- en: Note
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'On Windows, the execute permissions on the action hooks will be lost during
    `git push`. You can fix the problem by running the following command:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，操作钩子的执行权限会在`git push`过程中丢失。你可以通过运行以下命令来解决这个问题：
- en: '[PRE82]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Finally, you added the library as a dependency in your application's `pom.xml`
    file so that you can use the library in your application.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将库作为依赖项添加到应用程序的`pom.xml`文件中，这样就可以在应用程序中使用该库。
- en: See also
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Forcing a clean Maven build* recipe
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*强制进行清理的Maven构建* 方案'
- en: The *Overriding the default Maven build command* recipe
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*覆盖默认Maven构建命令* 方案'
- en: The *Skipping the Maven build* recipe
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*跳过Maven构建* 方案'
- en: Developing OpenShift Java applications using Eclipse
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Eclipse开发OpenShift Java应用程序
- en: You can build, deploy, and manage your OpenShift Java applications right from
    within the Eclipse IDE using the JBoss Tools OpenShift plugin. This recipe will
    guide you through installation, setup, application creation, and managing your
    application from within Eclipse. In this recipe, you will develop a Java EE 6
    PostgreSQL 9.2 application and deploy it on the JBoss EAP 6 application server
    running on OpenShift all from within Eclipse.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接在Eclipse IDE内使用JBoss Tools OpenShift插件来构建、部署和管理OpenShift Java应用程序。这个方案将引导你完成安装、设置、应用程序创建以及在Eclipse中管理应用程序的过程。在这个方案中，你将开发一个Java
    EE 6 PostgreSQL 9.2应用程序，并将其部署在运行OpenShift的JBoss EAP 6应用服务器上，所有操作都在Eclipse内完成。
- en: Getting ready
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Download the latest Eclipse package for your operating system from the official
    Eclipse website at [http://www.eclipse.org/downloads/](http://www.eclipse.org/downloads/).
    At the time of this writing, the latest Eclipse package is Kepler.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 从官方 Eclipse 网站下载适合您操作系统的最新 Eclipse 包，网址为[http://www.eclipse.org/downloads/](http://www.eclipse.org/downloads/)。在撰写本文时，最新的
    Eclipse 包是 Kepler 版本。
- en: 'It is very easy to install Eclipse; just extract the downloaded package, and
    we are done. On Linux and Mac, open a new command-line terminal, and type the
    following command:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Eclipse 非常简单，只需解压下载的包即可完成。在 Linux 和 Mac 系统上，打开一个新的命令行终端，并输入以下命令：
- en: '[PRE83]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: On Windows, you can extract the ZIP file using WinZip or 7-zip ([http://www.7-zip.org/download.html](http://www.7-zip.org/download.html))
    or any other software.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 系统上，您可以使用 WinZip 或 7-zip（[http://www.7-zip.org/download.html](http://www.7-zip.org/download.html)）或任何其他软件来解压
    ZIP 文件。
- en: After we have extracted the Eclipse file, there will be a folder named `*eclipse*`
    in the directory where we extracted Eclipse. We can optionally create a shortcut
    to the executable file.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 提取 Eclipse 文件后，在我们提取 Eclipse 的目录中会有一个名为`*eclipse*`的文件夹。我们可以选择性地创建一个快捷方式指向可执行文件。
- en: Note
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is recommended that you use the latest version of Eclipse, that is, Kepler,
    to work with OpenShift. Earlier versions are not supported and might not even
    work.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您使用最新版本的 Eclipse，即 Kepler，来与 OpenShift 配合使用。早期版本不再支持，甚至可能无法正常工作。
- en: How to do it…
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: 'Perform the following steps to create OpenShift applications using OpenShift
    Eclipse tooling:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤，使用 OpenShift Eclipse 工具创建 OpenShift 应用程序：
- en: After downloading and extracting the Eclipse Kepler IDE for Java EE, open Eclipse,
    and navigate to the project workspace. Navigate to **Help**|**Eclipse Marketplace**.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并解压 Eclipse Kepler IDE for Java EE 后，打开 Eclipse，进入项目工作区。导航到**帮助**|**Eclipse
    市场**。
- en: In the search box, type `jboss tools`, and then click on the **Go** button.
    After clicking on the **Go** button, we will see **JBoss Tools (Kepler)** as the
    first result. Now click on the **Install** button. Have a look at the following
    screenshot:![How to do it…](img/00065.jpeg)
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中输入`jboss tools`，然后点击**前往**按钮。点击**前往**按钮后，我们会看到**JBoss Tools (Kepler)**作为第一个结果。现在点击**安装**按钮。请查看以下截图：![操作步骤](img/00065.jpeg)
- en: After clicking on the **Install** button, you will get a list of plugins that
    you can install. As the purpose of this recipe is to demonstrate the OpenShift
    Eclipse support, we will only select **JBoss OpenShift Tools** from the list.
    After selecting **JBoss OpenShift Tools**, click on the **Confirm** button. Have
    a look at the following screenshot:![How to do it…](img/00066.jpeg)
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**安装**按钮后，您将看到可以安装的插件列表。由于本食谱的目的是演示 OpenShift Eclipse 的支持，我们只会从列表中选择**JBoss
    OpenShift Tools**。选择**JBoss OpenShift Tools**后，点击**确认**按钮。请查看以下截图：![操作步骤](img/00066.jpeg)
- en: Accept the license by clicking on the **I accept the terms of the license agreement**
    radio button, and then click on the **Finish** button.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**我接受许可协议的条款**单选按钮来接受许可协议，然后点击**完成**按钮。
- en: As the JBoss Tools OpenShift plugin is unsigned, you will get a security message.
    Click on the **OK** button, and restart Eclipse to apply the changes.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 JBoss Tools OpenShift 插件没有签名，您会收到安全提示。点击**确定**按钮，重新启动 Eclipse 以应用更改。
- en: Now that you've installed the OpenShift Eclipse plugin, you have everything
    required to start building the application. Create a new OpenShift application
    by navigating to **File**|**New**|**Other**|**OpenShift Application**:![How to
    do it…](img/00067.jpeg)
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您已经安装了 OpenShift Eclipse 插件，您拥有了构建应用程序所需的一切。通过导航到**文件**|**新建**|**其他**|**OpenShift
    应用程序**来创建一个新的 OpenShift 应用程序：![操作步骤](img/00067.jpeg)
- en: Click on the **Next** button, and you will be asked to provide your OpenShift
    account credentials. If you do not have an OpenShift account, you can click on
    the sign up **here** link on the wizard to create a new OpenShift account. Have
    a look at the following screenshot:![How to do it…](img/00068.jpeg)
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步**按钮，您将被要求提供您的 OpenShift 账户凭证。如果您没有 OpenShift 账户，可以点击向导中的**在这里注册**链接创建一个新的
    OpenShift 账户。请查看以下截图：![操作步骤](img/00068.jpeg)
- en: Enter your OpenShift account details. Also, check the **Save password** checkbox
    so that we do not have to enter the password with every command. Click on the
    **Next** button. Have a look at the following screenshot:![How to do it…](img/00069.jpeg)
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入您的 OpenShift 账户信息。同时，勾选**保存密码**复选框，这样我们就不需要在每次命令时都输入密码。点击**下一步**按钮。请查看以下截图：![操作步骤](img/00069.jpeg)
- en: After clicking on the **Next** button, you will be asked to enter additional
    information for password recovery. I choose **No**, but you can choose **Yes**
    as well.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步**按钮后，系统将要求您输入密码恢复的附加信息。我选择**否**，但您也可以选择**是**。
- en: Next, you will be asked to create a new OpenShift domain if you don't have a
    domain associated with your account already. The domain name is the unique namespace,
    and all the user applications will exist under this namespace. This is shown in
    the following screenshot:![How to do it…](img/00070.jpeg)
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，如果您的账户尚未关联域名，系统将要求您创建一个新的 OpenShift 域名。域名是唯一的命名空间，所有用户应用程序都将在该命名空间下存在。以下截图展示了此内容：![如何操作...](img/00070.jpeg)
- en: Next, you will be asked to upload your public SSH keys to OpenShift, as shown
    in the following screenshot:![How to do it…](img/00071.jpeg)
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，系统会要求您将公钥 SSH 上传至 OpenShift，如下所示截图所示：![如何操作...](img/00071.jpeg)
- en: You can either upload your existing SSH keys or create a new SSH key by clicking
    on the **New** button. Let's create a new key by clicking on the **New** button.
    We need to provide a name for the key and a name for the private and public key
    filenames. I have used my name as the key name and filename. Have a look at the
    following screenshot:![How to do it…](img/00072.jpeg)
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以上传现有的 SSH 密钥，也可以通过点击**新建**按钮创建一个新的 SSH 密钥。我们通过点击**新建**按钮来创建一个新的密钥。我们需要为密钥提供一个名称，以及为私钥和公钥文件指定文件名。我使用了我的名字作为密钥名称和文件名。请查看以下截图：![如何操作...](img/00072.jpeg)
- en: Now, you will be directed to the application creation wizard where you have
    to enter the application details. The details include the name of the application,
    the type of the application, the gear profile (whether you want a small, medium,
    or large instance; in a free tier, you have access only to small instances), whether
    you want a scalable application or a nonscalable application, and whether you
    want to embed any or multiple cartridges, such as MySQL, PostgreSQL, MongoDB,
    and others. For our application, we will select the JBoss EAP and PostgreSQL cartridges.
    We will name the application `jobstore` as shown in the following screenshot:![How
    to do it…](img/00073.jpeg)
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您将进入应用程序创建向导，在此您需要输入应用程序的详细信息。这些详细信息包括应用程序的名称、应用程序类型、实例配置（您希望使用小型、中型还是大型实例；在免费层中，您仅能使用小型实例）、是否希望应用程序可扩展，是否希望嵌入任何或多个插件，例如
    MySQL、PostgreSQL、MongoDB 等。对于我们的应用程序，我们将选择 JBoss EAP 和 PostgreSQL 插件。我们将把应用程序命名为
    `jobstore`，如下所示的截图所示：![如何操作...](img/00073.jpeg)
- en: Next, you have to set up a `jobstore` application and configure the server adapter
    settings. Choose the default and click on **Next**.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您需要设置一个`jobstore`应用程序并配置服务器适配器设置。选择默认设置并点击**下一步**。
- en: The next screen will ask us to specify the location where we want to clone the
    Git repository and the name of the Git remote. Have a look at the following screenshot:![How
    to do it…](img/00074.jpeg)
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一屏幕会要求我们指定克隆 Git 仓库的位置和 Git 远程的名称。请查看以下截图：![如何操作...](img/00074.jpeg)
- en: Finally, click on the **Finish** button to initiate the application creation
    process. This will create an application container for us, called a gear, and
    set up all the required SELinux policies and cgroup configuration. OpenShift will
    install the PostgreSQL cartridge on the application gear, and the JBoss Tools
    OpenShift plugin will show an information box with the PostgreSQL details.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击**完成**按钮以启动应用程序创建过程。这将为我们创建一个名为 gear 的应用程序容器，并设置所有必要的 SELinux 策略和 cgroup
    配置。OpenShift 会在应用程序 gear 上安装 PostgreSQL 插件，并且 JBoss Tools OpenShift 插件将显示一个包含
    PostgreSQL 详细信息的消息框。
- en: Finally, the project is imported as a Maven project in the Eclipse workspace.
    After importing the application to Eclipse, you will be asked whether you want
    to publish the uncommitted changes. You might start wondering why it is asking
    you to publish changes. The reason is that when a project is imported into Eclipse,
    JBoss Tools creates a new file called `.jsdtscope` under the `.settings` directory.
    As the file is not ignored, the OpenShift Eclipse plugin asks you for a deployment.
    You can easily ignore the file by navigating to the **Git Staging** view. To open
    the **Git Staging** view, navigate to **Window**|**Show View**|**Other**|**Git**|**Git
    Staging**. Have a look at the following screenshot:![How to do it…](img/00075.jpeg)
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，项目以Maven项目的形式导入到Eclipse工作区。导入应用程序到Eclipse后，系统会询问你是否要发布未提交的更改。你可能会开始怀疑为什么它会要求你发布更改。原因是，当一个项目导入到Eclipse时，JBoss
    Tools会在`.settings`目录下创建一个新的文件`.jsdtscope`。由于该文件没有被忽略，OpenShift Eclipse插件会要求你进行部署。你可以轻松忽略该文件，通过导航到**Git
    Staging**视图来完成。要打开**Git Staging**视图，导航到**窗口**|**显示视图**|**其他**|**Git**|**Git Staging**。请看下面的截图：![操作方法…](img/00075.jpeg)
- en: Right-click on the `.jsdtscope` file under the **Git Staging** view, and then
    choose **Ignore**. Have a look at the following screenshot:![How to do it…](img/00076.jpeg)
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Git Staging**视图下，右键点击`.jsdtscope`文件，然后选择**忽略**。请看下面的截图：![操作方法…](img/00076.jpeg)
- en: Next, open the **OpenShift Explorer** view. Navigate to **Window**|**Show View**|**Other**|**JBoss
    Tools**|**OpenShift Explorer**. This will open up a new view as shown in the following
    screenshot:![How to do it…](img/00077.jpeg)
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开**OpenShift Explorer**视图。导航至**窗口**|**显示视图**|**其他**|**JBoss 工具**|**OpenShift
    Explorer**。这将打开一个新视图，如下图所示：![操作方法…](img/00077.jpeg)
- en: Now, right-click on the application, and then click on the **Show in Web Browser**
    option. This will open up the template application in the default browser.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，右键点击应用程序，然后点击**在Web浏览器中显示**选项。这将会在默认浏览器中打开模板应用程序。
- en: How it works…
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The preceding steps help you to create OpenShift Java applications using Eclipse.
    In this recipe, I used the JBoss EAP cartridge, but you can do the same for the
    Tomcat or JBoss AS7 cartridge. The preceding steps are self-explanatory and do
    not require any explanation. Now, I will explain to you how your development workflow
    should work. The recommended way to work with OpenShift Eclipse tooling is split
    into two steps, which are as follows:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 上述步骤帮助你通过Eclipse创建OpenShift Java应用程序。在此示例中，我使用了JBoss EAP cartridge，但你也可以使用Tomcat或JBoss
    AS7 cartridge做同样的操作。前面的步骤不需要进一步解释，下面我将向你说明如何进行开发工作流。与OpenShift Eclipse工具的推荐工作方式分为两个步骤，具体如下：
- en: Write code for functionality, and then commit the code to a Git local repository
    using the **Git Staging** view. The **Git Staging** view gives a graphical view
    to the changes, and you can easily compare and look at all the files we have changed.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写功能代码，然后通过**Git Staging**视图将代码提交到Git本地仓库。**Git Staging**视图提供了图形化界面来查看更改，您可以轻松地比较并查看我们所修改的所有文件。
- en: In the **Git Staging** view, you have two options. You can either commit the
    changes to the local repository or do a commit and push together. When you perform
    `git commit` and `push` together, the code is pushed to a Git remote called `origin`.
    The `origin` remote points to a private Git repository created by OpenShift. When
    the code is pushed to the remote repository, OpenShift will kick off the build.
    The problem with the **Git Staging** view **Commit and Push** button is that you
    will not be able to monitor the application build logs. To view the application
    build logs, you should use the server view publication mechanism. We will use
    the server configured for the `jobstore` OpenShift application. To publish the
    changes, right-click on the server, and click on **Publish**. This internally
    does a `git push`. The advantage of this approach is that it will open up a new
    console view, where we can monitor the application build progress.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Git Staging**视图中，你有两个选项。你可以选择将更改提交到本地仓库，或者同时执行提交和推送。当你同时执行`git commit`和`push`时，代码会推送到名为`origin`的Git远程仓库。`origin`远程指向OpenShift创建的私人Git仓库。当代码推送到远程仓库时，OpenShift会启动构建。**Git
    Staging**视图中的**提交并推送**按钮的问题是，你将无法监控应用程序的构建日志。为了查看应用程序的构建日志，应该使用服务器视图的发布机制。我们将使用为`jobstore`
    OpenShift应用程序配置的服务器。要发布更改，右键点击服务器，然后点击**发布**。这将执行`git push`。这种方式的优点是，它会打开一个新的控制台视图，我们可以在其中监控应用程序的构建进度。
- en: 'Let''s make a small change to the application to better understand the development
    workflow discussed in the previous section. Open the `index.html` file, and consider
    the following code:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对应用程序做一个小的更改，以便更好地理解前一部分中讨论的开发工作流。打开`index.html`文件，并考虑以下代码：
- en: '[PRE84]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'And change it to:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将其更改为：
- en: '[PRE85]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Go to the **Git Staging** view, and you will see the change shown in the following
    screenshot:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 转到**Git Staging**视图，你将看到以下截图所示的更改：
- en: '![How it works…](img/00078.jpeg)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/00078.jpeg)'
- en: 'Next, drag the change to **Staged Changes**, and write a commit message. Have
    a look at the following screenshot:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将更改拖动到**Staged Changes**，并写入提交信息。请查看以下截图：
- en: '![How it works…](img/00079.jpeg)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/00079.jpeg)'
- en: Commit the change by clicking on the **Commit** button. As I mentioned before,
    do not use **Commit and Push**, as that will trigger application deployment and
    will not show the build log. The build log is very useful when the build fails.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击**Commit**按钮提交更改。如前所述，切勿使用**Commit and Push**，因为那样会触发应用程序部署，并且不会显示构建日志。构建日志在构建失败时非常有用。
- en: Go to the **Servers** view, and you will see a server configured for the `jobstore`
    application.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 转到**Servers**视图，你将看到为`jobstore`应用程序配置的服务器。
- en: 'Right-click on the application server, and then click on **Publish**. Have
    a look at the following screenshot:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击应用程序服务器，然后点击**Publish**。请查看以下截图：
- en: '![How it works…](img/00080.jpeg)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/00080.jpeg)'
- en: 'You will get a dialog where you have to confirm whether you want to publish
    the changes or not. Click on **Yes**, and it will open a new **Console** view
    where we can track the build progress. Have a look at the following screenshot:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到一个对话框，需要确认是否发布更改。点击**Yes**，这将打开一个新的**Console**视图，我们可以在其中跟踪构建进度。请查看以下截图：
- en: '![How it works…](img/00081.jpeg)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/00081.jpeg)'
- en: 'To view the logfiles of the JBoss EAP application server, go to the **OpenShift
    Explorer** view, and right-click on the application. Click on **Tail files…**.
    Have a look at the following screenshot:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看JBoss EAP应用程序服务器的日志文件，请转到**OpenShift Explorer**视图，右键点击应用程序。点击**Tail files…**。请查看以下截图：
- en: '![How it works…](img/00082.jpeg)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/00082.jpeg)'
- en: 'Next, you will configure to tail only the JBoss EAP `server.log` file. By default,
    it will tail all the logfiles, which includes the database logfiles as well, as
    shown in the following screenshot:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将配置仅跟踪JBoss EAP的`server.log`文件。默认情况下，它将跟踪所有日志文件，包括数据库日志文件，如下图所示：
- en: '![How it works…](img/00083.jpeg)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/00083.jpeg)'
- en: It will open up another console view where it will tail only the JBoss EAP `server.log`
    file.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开另一个控制台视图，届时它将仅跟踪JBoss EAP的`server.log`文件。
- en: Finally, we can view the change in the browser by right-clicking on the **jobstore**
    server, and then navigating to **Show In**|**Web Browser**. This will open up
    the default web browser, where we can view the change that we made in `index.html`.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过右键点击**jobstore**服务器，然后导航到**Show In**|**Web Browser**来在浏览器中查看更改。这将打开默认的Web浏览器，我们可以查看在`index.html`中所做的更改。
- en: There's more…
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'You can do a lot more with the OpenShift Eclipse plugin. For faster development,
    you should enable hot deployment. The OpenShift Eclipse plugin makes it very easy
    to enable hot deployment. To enable hot deployment, right-click on the project,
    and then navigate to **OpenShift**|**Configure Markers**. Have a look at the following
    screenshot:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用OpenShift Eclipse插件做更多的事情。为了加快开发速度，你应该启用热部署。OpenShift Eclipse插件使启用热部署变得非常简单。要启用热部署，右键点击项目，然后导航到**OpenShift**|**Configure
    Markers**。请查看以下截图：
- en: '![There''s more…](img/00084.jpeg)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多…](img/00084.jpeg)'
- en: 'Then, you will see a view where you can configure which OpenShift markers you
    want to enable for the application. Select the **Hot Deploy** marker. Have a look
    at the following screenshot:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将看到一个视图，在其中可以配置你希望为应用程序启用的OpenShift标记。选择**Hot Deploy**标记。请查看以下截图：
- en: '![There''s more…](img/00085.jpeg)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多…](img/00085.jpeg)'
- en: 'This will create a new empty file called `hot_deploy` in the `.openshift/markers`
    directory. You can commit the changes by going to the **Git Staging** view. Go
    to the **Servers** view, and publish this change. The build log will show that
    the cartridges are not stopped as hot deploy is enabled. Have a look at the following
    build log:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`hot_deploy`的新空文件，位于`.openshift/markers`目录中。你可以通过进入**Git Staging**视图提交更改。进入**Servers**视图，发布此更改。构建日志将显示热部署已启用，因此卡片没有停止。请查看以下构建日志：
- en: '[PRE86]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: See also
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Using Eclipse System Explorer to SSH into the application gear* recipe
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Eclipse 系统资源管理器 SSH 进入应用程序设备* 教程'
- en: The *Debugging Java applications in the Cloud* recipe
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在云中调试 Java 应用程序* 教程'
- en: Using Eclipse System Explorer to SSH into the application gear
  id: totrans-473
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Eclipse 系统资源管理器 SSH 进入应用程序设备
- en: In this recipe, you will learn how you can SSH into the application gear from
    within Eclipse.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，您将学习如何通过 Eclipse SSH 进入应用程序设备。
- en: Getting ready
  id: totrans-475
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires you to have Eclipse with the JBoss Tools OpenShift plugin
    installed. Please refer to the *Developing OpenShift Java applications using Eclipse*
    recipe for more information.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程要求您安装带有 JBoss Tools OpenShift 插件的 Eclipse。更多信息，请参考 *使用 Eclipse 开发 OpenShift
    Java 应用程序* 教程。
- en: How to do it…
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Perform the following steps to learn how to SSH into the application gear from
    within Eclipse:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤，了解如何通过 Eclipse SSH 进入应用程序设备：
- en: Create a new application using the OpenShift Eclipse plugin. Refer to the *Developing
    OpenShift Java applications using Eclipse* recipe for instructions.
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 OpenShift Eclipse 插件创建一个新应用程序。有关说明，请参考 *使用 Eclipse 开发 OpenShift Java 应用程序*
    教程。
- en: Navigate to **Window**|**Open Perspective**|**Other**|**Remote System Explorer**
    to open the **Remote System Explorer** perspective. Have a look at the following
    screenshot:![How to do it…](img/00086.jpeg)
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航至 **Window**|**Open Perspective**|**Other**|**Remote System Explorer** 打开
    **Remote System Explorer** 视图。请查看以下截图：![如何操作…](img/00086.jpeg)
- en: Go to **OpenShift Explorer** and copy the SSH connection details as shown in
    the following screenshot:![How to do it…](img/00087.jpeg)
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到 **OpenShift Explorer** 并复制 SSH 连接详细信息，如下图所示：![如何操作…](img/00087.jpeg)
- en: Copy the SSH details as shown in the following screenshot:![How to do it…](img/00088.jpeg)
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制 SSH 详细信息，如下图所示：![如何操作…](img/00088.jpeg)
- en: Go back to the **Remote System Explorer** perspective, and define a new connection
    to the remote system as shown in the following screenshot:![How to do it…](img/00089.jpeg)
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 **Remote System Explorer** 视图，并定义一个新的远程系统连接，如下图所示：![如何操作…](img/00089.jpeg)
- en: Next, it will ask you to select the remote system type. Select the **SSH Only**
    option as shown in the following screenshot:![How to do it…](img/00090.jpeg)
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，系统会要求您选择远程系统类型。选择 **仅 SSH** 选项，如下图所示：![如何操作…](img/00090.jpeg)
- en: Next, you will be asked to enter the details of the new connection. Enter the
    hostname of your application as shown in the following screenshot:![How to do
    it…](img/00091.jpeg)
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您将被要求输入新连接的详细信息。请输入您的应用程序主机名，如下图所示：![如何操作…](img/00091.jpeg)
- en: Click on the **Finish** button to create a new connection. The connection will
    be listed in the left-hand side bar.
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Finish** 按钮以创建新连接。连接将列在左侧栏中。
- en: To open an SSH terminal, navigate to **Ssh Terminals**|**Launch Terminal** as
    follows:![How to do it…](img/00092.jpeg)
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要打开 SSH 终端，请按照以下步骤导航到 **Ssh Terminals**|**Launch Terminal**：![如何操作…](img/00092.jpeg)
- en: Next, you will be asked to enter the user ID with which you want to connect.
    The user ID is the `UUID` part of the SSH connection URL. Click on **OK**. Have
    a look at the following screenshot:![How to do it…](img/00093.jpeg)
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，系统会要求您输入要连接的用户 ID。用户 ID 是 SSH 连接 URL 中的 `UUID` 部分。点击 **OK**。请查看以下截图：![如何操作…](img/00093.jpeg)
- en: Launch the terminal again, and you will see an SSH terminal as shown in the
    following screenshot:![How to do it…](img/00094.jpeg)
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次启动终端，您将看到如下所示的 SSH 终端：![如何操作…](img/00094.jpeg)
- en: How it works…
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理是……
- en: In the preceding steps, you used Eclipse Remote System Explorer to SSH into
    the OpenShift application gear. Remote System Explorer comes bundled with Eclipse
    Kepler for Java EE. Remote System Explorer allows you to connect and work with
    a variety of remote systems. To learn more about Remote System Explorer, you can
    refer to the documentation at [http://help.eclipse.org/kepler/index.jsp?nav=%2F56](http://help.eclipse.org/kepler/index.jsp?nav=%2F56).
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的步骤中，您使用了 Eclipse 的 Remote System Explorer 来 SSH 进入 OpenShift 应用程序设备。Remote
    System Explorer 已随 Eclipse Kepler for Java EE 打包。Remote System Explorer 允许您连接并与各种远程系统进行交互。要了解有关
    Remote System Explorer 的更多信息，您可以参考文档：[http://help.eclipse.org/kepler/index.jsp?nav=%2F56](http://help.eclipse.org/kepler/index.jsp?nav=%2F56)。
- en: See also
  id: totrans-492
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Developing OpenShift Java applications using Eclipse* recipe
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Eclipse 开发 OpenShift Java 应用程序* 教程'
- en: The *Debugging Java applications in the Cloud* recipe
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在云中调试 Java 应用程序* 教程'
- en: Debugging Java applications in the Cloud
  id: totrans-495
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在云中调试 Java 应用程序
- en: In this recipe, you will learn how to debug Java applications running on OpenShift.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，你将学习如何调试运行在OpenShift上的Java应用程序。
- en: Getting ready
  id: totrans-497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: This recipe requires you to have Eclipse with the JBoss Tools OpenShift plugin
    installed. Please refer to the *Developing OpenShift Java applications using Eclipse*
    recipe for more information.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱要求你安装带有JBoss Tools OpenShift插件的Eclipse。有关更多信息，请参考*使用Eclipse开发OpenShift Java应用程序*食谱。
- en: How to do it…
  id: totrans-499
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: 'Perform the following steps to learn how to debug your Java applications:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤，学习如何调试Java应用程序：
- en: In the *Developing OpenShift Java applications using Eclipse* recipe, you learned
    how to create a Java application using the Eclipse plugin. The application that
    we developed used the OpenShift template application as its starting point. As
    you might know, in the `rhc` command line, you can use the `--from-code` option
    to specify your own template application. Let's create a new Java application
    using Eclipse that uses the application we created in the *Creating and deploying
    Java EE 6 applications using the JBoss EAP and PostgreSQL 9.2 cartridges* recipe
    using Eclipse. Create a new OpenShift application by navigating to **File**|**New**|**Other**|**OpenShift
    Application**. After validating your account, you will get a screen where you
    need to enter the application details. Please select the **JBoss EAP** and **PostgreSQL
    9.2** cartridges. To specify the Git repository, click on the **Advanced** button,
    and then uncheck the **Use default source code** checkbox.
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*使用Eclipse开发OpenShift Java应用程序*的食谱中，你学习了如何使用Eclipse插件创建Java应用程序。我们开发的应用程序使用了OpenShift模板应用程序作为起点。如你所知，在`rhc`命令行中，你可以使用`--from-code`选项来指定自己的模板应用程序。现在，让我们创建一个新的Java应用程序，使用Eclipse，并使用在*使用JBoss
    EAP和PostgreSQL 9.2组件创建和部署Java EE 6应用程序*食谱中创建的应用程序。通过导航到**文件**|**新建**|**其他**|**OpenShift应用程序**来创建新的OpenShift应用程序。验证你的账户后，会出现一个屏幕，要求你输入应用程序的详细信息。请选择**JBoss
    EAP**和**PostgreSQL 9.2**组件。为了指定Git仓库，点击**高级**按钮，然后取消勾选**使用默认源代码**复选框。
- en: 'In the input box, specify the URL of the Git repository as shown in the following
    screenshot:'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在输入框中，指定Git仓库的URL，如下图所示：
- en: '![How to do it…](img/00095.jpeg)'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![操作步骤…](img/00095.jpeg)'
- en: Next, you have to set up a `jobstore` application and configure the server adapter
    settings. Choose the default and click on **Next**.
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要设置一个`jobstore`应用程序并配置服务器适配器设置。选择默认设置，然后点击**下一步**。
- en: The next screen will ask us to specify the location where you want to clone
    the Git repository and the name of the Git remote. Specify a writable directory,
    and click on **Finish**.
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一屏幕将要求你指定克隆Git仓库的位置以及Git远程的名称。指定一个可写目录，然后点击**完成**。
- en: Now, a new application instance will be created using the selected cartridges
    and Git repository. Finally, the project will be imported into Eclipse as a Maven
    project.
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将使用所选的组件和Git仓库创建一个新的应用程序实例。最后，项目将作为Maven项目导入到Eclipse中。
- en: To enable debugging, you have to create a new marker file called `enable_jpda`
    inside the `.openshift/markers` directory. The Eclipse plugin can help us create
    the file. Right-click on the project, and navigate to **OpenShift** |**Configure
    Markers…**.
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了启用调试，你必须在`.openshift/markers`目录中创建一个名为`enable_jpda`的新标记文件。Eclipse插件可以帮助我们创建这个文件。右键点击项目，导航到**OpenShift**
    | **配置标记…**。
- en: This will open a dialog where you can select the marker files. Select the **Enable
    JPDA** marker as shown in the following screenshot. This will create a new file
    called `enable_jpda` inside the `.openshift/markers` directory.![How to do it…](img/00096.jpeg)
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将打开一个对话框，你可以在其中选择标记文件。选择**启用JPDA**标记，如下图所示。这将在`.openshift/markers`目录下创建一个名为`enable_jpda`的新文件。![操作步骤…](img/00096.jpeg)
- en: Go to the **Git Staging** view, and commit the change. Have a look at the following
    screenshot:![How to do it…](img/00097.jpeg)
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**Git Staging**视图，并提交更改。请查看以下截图：![操作步骤…](img/00097.jpeg)
- en: After committing the change, go to the **Servers** view, and publish your changes.
    This will start the server with JPDA enabled.
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交更改后，进入**服务器**视图，发布你的更改。这将启动带有JPDA启用的服务器。
- en: Now, enable port forwarding so that you can connect with the JPDA port. Go to
    the **OpenShift Explorer** view, and right-click on the project to enable port
    forwarding. Have a look at the following screenshot:![How to do it…](img/00098.jpeg)
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，启用端口转发，以便你可以连接到JPDA端口。进入**OpenShift Explorer**视图，右键点击项目以启用端口转发。请查看以下截图：![操作步骤…](img/00098.jpeg)
- en: This will open a dialog where you can configure port forwarding. Click on the
    **Start All** button to enable port forwarding. The port `8787` is used to debug.
    This is shown in the following screenshot:![How to do it…](img/00099.jpeg)
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将打开一个对话框，你可以在其中配置端口转发。点击**全部启动**按钮以启用端口转发。端口`8787`用于调试。如以下截图所示：![如何操作…](img/00099.jpeg)
- en: Now, we will add the breakpoint to the `CompanyResource` class at line number
    32\. After setting the debug point, create a new debug configuration by right-clicking
    on the debug point, navigating to **Debug Configurations**|**Remote Java Application**|**New**
    and giving it a name, and enter the port as `8787` as shown in the following screenshot:![How
    to do it…](img/00100.jpeg)
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在`CompanyResource`类的第32行添加断点。设置完调试点后，通过右键单击调试点，依次选择**调试配置**|**远程 Java
    应用程序**|**新建**并为其命名，输入端口`8787`，如下图所示：![如何操作…](img/00100.jpeg)
- en: After entering all the details, click on the **Debug** button. Open the debug
    perspective, and you will see the remote debugger in action. Please note that
    it will take some time to enable remote debugging, so please be patient. This
    is shown in the following screenshot:![How to do it…](img/00101.jpeg)
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入所有信息后，点击**调试**按钮。打开调试视角，你将看到远程调试器正在运行。请注意，启用远程调试需要一些时间，请耐心等待。如下图所示：![如何操作…](img/00101.jpeg)
- en: Now, go to `http://jobstore-{domain-name}.rhcloud.com/#companies/new` and create
    a new company. This will invoke the breakpoint as shown in the following screenshot:![How
    to do it…](img/00102.jpeg)
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，访问`http://jobstore-{domain-name}.rhcloud.com/#companies/new`并创建一个新公司。这将触发下图所示的断点：![如何操作…](img/00102.jpeg)
- en: How it works…
  id: totrans-516
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'The preceding steps enable Java developers to debug their OpenShift Java applications.
    To enable debugging, you created a marker file under the`.openshift/markers` directory
    using the Eclipse plugin. The file is committed, and the changes are pushed to
    the OpenShift application gear. After a push, the JBoss server is stopped and
    then started again. The JBoss cartridge checks the presence of the `enable_jpda`
    file. If the `enable_jpda` marker file exists, then the server is started in debug
    mode. The debugging provided by JBoss is based on the **Java Platform Debugger
    Architecture** (**JPDA**). To enable debugging, the JBoss server is started with
    the `JAVA_OPTS` environment variable set to the value shown in the following code:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 上述步骤使 Java 开发人员能够调试其 OpenShift Java 应用程序。为了启用调试，你在`.openshift/markers`目录下使用
    Eclipse 插件创建了一个标记文件。该文件已提交，并将更改推送到 OpenShift 应用程序 gear。在推送后，JBoss 服务器会停止并重新启动。JBoss
    cartridge 会检查是否存在`enable_jpda`文件。如果`enable_jpda`标记文件存在，则服务器会以调试模式启动。JBoss 提供的调试基于**Java
    平台调试架构**(**JPDA**)。为了启用调试，JBoss 服务器会使用以下代码中显示的值设置`JAVA_OPTS`环境变量来启动：
- en: '[PRE87]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: As the port `8787` is not accessible to the outside world, you have to enable
    port forwarding. After enabling port forwarding, you created a new remote Java
    application that will connect to the JBoss EAP cartridge running in debug mode.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 由于端口`8787`无法对外访问，因此你必须启用端口转发。启用端口转发后，你创建了一个新的远程 Java 应用程序，将连接到以调试模式运行的 JBoss
    EAP cartridge。
- en: See also
  id: totrans-520
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Developing OpenShift Java applications using Eclipse* recipe
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Eclipse 开发 OpenShift Java 应用程序* 配方'
- en: The *Using Eclipse System Explorer to SSH into the application gear* recipe
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Eclipse 系统资源管理器通过 SSH 连接到应用程序 gear* 配方'
