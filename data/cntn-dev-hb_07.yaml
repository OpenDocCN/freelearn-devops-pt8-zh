- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Orchestrating with Swarm
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Swarm 进行编排
- en: As a developer, you can create your applications based on microservices. Using
    containers to distribute your applications into different components will allow
    you to provide them with different functionalities and capabilities, such as **scalability**
    or **resilience**. Working with a standalone environment is simple with tools
    such as Docker Compose, but things get difficult when containers can run cluster-wide
    on different hosts. In this chapter, we are going to learn how **Docker Swarm**
    will allow us to orchestrate our application containers with a full set of features
    for managing scalability, networking, and resilience. We will review how orchestration
    requirements are included in the Docker container engine and how to implement
    each of our application’s specific needs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，你可以基于微服务创建应用程序。使用容器将你的应用程序分发到不同的组件，可以为它们提供不同的功能和能力，如**可扩展性**或**弹性**。使用
    Docker Compose 等工具，单独的环境操作比较简单，但当容器能够在不同主机的集群范围内运行时，事情就变得复杂了。在本章中，我们将学习如何通过 **Docker
    Swarm** 来协调应用容器，提供一整套管理可扩展性、网络和弹性的功能。我们将回顾如何在 Docker 容器引擎中实现协调需求，并且如何实现每个应用程序的具体需求。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将覆盖以下主题：
- en: Deploying a Docker Swarm cluster
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署 Docker Swarm 集群
- en: Providing high availability with Docker Swarm
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker Swarm 提供高可用性
- en: Creating tasks and services for your applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的应用创建任务和服务
- en: A review of stacks and other Docker Swarm resources
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈和其他 Docker Swarm 资源的回顾
- en: Networking and exposing applications with Docker Swarm
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker Swarm 进行网络配置和暴露应用
- en: Updating your application’s services
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新应用程序的服务
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We will use open source tools to build, share, and run a simple but functional
    Docker Swarm environment. The labs included in this chapter will help you to understand
    the content presented, and they are published at https://github.com/PacktPublishing/Containers-for-Developers-Handbook/tree/main/Chapter7\.
    The *Code In Action* video for this chapter can be found at [https://packt.link/JdOIY](https://packt.link/JdOIY).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用开源工具构建、分享并运行一个简单但功能完善的 Docker Swarm 环境。本章包含的实验将帮助你理解所呈现的内容，并且它们已发布在 https://github.com/PacktPublishing/Containers-for-Developers-Handbook/tree/main/Chapter7。
    本章的 *Code In Action* 视频可以在 [https://packt.link/JdOIY](https://packt.link/JdOIY)
    找到。
- en: Deploying a Docker Swarm cluster
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署 Docker Swarm 集群
- en: '**Docker Swarm** is the orchestration platform developed by Docker Inc. It
    is probably the simplest orchestration solution for beginning to deploy your containerized
    applications. It is included inside the Docker container runtime and no additional
    software is required to deploy, manage, and provide a complete and secure Docker
    Swarm cluster solution. However, before we learn how to do this, let’s explore
    the architecture of Docker Swarm.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker Swarm** 是 Docker 公司开发的编排平台。它可能是最简单的编排解决方案，用于开始部署你的容器化应用程序。它已包含在 Docker
    容器运行时中，不需要额外的软件来部署、管理和提供完整且安全的 Docker Swarm 集群解决方案。不过，在我们学习如何操作之前，先来探索一下 Docker
    Swarm 的架构。'
- en: Understanding Docker Swarm’s architecture
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Docker Swarm 的架构
- en: Docker Swarm’s architecture is based on the concepts of a **control plane**,
    **management plane**, and **data plane** or **workload plane**. The control plane
    supervises the status of the cluster, the management plane provides all the platform
    management features, and finally, the data plane executes the user-defined tasks.
    These planes can be isolated from each other using multiple network interfaces
    (but this should be completely transparent to you as a developer). This model
    is also present in other orchestrators, such as Kubernetes (simplified into **role
    nodes**). Different roles will be used to define the work associated with the
    nodes within the cluster. The main difference between Docker Swarm and other orchestrators
    is that these roles are easily interchangeable within nodes; hence, a control/management
    plane node can be converted into a workload-ready node with just a command. Docker
    Swarm manages all the control plane communications securely by using **Transport
    Layer Security** (**TLS**)-encrypted networks. The internal **certificate authority**
    (**CA**) and its certificates will be completely managed by Docker Swarm.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Swarm 的架构基于**控制平面**、**管理平面**和**数据平面**（或**工作负载平面**）的概念。控制平面监督集群的状态，管理平面提供所有平台管理功能，最后，数据平面执行用户定义的任务。可以使用多个网络接口将这些平面相互隔离（但对你作为开发者来说，这应该是完全透明的）。这个模型在其他协调器中也存在，例如
    Kubernetes（简化为**角色节点**）。不同的角色将用于定义集群内节点的工作。Docker Swarm 与其他协调器的主要区别在于，这些角色可以轻松地在节点之间互换；因此，控制/管理平面节点只需一个命令即可转换为工作负载就绪的节点。Docker
    Swarm 使用**传输层安全性**（**TLS**）加密网络来安全地管理所有控制平面通信。内部**证书授权**（**CA**）及其证书将由 Docker
    Swarm 完全管理。
- en: Important note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Most container orchestration platforms will define **master nodes** as the nodes
    used to manage the platform, while **worker nodes** will finally execute all the
    workloads. These roles can also be shared and master nodes can execute some specific
    tasks. Docker Swarm allows us to completely change a node’s role with the command
    line without having to reinstall or recreate the node in the cluster.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数容器编排平台将定义**主节点**为用于管理平台的节点，而**工作节点**最终将执行所有工作负载。这些角色也可以共享，主节点可以执行一些特定任务。Docker
    Swarm 允许我们通过命令行完全更改节点的角色，而无需重新安装或重新创建节点。
- en: We will use the concept of a **service** to define the workloads in our cluster.
    The services have different properties to modify and manage how traffic will be
    delivered to our applications’ workloads. We will define the number of **replicas**
    for a service to be considered alive. The orchestrator will be in charge of making
    sure this number of replicas is always running. With this in mind, to scale a
    service up or down, we will just modify the number of replicas required to be
    considered healthy. When a cluster node goes down, Docker Swarm will schedule
    its tasks on other available hosts.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**服务**的概念来定义集群中的工作负载。服务具有不同的属性，用于修改和管理流量如何传递到应用程序的工作负载。我们将定义**副本**的数量，以确保服务被认为是活跃的。协调器将负责确保此数量的副本始终在运行。考虑到这一点，要扩展或缩减服务，我们只需修改认为健康所需的副本数。当集群节点发生故障时，Docker
    Swarm 会将任务调度到其他可用主机上。
- en: Applications that use many different container-based components will require
    multiple services to run, which makes it important to define communications between
    them. Docker Swarm will manage both the workload states and the networking layer
    (**overlay networks**). Encryption can also be enabled for service communications.
    To ensure that all service replicas are reachable, Docker Swarm manages an internal
    DNS and load-balances service requests among all healthy replicas.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用许多不同容器化组件的应用程序将需要多个服务才能运行，这使得定义它们之间的通信变得至关重要。Docker Swarm 将同时管理工作负载状态和网络层（**覆盖网络**）。还可以为服务通信启用加密。为了确保所有服务副本都可访问，Docker
    Swarm 会管理一个内部 DNS 并在所有健康副本之间进行负载均衡服务请求。
- en: The cluster will also manage the application’s services’ rolling upgrades any
    time a change is made to any of the components. Docker Swarm provides different
    types of deployments for specific needs. This feature allows us to execute maintenance
    tasks such as updates by simply replacing or degrading a service, avoiding any
    possible outages.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 集群还将管理应用程序服务的滚动升级，每当组件发生变化时，Docker Swarm 提供了针对特定需求的不同部署方式。此功能使我们能够通过简单地替换或降级服务来执行维护任务（如更新），避免任何可能的停机。
- en: 'We can summarize all of Docker Swarm features in the following points:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下几点总结 Docker Swarm 的所有功能：
- en: Docker Swarm is a built-in Docker container runtime and no additional software
    is required to deploy a container orchestrator cluster.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Swarm 是内置的 Docker 容器运行时，无需额外软件即可部署容器编排集群。
- en: A control plane, a management plane, and a data plane are deployed to supervise
    cluster states, manage all tasks, and execute our applications’ processes, respectively.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个控制平面、一个管理平面和一个数据平面被部署来分别监督集群状态、管理所有任务，并执行我们应用程序的进程。
- en: Cluster nodes can be part of the **control and management planes** (with a manager
    role), simply execute assigned workloads (with a worker or compute role), or have
    both roles. We can easily change a node’s role from manager to worker with the
    Docker client command line.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群节点可以是**控制和管理平面**的一部分（具有管理角色），仅执行分配的工作负载（具有工作者或计算角色），或同时具备这两种角色。我们可以通过 Docker
    客户端命令行轻松地将节点的角色从管理者更改为工作者。
- en: An application’s workloads are defined as services, represented by a number
    of healthy replicas. The orchestrator will automatically oversee the execution
    of a reconciliation process when any replica fails to meet the service’s requirements.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个应用程序的工作负载被定义为服务，通过若干健康的副本来表示。当任何副本未能满足服务的要求时，编排器将自动监督执行一个调节过程。
- en: All the cluster control plane and service communications (overlay networks)
    are managed by Docker Swarm, providing security by default with TLS in the control
    plane and with encryption features for services.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有集群的控制平面和服务通信（覆盖网络）由 Docker Swarm 管理，默认通过 TLS 提供控制平面的安全性，并为服务提供加密功能。
- en: Docker Swarm provides internal service discovery and homogeneous load balancing
    between all service replicas. We define how service replicas will be updated when
    we change any content or workload features, and Docker Swarm manages these updates.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Swarm 提供了内部服务发现和在所有服务副本之间的同质负载均衡。我们定义了在更改任何内容或工作负载特性时，服务副本将如何进行更新，而 Docker
    Swarm 会管理这些更新。
- en: Now we can advance in this section and learn how to deploy a Docker Swarm cluster
    and its architecture. You as a developer can apply your own knowledge to decide
    which cluster features and resources will help you run your applications with
    supervision from this orchestrator.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续本节内容，学习如何部署 Docker Swarm 集群及其架构。作为开发者，你可以运用自己的知识，决定哪些集群特性和资源将帮助你在该编排器的监督下运行应用程序。
- en: Docker Swarm manager nodes
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker Swarm 管理节点
- en: As mentioned earlier in this section, the control plane is provided by a set
    of hosts. These hosts are known as **manager nodes** in Swarm. These nodes in
    the cluster are critical for delivering all the control plane’s features. They
    all manage the Docker Swarm cluster environment. An internal key-value database
    is used to maintain the metadata of all the objects created and managed in the
    cluster.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节前面所述，控制平面由一组主机提供。这些主机在 Swarm 中被称为**管理节点**。这些集群中的节点对于提供所有控制平面的功能至关重要。它们都管理
    Docker Swarm 集群环境。一个内部的键值数据库用于维护所有在集群中创建和管理的对象的元数据。
- en: To provide high availability to your cluster, we deploy more than one manager
    node and we will share this key-value store to prevent a failure if a manager
    goes down. One of the manager nodes acts as the leader and writes all the objects’
    changes to its data store. The other managers will replicate this data into their
    own databases. The good thing here is that all this is managed internally by Docker
    Swarm. It implements the **Raft consensus algorithm** to manage and store all
    the cluster states. This ensures information distribution across multiple managers
    equally.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为集群提供高可用性，我们部署了多个管理节点，并将共享该键值存储，以防某个管理节点发生故障。一个管理节点充当领导者，负责将所有对象的更改写入其数据存储中。其他管理节点将把这些数据复制到它们自己的数据库中。好处是，所有这些都是由
    Docker Swarm 内部管理的。它实现了**Raft 共识算法**来管理和存储所有集群状态。这确保了信息在多个管理节点之间的均匀分配。
- en: The first node created in a Docker Swarm cluster automatically becomes the cluster
    leader and an election process is always triggered when the leader fails. All
    healthy manager nodes vote for a new leader internally; hence, a consensus must
    be reached before electing a new one. This means that we need at least *N/2+1*
    healthy managers to elect a new leader. We need to deploy an odd number of manager
    nodes and they all maintain the cluster’s health, serve the Docker Swarm HTTP
    API, and schedule workloads on healthy, available compute nodes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker Swarm 集群中，第一个创建的节点自动成为集群的领导节点，并且每当领导节点失败时，都会触发选举过程。所有健康的管理节点会在内部投票选举新的领导节点；因此，在选举新的领导节点之前，必须达成共识。这意味着我们至少需要*N/2+1*个健康的管理节点才能选举出新的领导节点。我们需要部署奇数个管理节点，并且这些节点会维护集群的健康状态，提供
    Docker Swarm HTTP API，并在健康的、可用的计算节点上调度工作负载。
- en: All the communications between manager and worker nodes are encrypted by using
    TLS (mutual TLS) by default. We don’t need to manage any of this encryption; an
    internal CA is deployed and servers’ certificates are rotated automatically.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有管理节点与工作节点之间的通信都会通过 TLS（相互 TLS）加密。我们无需管理任何加密过程；内部的 CA 会被部署，且服务器证书会自动轮换。
- en: Now that we understand how the cluster is managed, let’s review how applications
    are executed in the compute nodes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了集群是如何管理的，让我们来回顾一下应用程序如何在计算节点上执行。
- en: Docker Swarm worker nodes
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker Swarm 工作节点
- en: The leader of the manager nodes reviews the status of the platform and decides
    where to run a new task. All nodes report their statuses and loads to help the
    leader decide what the best location for executing the service replicas is. Worker
    nodes talk with manager nodes to inform them about the status of their running
    containers, and this information reaches the leader node.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 管理节点的领导者会查看平台的状态，并决定在哪里运行新的任务。所有节点都会报告其状态和负载，以帮助领导者决定执行服务副本的最佳位置。工作节点与管理节点通信，向其报告正在运行的容器的状态，这些信息会传递到领导节点。
- en: Worker nodes will just execute containers; they never participate in any scheduling
    decisions and they are part of the data plane, where all services’ internal communications
    are managed. These communications (overlay networks) are based on UDP VXLAN tunneling
    and they can be encrypted, although this isn’t enabled by default since some overhead
    is expected.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 工作节点只会执行容器；它们永远不会参与任何调度决策，并且它们是数据平面的一部分，所有服务的内部通信都在此管理。这些通信（覆盖网络）基于 UDP VXLAN
    隧道，并且可以加密，尽管默认情况下没有启用加密，因为加密会带来一些额外的开销。
- en: Important note
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: It is important to know that Docker Swarm manager nodes also have the worker
    role. This means that by default, any workload can run either on a manager node
    or a worker node. We will use additional mechanisms, such as workload locations,
    to avoid the execution of an application’s containers on manager nodes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 需要知道的是，Docker Swarm 的管理节点也具有工作节点的角色。这意味着默认情况下，任何工作负载都可以在管理节点或工作节点上运行。我们将使用额外的机制，如工作负载位置，来避免在管理节点上执行应用程序的容器。
- en: We can continue now and learn how to create a simple cluster.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续并学习如何创建一个简单的集群。
- en: Creating a Docker Swarm cluster
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Docker Swarm 集群
- en: Docker Swarm’s features are completely embedded into the Docker container runtime;
    hence, we don’t need any additional binaries to create a cluster.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Swarm 的功能完全嵌入在 Docker 容器运行时中，因此我们无需额外的二进制文件来创建集群。
- en: To create a Docker Swarm cluster, we will start by initializing it. We can choose
    any host interface for creating the cluster, and by default, the first one available
    will be used if none is selected. We will execute `docker swarm init` in a cluster
    node and this will become the leader. It is important to understand that we can
    have a fully functional cluster with just one node (leader), although we will
    not be able to provide high availability to our applications in this case. By
    default, any manager node, including the leader, will be able to run any application’s
    workloads.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 Docker Swarm 集群，我们将从初始化开始。我们可以选择任何主机接口来创建集群，如果没有选择，默认会使用第一个可用的接口。我们将在集群节点上执行`docker
    swarm init`命令，执行该命令的节点将成为领导节点。重要的是要理解，即使只有一个节点（领导节点），我们也能拥有一个完全功能的集群，尽管在这种情况下，我们无法为应用程序提供高可用性。默认情况下，任何管理节点，包括领导节点，都可以运行任何应用程序的工作负载。
- en: 'Once a Docker Swarm cluster is created, the Docker container runtime starts
    to work in **swarm mode**. At this point, some new Docker objects become available,
    which may make it interesting for you as a developer to deploy your own cluster:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了 Docker Swarm 集群，Docker 容器运行时将开始以**swarm 模式**工作。此时，一些新的 Docker 对象将变得可用，这对你作为开发人员来说，可能会让你更感兴趣地部署自己的集群：
- en: '**Swarm**: This object represents the cluster itself, with its own properties.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Swarm**：该对象代表集群本身，具有其独特的属性。'
- en: '**Nodes**: Each node within the cluster is represented by a **node object**,
    no matter whether it’s a leader, manager, or worker node. It can be very useful
    to add some labels to each node to help the internal scheduler allocate workloads
    to specific nodes (remember that all nodes can run any workload).'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点**：集群中的每个节点都由一个**节点对象**表示，无论它是领导者、管理节点还是工作节点。为每个节点添加一些标签非常有用，可以帮助内部调度器将工作负载分配到特定节点（请记住，所有节点都可以运行任何工作负载）。'
- en: '**Services**: The service represents the minimal workload scheduling unit.
    We will create a service for each application’s component, even if it just runs
    a single container. We will never run standalone containers in a Docker Swarm
    cluster, as these containers will not be managed by the orchestrator.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**：服务代表最小的工作负载调度单元。我们将为每个应用组件创建一个服务，即使它只运行一个单独的容器。我们绝不会在 Docker Swarm 集群中运行独立的容器，因为这些容器将不会由调度器进行管理。'
- en: '**Secrets**: These objects allow us to securely store all kinds of sensitive
    data (up to a maximum of 500 KB). Secrets will be mounted and used inside service
    containers and the cluster will manage and store their content.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机密**：这些对象允许我们安全地存储各种敏感数据（最大可达 500 KB）。机密将在服务容器中挂载并使用，集群将管理并存储其内容。'
- en: '**Configs**: Config objects will work like secrets, but they are stored in
    clear text. It is important to understand that configs and secrets are spread
    cluster-wide, which is critical, as containers will run in different hosts.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**：配置对象的作用类似于机密，但它们以明文形式存储。需要理解的是，配置和机密在集群中是分布式的，这一点非常重要，因为容器将运行在不同的主机上。'
- en: '**Stacks**: These are a new type of object used to deploy applications in Docker
    Swarm. We will use the Compose YAML file syntax to describe all the application’s
    components and their storage and networking configurations.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆栈**：这是一种新类型的对象，用于在 Docker Swarm 中部署应用程序。我们将使用 Compose YAML 文件语法来描述所有应用组件及其存储和网络配置。'
- en: Important note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The Docker Swarm cluster platform does not require as many resources as Kubernetes;
    hence, it is possible to deploy a three-node cluster on your laptop for testing.
    You will be able to verify how your applications work and maintain the service
    level when some of the application’s components fail or a cluster node goes completely
    offline. We use a standalone Docker Swarm cluster in order to use special objects
    such as **secrets** or **configs**.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Swarm 集群平台不需要像 Kubernetes 那样消耗大量资源；因此，可以在你的笔记本电脑上部署一个三节点集群进行测试。你将能够验证应用程序的运行方式，并在某些应用组件失败或集群节点完全离线时保持服务级别。我们使用独立的
    Docker Swarm 集群，以便使用特殊对象，如**机密**或**配置**。
- en: 'As we mentioned before in this section, we can just create a Docker Swarm cluster
    by executing `docker swarm init`, but many arguments can modify the default behavior.
    We will review a few of the most important ones just to let you know how isolated
    and secure a cluster can be:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节之前提到的，我们可以通过执行 `docker swarm init` 来创建一个 Docker Swarm 集群，但许多参数可以修改默认行为。我们将回顾一些最重要的参数，以让你了解集群的隔离性和安全性：
- en: '`--advertise-addr`: We can define the interface that will be used to initiate
    the cluster with this. All other nodes will use this IP address to join the recently
    created cluster. By default, the first interface will be used. This option will
    allow us to set which interface will be used to announce the control plane.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--advertise-addr`：我们可以使用此选项定义用于启动集群的接口。所有其他节点将使用此 IP 地址加入刚创建的集群。默认情况下，将使用第一个接口。此选项将允许我们设置用于宣布控制平面的接口。'
- en: '`--data-path-addr` and `--data-path-port`: We can isolate the data plane for
    the applications by setting a host’s specific interface IP address and port using
    these arguments. Traffic can be encrypted, and this will be completely transparent
    to your applications. Docker Swarm will manage this communication; some overhead
    may be expected due to the encryption/decryption processes.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--data-path-addr` 和 `--data-path-port`：我们可以通过使用这些参数设置主机特定接口的 IP 地址和端口，来为应用程序隔离数据平面。流量可以加密，这对您的应用程序是完全透明的。Docker
    Swarm 将管理此通信；由于加密/解密过程，可能会有一些开销。'
- en: '`--listen-addr`: By default, the Docker Swarm API will be listening on all
    host interfaces, but we can secure the API by answering on a defined interface.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--listen-addr`：默认情况下，Docker Swarm API 将监听所有主机接口，但我们可以通过定义的接口来安全地回答 API。'
- en: '`--autolock`: Docker Swarm will store all its data under `/var/lib/docker/swarm`
    (by default, depending on your runtime root data path). This directory contains
    the CA, used for creating all the nodes’ certificates, and the snapshots automatically
    created by Docker Swarm to preserve the data in case of failure. This information
    must be secure, and the `--autolock` option allows us to lock the content until
    a passphrase is provided.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--autolock`：Docker Swarm 将存储所有数据在 `/var/lib/docker/swarm` 下（默认情况下，取决于您的运行时根数据路径）。此目录包含
    CA，用于创建所有节点证书，以及 Docker Swarm 自动创建的快照，以在发生故障时保留数据。此信息必须是安全的，`--autolock` 选项允许我们锁定内容，直到提供密码为止。'
- en: Important note
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Locking Docker Swarm content may affect your cluster’s high availability. This
    is because every time the Docker runtime is restarted, you must use an unlock
    action to retrieve the directory’s content, and you will be asked for the autolock
    passphrase. Hence, an automatic restart of components is broken since manual intervention
    is required.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定 Docker Swarm 内容可能会影响集群的高可用性。这是因为每次重启 Docker 运行时时，您必须使用解锁操作来检索目录的内容，并且您将被要求输入自动锁定的密码。因此，由于需要手动干预，组件的自动重启被打破了。
- en: 'When a Docker swarm is initialized, a couple of cluster tokens are created.
    These tokens should be used to join additional nodes to the cluster. One token
    should be used to join new manager nodes and the other one should only be used
    to integrate worker nodes. Remember that the node’s roles can be changed later
    if a manager node fails, for example. The following code shows how the tokens
    are presented:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当初始化 Docker 集群时，会创建一对集群令牌。这些令牌应该用于将额外的节点加入到集群中。一个令牌用于加入新的管理节点，另一个令牌仅用于集成工作节点。请记住，如果管理节点失败，可以随时更改节点的角色。以下代码展示了如何呈现这些令牌：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To add a worker to this swarm, you can run the following command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要将工作节点添加到此集群中，可以运行以下命令：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To add a manager to this swarm, run `docker swarm join-token manager` and follow
    the instructions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要将管理器添加到此集群中，请运行 `docker swarm join-token manager` 并按照提示操作。
- en: We use `docker swarm join` followed by `--token` and the appropriate token for
    a new manager or worker node. This token will be shown at cluster initialization,
    but it can be retrieved whenever needed by simply using `docker swarm join-token`.
    This action can also be used to rotate the current token (automatic rotation will
    be triggered by default every 90 days).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `docker swarm join`，后跟 `--token` 和适用于新管理器或工作节点的适当令牌。此令牌将显示在集群初始化时，但可以随时通过简单使用
    `docker swarm join-token` 来检索。默认情况下，每90天会触发令牌的自动轮换。
- en: Docker Swarm nodes can leave the cluster whenever it is needed by executing
    `docker swarm leave`. It is important to understand that losing one manager may
    leave your cluster in danger. Be careful with the manager nodes, especially when
    you change their role to a worker node or when you remove them from a cluster.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Swarm 节点可以通过执行 `docker swarm leave` 随时离开集群。重要的是要理解，失去一个管理节点可能会使您的集群处于危险之中。在更改其角色为工作节点或将其从集群中删除时，请特别小心管理节点。
- en: Important note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Some Swarm object properties, such as autolock or certificate expiration, can
    be modified by using `docker` `swarm update`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `docker swarm update` 可以修改一些 Swarm 对象属性，例如自动锁定或证书过期。
- en: In the next section, we will learn what is required to provide high availability
    to a Docker Swarm cluster and the requirements for our applications.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解为 Docker Swarm 集群提供高可用性所需的内容及我们应用程序的要求。
- en: Providing high availability with Docker Swarm
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker Swarm 提供高可用性
- en: The Docker Swarm orchestrator will provide out-of-the-box **high availability**
    if we use an odd number of manager nodes. The **Raft protocol** used to manage
    the internal database requires an odd number of nodes to maintain it healthily.
    Having said that, the minimum number of healthy managers for the cluster to be
    fully functional is *N/2+1*, as discussed earlier in this chapter. However, no
    matter how many managers are working, your application’s functionality may not
    be impacted. Worker nodes will continue working even when you don’t have the minimum
    number of required manager nodes. An application’s services will continue running
    unless a container fails. In this situation, if the managers aren’t functional,
    your containers will not be managed by the cluster and thus your application will
    be impacted. It is important to understand this because it is the key to preparing
    your clusters for these situations.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用奇数个管理节点，Docker Swarm 调度器将提供开箱即用的**高可用性**。用于管理内部数据库的**Raft 协议**要求节点数量为奇数，以保持其健康。如前所述，本章讨论的完全功能集群的最小健康管理器数量为*N/2+1*。然而，无论有多少个管理器在工作，您的应用程序功能可能不会受到影响。即使没有满足所需的最小管理节点数量，工作节点也会继续工作。应用程序的服务将继续运行，除非容器发生故障。在这种情况下，如果管理器不可用，您的容器将无法被集群管理，因此应用程序将受到影响。理解这一点非常重要，因为它是为这些情况做好集群准备的关键。
- en: Although your cluster runs with fully high availability, you must prepare your
    applications. By default, resilience is provided. This means that if a running
    container fails, a new one will be created to replace it, but this will probably
    impact your application even if you run a fully stateless service.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您的集群实现了完全的高可用性，但您仍然需要为您的应用程序做好准备。默认情况下，系统会提供弹性支持。这意味着，如果一个正在运行的容器发生故障，将会创建一个新的容器来替代它，但即使您运行的是完全无状态的服务，这仍然可能会影响到您的应用程序。
- en: Services integrate **tasks** or **instances**, which finally represent a container.
    Hence, we must set the number of replicas (or tasks) required for a service to
    be considered healthy. The Docker container runtime running the workload will
    check whether the container is healthy by executing the health checks included
    within the container image or the ones defined at execution time (written using
    the Compose YAML file format in which the service is defined).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 服务集成了**任务**或**实例**，它们最终代表一个容器。因此，我们必须设置服务所需的副本数（或任务数），以确保服务被认为是健康的。运行工作负载的 Docker
    容器运行时将通过执行容器镜像中包含的健康检查或执行时定义的健康检查（使用 Compose YAML 文件格式编写的服务定义）来检查容器是否健康。
- en: Definitely, the number of **replicas** will impact the outage of your service
    when things go wrong. Therefore, you should prepare your applications for this
    situation by executing, for example, more than one replica for your services.
    Of course, this requires that you think of your application’s components’ logic
    from the very beginning. For example, even if your application is completely stateless
    and uses a stateful service, such as a database, you will probably have to think
    about how to provide high availability or at least fault tolerance to this component.
    Databases can run inside containers but their logic may need some tweaks. Sometimes,
    you can just replace your SQL database with a NoSQL database distributed solution.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，**副本**的数量会在出现故障时影响服务的中断。因此，您应该通过执行多个副本来为这种情况做好应用程序的准备，例如，确保服务有超过一个副本。当然，这要求您从一开始就考虑应用程序组件的逻辑。例如，即使您的应用程序完全无状态，并使用有状态服务（如数据库），您可能也需要考虑如何为该组件提供高可用性或至少容错性。数据库可以在容器内运行，但其逻辑可能需要做一些调整。有时，您可以将
    SQL 数据库替换为分布式的 NoSQL 数据库解决方案。
- en: In the previous application example, with a database component, we didn’t take
    into account the problem of managing the stateful data using volumes (even if
    using a distributed solution), but every stateful application should be able to
    move from one cluster node to another. This also affects the associated volumes
    that must be attached to containers wherever they run, no matter which node in
    the cluster receives a task. We can use remote storage filesystem solutions, such
    as NFS, or sync filesystems or folders between nodes. You as a developer don’t
    have to manage the infrastructure, but you must prepare your applications, for
    example, by verifying the existence of certain files. You should also ask yourself
    what will happen if more than one replica tries to access your data. This situation
    will definitely corrupt a database, for example. Other orchestrators, such as
    Kubernetes, provide more interesting solutions for these situations, as we will
    learn in [*Chapter 8*](B19845_08.xhtml#_idTextAnchor170), *Deploying Applications
    with the* *Kubernetes Orchestrator*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的应用示例中，包含了数据库组件，但我们没有考虑使用卷管理有状态数据的问题（即使是使用分布式解决方案），但每个有状态的应用应该能够从一个集群节点迁移到另一个节点。这也影响到必须附加到容器上的相关卷，无论它们运行在哪个节点，只要节点接收到任务。我们可以使用远程存储文件系统解决方案，如
    NFS，或在节点之间同步文件系统或文件夹。作为开发者，你不必管理基础设施，但你必须准备好你的应用程序，例如，验证某些文件的存在。你还应该问自己，如果多个副本尝试访问你的数据，会发生什么情况？这种情况肯定会破坏数据库，例如。其他调度器，如
    Kubernetes，为这些情况提供了更有趣的解决方案，我们将在 [*第 8 章*](B19845_08.xhtml#_idTextAnchor170) 中学习，*使用
    Kubernetes 调度器部署应用程序*。
- en: Docker Swarm nodes can be **promoted** from the worker role to the manager role,
    and vice versa, a manager can be **demoted** to a worker. We can also **drain**
    and **pause** nodes, which allows us to completely move all containers from a
    node to another available worker, and disable scheduling in the nodes defined,
    respectively. All these actions are part of infrastructure management. You should
    at least verify how your application will behave when a drain action is triggered
    and your containers stop on one node and start on another. How will your application’s
    components manage such circumstances? How will this affect component containers
    that consumed some of the affected services? This is something you have to solve
    in your application’s logic and code as a developer.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Swarm 节点可以从工作节点提升为管理节点，反之亦然，管理节点可以被**降级**为工作节点。我们还可以对节点进行**排空**和**暂停**，这可以让我们将所有容器完全从一个节点迁移到另一个可用的工作节点，并分别禁用在定义的节点中调度。所有这些操作都是基础设施管理的一部分。你至少应该验证当触发排空操作时，应用程序会如何表现，当你的容器从一个节点停止并在另一个节点启动时，应用的组件会如何管理这种情况？这会如何影响那些使用了一些受影响服务的组件容器？作为开发者，这是你必须在应用逻辑和代码中解决的问题。
- en: Next, let’s learn how to schedule our applications in Docker Swarm.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们学习如何在 Docker Swarm 中调度我们的应用。
- en: Creating tasks and services for your applications
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为你的应用创建任务和服务
- en: The first thing you should know is that we will never schedule containers on
    a Docker Swarm cluster. We will always run **services**, which are the minimal
    deployment units in a Docker Swarm cluster.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先你应该知道的是，我们永远不会在 Docker Swarm 集群上调度容器。我们始终会运行**服务**，它是 Docker Swarm 集群中最小的部署单元。
- en: Each service is defined by a number of replicas, known in Docker Swarm as **tasks**.
    And finally, each task will run one container.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务由若干个副本定义，在 Docker Swarm 中称为**任务**。最后，每个任务将运行一个容器。
- en: Important note
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Docker Swarm is based on Moby’s **SwarmKit** project, which was designed to
    run any kind of task cluster-wide (virtual machines, for example). Docker created
    Docker Swarm by implementing SwarmKit in the orchestrator, but specifically for
    running containers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Swarm 基于 Moby 的**SwarmKit**项目，该项目旨在运行任何类型的任务集群（例如虚拟机）。Docker 通过在调度器中实现
    SwarmKit 创建了 Docker Swarm，但它特别用于运行容器。
- en: We will use a **declarative model** to schedule services in our Docker Swarm
    cluster by setting the desired state for our services. Docker Swarm will take
    care of their state continuously and take corrective measures in case of any failure
    to reconcile its state. For example, if the number of running replicas is not
    correct because one container has failed, Docker Swarm will create a new one to
    correct the service’s state.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**声明性模型**在我们的 Docker Swarm 集群中安排服务，通过设置我们服务的期望状态。Docker Swarm 将持续关注它们的状态，并在任何故障时采取纠正措施。例如，如果运行的副本数量不正确，因为一个容器已失败，Docker
    Swarm 将创建一个新的来纠正服务的状态。
- en: 'Let’s continue by creating a simple `webserver` service using an `nginx:alpine`
    container image:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建一个简单的`webserver`服务，使用`nginx:alpine`容器镜像：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have just defined a service’s name and the image to be used for the associated
    containers. By default, services will be created with one replica.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚定义了服务的名称以及要用于关联容器的镜像。默认情况下，服务将创建一个副本。
- en: 'We can verify the service’s state by simply executing `docker service ls` to
    list all the Docker Swarm services:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过简单执行`docker service ls`来验证服务的状态，以列出所有 Docker Swarm 服务：
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you may have noticed, a service ID is created (object ID) and we can use
    any of the actions learned about in [*Chapter 2*](B19845_02.xhtml#_idTextAnchor036)
    and [*Chapter 4*](B19845_04.xhtml#_idTextAnchor096) for listing, inspecting, and
    removing Docker objects.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能注意到的，创建了一个服务 ID（对象 ID），我们可以使用在[*第 2 章*](B19845_02.xhtml#_idTextAnchor036)和[*第
    4 章*](B19845_04.xhtml#_idTextAnchor096)中学到的任何操作，用于列出、检查和移除 Docker 对象。
- en: 'We can verify in which node the service’s containers are running by using `docker
    node ps`. This will list all the containers running in the cluster that are associated
    with services:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`docker node ps`来验证服务的容器运行在哪个节点。这将列出与服务相关联的运行在集群中的所有容器：
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this example, one container is running in the `docker-desktop` host (Docker
    Desktop environment). We didn’t specify a port for publishing our web server;
    hence, it will work completely internally and will be unreachable to users. Only
    one replica was deployed because the default value was used when we didn’t set
    anything else. Therefore, to create a real service, we will usually need to specify
    the following information:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，一个容器正在`docker-desktop`主机（Docker Desktop 环境）上运行。我们没有为发布我们的 Web 服务器指定端口；因此，它将完全在内部工作，并且对用户不可达。当我们没有设置其他任何内容时，只部署了一个副本，因为使用了默认值。因此，要创建一个真正的服务，通常需要指定以下信息：
- en: The repository from which the image should be downloaded
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要下载图像的存储库
- en: The number of healthy replicas/containers required by our service to be considered
    alive
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的服务需要的健康副本/容器数量以被视为处于活动状态
- en: The published port, if the service must be reachable externally
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果服务必须在外部可达，则发布的端口
- en: It is also important to mention that Docker Swarm services can be either replicated
    (by default, as we have seen in the previous example) or global (run on all cluster
    nodes).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 也很重要的是要提到，Docker Swarm 服务可以是复制的（默认情况下，如我们在前面的示例中看到的）或全局的（在所有集群节点上运行）。
- en: A **replicated service** will create a number of replicas, known as **tasks**,
    and each will create one container. You as a developer can prepare your application’s
    logic to run more than one replica per service to provide simple but useful high
    availability (this will help you lose half of your service in case of failure).
    This will reduce the impact in case of failure and really help with the upgrade
    processes when changes need to be introduced.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**复制的服务**将创建多个副本，称为**任务**，每个任务将创建一个容器。作为开发者，您可以准备您应用程序的逻辑以运行多个副本，从而提供简单但有用的高可用性（这将帮助您在发生故障时失去一半的服务）。这将减少故障的影响，并且在需要引入更改时真正有助于升级过程。'
- en: On the other hand, a **global service** will run one replica of your service
    in each cluster node. This is very powerful but may reduce the overall performance
    of your cluster if you can distribute your application’s load into different processes.
    This type of service is used to deploy monitoring and logging applications, and
    they work as agents, automatically distributed in all nodes at once. It is important
    to notice that Docker Swarm will schedule a task for each service on any node
    joined to the cluster. You may use global services when you need to run agent-like
    applications on your cluster.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**全局服务**将在每个集群节点上运行你的服务的一个副本。这非常强大，但如果你能够将应用程序的负载分布到不同的进程中，它可能会降低集群的整体性能。这种类型的服务用于部署监控和日志记录应用程序，它们作为代理，自动分布到所有节点上。需要注意的是，Docker
    Swarm 会在加入集群的任何节点上为每个服务调度一个任务。当你需要在集群上运行类似代理的应用程序时，可以使用全局服务。
- en: You as a developer should think about which service type suits your application
    best and use the `--mode` argument to create an appropriate Docker Swarm service.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，你应该考虑哪种服务类型最适合你的应用程序，并使用 `--mode` 参数创建适当的 Docker Swarm 服务。
- en: Important note
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You may think that it’s a good idea to run a distributed database (MongoDB or
    any simpler key-value store) or a queue management solution (such as RabbitMQ
    or Apache Kafka) as a global service to ensure its availability, but you have
    to take care of the final number of running containers. Global services do not
    guarantee an odd number of containers/processes and may break your application
    if you join new nodes to the cluster. Every time you join a new node, a new container
    is created as part of the global service.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为将分布式数据库（如 MongoDB 或任何简单的键值存储）或队列管理解决方案（如 RabbitMQ 或 Apache Kafka）作为全局服务运行，以确保其可用性是个好主意，但你必须注意正在运行的容器的最终数量。全局服务不保证容器/进程的奇数数量，如果你将新节点加入集群，它可能会破坏你的应用程序。每次加入新节点时，都会创建一个新的容器作为全局服务的一部分。
- en: 'We can use labels to define locations for certain services. They will affect
    all the replicas at the same time. For example, we can create a global service
    that should only run on nodes labeled as `web`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用标签来为某些服务定义位置。它们会同时影响所有副本。例如，我们可以创建一个只能在标记为 `web` 的节点上运行的全局服务：
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The Docker Desktop environment works like a one-node Docker Swarm cluster;
    hence, the global service should be running if the appropriate label, `web`, is
    present:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Desktop 环境类似于一个单节点 Docker Swarm 集群；因此，如果存在适当的标签 `web`，全局服务应该正在运行：
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s add the label to the only cluster node we have:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为唯一的集群节点添加标签：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Automatically, Docker Swarm detected the node label change and scheduled the
    global service container for us:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Swarm 自动检测到节点标签的变化，并为我们调度了全局服务容器：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see, Docker Swarm allows us to change the default location of any
    service. Let’s review some of the options available to place our application’s
    tasks in specific nodes or pools of nodes:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Docker Swarm 允许我们更改任何服务的默认位置。让我们回顾一些可用的选项，以便将应用程序的任务放置在特定的节点或节点池中：
- en: '`--constraint`: This option fixes where to run our service’s containers. It
    uses labels, as we saw in the previous example. We can verify the placement requirements
    of a service by using `docker` `service inspect`:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--constraint`：此选项指定我们的服务容器应该运行的位置。它使用标签，就像我们在前面的例子中看到的那样。我们可以通过使用 `docker`
    `service inspect` 来验证服务的放置要求：'
- en: '[PRE9]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`--replicas-max-per-node`: Another way of setting the location under certain
    circumstances will be to avoid more than a specific number of replicas per cluster
    node. This will ensure, for example, that replicas will not compete for resources
    in the same host.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--replicas-max-per-node`：在某些情况下，设置位置的另一种方式是避免每个集群节点上的副本数量超过特定值。这将确保例如副本不会在同一主机上争夺资源。'
- en: By using placement constraints or preferred locations, you can ensure, for example,
    that your application will run in certain nodes with GPUs or faster disks.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用放置约束或首选位置，你可以确保你的应用程序运行在具有 GPU 或更快磁盘的特定节点上。
- en: Important note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You as a developer should design your application to run almost anywhere. You
    will need to ask your Docker Swarm administrators for any location labeling or
    preferences and use them in your deployments. These kinds of infrastructure features
    may impact how your applications run and you must be aware of them.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，你应该设计你的应用程序以便几乎可以在任何地方运行。你需要向 Docker Swarm 管理员询问任何位置标签或偏好设置，并在部署中使用它们。这些基础设施特性可能会影响你的应用程序运行方式，因此你必须了解它们。
- en: We can also execute `Completed` and no other container will be executed. Docker
    Swarm allows the execution of both global or replicated jobs, the `global-job`
    and `replicated-job` service types, respectively.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以执行 `Completed`，并且不会执行其他容器。Docker Swarm 允许执行全局任务或副本任务，分别为 `global-job` 和
    `replicated-job` 服务类型。
- en: Docker Swarm services can be updated at any time, for example, to change the
    container image or other properties, such as their scheduling location within
    the cluster nodes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Swarm 服务可以随时更新，例如更改容器镜像或其他属性，比如它们在集群节点中的调度位置。
- en: 'To update any available service’s property, we will use `docker service update`.
    In the following example, we will just update the number of replicas of the service:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新任何可用服务的属性，我们将使用 `docker service update`。在以下示例中，我们只会更新服务的副本数量：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now that we have two replicas or instances running for the `webservice` service,
    we can verify how Docker Swarm will check and manage any failure:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为 `webservice` 服务运行了两个副本或实例，我们可以验证 Docker Swarm 如何检查和管理任何故障：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Using the `docker` runtime client, we can list all the containers running (this
    works because we are using just one node cluster, the `docker-desktop` host):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker` 运行时客户端，我们可以列出所有正在运行的容器（因为我们只使用一个节点的集群，`docker-desktop` 主机，所以可以这样操作）：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can kill one of the `webserver` service’s containers and verify that Docker
    Swarm will create a new container to reconcile the service’s status:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以终止一个 `webserver` 服务的容器，并验证 Docker Swarm 会创建一个新的容器来恢复服务的状态：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A second after the failure is detected, a new container runs:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在检测到故障后的**1秒钟**，将会运行一个新的容器：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can verify that Docker Swarm managed the container issue:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以验证 Docker Swarm 如何管理容器问题：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding snippet shows a short history with the failed container ID and
    the new one created to maintain the health of the service.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码片段展示了一个简短的历史记录，包含了失败的容器 ID 和为保持服务健康而创建的新容器。
- en: 'As you may have noticed, the containers created within Docker Swarm have the
    prefix of the service associated, followed by the instance number. These help
    us identify which services may be impacted when we have to execute maintenance
    tasks on a node. We can list current containers to view how services’ tasks are
    executed:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，Docker Swarm 中创建的容器都有与服务相关的前缀，后面跟着实例编号。这些有助于我们在需要执行节点维护任务时，识别哪些服务可能会受到影响。我们可以列出当前的容器，查看服务的任务是如何执行的：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You must remember that we are running containers; hence, services can inherit
    all the arguments we used with containers (see [*Chapter 4*](B19845_04.xhtml#_idTextAnchor096),
    *Running Docker Containers*). One interesting point is that we can include some
    Docker Swarm internal keys using the Go template format as variables for our application
    deployments:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须记住我们正在运行容器；因此，服务可以继承我们与容器一起使用的所有参数（参见 [*第4章*](B19845_04.xhtml#_idTextAnchor096)，*运行
    Docker 容器*）。一个有趣的点是，我们可以使用 Go 模板格式作为变量，将一些 Docker Swarm 内部键值包括进来，应用到我们的部署中：
- en: '`.Service.ID`, `.Service.Name`, and `.Service.Labels` keys. Using these service
    labels may be interesting for identifying or including some information in your
    application.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.Service.ID`、`.Service.Name` 和 `.Service.Labels` 键。使用这些服务标签可能会很有趣，特别是当你想在应用程序中标识或包含一些信息时。'
- en: '`.Node.ID` and `.Node.Hostname`.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.Node.ID` 和 `.Node.Hostname`。'
- en: '`.Task.ID`, `.Task.Name`, and `.Task.Slot`, which may be interesting if you
    want to manage the behavior of your container within some application’s components.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.Task.ID`、`.Task.Name` 和 `.Task.Slot`，如果你想在某些应用程序的组件中管理容器的行为，这些可能会很有用。'
- en: 'Let’s see a quick example of how we can use such variables:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个快速示例，看看如何使用这些变量：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we update our service with a new hostname:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们用一个新的主机名更新我们的服务：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can now verify that the container’s hostname has changed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以验证容器的主机名已经发生了变化。
- en: Let’s continue with the definition of a complete application, as we already
    did with Compose in standalone environments, but this time running cluster-wide.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续定义一个完整的应用程序，就像我们在独立环境中使用 Compose 时那样，只不过这次是跨集群运行。
- en: A review of stacks and other Docker Swarm resources
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查堆栈和其他 Docker Swarm 资源
- en: Docker Swarm allows us to deploy applications with multiple services by running
    stacks. This new object defines, in a Compose YAML file, the structure, components,
    communications, and interactions with external resources of your applications.
    Therefore, we will use **infrastructure as code** (**IaC**) to deploy our applications
    on top of the Docker Swarm orchestrator.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Swarm允许我们通过运行堆栈来部署具有多个服务的应用程序。这个新对象在Compose YAML文件中定义了应用程序的结构、组件、通信和与外部资源的交互。因此，我们将使用**基础设施即代码**（**IaC**）在Docker
    Swarm编排器之上部署我们的应用程序。
- en: Important note
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Although we use a Compose YAML file, not all the `docker-compose` keys are available.
    For example, the `depends_on` key is not available for stacks because they don’t
    include any dependency declarations. That’s why it is so important to prepare
    your application’s logic in your code. Health checks will let you decide how to
    break some circuits when some components fail, but you should include status verifications
    on dependent components when, for example, they need some time to start. Docker
    Compose runs applications’ containers on standalone servers while Docker Swarm
    stacks deploy applications’ services (containers) cluster-wide.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们使用的是Compose YAML文件，但并非所有的`docker-compose`键都可用。例如，`depends_on`键在堆栈中不可用，因为它们不包含任何依赖声明。这就是为什么在代码中准备应用程序逻辑如此重要的原因。健康检查将让你决定在某些组件失败时如何断开某些电路，但你应该在依赖组件上包括状态验证，例如当它们需要一些时间来启动时。Docker
    Compose在独立服务器上运行应用程序的容器，而Docker Swarm堆栈则将应用程序的服务（容器）部署到整个集群中。
- en: 'In a stack YAML file, we will declare our application’s network, volumes, and
    configurations. We can use any Compose file with a few modifications. In fact,
    the Docker container runtime in swarm mode will inform you and fail if you use
    a forbidden key. Other keys, such as `depends_on`, are simply omitted when we
    use a `docker-compose` file with Docker Swarm. Here is an example using the Compose
    YAML file found in [*Chapter 5*](B19845_05.xhtml#_idTextAnchor118), *Creating
    Multi-Container Applications*. We will use `docker` `stack deploy`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在堆栈YAML文件中，我们将声明应用程序的网络、卷和配置。我们可以通过一些修改使用任何Compose文件。实际上，如果你使用了一个不允许的键，Docker
    Swarm模式下的Docker容器运行时会通知你并失败。其他键，例如`depends_on`，在使用Docker Swarm时的`docker-compose`文件中会被省略。这里是一个使用[*第5章*](B19845_05.xhtml#_idTextAnchor118)的Compose
    YAML文件的示例，*创建多容器应用程序*。我们将使用`docker` `stack deploy`：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, the container runtime informed us of an unsupported key, `Ignoring
    unsupported options: build`. You can use a Compose YAML file to build, push, and
    then use the container images within your application, but you must use a registry
    for your images. By using a registry, we can ensure that all container runtimes
    will get the image. You can download the images, save them as files, and copy
    them to all nodes, but this is not a reproducible process and it may cost some
    time and effort to synchronize all changes. It seems quite logical to use a registry
    to maintain all the images available to your clusters.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '如你所见，容器运行时通知我们一个不支持的键，`Ignoring unsupported options: build`。你可以使用Compose YAML文件来构建、推送，然后在应用程序中使用容器镜像，但你必须为你的镜像使用一个注册表。通过使用注册表，我们可以确保所有容器运行时都能获取到镜像。你可以下载镜像，将它们保存为文件，并将其复制到所有节点，但这不是一个可复现的过程，并且可能需要一些时间和精力来同步所有更改。使用注册表来维护所有可用镜像似乎是一个非常合理的做法。'
- en: 'We can now review the deployed stack and its services:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以查看已部署的堆栈及其服务：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice that the `REPLICAS` column shows `0/1` for all the services; this is
    because we are using a fake registry and repository. The container runtime will
    not pull images in this example because we are using an internal registry that
    doesn’t exist, but this still shows how to deploy a complete application. Working
    with registries may require the use of `--with-registry-auth` to apply certain
    authentications to our services. Credentials should be used to pull the images
    associated with each of your services if you are using private registries.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`REPLICAS`列显示所有服务为`0/1`；这是因为我们使用了一个虚拟的注册表和仓库。在这个示例中，容器运行时不会拉取镜像，因为我们使用的是一个不存在的内部注册表，但这仍然展示了如何部署一个完整的应用程序。与注册表交互可能需要使用`--with-registry-auth`来应用某些身份验证到我们的服务上。如果你使用的是私有注册表，应该使用凭证来拉取与每个服务关联的镜像。
- en: You will probably have also realized that all services have the stack’s name
    as a prefix, as we already learned about for projects and their services in [*Chapter
    5*](B19845_05.xhtml#_idTextAnchor118), *Creating* *Multi-Container Applications*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也已经意识到，所有服务的名称前缀都带有栈的名称，正如我们在[*第 5 章*](B19845_05.xhtml#_idTextAnchor118)《*创建多容器应用程序*》中学习的那样。
- en: 'Let’s now quickly review how configurations are managed cluster-wide. As we’d
    expect, running applications cluster-wide may require a lot of synchronization
    effort. Every time we create a service with some configuration or persistent data,
    we will need to ensure its availability on any host. Docker Swarm helps us by
    managing the synchronization of all configurations within the cluster. Docker
    Swarm provides us with two types of objects for managing configurations: secrets
    and configs. As we have already learned how secrets and configs work with Compose,
    we will just have a quick review since we will use them in this chapter’s labs.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们快速回顾一下集群范围内的配置管理。如我们所料，跨集群运行的应用程序可能需要大量的同步工作。每当我们创建一个带有某些配置或持久数据的服务时，都需要确保它在任何主机上都可用。Docker
    Swarm 通过管理集群内所有配置的同步帮助我们完成这一任务。Docker Swarm 提供了两种类型的对象来管理配置：机密和配置。由于我们已经学习了如何使用
    Compose 来处理机密和配置，这里将简要回顾一下，因为我们将在本章的实验中使用它们。
- en: Secrets
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机密
- en: '`tmpfs` on Linux hosts). This ensures that the information will be removed
    when the container dies. It may be considered volatile and therefore it is only
    available on running containers. By default, secrets are mounted as files in the
    form `/run/secrets/<SECRET_NAME>`, and they include the secret object’s content.
    This path can be changed, as well as the file permissions and ownership.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`tmpfs` 在 Linux 主机上）。这确保了容器终止时信息会被删除。它可以被视为易失性的，因此仅在运行中的容器中可用。默认情况下，机密作为文件挂载，路径为`/run/secrets/<SECRET_NAME>`，并包含机密对象的内容。该路径可以更改，文件权限和所有权也可以修改。'
- en: We can use secrets inside environment variables, which is fine because they
    are only visible inside containers. However, you can also use secrets to store
    a complete configuration file, even if not all its content must be secured. Secrets
    can only contain 500 KB of data; thus, you may need to split your configuration
    into different secrets if you think it may not be enough.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在环境变量中使用机密，这没问题，因为它们仅在容器内部可见。然而，你也可以使用机密来存储完整的配置文件，即使其中并非所有内容都需要加密。机密只能包含
    500 KB 的数据，因此，如果你认为不够，可能需要将配置拆分为不同的机密。
- en: Secrets can be created, listed, removed, inspected, and so on like any other
    Docker container object, but they can’t be updated.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 机密可以像其他 Docker 容器对象一样被创建、列出、删除、检查等，但不能被更新。
- en: Important note
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: As secrets are encrypted, `docker secret inspect` will show you their labels
    and other relevant information, but the data itself will not be visible. It is
    important to also understand that secrets can’t be updated, so they should be
    recreated if need be (removed and created again).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于机密是加密的，`docker secret inspect` 将显示它们的标签和其他相关信息，但数据本身是不可见的。需要理解的是，机密不能被更新，因此如果需要，应该重新创建它们（删除并重新创建）。
- en: Configs
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: '**Configs** are similar to secret objects, but they are not encrypted and can
    be updated. This makes them the perfect combination for easily reconfiguring your
    applications, but remember to always remove any sensitive information, such as
    connection strings where passwords are visible, tokens, and so on, that could
    be used by an attacker to exploit your application. Config objects are also stored
    in the Docker Swarm Raft Log database in clear text; therefore, an attacker with
    access to the Docker Swarm information can view them (remember that this information
    can be locked with a passphrase). These files can contain a maximum of 500 KB,
    but you can include even binary files.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**配置**类似于机密对象，但它们没有加密且可以更新。这使得它们成为轻松重新配置应用程序的完美选择，但请记住，始终删除任何敏感信息，例如包含密码可见的连接字符串、令牌等，这些信息可能被攻击者用来利用你的应用程序。配置对象也以明文形式存储在
    Docker Swarm Raft 日志数据库中；因此，攻击者如果能访问 Docker Swarm 信息，就可以查看它们（记住，这些信息可以通过密码保护）。这些文件的最大大小为
    500 KB，但你可以包括二进制文件。'
- en: Config objects will be mounted inside containers as if they were bind-mounted
    files, owned by the main process user and with read-all permissions. As with secrets,
    config-mounted file permissions and ownership can be changed depending on your
    own needs.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 配置对象将像绑定挂载的文件一样，挂载到容器内，归主进程用户所有，并具有所有读取权限。与密钥一样，配置挂载文件的权限和所有权可以根据自己的需求进行更改。
- en: In both cases, Docker Swarm takes care of syncing these objects cluster-wide
    without any additional action on our end.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，Docker Swarm 会在集群范围内同步这些对象，我们无需额外操作。
- en: Important note
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In both cases, you can decide the path at which secret or config files will
    be mounted and its owner and permissions. Please take care of the permissions
    you give to your files and ensure that only the minimum necessary permissions
    for reading the file are granted.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，你可以决定密钥或配置文件的挂载路径及其所有者和权限。请注意你赋予文件的权限，并确保仅授予读取文件所需的最小权限。
- en: We will now learn how our applications will be published internally and externally
    and how the application’s services will be announced cluster-wide.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将了解如何将我们的应用程序在内部和外部发布，以及应用程序的服务如何在集群范围内宣布。
- en: Networking and exposing applications with Docker Swarm
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker Swarm 进行网络连接和应用暴露
- en: We already learned how container runtimes provide network capabilities to our
    containers by setting network namespaces and virtual interfaces attached to the
    host’s bridge network interfaces. All these features and processes will also work
    with Docker Swarm but communication between hosts is also required, and this is
    where overlay networks come in.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了容器运行时如何通过设置网络命名空间和附加到主机桥接网络接口的虚拟接口，为容器提供网络功能。所有这些功能和过程在 Docker Swarm
    中也能正常工作，但主机之间的通信也是必需的，这正是 overlay 网络的作用。
- en: Understanding the Docker Swarm overlay network
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Docker Swarm 的 overlay 网络
- en: To manage all communications cluster-wide, a new network driver, **overlay**,
    will be available. The overlay network works by setting UDP VXLAN tunnels between
    all the cluster’s hosts. These communications can be encrypted with some overhead
    and Docker Swarm sets the routing layer for all containers. Docker Swarm only
    takes care of overlay networks while the container runtime will manage all other
    local scope networks.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理整个集群的通信，将提供一个新的网络驱动程序**overlay**。overlay 网络通过在所有集群主机之间设置 UDP VXLAN 隧道来工作。这些通信可以加密，但会有一些额外的开销，Docker
    Swarm 会为所有容器设置路由层。Docker Swarm 只负责 overlay 网络，而容器运行时将管理所有其他本地范围的网络。
- en: Once we have initialized a Docker Swarm cluster, two new networks will appear,
    `docker_gwbridge` (bridge) and `ingress` (overlay), with two different functions.
    The first one is used to interconnect all container runtimes, while the second
    one is used to manage all service traffic. By default, all services will be attached
    to the `ingress` network if no additional network is provided during their creation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦初始化了 Docker Swarm 集群，两个新网络将会出现，`docker_gwbridge`（桥接）和 `ingress`（overlay），它们有不同的功能。第一个用于互联所有容器运行时，第二个用于管理所有服务流量。如果在创建服务时没有提供额外的网络，则默认情况下，所有服务将会连接到
    `ingress` 网络。
- en: Important note
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you find issues with Docker Swarm, check whether your firewall blocks your
    overlay networking; `2377`/TCP (cluster management traffic), `7946`/TCP-UDP (node
    intercommunication), and `4789`/UDP (overlay networking) traffic should be permitted.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在使用 Docker Swarm 时遇到问题，检查防火墙是否阻止了 overlay 网络通信；`2377`/TCP（集群管理流量）、`7946`/TCP-UDP（节点间通信）和`4789`/UDP（overlay
    网络）流量应被允许。
- en: All services attached to the same overlay network will be reachable by other
    services also connected to the same overlay network. We can also run containers
    attached to these networks, but remember that standalone containers will not be
    managed by Docker Swarm. By default, all overlay networks will be unencrypted
    and non-attachable (standalone containers can’t connect); hence, we need to pass
    `--opt encrypted --attachable` arguments along with `--driver overlay` (required
    to create overlay networks) to encrypt them and make them attachable.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 所有连接到同一 overlay 网络的服务将可以被其他连接到同一网络的服务访问。我们还可以运行连接到这些网络的容器，但请记住，独立容器不会由 Docker
    Swarm 管理。默认情况下，所有 overlay 网络将是未加密且不可连接的（独立容器无法连接）；因此，我们需要在创建 overlay 网络时，传递`--opt
    encrypted --attachable`参数与`--driver overlay`（创建 overlay 网络所必需）一起，以加密它们并使其可连接。
- en: We can create different overlay networks to isolate our applications, as containers
    attached to one network will not see those attached to a different one. It is
    recommended to isolate your applications in production and define any allowed
    communication by connecting your services to more than one network if required.
    Configurations such as the subnet or IP address range within a subnet can be used
    to create your custom network, but remember to specify the `--driver` argument
    to ensure you create an overlay network.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建不同的叠加网络来隔离我们的应用程序，因为连接到一个网络的容器将无法看到连接到另一个网络的容器。建议在生产环境中隔离应用程序，并在需要时通过将服务连接到多个网络来定义任何允许的通信。可以使用子网或子网内的IP地址范围等配置来创建自定义网络，但请记得指定`--driver`参数以确保创建叠加网络。
- en: Let’s see now how we can access our services and publish them.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何访问和发布我们的服务。
- en: Using service discovery and internal load balancing
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用服务发现和内部负载均衡
- en: Docker Swarm provides its own internal IPAM and DNS. Each service receives an
    IP address from the attached network range and a DNS entry will be created for
    it. An internal load-balancing feature is also available to distribute requests
    across service replicas. Therefore, when we access our service’s name, available
    replicas will receive our traffic. However, you as a developer don’t have to manage
    anything – Docker Swarm will do it all for you – but you must ensure that your
    application’s components are attached to appropriate networks and that you use
    the appropriate service’s names. The internal load balancer receives the traffic
    and routes your requests to your service’s task containers. Never use a container’s
    IP address in your applications as it will probably change (containers die and
    new ones are created), but a service’s IP addresses will stay as they are unless
    you recreate your service (as in, remove and create a new one again). A service’s
    IP addresses are assigned by an internal IPAM from a specific set.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Swarm提供了自己的内部IPAM和DNS。每个服务都会从连接的网络范围内获得一个IP地址，并为其创建一个DNS条目。还提供了内部负载均衡功能，将请求分发到服务的副本。因此，当我们访问服务的名称时，可用的副本将接收我们的流量。然而，作为开发者，你无需管理任何内容——Docker
    Swarm会为你处理一切——但你必须确保应用程序的组件连接到适当的网络，并且使用正确的服务名称。内部负载均衡器接收流量并将请求路由到服务的任务容器。切勿在应用程序中使用容器的IP地址，因为它可能会发生变化（容器会终止并创建新的容器），但服务的IP地址在你重新创建服务之前会保持不变（即删除并重新创建一个新的服务）。服务的IP地址由内部IPAM从特定的地址集分配。
- en: Publishing your applications
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布你的应用程序
- en: You may be asking yourself, what about the overlay `ingress` network created
    by default? Well, this network will be used to publish our applications. As we
    already learned for standalone environments, containers can run attached to a
    network and expose their processes’ ports internally, but we can also expose them
    externally by using `–publish` options. In Docker Swarm, we have the same behavior.
    If no port is exposed, the ports declared in the image will be published internally
    (you can override the ports’ definitions, but your application may not be reached).
    However, we can also publish our service’s containers externally, exposing its
    processes either in a random port within the `30000-32767` range or in a specifically
    defined port (as usual, more than one port can be published per container).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，默认创建的叠加`ingress`网络怎么样？嗯，这个网络将用于发布我们的应用程序。正如我们在独立环境中学到的那样，容器可以连接到一个网络并在内部暴露其进程的端口，但我们也可以通过使用`–publish`选项将其暴露到外部。在Docker
    Swarm中，我们也有相同的行为。如果没有暴露端口，镜像中声明的端口将被内部发布（你可以覆盖端口定义，但可能无法访问你的应用程序）。然而，我们也可以将服务的容器公开到外部，暴露其进程到`30000-32767`范围内的随机端口或一个特定定义的端口（如往常一样，每个容器可以发布多个端口）。
- en: All nodes participate in the overlay `ingress` network, and the published container
    ports will be attached using the port NAT, in all available hosts. Docker Swarm
    provides internal OSI Layer 3 routing using a mesh to guide requests to all available
    services’ tasks. Therefore, we can access our services on the defined published
    port on any cluster host, even if they don’t have a running service container.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 所有节点都会参与叠加的`ingress`网络，发布的容器端口将在所有可用主机上使用端口NAT进行连接。Docker Swarm使用网状结构提供内部OSI三层路由，引导请求到所有可用服务的任务。因此，我们可以在任何集群主机上通过定义的发布端口访问我们的服务，即使它们没有正在运行的服务容器。
- en: An external load balancer can be used to assign an IP address and forward the
    clients’ requests to certain cluster hosts (enough to provide high availability
    to our service).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用外部负载均衡器来分配 IP 地址，并将客户端的请求转发到特定的集群主机（足以为我们的服务提供高可用性）。
- en: 'Let’s see a quick example by creating a new service and publishing the container
    port, `80`, on the host port, `1080`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个新服务并将容器端口 `80` 发布到主机端口 `1080` 来快速查看一个示例：
- en: '[PRE21]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we can verify its status:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以验证它的状态：
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can test port `1080` on any cluster host (we only have one host on Docker
    Desktop):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在任何集群主机上测试端口 `1080`（我们在 Docker Desktop 上只有一台主机）：
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As we have seen, containers are available on a host’s port. In fact, in a cluster
    with multiple hosts, this port is available on all hosts, and this is the default
    mechanism for publishing applications in Docker Swarm. However, there are other
    methods for publishing applications in this orchestrator:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，容器可在主机的端口上访问。实际上，在一个拥有多个主机的集群中，这个端口在所有主机上都可以访问，这是 Docker Swarm 中发布应用的默认机制。不过，在这个编排器中还有其他方法可以发布应用：
- en: The `host` mode allows us to set the port only on those nodes actually running
    a service’s container. Using this mode, we can specify a set of cluster hosts
    where service instances will run by setting labels and then forward the clients’
    traffic to these hosts using an external load balancer.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host` 模式允许我们仅在实际运行服务容器的节点上设置端口。使用此模式，我们可以通过设置标签来指定一组集群主机，在这些主机上运行服务实例，然后使用外部负载均衡器将客户端的流量转发到这些主机。'
- en: The `dnsrr` mode allows us to avoid a service’s virtual IP address; hence, no
    IP address from the IPAM will be set and a service’s name will be associated directly
    with a container’s IP address. We can use the `--endpoint-mode` argument to manage
    the publishing mode when we create a service. In `dnsrr` mode, the internal DNS
    will use **round-robin resolution**. Cluster-internal client processes will resolve
    a different container IP address every time they ask the DNS for the service’s
    name.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dnsrr` 模式允许我们避免使用服务的虚拟 IP 地址；因此，不会设置来自 IPAM 的 IP 地址，服务的名称将直接与容器的 IP 地址相关联。我们可以使用
    `--endpoint-mode` 参数来管理发布模式，在创建服务时使用它。在 `dnsrr` 模式下，内部 DNS 将使用 **轮询解析**。集群内部的客户端进程每次请求服务名称时，都会解析到不同的容器
    IP 地址。'
- en: Now that we have learned how to publish applications running inside a Docker
    Swarm cluster to be consumed by applications inside and outside the cluster itself,
    let’s move on to review how service containers and other properties can be updated
    automatically.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了如何将运行在 Docker Swarm 集群中的应用发布，以便集群内部和外部的应用可以使用，让我们继续回顾如何自动更新服务容器和其他属性。
- en: Updating your application’s services
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新您的应用服务
- en: In this section, we are going to review how Docker Swarm will help our applications’
    stability and availability when we push changes to them. It is important to understand
    that whatever platform we are using to run our containers, we need to be able
    to modify our application content to fix issues or add new functionality. In production,
    this will probably be more restricted but automation should be able to do this
    too, ensuring a secure supply chain.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾 Docker Swarm 如何帮助我们的应用在推送更改时保持稳定性和可用性。重要的是要理解，不管我们使用什么平台来运行容器，都需要能够修改应用内容，以修复问题或添加新功能。在生产环境中，这可能会更加受限，但自动化应该也能做到这一点，确保供应链的安全。
- en: Docker Swarm provides a rolling update feature that deploys new changes without
    interrupting current replicas and automatically switches to an older configuration
    when the update goes wrong (rolls back).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Swarm 提供了一个滚动更新功能，可以在不打断当前副本的情况下部署新更改，并且在更新出错时会自动切换回旧的配置（回滚）。
- en: You as a developer must think about which update method fits your application
    best. Remember to deploy multiple replicas if you want to avoid any outages. This
    way, by setting the update parallelism (`--update-parallelism`), the delay in
    seconds between container updates (`--update-delay`), and the order in which to
    deploy the change (`--update-order`) – which allows us to stop the previous container
    before starting a new one (default), or do the reverse – we can ensure our service
    health when we apply changes. It is very important to understand that your application
    must allow you to run more than one container replica at a time because this may
    be needed to access a volume at the same time. Remember, this may break your application
    data if your processes don’t allow it (for example, a database may get corrupted).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，你必须考虑哪种更新方法最适合你的应用程序。记住，如果你想避免任何停机，应该部署多个副本。通过设置更新并行度（`--update-parallelism`）、容器更新之间的延迟时间（`--update-delay`）以及部署变更的顺序（`--update-order`）——这允许我们在启动新容器之前停止之前的容器（默认），或者做相反的操作——我们可以确保在应用变更时服务的健康状况。理解这一点非常重要：你的应用程序必须允许你同时运行多个容器副本，因为这可能需要同时访问一个卷。记住，如果你的进程不允许这样做，这可能会破坏你的应用数据（例如，数据库可能会损坏）。
- en: When our service deploys many replicas, for example, a stateless frontend service,
    it is very important to decide what to do when issues arise during the upgrade
    process.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的服务部署了多个副本时，例如一个无状态的前端服务，决定在升级过程中遇到问题时应该怎么做是非常重要的。
- en: By default, Docker Swarm will wait five seconds to start monitoring the status
    of each task update. If your application requires more time to be considered healthy,
    you may need to set up an appropriate value by using the `--``update-monitor`
    argument.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker Swarm将在开始监控每个任务更新的状态之前等待五秒钟。如果你的应用程序需要更多时间才能被认为是健康的，你可能需要通过使用`--update-monitor`参数设置一个合适的值。
- en: 'The update process works by default as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 更新过程默认按以下方式工作：
- en: Docker Swarm stops the first service’s container (the first replica/task; the
    container’s suffix shows the task number).
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker Swarm停止第一个服务的容器（第一个副本/任务；容器的后缀显示任务编号）。
- en: Then, the update is triggered for this stopped task.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，更新将为这个停止的任务触发。
- en: A new container starts to update the task.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个新的容器开始更新任务。
- en: 'Then, two situations may occur:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，可能会出现两种情况：
- en: If the process goes fine, the update of a task returns `RUNNING`. Then, Docker
    Swarm waits for the defined delay time between updates and triggers the update
    process again for the next service task.
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果过程顺利，任务的更新会返回`RUNNING`。然后，Docker Swarm会等待定义的更新间隔时间，并再次触发下一个服务任务的更新过程。
- en: If the process fails, for example, the container doesn’t start correctly, the
    updated task returns `FAILED` and the current service update process is paused.
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果过程失败，例如容器没有正确启动，更新任务会返回`FAILED`，当前的服务更新过程会被暂停。
- en: When the service update process is paused, we have to decide whether we have
    to manually roll back to a previous version (configurations, container images,
    and so on – in fact, any change deployed since the latest correct update) or execute
    a new update again.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当服务更新过程暂停时，我们必须决定是手动回滚到先前的版本（配置、容器镜像等——实际上是自上次正确更新以来部署的任何更改），还是再次执行新的更新。
- en: We will use the `--update-failure-action` argument to automate the process when
    something goes wrong during the updates. This option allows us to either *continue*
    with the update, even if some containers fail, *pause* the update process (default),
    or automatically trigger a *rollback* in case of any error.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`--update-failure-action`参数来自动化处理在更新过程中出现问题时的过程。这个选项允许我们在某些容器失败的情况下，仍然*继续*更新，*暂停*更新过程（默认），或者在发生任何错误时自动触发*回滚*。
- en: It is really recommended to test your deployments and updates to have a clear
    idea of how your application can be compromised in case of failure.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议你测试部署和更新，以便清楚地了解在失败的情况下你的应用程序可能会受到哪些影响。
- en: All the options described to define the update process are also available for
    the rollback procedure; hence, we have a lot of options for managing our application
    stability even when we trigger service changes.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 所有定义更新过程的选项在回滚过程中也适用；因此，即使在触发服务更改时，我们也有许多选项来管理应用程序的稳定性。
- en: In the following section, we will prepare an application for Docker Swarm and
    review some of the features learned about in this chapter.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将为Docker Swarm准备一个应用程序，并回顾本章学习的一些功能。
- en: Labs
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验室
- en: The following labs will help you deploy a simple demo application on top of
    a Docker Swarm cluster to review the most important features provided by this
    container orchestrator. The code for the labs is available in this book’s GitHub
    repository at [https://github.com/PacktPublishing/Containers-for-Developers-Handbook.git](https://github.com/PacktPublishing/Containers-for-Developers-Handbook.git).
    Ensure you have the latest revision available by simply executing `git clone https://github.com/PacktPublishing/Containers-for-Developers-Handbook.git`
    to download all its content or `git pull` if you have already downloaded the repository
    before. Additional labs are included in GitHub. All commands and content used
    in these labs will be located inside the `Containers-for-Developers-Handbook/Chapter7`
    directory.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 以下实验将帮助你在 Docker Swarm 集群上部署一个简单的演示应用程序，以回顾这个容器编排器提供的最重要功能。实验代码可在本书的 GitHub
    仓库中找到，链接是 [https://github.com/PacktPublishing/Containers-for-Developers-Handbook.git](https://github.com/PacktPublishing/Containers-for-Developers-Handbook.git)。确保你获取到最新版本，只需执行
    `git clone https://github.com/PacktPublishing/Containers-for-Developers-Handbook.git`
    下载所有内容，或者如果你之前已经下载过该仓库，只需执行 `git pull`。更多实验也包括在 GitHub 中。所有在这些实验中使用的命令和内容都位于 `Containers-for-Developers-Handbook/Chapter7`
    目录下。
- en: We will start by deploying our own Docker Swarm cluster.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从部署我们自己的 Docker Swarm 集群开始。
- en: Deploying a single-node Docker Swarm cluster
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署单节点 Docker Swarm 集群
- en: In this lab, we will create a one-node Docker Swarm cluster using the Docker
    Desktop environment.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，我们将使用 Docker Desktop 环境创建一个单节点的 Docker Swarm 集群。
- en: Important note
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Deploying a single-node cluster is enough to review the most important features
    learned about in this chapter but, of course, we wouldn’t be able to move service
    tasks to another node. If you are interested in a situation like that and want
    to review advanced container scheduling scenarios, you can deploy multiple-node
    clusters following any of the methods described in the specific `multiple-nodes-cluster.md`
    Markdown file located in this chapter’s folder.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 部署一个单节点集群足以回顾本章学习的最重要功能，但当然，我们无法将服务任务移到其他节点。如果你对这种情况感兴趣，并想回顾高级容器调度场景，可以根据本章文件夹中
    `multiple-nodes-cluster.md` Markdown 文件中描述的任何方法部署多节点集群。
- en: 'To create a single-node Docker Swarm cluster, we will follow these steps:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个单节点的 Docker Swarm 集群，我们将按照以下步骤进行：
- en: 'Use the `docker` CLI with the `swarm` object. In this example, we will use
    default IP address values to initialize a Docker Swarm cluster:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `docker` CLI 和 `swarm` 对象。在本示例中，我们将使用默认的 IP 地址值来初始化一个 Docker Swarm 集群：
- en: '[PRE24]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can now verify the current Docker Swarm nodes:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以验证当前的 Docker Swarm 节点：
- en: '[PRE25]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Overlay and specific bridge networks were created, as we can easily verify
    by listing the available networks:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了 Overlay 和特定的桥接网络，我们可以通过列出可用的网络轻松验证：
- en: '[PRE26]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This cluster has one node; hence, this node is the manager (leader) and also
    acts as a worker (by default):'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个集群只有一个节点，因此该节点是管理节点（领导者），同时也充当工作节点（默认情况下）：
- en: '[PRE27]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This cluster is now ready to run Docker Swarm services.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个集群现在已经准备好运行 Docker Swarm 服务了。
- en: Reviewing the main features of Docker Swarm services
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾 Docker Swarm 服务的主要功能
- en: 'In this lab, we are going to review some of the features of the most important
    services by running a replicated and global service:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，我们将通过运行一个复制的全局服务来回顾一些最重要服务的特性：
- en: 'We will start by creating a simple `webserver` service using Docker Hub’s `nginx:alpine`
    container image:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过使用 Docker Hub 的 `nginx:alpine` 容器镜像来创建一个简单的 `webserver` 服务：
- en: '[PRE28]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: $ docker service ls
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker service ls
- en: ID             NAME        MODE         REPLICAS   IMAGE          PORTS
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ID             名称        模式         副本数   镜像         端口
- en: m93gsvuin5vl   webserver   replicated   1/1        nginx:alpine
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: m93gsvuin5vl   webserver   复制模式   1/1        nginx:alpine
- en: $ docker service ps webserver
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker service ps webserver
- en: ID             NAME          IMAGE          NODE             DESIRED STATE   CURRENT
    STATE                ERROR     PORTS
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ID             名称         镜像         节点             期望状态   当前状态                错误     端口
- en: 'webserver.1 and it runs on the docker-desktop node; we can verify the associated
    container by listing the containers on that node:'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: webserver.1 并且它运行在 docker-desktop 节点上；我们可以通过列出该节点上的容器来验证相关容器：
- en: '[PRE29]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It is easy to track the containers associated with services. We can still run
    containers directly using the container runtime, but those will not be managed
    by Docker Swarm.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 跟踪与服务关联的容器很容易。我们仍然可以直接使用容器运行时运行容器，但这些容器不会由 Docker Swarm 管理。
- en: '[PRE30]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let’s now replicate this service by adding a new task:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们通过添加一个新任务来复制这个服务：
- en: '[PRE31]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: $ docker service ps webserver
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker service ps webserver
- en: ID             NAME          IMAGE          NODE             DESIRED STATE   CURRENT
    STATE               ERROR     PORTS
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ID              名称              镜像              节点              期望状态        当前状态               错误        端口
- en: l38u6vpyq5zo   webserver.1   nginx:alpine   docker-desktop   Running         Running
    about an hour ago
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: l38u6vpyq5zo   webserver.1   nginx:alpine   docker-desktop   运行中         大约一个小时前运行
- en: j0at9tnwc3tx   webserver.2   nginx:alpine   docker-desktop   Running         Running
    4 minutes ago
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: j0at9tnwc3tx   webserver.2   nginx:alpine   docker-desktop   运行中         4分钟前运行
- en: vj6k8cuf0rix   webserver.3   nginx:alpine   docker-desktop   Running         Running
    4 minutes ago
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: vj6k8cuf0rix   webserver.3   nginx:alpine   docker-desktop   运行中         4分钟前运行
- en: '[PRE32]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Each container gets its own IP address and we will reach each one when we publish
    the service. We verify that all containers started correctly by reviewing the
    service’s logs:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个容器都有自己的 IP 地址，我们在发布服务时会访问每一个。我们通过查看服务的日志来验证所有容器是否正确启动：
- en: '[PRE33]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: $ docker service update \
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker service update \
- en: --publish-add published=8080,target=80 webserver
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --publish-add published=8080,target=80 webserver
- en: webserver
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: webserver
- en: 'overall progress: 3 out of 3 tasks'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 总体进度：3/3 任务完成
- en: '1/3: running   [==================================================>]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '1/3: 正在运行   [==================================================>]'
- en: '2/3: running   [==================================================>]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '2/3: 正在运行   [==================================================>]'
- en: '3/3: running   [==================================================>]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '3/3: 正在运行   [==================================================>]'
- en: '[PRE34]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: $ docker service ps webserver
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker service ps webserver
- en: ID             NAME              IMAGE          NODE             DESIRED STATE   CURRENT
    STATE             ERROR     PORTS
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ID              名称              镜像              节点              期望状态        当前状态               错误        端口
- en: u7i2t7u60wzt   webserver.1       nginx:alpine   docker-desktop   Running         Running
    26 seconds ago
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: u7i2t7u60wzt   webserver.1       nginx:alpine   docker-desktop   运行中         26秒前运行
- en: l38u6vpyq5zo    \_ webserver.1   nginx:alpine   docker-desktop   Shutdown        Shutdown
    29 seconds ago
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: l38u6vpyq5zo    \_ webserver.1   nginx:alpine   docker-desktop   已关机       29秒前关机
- en: i9ia5qjtgz96   webserver.2       nginx:alpine   docker-desktop   Running         Running
    31 seconds ago
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: i9ia5qjtgz96   webserver.2       nginx:alpine   docker-desktop   运行中         31秒前运行
- en: j0at9tnwc3tx    \_ webserver.2   nginx:alpine   docker-desktop   Shutdown        Shutdown
    33 seconds ago
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: j0at9tnwc3tx    \_ webserver.2   nginx:alpine   docker-desktop   已关机       33秒前关机
- en: 9duwbwjt6oow   webserver.3       nginx:alpine   docker-desktop   Running         Running
    35 seconds ago
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 9duwbwjt6oow   webserver.3       nginx:alpine   docker-desktop   运行中         35秒前运行
- en: '80 was assigned to a random host port):'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 80 已分配给一个随机主机端口）：
- en: '[PRE35]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: $ curl localhost:8080 -I
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ curl localhost:8080 -I
- en: HTTP/1.1 200 OK
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: HTTP/1.1 200 OK
- en: 'Server: nginx/1.23.4'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 服务器：nginx/1.23.4
- en: '...'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...'
- en: curl command a few times to access more than one service’s replica.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 curl 命令访问多个服务的副本。
- en: '[PRE36]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now we can check the logs again:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以再次检查日志：
- en: '[PRE38]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you may have noticed, multiple replicas were reached; hence, internal load
    balancing worked as expected.
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的那样，多个副本已被访问；因此，内部负载均衡按预期工作。
- en: 'We end this lab by removing the created service:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过删除创建的服务来结束这个实验：
- en: '[PRE39]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This lab showed how to deploy and modify a simple replicated service. It may
    be interesting for you to deploy your own global service and review the differences
    between them.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 本实验展示了如何部署和修改一个简单的复制服务。您可能会对部署您自己的全局服务并查看它们之间的差异感兴趣。
- en: We will now run a simple application using a Compose YAML file.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用 Compose YAML 文件运行一个简单的应用程序。
- en: Deploying a complete application with Docker
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Docker 部署完整应用程序
- en: 'In this lab, we will run a complete application using a stack object. Take
    a good look at the YAML file that we will use to deploy our application:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，我们将使用堆栈对象运行一个完整的应用程序。仔细查看我们将用来部署应用程序的 YAML 文件：
- en: 'We first create a couple of secret objects that we will use in the stack:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一些我们将在堆栈中使用的秘密对象：
- en: '[PRE40]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To create an initial database with our own data structure, we add a new config,
    `init-demo.sh`, to overwrite the file included in the image:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用我们自己的数据结构创建一个初始数据库，我们添加了一个新的配置 `init-demo.sh`，以覆盖镜像中包含的文件：
- en: '[PRE41]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'version: "3.9"'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 版本： "3.9"
- en: 'services:'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 服务：
- en: 'lb:'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'lb:'
- en: 'image: frjaraur/simplestlab:simplestlb'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 镜像： frjaraur/simplestlab:simplestlb
- en: 'environment: # This environment definitions are in clear-text as they don''t
    manange any sensitive data'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 环境：# 这些环境定义是明文的，因为它们不管理任何敏感数据
- en: '- APPLICATION_ALIAS=app # We use the service''s names'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- APPLICATION_ALIAS=app # 我们使用服务的名称'
- en: '- APPLICATION_PORT=3000'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- APPLICATION_PORT=3000'
- en: 'networks:'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 网络：
- en: 'simplestlab:'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'simplestlab:'
- en: 'ports:'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 端口：
- en: '- target: 80'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- target: 80'
- en: 'published: 8080'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 发布端口：8080
- en: 'protocol: tcp'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 协议：tcp
- en: '[PRE42]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'db:'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'db:'
- en: 'image: frjaraur/simplestlab:simplestdb'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'image: frjaraur/simplestlab:simplestdb'
- en: 'environment: # Postgres images allows the use of a password file.'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'environment: # Postgres 镜像允许使用密码文件。'
- en: '- POSTGRES_PASSWORD_FILE=/run/secrets/dbpasswd.env'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- POSTGRES_PASSWORD_FILE=/run/secrets/dbpasswd.env'
- en: 'networks:'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'networks:'
- en: 'simplestlab:'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'simplestlab:'
- en: 'secrets:'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'secrets:'
- en: '- dbpasswd.env'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- dbpasswd.env'
- en: 'configs: # We load a initdb script to initialize our demo database.'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'configs: # 我们加载一个 initdb 脚本来初始化我们的演示数据库。'
- en: '- source: init-demo.sh'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- source: init-demo.sh'
- en: 'target: /docker-entrypoint-initdb.d/init-demo.sh'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'target: /docker-entrypoint-initdb.d/init-demo.sh'
- en: 'mode: 0770'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'mode: 0770'
- en: 'volumes:'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'volumes:'
- en: '- pgdata:/var/lib/postgresql/data'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- pgdata:/var/lib/postgresql/data'
- en: '[PRE43]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'app:'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'app:'
- en: 'image: frjaraur/simplestlab:simplestapp'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'image: frjaraur/simplestlab:simplestapp'
- en: 'secrets: # A secret is used to integrate de database connection into our application.'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'secrets: # 密钥用于将数据库连接集成到我们的应用程序中。'
- en: '- source: dbconfig.json'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- source: dbconfig.json'
- en: 'target: /APP/dbconfig.json'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'target: /APP/dbconfig.json'
- en: 'mode: 0555'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'mode: 0555'
- en: 'networks:'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'networks:'
- en: 'simplestlab:volumes:'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'simplestlab:volumes:'
- en: 'pgdata: # This volume should be mounted from a network resource available to
    other hosts or the content should be synced between nodes'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'pgdata: # 这个卷应当从可供其他主机使用的网络资源挂载，或者在节点之间同步内容'
- en: '[PRE44]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'networks:'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'networks:'
- en: 'simplestlab:'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'simplestlab:'
- en: 'configs:'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'configs:'
- en: 'init-demo.sh:'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'init-demo.sh:'
- en: 'external: true'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'external: true'
- en: 'secrets:'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'secrets:'
- en: 'dbpasswd.env:'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'dbpasswd.env:'
- en: 'external: true'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'external: true'
- en: 'dbconfig.json:'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'dbconfig.json:'
- en: 'external: true'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'external: true'
- en: '[PRE45]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Important note
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We haven’t used a network volume because we are using a single-node cluster,
    so it isn’t needed. But if you plan to deploy more nodes in your cluster, you
    must prepare either a network storage or a cluster-wide synchronization solution
    to ensure the data is available wherever the database component is running. Otherwise,
    your database server won’t be able to start correctly.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有使用网络卷，因为我们使用的是单节点集群，因此不需要它。但如果您计划在集群中部署更多节点，则必须准备网络存储或集群范围的同步解决方案，以确保数据在数据库组件运行的地方都可用。否则，您的数据库服务器将无法正确启动。
- en: 'Now we can deploy the Compose YAML file as a Docker stack:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以将 Compose YAML 文件部署为 Docker stack：
- en: '[PRE46]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We verify the status of the deployed stack:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们验证已部署 stack 的状态：
- en: '[PRE47]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We now review which ports are available for accessing our application:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们查看哪些端口可用于访问我们的应用程序：
- en: '[PRE48]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '![Figure 7.1 – Application is accessible at http://localhost:8080](img/B19845_07_01.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – 应用程序可通过 http://localhost:8080 访问](img/B19845_07_01.jpg)'
- en: Figure 7.1 – Application is accessible at http://localhost:8080
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 应用程序可通过 http://localhost:8080 访问
- en: Before removing the application using `docker stack rm chapter7`, it may be
    interesting for you to experiment with scaling up and down the app component and
    changing some content (you have the code, configurations, and secrets deployed).
    This will help you experiment with how rolling updates and rollbacks are managed
    by Docker Swarm.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `docker stack rm chapter7` 删除应用程序之前，您可能会想尝试扩展和缩小应用程序组件，并更改一些内容（您已部署代码、配置和密钥）。这将帮助您实验
    Docker Swarm 如何管理滚动更新和回滚。
- en: This lab helped you understand how you can parametrize a Docker Compose file
    to deploy a complete application into a Docker Swarm cluster.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验帮助您理解了如何将 Docker Compose 文件参数化，以将一个完整的应用程序部署到 Docker Swarm 集群中。
- en: Summary
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the basic usage of Docker Swarm. We learned how
    to deploy a simple cluster and how to run our applications by taking advantage
    of Docker Swarm’s features. We learned how to use Compose YAML files to deploy
    stacks and define an application completely using services and tasks to finally
    execute its containers. Docker Swarm manages complicated networking communication
    cluster-wide, helping us to publish our applications for users or other applications
    to access. It also provides mechanisms to ensure the availability of our applications
    even when we trigger component updates, such as a change to a container image.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们介绍了 Docker Swarm 的基本使用方法。我们学习了如何部署一个简单的集群，并利用 Docker Swarm 的功能来运行我们的应用程序。我们学习了如何使用
    Compose YAML 文件来部署 stacks，并通过服务和任务完全定义一个应用程序，最终执行其容器。Docker Swarm 管理集群范围内复杂的网络通信，帮助我们发布应用程序供用户或其他应用程序访问。它还提供了机制，确保即使触发组件更新（例如更改容器镜像），我们的应用程序也能保持可用。
- en: In the next chapter, we will learn the basics of Kubernetes, the most popular
    and advanced container orchestrator currently available.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习 Kubernetes 的基础知识，这是目前最流行、最先进的容器编排工具。
