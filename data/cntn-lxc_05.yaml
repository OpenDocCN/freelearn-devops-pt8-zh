- en: Chapter 5. Networking in LXC with the Linux Bridge and Open vSwitch
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：使用Linux桥接和Open vSwitch在LXC中的网络
- en: To enable network connectivity for a newly built container we need a way to
    connect the virtual network interfaces from the container's network namespace
    to the host and provide routing to either other containers or the Internet, if
    needed. Linux provides a software bridge that allows us to *wire* LXC containers
    together in a variety of ways, as we'll explore in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 要为新建的容器启用网络连接，我们需要一种方法将容器网络命名空间中的虚拟网络接口连接到主机，并在需要时为其他容器或互联网提供路由。Linux提供了一个软件桥接，允许我们以多种方式将LXC容器*连接*在一起，正如我们将在本章中探讨的那样。
- en: There are two popular software bridge implementations – the Linux bridge provided
    by the `bridge-utils` package and the Open vSwitch project. These extend the basic
    functionality of the Linux bridge even further, by separating the control and
    management planes of the switch, allowing for the control of the traffic flow
    and providing for hardware integration among other things.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种流行的软件桥接实现——`bridge-utils`包提供的Linux桥接和Open vSwitch项目。这些通过将交换机的控制平面和管理平面分离，进一步扩展了Linux桥接的基本功能，从而实现了流量控制并提供硬件集成等功能。
- en: By default, when we build a container from the provided templates, the template
    script sets up networking by configuring a software bridge on the host OS using
    **Network Address Translation** (**NAT**) rules in `iptables`. In this mode, the
    container gets its IP address from a `dnsmasq` server that LXC starts. However,
    we have full control on what bridge, mode, or routing we would like to use, by
    means of the container's configuration file.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当我们从提供的模板构建容器时，模板脚本会通过在主机操作系统上使用`iptables`中的**网络地址转换**（**NAT**）规则来配置网络桥接。在这种模式下，容器从LXC启动的`dnsmasq`服务器获取IP地址。然而，我们可以通过容器的配置文件完全控制我们希望使用的桥接、模式或路由。
- en: 'In this chapter, we''ll explore the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Installing and configuring the Linux bridge
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和配置Linux桥接
- en: Installing and creating an Open vSwitch switch
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和创建Open vSwitch交换机
- en: Configuring networking in LXC using NAT, direct connect, VLAN, and other modes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NAT、直连、VLAN等模式在LXC中配置网络
- en: Software bridging in Linux
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux中的软件桥接
- en: Connecting LXC or any other type of virtual machine such as KVM or Xen, the
    hypervisor layer, or in the case of LXC, the host OS, requires the ability to
    bridge traffic between the containers/VMs and the outside world. Software bridging
    in Linux has been supported since the kernel version 2.4\. To take advantage of
    this functionality, bridging needs to be enabled in the kernel by setting **Networking
    support** | **Networking options** | **802.1d Ethernet Bridging** to yes, or as
    a kernel module when configuring the kernel.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 连接LXC或任何其他类型的虚拟机（如KVM或Xen）、虚拟化管理层，或者在LXC的情况下，主机操作系统，要求能够在容器/虚拟机与外部世界之间桥接流量。Linux中的软件桥接自内核版本2.4起便已被支持。为了利用这一功能，必须通过设置**网络支持**
    | **网络选项** | **802.1d以太网桥接**为“是”来启用桥接，或者在配置内核时作为内核模块进行启用。
- en: 'To check what bridging options are compiled in the kernel, or available as
    modules, run the following command:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查内核中编译了哪些桥接选项，或作为模块提供哪些选项，请运行以下命令：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'On Ubuntu and CentOS systems, the bridging is available as kernel modules.
    To verify that they are loaded, run the following command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu和CentOS系统上，桥接作为内核模块提供。要验证它们是否已加载，请运行以下命令：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To obtain more information about the `bridge` kernel module, execute the following
    command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取更多关于`bridge`内核模块的信息，请执行以下命令：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you are using a distribution that does not have the bridge compiled in the
    kernel, or available as a module, or if you would like to experiment with different
    kernel options, you'll need the kernel source first.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的发行版没有将桥接编译进内核，或者没有作为模块提供，或者如果你想尝试不同的内核选项，你需要首先获取内核源代码。
- en: 'To install it on Ubuntu, you can do this by running the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Ubuntu上安装它，可以通过运行以下命令来完成：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'On CentOS, install the kernel source with `yum`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在CentOS上，使用`yum`安装内核源代码：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To use the `ncurses` menu for configuring the kernel, run the following command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`ncurses`菜单配置内核，请运行以下命令：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Navigate to **Networking support** | **Networking options** | **802.1d Ethernet
    Bridging** and select either **Y** to compile the bridging functionality in the
    kernel, or **M** to compile it as a module.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 转到**网络支持** | **网络选项** | **802.1d以太网桥接**，并选择**Y**以将桥接功能编译到内核中，或选择**M**将其编译为模块。
- en: 'The kernel configuration menu looks like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 内核配置菜单如下所示：
- en: '![Software bridging in Linux](img/image_05_001.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![Linux中的软件桥接](img/image_05_001.jpg)'
- en: 'Once you make the selections, build the new kernel package and install it:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 选择完成后，构建新的内核包并安装：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To use the new kernel, install the packages and reboot.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用新内核，安装这些包并重启。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on how to compile and install the Linux kernel from source,
    refer to your distribution's documentation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何从源代码编译和安装Linux内核的更多信息，请参考您的发行版文档。
- en: The Linux bridge
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux桥接
- en: The built-in Linux bridge is a software layer 2 device. OSI layer 2 devices
    provide a way of connecting multiple Ethernet segments together and forward traffic
    based on MAC addresses, effectively creating separate broadcast domains.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的Linux桥接是一个软件层2设备。OSI层2设备提供了一种将多个以太网段连接在一起并基于MAC地址转发流量的方式，实质上创建了独立的广播域。
- en: 'Let''s start by installing the latest version from source on Ubuntu:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从源代码开始在Ubuntu上安装最新版本：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: From the preceding output, we can see that we first cloned the `git` repository
    for the `bridge-utils` project and then compiled the source code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以看到我们首先克隆了`git`仓库中的`bridge-utils`项目，然后编译了源代码。
- en: 'To compile the bridging software on CentOS, the process is similar to what
    we did in the previous section; first we install the prerequisite packages, then
    configure and compile, as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在CentOS上编译桥接软件的过程与我们在上一节中做的类似；首先我们安装所需的先决包，然后进行配置和编译，如下所示：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Invoking the `brctl` command without any parameters shows what operations are
    available:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`brctl`命令而不带任何参数可以显示可用的操作：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The Linux bridge and the LXC package on Ubuntu
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux桥接和Ubuntu上的LXC包
- en: 'Let''s install the LXC package and dependencies. To check the latest available
    package version from the repositories you have configured on your system, run
    the following command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装LXC包和依赖项。要检查系统中配置的存储库中可用的最新包版本，请运行以下命令：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output is from an Amazon EC2 instance, showing that the latest LXC version
    is `2.0.4-0ubuntu1~ubuntu14.04.1`. Let''s install it and observe the output:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 输出来自一个Amazon EC2实例，显示最新的LXC版本为`2.0.4-0ubuntu1~ubuntu14.04.1`。让我们安装它并观察输出：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice how the package installs and configures the `dnsmasq` service, due to
    package dependencies in the `lxc1.postinst` script part of the `lxc` package.
    This is quite convenient on Ubuntu, but if the distribution you are running does
    not support that, or you are compiling LXC from source, you can always install
    that manually. You only need to do this if you prefer `dnsmasq` to assign IP addresses
    to your containers dynamically. You can always configure the LXC containers with
    static IP addresses.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，包安装并配置了`dnsmasq`服务，这是由于`lxc`包中`lxc1.postinst`脚本部分的包依赖关系。这在Ubuntu上非常方便，但如果您运行的发行版不支持此功能，或者您是从源代码编译LXC，您始终可以手动安装它。只有在您希望`dnsmasq`动态分配IP地址给容器时，才需要这样做。您始终可以为LXC容器配置静态IP地址。
- en: 'From the preceding output, we can also observe that the package started the
    `lxc-net` service. Let''s look into that by checking its status:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们还可以观察到该包启动了`lxc-net`服务。让我们通过检查其状态来深入了解：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Also, take a look at the `init` configuration file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还请查看`init`配置文件：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can see that the `init` script starts the `lxc-net` service. Let''s see
    what this provides:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`init`脚本启动了`lxc-net`服务。让我们看看它提供了什么：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: From the first few lines of the preceding script we can see that it sets up
    LXC networking defaults, such as the name of the Linux bridge and the subnet that
    will be assigned by the `dnsmasq` service. It also points us to the default LXC
    network file that we can use to override those options.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面脚本的前几行中，我们可以看到它设置了LXC网络的默认值，例如Linux桥接的名称和将由`dnsmasq`服务分配的子网。它还指向了我们可以用来覆盖这些选项的默认LXC网络文件。
- en: 'Let''s take a look at the default `lxc-net` file:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看默认的`lxc-net`文件：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'LXC on Ubuntu is packaged in such a way that it also creates the bridge for
    us:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu上的LXC被打包成这样的方式，它也为我们创建了桥接：
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice the name of the bridge—`lxcbr0`—is the one specified in the `/etc/default/lxc-net`
    file and the `/usr/lib/x86_64-linux-gnu/lxc/lxc-net` script.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，桥接的名称—`lxcbr0`—是`/etc/default/lxc-net`文件和`/usr/lib/x86_64-linux-gnu/lxc/lxc-net`脚本中指定的名称。
- en: The Linux bridge and the LXC package on CentOS
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CentOS上的Linux桥接和LXC包
- en: Unfortunately, not all Linux distributions package LXC with the extra functionality
    of building the bridge, and configuring and starting `dnsmasq`, as we saw in the
    earlier section with Ubuntu. Building LXC from source, as described in [Chapter
    2](ch02.html "Chapter 2. Installing and Running LXC on Linux Systems"), *Installing
    and Running LXC on Linux Systems*, or using the CentOS packages, will not automatically
    create the Linux bridge, or configure and start the `dnsmasq` service.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，并非所有Linux发行版都在打包LXC时附带了构建桥接、配置和启动`dnsmasq`的额外功能，正如我们在之前的Ubuntu部分中看到的那样。从源代码构建LXC，如[第2章](ch02.html
    "第2章：在Linux系统上安装和运行LXC")所述，*在Linux系统上安装和运行LXC*，或使用CentOS的包，将不会自动创建Linux桥接，或配置并启动`dnsmasq`服务。
- en: 'Let''s explore this in more detail on CentOS, by building an LXC container
    named `bridge`, using the `centos` template:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在CentOS上更详细地探讨这个问题，通过使用`centos`模板构建一个名为`bridge`的LXC容器：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s check if a bridge was created after the `lxc` package was installed
    and the container was built:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查在安装`lxc`包并构建容器后是否创建了桥接：
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we try to start the container, we''ll get the following errors:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试启动容器，将会遇到以下错误：
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding output shows that the container is trying to connect to a bridge
    named `virbr0`, which does not exist. The name is defined in the following file
    and then assigned to the container''s configuration:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出显示容器正在尝试连接一个名为`virbr0`的桥接，但该桥接并不存在。该名称在以下文件中定义，并随后分配给容器的配置：
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In order to successfully start the container, we''ll have to first create the
    bridge that LXC expects:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功启动容器，我们必须首先创建LXC期望的桥接：
- en: '[PRE21]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then start the container again and check the bridge:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后重新启动容器并检查桥接：
- en: '[PRE22]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `vethB6CRLW` interface is the virtual interface that the LXC container
    presents to the host and connects to the `virbr0` bridge port:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`vethB6CRLW`接口是LXC容器呈现给主机的虚拟接口，并连接到`virbr0`桥接端口：'
- en: '[PRE23]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding output displays the current configuration for the virtual interface
    of the `bridge` container we built earlier, as seen by the host OS.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出显示了我们之前构建的`bridge`容器的虚拟接口的当前配置，如主机操作系统所看到的。
- en: Using dnsmasq service to obtain an IP address in the container
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`dnsmasq`服务在容器中获取IP地址
- en: 'The `dnsmasq` service that was started after installing the `lxc` package on
    Ubuntu should look similar to the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu上安装`lxc`包后启动的`dnsmasq`服务应类似于以下内容：
- en: '[PRE24]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note, the `dhcp-range` parameter matches what was defined in the `/etc/default/lxc-net`
    file.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`dhcp-range`参数与`/etc/default/lxc-net`文件中定义的内容相匹配。
- en: 'Let''s create a new container and explore its network settings:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的容器并探索其网络设置：
- en: '[PRE25]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Notice the name of the virtual interface that was created on the host OS – `veth366R6F`,
    from the output of the `lxc-info` command. The interface should have been added
    as a port to the bridge. Let''s confirm this using the `brctl` utility:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在主机操作系统上创建的虚拟接口名称—`veth366R6F`，这是`lxc-info`命令输出中的名称。该接口应作为端口添加到桥接中。让我们使用`brctl`工具确认这一点：
- en: '[PRE26]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing all interfaces on the host shows the bridge and the virtual interface
    associated with the container:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列出主机上的所有接口可以显示与容器关联的桥接和虚拟接口：
- en: '[PRE27]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Notice the IP address assigned to the `lxcbr0` interface—it''s the same IP
    address passed as the `listen-address` argument to the `dnsmasq` process. Let''s
    examine the network interface and the routes inside the container by attaching
    to it first:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意分配给`lxcbr0`接口的IP地址—它与传递给`dnsmasq`进程的`listen-address`参数相同。让我们首先通过连接到容器来检查容器内的网络接口和路由：
- en: '[PRE28]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The IP address assigned to the `eth0` interface by `dnsmasq` is part of the
    `10.0.3.0/24` subnet and the default gateway is the IP of the bridge interface
    on the host. The reason the container automatically obtained an IP address is
    its interface configuration file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`dnsmasq`为`eth0`接口分配的IP地址位于`10.0.3.0/24`子网中，默认网关是主机上桥接接口的IP地址。容器之所以自动获得IP地址，是因为其接口配置文件：'
- en: '[PRE29]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As the preceding output shows, `eth0` is configured to use DHCP. If we would
    rather use statically assigned addresses, we only have to change that file and
    specify whatever IP address we would like to use. Using DHCP with `dnsmasq` is
    not required for LXC networking, but it can be a convenience.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的输出所示，`eth0` 配置为使用 DHCP。如果我们宁愿使用静态分配的地址，只需更改该文件并指定我们想要使用的任何 IP 地址。使用 `dnsmasq`
    配合 DHCP 进行 LXC 网络连接并非必需，但它可以提供便利。
- en: 'Let''s change the range of IPs that `dnsmasq` offers, by not assigning the
    first one hundred IPs in the `/etc/default/lxc-net` file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过不分配 `/etc/default/lxc-net` 文件中的前一百个 IP 来更改 `dnsmasq` 提供的 IP 范围：
- en: '[PRE30]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After restarting `dnsmasq`, observe the new DHCP range passed as the `dhcp-range`
    parameter:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新启动 `dnsmasq` 后，观察作为 `dhcp-range` 参数传递的新 DHCP 范围：
- en: '[PRE31]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The next time we build a container using the Ubuntu template, the IP address
    that will be assigned to the container will start from `100` for the fourth octet.
    This is handy if we want to use the first `100` IPs for manual assignment, as
    we'll see next.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下次我们使用 Ubuntu 模板构建容器时，分配给容器的 IP 地址将从第四个八位组的 `100` 开始。如果我们想将前 `100` 个 IP 用于手动分配，使用这种方式很方便，正如我们接下来所看到的那样。
- en: Statically assigning IP addresses in the LXC container
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 LXC 容器中静态分配 IP 地址
- en: 'Assigning an IP address inside the container is not any different than configuring
    a regular Linux server. While attached to the container, run the following commands:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器内部分配 IP 地址与配置常规 Linux 服务器没有什么不同。在容器内运行以下命令：
- en: '[PRE32]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To make the change persistent, edit the file as follows, then stop and start
    the container:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为使更改持久化，按如下方式编辑文件，然后停止并启动容器：
- en: '[PRE33]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s use the `brctl` utility to see what MAC addresses the bridge knows about:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `brctl` 工具查看桥接了解哪些 MAC 地址：
- en: '[PRE34]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Notice how this is the MAC of the `veth366R6F` virtual interface and the bridge,
    as listed by `ifconfig` on the host from the earlier output.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是 `veth366R6F` 虚拟接口和桥接的 MAC 地址，正如之前在主机上通过 `ifconfig` 输出所列示的那样。
- en: Overview of LXC network configuration options
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LXC 网络配置选项概览
- en: 'Let''s examine the network configuration for the `br1` container we built earlier:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看之前构建的 `br1` 容器的网络配置：
- en: '[PRE35]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: An impoing to note is the `lxc.network.hwaddr` option. It is the MAC of `eth0`
    inside the container that was dynamically generated for us. All of the configuration
    options can be changed, before or after the creation of the container.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是 `lxc.network.hwaddr` 选项。它是容器内部的 `eth0` 的 MAC 地址，是动态生成的。所有配置选项都可以在容器创建之前或之后进行更改。
- en: 'The following table describes briefly what network configuration options are
    available to the container:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下表简要描述了容器可用的网络配置选项：
- en: '| **Option** | **Description** |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| **选项** | **描述** |'
- en: '| `lxc.network.type` | The type of network virtualization to be used |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `lxc.network.type` | 要使用的网络虚拟化类型 |'
- en: '| `lxc.network.link` | The interface on the host |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `lxc.network.link` | 主机上的接口 |'
- en: '| `lxc.network.flags` | An action to perform on the interface |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `lxc.network.flags` | 对接口执行的操作 |'
- en: '| `lxc.network.hwaddr` | Sets a MAC address on the container''s interface |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `lxc.network.hwaddr` | 设置容器接口的 MAC 地址 |'
- en: '| `lxc.network.mtu` | Sets the **Maximum Transfer Unit** (**MTU**) for the
    container''s interface |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `lxc.network.mtu` | 设置容器接口的 **最大传输单元** (**MTU**) |'
- en: '| `lxc.network.name` | Specifies the interface name |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `lxc.network.name` | 指定接口名称 |'
- en: '| `lxc.network.ipv4` | The IPv4 address to be assigned to the container |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `lxc.network.ipv4` | 分配给容器的 IPv4 地址 |'
- en: '| `lxc.network.ipv4.gateway` | The IPv4 address to be used as the default gateway
    |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `lxc.network.ipv4.gateway` | 用作默认网关的 IPv4 地址 |'
- en: '| `lxc.network.ipv6` | The IPv6 address to be assigned to the container |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `lxc.network.ipv6` | 分配给容器的 IPv6 地址 |'
- en: '| `lxc.network.ipv6.gateway` | The IPv6 address to be used as the default gateway
    |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `lxc.network.ipv6.gateway` | 用作默认网关的 IPv6 地址 |'
- en: '| `lxc.network.script.up` | Specifies a script to be executed after creating
    and configuring the network |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `lxc.network.script.up` | 指定在创建和配置网络后执行的脚本 |'
- en: '| `lxc.network.script.down` | Specifies a script to be executed before destroying
    the network |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `lxc.network.script.down` | 指定在销毁网络之前执行的脚本 |'
- en: Table 5.1
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表 5.1
- en: We'll explore most of the options from this table in more detail, later in this
    chapter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章稍后更详细地探讨此表中的大多数选项。
- en: Manually manipulating the Linux bridge
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动操作 Linux 桥接
- en: Let's finish our exploration of the Linux bridge by showing a few examples of
    how to manually work with it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过展示一些如何手动操作 Linux 桥接的例子，完成对它的探索。
- en: 'We can start by showing the bridge on the host by running the following command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令，首先显示主机上的桥接器：
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To delete the bridge, the interface needs to be brought down first:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除桥接器，首先需要将接口关闭：
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, let''s create a new bridge and add one of the containers'' interfaces
    to it that is exposed on the host OS, `veth366R6F`, in this example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个新的桥接器，并将主机操作系统中暴露的容器接口之一`veth366R6F`添加到该桥接器中：
- en: '[PRE38]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The bridge has been created, but the interface associated with it needs to
    be brought up as the error, as shown here:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接器已创建，但与之关联的接口需要启动，如下所示错误：
- en: '[PRE39]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, let''s assign an IP address to the bridge that the containers can
    use as their default gateway:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们给容器可以用作默认网关的桥接器分配一个 IP 地址：
- en: '[PRE40]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Open vSwitch
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Open vSwitch
- en: '**Open vSwitch** (**OVS**) is a software switch that allows for more advanced
    network configurations, such as policy routing, **Access Control Lists** (**ACLs**),
    **Quality of Service** (**QoS**) policing, traffic monitoring, flow management,
    VLAN tagging, GRE tunneling, and more. OVS can be used as an alternative to the
    Linux bridge. In the next chapter, we''ll build a software-defined network using
    OVS and GRE tunnels to isolate a group of LXC containers, but for now, let''s
    demonstrate how to install and configure it in a way similar to the Linux bridge.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**Open vSwitch** (**OVS**) 是一种软件交换机，允许更高级的网络配置，如策略路由、**访问控制列表** (**ACLs**)、**服务质量**
    (**QoS**) 管控、流量监控、流管理、VLAN 标签、GRE 隧道等。OVS 可以作为 Linux 桥接器的替代品。在下一章中，我们将使用 OVS 和
    GRE 隧道构建一个软件定义网络，将一组 LXC 容器隔离开，但现在让我们演示如何以类似于 Linux 桥接器的方式安装和配置它。'
- en: 'Let''s start by installing the package on Ubuntu:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先在 Ubuntu 上安装这个包：
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'OVS uses a kernel module that should be loaded:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: OVS 使用一个内核模块，该模块应该被加载：
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, let''s confirm there are no switches configured:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们确认没有配置任何交换机：
- en: '[PRE43]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The following processes are started after installing the package:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 安装包后启动以下进程：
- en: '[PRE44]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `ovsdb-server` is a database engine that uses JSON RPC and can run independent
    of OVS. The `ovsdb-server` accepts connections from the `ovs-vswitchd` daemon,
    which in turn can create and modify bridges, ports, network flows, and so on.
    As a quick example, we can list the databases managed by the `ovsdb-server` process
    and the various tables it contains:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`ovsdb-server` 是一个数据库引擎，使用 JSON RPC，并且可以独立于 OVS 运行。`ovsdb-server` 接受来自 `ovs-vswitchd`
    守护进程的连接，后者可以创建和修改桥接、端口、网络流等。作为一个快速示例，我们可以列出 `ovsdb-server` 进程管理的数据库以及它包含的各种表：'
- en: '[PRE45]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `ovs-vswitchd` process is the main OVS application that controls all switches
    on the host OS.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`ovs-vswitchd` 进程是主要的 OVS 应用程序，控制主机操作系统上的所有交换机。'
- en: 'Now it''s time to create a switch and name it `lxcovs0`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建一个交换机并命名为`lxcovs0`：
- en: '[PRE46]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, assign an IP address and attach the container''s virtual interface to
    it, by creating a port:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，分配一个 IP 地址并将容器的虚拟接口连接到它，方法是创建一个端口：
- en: '[PRE47]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `veth366R6F` interface belongs to the `br1` container we built earlier
    in this chapter. To test connectivity, attach to the container, and change the
    IP address and default gateway to be the port of the OVS network:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`veth366R6F` 接口属于我们在本章早些时候创建的 `br1` 容器。为了测试连接性，进入容器，并将 IP 地址和默认网关更改为 OVS 网络的端口：'
- en: '[PRE48]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To avoid conflict with the Linux bridge, ensure the bridge is destroyed and
    the kernel module is unloaded:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为避免与 Linux 桥接器发生冲突，请确保销毁桥接器并卸载内核模块：
- en: '[PRE49]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Connecting LXC to the host network
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接 LXC 到主机网络
- en: 'There are three main modes of connecting LXC containers to the host network:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 连接 LXC 容器到主机网络有三种主要模式：
- en: Using a physical network interface on the host OS, which requires one physical
    interface on the host for each container
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用主机操作系统上的物理网络接口，这需要为每个容器分配一个物理接口：
- en: Using a virtual interface connected to the host software bridge using NAT
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个虚拟接口，通过 NAT 连接到主机软件桥接器
- en: Sharing the same network namespace as the host, using the host network device
    in the container
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与主机共享相同的网络命名空间，在容器中使用主机网络设备
- en: 'The container configuration file provides the `lxc.network.type` option as
    we saw earlier in Table 5.1\. Let''s take a look at the available parameters for
    that configuration option:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 容器配置文件提供了`lxc.network.type`选项，如我们之前在表5.1中看到的。让我们来看一下该配置选项的可用参数：
- en: '| **Parameter** | **Description** |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **描述** |'
- en: '| `none` | The container will share the host''s network namespace. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `none` | 容器将共享主机的网络命名空间。 |'
- en: '| `empty` | LXC will create only the loopback interface. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `empty` | LXC 只会创建回环接口。 |'
- en: '| `veth` | A virtual interface is created on the host and connected to interface
    inside the container''s network namespace. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `veth` | 在主机上创建一个虚拟接口，并连接到容器网络命名空间中的接口。|'
- en: '| `vlan` | Creates a VLAN interface linked to the device specified with `lxc.network.link`.
    The VLAN ID is specified with the `lxc.network.vlan.id` option. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `vlan` | 创建一个 VLAN 接口，该接口与通过 `lxc.network.link` 指定的设备连接。VLAN ID 通过 `lxc.network.vlan.id`
    选项指定。|'
- en: '| `macvlan` | Allows a single physical interface to be associated with multiple
    IPs and MAC addresses. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `macvlan` | 允许一个物理接口与多个 IP 地址和 MAC 地址关联。|'
- en: '| `phys` | Assigns a physical interface from the host to the container, using
    the `lxc.network.link` option. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `phys` | 使用 `lxc.network.link` 选项将主机上的物理接口分配给容器。|'
- en: Let's explore the network configurations in more details.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探讨网络配置。
- en: Configuring LXC using none network mode
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 none 网络模式配置 LXC
- en: 'In this mode, the container will share the same network namespace as the host.
    Let''s configure the `br1` container we created in the beginning of this chapter
    for that mode:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模式下，容器将与主机共享相同的网络命名空间。让我们配置本章开始时创建的 `br1` 容器以使用该模式：
- en: '[PRE50]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Stop and start the container for the new network options to take effect, and
    attach to the container:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 停止并重新启动容器以使新的网络选项生效，并附加到容器：
- en: '[PRE51]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let''s check the interface configuration and network routes inside the container:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查容器内部的接口配置和网络路由：
- en: '[PRE52]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Not surprisingly, the network interfaces and routes inside the container are
    the same as those on the host OS, since both share the same root network namespace.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 不出所料，容器内部的网络接口和路由与主机操作系统上的相同，因为两者共享相同的根网络命名空间。
- en: 'Let''s check the network connectivity while attached to the container:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在附加到容器时检查网络连接：
- en: '[PRE53]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Tip
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Stopping the container in this mode will cause the host OS to shutdown, so be
    careful.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模式下停止容器将导致主机操作系统关闭，因此请小心。
- en: Configuring LXC using empty network mode
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用空网络模式配置 LXC
- en: 'The `empty` mode only creates the loopback interface in the container. The
    configuration file looks similar to the following output:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`empty` 模式只会在容器中创建回环接口。配置文件看起来类似于以下输出：'
- en: '[PRE54]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Restart the container and attach to it, so we can verify the loopback interface
    is the only device present:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动容器并附加到它，以便我们验证回环接口是唯一存在的设备：
- en: '[PRE55]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let''s check the interface configuration and network routes inside the container:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查容器内部的接口配置和网络路由：
- en: '[PRE56]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As expected, only the loopback interface is present and no routes are configured.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，只有回环接口存在，且未配置任何路由。
- en: Configuring LXC using veth mode
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 veth 模式配置 LXC
- en: The NAT mode is the default network mode when creating containers using the
    LXC template scripts or the libvirt userspace tools. In this mode, the container
    can reach the outside world using IP masquerading with `iptables` rules applied
    on the host. All examples we saw in previous chapters use the `veth` mode.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: NAT 模式是使用 LXC 模板脚本或 libvirt 用户空间工具创建容器时的默认网络模式。在此模式下，容器可以使用主机上应用的 `iptables`
    规则通过 IP 伪装访问外部世界。我们在前几章看到的所有示例都使用了 `veth` 模式。
- en: In this mode, LXC creates a virtual interface on the host named something like
    `veth366R6F`. This is one end of the virtual connection from the container and
    it should be connected to the software bridge. The other end of the connection
    is the interface inside the container, by default named `eth0`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模式下，LXC 会在主机上创建一个虚拟接口，命名类似 `veth366R6F`。这是容器虚拟连接的一端，应该连接到软件桥接器。连接的另一端是容器内部的接口，默认名为
    `eth0`。
- en: 'The following diagram helps visualize the network configuration:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示意图有助于可视化网络配置：
- en: '![Configuring LXC using veth mode](img/image_05_002.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![使用 veth 模式配置 LXC](img/image_05_002.jpg)'
- en: LXC in veth mode
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: LXC 的 veth 模式
- en: 'The container configuration is displayed here:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的是容器的配置：
- en: '[PRE57]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `lxc.network.link` option specifies the network device on the host the virtual
    interface should connect to, in this case, the `lxcovs0` OVS switch that was created
    earlier.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`lxc.network.link` 选项指定虚拟接口应该连接的主机网络设备，在这种情况下是先前创建的 `lxcovs0` OVS 交换机。'
- en: 'Notice the `iptables` masquerade rule that was applied on the host:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在主机上应用的 `iptables` 伪装规则：
- en: '[PRE58]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Tip
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If for some reason the `iptables` rule is not present, or you would like to
    build a container that is on a different subnet, adding a new rule can be done
    with the `iptables -t nat -A POSTROUTING -s 10.3.0.0/24 -o eth0 -j MASQUERADE`
    command.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因`iptables`规则不存在，或者你希望构建一个位于不同子网中的容器，可以使用`iptables -t nat -A POSTROUTING
    -s 10.3.0.0/24 -o eth0 -j MASQUERADE`命令添加新规则。
- en: Configuring LXC using phys mode
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用物理模式配置LXC
- en: In this mode, we specify a physical interface from the host with the `lxc.network.link`
    configuration option, which will get assigned to the network namespace of the
    container and then make it unavailable for use by the host.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模式下，我们通过`lxc.network.link`配置选项指定主机的物理接口，该接口将分配给容器的网络命名空间，并使主机无法使用该接口。
- en: 'The following diagram helps visualize the network configuration:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表帮助可视化网络配置：
- en: '![Configuring LXC using phys mode](img/image_05_003.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![使用物理模式配置LXC](img/image_05_003.jpg)'
- en: LXC in phys mode
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 物理模式下的LXC
- en: 'Let''s take a look at the configuration file:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看配置文件：
- en: '[PRE59]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We specify `phys` as the mode of networking, `eth1` as the interface from the
    host that will be moved in the container''s namespace, and the IP and MAC addresses
    of `eth1`. Let''s take a look at all network interfaces on the host first:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定`phys`作为网络模式，`eth1`作为将被移动到容器命名空间中的主机接口，以及`eth1`的IP和MAC地址。让我们先查看主机上的所有网络接口：
- en: '[PRE60]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Notice that the `eth1` interface is present on the host. Let''s restart the
    `br1` container and list the host interfaces again:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`eth1`接口现在出现在主机上。让我们重启`br1`容器，并再次列出主机上的接口：
- en: '[PRE61]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `eth1` interface is not showing on the host anymore. Let''s attach to the
    container and examine its interfaces:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`eth1`接口不再显示在主机上。让我们连接到容器并检查其接口：'
- en: '[PRE62]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `eth1` interface is now a part of the container, with the same IP and MAC
    address as the original `eth1` interface from the host, because we explicitly
    specified them in the container's configuration file.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`eth1`接口成为容器的一部分，具有与主机原始`eth1`接口相同的IP和MAC地址，因为我们在容器的配置文件中显式指定了它们。
- en: If we need to have multiple containers using the `phys` mode, then we'll need
    that many physical interfaces, which is not always practical.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要多个容器使用`phys`模式，那么我们就需要那么多物理接口，但这并不总是可行的。
- en: Configuring LXC using vlan mode
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用vlan模式配置LXC
- en: The `vlan` network mode allows us to create a **Virtual LAN** (**VLAN**) tagged
    interface inside the container's network namespace. A VLAN is a broadcast domain
    that is isolated at the data link layer from the rest of the network.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`vlan`网络模式允许我们在容器的网络命名空间内创建一个**虚拟局域网**（**VLAN**）标记接口。VLAN是一个广播域，在数据链路层与网络的其余部分隔离。'
- en: The `lxc.network.link` configuration option specifies the interface the container
    should be linked to from the host and `lxc.network.vlan.id` is the tag that will
    be applied to the network traffic by the container's interface.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`lxc.network.link`配置选项指定容器应从主机连接到的接口，而`lxc.network.vlan.id`是容器接口将应用于网络流量的标签。'
- en: This mode is useful when there are multiple containers running on hosts and
    the traffic needs to be isolated between subsets of containers, thus creating
    a logical network separation. We demonstrated similar concepts with VLAN tags
    when we talked about network namespaces in [Chapter 1](ch01.html "Chapter 1. Introduction
    to Linux Containers"), *Introduction to Linux Containers*.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当主机上运行多个容器，并且需要在容器子集之间隔离流量时，这种模式非常有用，从而实现逻辑上的网络分离。我们在[第1章](ch01.html "第1章。Linux容器简介")中通过VLAN标签演示了类似的概念，*Linux容器简介*。
- en: 'To create a container that will be tagging Ethernet packets, the configuration
    should look similar to the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个将标记以太网数据包的容器，配置应类似于以下内容：
- en: '[PRE63]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We specify a VLAN ID of `100` and `eth1` as the interface the container will
    be paired with. Restart the container and attach to it:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定VLAN ID `100`和`eth1`作为容器将配对的接口。重启容器并连接到它：
- en: '[PRE64]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Let''s examine the `eth0` interface from the container and ensure it''s configured
    to tag packets with a VLAN ID of `100`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查容器中的`eth0`接口，确保它已配置为使用VLAN ID `100`标记数据包：
- en: '[PRE65]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Notice how the `eth0` interface is named `eth0@if3`. Here, `if3` means that
    the container''s interface is paired with the host interface that has an ID of
    `3`, in our case `eth1`. We can see that by running the following command on the
    host:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`eth0`接口被命名为`eth0@if3`。这里，`if3`意味着容器的接口与主机接口ID为`3`的接口配对，在我们的例子中是`eth1`。我们可以通过在主机上运行以下命令来查看这一点：
- en: '[PRE66]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Now you can configure `eth0` inside the container to be part of the same subnet
    as the `eth1` interface on the host.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以配置容器内的`eth0`接口，使其属于与主机上`eth1`接口相同的子网。
- en: Configuring LXC using macvlan mode
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置LXC使用macvlan模式
- en: 'The `macvlan` network mode allows for a single physical interface on the host
    to be associated with multiple virtual interfaces having different IP and MAC
    addresses. There are three modes that `macvlan` can operate in:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`macvlan`网络模式允许将主机上的单个物理接口与多个具有不同IP和MAC地址的虚拟接口关联。`macvlan`可以在以下三种模式下操作：'
- en: '**Private**: This mode disallows communication between LXC containers'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有**：此模式不允许LXC容器之间进行通信'
- en: '**Virtual Ethernet Port Aggregator** (**VEPA**): This mode disallows communication
    between LXC containers unless there''s a switch that works as a reflective relay'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟以太网端口聚合器** (**VEPA**)：此模式不允许LXC容器之间进行通信，除非有一个作为反射中继的交换机'
- en: '**Bridge**: This mode creates a simple bridge (not to be confused with the
    Linux bridge or OVS), which allows containers to talk to each other, but it isolates
    them from the host.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**桥接**：此模式创建一个简单的桥接（与Linux桥接或OVS不同），允许容器之间相互通信，但将它们与主机隔离开来。'
- en: 'Let''s configure the `br1` container to use `macvlan` in `bridge` mode:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们配置`br1`容器，使用`macvlan`的`bridge`模式：
- en: '[PRE67]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The device that we specify with `lxc.network.link` is the bridged interface
    we are going to create next:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`lxc.network.link`指定的设备是我们接下来要创建的桥接接口：
- en: '[PRE68]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'With the `macvlan` bridged interface up, we can start the container and examine
    its network interfaces:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在`macvlan`桥接接口启用后，我们可以启动容器并检查其网络接口：
- en: '[PRE69]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Notice the `if3` ID of the `eth0` interface in the container matches the `eth1`
    ID on the host. We can now assign an IP address to the `eth0` interface from the
    same subnet as `eth1` on the host and be able to reach other containers in the
    same subnet. This mode is similar to using the Linux bridge or OVS, but without
    the overhead of each. Also notice that the containers will not be able to communicate
    with the host directly.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，容器中`eth0`接口的`if3` ID与主机上的`eth1` ID相匹配。现在我们可以为`eth0`接口分配一个与主机上`eth1`相同子网的IP地址，并能够访问同一子网中的其他容器。此模式类似于使用Linux桥接或OVS，但没有它们各自的开销。同时请注意，容器将无法直接与主机通信。
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you became familiar with the Linux Bridge and learned how to
    connect LXC containers to it. We also looked at Open vSwitch as an alternative
    to the Linux bridge. We then explored the various network configuration options
    that LXC presents and saw few examples.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你熟悉了Linux桥接，并学会了如何将LXC容器连接到它。我们还了解了Open vSwitch作为Linux桥接的替代方案。接着我们探索了LXC提供的各种网络配置选项，并查看了几个示例。
- en: We ended the chapter by demonstrating how to connect LXC to the host network
    and to other containers using, NAT, VLAN, direct connect, and more advanced nodes
    such as MAC VLAN.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，我们演示了如何使用NAT、VLAN、直接连接以及更先进的节点（如MAC VLAN）将LXC连接到主机网络和其他容器。
- en: In the next chapter, we are going to put all the knowledge you gained so far
    into practice, by building a highly available and scalable application deployment
    using LXC and HAProxy.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把到目前为止获得的所有知识付诸实践，构建一个使用LXC和HAProxy的高可用、可扩展的应用程序部署。
