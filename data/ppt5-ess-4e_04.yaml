- en: Combining Resources in Classes and Defined Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在类和定义类型中结合资源
- en: At this point, you have already performed some production-grade tasks with Puppet.
    You learned how to write standalone manifests and then invoke `puppet apply` to
    put them to use. While setting up your first Puppet master and agent, you created
    a simple example for a node manifest on the master. In a `node '<hostname>'` block,
    you created the equivalent of a manifest file. This way, the Puppet master used
    just this manifest for the specified agent node.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经使用 Puppet 执行了一些生产级任务。您学习了如何编写独立的 Manifest，并使用 `puppet apply` 来应用它们。在设置您的第一个
    Puppet 主控和代理时，您在主控上为节点 Manifest 创建了一个简单的示例。在 `node '<hostname>'` 块中，您创建了一个 Manifest
    文件的等效物。这样，Puppet 主控就只使用特定代理节点的这个 Manifest。
- en: While this is all useful and essentially important, it will obviously not suffice
    for daily business. By working with `node` blocks that contain sets of resources,
    you will end up performing lots of copy and paste operations for similar nodes,
    and the whole construct will become unwieldy very quickly. This is an unnatural
    approach to developing Puppet manifests. Despite the great differences to many
    other languages that you might be familiar with, the Puppet DSL is a programming
    language. Building manifests merely from `node` blocks and resources would be
    the same as writing C with no functions except `main`, or Ruby without any classes
    of your own.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些内容非常有用且基本重要，但显然不足以应对日常业务需求。通过使用包含一组资源的 `node` 块，您将不得不对类似节点执行大量的复制和粘贴操作，整个结构会迅速变得难以管理。这是一种不自然的方法来开发
    Puppet Manifest。尽管与您熟悉的许多其他语言存在显著差异，但 Puppet DSL 是一种编程语言。仅仅通过 `node` 块和资源来构建 Manifest
    与仅仅编写只有 `main` 函数的 C 程序或没有自定义类的 Ruby 代码是一样的。
- en: The manifests that you can write with the means that are already at your disposal
    are not flat, you learned about common control structures such as `if` and `case`.
    Your manifests can use these to adapt to various circumstances on the agent by
    querying the values of Facter facts and branching in accordance with the results.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用已经掌握的工具编写的 Manifest 并不是平面的。您学习了诸如 `if` 和 `case` 等常见的控制结构，您的 Manifest 可以使用这些结构根据
    Facter 事实的值查询并根据结果进行分支。
- en: 'However, these constructs should be complemented by the language tools to create
    reusable units of manifest code, similar to functions or methods in procedural
    languages. This chapter introduces these concepts through the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些结构应该由语言工具来补充，以创建可重复使用的代码单元，类似于过程化语言中的函数或方法。本章通过以下主题介绍这些概念：
- en: Introducing classes and defined types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入类和定义类型
- en: Design patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模式
- en: The dynamic aspect of defined types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已定义类型的动态方面
- en: Ordering and events among classes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类之间的排序和事件
- en: Making classes more flexible through parameters
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过参数使类更加灵活
- en: Introducing classes and defined types
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入类和定义类型
- en: 'Puppet''s equivalents to methods or functions are twofold: there are **classes**
    on one hand and defined types (also just referred to as defines) on the other.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 的方法或函数的等效物有两种：一方面是**类**，另一方面是定义类型（也简称为定义）。
- en: You will find that the function analogy is a bit weak for classes, but fits
    defined types quite well.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现，对于类来说，函数类比有些薄弱，但对于定义类型来说非常合适。
- en: They are similar at first glance, in that they both hold a chunk of reusable
    Puppet DSL code. There are big differences in the way each is used though. Let's
    take a look at classes first.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看它们很相似，因为它们都包含一块可重用的 Puppet DSL 代码块。但它们在使用方式上有很大的区别。让我们先看看类。
- en: Defining and declaring classes
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义和声明类
- en: A Puppet class can be considered to be a container containing collections of
    Puppet resource declarations. It is created once (class definition) and used by
    all nodes that need to make use of the prepared functionality. Each class represents
    a well-known subset of a system's configuration, such as `ntp`, `nginx`, and `ssh`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 类可以被认为是包含 Puppet 资源声明集合的容器。它只创建一次（类定义），并被所有需要使用准备好的功能的节点使用。每个类代表系统配置的一个众所周知的子集，例如
    `ntp`、`nginx` 和 `ssh`。
- en: 'For example, a classic use `case` is a class that installs the Apache web server
    and applies some basic settings. This class will look the same as the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个经典的用例 `case` 是一个安装 Apache Web 服务器并应用一些基本设置的类。这个类看起来与以下内容相同：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'All web server nodes will make use of this class. To this end, their manifests
    need to contain a simple statement:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Web 服务器节点将使用这个类。为此，它们的清单需要包含一个简单的声明：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is referred to as including a class, or declaring it. If your `apache`
    class is powerful enough to do all that is needed, this line might fully comprise
    a `node` block''s content:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这称为包含一个类，或者声明它。如果你的 `apache` 类足够强大，可以完成所有必要的任务，那么这一行可能会完全构成 `node` 块的内容：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In your own setup, you will probably not write your own Apache class. You can
    use open source classes that are available through Puppet modules. [Chapter 5](3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml),
    *Combining Classes, Configuration Files, and Extensions into Modules*, will give
    you all the details.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在你自己的设置中，可能不会编写自己的 Apache 类。你可以使用通过 Puppet 模块提供的开源类。[第 5 章](3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml)，*将类、配置文件和扩展组合成模块*，将为你提供所有详细信息。
- en: This concludes our tour of classes in a nutshell. There is yet more to discuss,
    of course, but let's take a look at defined types before that.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们对类的简要概述。虽然还有更多内容要讨论，但我们还是先来看一下已定义类型。
- en: Creating and using defined types
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和使用已定义类型
- en: A defined type can be regarded as a new resource type which makes use of existing
    resource types. This is useful when you have repeating instances of existing resource
    types, as you can wrap them in a defined type. As a class, it consists mainly
    of a body containing the manifest code. However, a defined type takes arguments
    and makes their values available in its body as local variables.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 已定义类型可以看作是一个新的资源类型，它利用了现有的资源类型。当你有多个相同的现有资源类型实例时，使用已定义类型非常有用，因为你可以将它们包装在已定义类型中。作为一个类，它主要由一个包含清单代码的主体构成。然而，已定义类型接收参数，并将这些参数的值作为局部变量在其主体中使用。
- en: 'Here is another typical example of a defined type, the Apache virtual host
    configuration:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个典型的已定义类型示例，即 Apache 虚拟主机配置：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Data types such as `String` have been available since Puppet 4\. In Puppet 3
    and earlier, you would have just skipped these; all variables used to be untyped.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型如 `String` 从 Puppet 4 开始就已可用。在 Puppet 3 及之前的版本中，你会直接跳过这些；所有变量曾经都是无类型的。
- en: 'This code might still seem pretty cryptic. It will become clearer in the context
    of how it is actually used from other places in your manifest; the following code
    shows you how:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可能看起来还是很晦涩。从实际使用它的其他地方来看，它会变得更加清晰；下面的代码展示了如何使用：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is why the construct is called a defined type; you can now place what appear
    to be resources in your manifest, but you really call your own manifest code construct.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么这个构造被称为已定义类型；你现在可以在清单中放置看似是资源的内容，但实际上你是在调用你自己定义的清单代码构造。
- en: 'When declaring multiple resources of the same type, as in the preceding code,
    you can do so in a single block and separate them with a semicolon:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当声明多个相同类型的资源时，如前面的代码所示，你可以在一个块中进行声明，并用分号分隔它们：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The official style guide forbids this syntax, but it can make manifests more
    readable and maintainable in some cases.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 官方风格指南禁止使用这种语法，但在某些情况下，它确实可以使清单更具可读性和可维护性。
- en: 'The `virtual_host` type takes two arguments: the `content` argument is mandatory
    as it has no default value and is used verbatim in the configuration file resource.
    Puppet will synchronize that file''s content to what is specified in the manifest.
    The `priority` argument is optional and its value becomes the file name prefix.
    If omitted, the respective virtual host definition uses the default priority of
    `050`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`virtual_host` 类型接受两个参数：`content` 参数是必需的，因为它没有默认值，并且在配置文件资源中按原样使用。Puppet 将同步该文件的内容为清单中指定的内容。`priority`
    参数是可选的，它的值将作为文件名的前缀。如果省略该参数，相应的虚拟主机定义将使用默认优先级 `050`。'
- en: Both parameters of this example type are of the `String` type. For details about
    Puppet's variable type system, see [Chapter 5](3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml),
    *Combining Classes, Configuration Files, and Extensions into Modules*. It suffices
    to say that you can restrict parameters to certain value types. This is optional,
    however. You can omit the type name, and Puppet will accept any value for the
    parameter in question.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例类型的两个参数都是 `String` 类型。有关 Puppet 变量类型系统的详细信息，请参见 [第 5 章](3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml)，*将类、配置文件和扩展组合成模块*。可以简要地说，你可以将参数限制为某些值类型。然而，这并非强制要求。你可以省略类型名，Puppet
    将接受该参数的任何值。
- en: Also, each defined type can implicitly refer to the name (or title) by which
    it was called. In other words, each instance that you define gets a name, and
    you can access it through the `$name` or `$title` variable.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个定义的类型可以隐式引用它被调用时的名称（或标题）。换句话说，您定义的每个实例都会有一个名称，您可以通过 `$name` 或 `$title`
    变量访问它。
- en: There are a few other *magic* variables that are available in the body of a
    defined type. If a resource of the defined type is declared with a metaparameter
    such as `require => ...`, its value can be accessed through the `$require` variable
    in the body. The variable value remains empty if the metaparameter is not used.
    This works for metaparameters, such as `before`, `notify`, and all the others,
    but you will probably never need to make use of this. The metaparameters automatically
    do the right thing.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义类型的主体中，有一些其他的 *魔法* 变量是可用的。如果一个定义类型的资源声明了像 `require => ...` 这样的元参数，它的值可以通过
    `$require` 变量在主体中访问。如果没有使用元参数，则该变量值为空。这适用于诸如 `before`、`notify` 等所有元参数，但您可能永远不需要使用这些。元参数会自动做出正确的处理。
- en: Understanding and leveraging the differences
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解并利用差异
- en: The respective purposes of Puppet's class and defined type are very specific
    and they usually don't overlap.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 的类和定义类型各自的目的非常明确，通常不会重叠。
- en: The class declares resources and properties that are in some way centric to
    the system. A class is a finalized description of one, or sometimes more, aspect
    of your system as a whole. Whatever the class represents, it can only ever exist
    in one form; to Puppet, each class is implicitly a singleton, a fixed set of information
    that either applies to your system (the class is included), or not.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 类声明了与系统某种方式相关的资源和属性。类是您系统中一个或多个方面的最终描述。无论类表示什么，它都只能以一种形式存在；对于 Puppet 来说，每个类本质上是一个单例，是一个固定的信息集，要么应用于您的系统（类被包含），要么不应用。
- en: 'The typical resources you will encapsulate in a class for convenient inclusion
    in a manifest are as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在类中封装并方便地包含在清单中的典型资源如下：
- en: One or more packages that should be installed (or removed)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个应该安装（或移除）的包
- en: A specific configuration file in `/etc`
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc` 中的特定配置文件'
- en: A common directory, needed to store scripts or configs for many subsystems
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存储许多子系统脚本或配置文件的常用目录
- en: Cron jobs that should be mostly identical on all applicable systems
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该在所有适用系统中几乎相同的 Cron 作业
- en: 'The define is used for all things that exist in multiple instances. All aspects
    that appear in varying quantities in your system can possibly be modeled using
    this language construct. In this regard, the define is very similar to the full-fledged
    resource it mimics with its declaration syntax. Some of the typical contents of
    defined types are:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`define` 用于所有存在多个实例的事物。所有在系统中以不同数量出现的方面都可以使用这种语言结构建模。从这个角度来看，`define` 与其声明语法所模拟的完整资源非常相似。定义类型的典型内容包括：'
- en: Files in a `conf.d` style directory
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`conf.d` 风格目录中的文件'
- en: Entries in an easily parseable file such as `/etc/hosts`
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如 `/etc/hosts` 之类的易于解析文件中的条目
- en: Apache virtual hosts
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache 虚拟主机
- en: Schemas in a database
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库中的模式
- en: Rules in a firewall
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防火墙中的规则
- en: 'The class''s singleton nature is especially valuable because it prevents clashes
    in the form of multiple resource declarations. Remember that each resource must
    be unique to a catalog. For example, consider a second declaration of the Apache
    package:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的单例特性尤为重要，因为它防止了多次资源声明的冲突。请记住，每个资源必须对一个目录是唯一的。例如，考虑 Apache 包的第二次声明：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This declaration can be anywhere in the manifest of one of your web servers
    (for example, right in the `node` block, next to `include apache`); this additional
    declaration will prevent the successful compilation of a catalog.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 该声明可以出现在您的一个 Web 服务器的清单中的任何位置（例如，直接在 `node` 块中，紧挨着 `include apache`）；这个额外的声明将防止目录的成功编译。
- en: The reason for the prevention of a successful compilation is that Puppet currently
    cannot make sure that both declarations represent the same target state, or can
    be merged to form a composite state. It is likely that multiple declarations of
    the same resource may conflict about the desired value of property (for example,
    one declaration might want to ensure that a package is `absent`, while the other
    needs it to be `present`). You want to see Puppet as a declarative description
    of your system configuration state.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 阻止成功编译的原因是Puppet目前无法确保两个声明表示相同的目标状态，或者可以合并成一个复合状态。可能多个相同资源的声明会在属性的期望值上发生冲突（例如，一个声明可能希望确保一个包是`absent`，而另一个声明则需要它是`present`）。你应该将Puppet视为对系统配置状态的声明性描述。
- en: The virtue of the class is that there can be an arbitrary number of `include`
    statements for the same class strewn throughout the manifest. Puppet will commit
    the class's contents to the catalog just once.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的优点是可以在清单中任意数量地添加相同类的`include`语句。Puppet只会将该类的内容提交到目录一次。
- en: 'The uniqueness constraint for resources applies to defined types. No two instances
    of your own define can share the same name. Using a name twice or more produces
    a compiler error:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 资源的唯一性约束适用于已定义的类型。你自己定义的两个实例不能共享相同的名称。使用相同的名称两次或更多次会导致编译错误：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Design patterns
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式
- en: Your knowledge of classes and defined types is still rather academic. You have
    learned about their defining aspects and the syntax to use them, but we have yet
    to give you a feeling of how these concepts come to bear in different real-life
    scenarios.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你对类和定义类型的了解仍然偏学术化。你已经学习了它们的定义方面以及使用它们的语法，但我们还没有让你体会这些概念在不同实际场景中的应用。
- en: The following sections will present an overview of what you can do with these
    language tools.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将概述你可以使用这些语言工具做什么。
- en: Writing comprehensive classes
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写全面的类
- en: 'Many classes are written to make Puppet perform momentous tasks on the agent
    platform. Of these, the Apache class is probably one of the more modest examples.
    You can conceive a class that can be included from any machine''s manifest and
    make sure that the following conditions are met:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 许多类被编写来让Puppet在代理平台上执行重要任务。在这些类中，Apache类可能是一个较为简单的例子。你可以设想一个类，它可以从任何机器的清单中包含，并确保满足以下条件：
- en: The firewalling software is installed and configured with a default ruleset
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防火墙软件已安装并配置了默认规则集。
- en: The malware detection software is installed
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恶意软件检测软件已安装。
- en: Cron jobs run the scanners at set intervals
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时任务按照设定的时间间隔运行扫描器。
- en: The mailing subsystem is configured to make sure the cron jobs can deliver their
    output
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邮件子系统已配置，以确保定时任务能够传递其输出。
- en: There are two general ways you can go about the task of creating a class of
    this magnitude. It can either become what one might call a **monolithic** implementation,
    a class with a large body that comprises all resources that work together to form
    the desired security baseline. This approach has the benefit of precisely describing
    your infrastructure, but it lacks maintainability. On the other hand, you could
    aim for a **composite** design, with few resources (or none at all) in the class
    body, and a number of `include` statements for simpler classes instead. The functionality
    is compartmentalized, and the central class acts as a collector. This is the common
    best practice way in which Puppet module developers work.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此类规模的类有两种常见方法。它可以成为所谓的**单体**实现，一个包含所有资源的大型类，这些资源共同工作以形成期望的安全基线。这种方法的优点是能准确描述你的基础设施，但缺乏可维护性。另一方面，你可以选择**组合**设计，类的主体中几乎没有资源（或者根本没有），而是通过多个`include`语句来包含较简单的类。功能被模块化，中心类充当收集器。这是Puppet模块开发人员常用的最佳实践方式。
- en: We have not yet touched on the ability of classes to include other classes.
    That's because it's quite simple. The body of a class can comprise almost any
    manifest, and the `include` statement is no exception. Among the few things that
    cannot appear in a class are `node` blocks.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有涉及类包含其他类的能力。这是因为这非常简单。类的主体几乎可以包含任何清单，`include`语句也不例外。类中唯一不能出现的几个元素之一就是`node`块。
- en: 'Adding some life to the descriptions, this is roughly what the respective classes
    will look like:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 给描述增添一些生动的元素，大致上各个类将呈现如下样子：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When developing your own functional classes, you should not try to pick either
    of these extremes. Most classes will end up anywhere on the spectrum in between.
    The choice can be largely based on your personal preference. The technical implications
    are subtle, but these are the respective drawbacks:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发自己的功能类时，您不应选择这两种极端中的任何一种。大多数类最终会位于这两者之间的某个位置。选择可以在很大程度上基于个人偏好。技术上的影响是微妙的，但它们各自的缺点如下：
- en: Consequently aiming for monolithic classes opens you up to resource clashes,
    because you take almost no advantage of the singleton nature of classes
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，追求单体类可能会导致资源冲突，因为您几乎没有利用类的单例特性。
- en: Splitting up classes too much can make it difficult to impose order and distribute
    refresh events, you can refer to the Combining classes, configuration files and
    extensions into Modules section later in this chapter
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将类拆分得过于细碎会使得施加秩序和分配刷新事件变得困难，您可以参考本章稍后的“将类、配置文件和扩展组合成模块”部分。
- en: Neither of these aspects is of critical importance at most times. The case-by-case
    design choices will be based on each author's experience and preference. When
    in doubt, lean towards composite designs at first.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，这些方面并不是至关重要的。逐案设计选择将基于每个作者的经验和偏好。在不确定的情况下，首先倾向于选择组合设计。
- en: Writing component classes
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写组件类
- en: There is another common use case for classes. Instead of filling a class with
    lots of aspects that work together to achieve a complex goal, you can also limit
    the class to a very specific purpose. Some classes will contain just one resource.
    The class wraps the resource, so to speak.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个类的常见使用案例。您不仅可以将一个类填充很多协同工作的方面来实现复杂的目标，还可以将类限制为非常特定的目的。有些类只包含一个资源。可以说，这个类将该资源包装起来。
- en: This is useful for resources that are needed in different contexts. By wrapping
    them away in a class, you can make sure that those contexts do not create multiple
    declarations of the same resource.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于在不同上下文中需要的资源非常有用。通过将它们包装在一个类中，您可以确保这些上下文不会产生同一资源的多次声明。
- en: 'For example, the `netcat` package can be useful to firewall servers, but also
    to web application servers. There is probably a `firewall` class and an `appserver`
    class. Both declare the `netcat` package:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`netcat`包对防火墙服务器很有用，也可以对 Web 应用服务器有用。可能会有一个`firewall`类和一个`appserver`类。两个类都声明了`netcat`包：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If any server ever has both roles (this might happen for budget reasons or
    in other unforeseen circumstances), it is a problem; when both the `firewall`
    and `appserver` classes are included, and the resulting manifest declares the
    `netcat` package twice. This is forbidden. To resolve this situation, the package
    resource can be wrapped in a `netcat` class, which is included by both the `firewall`
    and `appserver` classes:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个服务器同时具有两个角色（这可能由于预算原因或其他不可预见的情况发生），这将成为一个问题；当同时包含`firewall`和`appserver`类时，结果清单会声明两次`netcat`包。这是禁止的。为了解决这个问题，`netcat`包资源可以被包装在一个`netcat`类中，这个类由`firewall`和`appserver`类共同引用：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s consider another typical example for component classes that ensures
    the presence of a common file path. Assume your IT policy requires all custom
    scripts and applications to be installed in `/opt/company/bin`. Many classes,
    such as `firewall` and `appserver` from the previous example, will need some relevant
    content there. Each class needs to make sure that the directories exist before
    a script can be deployed inside it. This will be implemented by including a component
    class that wraps the `file` resources of the `directory` tree:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个典型的组件类示例，它确保一个公共文件路径的存在。假设您的 IT 政策要求所有自定义脚本和应用程序都安装在`/opt/company/bin`目录下。许多类，如前面例子中的`firewall`和`appserver`，都需要在这里放置一些相关内容。每个类都需要确保在部署脚本之前，相关目录已经存在。可以通过包含一个组件类来实现，该类包装了`directory`树中的`file`资源：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The component class is a pretty precise concept. However, as you have seen in
    the previous section about the more powerful classes, the whole range of possible
    class designs forms a fine-grained scale between the presented examples. All manifests
    you write will likely comprise more than a few classes. The best way to get a
    feeling for the best practices is to just go ahead and use classes to build the
    manifests you need.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 组件类是一个相当精确的概念。然而，正如您在前一节关于更强大类的部分中看到的那样，所有可能的类设计形式构成了一个细致的尺度，介于所呈现的例子之间。您编写的所有清单很可能会包含多个类。获得最佳实践的最佳方式是直接使用类来构建您所需要的清单。
- en: The terms **comprehensive** class and **component** class are not official Puppet
    language, and the community does not use them to communicate design practices.
    We chose them arbitrarily to describe the ideas we laid out in these sections.
    The same holds `true` for the descriptions of the use cases for defined types,
    which will be seen in the next sections.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**全面**类和**组件**类这些术语并不是官方的Puppet语言，社区也不会用它们来传达设计实践。我们随意选择它们来描述我们在这些章节中阐述的思想。对定义类型的用例描述也是如此，接下来的章节中将会看到这些用例。'
- en: Next, let's look at some uses for defined types.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看一下定义类型的一些用途。
- en: Using defined types as resource wrappers
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用定义类型作为资源包装器
- en: For all their apparent similarity to classes, defined types are used in different
    ways. For example, the component class was described as *wrapping a resource*.
    This is accurate in a very specific context, the wrapped resource is a singleton,
    and it can only appear in one form throughout the manifest.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管定义类型与类看似相似，但它们的使用方式有所不同。例如，组件类被描述为*封装一个资源*。这在一个非常特定的上下文中是准确的，封装的资源是一个单例，并且在整个清单中只能以一种形式出现。
- en: When wrapping a resource in a defined type instead, you end up with a variation
    on the respective resource type. The manifest can contain an arbitrary number
    of instances of the defined type, and each will wrap a distinct resource.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当将资源包装在定义类型中时，你最终会得到相应资源类型的变种。清单中可以包含任意数量的定义类型实例，每个实例将封装一个不同的资源。
- en: For this to work, the name of the resource that is declared in the body of the
    defined type must be dynamically created. It is almost always the `$name` variable
    of the respective defined type instance, or a value derived from it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其生效，在定义类型的主体中声明的资源名称必须是动态创建的。它几乎总是相应定义类型实例的`$name`变量，或者是从它派生的值。
- en: 'Here is yet another typical example from the many manifests out there: most
    users who make use of Puppet''s file serving capabilities will want to wrap the
    `file` type at some point so that the respective URL need not be typed for each
    file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个来自许多清单中的典型示例：大多数使用Puppet文件服务功能的用户，都会希望在某个时候包装`file`类型，这样就无需为每个文件单独输入相应的URL：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This makes it easy to get Puppet to sync files from the master to the agent.
    The master copy must be properly placed in the named modules on the master:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得Puppet能够轻松地将文件从主服务器同步到代理。主服务器上的副本必须正确放置在主服务器上的命名模块中：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This resource will make Puppet retrieve the `ntp.conf` file from the `ntp`
    module. The preceding declaration is more concise and less redundant than the
    fully written file resource with the Puppet URL (especially for the large number
    of files you might need to synchronize), which would resemble the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个资源将使Puppet从`ntp`模块中检索`ntp.conf`文件。前面的声明比完全编写的文件资源和Puppet URL（尤其是你可能需要同步的大量文件）更简洁、不冗余，后者可能类似于以下内容：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For a wrapper such as `module_file`, which will probably be used very widely,
    you will want to make sure that it supports all attributes of the wrapped resource
    type. In this case, the `module_file` wrapper should accept all `file` attributes.
    For example, this is how you add the `mode` attribute to the wrapper type:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像`module_file`这样的包装器，它可能会被广泛使用，你需要确保它支持所有被包装资源类型的属性。在这种情况下，`module_file`包装器应该接受所有`file`属性。例如，以下是如何将`mode`属性添加到包装器类型中的方法：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `File { ... }` block declares some default values for all `file` resource
    attributes in the same scope. The `undef` value is similar to Ruby's `nil`, and
    is a convenient parameter default value, because it is very unlikely that a user
    will need to pass it as an actual value for the wrapped resource.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`File { ... }`块声明了相同作用域内所有`file`资源属性的默认值。`undef`值类似于Ruby中的`nil`，它是一个方便的默认参数值，因为用户不太可能需要将它作为实际值传递给被包装的资源。'
- en: 'You can employ the override syntax instead of the default syntax as well:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用覆盖语法，而不是默认语法：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This makes the intent of the code slightly more obvious, but is not necessary
    in the presence of just one `file` resource. [Chapter 6](60cec52e-6b29-4028-bc15-3b5685598e6b.xhtml),
    *The Puppet Beginners Advanced Parts*, holds more information about overrides
    and defaults.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得代码的意图稍微更明显，但在只有一个`file`资源的情况下并不是必须的。[第6章](60cec52e-6b29-4028-bc15-3b5685598e6b.xhtml)，*Puppet初学者进阶部分*，包含了更多关于覆盖和默认值的信息。
- en: Using defined types as resource multiplexers
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用定义类型作为资源多路复用器
- en: Wrapping single resources with a defined type is useful, but sometimes you will
    want to add functionality beyond the resource type you are wrapping. At other
    times, you might wish for your defined type to unify a lot of functionality, just
    as the comprehensive classes from the beginning of the section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用已定义类型包装单一资源是有用的，但有时你可能希望在你包装的资源类型之外添加额外的功能。在其他时候，你可能希望已定义类型统一很多功能，就像本节开始时的综合类一样。
- en: 'For both scenarios, what you want to have is multiple resources in the body
    of your defined type. There is a classic example for this as well:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两种情况，你需要在已定义类型的主体中有多个资源。这里也有一个经典的例子：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This code allows you to create user accounts with authorized SSH keys in one
    resource declaration. This code sample has some notable aspects:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码允许你在一个资源声明中创建具有授权 SSH 密钥的用户帐户。这个代码示例有一些显著的特点：
- en: Since you are essentially wrapping multiple resource types, the titles of all
    inner resources are derived from the instance title (or name) of the current defined
    type instance; actually, this is a required practice for all defined types
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于你基本上是在包装多个资源类型，所有内部资源的标题都是从当前已定义类型实例的实例标题（或名称）派生的；实际上，这是所有已定义类型的必备实践。
- en: You can hardcode parts of your business logic; in this example, we dispensed
    with the support for non-RSA SSH keys and defined `users` as the default group
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以硬编码业务逻辑的部分；在这个例子中，我们取消了对非 RSA SSH 密钥的支持，并将 `users` 定义为默认组。
- en: Using defined types as macros
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用已定义类型作为宏
- en: Some source code requires many repetitive tasks. Assume that your site uses
    a subsystem that relies on symbolic links at a certain location to enable configuration
    files, just as `init` does with the symlinks in `rc2.d/` and its siblings, which
    point back to `../init.d/<service>`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一些源代码需要许多重复的任务。假设你的站点使用一个子系统，该子系统依赖于某个位置的符号链接来启用配置文件，就像 `init` 使用 `rc2.d/` 及其兄弟目录中的符号链接，并指向
    `../init.d/<service>`。
- en: 'A manifest that enables a large number of configuration snippets might look
    the same as this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一个启用大量配置片段的清单可能会看起来像这样：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is tiring to read and somewhat painful to maintain. In a C program, one
    would use a preprocessor macro that just takes the base name of both link and
    target and expands to the three lines of each resource description. Puppet does
    not use a preprocessor, but you can use defined types to achieve a similar result:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码很难阅读且维护起来有点痛苦。在 C 程序中，人们会使用预处理器宏，仅使用链接和目标的基本名称，就能扩展为每个资源描述的三行代码。Puppet 不使用预处理器，但你可以使用已定义类型来实现类似的效果：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The defined type actually acts more as a simple function call than an actual
    macro.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 该已定义类型实际上更像是一个简单的函数调用，而不是一个真正的宏。
- en: 'The define requires no arguments, it can rely solely on its resource name,
    so the preceding code can now be simplified to the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 该定义不需要任何参数，它可以仅依赖于资源名称，因此前面的代码现在可以简化为以下内容：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Alternatively, the following code is even more terse:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，以下代码更加简洁：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This array notation leads us to another use of defined types.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这种数组表示法引出了已定义类型的另一种用途。
- en: Exploiting array values using defined types
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用已定义类型中的数组值
- en: One of the more common scenarios in programming is the requirement to accept
    an array value from some source and perform a task on each value. Puppet manifests
    are not exempt from this.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 编程中一个比较常见的场景是需要接受某个来源的数组值，并对每个值执行任务。Puppet 清单也不例外。
- en: Let's assume that the symbolic links from the previous example actually led
    to directories, and that each such directory would contain a subdirectory to hold
    optional links to regions. Puppet should manage those links as well.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 假设之前示例中的符号链接实际上指向的是目录，并且每个这样的目录都包含一个子目录，用于存放指向区域的可选链接。Puppet 也应该管理这些链接。
- en: 'Of course, after learning about the macro aspect of defined types, you would
    not want to add each of those regions as distinct resources to your manifest.
    However, you will need to devise a way to map region names to countries. Seeing
    as there is already a defined resource type for countries, there is a very direct
    approach to this: make the list of regions an attribute (or rather, a parameter)
    of the defined type:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在了解了已定义类型的宏观概念后，你肯定不希望将每个区域都作为单独的资源添加到你的清单中。然而，你需要设计一种方法，将区域名称映射到国家。既然已经有一个为国家定义的资源类型，那么有一种非常直接的方法：将区域列表作为已定义类型的一个属性（或者说是一个参数）：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Using the parameter is straightforward:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该参数非常简单：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The actual challenge is putting these values to use. A naïve approach is to
    add the following to the definition of `example_app_config`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的挑战是将这些值付诸实践。一种天真的做法是将以下内容添加到`example_app_config`的定义中：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'However, this will not work. The `$name` variable does not refer to the title
    of the `file` resource that is being declared. It actually refers, just like `$title`,
    to the name of the enclosing class or defined type (in this case, the country
    name). Still, the actual construct will seem quite familiar to you. The only missing
    piece here is yet another defined type:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这样做是行不通的。`$name`变量并不引用正在声明的`file`资源的标题。它实际上就像`$title`一样，引用的是外部类或定义类型的名称（在这种情况下是国家名称）。不过，实际的结构应该是你非常熟悉的。唯一缺少的部分是另一个定义类型：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The complete definition of the `example_app_config` defined type should look
    like this then:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`example_app_config`定义类型的完整定义应该如下所示：'
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The *outer* defined type adapts the behavior of the `example_app_region` type
    to its respective needs by passing its own resource name as a parameter value.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*外部*定义类型通过将其自己的资源名称作为参数值传递，来调整`example_app_region`类型以适应其各自的需求。'
- en: Using iterator functions
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用迭代器函数
- en: With Puppet 4 and later versions, you probably would not write code like the
    one in the previous section. Thanks to new language features, using defined types
    as iterators is no longer necessary. We will outline the alternative using the
    following examples, with a more thorough exploration in [Chapter 7](b38488ca-86a7-4ecf-9a69-16938576d852.xhtml),
    *New Features from Puppet 4 and* *5*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Puppet 4 及更高版本时，你可能不会像上一节中那样编写代码。得益于新语言特性，使用定义类型作为迭代器已经不再必要。我们将通过以下示例概述这一替代方法，更多详细内容请参考[第7章](b38488ca-86a7-4ecf-9a69-16938576d852.xhtml)，*来自
    Puppet 4 和 5 的新特性*。
- en: 'The plain country links can now be declared from an Array using the `each`
    function:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以通过使用`each`函数从数组中声明普通的国家链接：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The regions can be declared from structured data. A hash suffices for this
    use case:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 区域可以通过结构化数据声明。对于这个用例，使用哈希就足够了：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In new manifests, you should opt for iteration using the `each` and `map` functions
    over using defined types for this purpose. You will find examples of the former
    in older manifest code, however. See [Chapter 7](b38488ca-86a7-4ecf-9a69-16938576d852.xhtml),
    *New Features from Puppet 4 and 5*, for more information on the topic.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的清单文件中，你应该选择使用`each`和`map`函数进行迭代，而不是为了此目的使用定义类型。不过，你仍然可以在旧的清单代码中找到前者的示例。有关更多信息，请参见[第7章](b38488ca-86a7-4ecf-9a69-16938576d852.xhtml)，*来自
    Puppet 4 和 5 的新特性*。
- en: Including classes from defined types
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从定义类型中包含类
- en: The `example_app_config` type that was defined in the previous example is supposed
    to serve a very specific purpose. Therefore, it assumes that the base directory,
    `/etc/example_app`, and its subdirectories were managed independently, outside
    the defined type. This was a sound design, but many defined types are meant to
    be used from lots of independent classes or other defined types. Such defines
    need to be self-contained.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个示例中定义的`example_app_config`类型应该服务于一个非常特定的目的。因此，它假设基本目录`/etc/example_app`及其子目录在定义类型之外被独立管理。这是一个合理的设计，但许多定义类型是为了被多个独立类或其他定义类型使用的。此类定义需要自包含。
- en: 'In our example, the defined type needs to make sure that the following resources
    are part of the manifest:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，定义类型需要确保以下资源是清单的一部分：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Just putting this declaration into the body of the define will lead to duplicate
    resource errors. Each instance of `example_app_config` will try to declare the
    directories by itself. However, we already have discussed a pattern to avoid just
    that issue we called it the component class.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 只将此声明放入定义体内将导致重复资源错误。每个`example_app_config`实例都会尝试自己声明目录。然而，我们已经讨论过一种模式来避免这一问题，我们称之为组件类。
- en: 'To make sure that any instance of the `example_app_config` type is self-contained
    and works on its own, wrap the preceding declaration in a class (for example,
    `class example_app_config_directories`) and make sure you include this class right
    in the body of the define:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保任何`example_app_config`类型的实例都是自包含并能够独立工作，请将前面的声明包裹在一个类中（例如，`class example_app_config_directories`），并确保将此类直接包含在定义体内：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can refer to the examples that come with your copy of this book for the
    definition of the class.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以参考本书附带的示例来查看类的定义。
- en: Ordering and events among classes
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类之间的排序和事件
- en: Puppet's classes bear little or no similarity to classes that you find in object-oriented
    programming languages such as Java or Ruby. There are no methods or attributes.
    There are no distinct instances of any class. You cannot create interfaces or
    abstract base classes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 的类与 Java 或 Ruby 等面向对象编程语言中的类几乎没有相似之处。没有方法或属性。没有任何类的独立实例。你不能创建接口或抽象基类。
- en: One of the few shared characteristics is the encapsulation aspect. Just like
    classes from OOP, Puppet's classes hide implementation details. To get Puppet
    to start managing a subsystem, you just need to include the appropriate class.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为数不多的共享特性之一是封装特性。就像面向对象编程（OOP）中的类一样，Puppet 的类隐藏了实现细节。要让 Puppet 开始管理某个子系统，你只需包含适当的类。
- en: Passing events between classes and defined types
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在类和定义类型之间传递事件
- en: By sorting all resources into classes, you make it unnecessary (for your co-workers
    or other collaborators) to know about each single resource. This is beneficial.
    You can think of the collection of classes and defined types as your interface.
    You would not want to read all of the manifests that anyone on your project ever
    wrote.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将所有资源分类到类中，你使得（你的同事或其他协作者）无需了解每个单独的资源。这是有益的。你可以将类和定义类型的集合视为你的接口。你不希望阅读项目中任何人写过的所有清单文件。
- en: However, the encapsulation is inconvenient for passing resource events. Say
    you have a daemon that creates live statistics from your Apache log files. It
    should subscribe to Apache's configuration files so that it can restart if there
    are any changes (which might be of consequence to this daemon's operation). In
    another scenario, you might have Puppet manage some external data for a self-compiled
    Apache module. If Puppet updates such data, you will want to trigger a restart
    of the Apache service to reload everything.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，封装在传递资源事件时不方便。假设你有一个守护进程，它从 Apache 日志文件中创建实时统计数据。它应该订阅 Apache 的配置文件，以便在有任何更改时重新启动（这些更改可能会影响该守护进程的操作）。在另一种情况下，你可能会让
    Puppet 管理一些外部数据，用于一个自编译的 Apache 模块。如果 Puppet 更新了这些数据，你可能会希望触发 Apache 服务的重启以重新加载所有内容。
- en: Armed with the knowledge that there is a service, `Service['apache2']`, defined
    somewhere in the `apache` class, you can just go ahead and have your module data
    files notify that resource. It would work Puppet does not apply any sort of protection
    to resources that are declared in foreign classes. However, it would pose a minor
    maintainability issue.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 凭借已知在 `apache` 类的某处定义了一个服务 `Service['apache2']`，你可以直接让你的模块数据文件通知该资源。如果 Puppet
    不对在外部类中声明的资源施加任何保护，它将有效。然而，这可能会带来一个小的可维护性问题。
- en: The reference to the resource is located far from the resource itself. When
    maintaining the manifest later, you or a coworker might wish to look at the resource
    when encountering the reference. In the case of Apache, it's not difficult to
    figure out where to look, but in other scenarios, the location of the reference
    target can be less obvious.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 资源的引用位置远离资源本身。稍后维护清单时，你或你的同事可能希望在遇到引用时查看资源。在 Apache 的情况下，找到查看的位置并不困难，但在其他情况下，引用目标的位置可能不那么明显。
- en: Looking up a targeted resource is usually not necessary, but it can be important
    to find out what that resource actually does. It gets especially important during
    debugging, if after a change to the manifest, the referenced resource is no longer
    found.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通常不需要查找目标资源，但了解该资源实际做什么可能很重要。特别是在调试过程中，如果更改了清单后，引用的资源找不到时，这一点尤为重要。
- en: Besides, this approach will not work for the other scenario, in which your daemon
    needs to subscribe to configuration changes. You could blindly subscribe the central
    `apache2.conf` file, of course. However, this would not yield the desired results
    if the responsible class opted to do most of the configuration work inside snippets
    in `/etc/apache2/conf.d`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这种方法在另一种情况下无法使用，其中你的守护进程需要订阅配置更改。当然，你可以盲目地订阅中央的 `apache2.conf` 文件。然而，如果负责的类选择在
    `/etc/apache2/conf.d` 中的片段里做大部分配置工作，这样做就无法达到预期的效果。
- en: 'Both scenarios can be addressed cleanly and elegantly by directing the `notify`
    or `subscribe` parameters at the whole class that is managing the entity in question:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `notify` 或 `subscribe` 参数指向管理相关实体的整个类，可以优雅地解决两种情况：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Of course, the signals are now sent (or received) indiscriminately the file
    not only notifies `Service['apache2']`, but also every other resource in the `apache`
    class. This is usually acceptable, because most resources ignore events.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，现在信号是无差别地发送（或接收）的，文件不仅通知了 `Service['apache2']`，还通知了 `apache` 类中的每一个其他资源。这通常是可以接受的，因为大多数资源会忽略事件。
- en: As for the `logwatch` daemon, it might refresh itself needlessly if a resource
    in the `apache` class needs a sync action. The odds for this occurrence depend
    on the implementation of the class. For ideal results, it might be sensible to
    relocate the configuration file resources into their own class so that the daemon
    can subscribe to that instead.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 至于 `logwatch` 守护进程，如果 `apache` 类中的资源需要同步操作，它可能会不必要地刷新自己。此现象发生的概率取决于类的实现。为了获得理想的结果，可能需要将配置文件资源移到它们自己的类中，以便守护进程可以订阅那个类。
- en: 'With your defined types, you can apply the same rules: subscribe to and notify
    them as required. Doing so feels quite natural, because they are declared like
    native resources anyway. This is how you subscribe several instances of the defined
    type, `symlink`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你定义的类型，你可以应用相同的规则：根据需要订阅和通知它们。这样做非常自然，因为它们本来就是像本地资源一样声明的。这就是你如何订阅多个定义类型实例（如
    `symlink`）的方法：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Granted, this very example is a bit awkward, because it requires all `symlink`
    resource titles to be available in an array variable. In this case, it would be
    more natural to make the defined type instances notify the service instead:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，这个示例有些笨拙，因为它要求所有 `symlink` 资源标题都必须在一个数组变量中可用。在这种情况下，更自然的做法是让定义类型实例通知服务，而不是这样做：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This notation passes a metaparameter to a defined type. The result is that this
    parameter value is applied to all resources declared inside the define.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 该表示法将一个元参数传递给已定义的类型。其结果是该参数值会应用于定义内部声明的所有资源。
- en: 'If a defined type wraps or contains a `service` or `exec` type resource, it
    can also be desirable to notify an instance of that define to refresh the contained
    resource. The following example assumes that the `service` type is wrapped by
    a defined type called `protected_service`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个已定义的类型包装或包含了 `service` 或 `exec` 类型的资源，也可能需要通知该定义的实例刷新包含的资源。以下示例假设 `service`
    类型被一个名为 `protected_service` 的定义类型所包装：
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Ordering containers
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器排序
- en: The `notify` and `subscribe` metaparameters are not the only ones that you can
    direct at classes and instances of defined types the same holds `true` for their
    siblings, `before` and `require`. These allow you to define an order for your
    resources relative to classes, order instances of your defined types, and even
    order classes among themselves.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`notify` 和 `subscribe` 元参数并不是唯一可以直接应用于已定义类型的类和实例的参数，`before` 和 `require` 这两个元参数也适用。这些元参数允许你为资源定义相对于类的顺序，排列已定义类型的实例，甚至对类之间的顺序进行排序。'
- en: 'The latter works by virtue of the chaining operator:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 后者是通过链式操作符来实现的：
- en: '[PRE35]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The effect of this code is that all resources from the `firewall` class will
    be synchronized before any resource from the `loadbalancing` class, and failure
    of any resource in the former class will prevent all resources in the latter from
    being synchronized.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的效果是，所有来自 `firewall` 类的资源将在任何来自 `loadbalancing` 类的资源之前同步，如果前者的任何资源失败，后者的所有资源都将无法同步。
- en: The chaining arrow cannot just be placed in between the `include` statements.
    It works only between resource definitions or resource references.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 链接箭头不能仅仅放置在 `include` 语句之间。它只在资源定义或资源引用之间有效。
- en: Because of these ordering semantics, it is actually quite wholesome to require
    a whole class. You effectively mark the resource in question as being dependent
    on the class. As a result, it will only be synchronized if the entire subsystem
    that the class models is successfully synchronized first.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些排序语义，要求整个类同步实际上是相当合理的。你实际上将相关资源标记为依赖于该类。因此，只有在类所建模的整个子系统成功同步后，相关资源才会同步。
- en: Limitations
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制
- en: 'Sadly, there is a rather substantial issue with both the ordering of containers
    and the distribution of refresh events: neither will transcend the `include` statements
    of further classes. Consider the following example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，容器的排序和刷新事件的分发存在一个相当严重的问题：它们都不会超越后续类的 `include` 语句。考虑以下示例：
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: I have often mentioned how the comprehensive `apache` class models everything
    about the Apache server subsystem, and in the previous section, I went on to explain
    that directing a `require` parameter at such a class will make sure that Puppet
    only touches the dependent resource if the subsystem has been successfully configured.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常提到，`apache` 类如何全面地模拟 Apache 服务器子系统的一切，在上一节中，我进一步解释了，如果将 `require` 参数指向这样一个类，将确保只有在子系统成功配置后，Puppet
    才会接触到相关的依赖资源。
- en: This is mostly true, but, due to the limitation concerning class boundaries,
    it doesn't achieve the desired effect in this scenario. The dependent configuration
    file should actually require the `Package['apache']` package, declared in `class
    apache::package`. However, the relationship does not span multiple class inclusions,
    so this particular dependency will not be part of the resulting catalog at all.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点大多是正确的，但由于类边界的限制，它在这个场景中无法实现预期效果。依赖的配置文件实际上应该需要在 `class apache::package`
    中声明的 `Package['apache']` 包。然而，这个关系并不会跨越多个类包含，因此这个特定的依赖关系根本不会成为生成目录的一部分。
- en: Similarly, any refresh events sent to the `apache` class will have no effect;
    they are distributed to resources declared in the class's body (of which there
    are none), but are not passed on to included classes. Subscribing to the class
    will make no sense either, because any resource events generated inside the included
    classes will not be forwarded by the `apache` class.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，发送到 `apache` 类的任何刷新事件都不会起作用；它们会被分发到类体内声明的资源（但其中没有任何资源），而不会传递给包含的类。订阅该类也没有意义，因为在包含类内部生成的任何资源事件都不会被
    `apache` 类转发。
- en: The bottom line is that relationships to classes cannot be built in utter ignorance
    of their implementation. If in doubt, you need to make sure that the resources
    that are of interest are actually declared directly inside the class you are targeting.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点是，不能完全忽视类的实现来构建类之间的关系。如果有疑问，您需要确保目标类中实际声明了您感兴趣的资源。
- en: The discussion revolved around the example of the `include` statements in classes,
    but since it is common to use them in defined types as well; the same limitation
    applies in this case too.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论围绕着类中的 `include` 语句展开，但由于在定义类型中也常常使用它们；相同的限制在这种情况下也适用。
- en: 'There is a bright side to this as well. A more correct implementation of the
    Apache configuration file from the example explained would depend on the package,
    but would also synchronize itself before the service, and perhaps even notify
    it (so that Apache restarts if necessary). When all resources are part of the
    `apache` class and you want to adhere to the pattern of interacting with the container
    only, it would lead to the following declaration:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这里也有一个亮点。根据之前解释的示例，Apache 配置文件的更正确实现应该依赖于该包，但在服务之前也会同步自身，并可能通知它（以便在必要时重启 Apache）。当所有资源都属于
    `apache` 类，并且你只想遵循与容器交互的模式时，它将导致如下声明：
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This forms an instant dependency circle: the `file` resource requires all parts
    of the `apache` class to be synchronized before it gets processed, but to notify
    them, they must all be put after the `file` resource in the order graph. This
    cannot work. With the knowledge of the inner structure of the `apache` class,
    the user can pick metaparameter values that actually work:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这形成了一个即时的依赖循环：`file` 资源要求在处理之前，`apache` 类的所有部分都必须同步，但为了通知它们，它们必须排在 `file` 资源之后，这在顺序图中是行不通的。通过了解
    `apache` 类的内部结构，用户可以选择真正有效的元参数值：
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: For the curious, the preceding code shows what the inner classes look like,
    roughly.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于好奇的人，前面的代码大致展示了内部类的样子。
- en: 'The other good news is that invoking defined types does not pose the same kind
    of issue that an `include` statement of a class does. Events are passed to resources
    inside defined types just fine, transcending an arbitrary number of stacked invocations.
    Ordering also works just as expected. Let''s keep the example brief:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个好消息是，调用定义类型不会像 `include` 语句那样引发问题。事件会正常传递给定义类型内部的资源，跨越任意数量的堆叠调用。排序也像预期的那样正常工作。让我们简要看看这个例子：
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This `apache` class also creates a virtual host using the defined type, `virtual_host`.
    A resource that requires this class will implicitly require all resources from
    within this `virtual_host` instance. A subscriber to the class will receive events
    from those resources, and events directed at the class will reach the resources
    of this `virtual_host`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`apache`类还使用已定义类型`virtual_host`创建了一个虚拟主机。需要此类的资源将隐式地要求`virtual_host`实例中的所有资源。订阅该类的用户将接收到来自这些资源的事件，指向该类的事件也将到达该`virtual_host`的资源。
- en: There is actually a good reason to make the `include` statements behave differently
    in this regard. As classes can be included very generously (thanks to their singleton
    aspect), it is common for classes to build a vast network of includes. By adding
    a single `include` statement to a manifest, you might unknowingly pull hundreds
    of classes into this manifest. Assume, for a moment, that relationships and events
    transcend this whole network. All manner of unintended effects would be the consequence.
    Dependency circles would be almost inevitable. The whole construct would become
    utterly unmanageable. The cost of such relationships would also grow exponentially.
    Refer to the next section.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，有充分的理由使`include`语句在这方面表现不同。由于类可以非常宽松地包含（得益于它们的单例特性），类通常会建立一个庞大的包含网络。通过在清单中添加一个`include`语句，你可能在不知情的情况下将数百个类拉入该清单。假设关系和事件超越了整个网络，随之而来的将是各种意外的效果。依赖循环几乎是不可避免的。整个构造将变得无法管理。此类关系的成本也将呈指数增长。请参阅下一节。
- en: The performance implications of container relationships
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器关系的性能影响
- en: There is another aspect that you should keep in mind whenever you are referencing
    a container type to build a relationship to it. The Puppet agent will have to
    build a dependency graph from this. This graph contains all resources as nodes
    and all relationships as edges. Classes and defined types get expanded to all
    their declared resources. All relationships to the container are expanded to relationships
    to each resource.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个方面，你在引用容器类型以建立关系时应牢记。Puppet代理需要从中构建一个依赖关系图。此图包含所有资源作为节点，所有关系作为边。类和已定义类型会扩展为它们所有的声明资源。与容器的所有关系都会扩展为与每个资源的关系。
- en: This is mostly harmless if the other end of the relationship is a native resource.
    A file that requires a class with five declared resources leads to five dependencies.
    That does not hurt. It gets more interesting if the same class is required by
    an instance of a defined type that comprises three resources. Each of these builds
    a relationship to each of the class's resources, so you end up with 15 edges in
    the graph.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果关系的另一端是本地资源，那么这种情况通常是无害的。一个需要五个声明资源的类会导致五个依赖关系，这不会造成问题。如果相同的类被一个包含三个资源的已定义类型的实例所要求，那么每个资源都会与该类的资源建立关系，这样你就会在图中得到15条边。
- en: It gets even more expensive when a container invokes complex defined types,
    perhaps even recursively.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器调用复杂的已定义类型时，成本会更高，可能还会是递归调用。
- en: A more complex graph means more work for the Puppet agent, and its runs will
    take longer. This is especially annoying when running agents interactively during
    the debugging or development of your manifest. To avoid the unnecessary effort,
    consider your relationship declarations carefully, and use them only when they
    are really appropriate.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的图意味着Puppet代理需要更多的工作，其运行时间也会更长。当在调试或开发清单时交互式运行代理时，这尤其令人烦恼。为了避免不必要的努力，请仔细考虑你的关系声明，并仅在真正适当时使用它们。
- en: Mitigating the limitations
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓解限制
- en: The architects of the Puppet language have devised two alternative approaches
    to solve the ordering issues. We will consider both, because you might encounter
    them in existing manifests. In new setups, you should always choose the latter
    variant.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet语言的架构师已经设计了两种替代方法来解决排序问题。我们将考虑这两种方法，因为你可能会在现有的清单中遇到它们。在新的设置中，你应该始终选择后一种方法。
- en: The anchor pattern
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锚点模式
- en: 'The `anchor` pattern is the classic workaround for the problem with ordering
    and signaling in the context of recursive class `include` statements. It can be
    illustrated by the following example class:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`anchor`模式是解决递归类`include`语句中排序和信号传递问题的经典解决方法。可以通过以下示例类进行说明：'
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Consider a resource that is placed `before``=> Class['example_app']`. It ends
    up in the chain before each `anchor`, and therefore, also before any resource
    in `example_app_config`, despite the `include` limitation. This is because the
    `Anchor['example_app::begin']` pseudo-resource notifies the included class and
    is therefore ordered before all of its resources. A similar effect works for objects
    that require the class, by virtue of the `example::end` anchor.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个资源被放置在`before`=> Class['example_app']之前。它会被放在链中的每个`anchor`之前，因此也会在`example_app_config`中的任何资源之前，尽管存在`include`的限制。这是因为`Anchor['example_app::begin']`伪资源会通知被包含的类，因此它会被排在所有资源之前。对于需要类的对象，`example::end`锚点也会起到类似的效果。
- en: The `anchor` resource type was created for this express purpose. It is not part
    of the Puppet core, but has been made available through the `stdlib` module instead
    (the next chapter will familiarize you with modules). Since it also forwards refresh
    events, it is even possible to notify and subscribe this anchored class, and events
    will propagate into and out of the included `example_app_config` class.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`anchor`资源类型是专门为此目的创建的。它不是Puppet核心的一部分，而是通过`stdlib`模块提供的（下一章会介绍模块）。由于它也转发刷新事件，因此甚至可以通知和订阅这个锚定类，事件将会在被包含的`example_app_config`类内外传播。'
- en: The `stdlib` module is available in the Puppet Forge, but more about this in
    the next chapter. There is a descriptive document for the `anchor` pattern to
    be found online as well, in Puppet documentation at [http://projects.puppetlabs.com/projects/puppet/wiki/Anchor_Pattern](https://docs.puppet.com/puppet/latest/lang_containment.html).
    It is somewhat dated, given that the anchor pattern has been supplanted as well
    by Puppet's ability to contain a class in a container.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdlib`模块可以在Puppet Forge中找到，更多内容将在下一章介绍。关于`anchor`模式的描述性文档也可以在Puppet文档的[http://projects.puppetlabs.com/projects/puppet/wiki/Anchor_Pattern](https://docs.puppet.com/puppet/latest/lang_containment.html)中找到。鉴于锚点模式已经被Puppet的类容器功能所取代，这份文档有些过时。'
- en: The contain function
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`contain`功能'
- en: To make composite classes work directly around the limitations of the `include`
    statement, you can take advantage of the `contain` function found in Puppet version
    3.4.x or newer.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让复合类能够绕过`include`语句的限制，你可以利用在Puppet版本3.4.x及更高版本中提供的`contain`功能。
- en: 'If the earlier `apache` example had been written like the following one, there
    would have been no issues concerning ordering and refresh events:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果之前的`apache`示例写成如下形式，关于顺序和刷新事件就不会再有问题了：
- en: '[PRE41]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The official documentation describes the behavior as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 官方文档描述了如下行为：
- en: '"A contained class will not be applied before the containing class is begun,
    and will be finished before the containing class is finished."'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '"一个被包含的类在包含类开始之前不会被应用，并且会在包含类结束之前完成。"'
- en: This might read like we're now discussing the panacea for the presented class
    ordering issues here. Should you just be using `contain` in place of `include`
    from here on out and never worry about class ordering again? Of course not; this
    would introduce lots of unnecessary ordering constraints and lead you into unfixable
    dependency circles very quickly. Do contain classes, but make sure that it makes
    sense. The contained class should really form a vital part of what the containing
    class is modeling.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能让你觉得我们现在在讨论一个可以解决类顺序问题的灵丹妙药。从现在开始，你是否只需要使用`contain`替代`include`，然后再也不用担心类的顺序问题呢？当然不是；这样做会引入许多不必要的顺序约束，并且很快让你陷入无法修复的依赖循环中。使用`contain`类，但要确保这样做是合理的。被包含的类应当真正构成包含类所建模内容的核心部分。
- en: The quoted documentation refers to classes only, but classes can be contained
    in defined types just as well. The effect of containment is not limited to ordering
    aspects either. Refresh events are also correctly propagated.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 被引用的文档仅提到了类，但类同样可以包含在定义的类型中。包含的效果不仅仅局限于顺序方面。刷新事件也会被正确地传播。
- en: Making classes more flexible through parameters
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过参数使类更具灵活性
- en: 'Up until this point, classes and defines were presented as direct opposites
    with respect to flexibility; defined types are inherently adaptable through different
    parameter values, whereas classes model just one static piece of state. As the
    section title suggests, this is not entirely true. Classes, too, can have parameters.
    Their definition and declaration become rather similar to those of defined types
    in this case:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 直到目前为止，类和定义在灵活性方面被视为直接对立的；定义类型本身通过不同的参数值具有适应性，而类则建模了单一的静态状态。正如本节标题所示，这并不完全正确。类也可以有参数。在这种情况下，它们的定义和声明与定义类型的定义和声明非常相似：
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'With a definition like the preceding one, the class can be declared with a
    parameter value:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用如上所示的定义，类可以用参数值进行声明：
- en: '[PRE43]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This enables some very elegant designs, but introduces some drawbacks as well.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这能够实现一些非常优雅的设计，但也带来了一些缺点。
- en: The caveats of parameterized classes
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数化类的注意事项
- en: 'The consequence of allowing class parameters is almost obvious: you lose the
    singleton characteristic. Well, that''s not entirely true either, but your freedom
    in declaring the class gets limited drastically.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 允许类参数的后果几乎显而易见：你会失去单例特性。嗯，这也不完全正确，但你在声明类时的自由度会被大大限制。
- en: Classes that define default values for all parameters can still be declared
    with the `include` statement. This can still be done an arbitrary number of times
    in the same manifest.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了所有参数默认值的类仍然可以使用`include`语句进行声明。在同一清单中，这仍然可以任意多次进行。
- en: 'However, the resource like declaration of `class { ''name'': }` cannot appear
    more than once for any given class in the same manifest. This is in keeping with
    the rules for resources and should not be very surprising-after all, it would
    be very awkward to try to bind different values to a class''s parameters in different
    locations throughout the manifest.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，`class { ''name'': }`的类似资源声明不能在同一清单中对任何给定的类出现多于一次。这与资源的规则相一致，不应感到非常惊讶——毕竟，如果在清单的不同位置试图为类的参数绑定不同的值，会显得非常尴尬。'
- en: 'Things become very confusing when mixing `include` with the alternative syntax
    though. It is valid to include a class an arbitrary number of times after it has
    been declared using the resource-like notation. However, you cannot use the resource
    style declaration after a class has been declared using `include`. That''s because
    the parameters are then determined to assume their default values, and a `class
    { ''name'': }` declaration clashes with that.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，当混合使用`include`和替代语法时，事情变得非常混乱。在使用类似资源的语法声明类后，可以任意次数地包含该类。然而，一旦使用`include`声明了类，就不能再使用资源风格的声明。这是因为参数将被认为采用默认值，而`class
    { ''name'': }`声明与此相冲突。'
- en: 'In a nutshell, the following code works:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，以下代码是有效的：
- en: '[PRE44]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'However, the following code does not work:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以下代码无法正常工作：
- en: '[PRE45]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As a consequence, you effectively cannot add parameters to component classes,
    because the `include` statement is no longer safe to use in large quantities.
    Therefore, parameters are essentially only useful for comprehensive classes, which
    usually don't get included from different parts of the manifest.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，你实际上不能为组件类添加参数，因为`include`语句在大量使用时不再安全。因此，参数本质上仅对综合类有用，而这些类通常不会从清单的不同部分进行包含。
- en: In [Chapter 5](3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml), *Combining Classes,
    Configuration Files, and Extensions into Modules*, we will discuss some alternate
    patterns, some of which exploit class parameters. Also note that Chapter 8, *Separation
    of Code and Data with Hiera*, presents a solution that gives you more flexibility
    with parameterized classes. Using this, you can be more liberal with your class
    interfaces.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml)，*将类、配置文件和扩展组合成模块*中，我们将讨论一些替代模式，其中一些利用了类参数。还要注意，第8章，*使用Hiera实现代码与数据的分离*，提出了一种解决方案，使你在使用参数化类时更加灵活。通过这种方法，你可以更自由地使用类接口。
- en: Preferring the include keyword
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更倾向于使用include关键字
- en: 'Ever since class parameters have been available, some Puppet users have felt
    compelled to write (example) code that would make it a point to forgo the `include`
    keyword in favor of resource-like class declarations, such as this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 自从类参数可用以来，一些Puppet用户感到有必要编写（示例）代码，故意放弃`include`关键字，转而使用类似资源的类声明，如下所示：
- en: '[PRE46]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Doing this is a very bad idea. We cannot stress this enough: one of the most
    powerful concepts about Puppet''s classes is their singleton aspect the ability
    to include a class in a manifest arbitrarily and without worrying about clashes
    with other code. The mentioned declaration syntax deprives you of this power,
    even when the classes in question don''t support parameters.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这么做是一个非常糟糕的主意。我们无法过度强调这一点：Puppet类的最强大概念之一是它们的单例特性，即可以在清单中任意包含类，而无需担心与其他代码的冲突。上述声明语法会剥夺你这种能力，即使相关的类不支持参数。
- en: The safest route is to use `include` whenever possible, and to avoid the alternate
    syntax whenever you can. In fact, Chapter 8, *Separation of Code and Data with
    Hiera*, introduces the ability to use class parameters without the resource same
    as class declaration. This way, you can rely solely on `include`, even when parameters
    are in play. These are the safest recommended practices to keep you out of trouble
    from incompatible class declarations.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最安全的做法是尽可能使用`include`，并尽量避免使用替代语法。事实上，第8章，*通过Hiera分离代码和数据*，介绍了在没有与类声明相同的资源情况下使用类参数的能力。这样，即使在使用参数时，你也可以完全依赖`include`。这些是最安全的推荐做法，可以帮助你避免与不兼容的类声明发生冲突。
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Classes and defined types are the essential tools to create reusable Puppet
    code. While classes hold resources that must not be repeated in a manifest, the
    define is capable of managing a distinct set of adapted resources upon every invocation.
    It does that by leveraging the parameter values it receives. While classes do
    support parameters as well, there are some caveats to bear in mind.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 类和定义类型是创建可重用Puppet代码的基本工具。类包含清单中不能重复的资源，而定义则能够在每次调用时管理一组独特的适配资源。它通过利用接收到的参数值来实现这一点。尽管类也支持参数，但仍有一些需要注意的注意事项。
- en: To use defined types in your manifest, you declare instances just like resources
    of native types. Classes are mainly used through the `include` statement, although
    there are alternatives such as the `class { }` syntax or the `contain` function.
    There are also some ordering issues with classes that the `contain` function can
    help mitigate. In theory, classes and defines suffice to build almost all the
    manifests that you will ever need. In practice, you will want to organize your
    code into larger structures.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在清单中使用定义的类型时，你可以像声明本地类型的资源一样声明实例。类主要通过`include`语句使用，尽管也有其他替代方式，例如`class { }`语法或`contain`函数。类的顺序问题也可以通过`contain`函数得到一定缓解。理论上，类和定义足以构建你所需的几乎所有清单。实际中，你可能希望将代码组织成更大的结构。
- en: The [Chapter 5](3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml), *Combining Classes,
    Configuration Files, and Extensions into Modules*, will show you how to do exactly
    that, and introduce you to a whole range of useful functionality beyond it.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[第5章](3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml)，*将类、配置文件和扩展组合成模块*，将向你展示如何做到这一点，并向你介绍一系列超出此内容的有用功能。'
