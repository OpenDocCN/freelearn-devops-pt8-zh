- en: Managing Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理代码
- en: Code management has gone a lot of changes over the lifetime of Puppet. In earlier
    versions of Puppet, code management was largely left to individual users. Most
    users started by simply editing code directly on the Puppet Master. One organization
    that I worked for created Yum RPMs for every module, allowing us to roll back
    and forth between individual modules on multiple Puppet Masters, prior to the
    introduction of Puppet environments. Many users stored their Puppet code in Git
    or subversion and checked the code out to directories in the Puppet Master.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 代码管理在Puppet的生命周期中经历了很多变化。在Puppet的早期版本中，代码管理主要由个人用户负责。大多数用户开始时只是直接在Puppet Master上编辑代码。我曾为一个组织工作过，该组织为每个模块创建了Yum
    RPM包，在引入Puppet环境之前，允许我们在多个Puppet Master之间回滚和前进。许多用户将Puppet代码存储在Git或Subversion中，并将代码签出到Puppet
    Master的目录中。
- en: 'Each of these models comes with significant overhead management, and two solutions
    have risen to the top of the Puppet community during the transition from Puppet
    2 to Puppet 3: Puppet Librarian and r10k. Puppet Librarian manages code like a
    Ruby bundle file, bringing in all the listed modules and dependencies with a single
    command. Automatic dependency management from the Forge has some issues, as well.
    Some modules include dependency lists for all operating systems, including ones
    that are not in your infrastructure. Some modules do not receive updates for a
    period of time, linking to old versions of a dependency while your organization
    is using a newer version. Finally, dependencies in Puppet modules are often listed
    as a range of versions rather than a single version, and if these modules are
    used across multiple manifests, it can be difficult to resolve conflicts.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模型每个都有显著的开销管理，在从Puppet 2到Puppet 3的过渡过程中，两个解决方案脱颖而出，成为Puppet社区的首选：Puppet Librarian和r10k。Puppet
    Librarian像Ruby的bundle文件一样管理代码，使用一个命令就能引入所有列出的模块和依赖项。来自Forge的自动依赖管理也有一些问题。一些模块包括所有操作系统的依赖列表，包括那些不在你基础设施中的操作系统。一些模块在一段时间内没有收到更新，导致它们链接到依赖的旧版本，而你的组织却使用了较新的版本。最后，Puppet模块中的依赖项通常列出一个版本范围而不是单一版本，如果这些模块跨多个清单使用，解决冲突可能会变得非常困难。
- en: Some users of Puppet Librarian use `puppet-librarian-simple`, which does not
    manage dependencies. Although `puppet-librarian-simple` is easier to install than
    r10k, it does not maintain feature parity with r10k; r10k has become the most
    commonly used code management solution, for both enterprise and open source users.
    r10k allows users to point to a remote repository that contains a set of instructions
    to build a Puppet environment. Puppet Enterprise comes with an expansion to r10k,
    known as Puppet Code Manager.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Puppet Librarian的用户使用`puppet-librarian-simple`，它不管理依赖项。尽管`puppet-librarian-simple`比r10k更容易安装，但它与r10k的功能不完全匹配；r10k已经成为最常用的代码管理解决方案，无论是企业用户还是开源用户。r10k允许用户指向一个包含构建Puppet环境的指令集的远程仓库。Puppet
    Enterprise带有r10k的扩展，称为Puppet代码管理器。
- en: 'This chapter will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Efficiently managing code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效管理代码
- en: Code Manager
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码管理器
- en: Git
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: r10k
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: r10k
- en: Control repository
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制库
- en: Installing and using r10k
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装并使用r10k
- en: Multitenant control repository
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多租户控制库
- en: Efficiently managing code
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效管理代码
- en: 'Although writing code directly to the disk on a Puppet Master is the easiest
    way to get started with Puppet, it is the least efficient model for managing infrastructure
    changes with Puppet. Manual changes leave the users to manage the following issues
    individually:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管直接在Puppet Master上编写代码是开始使用Puppet的最简单方式，但它是管理基础设施变化时最低效的模型。手动更改让用户单独管理以下问题：
- en: Backup and recovery
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备份与恢复
- en: Change management
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更管理
- en: Replication of Puppet Masters
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet Masters的复制
- en: Replication of Puppet environments
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet环境的复制
- en: Without code management, backups are often performed via disk snapshots, or
    by simply bundling code and moving it to a separate location in case of emergencies.
    Manual code placement leaves the organization responsible for maintaining a cadence
    and process for backing up and restoring, and for change management. Without any
    code management, replication of code to Puppet Masters and Puppet environments
    is a fully manual process, which leaves all Puppet code testing and implementation
    to dangerous manual processes, instead of processes within a controlled environment.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 没有代码管理时，备份通常通过磁盘快照进行，或者通过简单地将代码打包并移到一个独立的位置以防紧急情况。手动放置代码使得组织需要负责维护备份和恢复的节奏与流程，并进行变更管理。没有任何代码管理时，将代码复制到
    Puppet Masters 和 Puppet 环境的过程完全是手动的，这使得所有 Puppet 代码的测试和实现都依赖于危险的手动流程，而不是受控环境中的流程。
- en: Although placing code in RPMs can solve the backup and recovery issue, change
    management, and the replication of Puppet Masters, it struggles with Puppet environments.
    An RPM has to be created for each Puppet environment, and this creates a confusing
    set of build files that consistently place code in multiple environments. Also,
    RPMs do not lend themselves to short-lived environments that are used to test
    individual code features.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管将代码放入 RPM 中可以解决备份和恢复问题、变更管理和 Puppet Masters 的复制问题，但它在 Puppet 环境中存在困难。每个 Puppet
    环境都需要创建一个 RPM，这会导致一组混乱的构建文件，这些文件会不断将代码放入多个环境中。此外，RPM 不适用于用来测试单独代码功能的短期环境。
- en: Using Code Manager or r10k to manage code drastically simplifies these problems.
    Code is never written directly to the disk; instead, a list of requirements is
    pulled from one remote repository, and all relevant code is placed on the Puppet
    Master. One of the primary benefits of this model is that every change in code
    can be versioned in Git, and each change can be explicitly referenced (by tag,
    branch, or commit hash) and placed on the master. All of the code is always stored
    remotely, and is not reliant on the Puppet Master itself for backup and recovery.
    Rollbacks are now as easy as changing a single file in a remote repository. Code
    management also allows for the scaling of multiple Puppet Masters, with both long-lived
    and short-lived Puppet environments.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Code Manager 或 r10k 来管理代码能大大简化这些问题。代码从不直接写入磁盘；相反，它从一个远程仓库拉取需求列表，所有相关代码会被放置到
    Puppet Master 上。这个模型的主要好处之一是每个代码变更都可以在 Git 中版本化，每次变更都可以通过标签、分支或提交哈希进行明确引用并放置到主服务器上。所有代码始终存储在远程，并且不依赖
    Puppet Master 本身来进行备份和恢复。回滚现在只需在远程仓库中更改一个文件。代码管理还允许多个 Puppet Masters 的扩展，无论是长期存在的环境还是短期环境。
- en: Code Manager
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Code Manager
- en: Code Manager provides Enterprise RBAC and additional code distribution features
    to r10k. Code Manager will automatically set r10k up for you, but using it requires
    that you understand how r10k calls code, and how to store your code in a Git repository.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Code Manager 提供了企业级 RBAC 和额外的代码分发功能给 r10k。Code Manager 会自动为你设置 r10k，但使用它要求你了解
    r10k 如何调用代码，以及如何将代码存储在 Git 仓库中。
- en: Git
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git
- en: This book is not intended to be a complete resource on Git, but to use Code
    Manager effectively, you should know some basics about Git.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本书并非旨在成为 Git 的完整资源，但要有效使用 Code Manager，你应该了解一些 Git 的基础知识。
- en: Git is a modern code repository that allows for asynchronous work on the same
    code set by multiple users. It accomplishes this by distinguishing every code
    commit as the difference between the previous code commit. Every commit is the
    unique delta in code between the last commit and the current changes. The first
    commit might add hundreds of lines of code to a code base, but the following commit
    might be as simple as removing one line and replacing it with another. When this
    code is cloned (or copied) by another user, it brings down the latest code and
    allows the user to roll back to previous commits.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Git 是一个现代的代码仓库，它允许多个用户在同一代码集上进行异步工作。它通过将每次代码提交区分为与上次提交之间的差异来实现这一点。每次提交都是上次提交和当前更改之间的独特差异。第一次提交可能会向代码库添加数百行代码，但接下来的提交可能仅仅是删除一行并替换成另一行。当这段代码被另一个用户克隆（或复制）时，它会下载最新的代码，并允许用户回滚到之前的提交。
- en: As an introduction to Git, let's walk through a scenario. Suppose that you are
    using Git to redecorate your living room. The current commit is how your living
    room looks right now. If you liked how it looked last summer, before you replaced
    your couch, you could roll back to the previous commit and set your living room
    back to a previously accepted state. Commits should be seen as accepted states
    of code, or, in this case, accepted states of your living room.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Git 的入门，我们通过一个场景来演示。假设你使用 Git 来重新装修你的客厅。当前的提交就是你客厅现在的样子。如果你喜欢去年夏天的装修，替换沙发之前的样子，你可以回退到之前的提交，将客厅恢复到以前接受的状态。提交应该被视为代码的已接受状态，或者在这个例子中，是你客厅的已接受状态。
- en: 'First and foremost, we don''t want to break our living room while building
    a new one, so we''ll clone it with `git clone`. This makes a copy of the current
    living room, and its entire change history is bundled in. To keep things simple,
    we''ll use the most recent version of our living room. If we wanted to make a
    change to the living room, we could purchase a new couch, a new TV, and two new
    lamps. Let''s suppose that we love the lamps, but we''re not sure about the couch
    and the TV. If we use `git add` on the lamps, it will add those lamps to the staging
    directory. Git will report the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们最不希望在打造新客厅的同时破坏现有的客厅，因此我们会使用 `git clone` 克隆现有客厅。这样就会复制当前的客厅，并将整个更改历史一并打包。为了简化操作，我们将使用最新版本的客厅。如果我们想要对客厅进行更改，我们可以购买新的沙发、电视和两盏新的灯具。假设我们非常喜欢这些灯具，但对沙发和电视不太确定。如果我们对灯具使用
    `git add`，它将把这些灯具添加到暂存目录中。Git 将报告以下信息：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We''ve asked Git to track the changes on the new lamps that we love. When we
    type `git commit`, we''re asked to write what the change is, and then, Git will
    commit the new living room to memory:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经要求 Git 跟踪我们喜欢的新的灯具的更改。当我们输入 `git commit` 时，系统会要求我们写下更改的内容，然后 Git 会将新的客厅状态提交到记忆中：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that the couch and TV are not included in this manifest of changes. In
    our working directory, or our current living room, the couch and TV are still
    present, but they're not permanent changes until we also add and commit them.
    Optionally, we could send our new commit (the lamps) back to our remote repository
    for safekeeping, and to let any other decorator use our most current living room
    composition with `git push`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，沙发和电视并未包含在这次更改清单中。在我们的工作目录中，或者说我们的当前客厅，沙发和电视仍然存在，但它们并不是永久的更改，直到我们也将它们添加并提交。我们还可以选择将新的提交（灯具）推送回远程仓库以备份，并让其他装饰者使用我们最新的客厅组合，使用命令
    `git push`。
- en: In short, we clone (copy) a living room format. We make changes to that format
    at will. The changes that we're sure we like, we add and commit. The changes that
    we're unsure about remain present, but only in our current working directory (or
    the current state of our living room). We could either add and commit our couch
    and television, or simply `git stash` and return our living room to the last known
    good state, which is now our previous living room, plus the new lamps. This pattern
    gives us the option to try drastic changes, and only commit the ones that we're
    sure about as a checkpoint in time. Once we have a commit (checkpoint) that we're
    willing to stand behind, we can then push that back to the version of the living
    room that everyone can see.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们克隆（复制）一个客厅的格式。我们随意地对这个格式进行更改。我们确定喜欢的更改会被添加并提交。那些不确定的更改仍然存在，但只在当前的工作目录中（或当前的客厅状态）。我们可以选择添加并提交沙发和电视，或者简单地使用
    `git stash` 将客厅恢复到最后一个已知的良好状态，也就是我们之前的客厅，再加上新的灯具。这种模式给了我们尝试大幅度更改的选项，并且只提交我们确定的那些更改作为时间的检查点。一旦我们有了一个愿意支持的提交（检查点），我们就可以将其推送到所有人都能看到的客厅版本中。
- en: Let's go over using Git against code, instead of in the living room. The first
    step is to clone, or copy, a repository. The command `git clone` copies an entire
    repository and its history, and brings it to the local workstation. This copy
    of code is entirely separate from where it was cloned (its origin). `git clone`
    creates an entirely standalone copy of the original repository.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来讲解如何在代码上使用 Git，而不是在客厅里。第一步是克隆，或复制一个仓库。命令 `git clone` 会复制整个仓库及其历史记录，并将其带到本地工作站。这份代码的副本与它被克隆的地方（原始位置）完全独立。`git
    clone` 会创建一个完全独立的原始仓库副本。
- en: 'When a user first enters a code repository, all of the code is in the working
    directory. A user can make changes to the code at will here, and Git will track
    the delta between the last commit and what is currently in the repository. Git
    has a command called `git status` that allows a user to inspect what files are
    different from the last commit. In the following example, a module has been cloned,
    values have been changed in `init.pp`, and the user has run the `git status` from
    inside the directory of the module:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户第一次进入代码仓库时，所有的代码都在工作目录中。用户可以在这里随意更改代码，Git 会跟踪上次提交与当前仓库之间的差异。Git 有一个叫做`git
    status`的命令，可以让用户查看哪些文件与上次提交不同。在以下示例中，一个模块已被克隆，`init.pp`中的值已被更改，用户在模块目录内运行了`git
    status`：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You may have noticed `Changes not staged for commit`. Git recognizes the working
    directory, changes staged for a commit, and every commit in the repository history.
    The standard workflow is to clone a repository, make changes, stage them for a
    commit, and make a new atomic commit, before pushing it back to a central repository.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到`Changes not staged for commit`。Git 会识别工作目录、已暂存的更改以及仓库历史中的每次提交。标准工作流是克隆一个仓库，进行更改，将其暂存，创建一个新的原子提交，然后再推送回中央仓库。
- en: Although we generally don't make changes to a module procured from the Puppet
    Forge (the primary external repository for Puppet Code), let's go over what it's
    like to clone, change, commit, and (optionally) push our code back to the original
    repository, which Git automatically tags as `origin`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们通常不会对从 Puppet Forge（Puppet 代码的主要外部仓库）获得的模块进行修改，但我们还是来看看克隆、修改、提交和（可选地）将代码推送回原始仓库的过程，Git
    会自动将原始仓库标记为`origin`。
- en: 'First, we''ll clone and make a local copy of `puppetlabs/ntp`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将克隆并在本地创建`puppetlabs/ntp`的副本：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that it cloned the repository and applied 4,429 deltas. We now have a
    local copy of the entire repository contained on GitHub. It will create a directory
    called `puppetlabs-ntp`, which we must enter by using a change directory to continue
    in the local repository.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，它克隆了仓库并应用了4,429个差异。现在我们在 GitHub 上有了一个完整的本地仓库副本。它会创建一个名为`puppetlabs-ntp`的目录，我们必须通过使用`cd`命令进入该目录，才能继续在本地仓库中操作。
- en: 'Next, we''ll edit the files that we intend to edit. In this case, I added a
    single comment to `manifests/init.pp` in the repository. I can check how Git views
    the repository with the command `git status`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编辑我们打算修改的文件。在这种情况下，我在仓库的`manifests/init.pp`中添加了一个注释。我可以通过运行命令`git status`来查看
    Git 如何查看仓库：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Git now sees the change to the local repository. I want to ensure that this
    change is committed to the repository, so next, I''ll add it to the staging directory,
    highlighting it for a commit with `git add manifests/init.pp`. If we run another
    simple `git status`, we will notice that our code is no longer `not staged for
    commit`, but is now under `Changes to be committed`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Git 现在看到了本地仓库的更改。我想确保将这个更改提交到仓库，所以接下来，我会将其添加到暂存目录，使用`git add manifests/init.pp`将其标记为提交。如果我们再次运行`git
    status`命令，我们会注意到代码不再是`not staged for commit`，而是进入了`Changes to be committed`状态：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With `init.pp` in the staging directory, I can commit this code to a new version.
    Running the command `git commit` will open your default editor, allowing you to
    comment and name your commit. I will run the command with an `-m` flag, which
    allows me to pass the message on the command line, rather than by opening up my
    default editor:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在暂存目录中有了`init.pp`后，我可以将这段代码提交为一个新版本。运行命令`git commit`会打开默认编辑器，允许你对提交进行注释和命名。我将带上`-m`参数运行命令，这样我就可以直接在命令行中传递提交信息，而无需打开默认编辑器：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, my local repository has the new commit locally. I can view this commit
    with the command `git log`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我的本地仓库中已经有了新的提交。我可以使用命令`git log`查看这个提交：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Most notably, this change is only on the local repository on my laptop. To
    share this code, I want to push my commit back to where I retrieved the original
    code from. When you run `git clone` locally, it also records where the code came
    from, and, by default, names the remote repository `origin`. If I run the command `git
    remote -v`, I can actually see the URL that the repository came from:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最显著的是，这个更改仅存在于我笔记本上的本地仓库中。为了共享这段代码，我需要将我的提交推送回原始代码所在的位置。当你在本地运行`git clone`时，它也会记录代码的来源，并默认将远程仓库命名为`origin`。如果我运行命令`git
    remote -v`，我实际上可以看到仓库的来源 URL：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If I had permission to push directly to this repository, I could send my new
    commit to the source with the simple command, `git push origin master`. Master
    is the name of the branch, or the specific code set inside of a repository I'm
    working on.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我有权限直接推送到这个仓库，我可以使用简单的命令`git push origin master`将我的新提交推送到源代码中。Master 是分支的名称，或者说是我在仓库中所工作的特定代码集。
- en: Branches are a concept in Git that allow us to create a copy of code and work
    on it in what is similar to a separate directory. By default, Git creates a master
    branch, which is the intended location of the most up-to-date functional code.
    We can create a new branch in Git and change code without impacting the original
    branch that it came from. The most efficient use of Git is for trunk-based development,
    where we start on the master branch, create a new branch that contains new features,
    test those features, and eventually, merge our branch back into the master branch.
    This model allows us to work on, share, test, and even implement code, without
    impacting the original code set.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 分支是 Git 中的一个概念，它允许我们创建代码的副本并在类似独立目录的地方进行工作。默认情况下，Git 创建一个主分支，这是存放最新功能代码的地方。我们可以在
    Git 中创建一个新分支并修改代码，而不会影响它原来的分支。Git 最有效的使用方式是基于主干的开发模型，我们从主分支开始，创建一个包含新特性的分支，测试这些特性，最终将分支合并回主分支。这个模型使我们能够在不影响原始代码集的情况下进行工作、共享、测试，甚至实现代码。
- en: When we type `git checkout -b new_branch`, we create a new branch, based on
    the original branch that we were on. We can then work here, add additional commits,
    and even push it back to the source, without impacting the original code. Only
    when the code is merged back into the original branch does it have an impact on
    that branch. Think of it as the Git equivalent of copying a set of code to a new
    directory, working on it, testing it, and then copying it back to the original
    source when finished.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们输入`git checkout -b new_branch`时，我们创建了一个新的分支，它基于我们之前所在的原始分支。我们可以在这里进行工作，添加额外的提交，甚至将其推送回源代码，而不会影响原始代码。只有当代码被合并回原始分支时，才会对该分支产生影响。可以将其视为
    Git 中相当于将一套代码复制到新目录中，进行工作、测试，然后在完成后将其复制回原始源代码的操作。
- en: r10k
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: r10k
- en: r10k is the primary driver behind Puppet Enterprise Code Manager. It is centered
    around a single repository, called the **control repository**. The control repository
    contains files that describe an entire Puppet environment. This collection of
    files holistically makes up a version of Puppet code intended to be pushed to
    a particular set of nodes. Every time r10k is run, it redeploys everything contained
    in the control repository.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: r10k 是 Puppet Enterprise Code Manager 的主要驱动程序。它围绕一个单一的仓库展开，称为**控制仓库**。控制仓库包含描述整个
    Puppet 环境的文件。这些文件的集合整体上构成了一个版本的 Puppet 代码，旨在推送到特定的一组节点。每次运行 r10k 时，它会重新部署控制仓库中的所有内容。
- en: Control repository
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制仓库
- en: The control repository is the heart of code management for r10k and Code Manager.
    It is a single point of entry, represented as a Git repository, that describes
    one or more environments of one or more Puppet Masters.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 控制仓库是 r10k 和 Code Manager 代码管理的核心。它是一个单一的入口点，作为 Git 仓库表示，描述了一个或多个 Puppet Master
    的一个或多个环境。
- en: 'r10k is designed to provide the following to a Puppet environment, from a control
    repository:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: r10k 旨在为 Puppet 环境提供以下内容，来源于控制仓库：
- en: Each Puppet module required to make a code set via the `Puppetfile`
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `Puppetfile` 创建代码集所需的每个 Puppet 模块
- en: A Hiera hierarchy
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Hiera 层级结构
- en: Hiera data
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hiera 数据
- en: An environment-specific configuration
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境特定的配置
- en: Any additional code (such as `site.pp`, roles, or profiles)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何额外的代码（例如 `site.pp`、角色或配置文件）
- en: 'Multiple states on a single Puppet Master can be achieved by using a concept
    that was launched in Puppet 3: Puppet environments. In Puppet 3, we gained the
    ability to use multiple directories to store code, and to select which code directory
    each agent uses individually. Code Manager and r10k expand on this concept by
    treating every branch of the control repository as a completely separate environment.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个 Puppet Master 上实现多个状态，可以通过使用 Puppet 3 中推出的一个概念来实现：Puppet 环境。在 Puppet 3 中，我们获得了使用多个目录来存储代码的能力，并可以为每个代理选择单独使用的代码目录。Code
    Manager 和 r10k 在此基础上扩展了这个概念，将控制仓库的每个分支视为完全独立的环境。
- en: If a control repository contains multiple branches, r10k can deploy each branch
    individually, as a separate environment. This does make our control repository
    branches a little different from a standard Git repository. Traditionally, the
    best model is trunk-based development, which gives us one master branch that is
    intended to receive all of the finished code changes. A Puppet control repository
    usually contains multiple long-lived and short-lived branches, with varying levels
    of intention to merge code between the branches. In the best scenario, we merge
    our code with the different levels of environments, until we reach production.
    Our `Puppetfile`, covered later in this chapter, is often the file that differs
    the most between the environments.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个控制仓库包含多个分支，r10k 可以单独部署每个分支，作为一个独立的环境。这确实使得我们的控制仓库分支与标准的 Git 仓库有所不同。传统上，最佳模型是基于主干的开发，这使得我们有一个主分支，用于接收所有完成的代码更改。一个
    Puppet 控制仓库通常包含多个长期和短期存在的分支，且分支之间有不同程度的代码合并意图。在最佳情况下，我们将代码与不同层次的环境合并，直到最终进入生产环境。我们将在本章后面介绍的
    `Puppetfile` 通常是各个环境之间差异最大的文件。
- en: 'In a situation where an organization has formal production, preproduction,
    and development environments, and users actively working on Puppet code, we may
    see the following branches:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个组织拥有正式的生产、预生产和开发环境，并且用户积极编写 Puppet 代码的情况下，我们可能会看到以下几个分支：
- en: '`Production`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`生产环境`'
- en: '`Preproduction`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`预生产环境`'
- en: '`Development`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`开发环境`'
- en: '`Feature1`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`功能1`'
- en: '`Feature2`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`功能2`'
- en: '`Feature1` and `Feature2` would be considered short-lived branches, with changes
    intended for merging into the development environment. Puppet environments are
    not required to be one for one with what an organization would consider their
    own environments, and often should not be. Do not feel restricted to making your
    Puppet environments exactly conform to the organizational boundaries of servers.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`功能1` 和 `功能2` 被认为是短期分支，修改的目的是为了合并到开发环境中。Puppet 环境不需要与组织所认为的环境一一对应，且通常不应当如此。不要觉得需要将
    Puppet 环境完全符合服务器的组织边界。'
- en: One of the easiest ways to view these environments is to categorize your `control-repo`
    branches internally as `production-like` and `non-production-like`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 查看这些环境的最简单方法之一是将你的 `control-repo` 分支内部分类为 `生产环境相似` 和 `非生产环境相似`。
- en: production-like environments
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产环境相似的环境
- en: '`production-like` environments are formal lanes of code that an organization
    can expect to retrieve and get a stable code set for individual Puppet agents.
    When I work with organizations setting these up for the first time, I often describe
    them as, *any environment you may be called in to work on if it goes down on nights
    or weekends*. An organization may have a `dev` environment, but if it requires
    support from an infrastructure team to maintain, that environment should be treated
    like a production environment. Any environment meant to be used daily by another
    group in an organization should be controlled more tightly than `non-production-like`
    environments.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`生产环境相似`的环境是组织可以预期获取并为各个 Puppet 代理提供稳定代码集的正式代码通道。当我与组织首次设置这些环境时，我常常将它们描述为，*如果在夜间或周末出现故障，需要你前去处理的任何环境*。一个组织可能有一个`开发环境`，但如果需要基础设施团队的支持来维护，该环境应当被视为生产环境。任何被其他团队在组织内日常使用的环境，应当比`非生产环境相似`的环境受到更严格的控制。'
- en: 'A few key points on managing `production-like` branches are as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 管理 `生产环境相似` 分支的一些关键要点如下：
- en: If you're strong in CI/CD and deploying code to production often, deploy your
    modules by branch
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在 CI/CD 方面很强，并且经常将代码部署到生产环境中，请通过分支部署你的模块。
- en: If you're deploying updates in regular cycles (such as quarterly), deploy your
    modules by tag, as a version number
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在常规周期（例如季度）中部署更新，请通过标签部署模块，作为版本号。
- en: Make these branches protected branches in your Git repository
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这些分支设置为 Git 仓库中的受保护分支。
- en: Decide on an organizational RBAC and governance policy
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定组织的 RBAC（基于角色的访问控制）和治理策略。
- en: More information on deploying modules via tags and branches will be covered
    in the *Puppetfile* section of this chapter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于通过标签和分支部署模块的信息将在本章的 *Puppetfile* 部分详细讲解。
- en: If you're using a hosted Git solution, such as Bitbucket, GitLab, or GitHub,
    enable protected branches on `production-like` branches in the control repository.
    Protected branches ensure that only elevated administrator accounts can push directly
    to the branch or approve merge requests generated from other branches. This ensures
    that code is peer reviewed before being accepted into these controlled environments.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用托管Git解决方案，如Bitbucket、GitLab或GitHub，启用控制库中`生产环境`分支的受保护分支。受保护分支确保只有提升了权限的管理员账户可以直接推送到该分支，或批准从其他分支生成的合并请求。这确保了代码在接受进入这些受控环境之前，已经经过同行评审。
- en: An organization should decide on an RBAC and governance policy surrounding these
    protected branches, and should select technical people to review code and formally
    accept code into these `production-like` environments. Like an open source project,
    this allows any member of an organization to recommend a change to a controlled
    environment via Git, but requires a trusted individual to accept this code into
    the controlled code base.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 组织应当决定一个RBAC（角色基础访问控制）和治理政策，围绕这些受保护的分支，并应选派技术人员来审查代码并正式将代码接受到这些`类似生产环境`中。像开源项目一样，这允许任何组织成员通过Git向受控环境推荐更改，但需要可信任的个人将代码接受到受控代码库中。
- en: '`non-production-like` environments, on the other hand, require significantly
    less management, and can be used to test new features before merging code into
    environments that support direct business needs.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`非生产环境`的管理需求显著较低，可以在将代码合并到支持直接业务需求的环境之前，用于测试新特性。
- en: non-production-like environments
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非生产环境
- en: We manage `non-production-like` environments differently from `production-like`
    environments. Where `production-like` environments need management to ensure that
    only trusted code is deployed, our `non-production-like` branches are hampered
    by these same protections.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对待`非生产环境`与`生产环境`的方式不同。`生产环境`需要管理以确保仅有受信任的代码被部署，而我们的`非生产环境`分支则受限于这些相同的保护措施。
- en: The primary goal of these `non-production-like` branches is to facilitate rapid
    code deployment and testing cycles. Patterns like protected branches and governance
    policies intentionally slow development to add stability, and should not be used
    on these Wild-West Style development branches.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`非生产环境`分支的主要目标是促进快速的代码部署和测试周期。像受保护分支和治理政策这样的模式故意放慢开发速度，以增加稳定性，但不应在这些“西部片”风格的开发分支上使用。
- en: The two most common examples of `non-production-like` environments are Puppet
    staging environments and feature-branches. Puppet staging environments are built
    to allow all Puppet users to integrate and test changes in a single environment,
    prior to shipping code to a `production-like` environment.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`非生产环境`最常见的两个例子是Puppet暂存环境和功能分支。Puppet暂存环境旨在允许所有Puppet用户在一个环境中集成和测试更改，然后再将代码发送到`生产环境`。'
- en: If your organization needs a staging environment, you should only use a single
    staging environment, as merging between multiple staging environments can be difficult.
    Feature-branches are built exclusively to build and test new code in isolation,
    before sending it to staging, or directly to a `production-like` branch in absence
    of a staging environment, for organizations with robust CI/CD practices. We want
    to minimize overhead on these branches, to facilitate asynchronous code commits
    and testing without needing a trusted agent to approve every change.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的组织需要一个暂存环境，你应只使用一个暂存环境，因为在多个暂存环境之间合并代码可能会比较困难。功能分支专门用于在隔离的环境中构建和测试新代码，然后再将其发送到暂存环境，或者在没有暂存环境的情况下，直接将其发送到`生产环境`分支，对于拥有强大CI/CD实践的组织。我们希望减少这些分支的开销，以便于异步提交代码和测试，而不需要一个受信任的代理来批准每个变更。
- en: 'A common workflow to develop Puppet code in environments at larger organizations
    is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型组织中开发Puppet代码的常见工作流如下：
- en: Clone the control repository
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 克隆控制库
- en: Check out a new branch, based on the branch that you intend to make changes
    to (usually staging)
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检出一个新分支，基于你打算修改的分支（通常是staging分支）
- en: Add one or more nodes to this environment via the PE console, or set the environment
    in the agents `puppet.conf`
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过PE控制台将一个或多个节点添加到该环境，或者在代理的`puppet.conf`中设置环境。
- en: 'Iterate over code: write code and test it'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对代码进行迭代：编写代码并测试
- en: Merge your code with the staging environment and delete the short-lived branch
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的代码与暂存环境合并，并删除短期分支
- en: Promote the staging environment through the multiple levels of production-like
    branches
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过多级类似生产环境的分支来推广暂存环境
- en: With these concepts in mind, let's inspect what's contained inside of a Puppet
    control repository.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解这些概念之后，接下来我们来检查 Puppet 控制仓库中包含的内容。
- en: Puppetfile
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Puppetfile
- en: 'The heart of the control repository is the `Puppetfile`. The `Puppetfile` acts
    as a list of Puppet modules to be imported on each run of r10k and deployed into
    a Puppet environment matching the branch name of the control repository. It allows
    us to bring in modules from two places: the Puppet Forge and remote Git repositories.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 控制仓库的核心是 `Puppetfile`。`Puppetfile` 作为一个 Puppet 模块的列表，在每次运行 r10k 时都会被导入，并将模块部署到与控制仓库分支名称相匹配的
    Puppet 环境中。它允许我们从两个地方导入模块：Puppet Forge 和远程 Git 仓库。
- en: Pulling modules from the Puppet Forge can be written in shorthand, and at the
    very top of the file you can select a location to search for Forge modules. By
    default, the control repository will direct us to [https://forge.puppet.com](https://forge.puppet.com),
    which allows us to write the module we want to bring in in shorthand. Entering `mod
    "puppetlabs/ntp"` in the `Puppetfile` will pull in the latest version. By simply
    adding a version, such as `mod "puppetlabs/ntp", "7.1.1"`, r10k will ensure that
    only a specific version from the Forge is deployed to an environment. It is generally
    considered a best practice to always include a version with Forge modules, so
    as to not deploy a new major version into an environment unexpectedly.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Puppet Forge 拉取模块可以使用简写形式，在文件的最顶部，你可以选择一个位置来搜索 Forge 模块。默认情况下，控制仓库会将我们指向 [https://forge.puppet.com](https://forge.puppet.com)，这使得我们可以以简写形式编写我们想要引入的模块。在
    `Puppetfile` 中输入 `mod "puppetlabs/ntp"` 会拉取最新版本。通过简单地添加一个版本号，例如 `mod "puppetlabs/ntp",
    "7.1.1"`，r10k 将确保只部署 Forge 中的特定版本到环境中。通常认为最佳实践是始终包含 Forge 模块的版本，以避免意外地将新的主要版本部署到环境中。
- en: 'Additionally, we can point directly to Git repositories. The most common use
    of this is for Puppet modules developed internally by a user or an organization.
    Like the Forge, we can specifically target a version of a Git repository and deploy
    it into an environment. The following is an example of this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以直接指向 Git 仓库。这种用法最常见于用户或组织内部开发的 Puppet 模块。像 Forge 一样，我们可以专门指定一个 Git 仓库的版本，并将其部署到一个环境中。以下是一个示例：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Each line of this entry into the `Puppetfile` actually signifies something to
    r10k. The first line, `mod 'ourapp'`, tells r10k to deploy this repository under
    the name `'ourapp'`, and will deploy the module as that name. This name must match
    the namespace of the module, and, in this case, `config.pp` would need to contain `class
    ourapp::config`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `Puppetfile` 中的每一行实际上都代表着 r10k 的某个指令。第一行，`mod 'ourapp'`，告诉 r10k 以 `'ourapp'`
    这个名称部署该仓库，并将该模块作为该名称进行部署。这个名称必须与模块的命名空间匹配，在本例中，`config.pp` 需要包含 `class ourapp::config`。
- en: The `:git` reference tells r10k where to go to retrieve the code. r10k must
    have SSH keys available to reach this repository, unless the repository allows
    for anonymous cloning. The `ref` tag will actually search for commits, `git` tags,
    and branches, until it finds one that matches the reference. If this repository
    contained a `git` tag named `1.2.2`, r10k would use that particular version of
    code. Note that this method of calling the repository can be troublesome if there
    is a branch named `1.2.2` and a tag named `1.2.2`. `ref` is a shorthand that allows
    you to call a tag, branch, or commit, but they can also be directly called by
    the `:tag`, `:branch`, or `:commit` lines, respectively.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`:git` 引用告诉 r10k 到哪里去获取代码。r10k 必须具备 SSH 密钥才能访问这个仓库，除非仓库允许匿名克隆。`ref` 标签实际上会搜索提交、`git`
    标签和分支，直到找到与引用匹配的一个。如果这个仓库包含名为 `1.2.2` 的 `git` 标签，r10k 将使用该特定版本的代码。请注意，如果存在名为 `1.2.2`
    的分支和标签，调用仓库的这种方法可能会引起问题。`ref` 是一种简写方式，允许你调用标签、分支或提交，但它们也可以通过 `:tag`、`:branch`
    或 `:commit` 直接调用。'
- en: 'The following code is an example of a `Puppetfile` that provides the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个 `Puppetfile` 的示例，它提供了以下内容：
- en: Sets the Forge to the HTTPS version of `forge.puppet.com`
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Forge 设置为 `forge.puppet.com` 的 HTTPS 版本
- en: Includes the latest `puppetlabs/ntp`
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含最新的 `puppetlabs/ntp`
- en: Includes `puppetlabs/stdlib` version 4.25.1
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含 `puppetlabs/stdlib` 版本 4.25.1
- en: Includes `puppetlabs/nginx` version 0.11.0
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含 `puppetlabs/nginx` 版本 0.11.0
- en: Includes three internal applications, called by branch, tag, or commit
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含三个内部应用程序，可以通过分支、标签或提交进行调用
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: hiera.yaml
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: hiera.yaml
- en: 'One of the best features of Hiera in Puppet 5 is that it is included by default,
    and does not require an additional installation. As noted in the previous chapter,
    Puppet 5 gives us three levels of Hiera: global, environment, and data, in modules.
    The environment level of Hiera is contained in the control repository, giving
    us separate data in each environment and allowing us to store all of our Hiera
    data in a single repository.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Hiera在Puppet 5中的最佳功能之一是它默认包含在内，不需要额外安装。正如上一章所述，Puppet 5为我们提供了三个Hiera层级：全局、环境和模块中的数据。环境级别的Hiera包含在控制仓库中，为我们提供每个环境的独立数据，并允许我们将所有Hiera数据存储在一个仓库中。
- en: 'This model allows us to version control all of our data layer in Puppet 5 easily,
    and even merge our data across branches, if we want to iterate development of
    our Hiera data in the same way that we iterate over the development of Puppet
    code. We can use the same Hiera v5 configuration from the [Chapter 4](cea19359-3ab3-4ee7-99d5-be2e4cd1f992.xhtml),
    *Hiera 5*, shown as follows, to set up our data in environments:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模型允许我们轻松地在Puppet 5中进行数据层的版本控制，甚至可以在不同分支之间合并我们的数据。如果我们希望像迭代开发Puppet代码一样迭代开发Hiera数据，我们可以使用[第4章](cea19359-3ab3-4ee7-99d5-be2e4cd1f992.xhtml)中展示的相同的Hiera
    v5配置，*Hiera 5*，如下所示，在各个环境中设置我们的数据：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will use the default `datadir` in the `control-repo`, data, to store our
    Hiera data. If we were to use this hierarchy, our control repository might contain
    the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用`control-repo`中的默认`datadir`（数据目录）来存储我们的Hiera数据。如果我们使用这个层级结构，我们的控制仓库可能包含以下内容：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: site.pp
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: site.pp
- en: 'The `site.pp` is one of the oldest files found on a modern Puppet Master. The
    original intention of `site.pp` was to classify nodes, assigning classes and resources
    to a node to create a catalog. It accepts both regex and string match names, and,
    if used to place code and resources directly on a system, it would contain code
    such as the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`site.pp`是现代Puppet Master中最古老的文件之一。`site.pp`的最初目的是对节点进行分类，将类和资源分配给节点以创建目录。它接受正则表达式和字符串匹配名称，如果用于直接在系统上放置代码和资源，它将包含如下代码：'
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Today, most users no longer store classifications in `site.pp`. Classification
    is handled by an **external node classifier** (**ENC**), such as the Puppet Enterprise
    Console. Hiera has also become a common method of classification, in lieu of an
    ENC. Any code that is not contained to a node in `site.pp` is applied to all nodes
    in the Puppet environment. The following code, placed outside of a node specification,
    searches all levels of a node's Hiera hierarchy for unique classes in an array
    named `classes`, removes anything contained in arrays named `class_exclusions`,
    and then applies them to each node. This allows Hiera to act as the classifier
    for Puppet nodes.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，大多数用户不再将分类存储在`site.pp`中。分类由**外部节点分类器**（**ENC**）处理，例如Puppet Enterprise控制台。Hiera也成为了一种常见的分类方法，取代了ENC。任何未在`site.pp`中限定为节点的代码，都将应用于Puppet环境中的所有节点。以下代码，在节点规格外部放置时，会在节点的Hiera层级结构中搜索名为`classes`的数组中的唯一类，移除任何包含在名为`class_exclusions`的数组中的内容，并将它们应用于每个节点。这使得Hiera能够充当Puppet节点的分类器。
- en: 'The following code enables Hiera as a classification strategy, when placed
    in `site.pp`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码启用Hiera作为分类策略，当它放置在`site.pp`中时：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we had a server named `snowflake.ourcompany.com`, and the following was
    contained in our Hiera hierarchy, we would include `role::ourapp` and `profile::partners::baseline`,
    but exclude `profile::baseline`, even though it was listed as a class in `common.yaml`.
    This ensures that `profile::baseline` is applied everywhere in the infrastructure,
    except for where it is explicitly excluded:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个名为`snowflake.ourcompany.com`的服务器，且以下内容包含在我们的Hiera层级结构中，我们将包括`role::ourapp`和`profile::partners::baseline`，但排除`profile::baseline`，即使它在`common.yaml`中列为一个类。这确保了`profile::baseline`会在整个基础设施中应用，除了那些被显式排除的地方：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can also use our above class exclusions to remove baseline from a particular
    node:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用上面的类排除来从特定节点中移除基线：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`site.pp` also allows us to set some sane defaults to our Puppet code, across
    our entire environment. In the following example, any Windows machine will use
    the package provider `Chocolatey`, by default. `Chocolatey` is a free and open
    source solution to a Yum-like package manager on Windows. If you haven''t tried
    it yet in your Windows environment, it is a significant improvement on installing
    directly from `.msi` or `.exe`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`site.pp` 还允许我们为整个环境的 Puppet 代码设置一些合理的默认值。在以下示例中，任何 Windows 机器将默认使用 `Chocolatey`
    作为包管理器。`Chocolatey` 是一个免费的开源解决方案，类似于 Linux 中的 Yum 包管理器。如果你还没有在 Windows 环境中试过它，它是一个比直接从
    `.msi` 或 `.exe` 安装要好得多的选择：'
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: environment.conf
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: environment.conf
- en: 'The `environment.conf` file is an optional file in a control repository that
    allows you to override some settings in your Puppet environment. As of version
    5.5, five settings are available for `environment.conf`, as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`environment.conf` 文件是控制库中的一个可选文件，允许你覆盖 Puppet 环境中的某些设置。从 5.5 版本开始，`environment.conf`
    提供了五个设置，如下所示：'
- en: '`modulepath`: Where to search for Puppet modules.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modulepath`：搜索 Puppet 模块的位置。'
- en: '`manifest`: Where to search for `site.pp`, or a directory of node manifest
    files, parsed alphabetically.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`manifest`：搜索 `site.pp` 的位置，或按字母顺序解析的节点清单文件目录。'
- en: '`config_version`: A user-defined script to generate the version produced by
    running the Puppet agent.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config_version`：用户定义的脚本，用于生成通过运行 Puppet 代理所产生的版本。'
- en: '`environment_timeout`: How long the Puppet environment caches data about an
    environment.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`environment_timeout`：Puppet 环境缓存环境数据的时间长度。'
- en: '`static_catalogs`: An advanced configuration that internally versions files
    served from the Puppet Master. It is on, by default.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static_catalogs`：一个高级配置，内部版本化从 Puppet 主服务器提供的文件。默认启用。'
- en: 'Additionally, `environment.conf` is able to use variables produced from Puppet
    configurations. In the following example, we set two of the most common settings
    found in an `environment.conf` file:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`environment.conf` 能够使用从 Puppet 配置生成的变量。在以下示例中，我们设置了 `environment.conf` 文件中最常见的两个设置：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Roles and profiles
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色与配置文件
- en: In a previous chapter, we discussed roles and profiles. It is a common practice
    for many small organizations to place their roles and profiles in the control
    repository, as a simple place to get started writing puppet code for your organization. Using
    the previous `environment.conf`, our roles and profiles would be found at `/etc/puppetlabs/code/environments/<environment>/site`,
    as a roles directory and a profiles directory. These would be contained in the
    Git repository, in a `site` folder at the base of the repository.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们讨论了角色与配置文件。对于许多小型组织来说，将角色和配置文件放在控制库中是一个常见做法，因为这是一个简单的地方，可以开始为组织编写 Puppet
    代码。使用之前的 `environment.conf`，我们的角色和配置文件将位于 `/etc/puppetlabs/code/environments/<environment>/site`，作为角色目录和配置文件目录。这些将包含在
    Git 仓库中，位于仓库根目录下的 `site` 文件夹中。
- en: For many larger organizations, accepting commits to a standalone role and standalone
    profile module can be easier to maintain than bundling them into the control repository.
    This provides each environment with the ability to call tagged versions of the
    role and profile modules specifically. Both methodologies are valid, and produce
    the same results on the agents utilizing the code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多较大的组织，接受单独角色和单独配置文件模块的提交，比将它们打包到控制库中更容易维护。这为每个环境提供了调用特定标记版本的角色和配置文件模块的能力。这两种方法都是有效的，并且在使用代码的代理上产生相同的结果。
- en: At the end of this chapter, you will find a guide on a multitenancy control
    repository, which is easier to manage if the role and profile modules are separate
    from the control repository.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，你将找到一个关于多租户控制库的指南，如果角色和配置文件模块与控制库分开，将更容易管理。
- en: Control repository example
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制库示例
- en: 'If we use everything in the control repository as designed in the previous
    examples, a single branch of our control repository will look as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按照前面示例中的设计使用控制库中的所有内容，我们的控制库的单个分支将如下所示：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Installing and using r10k
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和使用 r10k
- en: Generally, if you have Puppet Enterprise, you should use Code Manager instead
    of r10k. If you are a Puppet open source user, or if your environment is a mix
    of both open source and Enterprise nodes, consider a direct installation of r10k.
    There is a Puppet module available on the Forge that installs r10k on an existing
    Puppet Master by Vox Pupuli. It can be found at [https://forge.puppet.com/puppet/r10k](https://forge.puppet.com/puppet/r10k.).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果你拥有 Puppet Enterprise，你应该使用 Code Manager 而不是 r10k。如果你是 Puppet 开源用户，或者你的环境是开源和企业节点的混合体，可以考虑直接安装
    r10k。Forge 上有一个 Puppet 模块，Vox Pupuli 提供的该模块可以在现有的 Puppet Master 上安装 r10k，地址是 [https://forge.puppet.com/puppet/r10k](https://forge.puppet.com/puppet/r10k)。
- en: Once r10k is installed, an environment can be deployed by running `r10k deploy
    environment <branch> -p` on each master as the root user, or as a user with `sudo`
    access. Often, when r10k is used in place of Code Manager, a CI/CD system is used
    to automate the deployment over r10k.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 r10k，可以通过以 root 用户或具有 `sudo` 权限的用户身份在每个 master 上运行 `r10k deploy environment
    <branch> -p` 来部署环境。通常，当 r10k 代替 Code Manager 使用时，CI/CD 系统会被用来自动化通过 r10k 的部署。
- en: Code Manager
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Code Manager
- en: 'Now that r10k has been detailed, let''s explore the Puppet Enterprise version
    of it: Code Manager. Code Manager adds four main features to r10k, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经详细介绍了 r10k，我们来探讨一下它的 Puppet Enterprise 版本：Code Manager。Code Manager 为 r10k
    添加了以下四个主要特性：
- en: File Sync and Rsync across masters from **Master of Masters** (**MoM**)
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件同步与从 **Master of Masters** (**MoM**) 的 Rsync 跨主机同步
- en: RBAC and pe-client-tools provides RBAC access
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RBAC 和 pe-client-tools 提供 RBAC 访问
- en: Automatic environment isolation
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动环境隔离
- en: Easy installation
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单安装
- en: The primary reason to use Code Manager over r10k in Puppet Enterprise is the
    robust RBAC model provided by Puppet Enterprise. Without Git, r10k hooks require
    that you log in to the Puppet Master over SSH or the console and run a command
    to deploy one or more environments. The PE client tools provided by Puppet allow
    a user to generate a short-lived RBAC access token, which is checked against RBAC
    in the Puppet Enterprise Console remotely. This remote RBAC model allows you not
    only to give individuals different levels of access to environment deployment,
    but it also does not require a user to log in to the Puppet Master at all. The
    PE client tools are run from a local workstation and deploy the environment through
    the Puppet Enterprise web API.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puppet Enterprise 中使用 Code Manager 而不是 r10k 的主要原因是 Puppet Enterprise 提供的强大
    RBAC 模型。没有 Git 时，r10k 钩子要求你通过 SSH 或控制台登录到 Puppet Master，运行命令部署一个或多个环境。Puppet 提供的
    PE 客户端工具允许用户生成一个短期有效的 RBAC 访问令牌，并通过远程检查与 Puppet Enterprise Console 中的 RBAC 进行匹配。这个远程
    RBAC 模型不仅可以为不同的人员分配不同级别的环境部署权限，而且完全不需要用户登录到 Puppet Master。PE 客户端工具可以从本地工作站运行，并通过
    Puppet Enterprise Web API 部署环境。
- en: The second major feature is file syncing. r10k deploys code directly into the
    code directory on a single Puppet Master. If an organization has multiple Puppet
    Masters controlled by a Master of Masters, a single command can deploy the code
    base to a code-staging directory on the MoM, which will then be deployed synchronously
    to all Puppet Masters in the environment. Instead of logging in to multiple Puppet
    Masters, you can run the command once, remotely, and allow the MoM to distribute
    code across all of your masters.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个主要特性是文件同步。r10k 直接将代码部署到单个 Puppet Master 的代码目录中。如果一个组织有多个 Puppet Masters，并由
    Master of Masters（MoM）进行控制，使用单一命令即可将代码库部署到 MoM 上的代码暂存目录中，然后该代码会同步部署到环境中的所有 Puppet
    Masters。这样，你无需登录到多个 Puppet Masters，而是可以远程运行一次命令，让 MoM 将代码分发到所有的 Puppet Masters
    上。
- en: Code Manager also ensures that all environment isolation commands are run across
    your system, ensuring that type resources don't accidentally spill over into other
    environments. The open source equivalent to this command is `puppet generate types
    --environment <environment>`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Code Manager 还确保在系统中运行所有环境隔离命令，确保类型资源不会意外地溢出到其他环境。该命令的开源等效命令是 `puppet generate
    types --environment <environment>`。
- en: The final major feature of Code Manager is an easy install. Everything needed
    to enable Code Manager is self-contained in Puppet Enterprise.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Code Manager 的最后一个主要特性是简易安装。启用 Code Manager 所需的一切都包含在 Puppet Enterprise 中。
- en: Enabling Code Manager
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用 Code Manager
- en: 'Enabling Code Manager across your architecture is easy in Puppet Enterprise,
    because it''s prebundled in the system. The only artifact that must be generated
    on each master is the SSH key used to access the control repository and any other
    Git repositories in the `Puppetfile`. These SSH keys should be created with no
    password, and should be protected on the Puppet Master. Additionally, if you are
    using a Git service that supports it, enter this key as a deploy key, rather than
    a user key. Deploy keys only have the ability to check out code, and cannot submit
    code back to the Git server. For a single master, the following commands can be
    run as the root user or with `sudo`, to generate an SSH key:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puppet Enterprise 中启用 Code Manager 非常简单，因为它已经预先捆绑在系统中。每个主节点上必须生成的唯一制品是用于访问控制库和任何其他
    `Puppetfile` 中 Git 仓库的 SSH 密钥。这些 SSH 密钥应该在没有密码的情况下创建，并应在 Puppet Master 上进行保护。此外，如果你使用的
    Git 服务支持它，请将此密钥作为部署密钥，而不是用户密钥。部署密钥仅具有检出代码的权限，不能将代码提交回 Git 服务器。对于单个主节点，可以作为 root
    用户或使用 `sudo` 运行以下命令来生成 SSH 密钥：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The simplest way to enable Code Manager after the generation of a key is to
    enter the classification of a PE Master, underneath the PE Infrastructure in the
    Puppet Enterprise console. Add the following parameters under the `puppet_enterprise::profile::master`
    class:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 Code Manager 的最简单方法是在生成密钥后，进入 Puppet Enterprise 控制台中 PE 基础设施下的 PE Master
    分类。在 `puppet_enterprise::profile::master` 类下添加以下参数：
- en: '`r10k_private_key`: Location of the private key generated and made available
    on the Puppet Master.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r10k_private_key`: 生成并在 Puppet Master 上提供的私钥的位置。'
- en: '`r10k_remote`: Location of the control repository—should be a Git URL.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r10k_remote`: 控制库的位置——应为 Git URL。'
- en: '`code_manager_auto_configure`: Set to true. This lets Puppet set it up automatically.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`code_manager_auto_configure`: 设置为 true。这让 Puppet 自动进行配置。'
- en: '`r10k_proxy` (Optional): Set the URL of a proxy to reach the Forge, if your
    master can only reach the internet via a proxy.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r10k_proxy`（可选）：设置访问 Forge 的代理 URL，如果你的主节点只能通过代理访问互联网。'
- en: 'An example of this classification without a proxy is as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 没有代理的此分类示例如下：
- en: '![](img/83cdd2b7-febb-4d56-80b3-6ad1228f65e5.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83cdd2b7-febb-4d56-80b3-6ad1228f65e5.png)'
- en: 'Some organizations would prefer to store their changes to Puppet in code, rather
    than in the PE console. The following code is also representative of the preceding
    changes, but the Puppet Master will fail to compile catalogs until `puppet_enterprise::profile::master`
    is removed from the PE console. To enable Code Manager with a profile instead
    of through the console, apply the following to the master, after removing the
    same class from the console:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一些组织更愿意将他们对 Puppet 的更改存储在代码中，而不是在 PE 控制台中。以下代码也代表了前述更改，但 Puppet Master 在删除 `puppet_enterprise::profile::master`
    类后，才会成功编译清单。要通过配置文件而不是通过控制台启用 Code Manager，请在删除控制台中的相同类后，将以下内容应用到主节点：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Each of these methods enables Code Manager on the master, enabling remote PE
    client tools to deploy environments from a separate workstation.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法中的每一种都可以在主节点上启用 Code Manager，允许远程 PE 客户端工具从单独的工作站部署环境。
- en: Code Manager RBAC
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Code Manager RBAC
- en: The simplest way to get started with Code Manager and RBAC is to add users to
    the existing user role, Code Deployers. Code Deployers have the ability to deploy
    any environment using the PE client tools. While this may seem too loose of a
    restriction at first, remember that Code Manager is only deploying an existing
    branch of the control repository. It is highly recommended not to prestage your
    code in Git, hoping that users do not run a code deployment and deploy the latest
    version of code. Code deployments should also be considered idempotent, and a
    user should be free to deploy environments at will, usually not overwriting any
    code at all if it is done by mistake.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 Code Manager 和 RBAC 的最简单方法是将用户添加到现有的用户角色 Code Deployers。Code Deployers 可以使用
    PE 客户端工具部署任何环境。虽然一开始这看起来限制过于宽松，但请记住，Code Manager 仅部署控制库的现有分支。强烈建议不要在 Git 中预先存储代码，指望用户不会执行代码部署并部署最新版本的代码。代码部署应被视为幂等的，用户应该可以随意部署环境，通常在出现错误时不会覆盖任何代码。
- en: 'In the following example, I have added myself as a user, added the user to
    the **Code Deployer** role, and maintained the ability to deploy any environment:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我已经将自己添加为用户，并将该用户添加到 **Code Deployer** 角色中，保持能够部署任何环境的权限：
- en: '![](img/c9678104-92b3-4dc0-98da-21619fc70dd3.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9678104-92b3-4dc0-98da-21619fc70dd3.png)'
- en: 'You can see the permission details in the following screenshot:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下截图中查看权限详情：
- en: '![](img/016113b0-be46-4955-9097-befe2b838697.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/016113b0-be46-4955-9097-befe2b838697.png)'
- en: PE client tools
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PE 客户端工具
- en: Code Manager is utilized through the PE client tools. These tools are installed
    by default on the Puppet Master, but for security reasons, we'd rather install
    them on user workstations, to allow for the remote deployment of code and to keep
    users off the Puppet Master. The PE client tools provide us with two new commands: `puppet-access
    login` and `puppet-code deploy <environment>`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Code Manager 是通过 PE 客户端工具来使用的。这些工具默认安装在 Puppet Master 上，但出于安全考虑，我们更倾向于将它们安装在用户工作站上，以便进行远程代码部署，并避免用户直接使用
    Puppet Master。PE 客户端工具为我们提供了两个新命令：`puppet-access login` 和 `puppet-code deploy
    <environment>`。
- en: '`puppet-access login` provides us with an RBAC token with a default lifetime
    of 5 minutes. Users can override this lifetime by adding the `--lifetime=<time>`
    flag to `puppet-access`. Time can be represented in minutes, hours, days, or years,
    with a number followed by `m`, `h`, `d`, or `y`, respectively. To give a half-day
    login, for example, a user should run `puppet-access login --lifetime=4h`. The
    maximum and default lifetime of these tokens is determined by the `puppet_enterprise::profile::console`
    class. The `rbac_token_auth_lifetime` parameter sets the default token that users
    will receive. `rbac_token_maximum_lifetime` sets the maximum lifetime of a token
    a user can request with the `--lifetime` flag. An organization should consider
    its standard login security practices before setting this value.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`puppet-access login` 为我们提供一个 RBAC 令牌，默认生命周期为 5 分钟。用户可以通过为 `puppet-access`
    添加 `--lifetime=<time>` 标志来覆盖这个生命周期。时间可以用分钟、小时、天或年表示，分别以 `m`、`h`、`d` 或 `y` 为单位。例如，要设置半天的登录时间，用户可以运行
    `puppet-access login --lifetime=4h`。这些令牌的最大值和默认生命周期由 `puppet_enterprise::profile::console`
    类来决定。`rbac_token_auth_lifetime` 参数设置用户接收到的默认令牌生命周期。`rbac_token_maximum_lifetime`
    设置用户通过 `--lifetime` 标志请求的令牌最大生命周期。组织在设置此值之前应考虑其标准登录安全实践。'
- en: '`puppet-code deploy <environment>` deploys a particular environment from the
    control repository, and can only be performed with a valid token from `puppet-access`.
    Once the token expires, the user will need to request access through `puppet-access`
    again. Adding the `-w` flag to `puppet-code deploy` will cause the deployment
    to wait and return a message about the status of the deployment. It is recommended
    that users run the `-w` flag when deploying manually, and omit it when a system
    runs a deploy automatically, such as a CI/CD system or a Git hook.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`puppet-code deploy <environment>` 从控制仓库部署特定的环境，并且只能使用 `puppet-access` 提供的有效令牌执行。一旦令牌过期，用户需要重新通过
    `puppet-access` 请求访问权限。通过为 `puppet-code deploy` 添加 `-w` 标志，可以让部署等待并返回部署状态的消息。建议用户在手动部署时使用
    `-w` 标志，而在系统自动执行部署时，如 CI/CD 系统或 Git 钩子，可以省略该标志。'
- en: The first step is to download the PE client tools from the Downloads page of
    Puppet. It is provided for multiple operating systems, including Linux, macOS
    X, and Windows.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是从 Puppet 的下载页面下载 PE 客户端工具。它支持多种操作系统，包括 Linux、macOS X 和 Windows。
- en: 'There are both a system-level configuration file and a user-level configuration
    file that can be set for the PE client tools. User configurations will override
    system configurations. There are two files that we must manage for PE client tools:
    `puppet-access.conf` and `puppet-code.conf`.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: PE 客户端工具可以设置系统级配置文件和用户级配置文件。用户配置会覆盖系统配置。我们必须管理两个 PE 客户端工具的文件：`puppet-access.conf`
    和 `puppet-code.conf`。
- en: System-level configurations are contained at `C:/ProgramData/PuppetLabs/client-tools/`
    on Windows and `/etc/puppetlabs/client-tools` on all other operating systems.
    User configurations are contained at `~/.puppetlabs/client-tools` on all operating
    systems, which will override the system-level configurations.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 系统级配置文件位于 Windows 的 `C:/ProgramData/PuppetLabs/client-tools/` 和所有其他操作系统的 `/etc/puppetlabs/client-tools`。用户配置文件位于所有操作系统的
    `~/.puppetlabs/client-tools`，并会覆盖系统级配置。
- en: Both `puppet-access` and `puppet-login` require a valid CA for the web API.
    By default, this can be found at `/etc/puppetlabs/puppet/ssl/certs/ca.pem` on
    any agent connected to the appropriate Puppet Master. You should copy this file
    locally, if performing development on a machine not managed by Puppet.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`puppet-access` 和 `puppet-login` 都需要一个有效的 CA 来进行 Web API 调用。默认情况下，这个文件可以在任何连接到相应
    Puppet Master 的代理上找到，路径为 `/etc/puppetlabs/puppet/ssl/certs/ca.pem`。如果在非 Puppet
    管理的机器上进行开发，你应该将此文件复制到本地。'
- en: '`puppet-access.conf` is used to provide configuration for the command `puppet-access
    login`, which connects to the Puppet Enterprise RBAC API, and grants a temporary
    login token to be used to deploy code. A `puppet-access.conf` usually contains
    at least the two following attributes:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`puppet-access.conf` 用于提供 `puppet-access login` 命令的配置，该命令连接到 Puppet Enterprise
    的 RBAC API，并授予一个临时登录令牌，用于部署代码。`puppet-access.conf` 通常包含至少以下两个属性：'
- en: '`service-url`: The RBAC API URL for the Puppet Enterprise installation'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`service-url`：Puppet Enterprise 安装的 RBAC API URL'
- en: '`certificate-file`: A valid SSL certificate provided by the master'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`certificate-file`：由主节点提供的有效 SSL 证书'
- en: '[PRE22]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`puppet-code.conf` is similar to `puppet-access.conf` in that it requires a
    certificate and a `service-url` to call. Two things should be noted about `puppet-code.conf`
    in comparison to `puppet-access.conf`. The first thing is that the service URL
    will be different. `puppet-access` calls the RBAC API, while `puppet-code` calls
    the code-manager API. Additionally, although both use the exact same certificate
    from the Puppet Master, you''ll notice that `puppet-code.conf` calls it `cacert`
    instead of `certificate-file`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`puppet-code.conf` 与 `puppet-access.conf` 类似，都需要证书和 `service-url` 进行调用。有两点需要注意的是，与
    `puppet-access.conf` 相比，`puppet-code.conf` 的服务 URL 会有所不同。`puppet-access` 调用 RBAC
    API，而 `puppet-code` 调用代码管理 API。此外，尽管两者都使用来自 Puppet Master 的相同证书，但你会注意到，`puppet-code.conf`
    使用的是 `cacert`，而不是 `certificate-file`：'
- en: '[PRE23]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once setup is complete, a user can use the Code Manager workflow to perform
    the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置完成，用户可以使用 Code Manager 工作流执行以下操作：
- en: Check out code
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看代码
- en: Make changes
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行更改
- en: Push it back to the origin
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推送回源仓库
- en: Run `puppet-access login` to receive a token
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 `puppet-access login` 获取令牌
- en: Run `puppet-code deploy` to deploy the environment
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 `puppet-code deploy` 部署环境
- en: Check results
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查结果
- en: Repeat, if necessary
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如有必要，重复操作
- en: Multitenant control repository
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多租户控制仓库
- en: Larger organizations may need a multitenant setup of Puppet Enterprise Code
    Manager. While fundamentally, the workflow is the same, the way that we structure
    the control repository is slightly different.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 较大的组织可能需要 Puppet Enterprise Code Manager 的多租户设置。虽然从根本上说，工作流是相同的，但我们结构化控制仓库的方式略有不同。
- en: We attempt to minimize the impact of the control repository, turning it into
    a call to libraries of sorts. We want to position our control repository to store
    references to code, rather than code itself. Moving role and profile manifests
    to external repositories allows us to manage them as a versioned artifacts, and
    declare which version is available to each and every enviroinment directly. Our
    control repository only contains the `Puppetfile`, things applied globally with
    `site.pp`, and values that we'd like to make available to the whole organization,
    to use in Hiera.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尽量减少控制仓库的影响，将其转化为类似库的调用。我们希望将控制仓库定位为存储代码引用，而非代码本身。将角色和配置文件清单移动到外部仓库，可以让我们将它们作为版本化的工件进行管理，并直接声明每个环境可以使用的版本。我们的控制仓库仅包含
    `Puppetfile`、使用 `site.pp` 全局应用的内容，以及我们希望对整个组织开放的值，以供在 Hiera 中使用。
- en: 'We make a few minor changes to the workflow to facilitate larger groups, as
    follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对工作流做了一些小改动，以便支持更大的团队，具体如下：
- en: Roles and profiles are exported to standalone modules, tagged with versions,
    and imported by the `Puppetfile`.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色和配置文件会被导出到独立模块中，标记上版本，并通过 `Puppetfile` 导入。
- en: Only values that serve for use across multiple modules, such as LDAP settings,
    are maintained in the environment-level Hiera. All direct calls to a class, such
    as `profile::ntp::servers`, are stored in data, in modules in the appropriate
    repo (in this case, the profile repository).
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有用于多个模块之间共享的值，如 LDAP 设置，才会保存在环境级别的 Hiera 中。所有直接调用类的操作，例如 `profile::ntp::servers`，都会存储在数据中，位于适当仓库中的模块中（在本例中是配置仓库）。
- en: Roles and profiles are migrated to be standalone modules, and each team receives
    their own module, as well. These modules then incorporate their own robust Hiera
    layer in the module, and can be used to provide roles and profiles to each team.
    If we had a team developing an application called `myapp`, they would create a
    module called `myapp` and include a `role` and `profile` folder. Our namespacing
    changes a little bit, but allows us to look at modules as a collection of roles
    and profiles per team. The original `role` and `profile` repositories become a
    house for code commonly used by the whole organization, such as security baselines
    or web server defaults.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 角色和配置文件被迁移为独立模块，并且每个团队也会获得自己的模块。这些模块然后在模块中加入自己的强大Hiera层次，并可用于为每个团队提供角色和配置文件。如果我们有一个开发名为`myapp`的应用程序的团队，他们将创建一个名为`myapp`的模块，并包含`role`和`profile`文件夹。我们的命名空间会发生一些变化，但这使得我们可以将模块视为每个团队的角色和配置文件集合。原始的`role`和`profile`仓库变成了整个组织常用代码的存放地，如安全基线或Web服务器默认配置。
- en: 'The following code can then be produced by the `myapp` team, which provides
    the strengths of Hiera, roles, and profiles to each of these repositories:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可以由`myapp`团队生成，它为这些仓库提供了Hiera、角色和配置文件的强大功能：
- en: '[PRE24]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This methodology, combined with other practices in this chapter, such as protected
    branches, allows teams to work at different paces on different projects, while
    not holding other teams in the organization back. It limits the control repository
    to describing an environment, and opens up roles and profiles to receive code
    contributions from anywhere in the organization, with RBAC and governance in place
    to ensure that proper code reviews are performed before accepting code for the
    entire organization.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法论结合了本章中的其他实践，如受保护分支，使得团队可以在不同的项目上以不同的速度工作，同时不会拖慢组织中其他团队的进度。它将控制库限制为仅描述环境，并开放角色和配置文件，以便从组织的任何地方接收代码贡献，同时通过RBAC和治理措施确保在接受代码之前进行适当的代码审查。
- en: 'Our significantly smaller control repository now looks as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们大大缩小后的控制库现在如下所示：
- en: '[PRE25]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And our team module acts like a small control repo for us, with a hiera hierarchy,
    roles and profiles:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的团队模块就像是一个小型的控制库，具有Hiera层次结构、角色和配置文件：
- en: '[PRE26]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we discussed Git, r10k, and Code Manager. We highlighted the
    logical separation of `production-like` and `non-production-like` environments.
    The contents of a control repository were laid out: `Puppetfile`, `hiera.yaml`,
    `environment.conf`, `site.pp`, and various types of code, such as `roles` and
    `profiles`. We covered enabling Code Manager and using the PE client tools to
    interact with Puppet Code Manager. Finally, we discussed a multitenant, Enterprise-focused
    control repository format that exports roles and profiles to standalone modules
    and uses data in modules to provide a Hiera hierarchy to each team in an organization.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Git、r10k和Code Manager。我们强调了`生产环境类`和`非生产环境类`的逻辑分离。我们列出了控制库的内容：`Puppetfile`、`hiera.yaml`、`environment.conf`、`site.pp`以及各种类型的代码，如`roles`和`profiles`。我们介绍了启用Code
    Manager并使用PE客户端工具与Puppet Code Manager进行交互的过程。最后，我们讨论了一种多租户、面向企业的控制库格式，该格式将角色和配置文件导出为独立的模块，并使用模块中的数据为组织中的每个团队提供Hiera层次结构。
- en: In the next chapter, we'll focus on integrating a workflow to our code development.
    We'll expand our work into the PDK and inspect good development practice.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于将工作流整合到我们的代码开发中。我们将扩展我们的工作到PDK，并检查良好的开发实践。
