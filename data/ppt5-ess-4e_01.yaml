- en: Writing Your First Manifests
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写你的第一个清单
- en: Configuration management has become essential to the IT world. Faster development
    using agile methods has a huge impact on IT operations that need to keep pace
    with the faster deployment of systems. Server operations in general are hardly
    even feasible without a robust management infrastructure. Among the available
    tools, Puppet has established itself as one of the most popular and widespread
    solutions. Originally written by Luke Kanies, the tool is now distributed under
    the terms of Apache License 2.0 and maintained by Luke's company, Puppet Inc.
    It boasts a large and bustling community, rich APIs for plugins and supporting
    tools, outstanding online documentation, and a great security model based on SSL
    authentication.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理已经成为IT世界中至关重要的一部分。使用敏捷方法进行更快的开发对IT运营产生了巨大影响，IT运营需要跟上更快的系统部署速度。没有强大的管理基础设施，服务器操作几乎是不可行的。在众多可用工具中，Puppet已经确立了自己作为最受欢迎和最广泛应用的解决方案之一。最初由Luke
    Kanies编写，这个工具现在在Apache 2.0许可证下分发，并由Luke的公司Puppet Inc维护。它拥有一个庞大且充满活力的社区，丰富的插件API和支持工具，出色的在线文档，以及基于SSL认证的强大安全模型。
- en: Like all configuration management systems, Puppet allows you to maintain a central
    repository of infrastructure definitions, along with a toolchain to enforce the
    desired state on the systems under management. The whole feature set is quite
    impressive. This book will guide you through some steps to quickly grasp the most
    important aspects and principles of Puppet.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 和所有配置管理系统一样，Puppet允许你维护一个基础设施定义的中央仓库，以及一个工具链，用于在受管系统上强制执行所需的状态。整个功能集非常令人印象深刻。本书将引导你通过一些步骤，快速掌握Puppet最重要的方面和原则。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Getting started
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用
- en: Introducing resources, parameters, and properties
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍资源、参数和属性
- en: Interpreting the output of the `puppet apply` command
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释`puppet apply`命令的输出
- en: Using variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变量
- en: Adding control structures in manifests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在清单中添加控制结构
- en: Controlling the order of execution
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制执行顺序
- en: Implementing resource interaction
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现资源交互
- en: Examining Puppet core resource types
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查Puppet核心资源类型
- en: Getting started
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用
- en: Installing Puppet is easy. On large Linux distributions, you can just install
    the Puppet package via `apt-get` or `yum`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Puppet很简单。在大型Linux发行版上，你可以通过`apt-get`或`yum`直接安装Puppet软件包。
- en: 'The installation of Puppet can be done in the following ways:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet的安装可以通过以下方式完成：
- en: From default operating system repositories
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从默认的操作系统仓库安装
- en: From Puppet Inc
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自Puppet Inc
- en: The former way is generally simpler. [Chapter 2](7cafeeab-0e5c-4848-9eb0-1bae38ed3525.xhtml),
    *Puppet Server and Agents*, provides simple instructions to install the Puppet
    Inc packages. A platform-independent way to install Puppet is to get the `puppet`
    Ruby gem. This is fine for testing and managing single systems, but it is not
    recommended for production use.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 前一种方式通常更简单。[第2章](7cafeeab-0e5c-4848-9eb0-1bae38ed3525.xhtml)，*Puppet服务器和代理*，提供了简单的安装Puppet
    Inc软件包的说明。安装Puppet的跨平台方式是获取`puppet` Ruby gem。这种方式适合用于测试和管理单一系统，但不推荐用于生产环境。
- en: 'After installing Puppet, you can use it right away. Puppet is driven by manifests,
    the equivalent of scripts or programs, written in Puppet''s **Domain-Specific
    Language** (**DSL**). Let''s start with the obligatory `Hello, world!` manifest:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Puppet后，你可以立即使用它。Puppet由清单驱动，清单相当于脚本或程序，使用Puppet的**领域特定语言**（**DSL**）编写。我们从必备的`Hello,
    world!`清单开始：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Downloading the example code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下载示例代码：
- en: You can download the example code files for all the Packt Publishing books you
    have purchased from your account at [http://www.packtpub.com](http://www.packtpub.com).
    If you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register yourself to have the files emailed directly to you.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你在[http://www.packtpub.com](http://www.packtpub.com)的账户中下载你购买的所有Packt Publishing书籍的示例代码文件。如果你在其他地方购买了本书，可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)，并注册自己以便将文件直接通过电子邮件发送给你。
- en: 'To put the manifest to work, use the following command (we avoided the term
    `execute` on purpose-manifests cannot be executed; more details will follow around
    the middle of this chapter):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使清单生效，请使用以下命令（我们特意避免使用`execute`这个术语——清单不能被执行；更多细节将在本章中段介绍）：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The package from Puppet Inc. bundles all required software components and installs
    to `/opt/puppetlabs`. In the case that the puppet command cannot be found, you
    can either specify the full path (`/opt/puppetlabs/bin/puppet`) or you can refresh
    your shell environment (`exec` bash, or log out and log in again).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet Inc. 提供的软件包包含所有必需的软件组件，并安装到 `/opt/puppetlabs`。如果找不到 puppet 命令，你可以指定完整路径（`/opt/puppetlabs/bin/puppet`），或者刷新你的
    shell 环境（`exec` bash，或注销并重新登录）。
- en: 'Before we take a look at the structure of the manifest and the output from
    the `puppet apply` command, let''s do something useful, just as an example. Puppet
    comes with its own background service. Let''s assume that you want to learn the
    basics before letting it mess with your system. You can write a manifest to have
    Puppet make sure that the service is not currently running and will not be started
    at system boot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看清单的结构和 `puppet apply` 命令的输出之前，先做一些有用的事情，作为示例。Puppet 自带其背景服务。假设你想在让它干扰系统之前先了解基本原理。你可以编写一个清单，让
    Puppet 确保该服务当前没有运行，并且不会在系统启动时启动：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To control system processes, boot options, software installation, and the same
    as the Puppet needs to be run with `root` privileges. This is the most common
    way to invoke the tool, because Puppet will often manage OS-level facilities.
    Apply your new manifest with root access, either through `sudo` or from a root
    shell, as shown in the following transcript:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制系统进程、启动选项、软件安装等，Puppet 需要以 `root` 权限运行。这是调用该工具最常见的方式，因为 Puppet 通常会管理操作系统级别的设施。通过
    `sudo` 或从 root shell 中，以 root 权限应用你的新清单，如下所示：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, Puppet has disabled the automatic startup of its background service for
    you. Applying the same manifest again has no effect, because the necessary steps
    are already complete:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Puppet 已为你禁用了其后台服务的自动启动。再次应用相同的清单没有效果，因为所需的步骤已经完成：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This reflects a standard behavior in Puppet: Puppet resources are **idempotent**,
    which means that every resource first compares the actual (system) with the desired
    (Puppet) state and only initiates actions in case there is a difference (configuration
    drift).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这反映了 Puppet 中的一个标准行为：Puppet 资源是**幂等的**，这意味着每个资源首先会将实际（系统）状态与期望（Puppet）状态进行比较，只有在存在差异（配置漂移）时才会启动操作。
- en: You will often get this output from Puppet. It tells you that everything is
    as it should be. As such, this is a desirable outcome, like the all clean output
    from git status.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会看到 Puppet 输出这样的内容。它告诉你一切都按预期进行。因此，这是一个理想的结果，就像 git status 输出的“清洁”一样。
- en: Introducing resources, parameters, and properties
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍资源、参数和属性
- en: Each of the manifests you wrote in the previous section declared one respective
    resource. Resources are the elementary building blocks of manifests. Each has
    a type (in this case, `notify` and `service`, respectively) and a name or title
    (`Hello, world!` and `puppet`). Each resource is unique to a manifest, and can
    be referenced by the combination of its type and name, such as `Service["puppet"]`.
    Finally, a resource also comprises a list of zero or more attributes. An attribute
    is a key-value pair, such as `"enable => false"`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你在前一部分编写的每个清单都声明了一个相应的资源。资源是清单的基本构建块。每个资源都有一个类型（在此案例中分别为 `notify` 和 `service`）和一个名称或标题（`Hello,
    world!` 和 `puppet`）。每个资源对于清单来说是唯一的，可以通过其类型和名称的组合来引用，例如 `Service["puppet"]`。最后，一个资源还包括一个零个或多个属性的列表。属性是键值对，例如
    `"enable => false"`。
- en: 'Attribute names cannot be chosen arbitrarily. They are part of the Puppet resource
    type. Puppet differentiates between two different attributes: parameters and properties.
    Each resource type supports a specific set of attributes. Parameters describe
    the way that Puppet should deal with a resource type. Properties describe a specific
    setting of a resource. Certain parameters are available for all resource types
    (metaparameters), and some names are just very common, such as `ensure`. The `service`
    type supports the `ensure` property, which represents the status of the managed
    process. Its `enabled` property, on the other hand, relates to the system boot
    configuration (with respect to the service in question).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 属性名称不能随意选择。它们是 Puppet 资源类型的一部分。Puppet 区分两种不同的属性：参数和特性。每种资源类型支持一组特定的属性。参数描述 Puppet
    应该如何处理资源类型，特性描述资源的特定设置。某些参数适用于所有资源类型（元参数），而一些名称则非常常见，例如 `ensure`。`service` 类型支持
    `ensure` 特性，它表示受管理进程的状态。另一方面，它的 `enabled` 特性与系统引导配置相关（针对特定服务）。
- en: We have used the terms attribute, property, and parameter in a seemingly interchangeable
    fashion. Don't be deceived-there are important distinctions. Property and parameter
    are the two different kinds of attributes that Puppet uses.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了属性、特性和参数这几个术语，看似可以互换使用。不要被迷惑——它们之间有重要的区别。特性和参数是 Puppet 使用的两种不同的属性。
- en: 'You have already seen two properties in action. Let''s look at a parameter:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看过两个特性的实际应用。现在让我们来看一个参数：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `provider` parameter tells Puppet that it needs to interact with the `upstart`
    subsystem to control its background service, as opposed to `systemd` or `init`.
    If you don't specify this parameter, Puppet makes an educated guess. There is
    quite a multitude of supported facilities to manage services on a system. You
    will learn more about providers and their automatic choosing later on.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`provider` 参数告诉 Puppet 需要与 `upstart` 子系统交互来控制其后台服务，而不是与 `systemd` 或 `init`
    交互。如果不指定该参数，Puppet 会做出智能猜测。系统上有很多支持的工具来管理服务。稍后你将了解更多关于提供者及其自动选择的内容。'
- en: 'The difference between parameters and properties is that the parameter merely
    indicates how Puppet should manage the resource, not what a desired state is.
    Puppet will only take action on property values. In this example, these are `ensure
    => ''stopped''` and `enable => false`. For each such property, Puppet will perform
    the following tasks:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 参数和属性的区别在于，参数仅指示 Puppet 应该如何管理资源，而不是期望的状态是什么。Puppet 只会对属性值进行操作。在这个例子中，它们是 `ensure
    => 'stopped'` 和 `enable => false`。对于每个这样的属性，Puppet 将执行以下任务：
- en: Test whether the resource is already in sync with the target state
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试资源是否已经与目标状态同步。
- en: If the resource is not in sync, it will trigger a sync action
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果资源未同步，它将触发同步操作。
- en: A property is considered to be in sync when the system entity that is managed
    by the given resource (in this case, the `upstart` service configuration for Puppet)
    is in the state that is described by the property value in the manifest. In this
    example, the `ensure` property will be in sync only if the `puppet` service is
    not running. The `enable` property is in sync if `upstart` is not configured to
    launch Puppet at system start.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当由给定资源管理的系统实体（在此例中是 Puppet 的 `upstart` 服务配置）处于与属性值在清单中描述的状态一致时，属性被认为是同步的。在这个例子中，只有当
    `puppet` 服务未运行时，`ensure` 属性才会是同步的。如果 `upstart` 没有配置为在系统启动时启动 Puppet，则 `enable`
    属性是同步的。
- en: As a mnemonic concerning parameters versus properties, just remember that properties
    can be out of sync, whereas parameters cannot.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个帮助记忆的提示，记住，特性可以不同步，而参数则不可以。
- en: 'Puppet also allows you to read your existing system state by using the puppet
    resource command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 还允许你通过使用 `puppet resource` 命令读取现有的系统状态：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Please note that some resource types will return read-only attributes (for example,
    the file resource type will return `mtime` and `ctime`). Refer to the appropriate
    type's documentation.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，某些资源类型会返回只读属性（例如，文件资源类型会返回 `mtime` 和 `ctime`）。请参阅相关类型的文档。
- en: Interpreting output of the puppet apply command
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释 `puppet apply` 命令的输出。
- en: 'As you have already witnessed, the output presented by Puppet is rather verbose.
    As you get more experienced with the tool, you will quickly learn to spot the
    crucial pieces of information. Let''s first take a look at the informational messages,
    though. Apply the `service.pp` manifest once more:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你已经看到的，Puppet 输出的信息相当冗长。随着你对工具的熟悉，你会迅速学会识别关键信息。让我们首先看看信息性消息。再一次应用 `service.pp`
    清单：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Puppet took no particular action. You only get two timings: one from the compiling
    phase of the manifest, and the other from the catalog application phase. The catalog
    is a comprehensive representation of a compiled manifest. Puppet bases all its
    efforts concerning the evaluation and syncing of resources on the content of its
    current catalog.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 没有采取任何特定的行动。你只会得到两个时间戳：一个来自清单的编译阶段，另一个来自目录应用阶段。目录是编译清单的全面表示。Puppet 基于当前目录的内容来评估和同步资源。
- en: 'Now, to quickly force Puppet to show you some more interesting output, pass
    it a one-line manifest directly from the shell. Regular users of Ruby or Perl
    will recognize the call syntax:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了快速强制 Puppet 显示一些更有趣的输出，可以直接从 shell 传递一行清单。Ruby 或 Perl 的常用用户会认出这种调用语法：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We prefer double quotes in manifests that get passed as command-line arguments,
    because on the shell, the manifest should be enclosed in single quotes as a whole.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更倾向于在作为命令行参数传递的清单中使用双引号，因为在 shell 中，清单应整体用单引号括起来。
- en: 'You instructed Puppet to perform yet another change on the Puppet service.
    The output reflects the exact change that was performed. Let''s analyze this log
    message:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你指示 Puppet 对 Puppet 服务执行另一次更改。输出反映了实际执行的更改。让我们分析一下这个日志消息：
- en: The `Notice:` keyword at the beginning of the line represents the log level.
    Other levels include `Warning`, `Error`, and `Debug`
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行首的 `Notice:` 关键字表示日志级别。其他级别包括 `Warning`（警告）、`Error`（错误）和 `Debug`（调试）
- en: The property that changed is referenced with a whole path, starting with `Stage[main]`.
    Stages are beyond the scope of this book, so you will always just see the default
    of `main` here
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改的属性通过完整路径进行引用，从 `Stage[main]` 开始。Stages 超出了本书的范围，因此你在这里总是看到默认的 `main`。
- en: The next path element is `Main`, which is another default. It denotes the class
    in which the resource was declared. You will learn about classes in [Chapter 4](daf11a18-5de2-4c3c-9880-e9a242ffb35b.xhtml),
    *Combining Resources in Classes and Defined Types*
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个路径元素是 `Main`，它是另一个默认值。它表示声明该资源的类。你将在 [第 4 章](daf11a18-5de2-4c3c-9880-e9a242ffb35b.xhtml)《*在类和定义类型中组合资源*》中学习类。
- en: Next, is the resource. You already learned that `Service[puppet]` is its unique
    reference
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是资源。你已经学到，`Service[puppet]` 是它的唯一引用
- en: Finally, `enable` is the name of the property in question. When several properties
    are out of sync, there will usually be one line of output for each property that
    gets synchronized
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`enable` 是相关属性的名称。当多个属性不同步时，通常每个属性都会有一行输出，表示该属性已同步。
- en: The rest of the log line indicates the type of change that Puppet saw fit to
    apply. The wording depends on the nature of the property. It can be as simple
    as `created`, for a resource that is newly added to the managed system, or a short
    phrase, such as `changed false to true`
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志行的其余部分表示 Puppet 认为合适应用的更改类型。表述方式取决于属性的性质。它可以像 `created`（已创建）一样简单，表示新添加到管理系统的资源，或者像
    `changed false to true`（更改 false 为 true）这样简短的短语。
- en: Dry testing your manifest
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 干运行你的清单
- en: Another useful command-line switch for `puppet apply` is the `--noop` option.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`puppet apply` 的另一个有用的命令行选项是 `--noop`。'
- en: It instructs Puppet to refrain from taking any action on unsynced resources.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 它指示 Puppet 在资源不同步时不执行任何操作。
- en: 'Instead, you only get a log output that indicates what will change without
    the switch. This is useful in determining whether a manifest would possibly break
    anything on your system:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你只会得到一条日志输出，表明在没有该选项时将会发生什么变化。这对于判断清单是否可能会破坏系统上的任何内容非常有用：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The output format is the same as before, with a (`noop`) marker trailing the
    notice about the sync action. This log can be considered a preview of what will
    happen when the manifest is applied without the `--noop` switch.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 输出格式与之前相同，日志末尾带有一个标记为 (`noop`) 的标记，表示同步操作。这个日志可以视为应用清单时的预览，假如不使用 `--noop` 选项。
- en: The additional notices about triggered refreshes will be described later, and
    can be ignored for the moment. You will have a better understanding of their significance
    after finishing this chapter and [Chapter 4](daf11a18-5de2-4c3c-9880-e9a242ffb35b.xhtml),
    *Combining Resources in Classes and Defined Types.*
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 关于触发刷新时的额外通知将在后面描述，目前可以忽略。完成本章和[第4章](daf11a18-5de2-4c3c-9880-e9a242ffb35b.xhtml)，*类和定义类型中的资源组合*后，你将更好地理解它们的意义。
- en: Using variables
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用变量
- en: 'Variable assignment works just like it does in most scripting languages. Any
    variable name is always prefixed with the `$` sign:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 变量赋值的工作方式与大多数脚本语言相同。任何变量名都始终以 `$` 符号开头：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Also, just like most scripting languages, Puppet performs variable value substitution
    in strings that are in double quotes, but no interpolation at all in single-quoted
    strings.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，像大多数脚本语言一样，Puppet 在双引号中的字符串内执行变量值替换，但在单引号字符串中不进行任何插值。
- en: Variables are useful for making your manifest more concise and comprehensible.
    They help you with the overall goal of keeping your source code free from redundancy.
    An important distinction from variables in imperative programming and scripting
    languages is the immutability of variables in Puppet manifests. Once a value has
    been assigned, it cannot be overwritten.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 变量对于使清单更简洁和易懂非常有用。它们帮助你实现保持源代码不冗余的总体目标。与命令式编程和脚本语言中的变量的一个重要区别是，Puppet 清单中的变量是不可变的。一旦一个值被赋值，它就不能被覆盖。
- en: Why is it called a variable at all if it is a constant? One should never look
    at Puppet as a tool that manages a single system. For a single system, a Puppet
    variable might look like a constant, but Puppet manages a multitude of systems
    with different operating systems. Across all these systems, variables will be
    different and not constants.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它是常量，为什么还叫做变量呢？人们不应将 Puppet 仅视为一个管理单一系统的工具。对于单一系统，Puppet 变量可能看起来像一个常量，但 Puppet
    管理着多个操作系统不同的系统。在所有这些系统中，变量将会不同，而不是常量。
- en: Variable types
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量类型
- en: 'As of Puppet 3.x, there are only four variable types: strings, arrays, hashes,
    and Booleans. Puppet 4 introduces a rich data type system. The new data type system
    will be explained at the end of, [Chapter 7](b38488ca-86a7-4ecf-9a69-16938576d852.xhtml),
    *New Features from Puppet 4 and 5*. The basic variable types work much like their
    respective counterparts in other languages. Depending on your background, you
    might be familiar with using associative arrays or dictionaries as semantic equivalents
    to Puppet''s hash type:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Puppet 3.x 开始，只有四种变量类型：字符串、数组、哈希和布尔值。Puppet 4 引入了一个丰富的数据类型系统。新数据类型系统将在[第7章](b38488ca-86a7-4ecf-9a69-16938576d852.xhtml)，*Puppet
    4 和 5 的新特性*的最后部分进行解释。这些基本的变量类型与其他语言中的相应类型工作方式类似。根据你的背景，你可能已经熟悉使用关联数组或字典作为 Puppet
    的哈希类型的语义等效物：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Accessing the values is equally simple. Note that the `hash` syntax is similar
    to that of Ruby, not Perl:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 访问值同样简单。请注意，`hash`语法类似于 Ruby，而不是 Perl：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Strings can be used as resource attribute values, but it''s worth noting that
    a resource title can also be a variable reference:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串可以作为资源属性值使用，但值得注意的是，资源标题也可以是变量引用：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It''s intuitively clear what a string value means in this context. But you
    can also pass arrays here to declare a whole set of resources in one statement.
    The following manifest manages three packages, making sure that they are all installed:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，字符串值的含义直观清晰。但你也可以在此传递数组，用一条语句声明一组资源。以下清单管理三个包，确保它们都已安装：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You will learn how to make efficient use of hash values in later chapters.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在后面的章节中学习如何高效地使用哈希值。
- en: The array does not need to be stored in a variable to be used, but it is a good
    practice in some cases.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 数组不需要存储在变量中就可以使用，但在某些情况下，将其存储在变量中是一个好习惯。
- en: Data types
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型
- en: The data type system in Puppet 4 allows you to check and verify whether a variable
    is of a specific data type. This prevents code from behaving incorrectly when
    (for example) it expects an array but receives a Boolean value.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 4 中的数据类型系统允许你检查和验证一个变量是否属于特定的数据类型。这可以防止代码在（例如）预期为数组却接收到布尔值时表现不正确。
- en: The full power of data types will be explained in [Chapter 7](b38488ca-86a7-4ecf-9a69-16938576d852.xhtml),
    *New Features from Puppet 4 and 5*. Within Puppet manifests, it is possible to
    check for data types using the regexp control structure.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型的完整功能将在 [第七章](b38488ca-86a7-4ecf-9a69-16938576d852.xhtml)，《Puppet 4 和 5
    的新特性》中详细解释。在 Puppet 清单中，可以使用正则表达式控制结构来检查数据类型。
- en: Puppet has core data types and abstract data types. The core data types are
    the most commonly used types of data, such as string or integer, whereas abstract
    data types allow for more sophisticated type validation, such as optional or variant.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 有核心数据类型和抽象数据类型。核心数据类型是最常用的数据类型，例如字符串或整数，而抽象数据类型允许进行更复杂的类型验证，如可选类型或变体类型。
- en: Prior to dealing with data types, we must understand the concept of control
    structures within Puppet manifests.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理数据类型之前，我们必须理解 Puppet 清单中的控制结构概念。
- en: Adding control structures in manifests
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在清单中添加控制结构
- en: So far, you have written three simple manifests while following the instructions
    in this chapter. Each comprised only one resource, and one of them was given on
    the command line using the `-e` option. Of course, you would not want to write
    distinct manifests for each possible circumstance. Instead, just as how Ruby or
    Perl scripts branch out into different code paths, there are structures that make
    your Puppet code flexible and reusable for different circumstances.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经根据本章的指引编写了三个简单的清单。每个清单只包含一个资源，其中一个是通过命令行的 `-e` 选项传入的。当然，你不可能为每一种情况都编写不同的清单。相反，就像
    Ruby 或 Perl 脚本会根据不同的条件分支出不同的代码路径一样，Puppet 代码也有一些结构，使其能够根据不同的情况变得灵活和可重用。
- en: 'The most common control element is the `if`/`else` block. It is quite similar
    to its equivalents in many programming languages:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的控制结构是 `if`/`else` 块。它与许多编程语言中的相应结构非常相似：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The Puppet DSL also has a `case` statement, which is reminiscent of its counterparts
    in other languages as well:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 的 DSL 也有一个 `case` 语句，类似于其他语言中的 `case`：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: At the second matcher, you can see how it is possible to use regular expressions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个匹配器中，你可以看到如何使用正则表达式。
- en: 'The case statement can also be used to switch to specific code based on variable
    data types:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`case` 语句还可以根据变量的数据类型切换到特定的代码：'
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A variation of the `case` statement is the selector. It''s an expression, not
    a statement, and can be used in a fashion similar to the ternary `if`/`else` operator
    found in C-like languages:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`case` 语句的一种变体是选择器。它是一个表达式，而不是语句，可以像 C 类语言中的三元 `if`/`else` 操作符一样使用：'
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Similar to the case statement, the selector can also be used to return results,
    depending on the data types:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `case` 语句，选择器也可以根据数据类型返回结果：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The selector should be used with caution, because in more complex manifests,
    this syntax will impede readability.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器的使用需要小心，因为在更复杂的清单中，这种语法会影响可读性。
- en: Controlling the order of execution
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制执行顺序
- en: With what you've seen this far, you might have got the impression that Puppet's
    DSL is a specialized scripting language. That is actually quite far from the truth.
    A manifest is not a script or program. The language is a tool to model a system
    state through a set of resources, including files, packages, and cron jobs, among
    others.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能已经有了这样的印象：Puppet 的 DSL 是一种专业化的脚本语言。但实际上，这种印象是错误的。清单（manifest）不是脚本或程序。该语言是一种工具，用于通过一组资源（包括文件、软件包和定时任务等）来建模系统状态。
- en: The whole paradigm is different from that of scripting languages. Ruby or Perl
    are imperative languages that are based around statements that will be evaluated
    in a strict order. The Puppet DSL is declarative, which means that the manifest
    declares a set of resources that are expected to have certain properties. These
    resources are put into a catalog, and Puppet then tries to build a path through
    all declared resources. The compiler parses the manifests in order, but the configurer
    applies resources in a very different way.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 整个范式与脚本语言不同。Ruby 或 Perl 是命令式语言，基于一系列按严格顺序执行的语句。而 Puppet 的 DSL 是声明式的，这意味着清单声明了一组期望具有特定属性的资源。这些资源被放入一个目录中，Puppet
    然后尝试在所有声明的资源中构建一条路径。编译器按顺序解析清单，但配置器以非常不同的方式应用资源。
- en: In other words, the manifests should always describe what you expect to be the
    end result. The specifics of what actions need to be taken to get there are decided
    by Puppet.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，清单应该始终描述你期望的最终结果。达到这个结果所需的具体操作由Puppet决定。
- en: 'To make this distinction more clear, let''s look at an example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地说明这一点，让我们看一个例子：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With this manifest, Puppet will make sure that the following state is reached:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个清单，Puppet将确保以下状态被实现：
- en: The `HAproxy` package is installed.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装了`HAproxy`包。
- en: The `haproxy.cfg` file has specific content, which has been prepared in a file
    in `/etc/puppet/modules/`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`haproxy.cfg`文件有特定的内容，这些内容已准备好并保存在`/etc/puppet/modules/`目录下的文件中。'
- en: '`HAproxy` is started.'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动了`HAproxy`。
- en: 'To make this work, it is important that the necessary steps are performed in
    order:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个工作生效，重要的是必须按照顺序执行必要的步骤：
- en: A configuration file cannot usually be installed before the package because
    there is not yet a directory to contain it
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件通常无法在包之前安装，因为还没有目录来容纳它。
- en: The service cannot start before installation either. If it becomes active before
    the configuration is in place, it will use the default settings from the package
    instead
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务在安装之前无法启动。如果它在配置完成之前变为活动状态，它将使用来自包的默认设置。
- en: This point is being stressed because the preceding manifest does not, in fact,
    contain cues for Puppet to indicate such a strict ordering. Without explicit dependencies,
    Puppet is free to put the resources in any order it sees fit.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 强调这一点是因为前面的清单实际上并未包含Puppet指示严格排序的提示。没有显式的依赖关系，Puppet可以自由地按其认为合适的顺序排列资源。
- en: 'The recent versions of Puppet allow a form of local manifest-based ordering,
    so the presented example will actually work as is. The manifest-based ordering
    can be configured in the `puppet.conf` configuration file as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet的最新版本允许一种基于本地清单的排序方式，因此呈现的例子实际上会按原样工作。基于清单的排序可以在`puppet.conf`配置文件中按如下方式配置：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This setting is default for Puppet 4\. It is still important to be aware of
    the ordering principles because the implicit order is difficult to determine in
    more complex manifests, and as you will learn soon, there are other factors that
    will influence the order.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置是Puppet 4的默认设置。仍然重要的是要了解排序原则，因为在更复杂的清单中，隐式顺序很难确定，而且正如你很快将学到的那样，还有其他因素会影响顺序。
- en: Declaring dependencies
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明依赖关系
- en: 'The easiest way to bring order to such a straightforward manifest is resource
    chaining. The syntax for this is a simple ASCII arrow between two resources:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将这种简单的清单整理成有序的方式最简单的方法是资源链式连接。其语法是在两个资源之间使用一个简单的ASCII箭头：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is only viable if all the related resources can be written next to each
    other. In other words, if the graphic representation of the dependencies does
    not form a straight chain, but more of a tree, star, or any other shape, this
    syntax is not sufficient.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当所有相关资源可以彼此紧挨着写时，这种方法才可行。换句话说，如果依赖关系的图形表示并不是一条直链，而是一个树形、星形或其他任何形状，这种语法就不够用了。
- en: Internally, Puppet *will* construct an ordered graph of resources and synchronize
    them during a traversal of that graph.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，Puppet *将*构建一个有序的资源图，并在遍历该图时同步它们。
- en: A more generic and flexible way to declare dependencies is through special metaparameters-parameters
    that are eligible for use with any resource type. There are different metaparameters,
    most of which have nothing to do with ordering (you have seen `provider` in an
    earlier example). For resource ordering, Puppet offers the metaparameters require
    and before.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更通用且灵活的声明依赖关系的方法是通过特殊的元参数——这些参数可以与任何资源类型一起使用。有不同的元参数，其中大多数与排序无关（你在前面的例子中见过`provider`）。对于资源排序，Puppet提供了`require`和`before`元参数。
- en: 'Both take one or more references to a declared resource as their value. As
    was previously mentioned, Puppet references have a special syntax:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都将一个或多个已声明资源的引用作为其值。如前所述，Puppet引用有一个特殊的语法：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can only build references to resources that are declared in the catalog.
    You cannot build and use references to something that is not managed by Puppet,
    even when it exists on the managed system.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能构建指向在目录中声明的资源的引用。即使在被管理的系统中存在，你也不能构建和使用指向未被Puppet管理的东西的引用。
- en: 'Here is the `HAproxy` manifest, ordered using the `require` metaparameter:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`require`元参数进行排序的`HAproxy`清单：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following manifest is semantically identical, but relies on the `before`
    metaparameter rather than `require`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下清单在语义上是相同的，但它依赖的是 `before` 元参数，而不是 `require`：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The manifest can also mix both styles of notation, of course. This is left as
    a reader exercise with no dedicated depiction.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，清单也可以混合使用这两种符号风格。这部分留给读者练习，没有专门的描述。
- en: The `require` metaparameter usually leads to more understandable code because
    it expresses the dependency of the annotated resource on another resource. The
    `before` parameter, on the other hand, implies a dependency that a referenced
    resource forms upon the current resource. This can be counter-intuitive, especially
    for frequent users of packaging systems (which usually implement a `require`-style
    dependency declaration).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`require` 元参数通常能生成更易于理解的代码，因为它表达了被注解资源对另一个资源的依赖关系。另一方面，`before` 参数则暗示了一个引用资源对当前资源所形成的依赖关系。这可能会让人感到不直观，特别是对于经常使用软件包系统的人（这些系统通常实现了
    `require` 风格的依赖声明）。'
- en: 'Sometimes, it might be difficult to decide whether to use `require` or `before`.
    In simple cases, most people prefer `require`. In some cases, it is easier to
    use `before`. Think of services that have multiple configuration files. Keeping
    information about the configuration file and the requirement in a single place
    reduces errors caused by forgetting to also adopt changes to the service when
    adding or removing additional configuration files. Take a look at the following
    example code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，决定是使用 `require` 还是 `before` 可能会很困难。在简单的情况下，大多数人更倾向于使用 `require`。在某些情况下，使用
    `before` 更容易。想想那些有多个配置文件的服务。将有关配置文件和需求的信息保存在一个地方，可以减少在添加或移除附加配置文件时忘记同时修改服务所造成的错误。看一下以下示例代码：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the example, all dependencies are declared within the file resource declarations.
    If you use the require parameter instead, you will always need to touch at least
    two resources in case of changes:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，所有依赖关系都在文件资源声明中进行了声明。如果你改用 `require` 参数，那么在发生变化时，你将始终需要修改至少两个资源：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Will you remember to update the service resource declaration whenever you add
    a new file to be managed by Puppet? Consider another, simpler example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你添加一个新文件并由 Puppet 管理时，你会记得更新服务资源声明吗？考虑另一个更简单的例子：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The file in the `preferences.d` directory only makes sense for Debian-like systems;
    that's why the package cannot safely `require` it. If the manifest is applied
    on a different OS, such as CentOS, the `apt` preferences file will not appear
    in the catalog thanks to the `if` clause. If the package had it as a requirement
    regardless, the resulting catalog would be inconsistent, and Puppet would not
    apply it. Specifying `before` in the file resource is safe, and semantically equivalent.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`preferences.d` 目录中的文件仅对类似 Debian 的系统有意义；这就是为什么该软件包不能安全地 `require` 它的原因。如果清单应用到其他操作系统，例如
    CentOS，`apt` 配置文件不会出现在目录中，感谢 `if` 条件语句。如果该软件包无论如何都将其作为依赖，最终的目录将不一致，Puppet 也无法应用它。在文件资源中指定
    `before` 是安全的，并且语义上是等效的。'
- en: The `before` metaparameter is outright necessary in situations like this one,
    and can make the manifest code more elegant and straightforward in other scenarios.
    Familiarity with both `before` and `require` is advisable.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在像这种情况中，`before` 元参数是必不可少的，并且在其他情况下，它能使清单代码更加优雅和直接。熟悉 `before` 和 `require` 两者是很有益的。
- en: Error propagation
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误传播
- en: Defining requirements serves another important purpose. References on declared
    resources will only be validated as successful references if the depended-upon
    resource was finished successfully. This can be seen as a kind of stop point inside
    Puppet DSL code, when a required resource is not synchronized successfully.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 定义需求有另一个重要的目的。声明的资源上的引用，只有在依赖的资源成功完成时才会被验证为成功引用。如果所需资源未能成功同步，可以视为 Puppet DSL
    代码中的一个停止点。
- en: 'For example, a `file` resource will fail if the URL of the `source` file is
    broken:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果 `source` 文件的 URL 被破坏，`file` 资源会失败：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'One path segment is missing here. Puppet will report that the file resource
    could not be synchronized:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里缺少了一个路径段。Puppet 会报告文件资源未能同步：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this example, the `Error` line describes the error caused by the broken URL.
    The error propagation is represented by the `Notice` and `Warning` lines below
    it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Error` 行描述了由破损 URL 引起的错误。错误传播通过下面的 `Notice` 和 `Warning` 行表示。
- en: 'Puppet failed to apply changes to the configuration file; it cannot compare
    the current state to the nonexistent source. As the service depends on the configuration
    file, Puppet will not even try to start it. This is for safety: if any dependencies
    cannot be put into the defined state, Puppet must assume that the system is not
    fit for the application of the dependent resource.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet未能应用对配置文件的更改；它无法将当前状态与不存在的源进行比较。由于服务依赖于配置文件，Puppet甚至不会尝试启动它。这是出于安全考虑：如果任何依赖关系无法进入定义的状态，Puppet必须假定系统不适合应用该依赖资源。
- en: This is another important reason to make use of resource dependencies. Remember
    that both the chaining arrow and the `before` metaparameter imply error propagation
    as well.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个利用资源依赖的重要原因。记住，链式箭头和`before`元参数也暗示着错误传播。
- en: Avoiding circular dependencies
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免循环依赖。
- en: 'Before you learn about another way in which resources can interrelate, there
    is an issue that you should be aware of: dependencies must not form circles. Let''s
    visualize this in an example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解资源之间另一种可能的相互关系之前，有一个问题你应该注意：依赖关系不能形成循环。让我们通过一个例子来可视化这个问题：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The dependency circle in this manifest is somewhat hidden (as will likely be
    the case for many such circles that you will encounter during regular use of Puppet).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个清单中的依赖循环有些隐藏（这很可能是你在使用Puppet时遇到的许多循环的情况）。
- en: 'It is formed by the following relations:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 它由以下关系构成：
- en: The `File['/etc/haproxy/haproxy.cfg']` auto-requires the parent directory, `File['/etc/haproxy']`.
    This is an implicit, built-in dependency
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File[''/etc/haproxy/haproxy.cfg'']`自动依赖父目录`File[''/etc/haproxy'']`。这是一个隐式的、内置的依赖关系。'
- en: The parent directory, `File['/etc/haproxy']`, requires `Service['haproxy']`
    due to its `before` metaparameter
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父目录`File['/etc/haproxy']`由于其`before`元参数，要求`Service['haproxy']`。
- en: The `Service['haproxy']` service requires the `File['/etc/haproxy/haproxy.cfg']`
    config
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Service[''haproxy'']`服务依赖`File[''/etc/haproxy/haproxy.cfg'']`配置文件。'
- en: 'Implicit dependencies exist for the following resource combinations, among
    others:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下资源组合存在隐式依赖关系，等等：
- en: If a directory and a file inside the `directory` are declared, Puppet will first
    create the `directory` and then the file
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果声明了一个目录和该目录中的一个文件，Puppet将首先创建目录，然后创建文件。
- en: If a user and his/her primary group is declared, Puppet will first create the
    group and then the user
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果声明了用户及其主组，Puppet将首先创建该组，然后创建用户。
- en: If a file and the owner (user) are declared, Puppet will first create the user
    and then the file
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果声明了文件和所有者（用户），Puppet将首先创建用户，然后创建文件。
- en: 'Granted, the preceding example is contrived-it will not make sense to manage
    the service before the configuration directory. Nevertheless, even a manifest
    design that is apparently sound can result in circular dependencies. This is how
    Puppet will react to such a design:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，前面的例子是人为设定的——在配置目录之前管理服务是没有意义的。尽管如此，即使是看似合理的清单设计，也可能导致循环依赖。这就是Puppet如何响应这种设计：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The output helps you locate the offending relation(s). For very wide dependency
    circles with lots of involved resources, the textual rendering is difficult to
    analyze. Therefore, Puppet also gives you the opportunity to get a graphical representation
    of the dependency graph through the `--graph` option.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 输出帮助你定位有问题的关系。如果依赖循环非常大，涉及大量资源，那么文本渲染就很难分析。因此，Puppet还提供了通过`--graph`选项获取依赖图的图形表示的机会。
- en: 'If you do this, Puppet will include the full path to the newly created `.dot`
    file in its output. Its content looks similar to Puppet''s output:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这样做，Puppet将在其输出中包含新创建的`.dot`文件的完整路径。它的内容看起来类似于Puppet的输出：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is not helpful by itself, but it can be fed directly into tools such as
    `dotty` to produce an actual diagram.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这本身没有太大帮助，但它可以直接输入到像`dotty`这样的工具中，生成实际的图表。
- en: To summarize, resource dependencies are helpful in keeping Puppet from acting
    upon resources in unexpected or uncontrolled situations. They are also useful
    in restricting the order of resource evaluation.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，资源依赖有助于防止Puppet在意外或不可控的情况下对资源进行操作。它们还可以限制资源评估的顺序。
- en: Implementing resource interaction
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现资源交互。
- en: 'In addition to dependencies, resources can also enter a similar yet different
    mutual relation. Remember the pieces of output that we skipped earlier. They are
    as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 除了依赖关系外，资源还可以进入类似但不同的相互关系。记住我们之前跳过的输出部分。它们如下：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Puppet mentions that **refreshes** would have been triggered for the reason
    of an **event**. Such events are emitted by resources whenever Puppet acts on
    the need for a sync action. Without explicit code to receive and react to events,
    they just get discarded.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 提到**刷新**会因为**事件**的原因而触发。每当 Puppet 需要同步操作时，资源会发出此类事件。如果没有显式的代码来接收并响应这些事件，它们将被丢弃。
- en: The mechanism to set up such event receivers is named in an analogy of a generic
    publish/subscribe queue; resources get configured to react to events using the
    `subscribe` metaparameter. There is no `publish` keyword or parameter, since each
    and every resource is technically a publisher of events (messages). Instead, the
    counterpart of the `subscribe` metaparameter is called `notify`, and it explicitly
    directs generated events at referenced resources.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 设置此类事件接收器的机制是通过类比通用的发布/订阅队列来命名的；资源通过 `subscribe` 元参数配置为响应事件。没有 `publish` 关键字或参数，因为每个资源在技术上都是事件（消息）的发布者。相应的
    `subscribe` 元参数的对立面叫做 `notify`，它明确地将生成的事件指向被引用的资源。
- en: One of the most common practical uses of the event system is to reload service
    configurations. When a `service` resource consumes an event (usually from a change
    in a config file), Puppet invokes the appropriate action to make the service restart.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 事件系统的一个常见实际应用是重新加载服务配置。当 `service` 资源接收事件（通常来自配置文件的更改）时，Puppet 会执行适当的操作以重启该服务。
- en: If you instruct Puppet to do this, it can result in brief service interruptions
    due to this restart operation. Note that if the new configuration causes an error,
    the service might fail to start and stay offline.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你指示 Puppet 执行此操作，可能会由于重启操作导致短暂的服务中断。请注意，如果新配置导致错误，服务可能无法启动并保持离线状态。
- en: 'The following code example shows the relationships between the `haproxy` package,
    the corresponding `haproxy` configuration file, and the `haproxy` service:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了 `haproxy` 包、相应的 `haproxy` 配置文件和 `haproxy` 服务之间的关系：
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If the `notify` metaparameter is to be used instead, it must be specified for
    the resource that emits the event:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要使用 `notify` 元参数，它必须指定给发出事件的资源：
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This will likely feel reminiscent of the `before` and `require` metaparameters,
    which offer symmetrical ways of expressing an interrelation of a pair of resources
    just as well. This is not a coincidence, these metaparameters are closely related
    to each other:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会让你想起 `before` 和 `require` 元参数，它们提供了对一对资源关系的对称表达方式。这并非巧合，这些元参数是紧密相关的：
- en: The resource that subscribes to another resource implicitly requires it
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅另一个资源的资源隐式地需要它。
- en: The resource that notifies another is implicitly placed before the later one
    in the dependency graph
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知另一个资源的资源在依赖图中会隐式地排在后一个资源之前。
- en: In other words, `subscribe` is the same as `require`, except for the dependent
    resource receiving events from its peer. The same holds true for `notify` and
    `before`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`subscribe` 与 `require` 相同，只是依赖资源接收来自同伴的事件。`notify` 和 `before` 也是如此。
- en: 'The chaining syntax is also available for signaling. To establish a signaling
    relation between neighboring resources, use an ASCII arrow with a tilde, `~>`,
    instead of the dash in `->`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 链接语法也可以用于信号传递。为了在相邻资源之间建立信号关系，请使用带波浪符的 ASCII 箭头 `~>`，而不是 `->` 中的破折号：
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `service` resource type is one of the two notable types that support refreshing
    when resources get notified (the other will be discussed in the next section).
    There are others, but they are not as ubiquitous.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`service` 资源类型是两种在资源收到通知时支持刷新的重要类型之一（另一个将在下一节讨论）。还有其他类型，但它们没有这么普遍。'
- en: Examining Puppet core resource types
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查 Puppet 核心资源类型
- en: To complete our tour of the basic elements of a manifest, let's take a closer
    look at the resource types that you have already used, and some of the more important
    ones that you have not yet encountered and are part of Puppet's base installation.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整了解清单的基本元素，我们来仔细看看你已经使用过的资源类型，以及一些你尚未遇到但属于 Puppet 基础安装的重要资源类型。
- en: You probably already have a good feeling for the `file` type, which will ensure
    the existence of files and directories, along with their permissions. Pulling
    a file from a repository (usually, a Puppet module) using the `source` parameter
    is also a frequent use case.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经对 `file` 类型有了很好的了解，它将确保文件和目录的存在及其权限。通过 `source` 参数从仓库（通常是 Puppet 模块）拉取文件也是一个常见的用例。
- en: 'For very short files, it is more economical to include the desired content
    right in the manifest:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非常短的文件，将所需内容直接包含在清单中更加经济：
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The double quotes allow expansion of escape sequences, such as `\n`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 双引号允许扩展转义序列，例如`\n`。
- en: 'Another useful capability is managing symbolic links:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的功能是管理符号链接：
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You should be aware that the file resource type requires an absolute path and
    filename. If a relative path is used within the title, then Puppet will produce
    an error:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该知道，文件资源类型需要绝对路径和文件名。如果在标题中使用相对路径，Puppet会报错：
- en: '[PRE40]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The next type that you already know is `package`, and its typical usage is
    quite intuitive. Make sure that packages are either installed or removed. A notable
    use case that you have not yet seen is to use the basic package manager instead
    of `apt` or `yum/zypper`. This is useful if the package is not available from
    a repository:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道的下一个类型是`package`，它的典型用法相当直观。确保包被安装或删除。你还没有看到的一个显著用例是使用基本的包管理器而不是`apt`或`yum/zypper`。如果某个包在仓库中不可用，这是非常有用的：
- en: '[PRE41]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Your mileage usually increases if you make the effort of setting up a simple
    repository instead, so that the main package manager can be used after all.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你努力设置一个简单的仓库，通常会提高效率，这样就可以使用主要的包管理器了。
- en: 'Last but not least, there is a `service` type, the most important attributes
    of which you already know. It''s worth pointing out that it can serve as a simple
    shortcut in cases where you don''t wish to add a fully-fledged `init` script or
    something similar. With enough information, the `base` provider for the `service`
    type will manage simple background processes for you:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，有一个`service`类型，它的最重要的属性你已经了解。值得指出的是，在你不希望添加完整的`init`脚本或类似脚本的情况下，它可以作为一个简单的快捷方式。如果提供了足够的信息，`service`类型的`base`提供者将为你管理简单的后台进程：
- en: '[PRE42]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Puppet will not only restart the script if it is not running for some reason,
    but will also restart it whenever the content of the referenced configuration
    file changes.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet不仅会在某些原因导致脚本未运行时重启它，还会在引用的配置文件内容发生变化时重新启动它。
- en: This only works if Puppet manages the file content and all changes propagate
    through Puppet only.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅在Puppet管理文件内容并且所有更改仅通过Puppet传播时有效。
- en: If Puppet changes any other property of the script file (for example, the file
    mode), that too will lead to a restart of the process.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Puppet更改了脚本文件的其他属性（例如文件模式），这也会导致进程重启。
- en: Let's take a look at some other types you will probably need.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看你可能需要的其他类型。
- en: The user and group types
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户和组类型
- en: 'Especially in the absence of central registries, such as LDAP, it is useful
    to be able to manage user accounts on each of your machines. There are providers
    for all supported platforms; however, the available attributes vary. On Linux,
    the `useradd` provider is the most common. It allows the management of all fields
    in `/etc/passwd`, such as `uid` and `shell`, and also group memberships:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在缺乏中央注册表（如LDAP）的情况下，能够管理每台机器上的用户账户是非常有用的。所有受支持平台都有提供者；然而，提供的属性有所不同。在Linux上，`useradd`提供者是最常见的。它允许管理`/etc/passwd`中的所有字段，如`uid`和`shell`，以及组成员关系：
- en: '[PRE43]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As with all resources, Puppet will not only make sure that the user and group
    exist, but also fix any divergent properties, such as the `home` directory.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有资源一样，Puppet不仅会确保用户和组存在，还会修复任何不同的属性，比如`home`目录。
- en: 'Even though the user depends on the group: (because it cannot be added before
    the group exists), it need not be expressed in the manifest. The user automatically
    requires all necessary groups, similar to a file auto-requiring its parent directory.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 即使用户依赖于组：（因为它不能在组存在之前被添加），也不需要在清单中显式表达。用户会自动要求所有必要的组，类似于文件自动要求其父目录。
- en: Puppet will also happily manage your LDAP user accounts.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet也可以愉快地管理你的LDAP用户账户。
- en: It was mentioned earlier that there are different attributes available, depending
    on the operating system. Linux (and the `useradd` provider) support setting a
    password, whereas on HP-UX (using the `hp-ux` provider), the user password cannot
    be set via Puppet.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到过，根据操作系统的不同，提供了不同的属性。Linux（以及`useradd`提供者）支持设置密码，而在HP-UX（使用`hp-ux`提供者）上，无法通过Puppet设置用户密码。
- en: In this case, Puppet will only show a warning saying that the user resource
    type is making use of an unsupported attribute, and will continue managing all
    other attributes. In other words, using an unsupported attribute in your Puppet
    DSL code will not break your Puppet run.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Puppet 只会显示一个警告，指出用户资源类型正在使用不受支持的属性，并继续管理所有其他属性。换句话说，在 Puppet DSL 代码中使用不受支持的属性不会破坏
    Puppet 的运行。
- en: The exec resource type
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`exec` 资源类型'
- en: There is one oddball resource type in the Puppet core. Remember our earlier
    assertion that Puppet is not a specialized scripting engine, but a tool that allows
    you to model part of your system state in a compelling DSL, and which is capable
    of altering your system to meet the defined goal. This is why you declare `user`
    and `group`, instead of invoking `groupadd` and `useradd` in order. You can do
    this because Puppet comes with support to manage such entities. This is vastly
    beneficial because Puppet also knows that, on different platforms, other commands
    are used for account management, and that the arguments can be subtly different
    on some systems.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puppet 核心中有一种特殊的资源类型。记住我们之前提到的，Puppet 不是一个专业的脚本引擎，而是一个允许你用引人注目的 DSL 模型化系统部分状态的工具，并且能够根据定义的目标改变系统。这就是为什么你声明
    `user` 和 `group`，而不是依次调用 `groupadd` 和 `useradd`。你之所以能这样做，是因为 Puppet 内置了对这些实体的管理支持。这非常有利，因为
    Puppet 还知道在不同的平台上，使用的是不同的命令进行账户管理，并且某些系统上的参数可能会略有不同。
- en: Of course, Puppet does not have knowledge of all the conceivable particulars
    of any supported system. Say that you wish to manage an OpenAFS file server. There
    are no specific resource types to aid you with this. The ideal solution is to
    exploit Puppet's plugin system and to write your own types and providers so that
    your manifests can just reflect the AFS-specific configuration. This is not simple,
    though, and also not worthwhile in cases where you only need Puppet to invoke
    some exotic commands from very few places in your manifest.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Puppet 并不掌握任何受支持系统的所有细节。假设你希望管理一个 OpenAFS 文件服务器，Puppet 没有专门的资源类型来帮助你。理想的解决方案是利用
    Puppet 的插件系统，编写你自己的类型和提供程序，这样你的清单就能直接反映 AFS 特定的配置。然而，这并不简单，而且在某些情况下，当你只需要 Puppet
    在清单的少数地方调用一些特殊的命令时，这也不值得去做。
- en: For such cases, Puppet ships with the `exec` resource type, which allows the
    execution of custom commands in lieu of an abstract sync action.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，Puppet 提供了 `exec` 资源类型，允许执行自定义命令来替代抽象的同步操作。
- en: 'For example, it can be used to unpack a tar ball in the absence of a proper
    package:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，它可以在没有合适的包时用来解压 tar 包：
- en: '[PRE44]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `creates` parameter is important for Puppet to tell whether the command
    needs running. Once the specified path exists, the resource counts as synchronized.
    For commands that do not create a telltale file or directory, there are the alternative
    parameters, `onlyif` and `unless`, to allow Puppet to query the sync state:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`creates` 参数对于 Puppet 判断命令是否需要执行非常重要。一旦指定的路径存在，资源就视为已同步。对于那些不会创建明显文件或目录的命令，还有其他参数
    `onlyif` 和 `unless`，它们允许 Puppet 查询同步状态：'
- en: '[PRE45]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The query command's exit code determines the state. In the case of `unless`,
    the `exec` command runs if the query fails. This is how the `exec` type maintains
    idempotency. Puppet does this automatically for most resource types, but this
    is not possible for `exec` because synchronization is defined so arbitrarily.
    It becomes your responsibility as the user to define the appropriate queries per
    resource.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 查询命令的退出代码决定了状态。在 `unless` 的情况下，查询失败时会执行 `exec` 命令。这就是 `exec` 类型保持幂等性的方法。Puppet
    对大多数资源类型自动执行这一操作，但对于 `exec` 来说，这不可行，因为同步是如此任意地定义的。作为用户，定义每个资源的适当查询就成了你的责任。
- en: 'Finally, the `exec` type resources are the second notable case of receivers
    for events using `notify` and `subscribe`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`exec` 类型的资源是使用 `notify` 和 `subscribe` 接收事件的第二个显著案例：
- en: '[PRE46]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You can even chain multiple `exec` resources in this fashion so that each invocation
    triggers the next one. However, this is bad practice, and degrades Puppet to a
    (rather flawed) scripting engine. The `exec` resources should be avoided in favor
    of regular resources whenever possible. Some resource types that are not part
    of the core are available as plugins from the Puppet Forge. You will learn more
    about this topic in [Chapter 5](3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml), *Combining
    Classes, Configuration Files, and Extensions into Modules*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以以这种方式将多个 `exec` 资源链接在一起，使得每次调用都会触发下一个命令。然而，这种做法并不推荐，它会使 Puppet 降级为一个（相当不完善的）脚本引擎。尽可能避免使用
    `exec` 资源，而应优先使用常规资源。一些不属于核心的资源类型可以作为插件从 Puppet Forge 获取。你将在[第5章](3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml)中了解更多关于这个主题的内容，*将类、配置文件和扩展结合成模块*。
- en: Since `exec` resources can be used to perform virtually *any* operation, they
    are sometimes abused to stand in for more proper resource types. This is a typical
    antipattern in Puppet manifests. It is safer to regard `exec` resources as the
    last resort or emergency exit that is only to be used if all other alternatives
    have been exhausted.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `exec` 资源可以用于执行几乎 *任何* 操作，它们有时被滥用来代替更合适的资源类型。这是 Puppet 清单中的典型反模式。最好将 `exec`
    资源视为最后的手段或紧急出口，只有在所有其他选择都已用尽的情况下才使用。
- en: Ideally, your `exec` resource types are built as one-time only commands.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你的 `exec` 资源类型应该构建为一次性命令。
- en: 'All Puppet installations have the type documentation built into the code, which
    is printable on the command line by using the puppet describe command:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Puppet 安装都有类型文档内置在代码中，可以通过 `puppet describe` 命令在命令行打印出来：
- en: '**`puppet describe <type> [-s]`** In case you are unsure whether a type exists,
    you can tell puppet describe to return a full list of all available resource types:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**`puppet describe <type> [-s]`** 如果你不确定某个类型是否存在，可以通过 `puppet describe` 命令返回所有可用资源类型的完整列表：'
- en: '`**puppet describe --list**`'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`**puppet describe --list**`'
- en: Let's briefly discuss two more types that are supported out of the box. They
    allow the management of cron jobs, mounted partitions, and shares respectively,
    which are all frequent requirements in server operations.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要讨论一下另两个内置支持的类型。它们分别允许管理 cron 任务、挂载的分区和共享资源，这些都是服务器操作中常见的需求。
- en: The cron resource type
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cron 资源类型
- en: 'A cron job mainly consists of a command and the recurring time and date at
    which to run the command. Puppet models the command and each date particle as
    a property of a resource with the `cron` type:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 cron 任务主要由一个命令和指定运行该命令的时间和日期组成。Puppet 将命令和每个日期元素建模为一个资源的属性，资源类型为 `cron`：
- en: '[PRE47]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `environment` property allows you to specify one or more variable bindings
    for `cron` to add to the job.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`environment` 属性允许你为 `cron` 指定一个或多个变量绑定，以添加到任务中。'
- en: The mount resource type
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挂载资源类型
- en: 'Finally, Puppet will manage all aspects of mountable filesystems for you, including
    their basic attributes, such as the source device and mount point, the mount options,
    and the current state. A line from the `fstab` file translates quite literally
    to a Puppet manifest:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Puppet 将为你管理所有可挂载的文件系统，包括它们的基本属性，如源设备和挂载点、挂载选项及当前状态。`fstab` 文件中的一行几乎可以直接转换为
    Puppet 清单：
- en: '[PRE48]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: For this resource, Puppet will make sure that the filesystem is indeed mounted
    after the run. Ensuring the `unmounted` state is also possible, of course; Puppet
    can also just make sure the entry is `present` in the `fstab` file, or `absent`
    from the system altogether.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此资源，Puppet 会确保文件系统在运行后确实被挂载。当然，也可以确保文件系统处于 `unmounted` 状态；Puppet 还可以确保该条目在
    `fstab` 文件中是 `present` 的，或在系统中完全 `absent`。
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: After installing Puppet on your system, you can use it by writing and applying
    manifests. These manifests are written in Puppet's DSL and contain descriptions
    of the desired state of your system. Even though they resemble scripts, they should
    not be considered as such. For one thing, they consist of resources instead of
    commands. These resources are generally not evaluated in the order in which they
    have been written. An explicit ordering should be defined through the `require`
    and `before` metaparameters instead.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统上安装 Puppet 后，你可以通过编写和应用清单来使用它。这些清单使用 Puppet 的 DSL 编写，并包含你系统所需状态的描述。尽管它们看起来像脚本，但不应视其为脚本。首先，它们由资源组成，而非命令。这些资源通常不是按它们编写的顺序进行评估的。相反，应通过
    `require` 和 `before` 元参数来显式定义顺序。
- en: 'Each resource has a couple of attributes: `parameters` and `properties`. Each
    property is evaluated in its own right; Puppet detects whether a change to the
    system is necessary to get any property into the state that is defined in the
    manifest. It will also perform such changes. This is referred to as synchronizing
    a resource or property.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 每个资源都有一些属性：`parameters` 和 `properties`。每个属性都会单独进行评估；Puppet 会检测是否需要对系统进行更改，以将某个属性同步到清单中定义的状态，并且会执行这些更改。这被称为同步资源或属性。
- en: The ordering parameters, `require` and `before`, are of further importance because
    they establish dependency of one resource on one or more others. This allows Puppet
    to skip parts of the catalog if an important resource cannot be synchronized.
    Circular dependencies must be avoided.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`require` 和 `before` 这两个排序参数非常重要，因为它们建立了一个资源对一个或多个其他资源的依赖关系。这使得 Puppet 可以跳过某些目录中的部分内容，如果一个重要资源无法同步。必须避免循环依赖。'
- en: Each resource in the manifest has a resource type that describes the nature
    of the system entity that is being managed. Some of the types that are used most
    frequently are file, package, and service. Puppet comes with many types for convenient
    system management, and many plugins are available to add even more. Some tasks
    require the use of `exec` resources, but this should be done sparingly.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 清单中的每个资源都有一个资源类型，用来描述所管理的系统实体的性质。一些最常用的类型包括文件（file）、软件包（package）和服务（service）。Puppet
    提供了许多类型用于方便的系统管理，并且有很多插件可供选择以扩展功能。某些任务需要使用 `exec` 资源，但应谨慎使用。
- en: In [Chapter 2](7cafeeab-0e5c-4848-9eb0-1bae38ed3525.xhtml), *Puppet Server and
    Agents*, we will introduce the master/agent setup.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2 章](7cafeeab-0e5c-4848-9eb0-1bae38ed3525.xhtml)，*Puppet 服务器与代理* 中，我们将介绍主机/代理的设置。
