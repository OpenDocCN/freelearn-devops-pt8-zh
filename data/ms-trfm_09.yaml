- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Go Serverless with AWS – Building Solutions with AWS Lambda
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AWS 实现无服务器 – 利用 AWS Lambda 构建解决方案
- en: In this chapter, we will turn the page to the final installment of our three-part
    series on **Amazon Web Services** (**AWS**). Having previously built solutions
    on AWS using **Virtual Machines** (**VMs**) in [*Chapter 7*](B21183_07.xhtml#_idTextAnchor365)
    and then in containers in [*Chapter 8*](B21183_08.xhtml#_idTextAnchor402), our
    journey now leads us to an exploration of what building a truly serverless solution
    looks like on AWS.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将翻开三部分系列的最后一章，探讨 **Amazon Web Services**（**AWS**）的无服务器解决方案。此前，我们在 [*第
    7 章*](B21183_07.xhtml#_idTextAnchor365) 使用 **虚拟机**（**VMs**）在 AWS 上构建了解决方案，又在 [*第
    8 章*](B21183_08.xhtml#_idTextAnchor402) 使用容器进行过构建，现在我们将探索在 AWS 上构建真正的无服务器解决方案的样子。
- en: While the foundational concepts and practices from the preceding chapters will
    help us, some aspects of the solution are completely absent here. Namely, we don’t
    need to worry about any operating system configuration, whether it be in Packer
    or Docker.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前几章的基础概念和实践对我们有所帮助，但解决方案的某些方面在这里完全没有涉及。具体来说，我们不需要担心任何操作系统的配置，无论是在 Packer 还是
    Docker 中。
- en: Our attention now turns to adapting our application code to **Lambda**’s application
    model. While this necessitates changes to our application code to align with Lambda’s
    approach, it also presents opportunities to enhance scalability and efficiency
    without the burden of managing servers. This shift in focus promises a more streamlined
    and efficient process. We’ll spend a bit more time adjusting our application code
    to conform than provisioning new services using Terraform.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的重点转向调整应用代码以适应 **Lambda** 的应用模型。虽然这需要对应用代码进行修改，以与 Lambda 的方法保持一致，但也为我们提供了在不再需要管理服务器的情况下提升可扩展性和效率的机会。焦点的转变意味着更简化和高效的流程。我们将花更多的时间来调整应用代码以符合
    Lambda 模式，而不是使用 Terraform 配置新服务。
- en: 'This chapter covers the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涉及以下主题：
- en: Laying the foundation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 奠定基础
- en: Designing the solution
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计解决方案
- en: Building the solution
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建解决方案
- en: Automating the deployment
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化部署
- en: Laying the foundation
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 奠定基础
- en: Our story continues through the lens of Söze Enterprises, founded by the enigmatic
    Turkish billionaire Keyser Söze. Our team has been hard at work building the next-generation
    autonomous vehicle orchestration platform. Our initial strategy involved minimizing
    change to allow the team to focus on driving features into our product. However,
    our elusive CEO had other ideas and pushed us to adopt container technology to
    make our product more flexible and scalable going forward. Working with Keyser,
    there is never a dull moment, but managing such radical change so quickly can
    be frustrating.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的故事通过 Söze Enterprises 公司的视角继续展开，这家公司由神秘的土耳其亿万富翁 Keyser Söze 创办。我们的团队一直在努力构建下一代自动驾驶车辆编排平台。最初，我们的策略是尽量减少变动，让团队专注于将功能快速推进到产品中。然而，我们那位难以捉摸的
    CEO 则有着不同的想法，他推动我们采用容器技术，以使我们的产品在未来变得更加灵活和可扩展。与 Keyser 一起工作，永远不会无聊，但如此迅速地管理如此激进的变革也令人感到沮丧。
- en: Meanwhile, in Davos, Switzerland, with the World Economic Forum in full swing,
    Keyser has a chance encounter at the espresso bar with Werner Vogels, with whom
    he immediately hits it off. When Werner gets a glimpse of Keyser’s immense vision
    for the autonomous vehicle platform, he casually suggests that maybe Keyser shouldn’t
    concern himself with infrastructure at all and that leveraging AWS’s serverless
    offerings could free him from the shackles of infrastructure management to allow
    him to focus on his grand vision.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，在瑞士达沃斯，世界经济论坛正在如火如荼地进行着，Keyser 在意大利浓缩咖啡吧与 Werner Vogels 偶遇，并立即与他聊得非常投机。当
    Werner 看到 Keyser 对自动驾驶平台的宏大愿景时，他随意地建议 Keyser 不必再为基础设施问题操心，利用 AWS 的无服务器产品可以将他从基础设施管理的枷锁中解脱出来，让他专注于实现他的宏大愿景。
- en: Thanks to Werner’s insights and Keyser’s whimsical decision-making, our team
    veers deeper into AWS, explicitly transitioning from Amazon **Elastic Kubernetes
    Service** (**EKS**) to AWS Lambda for serverless computing. This might require
    a complete re-think of our application architecture, but it could free us from
    the significant operational overhead of managing low-level infrastructure.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 Werner 的洞察力和 Keyser 独特的决策方式，我们的团队更深入地进入了 AWS，明确地从 Amazon **Elastic Kubernetes
    Service**（**EKS**）过渡到 AWS Lambda，实现无服务器计算。这可能需要对我们的应用架构进行彻底重新思考，但它也可能将我们从管理底层基础设施的巨大操作负担中解脱出来。
- en: Designing the solution
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计解决方案
- en: 'In this section, we will look at the overall design of our solution, given
    the shift from VM- and container-based architectures toward serverless architectures.
    Serverless has the quintessential objective of eliminating heavy infrastructure
    from the stack at its core. Therefore, we will look for ways to shed any AWS services
    requiring significant fixed costs, such as EC2 instances or EKS clusters, and
    replace them with serverless options. This change in our operational context and
    technology landscape will require us to rethink our solution’s design, implementation,
    and deployment strategy:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将考虑我们的解决方案的整体设计，鉴于从基于虚拟机和容器的架构转向无服务器架构的转变。无服务器架构的核心目标是消除堆栈中沉重的基础设施。因此，我们将寻找方法，去除任何需要高额固定成本的
    AWS 服务，如 EC2 实例或 EKS 集群，并用无服务器选项替代。这种在操作环境和技术领域的变化将要求我们重新思考解决方案的设计、实现和部署策略：
- en: '![Figure 9.1 – Logical architecture for the autonomous vehicle platform](img/B21183_09_1.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 自动驾驶平台的逻辑架构](img/B21183_09_1.jpg)'
- en: Figure 9.1 – Logical architecture for the autonomous vehicle platform
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 自动驾驶平台的逻辑架构
- en: 'Our application’s architecture doesn’t change significantly, but we will be
    using different Azure services to host it. In this case, we’ll be using Azure
    Storage to host the application’s frontend and Azure Functions to host the application’s
    backend:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的架构并不会发生显著变化，但我们将使用不同的 Azure 服务来托管它。在这种情况下，我们将使用 Azure 存储来托管应用程序的前端，使用
    Azure Functions 来托管应用程序的后端：
- en: '![Figure 9.2 – Source control structure of our repository](img/B21183_09_2.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 我们仓库的源代码控制结构](img/B21183_09_2.jpg)'
- en: Figure 9.2 – Source control structure of our repository
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 我们仓库的源代码控制结构
- en: In this solution, we’ll have four parts of our code base. The first two are
    the Terraform code that provisions the environment and the GitHub Actions code
    that executes the deployment process. Then we have the two code bases for our
    application’s frontend and backend.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个解决方案中，我们将有四部分代码库。前两部分是用于配置环境的 Terraform 代码和执行部署过程的 GitHub Actions 代码。然后是我们应用程序前端和后端的两个代码库。
- en: Cloud architecture
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 云架构
- en: In [*Chapter 7*](B21183_07.xhtml#_idTextAnchor365), our cloud-hosting solution
    was a set of dedicated EC2 instances. In [*Chapter 8*](B21183_08.xhtml#_idTextAnchor402),
    it was a set of shared EC2 instances managed by our Kubernetes cluster’s node
    pool. Using VMs, whether standalone VMs or ones that are part of a Kubernetes
    node pool, has the most sunk cost.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 7 章*](B21183_07.xhtml#_idTextAnchor365) 中，我们的云托管解决方案是由一组专用的 EC2 实例组成。在
    [*第 8 章*](B21183_08.xhtml#_idTextAnchor402) 中，它是由我们的 Kubernetes 集群的节点池管理的一组共享
    EC2 实例。无论是独立的虚拟机，还是作为 Kubernetes 节点池一部分的虚拟机，使用虚拟机的沉没成本是最高的。
- en: 'In [*Chapter 8*](B21183_08.xhtml#_idTextAnchor402), our entire solution was
    executed on containers that allowed the front- and backends to coexist as a set
    of containers on the same VMs. This saved some money, but we still needed servers
    to host the workload. In this chapter, we will have a new objective: to take advantage
    of the power of the cloud by leveraging cloud-native services that abstract the
    underlying infrastructure from us and allow us to truly only pay for what we use.
    AWS’s serverless offerings will be crucial to us in this endeavor.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 8 章*](B21183_08.xhtml#_idTextAnchor402) 中，我们的整个解决方案是通过容器执行的，前端和后端作为同一虚拟机上的一组容器共存。这节省了一些费用，但我们仍然需要服务器来托管工作负载。在本章中，我们有一个新的目标：通过利用云原生服务的力量，抽象掉底层基础设施，从而只为我们使用的部分付费。AWS
    的无服务器服务将在这一过程中对我们至关重要。
- en: Frontend
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前端
- en: In previous chapters, we hosted our frontend on public-facing servers that returned
    the HTML and JavaScript that composed our web application. However, we still require
    a cloud-hosted solution to host the files and respond to requests in both solutions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们将前端托管在面向公众的服务器上，这些服务器返回构成我们 Web 应用程序的 HTML 和 JavaScript。然而，在两种解决方案中，我们仍然需要一个云托管的解决方案来托管这些文件并响应请求。
- en: However, due to the nature of the web application running within the end user’s
    browser, we don’t need to use cloud-hosted VMs to host what are essentially flat
    files. We can use simple cloud storage to host the frontend as a static website
    and rely on the cloud platform to shoulder the burden of returning the web content.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于 Web 应用程序运行在最终用户的浏览器中，我们不需要使用云托管的虚拟机来托管本质上是静态文件的内容。我们可以使用简单的云存储来托管前端作为静态网站，并依赖云平台承担返回
    Web 内容的负载。
- en: 'On AWS, we can use **Simple Storage Service** (**S3**). This service allows
    us to host static web content that is internet-accessible. S3 handles all the
    load balancing, SSL termination, and scaling up to meet huge spikes in demand:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AWS 上，我们可以使用 **简单存储服务** (**S3**)。该服务允许我们托管可通过互联网访问的静态网页内容。S3 处理所有的负载均衡、SSL
    终止，并且根据需求波动进行自动扩展：
- en: '![Figure 9.3 – S3 handles web page requests, Lambda handles REST API requests](img/B21183_09_3.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – S3 处理网页请求，Lambda 处理 REST API 请求](img/B21183_09_3.jpg)'
- en: Figure 9.3 – S3 handles web page requests, Lambda handles REST API requests
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – S3 处理网页请求，Lambda 处理 REST API 请求
- en: In order to do this, we’ll need an S3 bucket. We will need to enable public
    internet access to its contents. This will require a combination of S3 and IAM
    configuration. All S3 buckets have an internet-accessible public domain. When
    we activate the static websites feature of S3, internet traffic gets routed to
    content hosted in our bucket.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要一个 S3 存储桶，并且需要启用对其内容的公共互联网访问。这将需要 S3 和 IAM 配置的组合。所有 S3 存储桶都有一个可通过互联网访问的公共域名。当我们启用
    S3 的静态网站功能时，互联网流量将被路由到托管在存储桶中的内容。
- en: 'This will give us a huge advantage because S3 has no sunk costs. Creating an
    S3 bucket costs you absolutely zero dollars per month. Like other serverless offerings,
    it uses a set of micro-transactions to measure your activity and charge you for
    precisely what you use. In S3, this can be a bit complicated, as several measurements
    incur costs:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做将带来巨大的优势，因为 S3 没有沉没成本。创建一个 S3 存储桶每月完全不收取任何费用。像其他无服务器服务一样，它采用微交易来衡量你的活动，并按实际使用量收费。在
    S3 中，这可能有些复杂，因为多个度量标准会产生费用：
- en: '| **Metric** | **Unit** | **Scale** | **Price** |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **度量** | **单位** | **规模** | **价格** |'
- en: '| Storage | GB | 1,000 | $0.023 |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 存储 | GB | 1,000 | $0.023 |'
- en: '| Read transactions | Transactions | 10,000 | $0.0004 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 读取交易 | 交易次数 | 10,000 | $0.0004 |'
- en: '| Write transactions | Transactions | 10,000 | $0.005 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 写入交易 | 交易次数 | 10,000 | $0.005 |'
- en: '| Other operations | Transactions | 10,000 | $0.01 |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 其他操作 | 交易次数 | 10,000 | $0.01 |'
- en: Table 9.1 – AWS S3’s micro-transactional pricing
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.1 – AWS S3 的微交易定价
- en: The preceding table shows all the costs you will run into when using AWS to
    host your static websites. The prices listed are accurate for AWS’s US West (Oregon)
    region at the time of writing. Prices may have changed by the time you read this,
    so it’s best to check the latest prices for the most accurate cost estimation.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 上表展示了使用 AWS 托管静态网站时会遇到的所有费用。所列价格适用于写作时的 AWS 美国西部（俄勒冈）区域。在你阅读此内容时，价格可能已发生变化，因此最好检查最新价格以获得最准确的费用估算。
- en: I included these prices to make a point. We can host a static website on a three-node
    Kubernetes cluster for approximately $300 a month, or on AWS S3 for less than
    $0.01 a month. Which approach would you choose?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我列出这些价格是为了说明一个问题。我们可以在一个三节点的 Kubernetes 集群上以大约每月 $300 的费用托管一个静态网站，或者在 AWS S3
    上托管每月不到 $0.01。你会选择哪种方式？
- en: Backend
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后端
- en: 'Like our frontend, in previous chapters, our backend was also hosted on VMs
    in two different ways: dedicated VMs and shared VMs within the node pool on our
    Kubernetes cluster.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的前端相似，在之前的章节中，我们的后端也以两种不同的方式托管在虚拟机上：专用虚拟机和 Kubernetes 集群中的节点池共享虚拟机。
- en: Unlike the frontend, our backend doesn’t have the option of running entirely
    client-side inside the end user’s web browser. In the backend, we have custom
    code that needs to run on a server. Therefore, we need to find a solution to host
    these components without all the overhead of a fleet of VMs.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与前端不同，我们的后端无法完全在最终用户的 Web 浏览器中运行客户端代码。在后端，我们有需要在服务器上运行的自定义代码。因此，我们需要找到一种托管这些组件的解决方案，而不必承受大量虚拟机带来的开销。
- en: 'We can use Lambda Functions on AWS to accomplish this. AWS Lambda is a managed
    service that allows you to deploy your code without paying the sunk costs for
    any of the underlying VMs. Like S3, it has its micro-transactional pricing model
    that charges you for precisely what you use:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 AWS 上使用 Lambda 函数来完成此任务。AWS Lambda 是一项托管服务，允许你部署代码而无需为底层虚拟机支付沉没成本。与 S3
    类似，它采用微交易定价模型，按实际使用量收费：
- en: '| **Metric** | **Unit** | **Scale** | **Price ($)** |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| **度量** | **单位** | **规模** | **价格（$）** |'
- en: '| Execution time | GB/s | 1 | $0.0000166667 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 执行时间 | GB/s | 1 | $0.0000166667 |'
- en: '| Total executions | Transactions | 1,000,000 | $0.020 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 总执行次数 | 交易次数 | 1,000,000 | $0.020 |'
- en: Table 9.2 – AWS Lambda’s micro-transactional pricing
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.2 – AWS Lambda 的微交易定价
- en: The preceding table shows the costs associated with deploying your code to Lambda
    Functions. The first thing you’ll probably notice is that, like S3, these prices
    are extremely low and measure a very small amount of activity on the platform.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 上表显示了将代码部署到 Lambda 函数所产生的费用。你可能会注意到，和 S3 类似，这些价格非常低，而且只衡量平台上极少量的活动。
- en: For example, the execution time metric has a unit of GB/s, which is the amount
    of memory that your Lambda Function uses per second in GB. Given that it measures
    at a per-second interval, you don’t have to run your Lambda Functions very long
    to rack up quite a few of these. The execution time cost can be adjusted based
    on how much memory you allocate. You can choose to allocate any amount of memory
    between 128 MB and 10 GB.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，执行时间度量的单位是 GB/s，表示 Lambda 函数每秒使用的内存量（单位为 GB）。鉴于它是按秒进行度量的，你不需要长时间运行 Lambda
    函数就能产生相当多的费用。执行时间费用可以根据你分配的内存量进行调整。你可以选择分配从 128 MB 到 10 GB 之间的任意内存。
- en: 'While straightforward, the total executions metric is subject to AWS Lambda’s
    built-in constraints, including execution time limits. For example, each of these
    executions is limited to 15 minutes. Suppose you are trying to respond to requests
    from a web application. In that case, you probably won’t want to design your Lambda
    Function to take 15 minutes anyway, as this would be a poor experience for the
    end users of the web browser. In this scenario, you would want your Lambda Function
    to return in no more than a few seconds. However, Lambda Functions can be employed
    for many different tasks besides responding to HTTP requests from a browser. In
    these situations, you must carefully design your Lambda solution to stay within
    this execution time limitation. This may require you to think about how to split
    up the work so that it can be processed more parallelly by hundreds, if not thousands,
    of instances of your Lambda Function:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管过程简单，**总执行次数**度量受 AWS Lambda 内置限制的影响，包括执行时间限制。例如，每次执行的时间限制为 15 分钟。假设你正在尝试响应来自
    Web 应用程序的请求，在这种情况下，你可能不希望将 Lambda 函数设计成运行 15 分钟，因为这对于 Web 浏览器的最终用户来说体验非常差。在这种情况下，你会希望
    Lambda 函数在几秒钟内返回结果。然而，Lambda 函数可以用于许多不同的任务，除了响应来自浏览器的 HTTP 请求。在这些情况下，你必须小心设计 Lambda
    解决方案，以确保不会超过此执行时间限制。这可能需要你考虑如何将工作分解，以便它能够通过成百上千个 Lambda 函数实例进行更并行的处理：
- en: '![Figure 9.4 – The backend’s architecture using Lambda](img/B21183_09_4.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 使用 Lambda 的后端架构](img/B21183_09_4.jpg)'
- en: Figure 9.4 – The backend’s architecture using Lambda
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 使用 Lambda 的后端架构
- en: Previously, our ASP.NET REST API was set up using a traditional ASP.NET project
    that used controllers to implement the REST API endpoints. However, when transitioning
    to Lambda Functions, we would expect the code base to be structured much differently.
    To host our REST API as Lambda Functions, we need to conform to the framework
    that Lambda dictates. As a result, the ASP.NET controller classes must be refactored
    to conform to this standard. In the next section, we’ll delve into the code that
    makes this possible.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们的 ASP.NET REST API 是通过传统的 ASP.NET 项目设置的，该项目使用控制器来实现 REST API 端点。然而，在过渡到
    Lambda 函数时，我们预计代码结构会有很大的不同。为了将我们的 REST API 托管为 Lambda 函数，我们需要遵循 Lambda 所要求的框架。因此，ASP.NET
    控制器类必须进行重构，以符合这一标准。在下一节中，我们将深入探讨使这一切成为可能的代码。
- en: Deployment architecture
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署架构
- en: Now that we have a good idea of what our cloud architecture for our solution
    on AWS will look like, we need to devise a plan for provisioning our environments
    and deploying our code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 AWS 上解决方案的云架构有了清晰的了解，我们需要制定一个计划来配置我们的环境并部署代码。
- en: In [*Chapter 7*](B21183_07.xhtml#_idTextAnchor365), when we deployed our application
    to VMs, we baked our compiled application code into a VM image using Packer. Similarly,
    in [*Chapter 8*](B21183_08.xhtml#_idTextAnchor402), when we deployed our application
    to containers on our Kubernetes cluster, we baked our application code into container
    images using Docker. With serverless, this completely changes because AWS’s serverless
    offerings completely abstract away the operating system. This means that all we
    are responsible for is producing a compatible deployment package.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B21183_07.xhtml#_idTextAnchor365)中，当我们将应用程序部署到VM时，我们使用Packer将编译的应用程序代码嵌入到VM映像中。同样，在[*第8章*](B21183_08.xhtml#_idTextAnchor402)中，当我们将应用程序部署到我们的Kubernetes集群上的容器时，我们使用Docker将应用程序代码嵌入到容器映像中。使用无服务器计算时，这完全改变了，因为AWS的无服务器提供完全抽象化的操作系统。这意味着我们唯一需要负责的是生成兼容的部署包。
- en: Creating the deployment package
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建部署包
- en: 'As we discussed in the previous section, our application has two components:
    the frontend and the backend. Each has a different deployment target. For the
    frontend, we are going to be deploying as a static website to AWS S3, while the
    backend is going to be deployed as an AWS Lambda Function. Since both are .NET
    projects, we will be using both .NET and AWS platform-specific tools in order
    to create deployment packages and deploy them to their target AWS services. The
    following diagram shows the process we will go through in order to provision our
    environment, package our application code, and deploy it to the target environment
    out in AWS:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中讨论的那样，我们的应用程序有两个组件：前端和后端。每个组件有不同的部署目标。对于前端，我们将作为静态网站部署到AWS S3，而后端将作为AWS
    Lambda函数部署。由于两者都是.NET项目，我们将使用.NET和AWS平台特定的工具来创建部署包并将其部署到目标AWS服务。下图显示了我们将执行的环境配置、应用程序代码打包和部署到AWS目标环境的流程：
- en: '![Figure 9.5 – The resource deployment pipeline to build our .NET application
    code for deployment to AWS](img/B21183_09_5.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 用于构建我们的.NET应用程序代码以部署到AWS的资源部署流水线](img/B21183_09_5.jpg)'
- en: Figure 9.5 – The resource deployment pipeline to build our .NET application
    code for deployment to AWS
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 用于构建我们的.NET应用程序代码以部署到AWS的资源部署流水线
- en: For the frontend, this means enabling the feature to deploy our ASP.NET Blazor
    web application as a web assembly. This will allow the frontend to be hosted as
    a static website running completely client-side without server-side rendering.
    This is only possible because of the way we have designed our front-end web application,
    which uses HTML, CSS, and JavaScript to interact with server-side REST APIs. It’s
    important to note that ASP.NET Blazor supports both hosting options. Still, we
    chose to go down the client-side-only path and eliminate any dependency on server-side
    page rendering. As a result, when we use the .NET CLI to publish our ASP.NET Blazor
    project, it will emit a folder containing static web content. Then, using the
    AWS CLI, we can upload the contents of this folder to our S3 bucket to complete
    the deployment.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前端，这意味着启用将我们的ASP.NET Blazor Web应用程序部署为Web程序集的功能。这将允许前端作为完全客户端运行的静态网站进行托管，而无需服务器端渲染。这仅有可能是因为我们设计的前端Web应用程序的方式，它使用HTML、CSS和JavaScript与服务器端REST
    API进行交互。值得注意的是，ASP.NET Blazor支持两种托管选项。但我们选择了仅客户端的路径，并消除了对服务器端页面渲染的任何依赖。因此，当我们使用.NET
    CLI发布我们的ASP.NET Blazor项目时，它将生成一个包含静态Web内容的文件夹。然后，使用AWS CLI，我们可以将此文件夹的内容上传到我们的S3存储桶以完成部署。
- en: Using the .NET CLI, we will publish our project for the backend, which emits
    all the files necessary for the AWS Lambda service to recognize and execute our
    Lambda Function.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用.NET CLI，我们将发布我们的后端项目，这会生成AWS Lambda服务所需的所有文件，以便识别和执行我们的Lambda函数。
- en: Once this is done, we must zip this folder into a ZIP archive. Finally, we can
    use the AWS CLI to deploy this ZIP archive to our Lambda Function.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，我们必须将此文件夹压缩为ZIP存档。最后，我们可以使用AWS CLI将此ZIP存档部署到我们的Lambda函数。
- en: Now that we have a solid plan for how we will implement both the cloud architecture
    using AWS and the deployment architecture using GitHub Actions, let’s start building!
    In the next section, we’ll break down the HashiCorp Configuration Language code
    we use to implement the Terraform and modify the application code to conform to
    AWS Lambda’s framework.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经制定了关于如何实现使用AWS的云架构和使用GitHub Actions的部署架构的坚实计划，让我们开始构建吧！在接下来的章节中，我们将分解使用的HashiCorp配置语言代码来实现Terraform，并修改应用程序代码以符合AWS
    Lambda的框架。
- en: Building the solution
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建解决方案
- en: Now that we have a solid design for our solution, we can begin building it.
    As discussed in the previous section, since we’ll be using AWS serverless offerings
    such as AWS S3 and Lambda Functions to host our application, we will need to make
    some changes to our application code. We never had to do this in *Chapters 7*
    and *8*, as we were able to deploy our application to the cloud by packaging it
    in either a VM image (using Packer) or a container image (using Docker). Therefore,
    we need to write some Terraform code and update our application code in C# to
    build our solution.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个稳固的解决方案设计，可以开始构建它。正如前一部分所讨论的，由于我们将使用AWS的无服务器服务，如AWS S3和Lambda函数来托管我们的应用程序，我们需要对应用程序代码做一些更改。在*第7章*和*第8章*中我们从未需要做这件事，因为我们能够通过将应用程序打包为虚拟机镜像（使用Packer）或容器镜像（使用Docker）来将应用程序部署到云端。因此，我们需要编写一些Terraform代码，并更新我们在C#中的应用程序代码来构建我们的解决方案。
- en: Terraform
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Terraform
- en: 'As we discussed in our design, our solution consists of two application components:
    the frontend and the backend. Each has its own code base of application code that
    needs to be deployed. In previous chapters, we also had the operating system configuration.
    Now that we are using serverless offerings, this is no longer our responsibility,
    as the platform will take care of it for us.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在设计中所讨论的，我们的解决方案由两个应用程序组件组成：前端和后端。每个组件都有自己需要部署的应用程序代码。在前几章中，我们也有操作系统配置。现在，由于我们使用的是无服务器服务，这不再是我们的责任，因为平台会为我们处理这些。
- en: Much of the Terraform setup is very similar to what we have done in previous
    chapters, so we will only focus on new resources needed for our solution. If you
    want to work with the complete solution, you can check the full source code for
    this book, which is available on GitHub.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform的设置与我们在前几章中做的非常相似，因此我们将只关注为我们的解决方案所需的新资源。如果你想使用完整的解决方案，可以查看本书的完整源代码，代码在GitHub上可用。
- en: Frontend
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前端
- en: 'First, we need to provision an AWS S3 bucket to which we can deploy our frontend.
    The S3 bucket is one of the most common Terraform resources to be provisioned,
    as many other AWS services use S3 buckets for different purposes:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个AWS S3桶来部署我们的前端。S3桶是最常见的Terraform资源之一，因为许多其他AWS服务都使用S3桶来执行不同的任务：
- en: '[PRE0]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'However, we need to configure our S3 bucket a bit differently by using a couple
    of additional resources. First, we need to configure public access using the `aws_s3_bucket_public_access_block`
    resource. Then we need to configure our static website using the `aws_s3_bucket_website_configuration`
    resource:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要通过使用一些额外的资源来配置我们的S3桶。首先，我们需要使用`aws_s3_bucket_public_access_block`资源来配置公共访问权限。然后，我们需要使用`aws_s3_bucket_website_configuration`资源来配置我们的静态网站：
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The configuration is pretty simple, but it is critical for enabling our S3
    bucket to be accessible over the internet. By altering our configuration here,
    we could also opt to host static websites that are not accessible over the internet.
    This might be ideal for intranet websites that we only want accessible when on
    a private network:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 配置相当简单，但对于使我们的S3桶可以通过互联网访问至关重要。通过在这里更改配置，我们还可以选择托管不对互联网开放的静态网站。这对于我们只希望在私人网络上访问的内部网站来说可能是理想的：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This configures the S3 bucket to specify the default web page when it redirects
    web traffic to the content stored within our bucket. The `index.html` page aligns
    with what our ASP.NET Blazor web application uses by default.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这会配置S3桶，以指定当它将Web流量重定向到存储在桶中的内容时的默认网页。`index.html`页面与我们的ASP.NET Blazor Web应用程序默认使用的页面一致。
- en: 'Lastly, we need to configure `aws` provider is to use a Data Source resource
    to generate IAM policy documents that can then be attached to other provisioned
    resources:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要配置`aws`提供程序，使用数据源资源来生成IAM策略文档，然后可以将其附加到其他已创建的资源：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding data source emits the correct policy document, which we can use
    when configuring the S3 bucket’s policy using an `aws_s3_bucket_policy` resource:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 上述数据源会生成正确的策略文档，我们可以在使用`aws_s3_bucket_policy`资源配置S3桶的策略时使用它：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Backend
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后端
- en: 'Lambda Functions are deployed to an `aws_lambda_function` resource, but the
    most important thing to set up first is the IAM role you will use for your Lambda
    Function. This will be how we allow our Lambda Function access to other resources
    on AWS, such as secrets and logging. It is also how we allow it to communicate
    with databases and other services our application code needs to communicate with:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 函数被部署到一个 `aws_lambda_function` 资源中，但首先需要设置的最重要的事情是你将为 Lambda 函数使用的 IAM
    角色。这将是我们允许 Lambda 函数访问 AWS 上其他资源（如密钥和日志）的方式。它也是我们允许 Lambda 函数与数据库以及应用程序代码需要通信的其他服务进行通信的方式：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will start with an IAM policy document for the `sts:AssumeRole` permissions
    and scope it to Lambda Functions. Then we define the IAM role and use this as
    the `assume_role_policy`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个 `sts:AssumeRole` 权限的 IAM 策略文档开始，并将其作用域限定为 Lambda 函数。然后，我们定义 IAM 角色并将其用作
    `assume_role_policy`：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can grant more permissions later by defining additional policies and attaching
    them to this IAM role; more on that later. Now, it’s time to provision our Lambda
    Function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过定义额外的策略并将其附加到这个 IAM 角色来授予更多权限；稍后会详细介绍。现在，是时候配置我们的 Lambda 函数了：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As in the previous two chapters, we must consistently tag our AWS resources
    with the `application` and `environment` tags. These tags organize our deployment
    into an AWS resource group for easier centralized management.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 和前两章一样，我们必须始终为我们的 AWS 资源打上 `application` 和 `environment` 标签。这些标签将我们的部署组织成一个
    AWS 资源组，便于集中管理。
- en: 'A key attribute here is `runtime`, which in our case is .NET 6\. Depending
    on your technology stack, this will, of course, vary. However, perhaps the most
    important attribute is `handler`. This is also the trickiest one to set, as it
    needs to be carefully aligned with our application code. The `handler` is a path
    to a component in our application code. In .NET, this path is made up of three
    parts: the namespace, the fully qualified class name, and the method name.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个关键属性是 `runtime`，在我们的案例中是 .NET 6。根据你的技术栈，当然会有所不同。然而，也许最重要的属性是 `handler`。这是设置起来最棘手的，因为它需要与我们的应用程序代码严格对齐。`handler`
    是应用程序代码中某个组件的路径。在 .NET 中，这个路径由三部分组成：命名空间、完全限定的类名和方法名。
- en: 'We can also use an optional nested block to set additional environment variables
    to help configure the Lambda Function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用一个可选的嵌套块来设置额外的环境变量，以帮助配置 Lambda 函数：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This can be a useful way to pass in configuration to Lambda, which is output
    by other Terraform resources.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以是传递配置给 Lambda 的一种有用方式，这些配置是由其他 Terraform 资源输出的。
- en: Logging
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日志记录
- en: 'As we’ve seen, AWS uses IAM policies to grant access to other foundational
    services on the platform. This is necessary for even things such as logging:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，AWS 使用 IAM 策略来授予访问平台上其他基础服务的权限。这对于日志记录等操作也是必要的：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, we are creating a policy that allows our Lambda Function
    to write to CloudWatch.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在创建一个允许 Lambda 函数写入 CloudWatch 的策略。
- en: 'Finally, we must attach this policy to the IAM role that we created for our
    Lambda Function:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须将这个策略附加到我们为 Lambda 函数创建的 IAM 角色上：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is what it looks like:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 它的样子是这样的：
- en: '![Figure 9.6 – IAM policy to grant access to CloudWatch logging](img/B21183_09_6.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6 – IAM 策略以授予对 CloudWatch 日志的访问权限](img/B21183_09_6.jpg)'
- en: Figure 9.6 – IAM policy to grant access to CloudWatch logging
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – IAM 策略以授予对 CloudWatch 日志的访问权限
- en: This will allow us to use CloudWatch to see what’s happening inside our application
    code every time our Lambda Function is executed, which is critical for troubleshooting
    and debugging.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们使用 CloudWatch 查看每次 Lambda 函数执行时应用程序代码中发生了什么，这对于故障排除和调试至关重要。
- en: Secrets management
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 秘密管理
- en: We saw that we could set environment variables on our Lambda Function. Still,
    if we want better control over our secrets, we may want to use AWS Secrets Manager
    to manage them and then configure our Lambda Function to access them from there.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到可以为 Lambda 函数设置环境变量。然而，如果我们想要更好地控制我们的秘密信息，可能需要使用 AWS Secrets Manager 来管理它们，然后配置
    Lambda 函数从那里访问它们。
- en: 'For example, we’ll set up a password using the `random_password` resource from
    the `random` utility provider that we reviewed in [*Chapter 3*](B21183_03.xhtml#_idTextAnchor185).
    Sometimes AWS services generate secrets on your behalf and sometimes they allow
    you to specify your own. In that situation, the `random_password` resource can
    be very useful:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将使用来自`random`工具提供商的`random_password`资源来设置密码，该提供商我们在[*第 3 章*](B21183_03.xhtml#_idTextAnchor185)中已经讨论过。有时，AWS
    服务会为你生成密钥，有时它们允许你指定自己的密钥。在这种情况下，`random_password`资源就非常有用：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code declares a password that we will use as our secret. Then
    we need to create a Secrets Manager `secret` to hold this secret:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码声明了我们将用作密钥的密码。接下来，我们需要创建一个 Secrets Manager `secret` 来存储这个密钥：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code generates the secret, but you must store secret values in
    the `aws_secretsmanager_secret_version` sub-resource:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码生成了密钥，但你必须将密钥值存储在`aws_secretsmanager_secret_version`子资源中：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There are additional features that can be enabled to handle automatic rotation
    and custom encryption that you could also consider.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以启用其他功能，以处理自动旋转和自定义加密，值得考虑。
- en: 'Now that our secret has been created and stored in Secrets Manager, we must
    create an IAM policy to grant our Lambda Function access:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的密钥已经在 Secrets Manager 中创建并存储，我们必须创建一个 IAM 策略来授予 Lambda 函数访问权限：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We will use `aws_iam_role_policy_attachment` to attach the policy to the Lambda
    Function’s IAM role just as we did for the permissions to log to CloudWatch. If
    you need to use additional secrets, you can continue to add them to the resource
    array where `secret_sauce` has been added.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`aws_iam_role_policy_attachment`将策略附加到 Lambda 函数的 IAM 角色，就像我们为 CloudWatch
    日志权限所做的那样。如果你需要使用额外的密钥，可以继续将它们添加到`secret_sauce`已经添加的资源数组中。
- en: '![Figure 9.7 – Resource IAM policy to grant access to Secrets Manager secrets](img/B21183_09_7.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7 – 资源 IAM 策略以授予访问 Secrets Manager 密钥的权限](img/B21183_09_7.jpg)'
- en: Figure 9.7 – Resource IAM policy to grant access to Secrets Manager secrets
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – 资源 IAM 策略以授予访问 Secrets Manager 密钥的权限
- en: As you can see, the Lambda Function has a much simpler deployment. We don’t
    need a virtual network or any other surrounding resources we provisioned in previous
    chapters to get off the ground. For most applications, the built-in security of
    Lambda Functions and Secrets Manager is sufficient. If we wanted to enable private
    networking because our application has to follow some regulatory compliance, we
    could do that. However, it is not required.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Lambda 函数的部署要简单得多。我们不需要虚拟网络或我们在前几章中配置的其他周边资源就能启动。对于大多数应用程序来说，Lambda 函数和
    Secrets Manager 的内建安全性已经足够。如果我们希望启用私有网络，因为我们的应用程序需要遵循某些合规要求，我们也可以这么做。然而，这是可选的。
- en: Application code
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序代码
- en: AWS Lambda is inherently event-based. Each Lambda Function is triggered by a
    different type of event. The AWS Lambda service provides many different event
    types to trigger your Lambda Function from a wide variety of other AWS services.
    This makes it easy to design Lambda Functions that can respond to all sorts of
    activities within your AWS environment. For the purposes of this book, we’ll focus
    on the Application Load Balancer only. If you are interested in this topic, I’d
    recommend that you check out all the other options that AWS Lambda has—they are
    quite extensive.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda 本质上是事件驱动的。每个 Lambda 函数都由不同类型的事件触发。AWS Lambda 服务提供了许多不同的事件类型，可以从各种
    AWS 服务触发 Lambda 函数。这使得设计可以响应 AWS 环境中各种活动的 Lambda 函数变得容易。为了本书的目的，我们将只关注应用程序负载均衡器。如果你对这个话题感兴趣，我建议你查看
    AWS Lambda 的其他选项——它们非常丰富。
- en: '![Figure 9.8 – Resource ASP.NET MVC Controller class anatomy](img/B21183_09_8.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – 资源 ASP.NET MVC 控制器类结构](img/B21183_09_8.jpg)'
- en: Figure 9.8 – Resource ASP.NET MVC Controller class anatomy
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – 资源 ASP.NET MVC 控制器类结构
- en: In a traditional ASP.NET REST API solution, you have Controller classes embodying
    a specific route and methods that implement different operations at that route.
    The Controller class must be decorated with an `ApiController` attribute that
    informs the ASP.NET runtime that this class should be used to process incoming
    web requests at the route specified in the `Route` attribute.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的 ASP.NET REST API 解决方案中，你会有控制器类，表示特定的路由，并实现该路由下的不同操作。控制器类必须使用`ApiController`特性进行装饰，告知
    ASP.NET 运行时该类应当用于处理指定在`Route`特性中的路由上的传入 Web 请求。
- en: Each method is decorated with an attribute that denotes which HTTP verb the
    method should respond to. In the preceding example, we used `HttpGet`, but there
    are corresponding attributes for each supported HTTP verb. The method can take
    strongly typed parameters that can be part of the route, query string, or request
    body. The method returns an `IActionResult` by default, which allows us to return
    different data structures depending on the outcome of the request.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法都用一个装饰器标记，指示该方法应响应的 HTTP 动词。在前面的例子中，我们使用了 `HttpGet`，但对于每个支持的 HTTP 动词，都有相应的装饰器。该方法可以接收强类型参数，这些参数可以是路由、查询字符串或请求体的一部分。该方法默认返回一个
    `IActionResult`，允许我们根据请求的结果返回不同的数据结构。
- en: 'To implement a REST API using Lambda Functions, we need to implement a class
    using the SDK Lambda function. This requires us to slightly adjust how we implement
    both our class and our method. We will employ different class and method attributes
    to achieve a similar outcome: defining an endpoint that responds to web requests
    at a specific route.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Lambda 函数实现 REST API，我们需要使用 SDK Lambda 函数实现一个类。这要求我们稍微调整类和方法的实现方式。我们将采用不同的类和方法属性来实现类似的目标：定义一个在特定路由上响应
    Web 请求的端点。
- en: 'The Lambda Function class is not decorated with any attributes. A method should
    take in a request object and an `ILambdaContext` object. This method should also
    return a corresponding response object. Depending on the type of event you are
    designing your Lambda Function to respond to, you will need to use different classes
    for the request and response objects. AWS has published some libraries to encapsulate
    common structures of these various types to make them easier to build:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 函数类没有使用任何装饰器。一个方法应该接收一个请求对象和一个 `ILambdaContext` 对象。该方法还应该返回一个对应的响应对象。根据你设计
    Lambda 函数响应的事件类型，你将需要为请求和响应对象使用不同的类。AWS 已发布了一些库，封装了这些不同类型的常见结构，使其更容易构建：
- en: '![Figure 9.9 – Resource AWS Lambda Function class anatomy](img/B21183_09_9.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.9 – 资源 AWS Lambda 函数类结构](img/B21183_09_9.jpg)'
- en: Figure 9.9 – Resource AWS Lambda Function class anatomy
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 资源 AWS Lambda 函数类结构
- en: In this book, we are using the Application Load Balancer; therefore, we used
    the `Amazon.Lambda.ApplicationLoadBalancerEvents` library to provide a standard
    implementation of our request and response objects. As you can see, we are taking
    in an `ApplicationLoadBalancerRequest` and returning an `ApplicationLoadBalancerResponse`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中，我们使用的是应用程序负载均衡器（Application Load Balancer）；因此，我们使用了 `Amazon.Lambda.ApplicationLoadBalancerEvents`
    库来提供请求和响应对象的标准实现。如你所见，我们接收一个 `ApplicationLoadBalancerRequest` 并返回一个 `ApplicationLoadBalancerResponse`。
- en: If we want to implement a more complex Lambda Function that supports different
    functionalities or operations, we can implement our routing logic around the `ApplicationLoadBalancerRequest`
    object’s `Path` and `HttpMethod` properties. These correspond to the ASP.NET framework’s
    route and HTTP verb attributes that decorate each controller class and its methods.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想实现一个更复杂的 Lambda 函数，支持不同的功能或操作，我们可以围绕 `ApplicationLoadBalancerRequest` 对象的
    `Path` 和 `HttpMethod` 属性实现路由逻辑。这些属性对应于 ASP.NET 框架中装饰每个控制器类及其方法的路由和 HTTP 动词属性。
- en: As we can see, the cloud architecture radically simplifies. However, one trade-off
    is that our backend code needs to be adapted to the AWS Lambda framework. This
    will require development and testing efforts to transform our code base into this
    new hosting model. This starkly contrasts with what we explored in previous chapters,
    where we hosted on VMs or containerized and hosted on a Kubernetes cluster. While
    conforming to the AWS Lambda application model does take work, its benefits are
    twofold. First, it allows us to take advantage of a close-to-zero sunk cost. Second,
    it allows us to fully abstract the underlying infrastructure from us and let the
    AWS platform take care of scalability and high availability. This allows us to
    focus more on the functionality of our solutions than on the plumbing required
    to keep the lights on.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，云架构大大简化了系统。然而，一个权衡是我们的后端代码需要适配 AWS Lambda 框架。这将需要开发和测试工作，将我们的代码库转化为这种新的托管模型。这与我们在前几章中探索的内容形成鲜明对比，在那些章节中，我们将应用托管在虚拟机或容器中，并且部署在
    Kubernetes 集群上。虽然符合 AWS Lambda 应用模型确实需要一些工作，但它的好处是双重的。首先，它让我们可以利用几乎为零的沉没成本。其次，它完全将底层基础设施抽象给我们，让
    AWS 平台负责可扩展性和高可用性。这使得我们可以更多地专注于解决方案的功能，而不是维持系统正常运行所需的复杂设置。
- en: Now that we have implemented Terraform to provision our solution and made changes
    to our application code to conform it to the AWS Lambda framework, in the next
    section, we’ll dive into YAML and Bash. We will also implement GitHub Actions
    workflows.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了 Terraform 来配置我们的解决方案，并对应用程序代码进行了更改，使其符合 AWS Lambda 框架，接下来我们将深入学习 YAML
    和 Bash，并实现 GitHub Actions 工作流。
- en: Automating the deployment
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化部署
- en: As discussed in the previous section, serverless offerings such as AWS Lambda
    and S3 abstract the operating system configuration away. Therefore, when we deploy,
    we simply need an application package that is compatible with the target platform.
    In this section, we’ll create an automation pipeline using GitHub Actions to provision
    our application to its new serverless home in AWS.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所讨论的，像 AWS Lambda 和 S3 这样的无服务器服务抽象了操作系统配置。因此，当我们部署时，我们只需要一个与目标平台兼容的应用程序包。在这一节中，我们将使用
    GitHub Actions 创建一个自动化管道，将我们的应用程序部署到 AWS 的新的无服务器环境中。
- en: Terraform
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Terraform
- en: 'The first thing that we need to do is to provision our environment to AWS.
    This is going to be extremely similar to the way we did this in the previous chapters.
    In [*Chapter 7*](B21183_07.xhtml#_idTextAnchor365), we needed to ensure that our
    VM images were built and available before we executed Terraform because the Terraform
    code base referenced the VM images when it provisioned the VMs. With our VM architecture,
    application deployment happens before Terraform provisions the environment:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是将我们的环境部署到 AWS。这将与我们在前几章中做的非常相似。在[*第 7 章*](B21183_07.xhtml#_idTextAnchor365)中，我们需要确保在执行
    Terraform 之前我们的虚拟机镜像已经构建并可用，因为 Terraform 代码库在配置虚拟机时引用了这些镜像。对于我们的虚拟机架构，应用程序的部署发生在
    Terraform 配置环境之前：
- en: '![Figure 9.10 – Packer-produced VM images are a prerequisite for Terraform](img/B21183_09_10.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.10 – Packer 生成的虚拟机镜像是 Terraform 的前提](img/B21183_09_10.jpg)'
- en: Figure 9.10 – Packer-produced VM images are a prerequisite for Terraform
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – Packer 生成的虚拟机镜像是 Terraform 的前提
- en: 'In [*Chapter 8*](B21183_08.xhtml#_idTextAnchor402), we provisioned our Kubernetes
    cluster using AWS EKS without such a prerequisite. In fact, the application deployment
    occurred after the Kubernetes cluster was online. This means that with container-based
    architecture, application deployment happens after Terraform provisions the environment:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 8 章*](B21183_08.xhtml#_idTextAnchor402)中，我们在没有这样的前提条件下，通过 AWS EKS 配置了我们的
    Kubernetes 集群。事实上，应用程序的部署发生在 Kubernetes 集群上线之后。这意味着，在基于容器的架构下，应用程序的部署是在 Terraform
    配置环境之后发生的：
- en: '![Figure 9.11 – Docker-produced container images are provisioned to Kubernetes
    after Terraform executes](img/B21183_09_11.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.11 – Docker 生成的容器镜像在 Terraform 执行后被部署到 Kubernetes](img/B21183_09_11.jpg)'
- en: Figure 9.11 – Docker-produced container images are provisioned to Kubernetes
    after Terraform executes
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – Docker 生成的容器镜像在 Terraform 执行后被部署到 Kubernetes
- en: 'When using AWS’s serverless offerings, the deployment process mirrors what
    we saw when deploying our application as containers to Kubernetes. Just like with
    this approach, we need to build a deployment artifact for AWS’s serverless offerings.
    For the frontend, that means simply generating the static web content. For the
    backend, that means generating a Lambda Functions ZIP archive. These artifacts
    share a similar purpose to the Docker images in that they are a target service-compatible
    way of packaging our application for deployment:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AWS 的无服务器服务时，部署过程与我们将应用程序作为容器部署到 Kubernetes 时所看到的过程类似。就像这种方法一样，我们需要为 AWS
    的无服务器服务构建一个部署工件。对于前端，这意味着只需生成静态 Web 内容。对于后端，这意味着生成一个 Lambda 函数的 ZIP 存档。这些工件与 Docker
    镜像的作用类似，它们都是一种兼容目标服务的应用程序打包方式：
- en: '![Figure 9.12 – The .NET CLI produces deployment artifacts that are provisioned
    to AWS after Terraform executes](img/B21183_09_12.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.12 – .NET CLI 生成的部署工件在 Terraform 执行后被部署到 AWS](img/B21183_09_12.jpg)'
- en: Figure 9.12 – The .NET CLI produces deployment artifacts that are provisioned
    to AWS after Terraform executes
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – .NET CLI 生成的部署工件在 Terraform 执行后被部署到 AWS
- en: As you can see, the serverless deployment looks very similar to the approach
    used with the container-based architecture. That’s because AWS is fulfilling the
    role that Kubernetes played when using a serverless approach. AWS just has custom
    tools to facilitate the deployment of the application.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，无服务器部署与使用基于容器的架构时的方法非常相似。这是因为 AWS 在无服务器方法中承担了 Kubernetes 的角色。AWS 只不过有定制化的工具来帮助应用程序的部署。
- en: Deployment
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署
- en: Now that Terraform has provisioned the AWS infrastructure that we need for our
    serverless solution, we need to take the final step of deploying both the deployment
    artifacts to the appropriate locations in AWS.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 既然 Terraform 已经为我们的无服务器解决方案提供了所需的 AWS 基础设施，我们需要采取最后一步，将部署工件部署到 AWS 中的适当位置。
- en: We will use .NET and AWS custom tools to produce and deploy the artifacts to
    these target locations.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 .NET 和 AWS 自定义工具来生成并部署工件到这些目标位置。
- en: Frontend
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前端
- en: As we saw in other chapters, our .NET application code needs to follow a continuous
    integration process, whereby the code is built and tested using automated unit
    testing and other built-in quality controls. Nothing changes there except that
    we need to add some special handling to the deployment artifact that these processes
    produce in order to make sure it is available to our GitHub Action’s job that
    deploys the workload to the appropriate location.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在其他章节中看到的，我们的 .NET 应用程序代码需要遵循持续集成流程，即使用自动化单元测试和其他内置质量控制构建和测试代码。唯一不同的是，我们需要为这些流程生成的部署工件添加一些特殊处理，以确保它能够被我们的
    GitHub Action 作业获取，进而部署到适当的位置。
- en: 'The `dotnet publish` command outputs the deployment artifact of the .NET application
    code. This output for the ASP.NET Blazor web application is a folder container:
    a collection of loose files with HTML, JavaScript, and CSS in it. In order to
    pass all of these files efficiently from one GitHub Actions job to another, we
    need to zip them up into a single file:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`dotnet publish` 命令输出 .NET 应用程序代码的部署工件。对于 ASP.NET Blazor Web 应用程序，这个输出是一个文件夹容器：其中包含
    HTML、JavaScript 和 CSS 的一系列松散文件。为了高效地将这些文件从一个 GitHub Actions 作业传递到另一个作业，我们需要将它们打包成一个单一的文件：'
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that the static web content has been zipped into a ZIP archive, we will
    use the `upload-artifact` GitHub action to save this file to GitHub Actions. This
    will make the file available for future jobs that are executed within the pipeline:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 既然静态网页内容已被打包成 ZIP 存档，我们将使用 `upload-artifact` GitHub Action 将此文件保存到 GitHub Actions
    中。这将使该文件可以供未来在管道中执行的作业使用：
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Future jobs can simply download the artifact using a corresponding `download-artifact`
    GitHub action and the same name that was used to upload it:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 未来的作业可以简单地使用相应的 `download-artifact` GitHub Action 和上传时使用的相同名称来下载工件：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since the ASP.NET Blazor web application will be hosted as static web content
    on our AWS S3 bucket, we need to ensure that we unzip it before uploading the
    contents. If we were to upload the ZIP archive to S3, the web application wouldn’t
    work correctly because all the web content would be trapped inside the archive
    file:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 ASP.NET Blazor Web 应用程序将作为静态网页内容托管在我们的 AWS S3 存储桶中，我们需要在上传内容之前确保解压它。如果我们将
    ZIP 存档上传到 S3，Web 应用程序将无法正确工作，因为所有网页内容都会被困在存档文件中：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that the static web content has been unzipped to the staging directory,
    we can use the `aws s3 sync` command to deploy all of the files in the folder
    to the S3 bucket:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 既然静态网页内容已经被解压到暂存目录，我们可以使用 `aws s3 sync` 命令将该目录中的所有文件部署到 S3 存储桶：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Backend
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后端
- en: To deploy the Lambda Function, the exact same process is followed to pass the
    artifact from the GitHub Actions job that builds the deployment artifact to the
    job that actually deploys it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署 Lambda 函数，必须遵循完全相同的流程，将从 GitHub Actions 作业中构建的部署工件传递到实际部署它的作业。
- en: 'The only difference is that we will use the `aws lambda update-function-code`
    command to provision a ZIP archive to the Lambda Function:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的不同之处是，我们将使用 `aws lambda update-function-code` 命令将 ZIP 存档部署到 Lambda 函数：
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Unlike how we provisioned the frontend, we don’t need to unzip the deployment
    package for the Lambda Function. AWS Lambda expects our application code to be
    bundled into a ZIP archive.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们为前端提供服务的方式不同，我们不需要为 Lambda 函数解压部署包。AWS Lambda 期望我们的应用程序代码以 ZIP 存档的形式打包。
- en: That’s it! Now our application has been fully deployed to AWS S3 and Lambda!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在我们的应用程序已完全部署到 AWS S3 和 Lambda！
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we embarked on an ambitious journey, transitioning from a .NET
    solution that was previously architected on VMs and Kubernetes using Amazon EKS
    to a fully serverless architecture utilizing AWS Lambda Functions. This transformative
    step involved converting our traditional .NET REST API into a suite of Lambda
    Functions and hosting the frontend as a static website on Amazon S3, marking a
    significant evolution in our cloud-native development journey for our fictional
    company’s autonomous vehicle fleet operations platform.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始了一项雄心勃勃的旅程，从一个先前在虚拟机和Kubernetes上架构的.NET解决方案（使用Amazon EKS）过渡到一个完全的无服务器架构，利用AWS
    Lambda Functions。这一变革性步骤涉及将我们传统的.NET REST API转换为一套Lambda Functions，并将前端托管为Amazon
    S3上的静态网站，标志着我们虚拟公司自动驾驶车队平台的云原生开发之旅迈出了重要的一步。
- en: As we conclude this chapter, we have built three distinct solutions on AWS,
    spanning VMs, Kubernetes, and now serverless architectures. We’ve also demonstrated
    our ability to navigate and leverage AWS’s diverse capabilities to meet our evolving
    needs.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章时，我们已在AWS上构建了三个独立的解决方案，涵盖了虚拟机、Kubernetes以及现在的无服务器架构。我们还展示了在AWS的多样化能力下，如何根据不断变化的需求进行导航并加以利用。
- en: Looking ahead, we are poised to embark on a new chapter of our cloud journey
    with Microsoft Azure. Under the guidance of our elusive and visionary CEO, Keyser
    Söze, who has now forged a partnership with Microsoft, we stand at the threshold
    of exploring similar architectures in the Azure ecosystem. With our sights now
    set on Azure, I invite you to continue our journey as we enter this alternate
    universe, ready to tackle new challenges and uncover new possibilities on a completely
    different cloud platform.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 展望未来，我们准备在Microsoft Azure的云之旅中迈出新的一步。在我们那位难以捉摸且富有远见的CEO Keyser Söze的指导下，他现在已与微软建立了合作关系，我们站在探索Azure生态系统中类似架构的门槛上。随着我们将目光投向Azure，我邀请你继续与我们一起进入这个全新的世界，准备迎接新的挑战，并在这个完全不同的云平台上发掘新的可能性。
- en: 'Part 4: Building Solutions on Azure'
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4部分：在Azure上构建解决方案
- en: 'Armed with the conceptual knowledge of Terraform and architectural concepts
    that transcend the implementation details of the major public cloud platforms,
    we’ll explore building solutions on Microsoft Azure with three cloud computing
    paradigms: virtual machines, containers with Kubernetes, and serverless with Azure
    Functions.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 凭借对Terraform概念性知识和超越主要公共云平台实现细节的架构概念的掌握，我们将探索在Microsoft Azure上构建解决方案的三种云计算范式：虚拟机、使用Kubernetes的容器以及使用Azure
    Functions的无服务器架构。
- en: 'This part has the following chapters:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 10*](B21183_10.xhtml#_idTextAnchor474), *Getting Started on Azure
    – Building Solutions with Azure Virtual Machines*'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B21183_10.xhtml#_idTextAnchor474)，*在Azure上入门——使用Azure虚拟机构建解决方案*'
- en: '[*Chapter 11*](B21183_11.xhtml#_idTextAnchor509), *Containerize on Azure –
    Building Solutions with Azure Kubernetes Service*'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B21183_11.xhtml#_idTextAnchor509)，*在Azure上进行容器化——使用Azure Kubernetes
    Service构建解决方案*'
- en: '[*Chapter 12*](B21183_12.xhtml#_idTextAnchor543), *Go Serverless on Azure –
    Building Solutions with Azure Functions*'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B21183_12.xhtml#_idTextAnchor543)，*在Azure上实现无服务器架构——使用Azure Functions构建解决方案*'
