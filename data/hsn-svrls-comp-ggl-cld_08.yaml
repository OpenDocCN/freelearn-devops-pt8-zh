- en: Cloud Functions Labs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云函数实验
- en: In the previous chapter, we picked up some useful skills as we built an application
    to access signed URLs. One of the most common examples is building a website.
    So we will move on to expand our repertoire by creating a static website-based
    example database on Marvel Films. By the end of the chapter, you will understand
    how to enhance the various techniques presented earlier through rich code samples.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们通过构建一个访问签名 URL 的应用程序，掌握了一些有用的技能。最常见的例子之一就是构建一个网站。因此，我们将通过创建一个基于静态网站的示例数据库，扩展我们的技能库，内容将围绕漫威电影展开。到本章结束时，你将理解如何通过丰富的代码示例增强之前介绍的各种技术。
- en: In our example, we will look at some tips on how to incorporate data and also
    take a first look at security in the context of service accounts. Beyond this,
    we will look at the main components of a static website and how this might potentially
    be enhanced.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将探讨如何将数据整合进来，并首次审视服务账户的安全性。除此之外，我们将查看静态网站的主要组件以及如何可能提升这些组件的功能。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Building a static website
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建静态网站
- en: Service account security
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务账户安全
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In order to complete the exercises in this chapter, you will require a Google
    Cloud project or a Qwiklabs account.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章的练习，你需要一个 Google Cloud 项目或 Qwiklabs 账户。
- en: You can find the code files for this chapter in the GitHub repository for this
    book in the `ch06` subdirectory at [https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch06](https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch06).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的 GitHub 仓库中的`ch06`子目录找到本章的代码文件，网址为[https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch06](https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch06)。
- en: While you are going through code snippets in the book, you will notice that,
    in a few instances, a few lines from the codes/outputs have been removed and replaced
    with ellipses (`...`). The use of ellipses serves to show only relevant code/output.
    The complete code is available on GitHub at the preceding link.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读书中的代码片段时，你会注意到，在少数情况下，代码/输出的某些行已被删除，并用省略号（`...`）代替。省略号的使用是为了仅展示相关的代码/输出。完整的代码可以通过前述链接在
    GitHub 上获取。
- en: Building a static website
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建静态网站
- en: In the following example, we will be building an application in which our now
    familiar function baseline code will consume an external data source (based on
    JSON) and output a view rendered against an HTML template.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将构建一个应用程序，在这个应用程序中，我们熟悉的函数基线代码将调用一个外部数据源（基于 JSON），并输出一个通过 HTML 模板渲染的视图。
- en: Provisioning the environment
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境配置
- en: We have seen this type of layout used previously in other Node.js applications
    (for example, [Chapter 3](4775f0c6-9325-4890-803a-e8feb14ee1d6.xhtml), *Introducing
    Lightweight Functions* and [Chapter 4](9431bfa5-ef43-4043-9779-d5b6d3fef36c.xhtml),
    *Developing Cloud Functions*), so in this chapter, the focus will be on building
    the code necessary to build our website.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在其他 Node.js 应用程序中看过这种布局（例如，[第 3 章](4775f0c6-9325-4890-803a-e8feb14ee1d6.xhtml)，*介绍轻量级函数*
    和 [第 4 章](9431bfa5-ef43-4043-9779-d5b6d3fef36c.xhtml)，*开发云函数*），所以在本章中，重点将放在构建我们网站所需的代码上。
- en: 'To begin, follow these steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，按照以下步骤操作：
- en: Make a brand new directory in which to host our code.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个全新的目录来托管我们的代码。
- en: Within the new directory, initialize the environment by performing `npm init
    --yes` at the command line to initialize our new development environment.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新目录中，通过在命令行中执行`npm init --yes`来初始化环境，以初始化我们的新开发环境。
- en: 'Complete the resulting `package.json` as per the following table:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据下表完成生成的`package.json`：
- en: '| **Field** | **Response** |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| **字段** | **响应** |'
- en: '| Package name: | `marvel-website` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 包名称： | `marvel-website` |'
- en: '| Version: | 1.0.0 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 版本： | 1.0.0 |'
- en: '| Description: | This is an example website built with Cloud Functions |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 描述： | 这是一个使用云函数构建的示例网站 |'
- en: '| Entry Point: | `index.js` |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 入口点： | `index.js` |'
- en: '| Test command: | blank |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 测试命令： | 空白 |'
- en: '| Git repository: | blank |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| Git 仓库： | 空白 |'
- en: '| Keywords: | blank |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 关键词： | 空白 |'
- en: '| Author: | Enter your name |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 作者： | 输入你的名字 |'
- en: '| License: | ISC |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 许可证： | ISC |'
- en: As highlighted in [Chapter 4](9431bfa5-ef43-4043-9779-d5b6d3fef36c.xhtml), *Developing
    Cloud Functions* and [Chapter 5](633e9be2-53a4-483b-b6f2-844cd249cbd3.xhtml),
    *Exploring Functions as a Service*), to work locally we can use the `functions-framework`
    package. In addition, we will also need to install the `pug` package for the view
    template used to render HTML.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[第4章](9431bfa5-ef43-4043-9779-d5b6d3fef36c.xhtml) *开发云函数*和[第5章](633e9be2-53a4-483b-b6f2-844cd249cbd3.xhtml)
    *探索函数即服务*中所述，为了本地运行，我们可以使用`functions-framework`包。此外，我们还需要安装`pug`包，用于渲染HTML的视图模板。
- en: 'From the command line, install the necessary packages by issuing the following
    commands:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行安装必要的包，使用以下命令：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, make a couple of new subdirectories to hold `views` and `data` in relation
    to the function:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建几个新的子目录，用于存放与该功能相关的`views`和`data`：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'At this point, your directory structure should look similar to the following;
    that is, two files (`package.json` and `package-lock.json`) and three subdirectories
    (`data`, `views`, and `node_modules`):'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到此为止，您的目录结构应类似于以下内容：也就是说，两个文件（`package.json`和`package-lock.json`）和三个子目录（`data`、`views`和`node_modules`）：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Remember that, to use the Functions Framework within your application, you need
    to alter the `package.json` file to incorporate a `start` property.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，为了在您的应用程序中使用Functions Framework，您需要修改`package.json`文件，以包含一个`start`属性。
- en: 'Edit the `package.json` file and add a reference to the Functions Framework
    as outlined here:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`package.json`文件，并按照这里所述的方式添加对Functions Framework的引用：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The information highlighted in *line 6* shows the necessary startup command.
    Take note that the target entry point is called `filmAPI`, which means the exported
    function in our application will also need to match this signature.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*第6行*中突出显示的信息显示了必要的启动命令。请注意，目标入口点名为`filmAPI`，这意味着我们应用程序中导出的函数也需要匹配这个签名。'
- en: Excellent! We have now created the basic structure of the application. Now we
    turn our attention to the data source that provides the information to be presented
    in our application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！我们现在已经创建了应用程序的基本结构。接下来，我们将注意力转向提供信息的源头，这些信息将在应用程序中展示。
- en: Creating a data source
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据源
- en: 'Turning our attention to the data directory, our next step is to create a **JavaScript
    Object Notation** (**JSON**) file to store our data. Using JSON is a quick and
    easy way to create an external data source, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将注意力转向数据目录，下一步是创建一个**JavaScript对象表示法**（**JSON**）文件来存储我们的数据。使用JSON是一种快速而简单的方式来创建外部数据源，如下所示：
- en: Create a new file in the `data` subdirectory called `films.json`. This will
    hold our film information.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`data`子目录中创建一个名为`films.json`的新文件。这个文件将存储我们的电影信息。
- en: For the first film, add the content in the following table to it.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第一部电影，添加以下表格中的内容：
- en: 'To explain the schema used, let''s examine the content of the text. The primary
    construct is an array in which we will create a number of placeholders for an
    object representing a film. The film object will expose several fields:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释所使用的架构，让我们先看看文本的内容。主要结构是一个数组，我们将在其中创建多个占位符，用于表示电影的对象。电影对象将暴露几个字段：
- en: '| **Field** | **Type** | **Comment** |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| **字段** | **类型** | **注释** |'
- en: '| `title` | String | Title of the film |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `title` | 字符串 | 电影标题 |'
- en: '| `director` | String | Name of the film director |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `director` | 字符串 | 电影导演的名字 |'
- en: '| `release` | String | Release date of the film |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `release` | 字符串 | 电影的发布日期 |'
- en: '| `description` | String | General overview of the film plot |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `description` | 字符串 | 电影情节的总体概述 |'
- en: '| `bgImage` | String | URL for the film post |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `bgImage` | 字符串 | 电影海报的URL |'
- en: 'Looking at the JSON file directly we can see how the data will be represented
    in the file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 直接查看JSON文件，我们可以看到数据在文件中的表示方式：
- en: Note the comma at the end of the code block; this indicates we are going to
    add further content to the file. If we are not adding further content, no comma
    is added after the film object (see *The Avengers* object for comparison).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意代码块末尾的逗号；这表示我们将要在文件中添加进一步的内容。如果我们不添加其他内容，则在电影对象后面不会加逗号（请参见*The Avengers*对象的比较）。
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Adding additional content such as `The Incredible Hulk` can be achieved by
    appending content at the end of the array record:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加像`The Incredible Hulk`这样的额外内容可以通过在数组记录末尾追加内容来实现：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add a new record for `Iron Man 2`:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Iron Man 2`添加一条新记录：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add a new record based on `Thor`:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于`Thor`添加一条新记录：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add a new record for `Captain America`:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Captain America`添加一条新记录：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, add a new record for `The Avengers`:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为`The Avengers`添加一条新记录：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Based on the preceding code, we have created six new records to hold our data
    in an array. The intention is for the data to work as input for the Cloud Function
    we are about to create. In the real world, it is more likely that a database would
    suffice for this type of access. However, in this example, brevity is our friend,
    and so is JSON!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 基于前面的代码，我们已经创建了六个新的记录，用于在数组中保存数据。目的是让这些数据作为我们即将创建的云函数的输入。在实际应用中，更可能使用数据库来满足这种访问方式。然而，在这个示例中，简洁是我们的朋友，JSON也是！
- en: Now we have created a data source, we will need to implement an onscreen representation
    to illustrate the information to be displayed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了数据源，接下来需要实现屏幕上的展示，以呈现要显示的信息。
- en: Designing a frontend
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计前端
- en: 'Making a frontend in HTML should not present too much of a challenge as there
    are plenty of excellent examples available. In this section, we will take our
    schema and display it onscreen. The template to be used will be created in the
    `views` subdirectory and will feature in a new file named `index.pug` with the
    following content:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTML制作前端应该不会带来太大的挑战，因为有很多优秀的示例可供参考。在这一部分，我们将采用我们的模式并将其显示在屏幕上。所使用的模板将在`views`子目录中创建，并以一个名为`index.pug`的新文件形式呈现，文件内容如下：
- en: Header definition
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头部定义
- en: Card definition
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卡片定义
- en: Release definition
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Release定义
- en: Description definition
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述定义
- en: Body definition
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Body定义
- en: 'From the preceding points, let''s look into the contents of each section:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的要点，让我们来看一下每个部分的内容：
- en: 'The header definition uses standard HTML to incorporate style content. In the
    example, we create a new header style to alter both the font and alignment of
    text:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 头部定义使用标准的HTML来结合样式内容。在示例中，我们创建了一个新的头部样式，用于更改文本的字体和对齐方式：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `card` definition creates a new style that will visually look like an onscreen
    card:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`card`定义创建了一个新的样式，视觉上看起来像一个屏幕上的卡片：'
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `release` definition creates color and font enhancements:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`release`定义创建了颜色和字体的增强效果：'
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `description` definition creates enhancements with reference to the color,
    font size, and padding for any element associated with this style:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`description`定义通过参考颜色、字体大小和内边距等内容，对与该样式相关的任何元素进行增强：'
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `body` definition provides the main layout considerations for importing
    data via the Cloud Function:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`body`定义提供了通过云函数导入数据的主要布局考虑：'
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s break it down:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下：
- en: '| **Name** | **Type** | **Comment** |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **类型** | **备注** |'
- en: '| H1 | Main heading | The page title |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| H1 | 主要标题 | 页面标题 |'
- en: '| H3 | Subheading | A subheading for the page |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| H3 | 子标题 | 页面的子标题 |'
- en: '| img | Image link | The URL link for the image |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| img | 图片链接 | 图片的URL链接 |'
- en: '| p | Paragraph | Description text |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| p | 段落 | 描述文本 |'
- en: When creating a view, we are using information passed from the Cloud Function
    to populate the onscreen view. Specifically, we take the title, release date,
    director, and description from the schema information consumed from the JSON data
    file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建视图时，我们使用从云函数传递过来的信息来填充屏幕上的视图。具体来说，我们从JSON数据文件中的模式信息中提取标题、发布日期、导演和描述等内容。
- en: 'At this point in our example, we should now have the following directory structure,
    based on the files created in this example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例的这个阶段，基于我们在示例中创建的文件，我们应该已经有了以下的目录结构：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We have also created a data source based on a JSON file that holds information
    concerning films. The methods to add a new movie, remove a film, and alter information
    relating to a film should be self-evident, and the data file presents a convenient
    way to manage external data content. Also, the view is isolated from the primary
    function; thus, as a bonus, the presentation layer acts independently, making
    alteration easy. Finally, we need to create the service to perform integration
    between the data and view and generate an appropriate HTTP response.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个基于JSON文件的数据源，其中包含关于电影的信息。添加新电影、移除电影和更改电影相关信息的方法应该很直观，数据文件为管理外部数据提供了一个方便的方式。而且，视图是与主功能分离的；因此，作为额外的好处，展示层独立运行，方便进行修改。最后，我们需要创建服务来实现数据和视图之间的集成，并生成适当的HTTP响应。
- en: Analyzing a Cloud Function
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析云函数
- en: 'The Cloud Function that we''ve defined doesn''t have a significant amount of
    code associated with it. There are the following elements in our Cloud Function:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的云函数没有太多的代码与之相关。我们的云函数中包含以下元素：
- en: Variable definitions
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量定义
- en: The private function
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有函数
- en: The public function
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共函数
- en: To explain the various elements that we've outlined here, let's take a minute
    to explore each component in a bit more detail.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释我们在这里概述的各种元素，让我们花一点时间更详细地探讨每个组件。
- en: 'Variable definitions are as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 变量定义如下：
- en: '**Line 1**: The function starts with a declaration to include our temporary
    data store in which film information is stored. Again, this is an easy way to
    incorporate data into an application without needing additional infrastructure
    to be put in place.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第1行**：函数以声明包含我们的临时数据存储开始，其中存储了电影信息。同样，这是一种将数据整合到应用程序中的简单方式，无需额外的基础设施支持。'
- en: '**Line 2**: Uses `pug` package dependencies and declares them for use within
    the function:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第2行**：使用`pug`包依赖并声明在函数中使用：'
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The private function works as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 私有函数的工作原理如下：
- en: '**Line 6**: Declares the view to be rendered based on the external view defined
    in the `index.pug` file'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第6行**：声明要根据`index.pug`文件中定义的外部视图进行渲染的视图'
- en: '**Line 11**: Creates the response object based on an HTTP status response code
    of 200 and an array value based on the item selected by the user when viewing
    the initial screen:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第11行**：根据HTTP状态响应码200以及基于用户在查看初始页面时选择的项目创建响应对象：'
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The public function works as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 公共函数的工作原理如下：
- en: '**Line 31**: A call to the `filmDetail` function passes the request, response,
    and data objects:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第31行**：调用`filmDetail`函数时，传递请求、响应和数据对象：'
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When running the preceding application (that is, `npm start` from the command
    line), the details of the JSON filmography array will be displayed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述应用程序（即从命令行运行`npm start`）时，将显示JSON电影列表数组的详细信息。
- en: Note that query string URLs can be used to access information beyond the first
    film. An HTTP query mechanism like this can be useful when passing additional
    parameters to sub-components. In this instance, we use these parameters to select
    alternative pages to be displayed without having to amend the existing function
    code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，查询字符串URL可以用于访问第一部电影之外的信息。像这样的HTTP查询机制在向子组件传递附加参数时非常有用。在此示例中，我们使用这些参数来选择显示不同的页面，而无需修改现有的函数代码。
- en: 'To select another film from the array of available films, use the URL query
    setting to access any film persisted in the film database, as demonstrated in
    the following table:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要从可用电影数组中选择另一部电影，请使用URL查询设置来访问电影数据库中保存的任何电影，如下表所示：
- en: '| **Film** | **URL** |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| **电影** | **URL** |'
- en: '| 1\. Iron Man | `http://localhost:8080` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 1\. 铁人 | `http://localhost:8080` |'
- en: '| 2\. The Incredible Hulk | `http://localhost:8080/?film=1` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 2\. 无敌浩克 | `http://localhost:8080/?film=1` |'
- en: '| 3\. Iron Man 2 | `http://localhost:8080/?film=2` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 3\. 钢铁侠2 | `http://localhost:8080/?film=2` |'
- en: '| 4\. Thor | `http://localhost:8080/?film=3` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 4\. 雷神 | `http://localhost:8080/?film=3` |'
- en: '| 5\. Captain America: The First Avenger | `http://localhost:8080/?film=4`
    |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 5\. 美国队长：复仇者先锋 | `http://localhost:8080/?film=4` |'
- en: '| 6\. The Avengers | `http://localhost:8080/?film=5` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 6\. 复仇者联盟 | `http://localhost:8080/?film=5` |'
- en: If you are running this from cloud shell, take note that the URL will be different
    from that shown above. However, you are still able to append query settings, for
    example,`https://mydomain-dot-devshell.appspot.com/?authuser=0&environment_id=default&film=2`
    to display the second film.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从云终端运行此应用，请注意URL会与上面显示的不同。但你仍然可以附加查询设置，例如`https://mydomain-dot-devshell.appspot.com/?authuser=0&environment_id=default&film=2`来显示第二部电影。
- en: You will see different pages when presenting different query objects to the
    application.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当向应用程序提交不同的查询对象时，您将看到不同的页面。
- en: This example shows how the GET HTTP verb can be extended through the use of
    querying parameters. It is this type of flexibility that has made HTTP such a
    widely adopted approach and outlines the strength of this protocol. Our working
    example demonstrates how to develop a simple web application using Cloud Functions.
    The example can, of course, extend to other more intricate use cases. I will leave
    it to your imagination to build the next big thing based on the accumulated knowledge
    gathered over the previous chapters.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了如何通过查询参数扩展GET HTTP方法。正是这种灵活性使得HTTP成为如此广泛采用的方法，并展现了该协议的优势。我们的示例展示了如何使用云函数开发一个简单的Web应用程序。这个例子当然可以扩展到其他更复杂的用例。我将把根据前几章所学的知识构建下一个大项目的任务留给你发挥想象力。
- en: We will now turn our attention to the crucial topic of Cloud Functions security.
    In the next section, we will discuss various security techniques that can be applied
    when working with Cloud Functions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将注意力转向 Cloud Functions 安全这一关键话题。在接下来的部分，我们将讨论在使用 Cloud Functions 时可以应用的各种安全技术。
- en: Service account security
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务账户安全
- en: Finally, in this chapter, we will introduce the concept of least privilege with
    regard to **Identity Access Management** (**IAM**) and explain how to apply this
    to Cloud Functions. We will look at some approaches that can secure an application
    using Cloud Functions.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在本章中，我们将介绍关于**身份访问管理**（**IAM**）的最小权限概念，并解释如何将其应用于 Cloud Functions。我们将探讨一些可以保障使用
    Cloud Functions 的应用程序安全的方法。
- en: Later in this chapter, we will discuss service accounts; however, let's take
    an initial brief look at how to restrict the caller status of the Cloud Functions
    deployed. Cloud Functions use service accounts rather than a user account to manage
    services. In this respect, the service account takes on the role of the user without
    needing an actual human to be involved in the process.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本章稍后将讨论服务账户；然而，首先简要看一下如何限制已部署的 Cloud Functions 的调用者状态。Cloud Functions 使用服务账户而非用户账户来管理服务。在这方面，服务账户扮演了用户的角色，而无需实际的人类参与此过程。
- en: Concerning the user account, each function deployed will be assigned a service
    account responsible for permissions. The service account is created either manually
    or automatically; in both instances, the role and permissions need to be defined.
    When a function deploys, the `cloudfunctions.invoker` permission is typically
    applied to the service account. This permission provides the service account with
    the ability to call/invoke Cloud Functions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 关于用户账户，每个已部署的函数将分配一个服务账户来负责权限。服务账户可以手动创建，也可以自动创建；无论哪种方式，都需要定义角色和权限。当函数被部署时，通常会为服务账户应用
    `cloudfunctions.invoker` 权限。该权限授予服务账户调用/触发 Cloud Functions 的能力。
- en: 'Besides this permission, the caller also needs to have the correct authentication
    for the function. If the default settings persist, then the `allUser/public` interface
    is bound to the service, meaning anyone can call the function. HTTP functions
    are typically deployed with the default `allUsers` policy binding, meaning that
    anyone can invoke the service. In doing this, it enables anyone to invoke our
    function by using the exposed endpoint. Open access presents a potential vulnerability
    for our application and needs a solution to mitigate this risk. If you wish to
    restrict access to the function, limit it to secure account access: for example,
    `allAuthenticated` or specific users denoted through their IAM account.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 除了此权限外，调用者还需要对该函数进行正确的身份验证。如果默认设置保持不变，则 `allUser/public` 接口将绑定到该服务，意味着任何人都可以调用该函数。HTTP
    函数通常会使用默认的 `allUsers` 策略绑定进行部署，这意味着任何人都可以调用该服务。这样，任何人都可以通过暴露的端点来调用我们的函数。开放访问为我们的应用程序带来了潜在的安全漏洞，需要一个解决方案来减轻这一风险。如果您希望限制对该函数的访问，请将其限制为安全账户访问，例如
    `allAuthenticated` 或通过其 IAM 账户指定的特定用户。
- en: Despite a function being available for a shorter amount of time, Cloud Functions
    are still susceptible to security risks such as malicious code or denial of service.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Cloud Functions 的运行时间较短，但它们仍然容易受到安全风险的威胁，例如恶意代码或服务拒绝攻击。
- en: Note that, with regard to denial-of-service attacks, Cloud Functions sits behind
    the Google frontend that is used to mitigate and absorb many attacks on layer
    4 and below, such as SYN floods, IP fragment floods, port exhaustion, and so on.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，关于拒绝服务攻击，Cloud Functions 位于 Google 前端后面，该前端用于缓解和吸收许多 4 层及以下的攻击，例如 SYN 洪水、IP
    分片洪水、端口耗尽等。
- en: Many different types of vulnerability can be problematic for web-based services.
    The complexity of this subject means we are not able to provide more than a limited
    overview of the mitigations in play. There is seemingly an ever-increasing spectrum
    of potential vulnerabilities, for example, malicious code, denial-of-service attacks,
    or event resource bottlenecks.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同类型的漏洞可能对基于 Web 的服务构成问题。由于该主题的复杂性，我们无法提供超出当前防护措施的更多概述。潜在的漏洞范围似乎在不断增加，例如恶意代码、拒绝服务攻击或事件资源瓶颈等。
- en: The following section details some techniques to mitigate security concerns
    with Cloud Functions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分详细介绍了一些技术，用于缓解 Cloud Functions 的安全问题。
- en: Economic limits
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 经济限制
- en: As we are now aware, serverless provides the ability to achieve scalability
    across the Cloud Functions. However, it may be that a service integrated with
    Cloud Functions isn't able to cope at these types of level. It is possible to
    restrict the maximum number of instances available, should such a restriction
    be applicable within your application.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们现在所知，serverless 提供了在 Cloud Functions 中实现可扩展性的能力。然而，集成了 Cloud Functions 的服务可能无法应对这种级别的扩展。在您的应用中，如果需要，您可以限制可用实例的最大数量。
- en: 'Applying restrictions against connectivity can ease the burden and prevent
    a service from experiencing flooding with more requests than can be successfully
    processed. A threshold setting the available number of instances means that the
    function can be limited at the point of deployment, as demonstrated in the following
    command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 应用连接性限制可以减轻负担，并防止服务遭遇过多无法成功处理的请求。通过设置实例的可用数量阈值，意味着在部署时可以限制该功能，如以下命令所示：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the constrained scenario here, a queuing mechanism is enabled to ensure the
    constraint applied doesn't impede the processing of information to your service.
    Limiting the instance threshold is an excellent start to securing service calls.
    A different variant looks at how to obtain the credentials used to access resources.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的受限场景中，启用了排队机制，以确保所施加的限制不会妨碍信息处理到您的服务。限制实例阈值是确保服务调用安全的一个良好开端。另一种变体则关注如何获取访问资源所需的凭证。
- en: Insecure credential storage
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不安全的凭证存储
- en: Credential storage is an increasingly important topic when attempting to secure
    various services. Essential credentials (or keys), such as database username/password/publication
    credentials or secrets stored in code, require a solution that enables this information
    to be accessible only to authenticated components.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 凭证存储是确保各种服务安全性时日益重要的话题。重要凭证（或密钥），例如数据库用户名/密码/发布凭证或存储在代码中的密钥，需要一个解决方案，以确保这些信息只能被经过身份验证的组件访问。
- en: Many industry-based solutions will provide the necessary protections, including
    Google Cloud **Key Management Service** (**KMS**), which supports using Google-
    or customer-based keys. Also, general products such as HashiCorp Vault provide
    a similar level of protection for information to be stored securely.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 许多行业解决方案将提供必要的保护，包括 Google Cloud **密钥管理服务** (**KMS**)，它支持使用 Google 或客户提供的密钥。此外，一些通用产品如
    HashiCorp Vault 也为存储信息提供了类似级别的安全保护。
- en: So credentials offer better protection and allow services to be secured. When
    working with multiple integrated services, how do we manage the workflow to the
    level of security desired?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，凭证提供了更好的保护并允许服务得到安全保障。当与多个集成服务一起工作时，如何管理工作流以达到所需的安全级别呢？
- en: Execution flow manipulation
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行流操作
- en: The execution flow essentially outlining how the function workflow for your
    application. In a scenario where you have multiple functions, there may be an
    information handoff between components in which they exchange information or provide
    access to a backend service such as a database.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 执行流基本上是描述您的应用程序功能工作流的方式。在您有多个功能的场景中，组件之间可能会进行信息交接，它们交换信息或提供对后端服务（如数据库）的访问。
- en: In this situation, it would not be appropriate for any of the functions in this
    workflow to be intercepted or accept communications from unauthenticated external
    sources. To do so would diminish the integrity of the workflow. A situation like
    this presents a substantive security risk to the application (for example, tainted
    information).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，任何功能都不应被拦截或接受来自未经身份验证的外部来源的通信。这样做将降低工作流的完整性。像这样的情况会给应用程序带来实质性的安全风险（例如，信息被篡改）。
- en: To prevent this type of vulnerability, we can utilize least-privilege security
    settings to manage service accounts and establish a per-function authorization
    mechanism to validate calls. By default, all functions/apps/containers can share
    the same service identities and have a role assigned, such as project editor.
    However, identity management can also be set on a per-function basis to establish
    the least privilege. For Cloud Functions, append a service account to control
    the function at the point of deployment.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种类型的漏洞，我们可以利用最小权限安全设置来管理服务帐户，并建立按功能的授权机制来验证调用。默认情况下，所有功能/应用程序/容器可以共享相同的服务身份，并分配角色，如项目编辑者。然而，身份管理也可以按功能进行设置，以建立最小权限。对于云功能，可以在部署时附加服务帐户来控制功能。
- en: 'In the following diagram, a service account capable of invoking a Cloud Function
    is labeled **Function A**:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图示中，能够调用 Cloud Function 的服务帐户标记为**Function A**：
- en: '![](img/67bedd99-4abb-47f3-b779-f0db5a9740f1.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67bedd99-4abb-47f3-b779-f0db5a9740f1.png)'
- en: Service account deployment provides a public interface to our other services.
    We will also create a second service account for **Function B** to manage the
    backend; this service account will not have invoker privileges and will not be
    made public. Finally, **Backend Services** do not expose themselves to the public-facing
    internet. Besides this, they will also be accessible from Function B. An arrangement
    of this type is relatively common, for example, on a bastion host where the host
    is internet-facing and only the host has permission to connect with other machines
    in the estate.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 服务帐户部署为我们的其他服务提供了一个公共接口。我们还将为**Function B**创建第二个服务帐户来管理后台；该服务帐户将没有调用者权限，并且不会公开。最后，**后端服务**不会向公众互联网开放。除此之外，它们还将可以从
    Function B 访问。这种安排相对常见，例如在堡垒主机上，堡垒主机面对互联网，且只有主机有权限与庄园中的其他机器连接。
- en: 'According to Google, a service account is a special account that calls the
    Google API without the involvement of a user. These computer accounts are an incredibly
    useful feature and are defined with IAM permissions. We can create a new service
    account that will provide access to the function by using the following `gcloud`
    command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 根据谷歌的说法，服务帐户是一种特殊帐户，它可以在没有用户参与的情况下调用 Google API。这些计算机帐户是非常有用的功能，并通过 IAM 权限进行定义。我们可以使用以下
    `gcloud` 命令创建一个新的服务帐户，该帐户将提供对该功能的访问权限：
- en: 'Create a service account—`Function A`:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建服务帐户—`Function A`：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Bind a role to the service account that will enable the latter to use the `invoker`
    role:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将角色绑定到服务帐户，使其能够使用 `invoker` 角色：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `cloudfunctions.invoker` role is required to initiate Cloud Functions, and
    we bind this permission to our new service account. By doing this, our service
    account can now call Cloud Functions.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 Cloud Functions 需要 `cloudfunctions.invoker` 角色，我们将此权限绑定到我们的新服务帐户。通过这样做，我们的服务帐户现在可以调用
    Cloud Functions。
- en: Now that we have created a service account with the necessary permissions, we
    can deploy our function with the new service account by appending the name of
    the account.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了具有必要权限的服务帐户，我们可以通过附加帐户名称来使用新服务帐户部署功能。
- en: 'Apply the new service account on deployment of the Cloud Function:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在部署 Cloud Function 时应用新的服务帐户：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To complete our example, we will create a second service account associated
    with our second function. For this service account, we will not apply the `invoker`
    (`cloudfunctions.invoker`) role, thereby restricting who can initiate the function.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的示例，我们将创建一个与第二个功能相关的第二个服务帐户。对于此服务帐户，我们将不应用 `invoker`（`cloudfunctions.invoker`）角色，从而限制谁可以启动该功能。
- en: 'Create a service account—`Function B`:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建服务帐户—`Function B`：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As we did with the first service account, we need to bind some permissions.
    In this instance, we are using Cloud SQL permissions.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如同我们在第一个服务帐户中所做的那样，我们需要绑定一些权限。在这个例子中，我们使用的是 Cloud SQL 权限。
- en: 'Bind a role to the service account:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将角色绑定到服务帐户：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Finally, we can deploy the function with the recently created service account.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用最近创建的服务帐户来部署该功能。
- en: 'Apply the service account to the function being deployed:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在部署的功能上应用服务帐户：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'At this point, we have now made simple changes to our application that ensure
    that the function execution flow works to our advantage. **Function A** is our
    entry point function and provides a frontend for our application. **Function B**
    is now only accessible via **Function A**, which secures the execution flow from
    A to B. Also note that now the **Backend Services** is only available via **Function
    B**. With the changes specified in the preceding steps, we now have the following
    layout:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经对应用程序进行了简单的修改，以确保函数执行流程符合我们的需求。**Function A** 是我们的入口函数，并为我们的应用提供前端。现在，**Function
    B** 仅通过 **Function A** 访问，从而确保了从 A 到 B 的执行流程的安全性。同时请注意，现在 **Backend Services**
    仅通过 **Function B** 访问。根据前面步骤中指定的更改，我们现在有了以下布局：
- en: '![](img/03d17991-0d41-4824-b24c-5052c989ee0e.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03d17991-0d41-4824-b24c-5052c989ee0e.png)'
- en: In the final area to be discussed, we'll look at security controls through policy
    controls.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个要讨论的领域中，我们将通过策略控制来研究安全控制。
- en: FunctionShield
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FunctionShield
- en: 'Google Cloud Functions also supports third-party solutions such as FunctionShield.
    With these solutions, strict security controls are employed that ensure the application
    of a policy to the functions deployed. Specifically, these protections apply to
    four distinct areas:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cloud Functions 还支持诸如 FunctionShield 等第三方解决方案。通过这些解决方案，采用严格的安全控制，确保对已部署的函数应用策略。具体来说，这些保护措施适用于四个不同的领域：
- en: The security policy allows the disabling of egress internet connectivity. Restriction
    of outbound traffic when not required by the service is a good practice to adopt,
    as most services will typically only require ingress/inbound traffic to be enabled.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全策略允许禁用出口互联网连接。当服务不需要外向流量时，限制出站流量是一个好习惯，因为大多数服务通常只需要启用入口/入站流量。
- en: As previously indicated, Cloud Functions are lightweight functions that are
    stateless. In this respect, local storage requirements, therefore, should be restricted
    where possible. FunctionShield can disable read/writes on the `/tmp` directory,
    typically used for intermediary storage requirements.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，Cloud Functions 是轻量级的无状态函数。在这方面，应该尽可能限制本地存储需求。因此，FunctionShield 可以禁用对 `/tmp`
    目录的读写操作，该目录通常用于中介存储需求。
- en: Thread execution for child processes should be minimized and restricted when
    not required by the function to be invoked. Being able to execute child processes
    presents a genuine security risk that is difficult to track and trace once initiated
    without the application of adequate protections.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在没有被调用的函数要求时，应尽量减少和限制子进程的线程执行。能够执行子进程带来了一个真实的安全风险，一旦启动，没有充分的保护措施很难追踪和追溯。
- en: Restrict access to the function's source code via the central console. Where
    the source code has some value or associate **intellectual property** (**IP**),
    this can be an extra safeguard that applies to the system source code to be deployed.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过中央控制台限制对函数源代码的访问。当源代码具有一定价值或关联**知识产权**（**IP**）时，这可以作为一种额外的保障措施，应用于要部署的系统源代码。
- en: 'The FunctionShield solution is a free product that can be deployed to multiple
    cloud providers, making it a flexible solution we can use to ensure the application
    of a standard policy within your serverless estate. No function code amendments
    are necessary to deploy this against your application. A proprietary, behavioral-based
    runtime establishes protection around the serverless environment. The observability
    of the cloud functions remains apparent and is available via the standard mechanism:
    Stackdriver on Google Cloud.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: FunctionShield 解决方案是一个免费产品，可以部署到多个云提供商，因此它是一个灵活的解决方案，我们可以用它来确保在无服务器环境中应用标准策略。部署到应用程序中不需要修改函数代码。一个基于行为的专有运行时在无服务器环境中建立保护。云函数的可观察性保持清晰，并且可以通过标准机制获取：Google
    Cloud 上的 Stackdriver。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: With this chapter, we have concluded our foray into Cloud Functions on Google
    Cloud. The last couple of chapters have covered a lot of material on how to develop
    Cloud Functions. In the first example, we continued on our journey with Cloud
    Functions to explore how to construct a website based on an external view and
    data template. In this example, we picked up a couple of tips regarding code organization
    and dependency isolation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 本章已结束我们在 Google Cloud 上对 Cloud Functions 的探索。过去几章涵盖了很多关于如何开发 Cloud Functions
    的内容。在第一个示例中，我们继续使用 Cloud Functions 探讨如何基于外部视图和数据模板构建一个网站。在这个示例中，我们总结了一些关于代码组织和依赖隔离的技巧。
- en: On completion of the example, we have an easy-to-maintain website that utilizes
    Cloud Functions to provide a scalable basis for lightweight site access. We learned
    about the principle of least privilege and how this applies to Cloud Functions.
    We also learned some fundamental methods that are capable of securing our Cloud
    Functions by working with Google Cloud service accounts.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这个示例后，我们得到了一个易于维护的网站，利用 Cloud Functions 提供了一个可扩展的轻量级站点访问基础。我们学习了最小权限的原则，以及它如何应用于
    Cloud Functions。同时，我们还学习了一些基本方法，能够通过与 Google Cloud 服务账号协作来确保我们的 Cloud Functions
    安全。
- en: 'At this stage, you should be comfortable building both web applications and
    services integrated with Google APIs. There is more to learn that we unfortunately
    don''t have the time or space to cover in this book. Cloud Build, GKE, databases,
    IoT, and third-party services are all possible avenues for further exploration.
    This concludes our tour of Cloud Functions on Google Cloud. In upcoming chapters,
    we will turn our attention to the latest iteration of serverless on Google Cloud:
    Cloud Run and Cloud GKE.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你应该已经能够熟练构建集成了 Google API 的 web 应用程序和服务。还有更多内容可以学习，不过我们在这本书中没有足够的时间或篇幅来涵盖。Cloud
    Build、GKE、数据库、物联网以及第三方服务都是进一步探索的潜在方向。这就结束了我们关于 Google Cloud 上 Cloud Functions
    的介绍。在接下来的章节中，我们将把注意力转向 Google Cloud 上最新的无服务器迭代：Cloud Run 和 Cloud GKE。
- en: Questions
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What permission does a Cloud Function require to be invoked?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cloud Function 需要什么权限才能被调用？
- en: What does Google KMS provide?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Google KMS 提供什么功能？
- en: What does the `allUsers` permission effectively mean?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`allUsers` 权限的实际含义是什么？'
- en: What does the `allAuthenticated` permission effectively mean?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`allAuthenticated` 权限的实际含义是什么？'
- en: What parameter needs to be applied to limit the number of instances available
    to a Cloud Function?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 限制 Cloud Function 可用实例数的参数是什么？
- en: What command allows a role to be bound to a service account?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个命令允许将角色绑定到服务账号？
- en: What command is used to create a service account?
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于创建服务账号的命令是什么？
- en: What is a bastion host and why is it useful?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是堡垒主机，它有什么用？
- en: Further reading
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '**Google service accounts**: [https://cloud.google.com/iam/docs/service-accounts](https://cloud.google.com/iam/docs/service-accounts)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google 服务账号**: [https://cloud.google.com/iam/docs/service-accounts](https://cloud.google.com/iam/docs/service-accounts)'
- en: '**Least privilege for Cloud Functions using Cloud IAM**: [https://cloud.google.com/blog/products/application-development/least-privilege-for-cloud-functions-using-cloud-iam](https://cloud.google.com/blog/products/application-development/least-privilege-for-cloud-functions-using-cloud-iam)'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 Cloud IAM 为 Cloud Functions 设置最小权限**: [https://cloud.google.com/blog/products/application-development/least-privilege-for-cloud-functions-using-cloud-iam](https://cloud.google.com/blog/products/application-development/least-privilege-for-cloud-functions-using-cloud-iam)'
- en: '**Controlling Scaling Behavior**: [https://cloud.google.com/functions/docs/max-instances](https://cloud.google.com/functions/docs/max-instances)'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制扩展行为**: [https://cloud.google.com/functions/docs/max-instances](https://cloud.google.com/functions/docs/max-instances)'
- en: '**Google Cloud Key Management Service**: [https://cloud.google.com/kms/](https://cloud.google.com/kms/)'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google Cloud 密钥管理服务**: [https://cloud.google.com/kms/](https://cloud.google.com/kms/)'
