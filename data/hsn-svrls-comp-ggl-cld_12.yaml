- en: Developing with Cloud Run for Anthos
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Cloud Run for Anthos 开发
- en: In this chapter, we will discover how to leverage more sophisticated tools and
    services to deliver production-level management of the environment. Kubernetes
    is a wide and intriguing subject that is beyond the scope of this book. However,
    knowing some of the background and key elements will make the transition to this
    platform easier.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索如何利用更复杂的工具和服务来提供生产级别的环境管理。Kubernetes 是一个广泛且令人着迷的主题，超出了本书的范围。然而，了解一些背景和关键元素将使你更容易过渡到这一平台。
- en: As per earlier chapters, an introduction to Cloud Run and Kubernetes will cover
    the key aspects of the technology. In that respect, working through the first
    section should act as a primer on **Google Kubernetes Engine** (**GKE**) if you
    are unfamiliar with the topic. Working with Cloud Run for Anthos provides the
    ability to utilize many of the benefits of Kubernetes. This chapter will deliver
    sufficient information to get you started. If you are already familiar with GKE,
    then feel free to skip the initial section and move on to the specifics of Cloud
    Run for Anthos.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面章节所述，Cloud Run 和 Kubernetes 的介绍将涵盖技术的关键方面。在这方面，如果你对该主题不熟悉，通过第一部分的学习应该为你提供一个关于
    **Google Kubernetes Engine**（**GKE**）的入门知识。使用 Cloud Run for Anthos 可以充分利用 Kubernetes
    的许多优势。本章将提供足够的信息帮助你入门。如果你已经熟悉 GKE，那么可以跳过初始部分，直接进入 Cloud Run for Anthos 的具体内容。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Setting up identity and policy management
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置身份和策略管理
- en: Working with environment monitoring
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用环境监控
- en: Creating custom networking
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义网络
- en: Establishing domains
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立域名
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete the hands-on exercises in this chapter, you will require a Google
    Cloud project.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章的实践练习，你需要一个 Google Cloud 项目。
- en: You can find the code files used in this chapter in the GitHub repository for
    the book under the `ch09` sub-directory, at [https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch09](https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch09).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的 GitHub 仓库中找到本章使用的代码文件，路径为 `ch09` 子目录：[https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch09](https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch09)。
- en: Identity and policy management
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份与策略管理
- en: Understanding the identity and policy arrangement on Google Cloud is a major
    learning curve for most users. Identity Access Management is a major component
    and could easily be the focus of its own book. In short, IAM provides a policy
    on a project to provide the relevant permissions associated with roles.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 Google Cloud 上的身份和策略安排是大多数用户的主要学习曲线。身份访问管理是一个重要组件，甚至可以单独作为一本书的主题。简而言之，IAM
    在项目上提供策略，以赋予与角色相关的权限。
- en: On Google Cloud, administrative management operations are typically performed
    using a service account. Working with the Google Cloud catalog, the IAM roles
    are defined to address the needs of users across a wide variety of scenarios.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Google Cloud 上，管理操作通常通过服务帐户执行。在与 Google Cloud 目录配合使用时，IAM 角色定义了针对各种用户需求的解决方案。
- en: IAM objects
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IAM 对象
- en: At a high level, Google Cloud uses a hierarchical structure made up of organizations,
    folders, projects, and resources to marshal access.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，Google Cloud 使用由组织、文件夹、项目和资源组成的层次结构来管理访问权限。
- en: The organization node is the root node for Google Cloud resources and containers
    all of the projects and resources.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织节点是 Google Cloud 资源的根节点，包含所有的项目和资源。
- en: Folders are optional, used to group projects under an organization. A folder
    may contain both projects and other folders. IAM policies can be used to control
    access to the resources a folder contains.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件夹是可选的，用于将项目分组到组织下。一个文件夹可以包含项目和其他文件夹。可以使用 IAM 策略来控制对文件夹中资源的访问。
- en: Google Cloud resources are always associated with a project. Google Cloud allows
    you to track resource and quota usage, enable billing, manage permissions and
    credentials, and enable services and APIs.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Cloud 资源始终与项目相关联。Google Cloud 允许你跟踪资源和配额使用情况、启用计费、管理权限和凭证，并启用服务和 API。
- en: The hierarchy defined in the preceding list is combined with members (that is,
    **users** or **service accounts**) and roles to constrict project access to specific
    groups based on defined access permissions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述列表中定义的层次结构与成员（即**用户**或**服务账户**）和角色结合使用，以根据定义的访问权限将项目访问权限限制到特定组。
- en: Members
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成员
- en: 'Member accounts are important as they provide access to the organization. Think
    of member accounts as providing domain access, that is used to determine the actions
    that can be performed when using the services available in Google Cloud. There
    are two types to consider when working with member accounts:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 成员账户很重要，因为它们提供对组织的访问权限。可以将成员账户视为提供域访问权限，用于确定在使用 Google Cloud 提供的服务时可以执行的操作。在处理成员账户时，有两种类型需要考虑：
- en: '**Member roles***:* Permissions given to members through the granting of roles.
    Roles define which permissions are granted. Google Cloud provides predefined roles,
    and also the ability to create custom roles.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成员角色**：通过授予角色来赋予成员权限。角色定义了授予哪些权限。Google Cloud 提供了预定义角色，并且还可以创建自定义角色。'
- en: '**Service accounts**: These allow us to control server-to-server interaction.
    Typically used to authenticate one service to another and control the application
    actions that a service can perform, service accounts on Google are referenced
    by an email address in the `gserviceaccount.com` domain.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务账户**：这些账户允许我们控制服务器之间的交互。通常用于验证一个服务对另一个服务的访问，并控制服务可以执行的应用操作。Google 上的服务账户通过
    `gserviceaccount.com` 域中的电子邮件地址来引用。'
- en: Once a member account has been defined, the next step is to assign a role to
    the member. In effect, this is providing permissions to perform actions within
    the project.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了成员账户，下一步是为该成员分配角色。实际上，这就是提供执行项目内操作的权限。
- en: Roles
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色
- en: 'On Google Cloud, roles provide a very flexible way to give access to resources.
    Access in this context is provided as a spectrum in which the range is coarse
    (in Google Cloud terms, primitive) to fine-grained (in Google Cloud terms, custom)
    depending on the use case. The three role types are outlined in the following
    list. In most instances, a mixture of these role types will be used to deliver
    the type of access required:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Google Cloud 上，角色提供了一种非常灵活的方式来授予对资源的访问权限。在这种情况下，访问权限作为一个范围提供，其中范围从粗粒度（在 Google
    Cloud 中称为原始角色）到细粒度（在 Google Cloud 中称为自定义角色），具体取决于使用场景。以下列表概述了三种角色类型。在大多数情况下，将使用这些角色类型的混合体来提供所需的访问类型：
- en: '**Primitive**: The least granular roles that existed before the introduction
    of Cloud IAM. Defined at the project level, these offer a coarse-grained level
    of access, for example, the Owner, Editor, and Viewer roles.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原始**：在 Cloud IAM 引入之前存在的最基础角色。定义在项目级别，这些角色提供粗粒度的访问控制，例如 Owner、Editor 和 Viewer
    角色。'
- en: '**Predefined**: Predefined IAM roles are used to provide finer-grained access
    control than primitive roles. Each Google Cloud service incorporates predefined
    roles. These are used to map to a job function, for example, Compute Network Admin,
    Security Reviewer.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预定义**：预定义的 IAM 角色用于提供比原始角色更细粒度的访问控制。每个 Google Cloud 服务都包含预定义角色。这些角色用于映射到某个工作职能，例如
    Compute Network Admin、Security Reviewer。'
- en: '**Custom**: Bespoke roles consisting of permissions and resources defined by
    the user.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义**：由用户定义的包含权限和资源的定制角色。'
- en: Learning the preceding role types will make working with Google Cloud significantly
    easier, as each project defined will adhere to the structure we've outlined. In
    the next section, we will look at GKE and see how this can be used in conjunction
    with Cloud Run.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 学习上述角色类型将使得在 Google Cloud 上的工作变得更加容易，因为每个定义的项目将遵循我们所概述的结构。在下一部分，我们将查看 GKE，并了解它如何与
    Cloud Run 配合使用。
- en: Overview of Google Kubernetes Engine
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Kubernetes 引擎概述
- en: Hopefully, you have heard about Kubernetes and understand how important this
    platform is for the deployment of technical environments. As an introduction for
    those not familiar with Kubernetes, this section will give you an overview of
    the key parts.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你听说过 Kubernetes，并理解这个平台在技术环境部署中的重要性。对于那些不熟悉 Kubernetes 的人，本节将为你提供关键部分的概述。
- en: Kubernetes is an orchestration platform for containers that enables scheduling
    and maintenance to be performed in an automated fashion by the system, rather
    than manually by a user.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一个容器编排平台，能够使得调度和维护由系统自动完成，而不是由用户手动进行。
- en: During the last couple of chapters on Cloud Run, we have discussed the importance
    of containers. What we haven't spoken about yet is what to do to coordinate this
    management, once you start to use it, in a more production-friendly way (that
    is, consistent and reliable).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章关于 Cloud Run 的内容中，我们讨论了容器的重要性。我们尚未讨论的是，一旦开始使用容器，如何以更适合生产环境的方式（即一致性和可靠性）来协调这一管理。
- en: As you might imagine, containers and Kubernetes are complementary technologies
    that establish an environment in which applications can be run at scale. The platform
    itself can be run on a range of Linux servers, including **virtual machines**
    (**VMs**), cloud instances, and even on bare metal. As an open source project,
    the pace of development is astounding, as are the quality of contributions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你想象的那样，容器和 Kubernetes 是互补的技术，它们建立了一个可以扩展运行应用的环境。平台本身可以运行在多种 Linux 服务器上，包括
    **虚拟机**（**VMs**）、云实例，甚至裸金属服务器。作为一个开源项目，开发的速度令人惊叹，贡献的质量也同样出色。
- en: To use Kubernetes on Google Cloud, we use GKE. This provides a managed environment
    for Kubernetes. To access the environment, we use a command called `kubectl`,
    also known as Kubernetes control. Provisioning and maintaining a Kubernetes cluster
    is beyond the scope of this book, but we will refer to the underlying constructs
    as we deploy our artifacts to the GKE cluster.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Google Cloud 上使用 Kubernetes，我们使用 GKE。这为 Kubernetes 提供了一个托管环境。为了访问该环境，我们使用名为
    `kubectl` 的命令，也称为 Kubernetes 控制命令。配置和维护 Kubernetes 集群超出了本书的范围，但我们将在将工件部署到 GKE
    集群时引用底层构件。
- en: Knowing the use case for a product can save effort in terms of building solutions.
    At this point, it is worth outlining the key differences between Cloud Run and
    Cloud on GKE (apart from the need for Kubernetes).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 了解产品的使用场景可以节省构建解决方案的工作量。此时，值得概述 Cloud Run 与 Cloud on GKE 之间的关键差异（除了对 Kubernetes
    的需求）。
- en: Differentiating Cloud Run from Cloud Run for Anthos
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区分 Cloud Run 与 Cloud Run for Anthos
- en: 'Cloud Run for Anthos provides many of the benefits of Cloud Run. In the following
    table, we illustrate some of the key differences that a user of the service should
    be aware of:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Run for Anthos 提供了许多 Cloud Run 的优势。在下表中，我们列出了一些用户应了解的关键差异：
- en: '|  | **Cloud Run** | **Cloud Run for Anthos** |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '|  | **Cloud Run** | **Cloud Run for Anthos** |'
- en: '| **Billing** | Pay per use | Provisioned cluster resource |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **计费** | 按使用量计费 | 配置的集群资源 |'
- en: '| **Machine customization** | Memory | Memory, CPU, GPU, networking |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **机器定制** | 内存 | 内存、CPU、GPU、网络 |'
- en: '| **URL and SSL** | Automatic HTTPS URL | Manual SSL certificates |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **URL 和 SSL** | 自动 HTTPS URL | 手动 SSL 证书 |'
- en: '| **Identity and Policy** | Public, invoker IAM role, CICP | Public or internal
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **身份和策略** | 公共，调用者 IAM 角色，CICP | 公共或内部 |'
- en: 'Despite the differences outlined in the preceding table, the services can actually
    be easily deployed without change via the simple deployment option. Development
    can be started on Cloud Run. Move to Cloud Run for Anthos where you need the platform
    resources associated with Kubernetes. There are also a number of features that
    are shared in common between the two:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面表格中列出了差异，但这些服务实际上可以通过简单的部署选项轻松部署，无需任何更改。开发可以在 Cloud Run 上开始。如果需要与 Kubernetes
    相关的平台资源，可以迁移到 Cloud Run for Anthos。两者之间还有许多共享的功能：
- en: Autoscaling (GKE limited by the cluster in use) for any service deployed.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于任何部署的服务，都可以进行自动扩展（GKE 受使用的集群限制）。
- en: Run HTTP-based apps and services easily over TCP port `8080`.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻松地通过 TCP 端口 `8080` 运行基于 HTTP 的应用和服务。
- en: A simple developer experience based on containers using a manifest.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于容器的简单开发者体验，使用清单文件。
- en: Select any language, or any library that can be packaged within a container.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择任何语言或任何可以打包到容器中的库。
- en: Utilize custom domain names without the need to configure the environment.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在无需配置环境的情况下，使用自定义域名。
- en: Now that we have a general appreciation of GKE, we can move on to apply our
    knowledge and use Cloud Run for Anthos in the next section.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 GKE 有了大致了解，可以在接下来的章节中应用我们的知识，使用 Cloud Run for Anthos。
- en: Using Cloud Run for Anthos
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Cloud Run for Anthos
- en: As mentioned earlier, working with Cloud Run for Anthos provides the ability
    to utilize many of the benefits of Kubernetes. In this section, we will explore
    some of these capabilities. Let's begin by creating (that is, provisioning) a
    cluster with access to Cloud Run a GKE environment.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用 Cloud Run for Anthos 提供了利用 Kubernetes 许多好处的能力。在本节中，我们将探讨这些功能的一些内容。我们先从创建（即配置）一个具有
    Cloud Run 访问权限的 GKE 集群开始。
- en: Provisioning GKE
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 GKE
- en: Cloud Run for Anthos requires a Kubernetes cluster. At a high level, Kubernetes
    provides a platform on which to manage (or *orchestrate*) containers. Outlining
    the value of Kubernetes is beyond the scope of this book, but it suffices to say
    it is something that is well worth the investment of time.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Run for Anthos 需要一个 Kubernetes 集群。从高层次来看，Kubernetes 提供了一个平台，用于管理（或*编排*）容器。阐述
    Kubernetes 的价值超出了本书的范围，但可以简单地说，它是一个非常值得投入时间的技术。
- en: To deploy code to Cloud Run for Anthos, there is an assumption that there is
    a GKE cluster available. Cloud Run for Anthos requires some pre-existing infrastructure
    to be available prior to deployment taking place. In this section, we will spin
    up a cluster and then deploy our application to it to explore in what ways the
    process is different between Cloud Run for Anthos and Cloud Run.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要将代码部署到 Cloud Run for Anthos，假设已有一个 GKE 集群。Cloud Run for Anthos 在部署之前需要一些预先存在的基础设施。在本节中，我们将启动一个集群，然后将我们的应用程序部署到该集群上，以探索
    Cloud Run for Anthos 与 Cloud Run 之间的过程差异。
- en: The following example uses Cloud Shell to enter the command line and enable
    the services needed within a project.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用 Cloud Shell 进入命令行并启用项目中所需的服务。
- en: 'To provision a cluster, the **Google Cloud Console** or **Cloud SDK** (**GCloud**)
    can be used. For this example, the Cloud SDK will be used so the underlying commands
    can be seen. Many of the features accessed in this section will reference beta/alpha,
    as, at the time of writing, this is their current state. As Cloud Run uses Google
    Container Registry and Cloud Build APIs, these services will need to be enabled
    within your project. Enabling the relevant `googleapis` can be done via the Console
    or using Cloud SDK:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要配置集群，可以使用**Google Cloud 控制台**或**Cloud SDK**（**GCloud**）。在本示例中，将使用 Cloud SDK，以便可以查看底层命令。本节中访问的许多功能将提到
    beta/alpha，因为在编写本文时，它们仍处于该状态。由于 Cloud Run 使用 Google 容器注册表和 Cloud Build API，因此需要在项目中启用这些服务。可以通过控制台或使用
    Cloud SDK 启用相关的`googleapis`：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Enabling Cloud Run on a cluster with beta status means the general format of
    the command may change once it moves to **general availability** (**GA**) status.
    If you are using Cloud Shell to run Cloud SDK commands, note this environment
    is automatically updated on a regular basis to incorporate the latest SDK changes.
    Other environments may need to be manually updated to ensure they have installed
    the correct components revisions. Here, we are going to store the cluster name
    and zone to be used, as this information is needed by both the cluster creation
    and `build` command:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在集群上启用 Cloud Run 的 beta 版本意味着，当它变为**正式发布**（**GA**）版本时，命令的通用格式可能会发生变化。如果你使用 Cloud
    Shell 运行 Cloud SDK 命令，请注意此环境会定期自动更新，以纳入最新的 SDK 更改。其他环境可能需要手动更新，以确保已安装正确的组件版本。在这里，我们将存储将要使用的集群名称和区域，因为此信息既在集群创建时需要，也在`build`命令中需要：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that it is often useful to set some local environment variables to store
    common parameters as a convenience measure. Ensuring the environment variables
    are formatted in uppercase text makes them stand out in your command-line scripts.
    To access the value of a variable, append the `$` symbol in front of the variable
    name—for example, echo `$CLUSTER_NAME` will display the name associated with the
    cluster.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通常建议设置一些本地环境变量，用于存储常见参数，作为一种便利措施。确保环境变量采用大写字母格式，使它们在命令行脚本中更加突出。要访问变量的值，只需在变量名之前加上`$`符号——例如，`echo
    $CLUSTER_NAME` 将显示与集群关联的名称。
- en: 'In the case of Cloud Run for Anthos, the element that is additionally required
    is the Cloud Run add-on. Our first use of the environment variable will be needed
    here. To reference this, we add the `$` to the front of the variable, for example,
    `$CLUSTER_NAME`. To provision the cluster, we use the following command to initiate
    the environment on which to deploy Cloud Run:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 Cloud Run for Anthos，额外需要的元素是 Cloud Run 插件。我们将在这里第一次使用环境变量。要引用这个变量，我们在变量前加上`$`符号，例如，`$CLUSTER_NAME`。要配置集群，我们使用以下命令来启动部署
    Cloud Run 的环境：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Please be aware that there are restrictions on cluster names, so do check prior
    to creation that the details used conform. The following restrictions are applied;
    that is, they must be a match of regex `(?:[a-z](?:[-a-z0-9]{0,38}[a-z0-9])?)`,
    meaning the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，集群名称有一定的限制，因此在创建之前请检查所使用的细节是否符合要求。以下是应用的限制；即它们必须匹配正则表达式`(?:[a-z](?:[-a-z0-9]{0,38}[a-z0-9])?)`，这意味着以下内容：
- en: Only alphanumerics and `-` allowed
  id: totrans-66
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只允许字母数字和`-`
- en: Start with a letter and end with an alphanumeric
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以字母开头，以字母或数字结尾
- en: No longer than 40 characters
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不超过40个字符
- en: 'When the cluster is created, there are a number of parameters we need to supply
    to the command that will be familiar if you have used GKE previously. A standard
    cluster requires the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当集群被创建时，我们需要向命令提供一些参数，如果你之前使用过GKE，这些参数会很熟悉。一个标准集群需要以下内容：
- en: Machine size—compute reference indicating the type of machine to be allocated
    per node
  id: totrans-70
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器规格—指示每个节点分配的计算机类型的参考
- en: Cluster version—signifies the version to be allocated to the Kubernetes cluster
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群版本—表示将分配给Kubernetes集群的版本
- en: Zone—the zone in which the compute resource will be created
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区域—将创建计算资源的区域
- en: Addons—ancillary commands providing additional functionality
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附加组件—提供额外功能的辅助命令
- en: During the provisioning process, in the GKE Cloud Console option, there is a
    more interactive version of the command line that shows what is being performed.
    However, there is no need to use this over the command other than curiosity.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置过程中，GKE Cloud Console选项中有一个更交互式的命令行版本，显示正在执行的操作。然而，除了出于好奇心，实际上没有必要使用这个命令行版本。
- en: 'Once the cluster provisioning process completes, it will denote the configuration
    created. As an option, we can also set the `gcloud` command defaults for the project
    at this stage:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦集群配置过程完成，它将表示已创建的配置。作为一个选项，我们还可以在此阶段为项目设置`gcloud`命令的默认值：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To confirm the cluster has been successfully created, use the `kubectl` command
    to interact with GKE. Kubectl is the main way to interact directly with the cluster
    created. In order to check the nodes, we need to issue the following command:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确认集群已成功创建，使用`kubectl`命令与GKE进行交互。Kubectl是与已创建集群直接交互的主要方式。为了检查节点，我们需要发出以下命令：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The output from the preceding command will display information such as the name,
    status, age, and version of the Kubernetes node deployed. In this context, a Kubernetes
    cluster is essentially our defined nodes working together as a unit.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令的输出将显示信息，如部署的Kubernetes节点的名称、状态、年龄和版本。在这个上下文中，Kubernetes集群本质上是我们定义的节点作为一个单元协同工作。
- en: In our GKE cluster, we now have the base platform on which to deploy Cloud Run.
    In the next section, we will take some time to explore how to deploy code to this
    environment. In addition, we will look at some workflow tips to aid development
    productivity.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的GKE集群中，我们现在拥有了部署Cloud Run的基础平台。在接下来的部分中，我们将花一些时间探索如何将代码部署到这个环境中。此外，我们还将查看一些工作流技巧，以帮助提高开发生产力。
- en: Custom networking on GKE
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GKE上的自定义网络
- en: When using Kubernetes on GKE, it's useful to understand that it will create
    a custom network. The key emphasis to note is that Kubernetes will utilize IP
    addressing to assist with communication across all of its resources (such as pods,
    nodes, and services, and so on).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在GKE上使用Kubernetes时，了解它会创建一个自定义网络是很有帮助的。需要特别注意的是，Kubernetes将利用IP地址来协助其所有资源（例如Pod、节点和服务等）之间的通信。
- en: Internal networking
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部网络
- en: The smallest element in a GKE cluster is called a **pod**. A pod is used to
    run containers and there can be just one or more, depending on the patterns used
    for a given application. Pods reside within the network namespace that is used
    to segregate access across the virtual network associated with Kubernetes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: GKE集群中最小的元素被称为**pod**。Pod用于运行容器，数量可以是一个或多个，具体取决于为给定应用使用的模式。Pods位于网络命名空间内，用于在Kubernetes关联的虚拟网络中隔离访问。
- en: Pods are scheduled to a node, and are able to communicate with any other pod,
    unless specifically restricted. Communication between pods is therefore taken
    as a given, even when they are removed and recreated dynamically. However, as
    pods are meant to be ephemeral, external access requires a separate mechanism
    called a service to provide a consistent point of access. Services use a label,
    which is basically a key-value pairing to a Kubernetes resource. Such a service
    retains a consistent IP address and port such that, externally, it can be used
    to access a grouping of pods as a logical unit.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Pods被调度到节点，并且可以与任何其他Pod通信，除非特别限制。因此，Pod之间的通信是默认的，即使它们被动态删除和重新创建。然而，由于Pod是短暂的，外部访问需要一个单独的机制，称为服务（service），以提供一致的访问点。服务使用标签，基本上是Kubernetes资源的键值对。这样的服务保持一致的IP地址和端口，以便从外部访问时，可以将其作为逻辑单元来访问一组Pods。
- en: External networking
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部网络
- en: For traffic outside of the cluster, the situation is managed in a different
    way. Kubernetes uses three distinct mechanisms to provide access to internal network
    resources.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于集群外的流量，情况是以不同的方式管理的。Kubernetes 使用三种不同的机制来提供对内部网络资源的访问。
- en: NodePort and ClusterIP provide access using an HTTP load balancer. Ingress access
    to resources requires a service to be defined for the reasons mentioned previously.
    The communication then ensures traffic is directed to the logical group labeled
    for the service.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: NodePort 和 ClusterIP 提供了通过 HTTP 负载均衡器的访问。Ingress 访问资源需要定义服务，原因如前所述。然后，通信确保流量被引导到标记为该服务的逻辑组。
- en: The main thing to note is that, as long as traffic remains within a cluster,
    communication between resources is enabled and supported. If external traffic
    is required, then a service and some form of load-balanced access should be made
    available.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的主要一点是，只要流量保持在集群内部，资源之间的通信就可以启用并得到支持。如果需要外部流量，则应该提供服务和某种形式的负载均衡访问。
- en: Deploying Cloud Run for Anthos
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署 Cloud Run for Anthos
- en: Now that we have a cluster created, we can think about how to deploy an application.
    The main emphasis of this section is to cover the process to use in terms of deploying
    an application to the GKE cluster. Google has been very deliberate in terms of
    trying to keep the Cloud Run commands as similar as possible. As in the previous
    section, we will build a simple Node.js container and push this to GKE.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经创建了集群，我们可以开始思考如何部署应用程序。本节的主要重点是涵盖部署应用程序到 GKE 集群的过程。谷歌非常有意识地使 Cloud Run
    命令尽可能相似。和前一节一样，我们将构建一个简单的 Node.js 容器，并将其推送到 GKE。
- en: 'To demonstrate the capability of our new GKE cluster, we will deploy the `hello-node`
    Node.js application. Our `hello-node` application simply prints out a message
    to the screen, so there is no code complexity to worry about. In fact, we already
    have the code available in the repository, so let''s clone that from the existing
    Cloud Shell environment:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示我们新 GKE 集群的能力，我们将部署 `hello-node` Node.js 应用程序。我们的 `hello-node` 应用程序只是简单地将一条消息打印到屏幕上，所以无需担心代码复杂性。实际上，我们已经在仓库中提供了代码，所以让我们从现有的
    Cloud Shell 环境中克隆它：
- en: 'Clone the GitHub repository:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆 GitHub 仓库：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Again, the `hello-node` application doesn't do anything amazing, it just outputs
    `Hello World!` on port `8080`. It is all packaged up (that is, into a `cloudbuild.yaml`
    file and a Dockerfile) and ready for use to push an image to the container repository.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，`hello-node` 应用程序并没有做什么特别的事情，它只是将 `Hello World!` 输出到 `8080` 端口。它已经打包好（也就是打包成
    `cloudbuild.yaml` 文件和 Dockerfile），并准备好用于将镜像推送到容器仓库。
- en: 'To begin the Cloud Build process, run the following command:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始 Cloud Build 过程，运行以下命令：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the build process, we will be using Google Container Registry, rather than
    the Docker Registry. A registry is essentially a storage location for images that
    can be used to push and pull stored images. The benefit of using a registry is
    that it provides a centralized storage area in which to share your images.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程中，我们将使用 Google 容器注册表，而不是 Docker 注册表。注册表本质上是一个存储镜像的位置，可以用来推送和拉取存储的镜像。使用注册表的好处是，它提供了一个集中存储区域，可以共享你的镜像。
- en: By default, the images stored in Container Registry are marked as private and
    require IAM permissions to access the content. Alternatively, images can also
    be marked as public, which means they can be shared outside of the project without
    requiring any additional authentication.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，存储在容器注册表中的镜像被标记为私有，需要 IAM 权限才能访问内容。或者，镜像也可以标记为公开，这意味着它们可以在不需要额外身份验证的情况下与项目外部共享。
- en: Once the build process has completed successfully, the image generated will
    be stored under the current Google Cloud project and given the tag specified in
    the `cloudbuild.yaml` file.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦构建过程成功完成，生成的镜像将存储在当前的 Google Cloud 项目下，并根据 `cloudbuild.yaml` 文件中指定的标签进行命名。
- en: 'The important thing to observe here is the tag associated with the image, as
    this is how the artifact will be referenced when pulling the image from the repository:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要特别注意的是与镜像关联的标签，因为这是在从仓库拉取镜像时引用该工件的方式：
- en: '![](img/8fcbb888-a085-4a5f-a1c5-5ed05051ca0e.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8fcbb888-a085-4a5f-a1c5-5ed05051ca0e.png)'
- en: Take a look in the Google Cloud Container Registry to see the image built in
    the previous step. Selecting the image in the registry will display further details,
    including the all-important tag reference.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 Google Cloud 容器注册表，以查看上一步构建的镜像。选择注册表中的镜像将显示更多详细信息，包括重要的标签引用。
- en: 'From Container Registry, we can see the image, together with the hostname and
    level of visibility (that is, private/public) applied. The hostname provides the
    region for which the image is associated, outlined as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从容器注册表中，我们可以看到镜像，以及应用的主机名和可见性级别（即，私有/公开）。主机名提供了镜像关联的区域，具体如下：
- en: '`gcr.io`: Currently located in the United States, but the location may change'
  id: totrans-105
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gcr.io`：当前位于美国，但位置可能会变化。'
- en: '`us.gcr.io`: United States'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`us.gcr.io`：美国'
- en: '`eu.gcr.io`: European Union'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eu.gcr.io`：欧盟'
- en: '`asia.gcr.io`: Asia'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asia.gcr.io`：亚洲'
- en: When building images, it is advantageous to use a location closest to the data
    to maximize overall performance. The reason for this is that, when pulling the
    image (that is, the retrieval process), you want to minimize the distance between
    the registry source and destination host machine.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建镜像时，最好选择距离数据最近的位置，以最大化整体性能。原因是，在拉取镜像（即获取过程）时，您希望尽量减少注册表源和目标主机之间的距离。
- en: The visibility of an image is either private to the project or public (that
    is, accessible by everyone). By default, the images are set to private; however,
    the visibility can easily be changed if required.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像的可见性可以是项目私有的，也可以是公开的（即，任何人都可以访问）。默认情况下，镜像设置为私有；不过，如果需要，也可以轻松更改可见性。
- en: 'At this point, as the image is present in the project registry, it will also
    be accessible to the cluster created earlier. Prior to deploying the image, let''s
    take a moment to understand some of the terms used in the standard commands for
    deployment:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，镜像已经存在于项目注册表中，集群也可以访问它。在部署镜像之前，让我们花一点时间了解一些用于部署的标准命令中的术语：
- en: '`SERVICE`: Represents the name to be associated with the image to be deployed.'
  id: totrans-112
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SERVICE`：表示要与部署的镜像关联的名称。'
- en: '`IMAGE`: An artifact available in Container Registry to be deployed as a service.'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IMAGE`：一个在容器注册表中可用的工件，将作为服务进行部署。'
- en: '`CLUSTER-NAME`: The name associated with the cluster created earlier; that
    is, `$CLUSTER_NAME`.'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLUSTER-NAME`：与先前创建的集群关联的名称，即 `$CLUSTER_NAME`。'
- en: '`CLUSTER-LOCATION`: This is the zone allocated to the cluster; that is, `$ZONE`.'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLUSTER-LOCATION`：这是分配给集群的区域，即 `$ZONE`。'
- en: Take note that the `IMAGE` tag must exactly match what is available in Container
    Registry (including a version number, if applied). If you are unsure of the tag
    to use, visit the Cloud Console and select the image required to see the relevant
    tag detail.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`IMAGE` 标签必须与容器注册表中的标签完全匹配（如果有版本号，也要包括）。如果不确定使用哪个标签，请访问 Cloud Console，选择所需的镜像以查看相关标签详情。
- en: The deployed container will be displayed with a service name, a revision (that
    is, a unique reference), and a URL for serving traffic. So far, we have created
    a placeholder for the service to be run. To make the container accessible as a
    named service, we need to deploy it. In the real world, the prior activities are
    likely going to be a one-off task and can be easily automated.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 部署后的容器将显示服务名称、修订版（即唯一引用）以及流量服务的 URL。到目前为止，我们已经为要运行的服务创建了一个占位符。为了将容器作为命名服务访问，我们需要部署它。在实际操作中，之前的活动很可能是一次性的任务，并且可以轻松自动化。
- en: 'To deploy the artifact to the GKE cluster, we use the `gcloud run deploy` command
    in the following way:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将工件部署到 GKE 集群，我们使用 `gcloud run deploy` 命令，方式如下：
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that the service has been deployed, there is a wealth of information suddenly
    available on the running of the application. There are two places of interest
    for information about the workloads running on GKE:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在服务已经部署，关于应用程序运行的大量信息突然变得可用。有两个地方值得关注，关于 GKE 上运行的工作负载的信息：
- en: The first is the Kubernetes Engine Workloads page, in which details of GKE deployments
    can be seen. If you are interested in the state of deployments or workloads sent
    to the cluster, this is a place to gather information. From here, it is possible
    to drill down into the various aspects of the deployment.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是 Kubernetes 引擎工作负载页面，其中可以查看 GKE 部署的详细信息。如果您对发送到集群的部署或工作负载的状态感兴趣，这里是获取信息的地方。从这里，您可以深入了解部署的各个方面。
- en: The second is Stackdriver. In the next section, we will update the application
    to see the impact this has on the data displayed and how to track information
    when things go wrong.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个是 Stackdriver。在下一节中，我们将更新应用程序，查看这对数据展示的影响，并了解如何在出现问题时跟踪信息。
- en: Now that we have a base-level understanding of deployment, we can consider how
    to automate the process using the toolset available on Google Cloud.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对部署有了基础了解，可以考虑如何利用 Google Cloud 提供的工具集来自动化这一过程。
- en: Continuous deployment
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续部署
- en: 'As we have seen, there is a lot of work to get a Cloud Run for Anthos up and
    running in comparison with Cloud Run. What happens if we want to deploy another
    revision of the code? Do we need to go through the whole process once again? Well
    no: the deployment of the service is the only aspect that needs to be repeated.
    Taking some time to explore this in more detail will be interesting and will provide
    an understanding of what is happening when multiple revisions are available to
    the cluster:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，与 Cloud Run 相比，启动 Cloud Run for Anthos 的工作量要大得多。如果我们想要部署代码的另一个修订版本会发生什么？我们需要再次走一遍整个过程吗？其实不需要：服务的部署是唯一需要重复的方面。花些时间更详细地探索这一点会很有意思，并且有助于理解在集群中存在多个修订版本时，发生了什么：
- en: 'Our previous image was version 0.1, so let''s implement a small change (I added
    a `+1` to the response string) and see the impact this has on the deployment process
    and rollout to the cluster:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们之前的镜像是版本 0.1，因此让我们进行一个小的改动（我在响应字符串中添加了 `+1`），看看这对部署过程以及向集群推出的影响：
- en: '[PRE8]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, update the stored image in Container Registry using the following command:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用以下命令更新 Container Registry 中存储的镜像：
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we want to deploy the updated image in our cluster:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们希望在集群中部署更新后的镜像：
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first this to do is confirm that the new service has been successfully deployed
    by looking at the command output. To get the status of a Cloud Run service, the
    Cloud console will always have an updated status in the workloads page and will
    show changes as they are initiated.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是确认新服务是否已成功部署，可以通过查看命令输出进行确认。要获取 Cloud Run 服务的状态，Cloud 控制台的工作负载页面始终会显示更新的状态，并在变更启动时显示相应信息。
- en: 'Unfortunately, it is a bit of a pain having to do these actions each time we
    want to deploy something. Never fear: there is a much more practical way of deploying
    our code that lets our trusty friends, the service account and Cloud Build, manage
    all the boring bits.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，每次我们想要部署某些内容时，都需要执行这些操作，实在是有点麻烦。不过不用担心：有一种更实用的方式来部署我们的代码，它允许我们的可靠伙伴——服务账户和
    Cloud Build，处理所有繁琐的部分。
- en: In the Cloud Build settings, amend the Cloud Run service account (Cloud Run
    Admin) and Service Accounts (Service Account User) to enabled. In the left-hand
    panel, select the Triggers option and connect to a valid repository.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cloud Build 设置中，修改 Cloud Run 服务账户（Cloud Run 管理员）和服务账户（服务账户用户）为启用状态。在左侧面板中，选择触发器选项并连接到有效的仓库。
- en: Note that, if a connection to GitHub has already been established, this will
    need to be done to successfully complete this setup.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果已经建立了与 GitHub 的连接，必须完成此操作才能成功完成设置。
- en: Creating a push trigger can be set up for specific branches or for all pushes
    to the repository. Note the type of trigger will attempt to auto-detect the configuration
    file. In the case of the author, the `cloudbuild.yaml` file is renamed `cloudbuild.github`,
    so that it is patently obvious which environment file should be used.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为特定分支或所有推送到仓库的推送设置触发器。请注意，触发器类型会尝试自动检测配置文件。在作者的情况下，`cloudbuild.yaml` 文件被重命名为
    `cloudbuild.github`，这样就很明显应该使用哪个环境文件。
- en: Select the create button and the trigger will now be active for the selected
    repository.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 选择创建按钮，触发器将为选定的仓库激活。
- en: 'Back with the source code, let''s amend the source code once more with another
    simple change, so we have a visible way to discern the difference in deployed
    versions. Update the highlighted line so it reflects the change shown as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到源代码，让我们再对源代码进行一次修改，做一个简单的变更，以便可以明显看到已部署版本之间的区别。更新高亮的行，使其反映如下更改：
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we will need to amend the `cloudbuild.github.yaml` file to refine
    our build process. The updated configuration file will look similar to that shown
    as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要修改 `cloudbuild.github.yaml` 文件，以优化我们的构建过程。更新后的配置文件将类似于以下所示：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Taking a closer look at the build file outlined in the preceding code block,
    we can see the flexibility of Cloud Builds, as it allows commands to be directly
    initiated. A closer examination of the commands highlights the following activities:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看前面代码块中列出的构建文件，我们可以看到 Cloud Builds 的灵活性，因为它允许直接启动命令。进一步检查这些命令，突出显示以下活动：
- en: '**Build the container image**: The `build` command is essentially a standard
    `docker build` command that tags the image with the appropriate naming convention.'
  id: totrans-143
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建容器镜像**：`build` 命令本质上是标准的 `docker build` 命令，它会使用适当的命名约定为镜像打标。'
- en: '**Push the container image to Container Registry**: Once the `docker build`
    process is complete, the image built is then pushed to Google Container Registry
    with the specified tag. Again, the standard Docker command is used to send the
    image to the repository.'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将容器镜像推送到容器注册表**：一旦 `docker build` 过程完成，构建的镜像将被推送到 Google 容器注册表，并使用指定的标签。再次使用标准的
    Docker 命令将镜像发送到仓库。'
- en: '**Deploy the container to Cloud Run**: The tagged image is deployed to the
    cluster.'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将容器部署到 Cloud Run**：打标的镜像被部署到集群中。'
- en: A layout such as this provides a common build pattern for Docker-based environments.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种布局为基于 Docker 的环境提供了一个常见的构建模式。
- en: 'To initiate a build, once again, we would need to initiate the build process
    from the command line:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启动构建，我们再次需要从命令行启动构建过程：
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: However, the preceding manual step is no longer necessary! The repository has
    now been linked directly to GitHub, so each time a branch change is detected,
    the build process will be automatically initiated. Working with Cloud Build can
    save a lot of effort for very little configuration, and is worth the investment
    in time to understand how it works.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，前述的手动步骤不再必要！该代码库现在已直接与 GitHub 关联，因此每当检测到分支更改时，构建过程会自动启动。使用 Cloud Build 可以节省大量精力，只需极少的配置，非常值得花时间去了解它是如何工作的。
- en: Having successfully built a service, in the next section we take a quick look
    at domains and how these are applied on Google Cloud when using Cloud Run.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功构建了一个服务之后，在下一部分我们将快速了解域名以及在使用 Cloud Run 时如何将其应用于 Google Cloud。
- en: Applying a domain
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用域名
- en: Once a service has been deployed, Google Cloud provides a number of options
    to manage the associated domain name. In short, a domain name provides the ability
    to map a service IP address so that is accessible on the internet with a human-readable
    name. So, instead of accessing the IP `216.58.206.110`, we can enter `www.google.com`
    into the browser—I will leave it to you to consider which is more memorable.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务被部署，Google Cloud 提供了许多选项来管理相关的域名。简而言之，域名提供了将服务 IP 地址映射到互联网并使用人类可读的名称访问的能力。因此，我们可以在浏览器中输入
    `www.google.com` 而不是访问 IP `216.58.206.110` —— 我将留给你考虑哪个更容易记住。
- en: Registering a domain name has become increasingly easy over the years and many
    companies provide an opportunity to purchase your own part of the internet. Once
    you have a domain name, you can actually map this to your Cloud Run service.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注册域名变得越来越容易，许多公司提供购买自己互联网一部分的机会。一旦你拥有了一个域名，你实际上可以将其映射到你的 Cloud Run 服务。
- en: 'If you do not wish to purchase a domain name, Google Cloud incorporates three
    external wildcard **domain name system** (**DNS**) test sites that can be associated
    with a deployed Cloud Run service, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想购买域名，Google Cloud 集成了三个外部通配符 **域名系统** (**DNS**) 测试网站，这些网站可以与部署的 Cloud Run
    服务关联，如下所示：
- en: '| **DNS service** | **Information** |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| **DNS 服务** | **信息** |'
- en: '| `nip.io` | [https://exentriquesolutions.com/](https://exentriquesolutions.com/)
    |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `nip.io` | [https://exentriquesolutions.com/](https://exentriquesolutions.com/)
    |'
- en: '| `xip.io` | [https://basecamp.com/](https://basecamp.com/) |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `xip.io` | [https://basecamp.com/](https://basecamp.com/) |'
- en: '| `sslip.io` | [https://github.com/sstephenson](https://github.com/sstephenson)[https://github.com/cunnie/sslip.io](https://github.com/cunnie/sslip.io)
    |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `sslip.io` | [https://github.com/sstephenson](https://github.com/sstephenson)[https://github.com/cunnie/sslip.io](https://github.com/cunnie/sslip.io)
    |'
- en: Alternatively, if you already own a domain, this can also be set up and used
    instead of the default domain. When you are not running a live service, having
    your own domain will likely be of little concern. However, once your product moves
    to production, having a domain looks much more professional.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你已经拥有一个域名，也可以将其设置并用于替代默认的域名。当你没有运行实时服务时，拥有自己的域名可能不会太重要。然而，一旦你的产品进入生产环境，拥有一个域名看起来就会更加专业。
- en: 'The default domain name used by Cloud Run for Anthos is actually `example.com`.
    When you change the domain, for example, to a test site, the service deployed
    will be registered against the selected name system, for example, `xip.io`. Changing
    the DNS setting requires the use of a config map to tell Kubernetes how the domain
    is to be configured:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Run for Anthos 默认使用的域名实际上是 `example.com`。当你更改域名时，例如，更改为测试站点，已部署的服务将注册到所选的名称系统中，例如
    `xip.io`。更改 DNS 设置需要使用配置映射来告诉 Kubernetes 如何配置域名：
- en: In the following section, we capture the output into environment variables.
    Doing this means we do not have to continually keep posting API requests to confirm
    values.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将捕获输出到环境变量中。这样做的目的是我们不需要不断地发送 API 请求来确认值。
- en: 'Get the service URL, currently using `default.com`, for example:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取当前使用 `default.com` 的服务 URL，例如：
- en: '[PRE14]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Get the external IP of the deployed service:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取已部署服务的外部 IP 地址：
- en: '[PRE15]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Apply a patch to the config map using the Istio Ingress IP as the external
    IP:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Istio Ingress IP 作为外部 IP，应用补丁到配置映射：
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Update the service URL environment variable:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新服务 URL 环境变量：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `gcloud sdk` and `kubectl` commands provide information in a number of formats,
    including JSON. Learning how to parse JSON is a very handy skill to acquire when
    learning to develop command-line scripts.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`gcloud sdk` 和 `kubectl` 命令提供多种格式的信息，包括 JSON。学习如何解析 JSON 是开发命令行脚本时一个非常实用的技能。'
- en: Congratulations! You have enabled a custom domain on your service. Now rather
    than displaying `default.com`, the service will be registered against the selected
    domain.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经为你的服务启用了自定义域名。现在，服务将不再显示 `default.com`，而是会注册到选定的域名。
- en: In the next section, we will cover the monitoring of an application and give
    some insights into the helpful information available.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将讨论应用程序的监控，并提供一些有用的信息见解。
- en: Troubleshooting with Stackdriver
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Stackdriver 进行故障排除
- en: Earlier sections have discussed many of the key details of Cloud Run. So far,
    we have provisioned a cluster on GKE, deployed our application and utilized Cloud
    Build to make us more productive. At this point, we should probably also cover
    what to do when things go wrong.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的章节已经讨论了 Cloud Run 的许多关键细节。到目前为止，我们已经在 GKE 上配置了集群，部署了我们的应用程序，并利用 Cloud Build
    提高了我们的生产力。在此时，我们可能还需要讨论当出现问题时该怎么办。
- en: 'Google Cloud provides a lot of environmental information, especially for compute-based
    resources such as GCE and GKE. For serverless workloads, fortunately, we can also
    take advantage of many of these key data points:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cloud 提供了很多环境信息，特别是对于基于计算的资源，如 GCE 和 GKE。幸运的是，对于无服务器工作负载，我们也可以利用这些关键数据点：
- en: 'To start, let''s continue with our `hello-node` application and introduce an
    error into the code. Access the source code for `index.js` and save the following
    erroneous entry to the code:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们继续使用我们的 `hello-node` 应用程序，并向代码中引入一个错误。访问 `index.js` 的源代码，并将以下错误条目保存到代码中：
- en: '[PRE18]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, we have intentionally added a code defect so that we
    can track this in Stackdriver. Once again we can run our `cloudbuild.github` to
    do all the hard work for us. However, this time the deployment task will fail!
    To see the details of the failure, we should go to the Cloud Run interface and
    investigate the existing services.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上述代码中，我们故意添加了一个代码缺陷，以便我们可以在 Stackdriver 中跟踪此问题。我们可以再次运行 `cloudbuild.github`
    来为我们完成所有繁重的工作。然而，这次部署任务会失败！要查看失败的详细信息，我们应该进入 Cloud Run 界面并调查现有服务。
- en: From the Cloud Run dashboard view, we have a green circle with a ticket mark
    present indicating the `hello-node` service has been successfully deployed and
    is operating within expected parameters. Contrast this with our latest deployment
    of the `hello-node` service that has encountered an error, as indicated by the
    red circle with an exclamation mark in the center. Furthermore, neither the GKE
    Cluster or Namespace detail is present, meaning the image has not been deployed
    to its end destination.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Cloud Run 仪表板视图中，我们可以看到一个绿色圆圈和勾号，表示 `hello-node` 服务已经成功部署并在预期的参数内运行。与此相比，我们最新部署的
    `hello-node` 服务出现了错误，图中间有一个红色圆圈和感叹号。另外，GKE 集群或命名空间详情没有显示，意味着镜像尚未部署到最终目标位置。
- en: 'Select the application with the error to display further information on the
    Services details page, as follows:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择带有错误的应用程序以显示服务详情页面上的更多信息，如下所示：
- en: '![](img/b7ef7070-4707-4f60-939c-491a4b757528.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b7ef7070-4707-4f60-939c-491a4b757528.png)'
- en: Before we get into how to explore further information about the error displayed,
    we should take a moment to highlight the Cloud Run Service details page and the
    information accessible from there.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨如何进一步了解显示的错误信息之前，我们应当花点时间来重点介绍 Cloud Run 服务详情页以及从该页可以访问到的信息。
- en: 'Whenever you deploy a service, there is a tremendous amount of information
    exchange taking place, much of it in the background. One of the important aspects
    of working with Google Cloud is the centralized management of resource-related
    data. Much of the information relating to services or resources deployed within
    your project will be captured in Stackdriver. Thankfully, the engineers at Google
    have taken the most common elements exposed in Stackdriver and added them to a
    handy dashboard covering METRICS, REVISION, LOGS, DETAILS, and YAML, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 每次部署服务时，都会进行大量的信息交换，其中许多操作是在后台完成的。使用 Google Cloud 的一个重要方面是资源相关数据的集中管理。与项目中部署的服务或资源相关的很多信息将被捕获到
    Stackdriver 中。幸运的是，Google 的工程师将 Stackdriver 中最常用的元素提取出来，并将其添加到一个便捷的仪表板中，涵盖了 METRICS、REVISIONS、LOGS、DETAILS
    和 YAML，具体如下：
- en: '![](img/4681cb86-eed2-43d2-a508-b64eef0d4c5d.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4681cb86-eed2-43d2-a508-b64eef0d4c5d.png)'
- en: 'Let''s explore these dashboard elements one by one:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一探索这些仪表板元素：
- en: '**METRICS**: The metrics screen provides a range of data that is commonly used
    by an application, for example, a request count. In addition, the information
    presented can also be filtered by time period (such as 1 hour, 6 hours, 7 days,
    or 30 days). From this screen, an application state can easily be viewed and issues
    relating to the service performance can begin to be investigated. So, if you have
    an issue relating to the performance of a service, for example, such as latency
    or bottlenecking, this is the screen where the attributes of an application can
    be viewed to get a sense of what is happening.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**度量（METRICS）**: 度量屏幕提供了应用程序常用的一系列数据，例如请求计数。此外，展示的信息也可以按时间段进行过滤（例如 1 小时、6 小时、7
    天或 30 天）。从这个屏幕中，应用程序的状态可以轻松查看，并可以开始调查与服务性能相关的问题。因此，如果你遇到与服务性能相关的问题，例如延迟或瓶颈，这就是查看应用程序属性以了解发生了什么的地方。'
- en: '**REVISIONS**: An overview of the revisions deployed, including environment
    variables and Cloud SQL connectivity.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修订（REVISIONS）**: 展示已部署的修订版本概览，包括环境变量和 Cloud SQL 连接情况。'
- en: '**LOGS**: Access the logged information for the service. The detail available
    is based on the system logs, so information captured by an application will be
    available here.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志（LOGS）**: 访问服务的日志信息。这里提供的详细信息基于系统日志，因此应用程序捕获的信息也会出现在此处。'
- en: '**DETAILS**: From this page, the service connectivity and authentication information
    are shared.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**详情（DETAILS）**: 在此页面中，服务连接和认证信息将会共享。'
- en: '**YAML**: The last tab provides an overview of the YAML associated with the
    service being viewed.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**YAML**: 最后一页提供了与当前查看的服务相关的 YAML 概览。'
- en: Remember that, at the time of writing this book, the dashboard capability was
    still being revised, so expect changes of a subtle (and not-so-subtle) nature
    in the feature set.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在写这本书的时候，仪表板功能仍在修订中，因此你可能会看到一些细微（甚至是明显的）变化。
- en: Now we have outlined the relative capabilities of the dashboard, we can move
    on to resolving our service error.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经概述了仪表板的相对功能，接下来我们可以开始解决我们的服务错误。
- en: Earlier, you will remember that we updated our application and introduced an
    error. We can see in the main dashboard of Cloud Run that our service was unsuccessful.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，我们早些时候更新了应用程序并引入了一个错误。在 Cloud Run 的主仪表板上，我们可以看到我们的服务未成功。
- en: 'Over the course of the chapter we have started with a simple application, and
    then incorporated it into a continuous integration build process. Traditionally,
    we use logs to get insight into applications that are not operating within standard
    procedures. Given that we have handed over much of the build process to an automated
    process, it makes sense that the logs for each stage of this process are also
    available centrally:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从一个简单的应用程序开始，然后将其纳入了持续集成构建过程。传统上，我们使用日志来深入了解那些未按标准流程运行的应用程序。由于我们已将构建过程的许多环节交给自动化流程，因此每个阶段的日志也理应集中存储：
- en: Go to Stackdriver. The logs that would naturally be available locally to the
    developer are now present in a central repository.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到 Stackdriver。那些本应在开发者本地可用的日志现在集中存储在一个中央仓库中。
- en: In the Cloud Run dashboard, select the item indicating an error to once again
    go to the Service details page.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Cloud Run仪表盘中，选择显示错误的项目，重新进入服务详情页面。
- en: From here, select the LOGS tab and take a closer look at what information has
    been captured by the logging process.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，选择LOGS选项卡，仔细查看日志进程捕获了哪些信息。
- en: Note that each entry in Stackdriver is timestamped, and associated with this
    is some form of command that returned a status update.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Stackdriver中的每一条日志项都带有时间戳，并且与此相关的是返回状态更新的某种命令。
- en: Working through the content displayed on screen, we can see that our application
    is executed with the `index.js` command node. If you are unclear why, it is because
    this relates to the start command we entered into the `package.json` file.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通过屏幕上显示的内容，我们可以看到应用程序是通过`index.js`命令节点执行的。如果你不明白为什么，是因为这与我们在`package.json`文件中输入的启动命令有关。
- en: 'Looking further down the list, we can see reference to `/usr/src/app/index.js:5`.
    This is telling us that something interesting occurred at the fifth line in `index.js`.
    In the following line, the logs indicate something curious: `oops` has been found
    in the source file. Well, that is clearly not meant to be there, so we have found
    our typo.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表的进一步查找中，我们看到提到了`/usr/src/app/index.js:5`。这表明在`index.js`的第五行发生了一些有趣的事情。在接下来的日志中，系统显示了一个有趣的提示：在源文件中发现了`oops`。显然，这不是我们想要的内容，因此我们找到了拼写错误。
- en: Now that we have explored the logs for valuable clues to correct our application
    defect, go back to the source code and remove the typo on line five of `index.js`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经通过日志探索到了有价值的线索来修正我们的应用缺陷，回到源代码并删除`index.js`文件中第五行的拼写错误。
- en: Resubmit the changed code to a branch and see the code once again automatically
    update to take account of the changes made.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将更改后的代码重新提交到一个分支，并再次查看代码是否自动更新以反映所做的更改。
- en: At this point, the code should be successfully working, based on the update
    made. Confirm the code is working by checking the text displayed is the same as
    that displayed in the current version of the source code.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，代码应根据所做的更新成功工作。通过检查显示的文本是否与当前版本源代码中显示的内容相同来确认代码是否正常运行。
- en: Hopefully, the process on which to debug an application has been made clearer
    with this preceding example. By incorporating the development workflow earlier
    into the Cloud process, it makes the overall integration more complete. Being
    able to utilize built-in tools such as Stackdriver provides an easier path to
    increased productivity.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 希望通过这个示例，调试应用程序的过程变得更加清晰。通过将开发工作流提前融入Cloud流程，它使整体集成更加完整。能够利用内建工具，如Stackdriver，提供了一个更容易的途径来提高生产力。
- en: Deleting the cluster
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除集群
- en: To complete the chapter, the final activity to cover is deleting the cluster.
    Removing a cluster is not a common activity; in fact, the only reason it is included
    here is to show the process. As we now know, the cluster incorporates all the
    base-level functionality associated with Kubernetes. On GKE, our cluster is managed;
    that is, you don't need to concern yourself with low-level activities such as
    node creation, TLS certification creation, and so on.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这一章，最后一个活动是删除集群。删除集群并不是一个常见的操作；事实上，之所以在这里展示，是为了说明这一过程。正如我们现在所知道的，集群包含了所有与Kubernetes相关的基础功能。在GKE上，我们的集群是受管理的；也就是说，你不需要担心诸如节点创建、TLS证书创建等低级别的活动。
- en: 'With that said, in order to remove the cluster created previously, use the
    following command:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，要删除之前创建的集群，请使用以下命令：
- en: '[PRE19]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Just to be clear, at the time of writing, the `cluster delete` command is in
    beta, so there may be some potential changes going forward.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清，在撰写时，`cluster delete`命令处于测试阶段，因此将来可能会有一些变化。
- en: Once we embark on deleting the cluster, it removes all the associated workloads,
    that is, the deployed containers. To restart, a new cluster would need to be created
    in order to deploy Cloud Run for Anthos.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开始删除集群，它会移除所有相关的工作负载，即已部署的容器。要重新启动，需要创建一个新集群以便部署Cloud Run for Anthos。
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the high-level concept of Kubernetes and then
    looked at how Cloud Run for Anthos can be used. If your platform of choice is
    Kubernetes, Cloud Run for Anthos is the path to follow. As we have seen, the migration
    between non-Kubernetes and Kubernetes environments requires no additional configuration
    as the delivery artifact is based on a container.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Kubernetes 的高级概念，并探讨了如何使用 Cloud Run for Anthos。如果你的首选平台是 Kubernetes，那么
    Cloud Run for Anthos 就是你应该选择的路径。正如我们所看到的，非 Kubernetes 环境与 Kubernetes 环境之间的迁移无需额外配置，因为交付工件是基于容器的。
- en: Through this chapter, we have discovered a more productive way to incorporate
    Cloud Build into our developer workflow. Utilizing the developer tools provided
    by Google is a sensible way to minimize the repetitive aspects that are integral
    to the build and deploy process.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章内容，我们发现了一种更高效的方式将 Cloud Build 融入开发者工作流。利用 Google 提供的开发者工具是减少构建和部署过程中重复性工作的明智方式。
- en: In the next chapter, we develop a couple of Cloud Run examples to illustrate
    some key features. Working through some example use cases will help to illustrate
    how to utilize Cloud Run in your own projects.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开发几个 Cloud Run 示例来说明一些关键功能。通过一些示例用例，将有助于说明如何在自己的项目中使用 Cloud Run。
- en: Questions
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What type of machine customization is possible when using Cloud Run for Anthos?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Cloud Run for Anthos 时可以进行哪些类型的机器定制？
- en: Are SSL certificates automatic or manual when using Cloud Run for Anthos?
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Cloud Run for Anthos 时，SSL 证书是自动生成的还是手动生成的？
- en: What platform flag is required when deploying to Cloud Run for Anthos?
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署到 Cloud Run for Anthos 时需要哪些平台标志？
- en: What port is used for service access when using Cloud Run for Anthos?
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Cloud Run for Anthos 时，服务访问使用哪个端口？
- en: Is a pre-provisioned cluster required for Cloud Run for Anthos? (True or False)
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Cloud Run for Anthos 需要预先配置集群吗？（正确或错误）
- en: What addons are required for Cloud Run for Anthos?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Cloud Run for Anthos 需要哪些附加组件？
- en: Which command is used to manage a GKE cluster from the command line?
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个命令用于从命令行管理 GKE 集群？
- en: What is a pod?
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 pod？
- en: How does GKE support external traffic?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GKE 如何支持外部流量？
- en: Further reading
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: '**Istio**: [https://cloud.google.com/istio/](https://cloud.google.com/istio/)'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Istio**: [https://cloud.google.com/istio/](https://cloud.google.com/istio/)'
- en: '**Cloud Run Authentication**: [https://cloud.google.com/run/docs/authenticating/overview](https://cloud.google.com/run/docs/authenticating/overview)'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cloud Run 身份验证**: [https://cloud.google.com/run/docs/authenticating/overview](https://cloud.google.com/run/docs/authenticating/overview)'
- en: '**Google Kubernetes Engine**: [https://cloud.google.com/kubernetes-engine/](https://cloud.google.com/kubernetes-engine/)'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google Kubernetes Engine**: [https://cloud.google.com/kubernetes-engine/](https://cloud.google.com/kubernetes-engine/)'
- en: '**Mapping Custom Domains**: [https://cloud.google.com/appengine/docs/standard/python/mapping-custom-domains](https://cloud.google.com/appengine/docs/standard/python/mapping-custom-domains)'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**映射自定义域名**: [https://cloud.google.com/appengine/docs/standard/python/mapping-custom-domains](https://cloud.google.com/appengine/docs/standard/python/mapping-custom-domains)'
- en: '**Filtering and formatting fun with gcloud, Google Cloud''s command-line interface**:
    [https://cloud.google.com/blog/products/gcp/filtering-and-formatting-fun-with](https://cloud.google.com/blog/products/gcp/filtering-and-formatting-fun-with)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过 gcloud、Google Cloud 的命令行界面进行过滤和格式化的乐趣**: [https://cloud.google.com/blog/products/gcp/filtering-and-formatting-fun-with](https://cloud.google.com/blog/products/gcp/filtering-and-formatting-fun-with)'
- en: '**JQ tutorial**: [https://stedolan.github.io/jq/tutorial/](https://stedolan.github.io/jq/tutorial/)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JQ 教程**: [https://stedolan.github.io/jq/tutorial/](https://stedolan.github.io/jq/tutorial/)'
