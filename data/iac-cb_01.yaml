- en: Chapter 1. Vagrant Development Environments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章：Vagrant 开发环境
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下内容：
- en: Adding an Ubuntu Xenial (16.04 LTS) Vagrant box
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个 Ubuntu Xenial (16.04 LTS) 的 Vagrant 盒子
- en: Using a disposable Ubuntu Xenial (16.04) in seconds
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用临时的 Ubuntu Xenial (16.04) 环境，几秒钟内完成
- en: Enabling VirtualBox Guest Additions in Vagrant
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Vagrant 中启用 VirtualBox 客户端附加功能
- en: Using a disposable CentOS 7.x with VMware in seconds
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 VMware 快速启动一个临时的 CentOS 7.x 环境
- en: Extending the VMware VM capabilities
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展 VMware 虚拟机的功能
- en: Enabling multiprovider Vagrant environments
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用多提供商的 Vagrant 环境
- en: Customizing a Vagrant VM
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义 Vagrant 虚拟机
- en: Using Docker with Vagrant
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Vagrant 中使用 Docker
- en: Using Docker in Vagrant for a Ghost blog behind NGINX
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Vagrant 中使用 Docker 来运行 Ghost 博客并通过 NGINX 代理
- en: Using Vagrant remotely with AWS EC2 and Docker
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Vagrant 远程连接 AWS EC2 和 Docker
- en: Simulating dynamic multiple host networking
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟动态多主机网络环境
- en: Simulating a networked three-tier architecture app with Vagrant
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Vagrant 模拟一个三层架构的网络化应用
- en: Showing your work on the LAN while working with Laravel
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用 Laravel 时，将你的工作展示到局域网中
- en: Sharing access to your Vagrant environment with the world
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与全球共享你 Vagrant 环境的访问权限
- en: Simulating Chef upgrades using Vagrant
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Vagrant 模拟 Chef 升级
- en: Using Ansible with Vagrant to create a Docker host
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ansible 和 Vagrant 创建一个 Docker 主机
- en: Using Docker containers on CoreOS with Vagrant
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 CoreOS 上使用 Vagrant 运行 Docker 容器
- en: Introduction
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Vagrant is a free and open source tool by Hashicorp aimed at building a repeatable
    development environment inside a virtual machine, using simple Ruby code. You
    can then distribute this simple file with other people, team members, and external
    contributors, so that they immediately have a working running environment as long
    as they have virtualization on their laptop. It also means that you can use a
    Mac laptop, and with a simple command, launch a fully configured Linux environment
    for you to use locally. Everyone can work using the same environment, regardless
    of their own local machine. Vagrant is also very useful to simulate full production
    environments, with multiple machines and specific operating system versions. Vagrant
    is compatible with most hypervisors, such as VMware, VirtualBox, or Parallels,
    and can be largely extended using plugins.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant 是由 Hashicorp 开发的一个免费开源工具，旨在通过简单的 Ruby 代码在虚拟机内部构建可重复的开发环境。你可以将这个简单的文件与其他人、团队成员和外部贡献者共享，只要他们的笔记本电脑支持虚拟化，就能立即拥有一个可用的运行环境。这也意味着你可以使用一台
    Mac 笔记本，通过一个简单的命令启动一个完全配置的 Linux 环境以供本地使用。无论每个人的本地机器是什么配置，大家都可以在相同的环境下工作。Vagrant
    还非常适用于模拟完整的生产环境，涵盖多个机器和特定操作系统版本。Vagrant 兼容大多数虚拟机监控器，如 VMware、VirtualBox 或 Parallels，并且可以通过插件大幅扩展功能。
- en: Vagrant uses *boxes* to run. These boxes are just packaged virtual machines
    images that are available, for example, from [https://atlas.hashicorp.com/boxes/search](https://atlas.hashicorp.com/boxes/search),
    or you can alternatively build your own using various tools.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant 使用 *盒子* 运行。这些盒子实际上是已经打包好的虚拟机镜像，可以从 [https://atlas.hashicorp.com/boxes/search](https://atlas.hashicorp.com/boxes/search)
    等网站获取，或者你也可以使用各种工具构建自己的盒子。
- en: Vagrant can be greatly extended using plugins. There're plugins for almost anything
    you can think about, and most of them are community supported. From specific guest
    operating systems to remote IaaS providers, features around sharing, caching or
    snapshotting, networking, testing or specifics to Chef/Puppet, a lot can be done
    through plugins in Vagrant.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant 可以通过插件进行极大的扩展。几乎任何你能想到的功能都有相应的插件，而且大多数插件都由社区支持。从特定的操作系统到远程 IaaS 提供商，再到共享、缓存或快照、网络、测试功能，甚至是
    Chef/Puppet 相关的特性，都可以通过 Vagrant 的插件实现。
- en: 'A list of all available plugins, including all Vagrant providers is available
    on the Vagrant wiki here: [https://github.com/mitchellh/vagrant/wiki/Available-Vagrant-Plugins](https://github.com/mitchellh/vagrant/wiki/Available-Vagrant-Plugins).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可用插件的列表，包括所有 Vagrant 提供商，已在 Vagrant wiki 上提供，链接如下：[https://github.com/mitchellh/vagrant/wiki/Available-Vagrant-Plugins](https://github.com/mitchellh/vagrant/wiki/Available-Vagrant-Plugins)。
- en: 'More information about all integrated providers can be found on Vagrant''s
    website: [https://www.vagrantup.com/docs/providers/](https://www.vagrantup.com/docs/providers/).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 关于所有集成提供商的更多信息，可以在 Vagrant 官网找到：[https://www.vagrantup.com/docs/providers/](https://www.vagrantup.com/docs/providers/)。
- en: You can download a Vagrant installer for your platform from [https://www.vagrantup.com/downloads.html](https://www.vagrantup.com/downloads.html).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 [https://www.vagrantup.com/downloads.html](https://www.vagrantup.com/downloads.html)
    下载适用于你平台的 Vagrant 安装程序。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Vagrant version in use for this book is Vagrant 1.8.4
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用的 Vagrant 版本是 Vagrant 1.8.4。
- en: Adding an Ubuntu Xenial (16.04 LTS) Vagrant box
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个 Ubuntu Xenial (16.04 LTS) Vagrant 盒子
- en: Vagrant boxes are referred to by their names, usually following the *username/boxname*
    naming scheme. A 64-bits *Precise* box released by *Ubuntu* will be named *ubuntu/precise64*
    while the *centos/7* box will always be the latest CentOS 7 official box.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant 盒子通过名称进行引用，通常遵循 *用户名/盒子名* 的命名规则。由 *Ubuntu* 发布的 64 位 *Precise* 盒子将命名为
    *ubuntu/precise64*，而 *centos/7* 盒子将始终是最新的 CentOS 7 官方盒子。
- en: Getting ready
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此步骤，你将需要以下内容：
- en: A working Vagrant installation using the free and open source Virtualbox hypervisor
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用免费开源的 Virtualbox 虚拟机管理程序的 Vagrant 安装实例
- en: An Internet connection
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个互联网连接
- en: How to do it…
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Open a terminal and type the following code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端并输入以下代码：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works…
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Vagrant knows where to look for the latest version for the requested box on
    the Atlas service and automatically downloads it over the Internet. All boxes
    are stored by default in `~/.vagrant.d/boxes`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant 知道在哪里查找请求的盒子在 Atlas 服务中的最新版本，并会自动通过互联网下载它。所有的盒子默认存储在`~/.vagrant.d/boxes`目录下。
- en: There's more…
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: If you're interested in creating your own base Vagrant boxes, refer to Packer
    ([https://www.packer.io/](https://www.packer.io/)) and the Chef Bento project
    ([http://chef.github.io/bento/](http://chef.github.io/bento/)).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣创建自己的基础 Vagrant 盒子，请参考 Packer ([https://www.packer.io/](https://www.packer.io/))
    和 Chef Bento 项目 ([http://chef.github.io/bento/](http://chef.github.io/bento/))。
- en: Using a disposable Ubuntu Xenial (16.04) in seconds
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 几秒钟内使用一次性 Ubuntu Xenial (16.04) 系统
- en: We want to access and use an Ubuntu Xenial system (16.04 LTS) as quickly as
    possible.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望尽可能快速地访问并使用 Ubuntu Xenial 系统（16.04 LTS）。
- en: 'To do that, Vagrant uses a file named `Vagrantfile` to describe the Vagrant
    infrastructure. This file is in fact pure Ruby that Vagrant reads to manage your
    environment. Everything related to Vagrant is done inside a block such as the
    following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，Vagrant 使用名为 `Vagrantfile` 的文件来描述 Vagrant 基础设施。这个文件实际上是纯 Ruby 代码，Vagrant
    读取它来管理你的环境。所有与 Vagrant 相关的操作都在一个类似下面的代码块内完成：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Getting ready
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此步骤，你将需要以下内容：
- en: A working Vagrant installation
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个工作的 Vagrant 安装实例
- en: A working VirtualBox installation
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个工作的 VirtualBox 安装实例
- en: An Internet connection
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个互联网连接
- en: How to do it…
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Create a folder for the project:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个项目文件夹：
- en: '[PRE2]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Using your favorite editor, create this very minimal Vagrantfile to launch
    an ubuntu/`xenial64` box:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你最喜欢的编辑器，创建这个非常简单的 Vagrantfile 来启动 ubuntu/`xenial64` 盒子：
- en: '[PRE3]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now you can execute Vagrant, by explicitly using the Virtualbox hypervisor:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以显式使用 Virtualbox 虚拟机管理程序执行 Vagrant：
- en: '[PRE4]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Within seconds, you''ll have a running Ubuntu 16.04 Vagrant box on your host
    and you can do whatever you want with it. For example, start by logging into it
    via **Secure Shell** (**SSH**) by issuing the following `vagrant` command and
    use the system normally:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几秒钟内，你将在主机上运行一个 Ubuntu 16.04 Vagrant 盒子，你可以对它做任何你想做的事。例如，可以通过发出以下 `vagrant`
    命令使用 **安全外壳** (**SSH**) 登录并正常使用系统：
- en: '[PRE5]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When you''re done with your Vagrant VM, you can simply destroy it:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你完成使用 Vagrant 虚拟机时，你可以直接销毁它：
- en: '[PRE6]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Alternatively, we can just stop the Vagrant VM with the goal of restarting
    it later in its current state using vagrant halt:'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另外，我们可以通过使用 vagrant halt 停止 Vagrant 虚拟机，目的是稍后在当前状态下重新启动它：
- en: '**$ vagrant halt**'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**$ vagrant halt**'
- en: How it works…
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When you started Vagrant, it read the Vagrantfile, asking for a specific box
    to run (Ubuntu Xenial). If you previously added it, it will launch it right away
    through the default hypervisor (in this case, VirtualBox), or if it's a new box,
    download it for you automatically. It created the required virtual network interfaces,
    then the Ubuntu VM got a private IP address. Vagrant took care of configuring
    **SSH** by exposing an available port and inserting a default key, so you can
    log into it via SSH without problems.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动 Vagrant 时，它读取了 Vagrantfile，要求运行特定的盒子（Ubuntu Xenial）。如果你之前已添加过，它会通过默认的虚拟机管理程序（在这种情况下是
    VirtualBox）立即启动；如果是新的盒子，它会自动为你下载。它创建了所需的虚拟网络接口，然后 Ubuntu 虚拟机获得了一个私有 IP 地址。Vagrant
    负责配置 **SSH**，通过暴露一个可用的端口并插入默认密钥，这样你就可以通过 SSH 无问题地登录。
- en: Enabling VirtualBox Guest Additions in Vagrant
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Vagrant 中启用 VirtualBox 客户端附加组件
- en: The VirtualBox Guest Additions are a set of drivers and applications to be deployed
    on a virtual machine to have better performance and enable features such as folder
    sharing. While it's possible to include the **Guest Additions** directly in the
    box, not all the boxes you'll find have it, and even when they do, they can be
    outdated very quickly.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: VirtualBox Guest Additions 是一组驱动程序和应用程序，旨在部署到虚拟机中，以提高性能并启用诸如文件夹共享等功能。虽然可以将 **Guest
    Additions** 直接包含在 box 中，但并不是所有找到的 box 都包含它，即使有，也可能会很快过时。
- en: The solution is to automatically deploy the VirtualBox Guest Additions on demand,
    through a plugin.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是通过插件按需自动部署 VirtualBox Guest Additions。
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The downside to using this plugin is that the Vagrant box may now take longer
    to boot, as it may need to download and install the right guest additions for
    the box.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个插件的缺点是，Vagrant box 可能需要更长的时间来启动，因为它可能需要下载并安装正确的 Guest Additions。
- en: Getting ready
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To step through this recipe, you will need the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此食谱，你将需要以下内容：
- en: A working Vagrant installation
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的 Vagrant 安装
- en: A working VirtualBox installation
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的 VirtualBox 安装
- en: An internet connection
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个互联网连接
- en: The Vagrantfile from the previous recipe
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自上一食谱的 Vagrantfile
- en: How to do it…
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Follow these steps to enable VirtualBox Guest Additions in Vagrant:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在 Vagrant 中启用 VirtualBox Guest Additions：
- en: 'Install the `vagrant-vbguest` plugin:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `vagrant-vbguest` 插件：
- en: '[PRE7]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Confirm that the plugin is installed:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认插件已安装：
- en: '[PRE8]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Start Vagrant and see that the VirtualBox Guest Additions are installed:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Vagrant 并查看 VirtualBox Guest Additions 是否已安装：
- en: '[PRE9]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, maybe you don''t want to do this every time you start you Vagrant box,
    because it takes time and bandwidth or because the minor difference between your
    host VirtualBox version and the one already installed in the Vagrant box isn''t
    a problem for you. In this case, you can simply tell Vagrant to disable the auto-update
    feature right from the Vagrantfile:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，可能你不想每次启动 Vagrant box 时都做这个，因为它需要时间和带宽，或者因为你的宿主机 VirtualBox 版本和 Vagrant box
    中已经安装的版本之间的小差异对你来说不是问题。在这种情况下，你可以直接从 Vagrantfile 中告诉 Vagrant 禁用自动更新功能：
- en: '[PRE10]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'An even better way to keep your code compatible with people without this plugin
    is to use this plugin configuration only if the plugin is found by Vagrant itself:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持代码与没有安装此插件的人兼容的更好方法是，仅在 Vagrant 自身找到插件时才使用此插件配置：
- en: '[PRE11]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The full Vagrantfile now looks like this:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完整的 Vagrantfile 现在看起来是这样的：
- en: '[PRE12]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works…
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Vagrant plugins are automatically installed from the vendor's website, and made
    available globally on your system for all other Vagrant environments you'll run.
    Once the virtual machine is ready, the plugin will detect the operating system,
    decide if the Guest Additions need to be installed or not, and if they do, install
    the necessary tools to do that (compilers, kernel headers, and libraries), and
    finally download and install the corresponding Guest Additions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant 插件会自动从供应商的网站安装，并在你的系统上全局可用，供你运行的所有其他 Vagrant 环境使用。一旦虚拟机准备就绪，插件会检测操作系统，决定是否需要安装
    Guest Additions，如果需要，它将安装必要的工具（编译器、内核头文件和库），最后下载并安装相应的 Guest Additions。
- en: There's more…
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'Using Vagrant plugins also extends what you can do with the Vagrant CLI. In
    the case of the VirtualBox Guest Addition plugin, you can do a lot of things such
    as status checks, manage the installation, and much more:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Vagrant 插件还扩展了你可以通过 Vagrant CLI 做的事情。在 VirtualBox Guest Additions 插件的情况下，你可以做很多事情，如状态检查、管理安装等：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The plugin can later be called through Vagrant directly; here it''s triggering
    the Guest Additions installation in the virtual machine:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 该插件可以通过 Vagrant 直接调用；这里它触发了虚拟机中 Guest Additions 的安装：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using a disposable CentOS 7.x with VMware in seconds
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用一个一次性的 CentOS 7.x 版本和 VMware，几秒钟内即可完成
- en: Vagrant supports both VMware Workstation and VMware Fusion through official
    plugins available on the Vagrant store ([https://www.vagrantup.com/vmware](https://www.vagrantup.com/vmware)).
    Follow the indications from the official website to install the plugins.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant 支持通过 Vagrant 商店中的官方插件支持 VMware Workstation 和 VMware Fusion（[https://www.vagrantup.com/vmware](https://www.vagrantup.com/vmware)）。按照官网的说明安装插件。
- en: Vagrant boxes depend on the hypervisor—a VirtualBox image won't run on VMware.
    You need to use dedicated images for each supervisor you choose to use. For example,
    Ubuntu official releases only provide VirtualBox images. If you try to create
    a Vagrant box with a provider while using an image built for another provider,
    you'll get an error.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant 镜像依赖于虚拟化程序——VirtualBox 镜像不能在 VMware 上运行。你需要为每个你选择使用的虚拟化程序使用专门的镜像。例如，Ubuntu
    官方发布的镜像仅提供 VirtualBox 镜像。如果你尝试使用一个为另一虚拟化程序构建的镜像来创建 Vagrant 镜像，你将遇到错误。
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步执行此食谱，你将需要以下内容：
- en: A working Vagrant installation
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的 Vagrant 安装
- en: A working VMware Workstation (PC) or Fusion (Mac) installation
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的 VMware Workstation（PC）或 Fusion（Mac）安装
- en: A working Vagrant VMware plugin installation
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的 Vagrant VMware 插件安装
- en: An Internet connection
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个互联网连接
- en: How to do it…
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The Chef Bento project provides various multiprovider images we can use. For
    example, let''s use a CentOS 7.2 with Vagrant (bento/centos-7.2) with this simplest
    Vagrantfile:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Chef Bento 项目提供了多种多提供商镜像，我们可以使用。例如，使用这个最简单的 Vagrantfile 来运行 CentOS 7.2 与 Vagrant（bento/centos-7.2）：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Start your CentOS 7.2 virtual environment and specify the hypervisor you want
    to run:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 启动你的 CentOS 7.2 虚拟环境，并指定你要运行的虚拟化程序：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You're now running a CentOS 7.2 Vagrant box using VMware!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在正在使用 VMware 运行 CentOS 7.2 Vagrant 镜像！
- en: How it works…
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Vagrant is powered by plugins extending its usage and capabilities. In this
    case, the Vagrant plugin for VMware delegates all the virtualization features
    to the VMware installation, removing the need for VirtualBox.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant 通过插件扩展其使用和功能。在这种情况下，Vagrant 的 VMware 插件将所有虚拟化功能委托给 VMware 安装，从而不再需要
    VirtualBox。
- en: There's more…
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'If VMware is your primary hypervisor, you''ll soon be tired to always specify
    the provider in the command line. By setting the `VAGRANT_DEFAULT_PROVIDER` environment
    variable to the corresponding plugin, you will never have to specify the provider
    again, VMware will be the default:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 VMware 是你主要的虚拟化程序，你很快会厌倦每次都在命令行中指定提供商。通过将 `VAGRANT_DEFAULT_PROVIDER` 环境变量设置为对应的插件，你将再也无需指定提供商，VMware
    将成为默认：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: See also
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The Chef Bento Project at [http://chef.github.io/bento/](http://chef.github.io/bento/)
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chef Bento 项目，地址为 [http://chef.github.io/bento/](http://chef.github.io/bento/)
- en: A community VMware vSphere plugin at [https://github.com/nsidc/vagrant-vsphere](https://github.com/nsidc/vagrant-vsphere)
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个社区版的 VMware vSphere 插件，地址为 [https://github.com/nsidc/vagrant-vsphere](https://github.com/nsidc/vagrant-vsphere)
- en: A community VMware vCloud Director plugin at [https://github.com/frapposelli/vagrant-vcloud](https://github.com/frapposelli/vagrant-vcloud)
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个社区版的 VMware vCloud Director 插件，地址为 [https://github.com/frapposelli/vagrant-vcloud](https://github.com/frapposelli/vagrant-vcloud)
- en: A community VMware vCenter plugin at [https://github.com/frapposelli/vagrant-vcenter](https://github.com/frapposelli/vagrant-vcenter)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个社区版的 VMware vCenter 插件，地址为 [https://github.com/frapposelli/vagrant-vcenter](https://github.com/frapposelli/vagrant-vcenter)
- en: A community VMware vCloud Air plugin at [https://github.com/frapposelli/vagrant-vcloudair](https://github.com/frapposelli/vagrant-vcloudair)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个社区版的 VMware vCloud Air 插件，地址为 [https://github.com/frapposelli/vagrant-vcloudair](https://github.com/frapposelli/vagrant-vcloudair)
- en: Extending the VMware VM capabilities
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展 VMware 虚拟机功能
- en: 'The hardware specifications of the Vagrant box vary from image to image as
    they''re specified at the creation time. However, it''s not fixed forever: it''s
    just the default behavior. You can set the requirements right in the Vagrantfile,
    so you can keep a daily small Vagrant box and on-demand.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant 镜像的硬件规格因镜像而异，因为它们在创建时指定。然而，它并非永远固定：这只是默认行为。你可以在 Vagrantfile 中设置需求，以便保持一个小的
    Vagrant 镜像，并按需调整。
- en: Getting ready
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步执行此食谱，你将需要以下内容：
- en: A working Vagrant installation
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的 Vagrant 安装
- en: A working VMware Workstation (PC) or Fusion (Mac) installation
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的 VMware Workstation（PC）或 Fusion（Mac）安装
- en: A working Vagrant VMware plugin installation
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的 Vagrant VMware 插件安装
- en: An internet connection
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个互联网连接
- en: The Vagrantfile from the previous recipe using a bento/centos72 box
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 bento/centos72 镜像的 Vagrantfile，参见前面的食谱
- en: How to do it…
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The VMware provider can be configured inside the following configuration blocks:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: VMware 提供商可以在以下配置块中进行配置：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If the configuration is the same, you''ll end up with a lot of duplicated code.
    Take advantage of the Ruby nature of the Vagrantfile and use a simple loop to
    iterate through both values:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果配置相同，你将会有很多重复的代码。利用 Vagrantfile 的 Ruby 特性，使用一个简单的循环来迭代这两个值：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Our default Bento CentOS 7.2 image has only 512 MB of RAM and one CPU. Let''s
    double that for better performance using the `vmx["numvcpus"]` and `vmx["memsize"]`
    keys:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们默认的 Bento CentOS 7.2 镜像只有 512 MB 内存和一个 CPU。为了更好的性能，我们将通过 `vmx["numvcpus"]`
    和 `vmx["memsize"]` 键来将其翻倍：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Start or restart your Vagrant machine to apply the changes:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 启动或重启你的 Vagrant 虚拟机以应用更改：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Your box is now using two CPUs and 1 GB of RAM.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 box 现在使用了两个 CPU 和 1 GB 内存。
- en: How it works…
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Virtual machine configuration is the last thing done by Vagrant before starting
    up. Here, it just tells VMware to allocate two CPUs and 1 GB of RAM to the virtual
    machine it's launching the way you would have done manually from inside the software.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机配置是 Vagrant 启动前的最后一步。这里，它仅仅告诉 VMware 为它启动的虚拟机分配两个 CPU 和 1 GB 的内存，就像你在软件内部手动操作时所做的一样。
- en: There's more…
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Vagrant's authors may merge both plugins into one at some point in the future.
    The current 4.x version of the plugins is still split.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant 的作者可能会在未来某个时刻将这两个插件合并成一个。目前，插件的 4.x 版本仍然是分开的。
- en: The VMX format is not very well documented by VMware. The possible keys and
    values can be found on most VMware Inc. documentation about VMX configuration.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: VMware 对 VMX 格式的文档并不完善。有关 VMX 配置的可能键和值，可以在 VMware Inc. 的大多数文档中找到。
- en: Enabling multiprovider Vagrant environments
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用多提供商 Vagrant 环境
- en: You might be running VMware on your laptop, but your coworker might not. Alternatively,
    you want people to have the choice, or you simply want both environments to work!
    We'll see how to build a single Vagrantfile to support them all.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在笔记本上运行 VMware，但你的同事可能没有。或者，你希望大家可以选择，或者你只是希望两种环境都能工作！我们将看到如何构建一个单一的 Vagrantfile
    来支持它们所有。
- en: Getting ready
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照这个步骤进行，你需要以下内容：
- en: A working Vagrant installation
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的 Vagrant 安装
- en: A working VirtualBox installation
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的 VirtualBox 安装
- en: A working VMware Workstation (PC) or Fusion (Mac) installation
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的 VMware Workstation（PC）或 Fusion（Mac）安装
- en: A working Vagrant VMware plugin installation
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的 Vagrant VMware 插件安装
- en: An internet connection
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条互联网连接
- en: The Vagrantfile from the previous recipe using a bento/centos72 box
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 bento/centos72 box 的上一个配方中的 Vagrantfile
- en: How to do it…
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Some Vagrant boxes are available for multiple hypervisors, such as the CentOS
    7 Bento box we previously used. This way, we can simply choose which one to use.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Vagrant box 可以用于多个虚拟化平台，例如我们之前使用的 CentOS 7 Bento box。这样，我们可以简单地选择使用哪个。
- en: 'Let''s start with our previous Vagrantfile including customizations for VMware:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们之前的 Vagrantfile 开始，其中包含了对 VMware 的自定义配置：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'How would we add the same configuration on VirtualBox as we have on VMware?
    Here''s how to customize VirtualBox similarly in the Vagrantfile:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在 VirtualBox 上添加与 VMware 相同的配置？以下是在 Vagrantfile 中类似地自定义 VirtualBox 的方法：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Add this to your current Vagrantfile, reload and you'll get the requested resources
    from your hypervisor, be it VMware or VirtualBox.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 将此添加到你当前的 Vagrantfile，重新加载后，你将从你的虚拟化平台（无论是 VMware 还是 VirtualBox）获取所请求的资源。
- en: 'It''s nice, but we''re still repeating ourselves with the values, leading to
    possible errors, omissions, or mistakes in the future. Let''s take advantage once
    again of the Ruby nature of our Vagrantfile and declare some meaningful variables
    at the top of our file:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但我们仍然在重复使用这些值，未来可能会导致错误、遗漏或问题。让我们再次利用 Vagrantfile 的 Ruby 特性，在文件的顶部声明一些有意义的变量：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now replace the four values by their variable names and you''re done: you''re
    centrally managing characteristics of the Vagrant environment you''re using and
    distributing, whatever hypervisor you''re using.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将四个值替换为它们的变量名，你就完成了：你正在集中管理你所使用和分发的 Vagrant 环境的特性，无论你使用的是哪个虚拟化平台。
- en: How it works…
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The simple fact that the Vagrantfile is a pure Ruby file helps creating powerful
    and dynamic configuration, by simply setting variables that we use later for all
    the providers.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrantfile 作为纯 Ruby 文件这一事实，有助于通过简单地设置变量来创建强大而动态的配置，后续可以在所有提供商中使用这些变量。
- en: Customizing a Vagrant VM
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义 Vagrant 虚拟机
- en: Vagrant supports many configuration options through the Vagrantfile. Here are
    the most useful ones for daily use.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant 通过 Vagrantfile 支持许多配置选项。以下是日常使用中最有用的一些。
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照这个步骤进行，你需要以下内容：
- en: A working Vagrant installation (with a hypervisor)
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的 Vagrant 安装（带有虚拟化平台）
- en: An Internet connection
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条互联网连接
- en: The Vagrantfile from the previous recipe using a bento/centos72 box
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 bento/centos72 box 的上一个配方中的 Vagrantfile
- en: How to do it…
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: Here are some possible customizations for your Vagrant Virtual Machine.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可能的 Vagrant 虚拟机自定义选项。
- en: Set the hostname
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置主机名
- en: 'If you want to specify the VM name right from Vagrant, just add the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想直接从 Vagrant 指定虚拟机名称，只需添加以下内容：
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will also add an entry with the hostname to the `/etc/host` file.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这还将向 `/etc/host` 文件中添加一个包含主机名的条目。
- en: Disable new box version check at startup
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 禁用启动时的新盒子版本检查
- en: 'You may be using a slow internet connection, or you know you do want to use
    your current installed box, or maybe you''re in a hurry and just want to get the
    job done; you can just remove the option to check for a new version of the box
    at startup by adding the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能正在使用较慢的互联网连接，或者你知道你确实想使用当前安装的盒子，或者你可能很急，只想完成工作；你可以通过添加以下内容，去除启动时检查新版本盒子的选项：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Use a specific box version
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用特定的盒子版本
- en: 'If you know you want to use a specific version of the box (maybe for debugging
    purposes or compliance) and not the latest, you can simply declare it as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道自己想使用某个特定版本的盒子（可能出于调试目的或合规性需求），而不是最新版本，你可以简单地按如下方式声明：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Display an informational message to the user
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向用户显示信息性消息
- en: 'A useful feature is to display some basic but relevant information to the user
    launching the Vagrant box, such as usage or connection information. Don''t forget
    to escape the special characters. As it''s Ruby, you can access all available
    variables, so the message can be even more dynamic and useful to the user:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的功能是向启动 Vagrant 盒子的用户显示一些基本但相关的信息，比如使用说明或连接信息。别忘了转义特殊字符。由于这是 Ruby，你可以访问所有可用的变量，因此信息可以变得更加动态并对用户更有用：
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Specify a minimum Vagrant version
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定最低 Vagrant 版本
- en: 'Vagrant is updated quite often, and new features are added regularly. A good
    practice, if you use a feature that is known to work only after a specific version,
    is to declare it in the Vagrantfile, so people with an older version know they
    have to update:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant 经常更新，并定期添加新功能。如果你使用了一个已知只有在特定版本之后才能正常工作的功能，最好在 Vagrantfile 中声明，以便使用旧版本的人知道他们需要更新：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using Docker with Vagrant
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Vagrant 中使用 Docker
- en: Development environments can often be mixed, using both virtual machines and
    Docker containers. While virtual machines include everything needed to run a full
    operating system like memory, CPU, a kernel and all required libraries, a container
    is much more lightweight and can share all this with its host, while keeping a
    good isolation through special kernel features named cgroups. Docker containers
    helps developers use, share and ship a *bundle* including everything needed to
    run their application. Here, we'll show how to use Vagrant to start containers.
    Since Docker usage is a little different between Linux hosts and other platforms,
    the reference used here is the native Docker platform—Linux.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 开发环境通常会混合使用虚拟机和 Docker 容器。虚拟机包含运行完整操作系统所需的所有内容，如内存、CPU、内核和所有必需的库，而容器则更加轻量，可以与宿主机共享所有这些资源，同时通过名为
    cgroups 的特殊内核功能保持良好的隔离。Docker 容器帮助开发者使用、共享和发布一个包含运行应用程序所需的一切的*包*。在这里，我们将展示如何使用
    Vagrant 启动容器。由于 Docker 在 Linux 主机和其他平台上的使用略有不同，本文所参考的是原生 Docker 平台——Linux。
- en: Getting ready
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步执行这个过程，你将需要以下内容：
- en: A working Vagrant installation (no hypervisor needed)
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个工作正常的 Vagrant 安装（无需虚拟化管理程序）
- en: A working Docker installation and basic Docker knowledge
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个工作正常的 Docker 安装和基本的 Docker 知识
- en: An Internet connection
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个互联网连接
- en: How to do it…
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: We'll see how to use, access, and manipulate an NGINX container in Vagrant using
    Docker as a provider.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何使用 Docker 作为提供者，在 Vagrant 中使用、访问和操作一个 NGINX 容器。
- en: Using NGINX Docker container through Vagrant
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 Vagrant 使用 NGINX Docker 容器
- en: 'Let''s start with the simplest Vagrantfile possible, using the `nginx:stable`
    container with the Docker Vagrant provider:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 从最简单的 Vagrantfile 开始，使用 `nginx:stable` 容器与 Docker Vagrant 提供者：
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Simply start it up with the following code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 只需使用以下代码启动它：
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s remove the need to specify the provider on the command line by setting
    a simple Ruby environment access code at the top of the Vagrantfile:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 Vagrantfile 顶部设置一个简单的 Ruby 环境访问代码，来消除在命令行中指定提供者的需求：
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now you can distribute your Vagrantfile and not worry about people forgetting
    to explicitly specify the Docker provider.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以分发你的 Vagrantfile，而不必担心别人忘记明确指定 Docker 提供者。
- en: Exposing Docker ports in Vagrant
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Vagrant 中暴露 Docker 端口
- en: 'Okay, the previous example wasn''t terribly useful as we didn''t expose any
    ports. Let''s tell Vagrant to expose the Docker container HTTP (TCP/80) port to
    our host''s HTTP (TCP/80) port:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，之前的示例并不太有用，因为我们没有暴露任何端口。现在让我们告诉Vagrant暴露Docker容器的HTTP（TCP/80）端口到主机的HTTP（TCP/80）端口：
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Restart the Vagrant and verify you can access your NGINX container:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 重启Vagrant并验证你是否能访问到你的NGINX容器：
- en: '[PRE34]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Sharing folders with Docker through Vagrant
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过Vagrant共享Docker文件夹
- en: What about sharing a local folder so you can code on your laptop and see the
    result processed by the Vagrant environment? The default NGINX configuration reads
    files from `/usr/share/nginx/html`. Let's put our own `index.html` in there.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果共享一个本地文件夹，让你可以在笔记本上编码并查看Vagrant环境处理后的结果呢？默认的NGINX配置会从`/usr/share/nginx/html`读取文件。我们把自己的`index.html`放在这里。
- en: 'Create a simple `src/index.html` file, containing some text:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个简单的`src/index.html`文件，包含一些文本：
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add the Docker volume configuration to our Docker provider block in Vagrant:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 将Docker卷配置添加到Vagrant中的Docker提供者块：
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`#{Dir.pwd}` is the Ruby for finding the current directory, so you don''t hardcode
    paths, making it highly distributable.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`#{Dir.pwd}`是Ruby中用于查找当前目录的命令，使用它可以避免硬编码路径，使得代码具有很好的可分发性。'
- en: 'Restart the Vagrant environment and see the result:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 重启Vagrant环境并查看结果：
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'On SELinux-enabled systems you may need to do some configuration that''s beyond
    the scope of this book. We encourage you to secure your Docker systems using SELinux,
    but to disable SELinux just type the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用了SELinux的系统上，你可能需要做一些配置，这超出了本书的范围。我们鼓励你使用SELinux来确保Docker系统的安全，但要禁用SELinux，只需键入以下命令：
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There's more…
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'You can choose not to use your local or default Docker installation, but instead
    use a dedicated VM, maybe to reflect production or a specific OS (such as CoreOS).
    In this case, you can specify a dedicated Vagrantfile as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择不使用本地或默认的Docker安装，而是使用专用的虚拟机，也许是为了模拟生产环境或特定的操作系统（例如CoreOS）。在这种情况下，你可以像下面这样指定一个专用的Vagrantfile：
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Using Docker in Vagrant for a Ghost blog behind NGINX
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Vagrant中使用Docker为NGINX后面的Ghost博客提供服务
- en: Vagrant in Docker can be used more usefully to simulate traditional setups such
    as an application behind a load balancer or a reverse proxy. We've already set
    up NGINX, so what about using it as a front reverse proxy with a blog engine such
    as Ghost behind it? We'll end up by showing how to do something similar with docker-compose.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker中使用Vagrant可以更有效地模拟传统的设置，比如应用程序后面有负载均衡器或反向代理。我们已经设置了NGINX，那么可以用它作为前端反向代理，并将像Ghost这样的博客引擎放在后面吗？我们最后将展示如何使用docker-compose做类似的事情。
- en: Getting ready
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行这个操作，你需要以下条件：
- en: A working Vagrant installation (no hypervisor needed)
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的Vagrant安装（不需要虚拟化管理程序）
- en: A working Docker installation and basic Docker knowledge
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的Docker安装和基本的Docker知识
- en: An Internet connection
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个互联网连接
- en: How to do it…
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The previous example allows only one container to be launched simultaneously,
    which is sad considering the power of Docker. Let''s define multiple containers
    and start by creating a `front` container (our previous NGINX):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例只允许启动一个容器，这有点遗憾，因为Docker的强大之处就在于可以运行多个容器。让我们定义多个容器，并从创建一个`front`容器（我们之前的NGINX）开始：
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now how about creating an application container, maybe a blog engine such as
    Ghost? Ghost publishes a ready-to-use container on the Docker Hub, so let''s use
    that (version 0.9.0 at the time of writing) and expose on TCP/8080 the application
    container listening on TCP/2368:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如何创建一个应用程序容器呢，也许是像Ghost这样的博客引擎？Ghost在Docker Hub上发布了一个现成的容器，所以我们就使用它（本文写作时为版本0.9.0），并将TCP/2368上监听的应用程序容器暴露到TCP/8080上：
- en: '[PRE41]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Check if you can access the blog on `http://localhost:8080` and NGINX on `http://localhost`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 检查是否可以在`http://localhost:8080`访问博客，在`http://localhost`访问NGINX：
- en: '[PRE42]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now let''s use NGINX for what it''s for—serving the application. Configuring
    NGINX as a reverse proxy is beyond the scope of this book, so just use the following
    simple configuration for the `nginx.conf` file at the root of your working folder:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用NGINX来实现它的目的——为应用程序提供服务。配置NGINX作为反向代理超出了本书的范围，所以只需使用以下简单配置，将其保存为工作文件夹根目录下的`nginx.conf`文件：
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Change the configuration of the `front` container in Vagrant to use this configuration,
    remove the old `index.html` as we''re not using it anymore, and link this container
    to the `app` container:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 更改Vagrant中`front`容器的配置，使用这个配置，删除旧的`index.html`，因为我们不再使用它，并将此容器与`app`容器连接：
- en: '[PRE44]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Linking the `app` container makes it available to the `front` container, so
    now there''s no need to expose the Ghost blog container directly, let''s make
    it simpler and more secure behind the reverse proxy:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 链接`app`容器使其可以被`front`容器访问，因此现在无需直接暴露Ghost博客容器，让我们通过反向代理将其变得更加简洁和安全：
- en: '[PRE45]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We''re close! But this setup will eventually fail for a simple reason: our
    systems are too fast, and Vagrant parallelizes the startup of virtual machines
    by default, and also does this for containers. Containers start so fast that the
    `app` container may not be ready for NGINX when it''s started. To ensure sequential
    startup, use the `VAGRANT_NO_PARALLEL` environment variable at the top of the
    Vagrantfile:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快完成了！但是这个设置最终会失败，原因很简单：我们的系统太快了，Vagrant默认会并行启动虚拟机，也会并行启动容器。容器启动得太快，以至于`app`容器可能在NGINX启动时还没有准备好。为了确保顺序启动，请在Vagrantfile顶部使用`VAGRANT_NO_PARALLEL`环境变量：
- en: '[PRE46]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now you can browse to `http://localhost/admin` and start using your Ghost blog
    in a container, behind a NGINX reverse proxy container, with the whole thing managed
    by Vagrant!
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以浏览到`http://localhost/admin`并开始使用你在容器中的Ghost博客，它位于NGINX反向代理容器后面，整个过程由Vagrant管理！
- en: There's more…
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'You can access the containers logs directly using Vagrant:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过Vagrant直接访问容器日志：
- en: '[PRE47]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: A Docker Compose equivalent
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker Compose等效方式
- en: 'Docker Compose is a tool to orchestrate multiple containers and manage Docker
    features from a single YAML file. So if you''re more familiar with Docker Compose,
    or if you''d like to do something similar with this tool, here''s what the code
    would look like in the `docker-compose.yml` file:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose是一个工具，用于从单一的YAML文件编排多个容器并管理Docker功能。所以如果你更熟悉Docker Compose，或者你希望用这个工具做类似的事情，以下是`docker-compose.yml`文件中的代码：
- en: '[PRE48]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that with Vagrant, you can mix virtual machines and Docker containers,
    while you can't with docker-compose.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，使用Vagrant，你可以混合虚拟机和Docker容器，而使用docker-compose则不行。
- en: Using Vagrant remotely with AWS EC2 and Docker
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vagrant远程连接AWS EC2和Docker
- en: 'Another powerful usage of Vagrant can be with remote IaaS resources such as
    Amazon EC2\. Amazon Web Services Elastic Compute Cloud (EC2) and similar Infrastructure-as-a-Service
    providers like Google Cloud, Azure or Digital Ocean, to name a few, are selling
    virtual machines with varying compute power and network bandwidth for a fee. You
    don''t always have all the necessary CPU and memory you need on your laptop, or
    you need to have some specific computing power for a task, or you just want to
    replicate part of an existing production environment: here''s how you can leverage
    the power of Vagrant using Amazon EC2.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant的另一个强大用法是与远程IaaS资源结合使用，如Amazon EC2。Amazon Web Services弹性计算云（EC2）和类似的基础设施即服务提供商，如Google
    Cloud、Azure或Digital Ocean等，出售具有不同计算能力和网络带宽的虚拟机。你不一定总是能在你的笔记本上获得所需的全部CPU和内存，或者你需要为某个任务提供特定的计算能力，或者你只是想复制现有生产环境的一部分：这是你如何利用Vagrant与Amazon
    EC2结合使用的方式。
- en: Here, we'll deploy a Ghost blog with an NGINX reverse proxy, all on Docker,
    using an Ubuntu Xenial 16.04 on AWS EC2! This is to simulate a real deployment
    of an application, so you can see if it is working in real conditions.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将在AWS EC2上使用Ubuntu Xenial 16.04和Docker部署一个带有NGINX反向代理的Ghost博客！这是为了模拟应用程序的实际部署，这样你就可以看到它在真实条件下是否能正常工作。
- en: Getting ready
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照这个教程操作，你需要以下内容：
- en: A working Vagrant installation (no hypervisor needed)
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的Vagrant安装（不需要虚拟化管理程序）
- en: An Amazon EC2 account (or create one for free at [https://aws.amazon.com/](https://aws.amazon.com/)
    if you don't have one already), with valid Access Keys, a keypair named *iac-lab*,
    a security group named *iac-lab* allowing at least HTTP ports, and SSH access.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Amazon EC2账户（如果你还没有，可以在[https://aws.amazon.com/](https://aws.amazon.com/)免费创建一个），需要有效的访问密钥、名为*iac-lab*的密钥对、一个名为*iac-lab*的安全组，允许至少HTTP端口和SSH访问。
- en: An Internet connection
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要一个互联网连接
- en: How to do it…
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Begin by installing the plugin:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 首先安装插件：
- en: '[PRE49]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'A requirement of this plugin is the presence of a dummy Vagrant box that does
    nothing:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这个插件的一个要求是必须有一个什么都不做的虚拟Vagrant box：
- en: '[PRE50]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Remember how we configured the Docker provider in the previous recipes? This
    is no different:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在前面的教程中如何配置Docker提供者吗？这没什么不同：
- en: '[PRE51]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Then, defining an application VM will consist of specifying which provider it's
    using (AWS in our case), the **Amazon Machine Image** (**AMI**) (Ubuntu 16.04
    LTS in our case), and a provisioning script that we creatively named `script.sh`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，定义一个应用程序虚拟机，将包括指定其使用的提供商（在我们这里是 AWS）、**Amazon 机器映像**（**AMI**）（在我们这里是 Ubuntu
    16.04 LTS），以及一个我们创意命名为 `script.sh` 的配置脚本。
- en: 'You can find other AMI IDs at [http://cloud-images.ubuntu.com/locator/ec2/](http://cloud-images.ubuntu.com/locator/ec2/):'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [http://cloud-images.ubuntu.com/locator/ec2/](http://cloud-images.ubuntu.com/locator/ec2/)
    找到其他 AMI ID：
- en: '[PRE52]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: So what is the AWS-related information we need to fill in so Vagrant can launch
    servers on AWS?
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们需要填写哪些与 AWS 相关的信息，以便 Vagrant 能够在 AWS 上启动服务器呢？
- en: 'We need the AWS Access Keys, preferably from environment variables so you don''t
    hardcode them in your Vagrantfile:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要 AWS 访问密钥，最好从环境变量中获取，这样就不需要在 Vagrantfile 中硬编码它们：
- en: '[PRE53]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Indicate the region and availability zone where you want the instance to start:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 指定您希望实例启动的区域和可用区：
- en: '[PRE54]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Include the instance type; here, we''ve chosen the one included in the AWS
    free tier plan so it won''t cost you a dime with a new account:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 包括实例类型；在这里，我们选择了 AWS 免费套餐中包含的类型，因此在新帐户下不会花费您一分钱：
- en: '[PRE55]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Indicate in which security group this instance will live (it''s up to you to
    adapt the requirements to your needs):'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 指定此实例将所在的安全组（您可以根据需要调整要求）：
- en: '[PRE56]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Specify the AWS keypair name, and override the default SSH username and keys:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 指定 AWS 密钥对名称，并覆盖默认的 SSH 用户名和密钥：
- en: '[PRE57]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Under some circumstances, you can experience a bug with NFS while using Vagrant
    and AWS EC2, so I choose to disable this feature:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，使用 Vagrant 和 AWS EC2 时，可能会遇到 NFS 的 bug，因此我选择禁用此功能：
- en: '[PRE58]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, it''s a good practice to tag the instances, so you can later find
    out where they come from:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为实例打标签是一个好习惯，这样您以后就能查找它们的来源：
- en: '[PRE59]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Add a simple shell script that will install Docker and `docker-compose`, then
    execute the docker-compose file:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个简单的 shell 脚本来安装 Docker 和 `docker-compose`，然后执行 docker-compose 文件：
- en: '[PRE60]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Include both NGINX configuration and `docker-compose.yml` files from the previous
    recipe and you''re good to go:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 包含前面配方中的 NGINX 配置和 `docker-compose.yml` 文件，您就可以开始了：
- en: '[PRE61]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Open your browser at `http://a.b.c.d/` (using the EC2 instance public IP) and
    you'll see your Ghost blog behind an NGINX reverse proxy, using Docker containers,
    using Vagrant on Amazon EC2.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器并访问 `http://a.b.c.d/`（使用 EC2 实例的公网 IP），您将看到 Ghost 博客通过 NGINX 反向代理在 Docker
    容器中运行，使用 Vagrant 在 Amazon EC2 上部署。
- en: A common usage for such a setup is for the developer to test the application
    in close to real production conditions, maybe to show a new feature to a remote
    product owner, replicate a bug seen only in this setup, or at some point in the
    CI. Once Docker containers have been built, smoke test them on EC2 before going
    any further.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置的常见用途是让开发人员在接近真实生产环境的条件下测试应用程序，可能是向远程产品经理展示新功能，复制仅在此设置中出现的 bug，或者在某个 CI
    阶段进行测试。一旦构建了 Docker 容器，可以在 EC2 上进行烟雾测试，然后再继续其他操作。
- en: Simulating dynamic multiple host networking
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟动态的多个主机网络
- en: Vagrant is also very useful when used to simulate multiple hosts in a network.
    This way you can have full systems able to talk to each other in the same private
    network and easily test connectivity between systems.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当用于模拟网络中的多个主机时，Vagrant 也非常有用。这样，您可以在同一个私有网络中拥有能够相互通信的完整系统，轻松测试系统间的连接性。
- en: Getting ready
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备开始
- en: 'To step through this recipe, you will need the following:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步完成此配方，您需要以下内容：
- en: A working Vagrant installation
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的 Vagrant 安装
- en: A working VirtualBox installation
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的 VirtualBox 安装
- en: An Internet connection
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个互联网连接
- en: How to do it…
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点……
- en: 'Here''s how we would create one CentOS 7.2 machine with 512 MB of RAM and one
    CPU, in a private network with a fixed IP 192.168.50.11, and a simple shell output:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何创建一个 CentOS 7.2 虚拟机，配置 512 MB 内存和一个 CPU，位于私有网络并使用固定 IP 地址 192.168.50.11，输出一个简单的
    shell：
- en: '[PRE62]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'To add a new machine to this network, we could simply duplicate the `srv-1`
    machine definition, as in the following code:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要向该网络添加新机器，我们可以简单地复制 `srv-1` 机器定义，如下所示：
- en: '[PRE63]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: That's not very DRY, so let's take advantage of the Ruby nature of the Vagrantfile
    to create a loop that will dynamically and simply create as many virtual machines
    as we want.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是很符合 DRY 原则，所以让我们利用 Vagrantfile 的 Ruby 特性创建一个循环，动态且简洁地创建我们需要的虚拟机数量。
- en: 'First, declare a variable with the amount of virtual machines we want (`2`):'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，声明一个变量来指定我们想要的虚拟机数量（`2`）：
- en: '[PRE64]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then iterate through that value, so it can generate values for an IP and for
    a hostname:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 然后遍历该值，以生成IP和主机名的值：
- en: '[PRE65]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This will create two virtual machines (`srv-1` at `192.168.50.11` and `srv-2`
    at `192.168.50.12`) on the same internal network, so they can talk to each other.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建两个虚拟机（`srv-1`的IP为`192.168.50.11`，`srv-2`的IP为`192.168.50.12`）在同一内部网络中，这样它们就可以互相通信。
- en: Now you can simply change the value of `vm_num` and you'll easily spawn new
    virtual machines in seconds.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你只需简单地更改`vm_num`的值，就能轻松在几秒钟内启动新的虚拟机。
- en: There's more…
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: We can optionally go even further, using the following cloning and networking
    features.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以选择进一步扩展，使用以下克隆和网络功能。
- en: Speed up deployments with linked clones
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过链接克隆加速部署
- en: Linked clones is a feature that enables new VMs to be created based on an initial
    existing disk image, without the need to duplicate everything. Each VM stores
    only its delta state, allowing very fast virtual machines boot times.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 链接克隆是一个特性，允许基于现有的磁盘映像创建新的虚拟机，而不需要重复所有内容。每个虚拟机只存储其增量状态，从而实现非常快速的虚拟机启动时间。
- en: 'As we''re launching many machines, you can optionally enable linked clones
    to speed things up:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们启动了多个虚拟机，你可以选择启用链接克隆以加速过程：
- en: '[PRE66]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Using named NAT networks
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用命名的NAT网络
- en: VirtualBox has the option to let you define your own networks for further reference
    or reuse. Configure them under **Preferences** | **Network** | **NAT Networks**.
    Luckily, Vagrant can work with those named NAT networks too. To test the feature,
    you can create in VirtualBox a network (like iac-lab) and assign it the network
    `192.168.50.0/24`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: VirtualBox提供了一个选项，让你定义自己的网络以便进一步参考或重用。你可以在**首选项** | **网络** | **NAT网络**下进行配置。幸运的是，Vagrant也可以与这些命名的NAT网络一起使用。为了测试此功能，你可以在VirtualBox中创建一个网络（如iac-lab），并将其分配给网络`192.168.50.0/24`。
- en: 'Just change the network configuration from the preceding Vagrantfile to launch
    the VMs in this specific network:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 只需更改前面Vagrantfile中的网络配置，即可在此特定网络中启动虚拟机：
- en: '[PRE67]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Simulating a networked three-tier architecture app with Vagrant
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vagrant模拟一个网络化的三层架构应用
- en: Vagrant is a great tool to help simulate systems in isolated networks, allowing
    us to easily mock architectures found in production. The idea behind the multiple
    tiers is to separate the logic and execution of the various elements of the application,
    and not centralize everything in one place. A common pattern is to get a first
    layer that gets the common user requests, a second layer that does the application
    job, and a third layer that stores and retrieves data, usually from a database.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant是一个非常棒的工具，可以帮助模拟孤立网络中的系统，使我们能够轻松地模拟生产环境中的架构。多层架构的核心理念是将应用程序的不同元素的逻辑和执行分开，而不是将所有内容集中在一个地方。常见的模式是首先获取一个处理常见用户请求的层，第二层执行应用程序的任务，第三层存储和检索数据，通常是从数据库中获取。
- en: 'In this simulation, we''ll have the traditional three tiers, each running CentOS
    7 virtual machines on their own isolated network:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模拟中，我们将使用传统的三层架构，每一层都在自己的独立网络上运行CentOS 7虚拟机：
- en: '**Front**: NGINX reverse proxy'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前端**：NGINX反向代理'
- en: '**App**: a Node.js app running on two nodes'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用**：一个在两个节点上运行的Node.js应用'
- en: '**Database**: Redis'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库**：Redis'
- en: '| Virtual Machine Name | front_lan IP | app_lan IP | db_lan IP |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| 虚拟机名称 | front_lan IP | app_lan IP | db_lan IP |'
- en: '| --- | --- | --- | --- |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| front-1 | 10.10.0.11/24 | 10.20.0.101/24 | N/A |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| front-1 | 10.10.0.11/24 | 10.20.0.101/24 | N/A |'
- en: '| app-1 | N/A | 10.20.0.11/24 | 10.30.0.101/24 |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| app-1 | N/A | 10.20.0.11/24 | 10.30.0.101/24 |'
- en: '| app-2 | N/A | 10.20.0.12/24 | 10/30.0.102/24 |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| app-2 | N/A | 10.20.0.12/24 | 10/30.0.102/24 |'
- en: '| db-1 | N/A | N/A | 10.30.0.11/24 |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| db-1 | N/A | N/A | 10.30.0.11/24 |'
- en: You will access the reverse proxy (NGINX), which alone can contact the application
    server (Node.js), which is the only one to be able to connect to the database.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 你将访问反向代理（NGINX），只有它能够与应用服务器（Node.js）进行通信，而应用服务器则是唯一能够连接到数据库的。
- en: Getting ready
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个步骤，你需要以下内容：
- en: A working Vagrant installation
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的Vagrant安装
- en: A working VirtualBox installation
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的VirtualBox安装
- en: An Internet connection
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条互联网连接
- en: How to do it…
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: Follow these steps for simulating a networked three-tier architecture app with
    Vagrant.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用Vagrant模拟一个网络化的三层架构应用。
- en: Tier 3 – the database
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第三层 – 数据库
- en: The database lives in a db_lan private network with the IP 10.30.0.11/24.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库位于一个名为db_lan的私有网络中，IP地址为10.30.0.11/24。
- en: 'This application will use a simple Redis installation. Installing and configuring
    Redis is beyond the scope of this book, so we''ll keep it as simple as possible
    (install it, configure it to listen on the LAN port instead of 127.0.0.1, and
    start it):'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序将使用一个简单的Redis安装。安装和配置Redis超出了本书的范围，因此我们将尽量简化（安装它，配置它监听局域网端口而不是127.0.0.1，并启动它）：
- en: '[PRE68]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Tier 2: the application servers'
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二级：应用程序服务器
- en: This tier is where our application lives, backed by an application (web) server.
    The application can connect to the database tier, and will be available to the
    end user through tier 1 proxy servers. This is usually where all the logic is
    done (by the application).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层是我们应用程序所在的地方，背后是一个应用程序（Web）服务器。该应用程序可以连接到数据库层，并通过第一级代理服务器提供给最终用户。通常这就是应用程序完成所有逻辑处理的地方。
- en: The Node.js application
  id: totrans-357
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Node.js应用程序
- en: This will be simulated with the simplest Node.js code I could produce to demonstrate
    the usage, displaying the server hostname (the filename is `app.js`).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过我能够编写的最简单的Node.js代码来模拟，展示服务器主机名（文件名为`app.js`）。
- en: 'First, it creates a connection to the Redis server on the `db_lan` network:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它将在`db_lan`网络上创建与Redis服务器的连接：
- en: '[PRE69]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Then if it goes well, it creates an HTTP server listening on `:8080`, displaying
    the server''s hostname:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，它将创建一个在`:8080`上监听的HTTP服务器，显示服务器的主机名：
- en: '[PRE70]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Start the app, the simplest of the `systemd` service file (`systemd` unit files
    are out of the scope of this book):'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序，这是最简单的`systemd`服务文件（`systemd`单元文件不在本书讨论范围内）：
- en: '[PRE71]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Let''s iterate through the deployment of a number of application servers (in
    this case: two) to serve the app. Once again, deploying Node.js applications is
    out of the scope of this book, so I kept it as simple as possible—simple directories
    and permissions creation and systemd unit deployment. In production, this would
    probably be done through a configuration management tool such as Chef or Ansible
    and maybe coupled with a proper deployment tool:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步部署若干个应用程序服务器（在本例中为两个），以提供应用程序服务。再次强调，部署Node.js应用程序不在本书的讨论范围内，因此我尽量简化了——仅创建简单的目录和权限，并部署systemd单元。在生产环境中，这通常会通过像Chef或Ansible这样的配置管理工具来完成，并可能结合适当的部署工具：
- en: '[PRE72]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Tier 1: the NGINX reverse proxy'
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一级：NGINX反向代理
- en: 'Tier 1 is represented here by an NGINX reverse proxy configuration on CentOS
    7, as simple as it could be for this demo. Configuring an NGINX reverse proxy
    with a pool of servers is out of the scope of this book:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 第一级在这里由CentOS 7上的NGINX反向代理配置表示，尽可能简单，以适应本次演示。配置一个带有服务器池的NGINX反向代理超出了本书的讨论范围：
- en: '[PRE73]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now let''s create the reverse proxy VM that will serve `http://localhost:8080`
    through the pool of application servers. This VM listens on 10.10.0.11/24 on its
    own LAN (`front_lan`), and on `10.20.0.101`/`24` on the application servers''
    LAN (`app_lan`):'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个反向代理虚拟机，通过应用程序服务器池提供`http://localhost:8080`。这台虚拟机在自己的局域网（`front_lan`）上监听`10.10.0.11/24`，在应用程序服务器的局域网（`app_lan`）上监听`10.20.0.101/24`：
- en: '[PRE74]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Start this up (`vagrant up`) and navigate to `http://localhost:8080`, where
    the app displays the application server hostname so you can confirm that the load
    balancing across networks is working (while application servers can talk to the
    Redis backend).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 启动它（`vagrant up`），并导航到`http://localhost:8080`，在该页面上，应用程序显示应用服务器主机名，你可以确认跨网络的负载均衡是否正常工作（同时应用服务器能够与Redis后端通信）。
- en: Showing your work on the LAN while working with Laravel
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在使用Laravel时展示你的工作
- en: You're working on your application using Laravel, the free and open source PHP
    framework (https://laravel.com/), and you'd like to showcase your work to your
    colleagues. Using a Vagrant development environment can help keep your work machine
    clean and allow you to use your usual tools and editors while using an infrastructure
    close to production.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在使用Laravel框架（一个免费开源的PHP框架，https://laravel.com/）开发应用程序，并且想向你的同事展示你的工作。使用Vagrant开发环境可以帮助你保持工作机的整洁，并允许你使用常用工具和编辑器，同时使用接近生产环境的基础设施。
- en: In this example, we'll deploy a CentOS 7 server, with NGINX, PHP-FPM, and MariaDB,
    all the PHP dependencies, and install Composer. You can build from this example
    and others in this book to create an environment that mimics production (three-tier,
    multiple machines, and other characteristics).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将部署一台CentOS 7服务器，安装NGINX、PHP-FPM和MariaDB，所有PHP依赖项，并安装Composer。你可以从这个示例和本书中的其他示例中构建一个模拟生产环境的环境（三层架构、多台机器和其他特征）。
- en: This environment will be available for access to all your coworkers on your
    network, and the code will be accessible to you locally.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这个环境将对您网络中的所有同事开放，并且代码对您本地可访问。
- en: Getting ready
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To step through this recipe, you will need the following:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 要按步骤完成此教程，您需要以下内容：
- en: A working Vagrant installation
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的 Vagrant 安装
- en: A working VirtualBox or VMware installation
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的 VirtualBox 或 VMware 安装
- en: An Internet connection
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个互联网连接
- en: How to do it…
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Let''s start with the simplest Vagrant environment we know:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的 Vagrant 环境开始：
- en: '[PRE75]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: A sample NGINX configuration for Laravel
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个适用于 Laravel 的示例 NGINX 配置
- en: 'Configuring NGINX for Laravel is out of the scope for this book, but for reference,
    here''s a simple NGINX configuration that will work well for us, listening on
    HTTP, serving files located on `/srv/app/public`, and using PHP-FPM (the file
    name is `nginx.conf`):'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 NGINX 以支持 Laravel 超出了本书的范围，但作为参考，这里有一个简单的 NGINX 配置，它能很好地支持我们，监听 HTTP，服务文件位于`/srv/app/public`，并使用
    PHP-FPM（文件名为`nginx.conf`）：
- en: '[PRE76]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Simple shell provisioning
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单的 Shell 配置
- en: 'We''ll create a provisioning script that we''ll name as `provision.sh`, which
    contains all the steps we need to have a fully working Laravel environment. The
    details are out of the scope of this book, but here are the steps:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`provision.sh`的配置脚本，里面包含我们需要的所有步骤，以便拥有一个完整工作的 Laravel 环境。具体细节超出了本书的范围，但以下是步骤：
- en: 'We want **Extra Packages for Enterprise Linux** (**EPEL**):'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要**企业 Linux 的额外软件包**（**EPEL**）：
- en: '[PRE77]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We want PHP-FPM:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要 PHP-FPM：
- en: '[PRE78]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We want PHP-FPM to run as the Vagrant user so we have the rights:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望 PHP-FPM 以 Vagrant 用户身份运行，以便拥有适当的权限：
- en: '[PRE79]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Install a bunch of PHP dependencies:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装一堆 PHP 依赖：
- en: '[PRE80]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Install Composer:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Composer：
- en: '[PRE81]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Install and ship a good enough NGINX configuration:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装并配置一个足够好的 NGINX 配置：
- en: '[PRE82]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Install MariaDB Server:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 MariaDB Server：
- en: '[PRE83]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Start all the services:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动所有服务：
- en: '[PRE84]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Enable provisioning
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用配置
- en: 'To enable provisioning using our script, add the following code in the VM definition
    block:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用使用我们的脚本进行配置，请在虚拟机定义块中添加以下代码：
- en: '[PRE85]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Shared folder
  id: totrans-409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享文件夹
- en: 'To share the `src` folder between your host and the Vagrant VM under `/srv/app`,
    you can add the following code:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 要在主机和 Vagrant 虚拟机之间共享`src`文件夹，并将其挂载到`/srv/app`，您可以添加以下代码：
- en: '[PRE86]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Public LAN Networking
  id: totrans-412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 公共 LAN 网络
- en: 'The last thing we need to do now is to add a network interface to our Vagrant
    virtual machine, that will be on the real LAN, so our coworkers will access it
    easily through the network:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要做的最后一件事是向我们的 Vagrant 虚拟机添加一个网络接口，它将连接到真实的局域网，这样我们的同事就可以通过网络轻松访问它：
- en: '[PRE87]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Adapt the name of your network adapter to use (this was on a Mac, as you can
    guess) to your needs. Another solution is not to specify any adapter name, so
    you will be presented a list of possible adapters to bridge:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需要调整您的网络适配器名称（这在 Mac 上，如您所见）。另一种解决方案是不指定适配器名称，这样会显示一个可供桥接的适配器列表：
- en: '[PRE88]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Start the Vagrant environment (`vagrant up`), and when it''s available, you
    can execute commands such as finding out the network information: `vagrant ssh
    -c "ip addr"`. Your mileage will vary, but in this network, the public IP of this
    Vagrant box is `192.168.1.106`, so our work is available.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 Vagrant 环境（`vagrant up`），当它可用时，您可以执行诸如获取网络信息等命令：`vagrant ssh -c "ip addr"`。您的情况可能不同，但在这个网络中，这个
    Vagrant 盒子的公共 IP 地址是`192.168.1.106`，所以我们的工作是可访问的。
- en: 'Now you can start coding in the `./src/` folder. This is not a Laravel book,
    but a way to create a new project in a clean directory is as follows:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以开始在`./src/`文件夹中编码。虽然这不是一本 Laravel 书籍，但创建新项目的方式如下：
- en: '[PRE89]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Don't forget to remove all files from the folder beforehand. Navigate to `http://local-ip/`
    and you'll see the default Laravel welcome screen.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了提前清空文件夹中的所有文件。导航到`http://local-ip/`，您将看到默认的 Laravel 欢迎页面。
- en: To verify the file sharing sync is working correctly, edit the `./resources/views/welcome.blade.php`
    file and reload your browser to see the change reflected.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证文件共享同步是否正常工作，请编辑`./resources/views/welcome.blade.php`文件，并重新加载浏览器查看更改是否已反映。
- en: There's more…
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: If you include the Vagrantfile directly with your project's code, coworkers
    or contributors will only have to run `vagrant up` to see it running.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将 Vagrantfile 直接与项目代码一起包含，您的同事或贡献者只需运行`vagrant up`，即可看到它在运行。
- en: Other Vagrantfile sharing options include Windows Sharing (smb), rsync (useful
    with remote virtual machines such as on AWS EC2), and even NFS.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 其他 Vagrantfile 共享选项包括 Windows 共享（smb）、rsync（对于远程虚拟机，如 AWS EC2 非常有用），甚至 NFS。
- en: 'A noticeable bug in the sharing feature using VirtualBox leads to corrupted
    or non-updating files. The workaround is to deactivate in the web server configuration
    `sendfile`, using NGINX:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 VirtualBox 共享功能时，一个明显的 bug 会导致文件损坏或无法更新。解决方法是禁用 Web 服务器配置中的 `sendfile`，使用
    NGINX：
- en: '[PRE90]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Using Apache, it is as follows:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Apache，如下所示：
- en: '[PRE91]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Sharing access to your Vagrant environment with the world
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将你的 Vagrant 环境共享给全世界
- en: You're working on your project with your local Vagrant environment, and you'd
    like to show the status of the job to your customer who's located in another city.
    Maybe you have an issue configuring something and you'd like some remote help
    from your coworker on the other side of the planet. Alternatively, maybe you'd
    like to access your work Vagrant box from home, hotel, or coworking space? There's
    a neat Vagrant sharing feature we'll use here, working with a Ghost blog on CentOS
    7.2.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在本地 Vagrant 环境中进行项目开发，并且你想向位于另一个城市的客户展示工作的状态。也许你在配置某些内容时遇到问题，需要来自地球另一端同事的远程帮助。或者，你可能希望从家里、酒店或共享办公空间访问你的工作
    Vagrant 盒子？这里有一个很棒的 Vagrant 共享功能，我们将用于在 CentOS 7.2 上运行的 Ghost 博客。
- en: Getting ready
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To step through this recipe, you will need the following:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个教程，你需要以下内容：
- en: A working Vagrant installation
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的 Vagrant 安装
- en: A working VirtualBox installation
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的 VirtualBox 安装
- en: A free HashiCorp Atlas account ([https://atlas.hashicorp.com/account/new](https://atlas.hashicorp.com/account/new))
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个免费的 HashiCorp Atlas 账户 ([https://atlas.hashicorp.com/account/new](https://atlas.hashicorp.com/account/new))
- en: An Internet connection
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个互联网连接
- en: How to do it…
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Let''s start with this simple Vagrantfile:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从这个简单的 Vagrantfile 开始：
- en: '[PRE92]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We know we''ll have to install some packages, so let''s add a provisioning
    script to be executed:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道需要安装一些包，所以让我们添加一个配置脚本来执行：
- en: '[PRE93]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We''ll want to hack locally on our Ghost blog, such as adding themes and more,
    so let''s sync our `src/` folder to the remote `/srv/blog` folder:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要在本地对 Ghost 博客进行修改，比如添加主题等，因此我们将 `src/` 文件夹同步到远程 `/srv/blog` 文件夹：
- en: '[PRE94]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We want a local private network so we can access the virtual machine, with
    the `2368` TCP port (Ghost default) redirected to our host `8080` HTTP port:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个本地私有网络，以便可以访问虚拟机，并将 `2368` TCP 端口（Ghost 默认端口）重定向到我们主机的 `8080` HTTP 端口：
- en: '[PRE95]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Provisioning
  id: totrans-446
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置
- en: 'To configure our new box, we''ll first need to enable EPEL:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了配置我们的新盒子，首先需要启用 EPEL：
- en: '[PRE96]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Then install the requirements, `node`, `npm`, and `unzip`:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后安装要求的工具，`node`、`npm` 和 `unzip`：
- en: '[PRE97]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Download the latest Ghost version:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载最新版本的 Ghost：
- en: '[PRE98]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Uncompress it in the `/srv/blog` folder:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其解压到 `/srv/blog` 文件夹中：
- en: '[PRE99]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Install the Ghost dependencies:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Ghost 依赖项：
- en: '[PRE100]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Put all those commands in the `provisioning.sh` script and we''re good to go:
    `vagrant up`.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些命令放入 `provisioning.sh` 脚本中，之后我们就可以开始了：`vagrant up`。
- en: Starting Ghost engine
  id: totrans-458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动 Ghost 引擎
- en: 'As you would do normally, log in to your Vagrant box to launch the node server:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 按照通常的方式，登录到你的 Vagrant 盒子，启动节点服务器：
- en: '[PRE101]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Change the host IP from `127.0.0.1` to `0.0.0.0` in the generated `config.js`
    file so the server listens on all interfaces:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成的 `config.js` 文件中的主机 IP 从 `127.0.0.1` 更改为 `0.0.0.0`，这样服务器就能监听所有接口：
- en: '[PRE102]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Restart the node server:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 重启节点服务器：
- en: '[PRE103]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'You now have a direct access to the blog through your box LAN IP (adapt the
    IP to your case): `http://172.28.128.3:2368/`.'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以通过你的盒子局域网 IP 直接访问博客（根据你的情况调整 IP）：`http://172.28.128.3:2368/`。
- en: Sharing access
  id: totrans-466
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享访问
- en: 'Now you can access your application locally through your Vagrant box, let''s
    give access to it to others through the Internet using `vagrant share`:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过你的 Vagrant 盒子本地访问你的应用，让我们通过互联网使用 `vagrant share` 给它提供访问权限：
- en: HTTP
  id: totrans-468
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: HTTP
- en: 'The default is to share through HTTP, so your work is available through a web
    browser:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，通过 HTTP 共享，因此你可以通过 Web 浏览器访问你的工作：
- en: '[PRE104]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'This URL is the one you can give to anyone to access publicly your work: Vagrant
    servers being used as proxy.'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 URL 是你可以分享给任何人以公开访问你工作的链接：Vagrant 服务器作为代理。
- en: SSH
  id: totrans-472
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SSH
- en: 'Another possible sharing option is by SSH (deactivated by default). The program
    will ask you for a password you''ll need to connect to the box remotely:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能的共享选项是通过 SSH（默认情况下禁用）。该程序会要求你输入密码，用以远程连接到盒子：
- en: '[PRE105]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Now, at home or at the coworking space, you can simply connect to your work
    Vagrant box (if needed, the default Vagrant password is vagrant):'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在家里或共享办公空间，你只需连接到你的工作 Vagrant 盒子（如果需要，默认的 Vagrant 密码是 vagrant）：
- en: '[PRE106]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: You or your coworker are now remotely logged into your own Vagrant box over
    the Internet!
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 你或你的同事现在可以通过互联网远程登录到你自己的 Vagrant 盒子了！
- en: Simulating Chef upgrades using Vagrant
  id: totrans-478
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Vagrant 模拟 Chef 升级
- en: Wouldn't it be awesome to simulate production changes quickly? Chances are you're
    using Chef in production. We'll see how to use both Chef cookbooks with Vagrant,
    as well as how to simulate Chef version upgrades between environments. This kind
    of setup is the beginning of a good combination of infrastructure as code.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 如果能够快速模拟生产环境的变更，那不是很棒吗？很可能你在生产环境中使用的是 Chef。我们将学习如何在 Vagrant 中使用 Chef cookbook，并且如何在不同环境之间模拟
    Chef 版本升级。这种配置是将基础设施即代码（Infrastructure as Code）结合得非常好的起点。
- en: Getting ready
  id: totrans-480
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行这个步骤，你需要以下资源：
- en: A working Vagrant installation
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的 Vagrant 安装
- en: A working VirtualBox installation
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的 VirtualBox 安装
- en: An Internet connection
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个互联网连接
- en: How to do it…
  id: totrans-485
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Let''s start with a minimal virtual machine named `prod` that simply boots
    a CentOS 7.2, like we have in our production environment:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个最小的虚拟机 `prod` 开始，它仅启动一个 CentOS 7.2，就像我们在生产环境中的设置：
- en: '[PRE107]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Vagrant Omnibus Chef plugin
  id: totrans-488
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Vagrant Omnibus Chef 插件
- en: 'Now, if we want to use Chef code, if we want to use Chef code (Ruby files organized
    in directories that form a unit called a ''cookbook'' that configure and maintain
    a specific area of a system), we first need to install Chef on the Vagrant box.
    There''re many ways to do this, from provisioning shell scripts to using boxes
    with Chef already installed. A clean, reliable, and repeatable way is to use a
    Vagrant plugin to do just that—vagrant-omnibus. Omnibus is a packaged Chef. Install
    it like any other Vagrant plugin:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想使用 Chef 代码（Chef 代码是以目录组织的 Ruby 文件，这些文件形成一个名为“cookbook”的单元，用于配置和维护系统的特定区域），我们首先需要在
    Vagrant 虚拟机上安装 Chef。实现这一点有很多方法，从配置 Shell 脚本到使用已经安装 Chef 的盒子。一个干净、可靠且可重复的方法是使用
    Vagrant 插件来实现——vagrant-omnibus。Omnibus 是一个打包好的 Chef。像其他 Vagrant 插件一样安装它：
- en: '[PRE108]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Then, just add the following configuration in your VM definition of the Vagrantfile
    and you''ll always have the latest Chef version installed on this box:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，只需在 Vagrantfile 的虚拟机定义中添加以下配置，你就能确保始终安装最新版本的 Chef：
- en: '[PRE109]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'However, our goal is to mimic production, maybe we''re still using the latest
    in v11.x series of Chef instead of the latest 12.x, so instead let''s specify
    exactly which version we want:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的目标是模拟生产环境，也许我们仍然在使用 Chef v11.x 系列的最新版本，而不是最新的 12.x 版本，因此我们将具体指定我们需要的版本：
- en: '[PRE110]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Now that we''re using a new plugin, our Vagrantfile won''t work out of the
    box for everybody. Users will have to install this vagrant-omnibus plugin. If
    you care about consistency and repeatability, an option is to add the following
    Ruby check at the beginning of your Vagrantfile:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用了一个新插件，Vagrantfile 对每个人可能无法直接工作。用户必须安装 vagrant-omnibus 插件。如果你关心一致性和可重复性，可以选择在
    Vagrantfile 的开头添加以下 Ruby 检查：
- en: '[PRE111]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: This code snippet will simply iterate over each plugin name to verify that Vagrant
    returns them as *installed*. If not, stop there and return a helpful exit message
    on how to install the required plugins.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会遍历每个插件名称，验证 Vagrant 是否将它们标记为 *已安装*。如果没有，就停止并返回一个帮助退出信息，指导如何安装所需的插件。
- en: A sample Chef recipe
  id: totrans-498
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个示例的 Chef 配方
- en: 'This part of the book isn''t about writing Chef recipes (read more about it
    later in the book!), so we''ll keep that part simple. Our objective is to install
    the Apache 2 web server on CentOS 7 (`httpd` package), and start it. Here''s what
    our sample recipe looks like (`cookbooks/apache2/recipes/default.rb`); it does
    exactly what it says in plain English:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的这一部分并不是关于编写 Chef 配方（后面章节会详细讲解！），因此我们会简化这一部分。我们的目标是在 CentOS 7 上安装 Apache 2
    Web 服务器（`httpd` 包），并启动它。下面是我们的示例配方（`cookbooks/apache2/recipes/default.rb`）；它做的正是用通俗的语言描述的内容：
- en: '[PRE112]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Vagrant and Chef integration
  id: totrans-501
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Vagrant 与 Chef 集成
- en: 'Here''s how, in our VM definition block, we''ll tell Vagrant to work with Chef
    Solo (a way of running Chef in standalone mode, without the need of a Chef server)
    to provision our box:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的虚拟机定义块中，我们将告诉 Vagrant 使用 Chef Solo（一个无需 Chef 服务器即可单独运行 Chef 的方式）来配置我们的虚拟机：
- en: '[PRE113]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: As simple as that. Vagrant this up (`vagrant up`), and you'll end up with a
    fully provisioned VM, using the old 11.18.12 version, and a running Apache 2 web
    server.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单。启动 Vagrant (`vagrant up`)，你将得到一个完全配置好的虚拟机，使用的是旧版本 11.18.12，并且 Apache 2
    Web 服务器正在运行。
- en: 'Our manual tests can include checking that the chef-solo version is the one
    we requested:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的手动测试可以包括检查 chef-solo 版本是否是我们要求的版本：
- en: '[PRE114]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'They can also check if we have `httpd` installed:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 它们还可以检查我们是否已经安装了 `httpd`：
- en: '[PRE115]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Also, we can check if `httpd` is running:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们可以检查 `httpd` 是否正在运行：
- en: '[PRE116]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Note
  id: totrans-511
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Various other options than chef-solo exist, such as chef-client and chef-zero.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 除 chef-solo 外，还存在其他各种选项，比如 chef-client 和 chef-zero。
- en: Testing the Chef version update
  id: totrans-513
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试 Chef 版本更新
- en: 'So we simulated our production environment locally, with the same CentOS version,
    the apache2 cookbook used in production, and the old Chef version 11\. Our next
    task is to test if everything is still running smoothly after an upgrade to the
    new version 12\. Let''s create a second "staging" VM, very similar to our production
    setup, except we want to install the current latest Chef version (12.13.37 at
    the time of writing, feel free to use `:latest` instead):'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在本地模拟了我们的生产环境，使用相同的 CentOS 版本、生产环境中使用的 apache2 cookbook 和旧的 Chef 版本 11。我们的下一个任务是测试在升级到新版本
    12 后，一切是否仍然运行顺利。让我们创建第二个“暂存”虚拟机，设置与生产环境非常相似，唯一不同的是我们想安装当前最新的 Chef 版本（截至本文写作时是
    12.13.37，随时可以使用 `:latest`）：
- en: '[PRE117]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Launch this new machine (`vagrant up staging`) and we''ll see if our setup
    still works with the new major Chef version:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 启动这个新机器（`vagrant up staging`），看看我们的设置在新版本的 Chef 中是否仍然有效：
- en: '[PRE118]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: So we can safely assume, as far as our testing goes, that the newest Chef version
    still works correctly with our production Chef code.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基于我们的测试结果，我们可以安全地假设，最新版本的 Chef 仍然能够与我们的生产 Chef 代码正常工作。
- en: There's more…
  id: totrans-519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: Here are more ways of controlling a Vagrant environment, and use even better
    Chef tooling inside it.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有更多控制 Vagrant 环境的方法，并可以在其中使用更好的 Chef 工具。
- en: Controlling default Vagrant VMs
  id: totrans-521
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制默认的 Vagrant 虚拟机
- en: 'You may not always want to boot both production and staging vagrant virtual
    machines, especially when you just want to work on the default production setup.
    To specify a default VM:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不总是希望启动生产和暂存的 Vagrant 虚拟机，尤其是在你只想处理默认的生产环境设置时。要指定默认的虚拟机：
- en: '[PRE119]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'To not start automatically a VM when issuing the `vagrant up` command:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 要在执行 `vagrant up` 命令时不自动启动虚拟机：
- en: '[PRE120]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Berkshelf and Vagrant
  id: totrans-526
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Berkshelf 和 Vagrant
- en: Chances are, if your production environment is using Chef, you're also using
    Berkshelf for dependency management and not 100% local cookbooks (if you aren't,
    you should!).
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的生产环境使用 Chef，那么你很可能也在使用 Berkshelf 来进行依赖管理，而不是完全使用本地 cookbooks（如果你没有这样做，你应该尝试！）。
- en: Vagrant work pretty well with a Berkshelf enabled Chef environment, using the
    `vagrant-berkshelf` plugin.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant 在启用了 Berkshelf 的 Chef 环境中工作得很好，使用 `vagrant-berkshelf` 插件。
- en: Note
  id: totrans-529
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Your workstation will need the Chef Development Kit (Chef DK: [https://downloads.chef.io/chef-dk/](https://downloads.chef.io/chef-dk/))
    for this to work correctly.'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 你的工作站需要 Chef 开发工具包（Chef DK：[https://downloads.chef.io/chef-dk/](https://downloads.chef.io/chef-dk/)）才能正确运行。
- en: Testing with Test Kitchen
  id: totrans-531
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Test Kitchen 进行测试
- en: This setup is in fact so close to what's used to make infrastructure code testing
    that you'll see a lot of similarities in the dedicated section of this book.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置实际上非常接近用于基础架构代码测试的方式，你会在本书的专门章节中看到许多相似之处。
- en: Using Ansible with Vagrant to create a Docker host
  id: totrans-533
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ansible 与 Vagrant 创建 Docker 主机
- en: Ansible ([https://www.ansible.com/](https://www.ansible.com/)) is a very simple
    and powerful open source automation tool. While using and creating Ansible *playbooks*
    is off-topic for this book, we'll use a very simple *playbook* to install and
    configure Docker on a CentOS 7 box. Starting from here, you'll be able to iterate
    through more complex Ansible playbooks.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible ([https://www.ansible.com/](https://www.ansible.com/)) 是一个非常简单且强大的开源自动化工具。虽然使用和创建
    Ansible *playbooks* 超出了本书的主题，但我们将使用一个非常简单的 *playbook* 来安装和配置 CentOS 7 上的 Docker。从这里开始，你将能够逐步编写更复杂的
    Ansible playbooks。
- en: Getting ready
  id: totrans-535
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此配方，你需要以下内容：
- en: A working Vagrant installation
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的 Vagrant 安装
- en: A working hypervisor
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的虚拟化管理程序
- en: A working Ansible installation on your machine (an easy way is to `$ pip install
    ansible` or to pick your usual package manager like APT or YUM/DNF)
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你机器上的 Ansible 安装（一个简单的方法是 `$ pip install ansible`，或者使用你习惯的包管理器，如 APT 或 YUM/DNF）
- en: An Internet connection
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个互联网连接
- en: How to do it…
  id: totrans-541
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Because writing complex Ansible playbooks is out of the scope of this book,
    we'll use a very simple one, so you can learn more about Ansible later and still
    reuse this recipe.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 因为编写复杂的 Ansible playbook 超出了本书的范围，我们将使用一个非常简单的 playbook，这样你可以稍后深入了解 Ansible，并仍然能够重用这个示例。
- en: A simple Ansible Docker playbook for Vagrant
  id: totrans-543
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个简单的 Ansible Docker playbook 用于 Vagrant
- en: 'Our playbook file (`playbook.yml`) is a plain YAML file, and we''ll do the
    following in this order:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 playbook 文件（`playbook.yml`）是一个普通的 YAML 文件，我们将按照以下顺序进行操作：
- en: Install EPEL.
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 EPEL。
- en: Create a Docker Unix group.
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 Docker Unix 组。
- en: Add the default Vagrant user to the new Docker group.
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将默认的 Vagrant 用户添加到新的 Docker 组中。
- en: Install Docker from CentOS repositories.
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 CentOS 仓库安装 Docker。
- en: Enable and start Docker Engine.
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用并启动 Docker 引擎。
- en: 'Here''s how the `playbook.yml` file looks:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `playbook.yml` 文件的样子：
- en: '[PRE121]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Apply Ansible from Vagrant
  id: totrans-552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 Vagrant 应用 Ansible
- en: 'To use our Ansible playbook, let''s start with a simple Vagrantfile starting
    a CentOS 7 box:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用我们的 Ansible playbook，我们从一个简单的 Vagrantfile 开始，它启动一个 CentOS 7 虚拟机：
- en: '[PRE122]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Simply add Ansible provisioning like this to the VM definition so it will load
    and apply your `playbook.yml` file:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将 Ansible 配置添加到虚拟机定义中，这样它将加载并应用你的 `playbook.yml` 文件：
- en: '[PRE123]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'You can now run `vagrant up` and use CentOS 7 Docker Engine version right away:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以运行 `vagrant up` 并立即使用 CentOS 7 Docker 引擎版本：
- en: '[PRE124]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: There's more…
  id: totrans-559
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'What if for some reason you don''t or can''t have Ansible installed on your
    host machine? Alternatively, maybe you need a specific Ansible version on your
    Vagrant box to mimic production and you don''t want to mess with your local Ansible
    installation. There''s an interesting variant Ansible provider you can use: it
    will either use Ansible directly from the guest VM, and if it''s not installed,
    it will install it from official repositories or PIP. You can use this very simple
    default configuration:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某些原因你不能在主机上安装 Ansible，或者你需要在 Vagrant box 中安装特定版本的 Ansible 来模拟生产环境，而又不想影响本地的
    Ansible 安装，你可以使用一个有趣的 Ansible 提供者变体：它将直接使用来自客机 VM 的 Ansible，如果没有安装，它会从官方仓库或 PIP
    安装。你可以使用这个非常简单的默认配置：
- en: '[PRE125]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'You can also use the following command:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用以下命令：
- en: '[PRE126]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Log in to the box via SSH and check that Ansible is locally installed with
    the latest version:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 SSH 登录到 box 并检查是否已本地安装最新版本的 Ansible：
- en: '[PRE127]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'If your use case is different, you can use more precise deployment options,
    to be able to fix an Ansible version number using PIP (here, version 1.9.6 instead
    of the latest 2.x series):'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的使用场景不同，你可以使用更精确的部署选项，通过 PIP 固定 Ansible 版本号（例如，使用 1.9.6 版本，而不是最新的 2.x 系列）：
- en: Note
  id: totrans-567
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It will take noticeably longer to start, as it needs to install many packages
    on the guest system.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 启动过程会明显变慢，因为它需要在客机系统上安装许多软件包。
- en: '[PRE128]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'You can also use the following command:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用以下命令：
- en: '[PRE129]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Inside the Vagrant guest, you can now check for the PIP and Ansible versions:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vagrant 客机中，你现在可以检查 PIP 和 Ansible 的版本：
- en: '[PRE130]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'You can also check if our playbook has been installed correctly with the old
    1.x Ansible version:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以检查我们的 playbook 是否在旧版本的 1.x Ansible 上正确安装：
- en: '[PRE131]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Also check if Docker is installed, and verify now it''s working as the Vagrant
    user:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 还要检查 Docker 是否已安装，并且现在可以作为 Vagrant 用户正常工作：
- en: '[PRE132]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Using Docker containers on CoreOS with Vagrant
  id: totrans-578
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 CoreOS 上使用 Docker 容器与 Vagrant
- en: Vagrant can help in simulating environments, and Docker containers are not forgotten
    with Vagrant. We'll use one of the best platforms to run containers, the free
    and open source lightweight operating system CoreOS. Based on Linux, targeting
    easy container and clustered deployments, it also provides official Vagrant boxes.
    We'll deploy the official WordPress container with MariaDB on another container
    using the Vagrant Docker provisioner (and not the Vagrant Docker provider).
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant 可以帮助模拟环境，Docker 容器在 Vagrant 中也得到了支持。我们将使用一个最佳平台来运行容器——免费且开源的轻量级操作系统
    CoreOS。它基于 Linux，旨在简化容器和集群的部署，并提供官方的 Vagrant box。我们将使用 Vagrant Docker 提供者（而不是
    Vagrant Docker 提供者）部署官方的 WordPress 容器与 MariaDB 容器。
- en: Getting ready
  id: totrans-580
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行这个步骤，你需要以下内容：
- en: A working Vagrant installation
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的 Vagrant 安装
- en: A working hypervisor
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的虚拟化管理程序
- en: An Internet connection
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个互联网连接
- en: How to do it…
  id: totrans-585
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'CoreOS doesn''t host its official images at the default location on Atlas,
    it hosts it itself. So, we have to specify the full URL to the Vagrant box in
    our Vagrantfile:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: CoreOS 并没有在 Atlas 的默认位置托管官方镜像，而是自行托管。所以，我们必须在 Vagrantfile 中指定 Vagrant box 的完整
    URL：
- en: '[PRE133]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'As CoreOS is a minimal OS, it doesn''t support any of the VirtualBox guest
    addition tools, so we''ll disable them, and don''t try anything if we (most likely)
    have the `vagrant-vbguest` plugin:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 CoreOS 是一个极简操作系统，它不支持任何 VirtualBox 客户机附加工具，因此我们将禁用它们。如果我们（很可能）安装了 `vagrant-vbguest`
    插件，也不要尝试使用这些工具：
- en: '[PRE134]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Let''s create a new VM definition, using the CoreOS Vagrant box:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的虚拟机定义，使用 CoreOS Vagrant box：
- en: '[PRE135]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'We now need to run the `mariadb` and `wordpress` official containers from the
    Docker Hub. Using Docker directly, we would have run the following:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要运行 Docker Hub 上的 `mariadb` 和 `wordpress` 官方容器。直接使用 Docker，我们将运行以下命令：
- en: '[PRE136]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Let''s translate this into our Vagrantfile:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其转换到我们的 Vagrantfile 中：
- en: '[PRE137]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Vagrant this up (`$ vagrant up`), and you''ll access a ready-to-use WordPress
    installation running on CoreOS:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 Vagrant (`$ vagrant up`)，你将访问一个已经安装好并可以使用的 WordPress 环境，运行在 CoreOS 上：
- en: '[PRE138]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: There's more…
  id: totrans-598
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: The CoreOS team proposes a full Vagrant environment to try and manipulate a
    CoreOS cluster [https://github.com/coreos/coreos-vagrant](https://github.com/coreos/coreos-vagrant).
    You'll then be able to try all CoreOS features and configuration options for all
    release channels (alpha, beta, or stable).
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: CoreOS 团队提供了一个完整的 Vagrant 环境，用于尝试和操作一个 CoreOS 集群 [https://github.com/coreos/coreos-vagrant](https://github.com/coreos/coreos-vagrant)。你将能够尝试所有
    CoreOS 的功能和配置选项，涵盖所有发布渠道（alpha、beta 或 stable）。
- en: Other operating systems such as Ubuntu or CentOS are fully supported to provision
    Docker containers, even if Docker isn't installed at first on the base image.
    Vagrant will install Docker for you, so it will work transparently and run the
    containers as soon as it's installed.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 其他操作系统如 Ubuntu 或 CentOS 完全支持为 Docker 容器提供配置，即使基础镜像中一开始没有安装 Docker。Vagrant 会为你安装
    Docker，因此它将透明地工作，并在安装完成后立即运行容器。
