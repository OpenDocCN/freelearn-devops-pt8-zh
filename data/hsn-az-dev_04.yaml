- en: Distributed Applications and Microservices with Service Fabric
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Service Fabric 开发分布式应用和微服务
- en: '**Service Fabric** (**SF**) is a platform for distributed applications that
    greatly simplifies developing and deploying applications that are scalable and
    reliable. It''s one of the best solutions for developing cloud-native apps and
    lets users focus on developing rather than on maintaining infrastructure and connections
    between particular components. It''s a next-generation platform that is actively
    developed by Microsoft and has received much attention recently.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**Service Fabric** (**SF**) 是一个分布式应用平台，它大大简化了可扩展且可靠的应用开发与部署。它是开发云原生应用的最佳解决方案之一，让用户可以专注于开发，而非维护基础设施和组件之间的连接。它是一个下一代平台，由微软积极开发，最近受到了广泛关注。'
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Microservice architecture and how to use it in the cloud with SF
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构以及如何在云中使用 SF
- en: Basic concepts of SF, such as services or actors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SF 的基本概念，如服务或角色
- en: Communicating between services in SF
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 SF 中的服务间通信
- en: Managing clusters in SF and securing them
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 SF 中管理集群并确保其安全
- en: Monitoring services in SF and how to diagnose them
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控 SF 中的服务及如何诊断它们
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To perform exercises in this chapter, you will need the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章的练习，你将需要以下内容：
- en: Visual Studio 2017 with **Azure development** and **ASP.NET** and **web development** workloads
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有**Azure 开发**、**ASP.NET**和**Web 开发**工作负载的 Visual Studio 2017
- en: Microsoft Azure SF SDK ([http://www.microsoft.com/web/handlers/webpi.ashx?command=getinstallerredirect&appid=MicrosoftAzure-ServiceFabric-CoreSDK](http://www.microsoft.com/web/handlers/webpi.ashx?command=getinstallerredirect&appid=MicrosoftAzure-ServiceFabric-CoreSDK))
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Azure SF SDK ([http://www.microsoft.com/web/handlers/webpi.ashx?command=getinstallerredirect&appid=MicrosoftAzure-ServiceFabric-CoreSDK](http://www.microsoft.com/web/handlers/webpi.ashx?command=getinstallerredirect&appid=MicrosoftAzure-ServiceFabric-CoreSDK))
- en: Node.js ([https://nodejs.org/en/](https://nodejs.org/en/))
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js ([https://nodejs.org/en/](https://nodejs.org/en/))
- en: Understanding microservices
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解微服务
- en: Probably you have heard about an architecture called **microservices**. There
    is no single definition that we could quote here, so the main purpose of this
    chapter will be to acquire a better insight into what we can call a microservice
    and how to develop an application in such a manner. This directly connects to SF,
    which is one of the biggest and most advanced services in Azure. If you aim at
    building a modular, loosely-coupled, and modern application, this particular cloud
    component is designed for you.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过一种叫做**微服务**的架构。这里没有一个单一的定义可以引用，因此本章的主要目的是更好地理解我们可以称之为微服务的内容，以及如何以这种方式开发应用程序。这与SF直接相关，SF是Azure中最大和最先进的服务之一。如果你打算构建一个模块化、松耦合且现代的应用程序，这个云组件专为你设计。
- en: Monolith versus microservices
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单体应用与微服务
- en: 'We will start our journey with microservices by comparing them with a traditional
    application, which is composed of multiple layers serving different purposes:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过将微服务与传统应用进行对比来开始我们的微服务之旅，传统应用由多个层次构成，每个层次服务不同的目的：
- en: '![](img/3755b0bf-a1ea-4aad-8984-19b4653f85cb.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3755b0bf-a1ea-4aad-8984-19b4653f85cb.png)'
- en: 'As you can see, we define such services as monolithic, where the whole code
    base is deployed as one application. This one application has multiple responsibilities:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们将这些服务定义为单体应用，其中整个代码库作为一个应用程序部署。这个应用程序有多个职责：
- en: Serving the UI
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供 UI 服务
- en: Running business logic
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行业务逻辑
- en: Running additional processes (such as jobs)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行额外进程（如作业）
- en: 'We can also look at it differently—as a single module that handles features
    from different domains. Let''s consider an e-shop, where we have the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以从不同的角度来看待它——作为一个处理不同领域功能的单一模块。让我们考虑一个电子商店，其中有以下内容：
- en: Payment logic
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支付逻辑
- en: Basket logic
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购物车逻辑
- en: Order processing logic
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单处理逻辑
- en: Discounts logic
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 折扣逻辑
- en: Many, many more different domains
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多，许多其他不同领域
- en: Now the question arises—should our application run such logic in one instance
    or should we divide it into multiple independent modules, which have different
    lifetimes, run differently, and can be developed individually? Maybe we would
    also like to scale them separately depending on current workload or business requirements.
    The choice always depends on the requirements your application will have to face.
    However, if you would like to give try microservices, SF is the way to go, especially
    if you aim at using cloud-native components.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在问题来了——我们的应用程序应该在一个实例中运行这些逻辑，还是应该将其拆分成多个独立的模块，这些模块具有不同的生命周期、不同的运行方式，并且可以单独开发？也许我们还希望根据当前的工作负载或业务需求分别扩展它们。选择总是取决于你的应用程序将面临的需求。然而，如果你希望尝试微服务，SF是最好的选择，尤其是当你打算使用云原生组件时。
- en: Microservice approach
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务方法
- en: You may wonder whether the microservice architecture is one you would like to
    choose and work with. In this section, I would like to focus on specific features
    this approach provides and how you can address them when writing an application
    and, in the end, using SF.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，微服务架构是否是你愿意选择并使用的架构。在本节中，我将重点介绍这种方法所提供的特定功能，以及如何在编写应用程序时处理这些功能，最终使用SF。
- en: Using different languages and frameworks
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用不同的语言和框架
- en: Sometimes, we would like to address different problems resolved by our application
    by using different programming languages or tools. Maybe it is a good idea to
    write mainly in C# or Java and deliver more advanced features such as domain-specific
    calculations using a dedicated language. Maybe we have multiple teams working
    on different features and each one would like to use a different framework.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们希望通过使用不同的编程语言或工具来解决我们的应用程序所面临的不同问题。也许主要用C#或Java编写应用程序，并使用专用语言交付更复杂的功能，如领域特定的计算。也许我们有多个团队在开发不同的特性，每个团队都希望使用不同的框架。
- en: Maybe the whole work is so globally distributed that dividing it into multiple
    smaller packages (and finally services) is the way to go. All of these problems
    are possible to solve using a single application but, on a bigger scale, such
    an approach could become cumbersome and insufficient. By leveraging the capabilities
    of SF in Azure, we can organize multiple applications (containing multiple services
    each) as a single platform, which can be managed from one place and deployed individually,
    saving time and money.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 也许整个工作是如此全球化分布，以至于将其拆分为多个较小的包（最终变成服务）是前进的方向。所有这些问题都可以通过使用一个单一应用程序来解决，但在更大规模下，这种方法可能会变得繁琐且不足够。通过利用Azure中的SF功能，我们可以将多个应用程序（每个应用程序包含多个服务）组织成一个单一平台，从一个地方进行管理并单独部署，从而节省时间和成本。
- en: Scaling and updating services individually
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单独扩展和更新服务
- en: 'We have just talked about deploying each service individually. Thanks to such
    an approach, you do not have to push the whole code base at once. I am sure you
    have had at least one project that was so big that the whole process of delivering
    it to the production environment was difficult to automate and took really long
    to finish. In such a scenario, dividing the project into smaller modules can also
    be beneficial let''s say that, in the last month, only one team delivered a new
    feature; you do not have to go through all your platform tests. What is more,
    if something is not right after deployment in a part of the system you have not
    modified, you do not have to bring in another team to investigate the problem.
    This confers the following advantages:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才讨论了如何单独部署每个服务。得益于这种方法，你不必一次性推送整个代码库。我相信你至少有过一个项目，它是如此庞大，以至于将整个项目交付到生产环境的过程难以自动化，并且需要非常长的时间才能完成。在这种情况下，将项目拆分成更小的模块也是有益的。比如说，在上个月，只有一个团队交付了一个新特性；你不必重新进行所有平台测试。更重要的是，如果部署后系统中某个未修改的部分出现问题，你也不需要另一个团队来调查问题。这带来了以下优势：
- en: The process of delivering a business value is shorter and simpler, and hence
    less vulnerable to mistakes
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交付商业价值的过程更短、更简单，因此更不容易出错
- en: You can focus on a particular module and changes in it often do not affect other
    modules
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以专注于某个特定模块，并且其中的更改通常不会影响其他模块
- en: 'There is one more interesting feature of the microservices architecture—you
    can scale each component separately. This means that if, for example, there is
    a module responsible for processing payments and you have just had a big discount
    in your online shop, resulting in a rapid growth of incoming orders, you do not
    have to worry that they overwhelm it. What you can do in such a situation is simply
    scale it out, so you can process each order in parallel using as many instances
    of your module as you currently need. Later in this chapter, you will learn how
    you can achieve such scalability in SF using different approaches depending on
    the actual structure of your application. The following diagram describes the
    difference between scaling microservices and monolith application—while the former
    gives you the possibility to scale up each service individually, the latter has
    to be scaled as a single entity:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构还有一个有趣的特点——你可以单独扩展每个组件。这意味着，如果例如有一个负责处理支付的模块，而你刚刚在网上商店进行了一次大幅度的折扣促销，导致订单量急剧增长，你不必担心订单会压垮它。在这种情况下，你可以做的是简单地扩展该模块，这样你就可以并行处理每个订单，使用尽可能多的实例来满足当前需求。本章稍后会介绍如何根据应用程序的实际结构使用不同的方法来实现这种可扩展性。下面的图表描述了微服务和单体应用程序扩展的区别——前者使你能够单独扩展每个服务，而后者则必须作为一个整体进行扩展：
- en: '![](img/b70e27f1-7128-4a45-9123-bdbfaa8d4ef5.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b70e27f1-7128-4a45-9123-bdbfaa8d4ef5.png)'
- en: Using well-designed interfaces and protocols
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用设计良好的接口和协议
- en: You may ask, If we divide our application into, for instance, several smaller
    modules, how can we now ensure that communication between them will be smooth,
    seamless, and with the smallest latency possible? To satisfy such requirements,
    one has to refer to multiple communication patterns described by patterns for
    service-oriented architectures, which in fact are the very foundation of microservices.
    In general, you have to leverage well-known protocols such as HTTP or TCP, which
    are widely used in the IT industry and are understood by thousands of APIs, devices,
    and frameworks. Of course, you could think about designing a custom protocol or
    standard—while initially, it might be a good idea, sooner or later it may become
    an obstacle to expanding your application because it's not compatible with newer
    services. What is more, it is important to use popular serialization methods such
    as XML, JSON, or any binary format that is easily available and well documented.
    By following such guides, you can be sure that your microservice architecture
    will be easy to extend and integrate with.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，如果我们将应用程序划分为多个较小的模块，我们如何确保它们之间的通信既顺畅、无缝，又能尽量减少延迟？为了满足这样的要求，我们必须参考面向服务架构（SOA）所描述的多种通信模式，而这些模式实际上是微服务的基础。一般来说，你需要利用广泛应用于
    IT 行业的、为成千上万的 API、设备和框架所理解的著名协议，如 HTTP 或 TCP。当然，你也可以考虑设计一个自定义的协议或标准——虽然最初这可能是个好主意，但迟早它会成为扩展应用程序的障碍，因为它与更新的服务不兼容。更重要的是，使用流行的序列化方法，如
    XML、JSON，或任何容易获取并且有良好文档支持的二进制格式是很重要的。通过遵循这些指南，你可以确保你的微服务架构将易于扩展和集成。
- en: Dealing with state
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理状态
- en: Nearly every application has some kind of state (of course, one can develop
    a stateless service, which does not have to store a state anywhere and just performs
    an action/returns a result; we will cover such services later in this chapter).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个应用程序都有某种状态（当然，也可以开发一个无状态的服务，它不需要在任何地方存储状态，只执行操作/返回结果；我们将在本章稍后讨论这样的服务）。
- en: This state has to be managed and shared; in monolithic application handling,
    it is pretty straightforward and obvious—we have, for instance, a database, which
    holds all information from multiple parts of our system. In general, it is stored
    in one place (of course it can be scaled and shared, but we do not manage such
    features on our own), so we do not have to worry that we update it only partially
    (and if we do, there are always transactions). Of course, the state does not have
    to be stored in a database—we can use any kind of storage that holds data.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个状态必须被管理和共享；在单体应用程序的处理过程中，这个过程非常直接且显而易见——例如，我们有一个数据库，存储着系统多个部分的所有信息。一般来说，它存储在一个地方（当然它可以扩展和共享，但我们不会自己管理这些功能），因此我们不必担心它只被部分更新（如果真的部分更新了，也总有事务来保证一致性）。当然，状态不一定要存储在数据库中——我们可以使用任何类型的存储来保存数据。
- en: When using microservices, it turns out that each individual service has its
    own state and manages it independently. Problems arise where we have to query
    data from different modules or store data in more than one form of storage. To
    overcome such problems, one can use patterns such as eventual consistency. In SF,
    you can choose whether a state should be externalized or co-located. Additionally,
    SF takes care of making it highly available and durable.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务时，结果表明每个独立的服务都有自己的状态并独立管理它。当我们必须从不同模块查询数据或将数据存储在多个存储形式中时，就会出现问题。为了解决这些问题，可以使用如最终一致性这样的模式。在SF中，你可以选择一个状态是应该外部化还是共置的。此外，SF会确保它的高可用性和持久性。
- en: Diagnosing and monitoring microservices
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 诊断和监控微服务
- en: 'While the process of monitoring traditional applications is pretty straightforward
    and simple, when you have tens or hundreds of smaller services, making it right
    is not that obvious. This has also other implications such as: What is the actual
    impact if one module goes down? When you have a monolith, you are immediately
    aware of any issues as your application simply stops working properly. With microservices,
    you may find it difficult to react in time if your monitoring does not cover all
    areas of your system. In SF, you have multiple levels of monitoring, which you
    can define as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然监控传统应用程序的过程相对直接和简单，但当你拥有数十个或数百个小型服务时，正确的实现方式并不那么明显。这也带来了其他影响，例如：如果一个模块出现故障，实际影响是什么？当你使用单体架构时，应用程序出现任何问题时，你会立即意识到，因为它会直接停止正常工作。而在微服务架构中，如果监控覆盖不到系统的所有领域，你可能会发现难以及时做出反应。在SF中，你有多层次的监控，可以按如下方式定义：
- en: '**Application monitoring**: This tracks how your application is used.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序监控**：这跟踪你的应用程序的使用情况。'
- en: '**Cluster monitoring**: This allows you to monitor the whole SF cluster, so
    you can verify whether the whole service performs as expected.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集群监控**：这允许你监控整个SF集群，从而验证整个服务是否按预期运行。'
- en: '**Performance monitoring**: Sometimes, it is hard to understand how your application
    behaves if you do not monitor its performance. In SF, it is easier to track resource
    utilization and predict possible issues.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能监控**：有时候，如果不监控应用程序的性能，可能很难理解其行为。在SF中，追踪资源利用率并预测可能的问题更为容易。'
- en: '**Health monitoring**: When working with microservices, it is crucial to know
    whether particular modules are healthy or not. In SF, you can leverage the Health
    API or health reports available in SF Explorer to gain a better insight into the
    current status of your application.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**健康监控**：在使用微服务时，了解特定模块是否健康至关重要。在SF中，你可以利用健康API或在SF Explorer中提供的健康报告，更好地了解你应用程序的当前状态。'
- en: Containers, services, and actors in SF
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SF中的容器、服务和参与者
- en: 'To start with SF, we will cover three main topics, which allow you to divide
    an application logically and physically:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用SF之前，我们将讨论三个主要主题，帮助你在逻辑和物理上划分应用程序：
- en: '**Containers**: Small, deployable components that are isolated from each other
    and enable you to virtualize the underlying operating system'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器**：小型、可部署的组件，彼此隔离，使你能够虚拟化底层操作系统'
- en: '**Reliable services**: One of the programming models available in SD for writing
    and managing stateful and stateless services'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠服务**：SD中可用的一种编程模型，用于编写和管理有状态和无状态的服务'
- en: '**Reliable a****ctors**: Another programming model on top of Reliable services'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠的参与者**：在可靠服务之上的另一种编程模型'
- en: Containers
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器
- en: 'For now, SF supports two types of container:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，SF支持两种类型的容器：
- en: '**Docker **on Linux'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linux上的Docker**'
- en: '**Windows Server **containers on Windows Server 2016'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows Server 2016上的Windows Server容器**'
- en: When working with containers in SF, you can use any programming language or
    framework (as you probably expected), but the most important thing related to
    such a model is the fact that you do not have to stick to built-in programming
    models (Reliable actors and Reliable services). What is more, this approach is
    very similar to running so-called **guest executables**, where you deploy an existing
    executable to SF.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在SF中使用容器时，你可以使用任何编程语言或框架（如你所期望的那样），但与这种模型相关的最重要的事情是，你不必坚持使用内置的编程模型（可靠参与者和可靠服务）。更重要的是，这种方法非常类似于运行所谓的**来宾可执行文件**，你可以将现有的可执行文件部署到SF中。
- en: Creating a cluster
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个集群
- en: Before we start with containers, we will need to create an SF cluster. To do
    so, go to Azure Portal and click + Create a resource. Search for `Service Fabric
    Cluster` and click Create. You will see a familiar screen, where you have to fill
    multiple fields with your cluster configuration. In SF, the process of creation
    is divided into four different steps, which we will cover one by one.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用容器之前，我们需要创建一个 SF 集群。为此，进入 Azure 门户并点击 + 创建资源。搜索 `Service Fabric Cluster` 并点击创建。你将看到一个熟悉的界面，需要在多个字段中填写集群配置。在
    SF 中，创建过程分为四个不同的步骤，我们将逐一介绍。
- en: 'On the very first screen, you will have to enter basic information regarding
    the cluster:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个屏幕上，你需要输入有关集群的基本信息：
- en: '![](img/4566481e-7e38-41ba-9496-d09745398369.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4566481e-7e38-41ba-9496-d09745398369.png)'
- en: There is one field that probably requires a little bit of clarification, namely, Operating
    system. As mentioned in the beginning of this chapter, SF supports both Windows and Linux containers,
    which you can select here. The choice affects both the pricing and available features,
    so you have to be sure which OS you're using.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个字段可能需要稍作澄清，即 操作系统。如本章开头所提到，SF 支持 Windows 和 Linux 容器，你可以在此处进行选择。选择会影响定价和可用功能，因此你必须确认自己使用的是哪个操作系统。
- en: 'Once you are satisfied with the setup, you can proceed to the next screen:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对设置满意，就可以继续到下一个屏幕：
- en: '![](img/f63ee24d-2611-4248-b7cc-016f6e794c8c.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f63ee24d-2611-4248-b7cc-016f6e794c8c.png)'
- en: 'Now we begin with the actual cluster configuration. The first thing you have
    to do is select Node type count. To select the correct version, you have to understand
    what this actually means. This property defines the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始实际的集群配置。你需要做的第一件事是选择 Node 类型计数。为了选择正确的版本，你需要理解它的实际含义。此属性定义了以下内容：
- en: Virtual machine (VM) sizes
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟机（VM）大小
- en: The number of VMs
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟机的数量
- en: Properties of VMs
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟机的属性
- en: So, to cut a long story short—if you need two different types of machine (because,
    for instance, you have a lightweight frontend and heavy backend), you will choose
    two different node types.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，简而言之——如果你需要两种不同类型的机器（例如，你有一个轻量级前端和一个重量级后端），你将选择两种不同的节点类型。
- en: Remember that you can always add or remove a node after cluster creation, but
    you will always need to have at least one.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在集群创建后，你始终可以添加或移除节点，但你总是需要至少保留一个节点。
- en: On the Node type configurationblade, you will have to choose the size of virtual
    machines and their capacity and select a name for the node. You can also configure
    advanced options but, as we are just starting with SF, I would not recommend changing
    anything there.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node 类型配置面板上，你需要选择虚拟机的大小及其容量，并为节点选择一个名称。你还可以 配置高级选项，但由于我们刚刚开始使用 SF，我不建议在那里更改任何内容。
- en: Using fewer than five virtual machines initially designates a cluster as a test
    cluster. The reason why SF requires you to run five or more VMs is to make sure
    that your solution is more resilient to simultaneous failures. You still can use
    a test cluster to run production workloads, but it is not recommended.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用少于五台虚拟机最初会将集群标记为测试集群。SF 要求你运行五台或更多虚拟机的原因，是为了确保你的解决方案能更好地应对 同时 故障。你仍然可以使用测试集群来运行生产工作负载，但不推荐这么做。
- en: 'Now click OK to proceed. The last but one screen allows you to configure the
    security features of your cluster:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在点击 OK 继续。倒数第二个屏幕允许你配置集群的安全功能：
- en: '![](img/5a461416-515c-4e6f-ad5a-403141143d53.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a461416-515c-4e6f-ad5a-403141143d53.png)'
- en: You can choose either the Basic or Custom configuration type—the difference
    between them is that, when using Basic, a certificate will be created for you
    and, when choosing Custom, you can enter certificate information on your own.
    Additionally, SF will require you to select a key vault (or create a new one)
    to store a certificate.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择 Basic 或 Custom 配置类型——它们的区别在于，使用 Basic 时，系统会为你创建证书，而选择 Custom 时，你可以自己输入证书信息。此外， SF 要求你选择一个密钥保管库（或创建一个新的）来存储证书。
- en: We will not cover Azure key vaults in this book. If you would like to know more
    about this service, please take a look at the documentation—[https://docs.microsoft.com/en-us/azure/key-vault/](https://docs.microsoft.com/en-us/azure/key-vault/)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不会涵盖 Azure 密钥保管库。如果你想了解更多关于该服务的信息，请查看文档——[https://docs.microsoft.com/en-us/azure/key-vault/](https://docs.microsoft.com/en-us/azure/key-vault/)
- en: 'When everything is set and ready, you can click OK, and you will see the final
    screen with a summary of the configuration of your cluster. Validate all of the
    information displayed there and, if you are ready to create the cluster, click
    on Create. When you go to the resource group you selected while creating the cluster,
    you should see a similar setup to mine:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切设置好并准备就绪时，你可以点击“确定”，然后你将看到包含集群配置摘要的最终屏幕。验证显示的所有信息，如果准备好创建集群，点击“创建”。当你进入创建集群时选择的资源组，你应该会看到与我类似的设置：
- en: '![](img/43a7b959-18bd-466d-99c9-459d5bebdc49.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43a7b959-18bd-466d-99c9-459d5bebdc49.png)'
- en: 'As you can see, it contains many different services already:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它已经包含了许多不同的服务：
- en: '**Virtual machine scale set**: To make sure you can easily scale out, SF uses the
    VMs scale set to automate the whole process'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟机规模集**：为了确保你能轻松扩展，SF 使用虚拟机规模集来自动化整个过程'
- en: '**Service Fabric ****cluster**: The actual SF service'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Service Fabric 集群**：实际的 SF 服务'
- en: '**Load balancer**: To distribute the load between your machines'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载均衡器**：在你的机器之间分配负载'
- en: '**Public IP address**: So your application is available publicly'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共 IP 地址**：使你的应用程序可公开访问'
- en: '**Storage account**: For storing data'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储账户**：用于存储数据'
- en: '**Virtual network**: To secure and ease communication between machines, SF utilizes Azure
    Virtual Network to couple machines in the VMs scale set'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟网络**：为了确保机器之间的安全和便捷的通信，SF 使用 Azure 虚拟网络将虚拟机规模集中的机器连接起来'
- en: Now that we have a cluster configured and running, we can proceed to deploy
    the Docker container.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置并运行了一个集群，可以继续部署 Docker 容器。
- en: Deploying a container
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署容器
- en: To use Docker images in SF, we will need a registry in Azure Container Registry.
    You can go back to [Chapter 3](51d6dd91-dc4f-4c18-af05-e6ddc1b552fc.xhtml), *Deploying
    Web Applications as Containers*, where I described in detail how to work with
    ACR and Docker.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 SF 中使用 Docker 镜像，我们需要在 Azure 容器注册表中有一个注册表。你可以回到 [第 3 章](51d6dd91-dc4f-4c18-af05-e6ddc1b552fc.xhtml)，*将
    Web 应用程序部署为容器*，在那里我详细描述了如何使用 ACR 和 Docker。
- en: 'Now we will try to deploy a simple Python application—to start, we will need
    Dockerfile, of course:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将尝试部署一个简单的 Python 应用程序——首先，我们当然需要 Dockerfile：
- en: '[PRE0]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Additionally, let''s create a Python application, which will display simple
    text:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将创建一个 Python 应用程序，显示简单的文本：
- en: '[PRE1]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, run the `docker build` command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行 `docker build` 命令：
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will be able to test and run it locally by typing the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将能够通过输入以下命令在本地进行测试和运行：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see, all is working correctly—we can proceed by pushing an image
    and deploying it:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，一切正常工作——我们可以继续推送镜像并部署它：
- en: '![](img/a760e192-3e6a-4ea1-a7cf-ad93d14f14da.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a760e192-3e6a-4ea1-a7cf-ad93d14f14da.png)'
- en: To push a container image, you will need of course a registry for it. If you
    want to use Azure Container Registry, please refer to the previous chapter for
    detailed instructions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要推送容器镜像，当然你需要一个注册表。如果你想使用 Azure 容器注册表，请参考前一章的详细说明。
- en: 'For now, you will need three Dockercommands:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将需要三个 Docker 命令：
- en: '`docker login`: To authenticate in ACR'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker login`：用于在 ACR 中进行身份验证'
- en: '`docker tag`**:** To create an alias of an image and put it in the correct
    namespace'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker tag`**:** 创建镜像的别名，并将其放入正确的命名空间'
- en: '`docker push`: To deploy an image to the registry'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker push`：将镜像部署到注册表'
- en: 'The following is the full syntax:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完整的语法：
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Packaging a service
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包服务
- en: 'To package our service, we will use Yeoman with the SF Yeoman container generator.
    To do so, you have to install them—in your command line, execute the following
    two commands:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打包我们的服务，我们将使用 Yeoman 与 SF Yeoman 容器生成器。为此，你需要先安装它们——在命令行中执行以下两个命令：
- en: '[PRE5]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will need one more thing—because the container image will be fetched from
    ACR, we have to configure its credentials in `ApplicationManifest.xml`.While the
    username can be traditionally found on the Overview blade of Container Registry,
    to find a password you have to run these two commands:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要做一件事——因为容器镜像将从 ACR 获取，所以我们必须在 `ApplicationManifest.xml` 中配置其凭证。用户名可以在容器注册表的概览面板中找到，而密码则需要运行以下两个命令：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we will need to update the manifest generated by Yeoman so it uses our
    credentials:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要更新 Yeoman 生成的清单，以便它使用我们的凭证：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, log in to your cluster using the following command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用以下命令登录到你的集群：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Finally, just run the `install.ps1`file Yeoman generated and wait a moment—your
    application image should be deployed to the SF cluster in the cloud and fully
    working.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，运行Yeoman生成的`install.ps1`文件并等待片刻——你的应用程序镜像应该会被部署到云中的SF集群，并且完全可用。
- en: To get a certificate, you can download it from the Certificates blade in key
    vault.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 若要获取证书，你可以从密钥保管库中的证书选项卡下载。
- en: Reliable services
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可靠服务
- en: In this section, we will try to create both stateless and stateful services
    using SF. This time, we will use Visual Studio to create a C# application and
    deploy it to our cluster. You can also start with Reliable serviceson Linux, but
    this will not be covered in this book. Refer to the *Further reading*section for
    links to the appropriate documentation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们将尝试使用SF创建无状态和有状态服务。这次，我们将使用Visual Studio创建一个C#应用程序，并将其部署到我们的集群。你也可以从Linux上的可靠服务开始，但这本书不会覆盖这一部分。请参考*进一步阅读*部分，了解相关文档链接。
- en: Creating a SF application
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个SF应用程序
- en: 'When you open a Visual Studio instance, go to File | New Project. In the new
    window search for Visual C# | Cloud templates; you should be able to find the Service
    Fabric Application option:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开Visual Studio实例时，进入文件 | 新建项目。在新窗口中搜索Visual C# | 云模板；你应该能够找到Service Fabric
    Application选项：
- en: '![](img/bc14a362-7565-4abe-92b3-053f7f823991.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc14a362-7565-4abe-92b3-053f7f823991.png)'
- en: If you cannot find this option, make sure you have installed the SF SDK.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你找不到这个选项，请确保你已经安装了SF SDK。
- en: 'On the next screen, you will see many different options, most of which we will
    discuss later. For now, select Stateless Serviceand click OK:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一屏幕上，你将看到许多不同的选项，我们稍后会讨论其中的大多数。现在，选择无状态服务（Stateless Service）并点击确定（OK）：
- en: '![](img/13a5a698-e9a3-4ffe-a318-6542987ed80b.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13a5a698-e9a3-4ffe-a318-6542987ed80b.png)'
- en: 'After a moment you should be able to see that a stateless service template
    has been built with SF. You can now press *F5*to see how it works with all the
    default values:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 稍等片刻后，你应该能够看到一个无状态服务模板已经通过SF构建完成。你现在可以按*F5*来查看它在所有默认值下的工作情况：
- en: '![](img/b393b48b-2c84-4a90-8a87-383bfbda32a5.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b393b48b-2c84-4a90-8a87-383bfbda32a5.png)'
- en: If you have trouble starting your local SF instance, make sure you have started
    Visual Studio as an administrator.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在启动本地SF实例时遇到问题，请确保你以管理员身份启动了Visual Studio。
- en: 'As you can see, each second a message—`Working-{N}`—is published. Take a look
    at the `RunAsync()`method:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每秒都会发布一条消息——`Working-{N}`。请看一下`RunAsync()`方法：
- en: '[PRE9]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You will see that it is the source of those messages. In fact, it is the starting
    point of your service, which is called when it starts. It also accepts one parameter, `cancellationToken`, which
    is here to inform you about any of the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到它是这些消息的来源。事实上，它是你的服务的起点，当服务启动时会调用它。它还接受一个参数，`cancellationToken`，用于告知你以下任意一种情况：
- en: There was a fatal error in your code and the service is currently in the invalid
    state
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的代码中发生了致命错误，当前服务处于无效状态
- en: There was a hardware outage in a cluster
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群中发生了硬件故障
- en: There is an ongoing upgrade
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在进行升级
- en: The current instance of service is no longer required
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前的服务实例不再需要
- en: Remember to honor that `RunAsync()`should return a task. The system will wait
    until the service finishes executing, so always try to do it as quickly as possible
    if you discover that cancellation was requested.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 记得确保`RunAsync()`方法应该返回一个任务。系统会等待直到服务执行完毕，因此如果你发现请求了取消操作，务必尽可能快速地完成。
- en: 'Let''s now try to add also a stateful service—to do so, add a new Service Fabric
    Applicationproject to the solution, but this time select Stateful Service:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们尝试添加一个有状态服务——为此，向解决方案中添加一个新的Service Fabric应用程序项目，但这次选择有状态服务（Stateful Service）：
- en: '![](img/262514e8-d2e8-4967-8b99-4a5cd0bc75b8.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/262514e8-d2e8-4967-8b99-4a5cd0bc75b8.png)'
- en: 'If you compare the stateless `RunAsync()`with the stateful one, you will see
    many differences:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将无状态的`RunAsync()`与有状态的进行对比，你将看到许多不同之处：
- en: '[PRE10]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The most important one is a direct reference to state—in a stateful service,
    we have the state manager, which enables you to query state and execute actions
    within transactions. Here, in the previous example, we fetch a dictionary of the `IReliableDictionary<>` type
    from it—it is a reliable collection that stores data and replicates it to other
    machines. In fact, it is the same dictionary as, for example, `IDictionary<>`,
    but this time operations on a collection are asynchronous because data has to
    be persisted on disk.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是直接引用状态——在有状态服务中，我们有状态管理器，它使你能够查询状态并在事务中执行操作。在之前的例子中，我们从中获取了一个 `IReliableDictionary<>`
    类型的字典——这是一个可靠的集合，用来存储数据并将其复制到其他机器上。实际上，它与 `IDictionary<>` 是相同的字典，但这次对集合的操作是异步的，因为数据必须持久化到磁盘上。
- en: Remember that everything you store in the state manager has to be serializable.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你存储在状态管理器中的所有内容都必须是可序列化的。
- en: 'When you start your application, you will see that both services are running
    at the same time:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动应用程序时，你会看到两个服务同时运行：
- en: '![](img/2ad502eb-f52e-4249-bc9f-43ec34221e3c.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ad502eb-f52e-4249-bc9f-43ec34221e3c.png)'
- en: Now we would like to publish our simple application to Azure to see whether
    it really works.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想将我们的简单应用程序发布到 Azure，看看它是否真的有效。
- en: Deploying an application to the cloud
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将应用程序部署到云端
- en: 'If you take a look, you will see that our solution contains now three projects:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看一下，你会看到我们的解决方案现在包含了三个项目：
- en: Stateless service
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态服务
- en: Stateful service
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有状态服务
- en: SF project
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SF 项目
- en: 'Now right-click on the SF project and click the Publish...option:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在右键点击 SF 项目，点击“发布...”选项：
- en: '![](img/90bb0bc6-4fe0-474a-8df8-6d9fbccd3faf.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90bb0bc6-4fe0-474a-8df8-6d9fbccd3faf.png)'
- en: 'On the new screen, you can configure things such as Target profileor Application
    Parameters File, but the most interesting one is Connection Endpoint, which is
    empty now. In fact, you cannot proceed without selecting one option, so let''s
    open the drop-down menu and see our options. Among the available options, you
    will have the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在新屏幕上，你可以配置一些内容，如目标配置文件或应用程序参数文件，但最有趣的是连接端点，它现在是空的。实际上，如果不选择一个选项，你无法继续操作，所以让我们打开下拉菜单，看看我们的选项。在可用选项中，你会看到以下内容：
- en: Local cluster
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地集群
- en: Create New Cluster
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新集群
- en: Use Trial Cluster
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用试用集群
- en: Refresh
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 刷新
- en: While the local/new cluster option is self-explanatory, you might wonder what
    the Trial option is. When you select it, you will be given an option to sign-in
    to so-called **party clusters**. These are free-of-charge SF clusters, which you
    can use to play with this service a little bit and learn how it works. You do
    not need a subscription, but after an hour the cluster will be taken down. Because
    we are learning about services in Azure in this book, I will not use that option,
    but feel free to utilize it later if you decide you want to know much more about SF than
    this short chapter was able to provide.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本地/新集群选项不言自明，但你可能会想知道什么是“试用”选项。当你选择它时，你将获得一个选项来登录到所谓的 **派对集群**。这些是免费的 SF 集群，你可以用它们来稍微玩一下这个服务，了解它的工作原理。你不需要订阅，但一个小时后集群将被关闭。因为我们在本书中学习的是
    Azure 中的服务，我不会使用该选项，但如果你决定深入了解 SF，而不仅仅是本章所能提供的内容，随时可以使用它。
- en: When you select the Create New Clusteroption, a new screen will appear with
    the whole SF cluster configuration. It is very similar to the one you can see
    in the portal—it has the same sections, such as Cluster, Certificate, and VM Detail.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择“创建新集群”选项时，屏幕上会出现整个 SF 集群配置。这与门户中看到的非常相似——它具有相同的部分，如集群、证书和虚拟机详情。
- en: Creating an SF cluster from Visual Studio has one downside—you do not know what
    the recommended values are and have no direct reference to the documentation.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Visual Studio 创建 SF 集群有一个缺点——你不知道推荐的值是什么，也没有直接参考文档。
- en: 'The following shows my configuration from the first tab:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我从第一个标签页中的配置：
- en: '![](img/acaa76fb-9dfb-4b6d-95cc-85e366621bfa.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/acaa76fb-9dfb-4b6d-95cc-85e366621bfa.png)'
- en: 'As you can see, I set the Number of nodes to `1`—this is because I am not planning
    to deploy a production workload and do not need two different characteristics
    of virtual machines as both my services are more or less the same. When you click Next,
    you will see the second tab, where you will specify a certificate password. A
    certificate will be automatically created and imported if you leave the Import
    certificateoption checked:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我将节点数量设置为`1`——这是因为我不打算部署生产工作负载，并且不需要两种不同特征的虚拟机，因为我的两个服务基本相同。当您点击“下一步”时，您将看到第二个标签，在该标签中您将指定证书密码。如果您保留选中“导入证书”选项，则会自动创建并导入证书：
- en: '![](img/c888da57-7ae9-46d4-8cc4-fc7effb6f4db.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c888da57-7ae9-46d4-8cc4-fc7effb6f4db.png)'
- en: Certificates in SF are a way to secure both node-to-node and client-to-node
    communication. These are X.509 certificates and, what is more, it is important
    to keep at least one valid—failing to do so can even make the cluster stop functioning.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在SF中，证书是确保节点到节点以及客户端到节点通信安全的一种方式。这些是X.509证书，更重要的是，至少要保持一个有效证书——如果证书无效，甚至可能导致集群停止工作。
- en: 'The next tab is VM Detail, where you can specify details of machines running
    your cluster. After providing a User name and Password, you have to choose which
    operating system will be used to run SF and the size of each VM. After entering
    all the required information, you can click on Create:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个标签是VM详细信息，您可以在其中指定运行集群的机器的详细信息。在提供了用户名和密码后，您需要选择将用于运行SF的操作系统以及每个虚拟机的大小。输入所有必需信息后，您可以点击“创建”：
- en: '![](img/0f419abf-58e7-443f-ada4-3f1ec783431e.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f419abf-58e7-443f-ada4-3f1ec783431e.png)'
- en: 'Deploying an SF cluster can take a while so be patient. Once it is finished,
    you can take a look at it in Azure Portal to see that all parts of the whole ecosystem
    are deployed. However, when you enter the SF cluster in Azure, you will see that
    it has both `0` applications and `0` nodes attached. This is because we just created
    it without deploying anything. This is why we have to go back to Visual Studio
    and click Publish once more, this time selecting a cluster we just created:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 部署SF集群可能需要一些时间，所以请耐心等待。一旦完成，您可以在Azure门户中查看，确认整个生态系统的所有部分都已部署。然而，当您进入Azure中的SF集群时，您会看到它没有任何应用程序或节点附加。这是因为我们刚刚创建了它，并没有部署任何内容。因此，我们需要返回Visual
    Studio，再次点击“发布”，这次选择我们刚刚创建的集群：
- en: '![](img/cbcd32d1-0685-40f9-af53-2e855db9362c.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cbcd32d1-0685-40f9-af53-2e855db9362c.png)'
- en: 'Now, let''s go to Azure and explore our application. On the Overview blade
    of our SF instance, there is the Explorer button:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们去Azure并探索我们的应用程序。在我们的SF实例的概览页面上，有一个“Explorer”按钮：
- en: '![](img/86aee828-8e92-4f0e-95e8-a7abc002d786.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86aee828-8e92-4f0e-95e8-a7abc002d786.png)'
- en: 'When you click on it, new windows will open in your browser and you will be
    asked to select a certificate, which will be used to secure a connection. Remember
    to select the one you created and exported during SF cluster creation. After accepting
    it, you should be able to see Service Fabric Explorer:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击它时，新的窗口将在您的浏览器中打开，您将被要求选择一个证书，该证书将用于安全连接。记得选择在SF集群创建过程中创建并导出的那个证书。接受后，您应该能够看到Service
    Fabric Explorer：
- en: '![](img/3fadbcd5-d990-4d20-8a73-ea9314d2fe13.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3fadbcd5-d990-4d20-8a73-ea9314d2fe13.png)'
- en: Congratulations—you have just created your very first microservice architecture
    using SF!
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜——您刚刚使用SF创建了您的第一个微服务架构！
- en: Reliable actors
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可靠演员
- en: 'In the previous section, we created an application that is made up of two services—a
    stateful and stateless one. In SF, there are many different frameworks to build
    your system—another one is Reliable actors. It is designed for creating a platform
    of distributed services that can work concurrently and independently—because each
    actor is isolated, an issue with one instance does not affect others working at
    the same moment. You may wonder when to choose Reliable services and when the
    best option is Reliable Actors? The rule of thumb could be defined as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们创建了一个由两个服务组成的应用程序——一个有状态服务和一个无状态服务。在SF中，有许多不同的框架来构建系统——另一个是可靠演员。它旨在创建一个可以并发和独立运行的分布式服务平台——因为每个演员是隔离的，一个实例的问题不会影响其他正在运行的实例。您可能会想知道什么时候选择可靠服务，什么时候选择可靠演员？经验法则可以这样定义：
- en: If you require to divide your work among multiple workers (such as hundreds
    or thousands), choose Reliable Actors
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您需要将工作分配给多个工作者（例如成百上千个），请选择“可靠演员”
- en: If you want to isolate your work and expect a single-threaded environment for
    simplicity, choose Reliable Actors
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想隔离你的工作并希望一个单线程环境以简化操作，选择可靠演员
- en: If your business domain expects work to be performed in the transaction, choose Reliable
    Services
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的业务领域要求在事务中执行工作，选择可靠服务
- en: If your service has to be reliable and highly available, choose Reliable Services
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的服务必须是可靠且高可用的，选择可靠服务
- en: Of course, the aforementioned reasons do not cover all possible scenarios, but
    you should be able to understand the difference by now. In general, you cannot
    expect that actors will be very durable as the idea is to spawn new ones and forward
    the workload to them instead of ensuring that they can work indefinitely.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，上述原因并不能涵盖所有可能的场景，但你现在应该能够理解它们之间的区别了。一般来说，你不能期望演员们会非常耐用，因为其核心思想是生成新的演员，并将工作负载转移给它们，而不是确保它们能够无限期地工作。
- en: Creating a project with actors
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个演员项目
- en: 'We will start our journey with Reliable actors by creating a brand new project
    in Visual Studio—for this, click on File | New projectand once more select an
    SF template. On the New Service Fabric Servicescreen, select the Actor Servicetemplate
    and click OK:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在 Visual Studio 中创建一个全新的项目来开始我们与可靠演员的旅程——为此，点击文件 | 新建项目，再次选择 SF 模板。在“新建服务”屏幕中，选择“演员服务”模板并点击确定：
- en: '![](img/e7f8d6c5-6fe8-4e26-95d2-28458cf6c95d.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e7f8d6c5-6fe8-4e26-95d2-28458cf6c95d.png)'
- en: 'After your project is initialized, you will see that it is a bit different
    from the one for Reliable services—what is most important is that it now contains
    the `.Interfaces`project, which for now contains only one file with the following
    content:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目初始化后，你会发现它与可靠服务的项目略有不同——最重要的是，它现在包含了 `.Interfaces` 项目，目前该项目仅包含一个文件，内容如下：
- en: '[PRE11]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It will act as our communication point between the actor and its clients. You
    may think of it as a contracts aggregator. Now, check the main actor project (in
    my case it is `ReliableActor`)—you will find there the current implementation
    of the previous interface. The following is the current code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 它将作为演员和其客户端之间的通信点。你可以把它看作是一个契约聚合器。现在，检查一下主要演员项目（在我的例子中是 `ReliableActor`）——你会在那里找到之前接口的当前实现。以下是当前代码：
- en: '[PRE12]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Each actor implementation is decorated with the `[StatePersistence]`attribute.
    It has three different options:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 每个演员实现都带有 `[StatePersistence]` 特性。它有三种不同的选项：
- en: 'Persisted: Here the state is persisted to disk and replicated to replicas (three
    or more). It is the most durable option and prevents you from losing it even during
    a complete cluster failure.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久化：在这里，状态会被持久化到磁盘并复制到副本（三个或更多）。这是最耐用的选项，即使在整个集群故障的情况下也能防止丢失数据。
- en: Volatile: Instead of persisting a state to disk, it is only replicated and held
    in memory on three or more replicas. This is the less durable option, similar
    to holding your data only in RAM memory, which will be lost once power is lost.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易失性：与其将状态持久化到磁盘，不如将其复制并存储在三个或更多副本的内存中。这是一个较不耐用的选项，类似于仅将数据保存在 RAM 中，一旦断电，数据会丢失。
- en: None: If you do not need to persist in your state, you can use this option.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无：如果你不需要持久化状态，可以选择此选项。
- en: There is no best option here—it all depends on the requirements of your actors.
    Please note one more thing—an actor itself is not limited to some kind of "hard"
    contract; you define the code all by yourself and SF will do its best to replicate
    it, persist state (if needed), and scale out to meet your demands. Currently,
    we have only a worker—we also need a client to test our service.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里没有最佳选择——一切取决于你的演员需求。请再注意一点——演员本身并不局限于某种“硬性”契约；你可以自己定义代码，SF 会尽最大努力复制它，持久化状态（如有需要），并进行横向扩展以满足你的需求。目前，我们只有一个工作者——我们还需要一个客户端来测试我们的服务。
- en: Creating an actor's client
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个演员的客户端
- en: 'To create a client, we will use the most traditional Console Application.Once
    more, click on File | New project and search for it or just right-click on the
    solution and click on Add | New project. You will have to add two more things
    before we write some code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个客户端，我们将使用最传统的控制台应用程序。再次点击文件 | 新建项目并搜索，或者直接右键点击解决方案并点击添加 | 新建项目。在我们编写代码之前，你需要再添加两个内容：
- en: Add a reference to our `.Interfaces`project as we have to know which methods
    we would like to call
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加对 `.Interfaces` 项目的引用，因为我们必须知道要调用哪些方法
- en: Install the `Microsoft.ServiceFabric.Actors` package
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 `Microsoft.ServiceFabric.Actors` 包
- en: 'We will write a simple application that calls our actor, fetches the current
    count value, and updates it. The following shows my example code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个简单的应用程序，该应用程序调用我们的 Actor，获取当前的计数值并更新它。以下是我的示例代码：
- en: '[PRE13]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As you can see, I am doing three things:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我做了三件事：
- en: I am getting a reference to my actor service by using the `fabric` protocol
    and a specific interface I created
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我通过使用`fabric`协议和我创建的特定接口来获取对我的 Actor 服务的引用。
- en: To obtain the count value, I am calling the `GetCountAsync()`method on my reference
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了获取计数值，我在我的引用上调用了`GetCountAsync()`方法。
- en: I am updating state by calling `SetCountAsync()`
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我通过调用`SetCountAsync()`来更新状态。
- en: 'The following shows the result of running both actor and client:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了同时运行 Actor 和客户端的结果：
- en: '![](img/d2912129-005c-4c3a-b185-0498b5e4826a.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2912129-005c-4c3a-b185-0498b5e4826a.png)'
- en: Great—all works as expected. You may wonder how actor instances are distributed
    in the SF cluster and how we achieve the distribution of hundreds of instances
    of them. Well, it is all handled by SF runtime by partitioning instances and attaching
    them to different nodes on a cluster. Thanks to that, you can expect that the
    workload will be balanced—what is more, you can reference an actor by its ID (as
    opposed to the presented method, `ActorId.CreateRandom()`), but it is not always
    recommended as you have to ensure you are not overloading one actor.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 很好——一切按预期工作。你可能会好奇 Actor 实例是如何在 SF 集群中分配的，以及我们是如何实现数百个实例的分配的。其实，这一切都由 SF 运行时处理，它通过对实例进行分区并将它们附加到集群中的不同节点来实现。正因为如此，你可以期待负载会得到平衡——更重要的是，你可以通过
    Actor 的 ID 来引用它（与展示的`ActorId.CreateRandom()`方法不同），但并不总是推荐这么做，因为你必须确保不会使某个 Actor
    超负荷。
- en: Communication between services
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务之间的通信
- en: You currently know how to work with SF using Reliable services and Reliable
    actors. The next important topic refers to communication between each instance
    of a service. As we discussed at the beginning of this chapter, the best option
    when building your microservices is to create a platform that will be agnostic
    when it comes to choosing what is the best way to communicate and accept incoming
    requests. In SF, you do not have a single way to exchange messages—instead you
    are provided with a complete framework to do it your way. In this section, we
    will focus on building a simple communication channel for your services.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经知道如何使用 SF（服务框架）来处理可靠服务和可靠 Actor。下一个重要话题是关于服务实例之间的通信。正如我们在本章开始时讨论的，构建微服务时最好的选择是创建一个平台，使其在选择最佳的通信方式和接受传入请求时保持中立。在
    SF 中，你并没有单一的消息交换方式——相反，它为你提供了一个完整的框架，让你可以按照自己的方式进行操作。在这一部分，我们将重点构建一个简单的通信通道来支持你的服务。
- en: Creating a communication channel
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建通信通道
- en: 'To create a channel, you will need to implement the following interface:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个通道，你需要实现以下接口：
- en: '[PRE14]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, there is no information regarding technology or the framework
    used—it is up to you. We will try to open the HTTP protocol in our service. Since
    we cannot cover all types of service in this book, we will focus on the stateless
    service. If you open the project from the section about it, in the main file of
    your service, you can find the following method:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，关于使用的技术或框架没有任何信息——这完全取决于你。我们将尝试在我们的服务中开启 HTTP 协议。由于本书无法覆盖所有类型的服务，我们将重点介绍无状态服务。如果你从关于它的章节打开项目，在服务的主文件中，你可以找到以下方法：
- en: '[PRE15]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Currently, it returns an empty array—we would have to provide a custom implementation
    of `ServiceInstanceListener`and add it here. While it is, of course, possible
    to do so, it would take too much time to describe it in detail; instead, we use
    a NuGet package, which has the correct implementation of such a listener and is
    built using ASP.NET Core.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，它返回的是一个空数组——我们需要提供一个自定义的`ServiceInstanceListener`实现并将其添加到这里。虽然当然可以这么做，但描述它的细节会花费太多时间；因此，我们使用一个
    NuGet 包，它包含了一个正确实现的监听器，并且是基于 ASP.NET Core 构建的。
- en: Currently, it is possible to use Http Sys or Kestrel to resolve communication.
    Feel free to experiment as those technologies differ a little and are always a
    substitute for each other (for example, Http Sys is currently not designed for
    stateful services).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，可以使用 Http Sys 或 Kestrel 来解决通信问题。请随意进行实验，因为这些技术有所不同，且它们总是可以互相替代（例如，Http Sys
    目前并不适用于有状态服务）。
- en: 'For this exercise, please install the following package: `Microsoft.ServiceFabric.AspNetCore.
    HttpSys`. Once you have it, you can modify the `CreateServiceInstanceListeners()`method
    as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，请安装以下包：`Microsoft.ServiceFabric.AspNetCore.HttpSys`。安装后，你可以如下修改`CreateServiceInstanceListeners()`方法：
- en: '[PRE16]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you can see, it provided the full implementation of a listener and a pipeline
    for handling a request. You will also need to implement the `Startup` class, which
    will handle communication:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它提供了完整的监听器实现和处理请求的管道。你还需要实现`Startup`类，来处理通信：
- en: '[PRE17]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This may look familiar to you as this is a simple ASP.NET Core stack, which
    you would implement in the same manner, creating a web application not hosted
    in SF. Only one thing remains for now—we have to modify `ServiceManifest.xml` and
    specify that our endpoint is exposed by a service:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来可能很熟悉，因为这是一个简单的ASP.NET Core堆栈，你会以相同的方式实现，创建一个不托管在SF中的Web应用程序。目前只有一件事需要修改——我们必须修改`ServiceManifest.xml`并指定我们的端点是由服务暴露的：
- en: '[PRE18]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Remember that the endpoint name must match the one you defined in your code.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，端点名称必须与在代码中定义的名称匹配。
- en: 'Now, when you run your application, you should be able to call it by using
    the exposed endpoint, which can be found in Service Fabric Explorer:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行应用程序时，你应该能够通过使用暴露的端点来调用它，该端点可以在Service Fabric Explorer中找到：
- en: '![](img/78fbe318-6fe3-4a32-9784-b3d07b56a62e.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/78fbe318-6fe3-4a32-9784-b3d07b56a62e.png)'
- en: 'The following is the result of calling my service from the Postman application:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从Postman应用程序调用我的服务的结果：
- en: '![](img/7deca25b-2c8a-436e-8b28-33cd7059e0c2.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7deca25b-2c8a-436e-8b28-33cd7059e0c2.png)'
- en: 'Now the question is: What you can do with such a feature? In fact, there are
    many possibilities—you can exchange messages between services, you can query a
    service for the status of a task currently performed, or you can change a state
    so a different path will be chosen when running a workload. This is a very powerful
    functionality and, in addition to all of the advantages that SF brings to distributed
    systems, you can be sure that your communication is reliable and fully under your
    control.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是：你可以利用这样的功能做些什么？实际上，有很多可能性——你可以在服务之间交换消息，可以查询某个服务当前执行的任务状态，或者可以更改某个状态，以便在运行工作负载时选择不同的路径。这是一个非常强大的功能，除了SF为分布式系统带来的所有优势外，你还可以确保你的通信是可靠的，并且完全在你的控制之下。
- en: Clusters in SF
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SF中的集群
- en: We have talked about clusters in SF, but how can you really understand such
    a concept in that service? You probably remember that, during the creation of
    a cluster, we had to choose both node types and their characteristics—the number
    of VMs and their type. If you choose to have three nodes with five machines in
    each one, you will end up with a cluster of fifteen machines in total. SF automatically
    balances it, so if you are changing its size, all services will be redeployed
    to achieve maximum utilization. In this chapter, we will talk a little about security,
    available features, and scalability.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了SF中的集群，但你如何真正理解在该服务中的这一概念呢？你可能还记得，在创建集群时，我们需要选择节点类型及其特性——虚拟机的数量及其类型。如果你选择有三个节点，每个节点包含五台机器，那么你最终会得到一个总共十五台机器的集群。SF会自动进行负载均衡，因此如果你改变集群大小，所有服务将会重新部署，以达到最大利用率。本章将简要讨论安全性、可用功能和可扩展性。
- en: 'The following is a conceptual diagram of a cluster organization:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是集群组织的概念图：
- en: '![](img/7cb6390b-610a-4fd4-8d3a-ddfbb6a44ae0.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7cb6390b-610a-4fd4-8d3a-ddfbb6a44ae0.png)'
- en: Cluster security
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集群安全
- en: If you go back to the creation of a cluster, you will notice that we always
    had to create or import a certificate—without it, there was no way to proceed.
    You have to remember that it is your responsibility to secure your environment
    and prevent unauthorized access. As the documentation states, it is impossible
    to create an insecure cluster—this is, of course, true. However, if you expose
    your endpoint (especially in production workloads) publicly, there is always the
    possibility that somebody will figure it out and start abusing it.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回到集群的创建过程，你会注意到我们总是需要创建或导入证书——没有它，就无法继续。你必须记住，确保你的环境安全并防止未经授权的访问是你自己的责任。正如文档所述，创建不安全的集群是不可能的——这当然是正确的。然而，如果你将端点公开暴露（特别是在生产工作负载中），总有可能有人会发现它并开始滥用。
- en: Node-to-node security
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点间安全
- en: 'Let''s assume that you have three different nodes for different types of workload:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有三个不同的节点，分别用于不同类型的工作负载：
- en: '![](img/40fd6dd9-2024-4d7f-b431-b4b048ec93bf.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40fd6dd9-2024-4d7f-b431-b4b048ec93bf.png)'
- en: 'Those nodes could be exposed (or not exposed) to the external network. Now,
    you may wonder how SF ensures that communication is handled in a secure manner.
    In fact, there are two possibilities:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这些节点可能会暴露（或不暴露）给外部网络。现在，你可能会想知道 SF 是如何确保通信以安全的方式处理的。实际上，有两种可能性：
- en: '**Certificate security**: In such a scenario, a client (node) attaches credentials
    to each request and signs a message with the private key'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**证书安全性**：在这种场景下，客户端（节点）会将凭证附加到每个请求中，并用私钥签名消息'
- en: '**Windows security**: Based on the Kerberos protocol'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows 安全性**：基于 Kerberos 协议'
- en: The final solution depends on your actual needs.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的解决方案取决于你的实际需求。
- en: Client-to-node security
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端与节点的安全性
- en: 'Besides communicating within a cluster, you may need to allow authorized users
    to exchange messages with individual nodes. In fact, this is cover by similar
    security options as **node-to-node **security—here you can choose between certificates
    and **Active Directory** (**AD**) security. What is the advantage of using AD
    in that scenario? There is one very important aspect—in most cases, you do not
    want to share certificates with your client (this could also be cumbersome with
    a large number of them). AD security can be set in the ARM template by providing
    additional options:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在集群内进行通信外，你还可能需要允许授权用户与单个节点交换消息。事实上，这与 **节点间安全性** 相似——在这种情况下，你可以选择使用证书或 **Active
    Directory**（**AD**）安全性。在这种场景下使用 AD 的优势是什么？有一个非常重要的方面——在大多数情况下，你不想与客户端共享证书（尤其是当证书数量很多时，这会变得非常繁琐）。AD
    安全性可以通过在 ARM 模板中提供额外的选项进行设置：
- en: '[PRE19]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Scaling
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展
- en: 'Scaling is one of the most important features of SF as the microservices architecture
    is all about being able to scale out when you need and preserving a stable environment
    while doing so. In most cases, you will need to scale horizontally (by getting
    more machines running your workloads) but, of course, it is also possible to scale
    vertically (so more powerful machines become available and, in some scenarios,
    it is a better option than scaling out). In general, the answer to whether you
    need to scale out or up depends on the work your code needs to do:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展是 SF 最重要的功能之一，因为微服务架构的核心就是能够在需要时进行扩展，并在此过程中保持稳定的环境。在大多数情况下，你需要水平扩展（通过增加更多的机器来运行工作负载），但当然，也可以进行垂直扩展（这样更强大的机器就能投入使用，并且在某些情况下，这比水平扩展更合适）。通常，是否选择水平扩展或垂直扩展，取决于你的代码需要执行的工作：
- en: If your work can be parallelized, choose to scale out
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的工作可以并行化，选择水平扩展
- en: If your work performs many calculations and is I/O-heavy and such actions cannot
    be distributed, choose to scale out
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的工作涉及大量计算并且 I/O 密集型，且这些操作无法分布式处理，选择水平扩展
- en: What is more, each node type in SF is a separate VM scale set. That means that
    you can scale your nodes independently, according to your needs. This is a very
    important feature—you probably would not appreciate, if only one part of your
    system requires more computing power, having to update the whole cluster.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，SF 中的每个节点类型都是一个独立的虚拟机扩展集。这意味着你可以根据需要独立地扩展节点。这是一个非常重要的特性——如果只有系统的某一部分需要更多的计算能力，而你还需要更新整个集群，你可能不会很高兴。
- en: In SF, each node has specific requirements when it comes to scaling, as it is
    important to keep the correct number of nodes running production workloads. Details
    can be found in the documentation; you can find a link to it in the *Further reading*section
    at the end of this chapter.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SF 中，每个节点在扩展时有特定的要求，因为保持正确数量的节点运行生产工作负载是很重要的。详细信息可以在文档中找到；你可以在本章末尾的 *进一步阅读*
    部分找到相关链接。
- en: Scaling a cluster up or down
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展集群的规模
- en: In general, it is not recommended to scale a cluster up or down, as it is a
    dangerous operation (especially if you would like to change the VM SKU of the
    primary node). If you wonder why, please consider the following operation—you
    are about to scale down a node. This is an infrastructure operation, which requires
    changing available hardware for your application. If you do not monitor and orchestrate
    all operations correctly, you may end up with your stateful services losing data
    (for example, you temporarily lost access to a database) and even stateless services
    may become unstable. In fact, to scale up or down in a secure fashion, you should
    first create a new node type, and then gradually reduce the instance count of
    the old one, so SF is able to distribute the workload correctly before the old
    node is shut down.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，不建议对集群进行上下扩展，因为这是一项危险的操作（特别是如果你想更改主节点的VM SKU）。如果你想知道原因，请考虑以下操作——你即将缩减一个节点。这是一项基础设施操作，需要为你的应用程序更改可用硬件。如果你没有正确监控和编排所有操作，你可能会导致你的有状态服务丢失数据（例如，暂时无法访问数据库），甚至无状态服务也可能变得不稳定。实际上，要安全地进行上下扩展，你应该首先创建一个新的节点类型，然后逐渐减少旧节点的实例计数，以便SF能够在关闭旧节点之前正确地分发工作负载。
- en: The SF documentation states that it is highly inadvisable to change the SKU
    of VMs running a primary node. However, it is, of course, possible when done carefully; you
    can find a link to instructions in the *Further reading*section at the end of
    this chapter.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: SF文档指出，在运行主节点的VM上更改SKU是非常不建议的。然而，当小心操作时，这是可能的；你可以在本章末尾的*Further reading*部分找到一篇指南的链接。
- en: Monitoring and diagnostics
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监视和诊断
- en: In the final section of this chapter, we will cover some topics regarding monitoring
    and diagnosing your services in SF. As you probably remember, I noted such features
    as one of the most important in microservices, as you have to always be able to
    tell how each one works and perform the needed action (such as scale out, restart,
    or kill an instance) if required. In SF, there are a few levels of monitoring
    that we will briefly describe here.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一节，我们将涵盖一些关于在SF中监视和诊断你的服务的主题。正如你可能记得的那样，我将这些功能视为微服务中最重要的之一，因为你必须始终能够知道每个服务如何工作，并在需要时执行必要的操作（例如扩展、重启或终止实例）。在SF中，有几个监控层次，我们将在这里简要描述。
- en: Application monitoring
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序监控
- en: 'In most cases, you want to monitor how your application works, what the user
    traffic is, and how your services communicate with each other. While you are able
    to bring your own framework, you can also leverage **Application Insights** (**AI**)
    integration—this will ensure that you are getting all necessary logs and available
    diagnostic messages. You can set up AI integration while creating a cluster for SF:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你希望监视你的应用程序如何工作，用户流量是多少，以及你的服务如何相互通信。虽然你可以自己带入框架，但也可以利用**应用程序洞察**（**AI**）集成——这将确保你获取所有必要的日志和可用的诊断消息。你可以在创建SF集群时设置AI集成：
- en: '![](img/f8f11568-683e-4857-ad31-91652b7aadb9.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8f11568-683e-4857-ad31-91652b7aadb9.png)'
- en: Cluster monitoring
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集群监控
- en: 'While working, your cluster emits a variety of events, which map to one particular
    entity within it:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作过程中，你的集群会发出各种事件，这些事件映射到其中的一个特定实体：
- en: Cluster
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群
- en: Application
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序
- en: Service
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务
- en: Partition
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分区
- en: Replica
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 副本
- en: Container
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器
- en: 'You can query these events by leveraging the `EventStore` service available
    in SF. It is possible to correlate them, so you can find out how one entity impacts
    others. The following is the example request to the API returning events from
    a specific time range:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过利用SF中提供的`EventStore`服务查询这些事件。可以对它们进行关联，以便找出一个实体如何影响其他实体。以下是从特定时间范围返回事件的API示例请求：
- en: '[PRE20]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Health monitoring
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健康监控
- en: 'Besides monitoring your application and cluster, you will also want to check
    how a particular service is working. To check its health, SF introduces Service
    Fabric Explorer, which you can access to verify the health of the following:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 除了监视你的应用程序和集群外，你还需要检查特定服务的工作情况。为了检查其健康状况，SF引入了Service Fabric Explorer，你可以访问以验证以下内容的健康状况：
- en: Node
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点
- en: Application
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序
- en: Service
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务
- en: Partition
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分区
- en: Replica
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 副本
- en: 'You can access the Explorer both locally and in the cloud. It presents a nice
    UI, which displays a lot of useful information that you can use to determine the
    current status of the whole system, notice possible problems, and get the necessary
    details to investigate an issue further:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本地和云端访问Explorer。它呈现了一个不错的用户界面，显示了大量有用的信息，你可以利用这些信息来确定系统的当前状态，发现潜在问题，并获取必要的细节以进一步调查问题：
- en: '![](img/87d148c2-b6e6-40c0-b69c-35f50d14693a.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87d148c2-b6e6-40c0-b69c-35f50d14693a.png)'
- en: Summary
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we only took a brief look at SF and the microservices built
    with this Azure component. You have learned the basic concepts of SF, such as
    Reliable services and Reliable actors, and how to implement a communication protocol
    to exchange messages between services and clients. Remember that building an application
    based on microservices is not a trivial task and requires sticking to many important
    rules to avoid problems with dealing with state, monitoring, or scaling. Use SF as
    a framework for building distributed applications, which takes care of ensuring
    that they are reliable and highly available.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们只是简单介绍了SF及其构建的微服务。你已经学习了SF的基本概念，例如可靠服务和可靠演员，以及如何实现一个通信协议以便在服务与客户端之间交换消息。记住，基于微服务构建应用程序并非易事，它要求遵循许多重要规则，以避免处理状态、监控或扩展时出现问题。将SF作为构建分布式应用程序的框架，它确保应用程序的可靠性和高可用性。
- en: 'Last but not least: do not be discouraged if you have problems with SF or feel
    overwhelmed by its multiple options and configurations—this particular service
    has a pretty difficult learning curve, but after reading this whole chapter, you
    should be able to start writing your very own services without problems.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是：如果你在使用SF时遇到问题，或者被其众多选项和配置所困扰，不要灰心——这项服务确实有一个相当陡峭的学习曲线，但在阅读完整本章节后，你应该能够毫不费力地开始编写自己的服务。
- en: 'In [Chapter 3](51d6dd91-dc4f-4c18-af05-e6ddc1b552fc.xhtml), *Deploying Web
    Applications as Containers*, you will learn about another PaaS service available
    in Azure: Azure Search, which lets you start using your own search engine to index
    and query stored documents.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](51d6dd91-dc4f-4c18-af05-e6ddc1b552fc.xhtml)《将Web应用程序部署为容器》中，你将了解Azure中另一个PaaS服务：Azure
    Search，它允许你使用自己的搜索引擎对存储的文档进行索引和查询。
- en: Questions
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between Reliable services and Reliable actors?
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可靠服务和可靠演员之间有什么区别？
- en: What is the difference between stateless and stateful services?
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无状态服务和有状态服务之间有什么区别？
- en: What one has to be implemented to introduce its very own communication channel
    in SF?
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在SF中引入自己独立的通信通道，必须实现哪些内容？
- en: What is node type in SF?
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SF中的节点类型是什么？
- en: Can you scale (up/out) node types individually?
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以单独扩展（向上/向外）节点类型吗？
- en: Can you select a VM SKU when creating a cluster?
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建集群时，你可以选择虚拟机SKU吗？
- en: What are the two types of node security in SF?
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SF中有哪两种类型的节点安全性？
- en: What is the difference between cluster, application, service, partition, and
    replica?
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集群、应用程序、服务、分区和副本之间有什么区别？
- en: Why does SF advocate creating a node with at least five VMs?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么SF建议创建至少包含五个虚拟机的节点？
- en: What is the reliability tier in SF?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SF中的可靠性等级是什么？
- en: Further reading
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-technical-overview](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-technical-overview)'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-technical-overview](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-technical-overview)'
- en: '[https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-cluster-creation-via-arm](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-cluster-creation-via-arm)'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-cluster-creation-via-arm](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-cluster-creation-via-arm)'
- en: '[https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-cluster-scaling](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-cluster-scaling)'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-cluster-scaling](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-cluster-scaling)'
- en: '[https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-diagnostics-event-generation-operational](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-diagnostics-event-generation-operational)'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-diagnostics-event-generation-operational](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-diagnostics-event-generation-operational)'
- en: '[https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-work-with-reliable-collections](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-work-with-reliable-collections)'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-work-with-reliable-collections](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-work-with-reliable-collections)'
