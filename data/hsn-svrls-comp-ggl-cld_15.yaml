- en: Building a PDF Conversion Service
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 PDF 转换服务
- en: In the previous chapters, we have discussed the relative merits of working with
    serverless computing on Google Cloud. Over the course of this chapter and the
    next, we will look at a case study to explore how a solution might be deployed.
    Working through the examples will illustrate how to use many of the techniques
    we've previously discussed.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了在 Google Cloud 上使用无服务器计算的相对优点。在本章和下一章中，我们将通过案例研究来探讨如何部署解决方案。通过实际操作这些示例，将演示如何使用我们之前讨论的许多技巧。
- en: In order to do this, we will use an example case study based on Pet Theory,
    a hypothetical veterinary practice that is making the transition to using serverless
    technology on Google Cloud.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一目标，我们将使用一个基于 Pet Theory 的示例案例研究，这是一家假设的兽医诊所，正在过渡到在 Google Cloud 上使用无服务器技术。
- en: 'Over the course of this chapter, we will discuss the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Designing a document service
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计文档服务
- en: Developing a document service
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发文档服务
- en: Developing a Cloud Run service
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发 Cloud Run 服务
- en: Securing service access
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护服务访问
- en: Testing the document access
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试文档访问
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete the exercises in this chapter, you will require a Google Cloud project
    or a Qwiklabs account.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章的练习，你需要一个 Google Cloud 项目或 Qwiklabs 账户。
- en: You can find the code files of this chapter in the GitHub repository for this
    book, under the `ch11` subdirectory, at [https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch11](https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch11).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的 GitHub 仓库中找到本章的代码文件，路径为 `ch11` 子目录，地址是 [https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch11](https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch11)。
- en: While you are going through the code snippets in this book, you will notice
    that, in a few instances, a few lines from the codes/outputs have been removed
    and replaced with ellipses (`...`). The use of ellipses is only to show relevant
    code/output. The complete code is available on GitHub at the link mentioned previously.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在你阅读本书中的代码片段时，你会注意到在某些情况下，部分代码行或输出已被删除，并用省略号（`...`）代替。使用省略号的目的是仅展示相关的代码或输出。完整的代码可以在之前提到的
    GitHub 链接中找到。
- en: Pet Theory case study overview
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pet Theory 案例研究概述
- en: For our case study, we will be exploring the Pet Theory veterinary practice.
    In this scenario, the business is looking to transition to serverless technology
    and provide some practical methods to incorporate Google Cloud and its products
    within the business.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的案例研究，我们将探讨 Pet Theory 兽医诊所。在这个场景中，企业希望过渡到无服务器技术，并提供一些实用方法，以便将 Google Cloud
    及其产品融入到业务中。
- en: 'The full Pet Theory case study incorporates a number of different scenarios
    that demonstrate how to resolve typical real-world issues with serverless technology.
    To view the complete scenario, visit the Qwiklabs site and search for *Serverless
    Workshop: Pet Theory Quest* ([https://www.qwiklabs.com/quests/98](https://www.qwiklabs.com/quests/98))
    to see the associated labs.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '完整的 Pet Theory 案例研究包含了多个不同的场景，展示了如何使用无服务器技术解决典型的现实世界问题。要查看完整的场景，请访问 Qwiklabs
    网站并搜索 *Serverless Workshop: Pet Theory Quest*（[https://www.qwiklabs.com/quests/98](https://www.qwiklabs.com/quests/98)）以查看相关实验。'
- en: Over the course of this chapter and the next, we will be working through two
    lab examples that illustrate the power and flexibility of serverless technologies.
    In the first example in this chapter, we will look at how Pet Theory deals with
    moving to a unified document process based on the automatic conversion of documents.
    To begin our review, we will outline what the proposed architecture is attempting
    to achieve and the component roles and requirements involved.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和下一章中，我们将通过两个实验示例来展示无服务器技术的强大和灵活性。在本章的第一个示例中，我们将看看 Pet Theory 如何通过基于文档自动转换的统一文档流程进行迁移。为了开始我们的回顾，我们将概述所提议的架构试图实现的目标以及涉及的组件角色和需求。
- en: Designing a document service
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计文档服务
- en: Pet Theory has an issue with its existing process for document management. Currently,
    they use multiple document formats within the business and want to rationalize
    this to use a single unified approach. After some consultation, they decided to
    transition to **Portable Document Format** (**PDF**) so that they could continue
    to use rich media when sending information electronically to their clients and
    suppliers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Pet Theory在现有的文档管理流程中遇到了一些问题。目前，他们在业务中使用多种文档格式，并希望统一规范，采用单一的标准方法。经过一些咨询，他们决定过渡到**可移植文档格式**（**PDF**），这样他们在向客户和供应商电子发送信息时，仍然可以使用丰富的媒体内容。
- en: 'In terms of requirements, the Pet Theory team have decided they need a system
    capable of the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 就需求而言，Pet Theory团队决定他们需要一个能够实现以下功能的系统：
- en: '| **Requirement** | **Component** |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **需求** | **组件** |'
- en: '| Storing document information | Storage |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 存储文档信息 | 存储 |'
- en: '| Handling processing requests | Processing |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 处理请求 | 处理 |'
- en: '| Securing service access | Security |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 确保服务访问安全 | 安全 |'
- en: '| Processing document conversions | Service |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 处理文档转换 | 服务 |'
- en: Now we have the high-level requirements for the application, we should add to
    our understanding by describing each requirement.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了应用的高层次需求，我们应该通过描述每个需求来进一步完善我们的理解。
- en: Storing document information
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储文档信息
- en: From the preceding information, we know that storage is a key component in our
    architecture, as the documents will need to be stored somewhere. We also know
    that Google Cloud has a number of products that would suit this type of requirement.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的信息来看，我们知道存储是我们架构中的关键组件，因为文档需要存储在某个地方。我们还知道，Google Cloud有许多产品适合这种需求。
- en: Typically, the obvious choice for storage is to use a disk or shared filesystem
    to persist the data to be processed. However, in this instance, this type of storage
    may not be the best option for the situation presented. The general remit is to
    minimize the maintenance of the infrastructure required, and creating a traditional
    database on managed infrastructure would not meet this requirement.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，存储的明显选择是使用磁盘或共享文件系统将数据持久化。但是，在这种情况下，这种存储方式可能并不是最适合当前情形。总体要求是尽量减少基础设施的维护，而在托管基础设施上创建传统数据库无法满足这一要求。
- en: Thinking about what we have learned regarding Google Cloud Storage, we know
    that short-term object storage can be used for transient information. We also
    know that Cloud Storage provides an event framework that supports interaction
    with serverless computing. On that basis, Cloud Storage seems like a good candidate
    that is capable of meeting our storage requirement.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们对Google Cloud Storage的了解，我们知道短期对象存储可以用于临时信息存储。我们还知道，Cloud Storage提供了一个事件框架，支持与无服务器计算的交互。因此，Cloud
    Storage似乎是一个能够满足我们存储需求的良好候选者。
- en: Handling processing requests
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理处理请求
- en: Processing requests can be handled in a number of ways. In this example, we
    are going to build a solution that can scale on demand. To that end, we want to
    decouple the storage requirement from the processing component, meaning we need
    to add some middleware capable of efficiently handling the information.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 处理请求可以通过多种方式进行。在这个示例中，我们将构建一个可以按需扩展的解决方案。为此，我们希望将存储需求与处理组件解耦，这意味着我们需要添加一些中间件，能够高效地处理信息。
- en: In our application, we have already decided to utilize Cloud Storage and therefore
    we will need a mechanism to asynchronously communicate this service with the backend
    processing to be performed. The application needs to work autonomously as much
    as possible to minimize both user interaction and the potential for errors.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用中，我们已经决定使用云存储，因此我们需要一种机制来异步地与后端处理进行通信。应用需要尽可能自主运行，以减少用户交互和错误发生的可能性。
- en: Adding Cloud Pub/Sub to the application enables the application to define a
    consistent and scalable messaging service. The service can consume information
    from Cloud Storage and propagate this information to the component performing
    the backend processing. At this point, you may be thinking that Cloud Tasks would
    be a good alternative for this solution. However, the use case for Cloud Tasks
    states that it is better suited to a scenario where control of execution timing
    (that is, rate-limiting) is required. In our scenario, we do not need that level
    of control over execution. We have a need for general data ingestion and distribution
    for which the Cloud Pub/Sub product is better suited.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Cloud Pub/Sub 添加到应用程序中使其能够定义一个一致且可扩展的消息传递服务。该服务可以从 Cloud Storage 中获取信息，并将这些信息传播到执行后端处理的组件。在这一点上，你可能会认为
    Cloud Tasks 是一个不错的替代方案。然而，Cloud Tasks 的用例表明，它更适用于需要控制执行时机（即速率限制）的场景。在我们的场景中，我们不需要那种执行控制级别。我们需要的是通用的数据摄取和分发，而
    Cloud Pub/Sub 产品更适合这种需求。
- en: When using Cloud Pub/Sub, we will need to provide information relating to a
    topic that provides the information to be transported. In our application, this
    will contain information relating to the file that's uploaded to the Cloud Storage
    bucket. To consume information relating to a topic, we will also create a subscription
    that will receive an event notification based on a new message being added to
    the topic.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Cloud Pub/Sub 时，我们需要提供与主题相关的信息，这些信息是要传输的数据。在我们的应用程序中，这将包含与上传到 Cloud Storage
    存储桶的文件相关的信息。为了消费与主题相关的信息，我们还需要创建一个订阅，它会根据向主题添加新消息来接收事件通知。
- en: Securing service access
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保服务访问安全
- en: As part of our requirements, we also need to implement security permissions
    for service access to ensure that only authorized accounts can invoke the new
    service. Our assumption with this service is that we can use an account to manage
    the necessary permissions. Over the course of the chapters relating to Cloud Functions
    and Cloud Run, we have seen how valuable these service accounts are for non-interactive
    solutions. To achieve this requirement, we can use service accounts that will
    be allocated the necessary permissions associated with the appropriate roles.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们需求的一部分，我们还需要实施服务访问的安全权限，以确保只有授权的帐户可以调用新服务。我们对这个服务的假设是，我们可以使用一个帐户来管理必要的权限。在与
    Cloud Functions 和 Cloud Run 相关的章节中，我们已经看到这些服务帐户对于非交互式解决方案是多么宝贵。为了实现这一要求，我们可以使用服务帐户，并为其分配与适当角色相关的必要权限。
- en: Processing document conversations
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文档转换
- en: 'In order to select a service capable of performing the document conversion,
    take a moment to recap the relative merits of the serverless options available
    on Google Cloud:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了选择能够执行文档转换的服务，请花点时间回顾 Google Cloud 上可用的无服务器选项的相对优点：
- en: '| **Product** | **Scenario** | **Typical use case** |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **产品** | **场景** | **典型用例** |'
- en: '| App Engine | Serverless HTTP applications | Web applications |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| App Engine | 无服务器 HTTP 应用程序 | Web 应用程序 |'
- en: '| Cloud Functions | Serverless functions and events | Event-driven functions
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| Cloud Functions | 无服务器函数和事件 | 基于事件的函数 |'
- en: '| Cloud Run | Serverless HTTP containers | Fully managed HTTP request-response
    containers |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| Cloud Run | 无服务器 HTTP 容器 | 完全托管的 HTTP 请求-响应容器 |'
- en: 'In addition to the original requirements, the Pet Theory team want to be able
    to do the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了原始要求外，Pet Theory 团队还希望能够完成以下任务：
- en: Process information in a scalable manner
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以可扩展的方式处理信息
- en: Leverage existing code/application where practical
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实际可行的情况下，利用现有代码/应用程序
- en: Minimize application maintenance
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化应用程序维护
- en: Utilize in-house knowledge and skills as much as possible
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能利用公司内部的知识和技能
- en: A team member has identified that the LibreOffice application can handle the
    conversion of documents to PDF. Packaging this application as a Docker image will
    allow the team to easily reuse and standardize the integration within their project.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一位团队成员发现 LibreOffice 应用程序能够处理文档转换为 PDF。将这个应用程序打包成 Docker 镜像，将使团队能够轻松地在项目中复用和标准化集成。
- en: From the preceding paragraphs, it seems that Cloud Run is a good fit for the
    current requirements. As we have learned, Cloud Run supports stateless HTTP and
    custom libraries. Furthermore, the established integration with services such
    as Cloud Pub/Sub means this is perfect for our proposed solution. Once the initial
    build has been tested and verified, the solution can be further enhanced by utilizing
    Google Developer tools such as Cloud Build to achieve continuous integration.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的段落来看，Cloud Run似乎非常适合当前的需求。正如我们所了解到的，Cloud Run支持无状态HTTP和自定义库。此外，与Cloud Pub/Sub等服务的集成意味着它非常适合我们提出的解决方案。一旦初始构建经过测试和验证，该解决方案可以通过利用Google开发者工具，如Cloud
    Build，进一步增强，以实现持续集成。
- en: 'Awesome job! We have walked through a high-level analysis of requirements,
    broken it down into components, and now have the essence of a solution. To confirm
    our understanding, the following diagram covers the solution we have designed:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 做得好！我们已经进行了高层次的需求分析，将其拆解成组件，现在已经掌握了解决方案的精髓。为了确认我们的理解，以下图表展示了我们设计的解决方案：
- en: '![](img/b86663ee-371e-4ded-a94e-a1f1dfd66bdf.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b86663ee-371e-4ded-a94e-a1f1dfd66bdf.png)'
- en: 'In this diagram, we have defined three distinct stages to be run on Google
    Cloud that represent the components we previously defined in order to manage our
    document processing. Our architecture can be described by the following steps:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图表中，我们定义了三个在Google Cloud上运行的不同阶段，这些阶段代表了我们之前定义的组件，用于管理文档处理。我们的架构可以通过以下步骤来描述：
- en: A source document uploads to system storage (that is, a Cloud Storage bucket).
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个源文档上传到系统存储（即一个云存储桶）。
- en: A life cycle event is triggered and generates a new payload for the Pub/Sub
    topic.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 触发生命周期事件并生成一个新的负载，发送到Pub/Sub主题。
- en: A Pub/Sub subscription polls for new data notifications.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个Pub/Sub订阅轮询新数据通知。
- en: A Cloud Run service processes the uploaded content and creates a PDF.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个Cloud Run服务处理上传的内容并创建PDF。
- en: Note that in the preceding diagram, the main boxes are general abstractions
    to indicate service isolation. For our simple service, this should help clarify
    each stage of processing and the responsible component. In addition, we can also
    see that the majority of processing does not require the creation of code to handle
    storage event notifications and the message queue data objects. Our efforts are
    largely focused on the creation of the service for which we have sensibly opted
    for a preexisting application to handle the PDF conversion.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的图表中，主要框体是一般的抽象，用来表示服务隔离。对于我们简单的服务来说，这应该有助于澄清每个处理阶段以及负责的组件。此外，我们还可以看到，大部分处理并不需要创建代码来处理存储事件通知和消息队列数据对象。我们的努力主要集中在创建服务上，我们明智地选择了一个现有的应用程序来处理PDF转换。
- en: Based on this discussion, we now have a general understanding of the PDF creation
    process for documents that are submitted to our service. In the next section,
    we will start to look at the practical elements of developing the PDF service
    in order to fulfill the requirements.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这一讨论，我们现在对提交给我们服务的文档的PDF创建过程有了一个大致的了解。在接下来的部分，我们将开始着手开发PDF服务的实际要素，以满足需求。
- en: Developing a document service
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发文档服务
- en: In the previous section, we outlined an architecture for our serverless application.
    During this analysis phase, we worked out the high-level components required and
    then theorized on the type of activities required. Creating a document service
    requires the creation of a Cloud Run service to consume information from a Cloud
    Pub/Sub subscription. As we have chosen to minimize the code development process,
    our productivity has been significantly increased. Code for complex notifications
    and message queues has been deferred to existing mechanisms managed by Google
    Cloud. Instead, we will concentrate on building only the specific element needed
    for our requirements, for example, PDF conversion.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一部分中，我们概述了无服务器应用程序的架构。在这个分析阶段，我们确定了所需的高层次组件，并推测了所需的活动类型。创建文档服务需要创建一个Cloud
    Run服务，以便从Cloud Pub/Sub订阅中获取信息。由于我们选择最小化代码开发过程，我们的生产力得到了显著提高。复杂的通知和消息队列的代码已推迟到Google
    Cloud管理的现有机制中。相反，我们将专注于构建满足需求的特定元素，例如PDF转换。
- en: In your Google Cloud project, open Cloud Shell and make sure a clone of the
    lab repository for `Chap11` is available.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的Google Cloud项目中，打开Cloud Shell，并确保可以使用`Chap11`实验室仓库的克隆版本。
- en: Storing document information
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储文档信息
- en: 'To get the project started, we need to create the storage for the application.
    In the following diagram, we can see that the solution uses two storage buckets.
    The first bucket stores document uploads while the second stores the output, that
    is, the processed PDF file:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动项目，我们需要为应用程序创建存储。在以下示意图中，我们可以看到该解决方案使用了两个存储桶。第一个存储桶存储文档上传，第二个存储桶存储输出，即处理后的
    PDF 文件：
- en: '![](img/e0a3ed35-cc7d-43a5-b518-aa6f7c3a9d14.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0a3ed35-cc7d-43a5-b518-aa6f7c3a9d14.png)'
- en: 'Creating storage buckets on Google Cloud is straightforward, and at this point
    should be a familiar activity, whether it''s performed from the console or Cloud
    Shell. For this example, we will use Cloud Shell to complete the task:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Google Cloud 上创建存储桶很简单，此时无论是从控制台还是 Cloud Shell 执行，都应该是一个熟悉的操作。对于本示例，我们将使用
    Cloud Shell 来完成任务：
- en: 'Create a multi-region storage bucket for uploaded files:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为上传的文件创建一个多区域存储桶：
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a multi-region storage bucket for processed files:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为处理后的文件创建一个多区域存储桶：
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Google Cloud Storage provides the ability to enable a notification event linked
    to Pub/Sub. The event notification system is extremely powerful and will be used
    to raise a new message for each document that's deposited in the upload bucket.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cloud Storage 提供了启用与 Pub/Sub 相关的通知事件的功能。事件通知系统非常强大，将用于为每个存入上传桶的文档生成新消息。
- en: 'Take a look at the following architecture diagram, which shows that we automatically
    receive a notification when data is added to the upload bucket. Linking Cloud
    Storage and Cloud Pub/Sub together in this way provides a sensible usage pattern
    that can be used in other projects to indicate the availability of data:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下架构图，它显示了当数据被添加到上传桶时，我们会自动收到通知。以这种方式将 Cloud Storage 和 Cloud Pub/Sub 结合在一起，提供了一种合理的使用模式，可以在其他项目中使用，以指示数据的可用性：
- en: '![](img/535fa8df-7e39-4a46-8162-bb332025837c.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/535fa8df-7e39-4a46-8162-bb332025837c.png)'
- en: Now, whenever a file is deposited in the upload bucket, a new Pub/Sub topic
    message will be queued, indicating that new content has been made available.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当一个文件存入上传桶时，一个新的 Pub/Sub 主题消息将被排队，表示新内容已经可用。
- en: To set up the notification mechanism on the existing bucket, we use the `gsutil`
    command. The command will need to know what notification is to be triggered and
    also that a new topic is to be created for the upload bucket.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要在现有桶上设置通知机制，我们使用 `gsutil` 命令。该命令需要知道触发哪种通知，并且还需要创建一个新的主题供上传桶使用。
- en: 'Create a Pub/Sub topic notification called `new-doc` when a file is added to
    the upload bucket:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当文件添加到上传桶时，创建一个名为 `new-doc` 的 Pub/Sub 主题通知：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding command, we use the `OBJECT_FINALIZE` command, which indicates
    a new object being presented to a Google Cloud Storage bucket. Take note that
    the information generated uses the JSON format to pass information to the `new-doc`
    topic.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们使用了 `OBJECT_FINALIZE` 命令，这表示一个新对象被提交到 Google Cloud Storage 存储桶。请注意，生成的信息使用
    JSON 格式将信息传递给 `new-doc` 主题。
- en: We will only receive a notification about the file that's been uploaded after
    deploying the PDF service (as there is no active subscription for this new topic).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在部署 PDF 服务后，我们才会收到有关已上传文件的通知（因为对于此新主题没有有效的订阅）。
- en: Great work! We now have the data storage and stream processing services up and
    running. Next, we will see how to build a PDF service using Cloud Run.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 做得好！我们现在已经启动并运行了数据存储和流处理服务。接下来，我们将看到如何使用 Cloud Run 构建 PDF 服务。
- en: Developing a Cloud Run service
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发 Cloud Run 服务
- en: Building a service can be both daunting and challenging. In this section, we
    will walk through an example of how to build a service based on an existing application.
    In this instance, we will be using LibreOffice to create a PDF.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个服务可能既令人生畏又充满挑战。在本节中，我们将通过一个示例展示如何基于现有应用程序构建服务。在此示例中，我们将使用 LibreOffice 来创建
    PDF。
- en: One thing to mention about this example is how an external application can easily
    be integrated to build a simple service. Applications (specifically Linux) encompass
    a lot of versatility, which means they typically offer a great way to extend and
    incorporate these within a solution. For example, Inkscape can be used to convert
    SVG into PNG, while Calibre can convert EPUB into PDF. The bottom line, before
    going down the route of developing an application, is to investigate what is possible
    using already-existing applications.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 需要提到的一点是，如何轻松集成外部应用程序来构建一个简单的服务。应用程序（特别是Linux）具有很高的灵活性，这意味着它们通常提供了一个很好的方式将这些应用程序集成到解决方案中。例如，Inkscape可以用来将SVG转换为PNG，而Calibre可以将EPUB转换为PDF。在决定开发应用程序之前，最重要的是调查现有的应用程序可以实现什么功能。
- en: Going back to the creation of our service, to build our application, we will
    encapsulate LibreOffice in a Docker image. The information for the service is
    provided through a Cloud Pub/Sub subscription that encapsulates the Cloud Storage
    notification event.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 回到服务的创建过程，为了构建我们的应用程序，我们将把LibreOffice封装在一个Docker镜像中。服务的信息通过一个Cloud Pub/Sub订阅提供，封装了Cloud
    Storage通知事件。
- en: Our application will be built using Node.js and will demonstrate how to access
    the message queue information. Although the code base is relatively short, it
    demonstrates how to integrate external applications with Cloud Run. Remember when
    exploring alternative applications that Cloud Run applications are meant to be
    stateless, as well as utilize HTTP.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将使用Node.js构建，并展示如何访问消息队列信息。尽管代码库相对简短，但它演示了如何将外部应用程序集成到Cloud Run中。请记住，当探索替代应用程序时，Cloud
    Run应用程序应该是无状态的，并且利用HTTP。
- en: The document service receives HTTP through the subscription interface to Cloud
    Pub/Sub, which means this provides a straightforward mechanism to exchange data
    between products. Additionally, state information is not required for the request-response
    life cycle associated with the data exchange. Processing the file with LibreOffice
    will, however, use the `/tmp` directory allocated to Cloud Run to temporarily
    hold information on the output file.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 文档服务通过Cloud Pub/Sub的订阅接口接收HTTP，这意味着它提供了一种简单的机制来交换产品之间的数据。此外，数据交换相关的请求-响应生命周期并不需要状态信息。然而，使用LibreOffice处理文件时，将使用分配给Cloud
    Run的`/tmp`目录临时存储输出文件的信息。
- en: 'To enable Cloud Run to perform document conversions, we are going to consume
    notification messages derived from Cloud Storage, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使Cloud Run执行文档转换，我们将使用来自Cloud Storage的通知消息，如下所示：
- en: '![](img/dc539cab-8e33-4ab6-8531-3d0cfcede04b.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc539cab-8e33-4ab6-8531-3d0cfcede04b.png)'
- en: Building the Cloud Run service incorporates a Node.js application to process
    the information, as well as the creation of a Docker container. As in previous
    examples, we start with the `package.json` file and install packages to enable
    access to additional resources (for example, Cloud Storage and Express.js).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Cloud Run服务包括一个Node.js应用程序来处理信息，并创建一个Docker容器。与之前的示例一样，我们从`package.json`文件开始，并安装包以启用访问额外资源（例如，Cloud
    Storage和Express.js）。
- en: Developing the service
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发服务
- en: 'First, we need to populate our configuration files with the correct information:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要用正确的信息填充配置文件：
- en: 'Amend the `package.json` file to add a `start` script, as follows:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`package.json`文件，添加一个`start`脚本，如下所示：
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the packages used by the conversion process:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加转换过程使用的包：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Edit the `index.js` file to add the required references and additional code.
    Add the following package requirements to the top of the code file:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`index.js`文件，添加所需的引用和额外的代码。将以下包依赖添加到代码文件的顶部：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Replace the existing `app.post` function with the code outlined, as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用下面的代码替换现有的`app.post`函数：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the `downloadFile` function:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`downloadFile`函数：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The next function is where the magic happens in our program. From the following
    code snippet, we can see that LibreOffice is called in a headless state (that
    is, with no graphical interface) to generate a PDF. The resultant file is stored
    in the `/tmp` directory for postprocessing.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数是我们程序中魔法发生的地方。从以下代码片段中，我们可以看到LibreOffice以无头模式（即没有图形界面）被调用来生成PDF。生成的文件存储在`/tmp`目录中，以便后续处理。
- en: 'Add the `convertFile` function:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`convertFile`函数：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add the `deleteFile` function:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`deleteFile`函数：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the `uploadFile` function:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`uploadFile`函数：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Nice work! We now have an application capable of generating a PDF from an object
    passed to it. The next step is to create a Docker image that will run the application
    when the container is run.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！现在我们有一个能够根据传递给它的对象生成 PDF 的应用程序。下一步是创建一个 Docker 镜像，该镜像将在容器运行时启动应用程序。
- en: Deploying the service
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署服务
- en: 'To create a Dockerfile manifest for the application, follow these steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要为应用程序创建 Dockerfile 清单，请遵循以下步骤：
- en: 'Add the definition to install the `libreoffice` package to the Dockerfile:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将安装 `libreoffice` 包的定义添加到 Dockerfile 中：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'From the command line, build the service, create an image from the manifest,
    and store it in `gcr.io`:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，构建服务，从清单创建镜像，并将其存储在 `gcr.io` 中：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once the build process has successfully completed, deploy the service:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦构建过程成功完成，部署该服务：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding properties for Cloud Run provide an overview of the key attributes
    associated with a typical deployment. We have increased the memory allocated for
    Cloud Run as the conversion process is memory intensive.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 Cloud Run 属性概述了典型部署所涉及的关键属性。由于转换过程占用大量内存，因此我们增加了为 Cloud Run 分配的内存。
- en: 'Create a new environment variable to hold the `SERVICE_URL` parameters:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的环境变量来保存 `SERVICE_URL` 参数：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We now have an image built and stored in Google Cloud. The image is maintained
    in the Container Registry and the artifact can be deployed with additional properties
    to specify additional memory and the region in which it will be run. Notably,
    when the instance is run, we need to specify an environment variable that names
    the bucket that data will be output to.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经在 Google Cloud 中构建并存储了一个镜像。该镜像保存在容器注册表中，且可以通过指定额外的内存和运行区域等属性进行部署。特别地，在实例运行时，我们需要指定一个环境变量，该变量用于指定数据输出的桶名称。
- en: As the final step for this build and deployment section, we capture the service
    URL assigned to the deployed Cloud Run instance. Capturing the service URL enables
    the user to access the service via an environment variable. We will use this environment
    variable later on in this exercise.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本次构建和部署部分的最后一步，我们获取分配给已部署 Cloud Run 实例的服务 URL。获取服务 URL 使用户能够通过环境变量访问该服务。稍后我们将在本练习中使用该环境变量。
- en: Congratulations – there now exists a service on Google Cloud capable of automatically
    creating a PDF based on an uploaded file.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜——现在 Google Cloud 上已经存在一个能够根据上传的文件自动生成 PDF 的服务。
- en: Securing service access
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保服务访问
- en: With the service enabled successfully, we will turn our attention to securing
    access. To achieve this, we will be creating a new service account with the specific
    task of managing the invocation of the new service.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 服务成功启用后，我们将重点关注访问安全。为此，我们将创建一个新的服务账户，专门负责管理新服务的调用。
- en: Thinking back to the original design, the service is actually invoked by Cloud
    Pub/Sub rather than a user. As we have chained together a series of events, we
    can take advantage of this to minimize the external sources that are able to initiate
    our new service. The following steps illustrate how to create a service account
    tasked with the invocation of a new Cloud Run PDF service instance.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下原始设计，服务实际上是通过 Cloud Pub/Sub 而不是用户调用的。由于我们已经串联了一系列事件，我们可以利用这一点来最小化能够启动我们新服务的外部来源。以下步骤展示了如何创建一个服务账户，专门负责调用新的
    Cloud Run PDF 服务实例。
- en: Creating a service account
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建服务账户
- en: 'To create a service account, follow these simple steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个服务账户，请遵循以下简单步骤：
- en: 'Create a new service account:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的服务账户：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Give the service account permission to invoke Cloud Run:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授予服务账户调用 Cloud Run 的权限：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create an environment variable to hold the `PROJECT_ID`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个环境变量来保存 `PROJECT_ID`：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Allow the project to create Cloud Pub/Sub authentication tokens:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许项目创建 Cloud Pub/Sub 身份验证令牌：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Congratulations – using a service account to manage resources follows best practice
    guidelines laid out by Google Cloud. Following these simple steps ensures that
    the identity and access permissions are limited to only the service account requiring
    access.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜——使用服务账户来管理资源符合 Google Cloud 提供的最佳实践指南。遵循这些简单步骤确保身份和访问权限仅限于需要访问的服务账户。
- en: Now that we have a backend service constrained to a service account invocation,
    we can set up the message queue to process requests.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经将后端服务限制为仅通过服务账户进行调用，我们可以设置消息队列来处理请求。
- en: Handling processing requests
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理处理请求
- en: The final development task is to add a subscription to the solution. The subscription
    is used to consume information from the selected topic on Cloud Pub/Sub. A simple
    mechanism such as this allows information to be channeled between different services
    with minimal effort.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的开发任务是向解决方案中添加一个订阅。该订阅用于从 Cloud Pub/Sub 上选定的主题中消费信息。像这样的简单机制可以让信息在不同的服务之间轻松流动。
- en: 'In the following diagram, we bind the push endpoint for Pub/Sub to the `SERVICE_URL`
    and tie the invocation of the function to the service account we created earlier.
    Fortunately, initiating a processing request like this is straightforward on Google
    Cloud:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，我们将 Pub/Sub 的推送端点绑定到 `SERVICE_URL`，并将函数的调用与我们之前创建的服务账户绑定。幸运的是，在 Google
    Cloud 上启动这样的处理请求非常简单：
- en: '![](img/d89a5e0a-b664-4d6d-8ead-71b14f0788a1.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d89a5e0a-b664-4d6d-8ead-71b14f0788a1.png)'
- en: 'To initiate a subscription on an existing Cloud Pub/Sub topic, do the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要在现有的 Cloud Pub/Sub 主题上启动订阅，请执行以下操作：
- en: 'Create a new Pub/Sub subscription bound to the `SERVICE_URL`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Pub/Sub 订阅，并绑定到 `SERVICE_URL`：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now that a subscription has been declared, the information that''s passed to
    the `new-doc` topic will be automatically pushed to the subscriber by Cloud Pub/Sub:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在已经声明了订阅，将信息传递到 `new-doc` 主题时，Cloud Pub/Sub 会自动将其推送到订阅者：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The message object indicates both a subscription and message. A subscription
    key/value pair defines the project and subscription ID to be used in the message
    queue. Additionally, a message object that details the key/value pairs for the
    attributes, data, and message ID allocated to the data to be sent.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 消息对象同时表示订阅和消息。订阅的键/值对定义了在消息队列中使用的项目和订阅 ID。此外，还包括一个消息对象，详细说明了分配给待发送数据的属性、数据和消息
    ID 的键/值对。
- en: In the preceding example, once the message/data has been successfully retrieved,
    the endpoint will use base64 to decode the message passed.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的示例中，一旦消息/数据成功检索，端点将使用 base64 解码传递的消息。
- en: Both the `PROJECT_ID` and `SUBSCRIPTION_ID` values need to be valid for the
    Google Cloud project being used.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`PROJECT_ID` 和 `SUBSCRIPTION_ID` 的值需要对正在使用的 Google Cloud 项目有效。'
- en: In case you are wondering, the data value displayed in the preceding example
    is a base64-encoded message. To encode a message, use the base64 application;
    for example, `echo "Welcome to Google Cloud Serverless" | base64`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道，前面示例中显示的数据值是经过 base64 编码的消息。要编码一条消息，可以使用 base64 应用程序；例如，`echo "Welcome
    to Google Cloud Serverless" | base64`。
- en: To decode a message, add `-d` to the application command line; for example,
    `echo "V2VsY29tZSB0byBHb29nbGUgQ2xvdWQgU2VydmVybGVzcwo=" | base64 -d`
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要解码一条消息，请在应用程序命令行中添加`-d`参数；例如，`echo "V2VsY29tZSB0byBHb29nbGUgQ2xvdWQgU2VydmVybGVzcwo="
    | base64 -d`
- en: The HTTPS request will be passed to the predefined endpoint and acknowledged
    on receipt. If the object passed is not acknowledged as successful, a retry mechanism
    will be employed, indicating the message needs to be resent. The retry process
    will be marshaled by a default acknowledgment deadline, which means the endpoint
    needs to respond before this timeout is in effect.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS 请求将传递到预定义的端点，并在收到后确认。如果传递的对象未被确认成功，将启用重试机制，表明该消息需要重新发送。重试过程将由默认的确认截止时间来协调，这意味着端点需要在超时生效前作出响应。
- en: When working with Cloud Pub/Sub, it is useful to note that Google Cloud serverless
    systems (that is, App Engine, Cloud Functions, and Cloud Run) use the push mechanism.
    As flow control is automatically established, the client only needs to indicate
    success/failure on message processing.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Cloud Pub/Sub 时，值得注意的是 Google Cloud 无服务器系统（即 App Engine、Cloud Functions
    和 Cloud Run）使用推送机制。由于流量控制是自动建立的，客户端只需指示消息处理的成功/失败。
- en: Congratulations—the create-a-PDF service has now been designed and developed
    using Google Cloud serverless technologies. That concludes the development phase,
    and we can now progress to testing our new service.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你——创建 PDF 服务已经使用 Google Cloud 无服务器技术完成设计和开发。这标志着开发阶段的结束，我们现在可以开始测试我们的新服务。
- en: Testing the document service
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试文档服务
- en: 'Once the service has been successfully configured, we can commence testing
    the service. Before we begin that activity, let''s take a moment to view the service
    architecture that has been built:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务成功配置完成，我们可以开始测试该服务。在开始这一活动之前，让我们先花点时间查看已构建的服务架构：
- en: '![](img/3b6781b2-fc94-4b6b-8850-1ce5044cb2a7.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b6781b2-fc94-4b6b-8850-1ce5044cb2a7.png)'
- en: Despite the simplicity of our service, the constituent components remove much
    of the complexity associated with processing information. The use of Cloud Storage
    negates the need to work with a database and provides an effective event notification
    system for content changes that are made to the storage.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的服务很简单，但其组成部分去除了与信息处理相关的大部分复杂性。使用云存储避免了与数据库打交道的需要，并为存储中内容变化提供了有效的事件通知系统。
- en: Once the data has been uploaded, the event notification generates a new Cloud
    Pub/Sub message containing relevant information on the file uploaded. Again, we
    are not required to do any processing to achieve this result. The Topic/Subscription
    mechanism provides all the message-processing capability required.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据上传，事件通知会生成一条新的云Pub/Sub消息，其中包含上传文件的相关信息。同样，我们不需要做任何处理就能实现这一结果。Topic/Subscription机制提供了所需的所有消息处理能力。
- en: Finally, the message that a new file has been uploaded reaches our PDF backend
    service. This is the point at which we see the inclusion of the image we built
    earlier. When Cloud Run executes, it receives the payload from Cloud Pub/Sub before
    seamlessly processing the information.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，表示新文件已上传的消息到达我们的PDF后端服务。这时我们会看到之前构建的图像被包含在内。当Cloud Run执行时，它会接收来自Cloud Pub/Sub的有效负载，然后无缝地处理信息。
- en: 'Why was it worth recounting what we did? Well, it should indicate how little
    we actually need to test in terms of the end-to-end process we''ve defined. Basically,
    we need to confirm the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么值得回顾我们所做的工作呢？嗯，这应该表明在我们定义的端到端过程里，我们实际上需要测试的内容非常少。基本上，我们需要确认以下几点：
- en: That the Storage Service uses a managed activity
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储服务使用的是一个托管活动
- en: That the Stream Processing Service uses a managed activity
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流处理服务使用的是一个托管活动
- en: That the PDF Service is based on our code
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PDF服务基于我们的代码
- en: So, how and what would we test with the PDF service?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们该如何测试PDF服务呢？
- en: Basic testing of the service can be performed by checking the service is online
    and by adding documents to the specified upload bucket.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的基本测试可以通过检查服务是否在线，以及将文档添加到指定的上传存储桶来进行。
- en: 'To test the PDF service is active, we will use the cURL program to retrieve
    an authorization token:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试PDF服务是否正常工作，我们将使用cURL程序来获取授权令牌：
- en: 'Initially, test that the service has been deployed successfully:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，测试服务是否已成功部署：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that we know the service is online, we can begin to test the service. Remember,
    we have added a Pub/Sub notification event to our upload storage. Once data is
    added, the message queue will be updated and send a request to the service to
    transform the data file.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道服务已上线，可以开始测试服务了。请记住，我们已经为上传存储添加了一个Pub/Sub通知事件。一旦数据被添加，消息队列将更新，并向服务发送请求以转换数据文件。
- en: 'Test the conversion process by uploading some public Qwiklabs example files:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过上传一些公共的Qwiklabs示例文件来测试转换过程：
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To confirm the files have been processed, check the processed Cloud Storage
    bucket:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要确认文件是否已被处理，请检查处理过的云存储桶：
- en: '![](img/d4911469-6b9b-44c6-9698-3034dc9f6a47.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4911469-6b9b-44c6-9698-3034dc9f6a47.png)'
- en: In the preceding screenshot, you will note that the original files have now
    been transformed into PDFs. Take a moment to also check the original upload folder
    on Cloud Storage and notice that the upload folder is now empty. What happened
    to all those files that were uploaded? Well, the application includes a hygiene
    element that also helpfully removes the files once they've successfully processed.
    Therefore, the upload folder only contains files that have not been converted.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，你会注意到原始文件现在已经转换成了PDF。花一点时间检查一下Cloud Storage中的原始上传文件夹，注意到上传文件夹现在已经为空。那些已经上传的文件都去哪了？嗯，应用程序包含了一个清理元素，它会在文件成功处理后自动删除这些文件。因此，上传文件夹只包含那些尚未转换的文件。
- en: There was a lot of work involved in this scenario; however, none of the techniques
    presented should be unfamiliar now that you've worked through the various chapters
    in this book. Congratulations on successfully creating the PDF service – learning
    how to build the components services will enable more complex systems to be developed
    over time.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个场景涉及了很多工作；然而，由于你已经完成了本书中各章节的学习，所呈现的技术现在应该不再陌生。恭喜你成功创建了PDF服务——学习如何构建组件服务将使得更复杂的系统随着时间的推移得以开发。
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we detailed the process for fulfilling project requirements
    with Google Cloud serverless technologies. As part of this process, we broke down
    the initial customer requirements and matched those to pre-existing Google Cloud
    products. Taking this approach significantly shortened our development cycle and
    minimized the level of testing required.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细介绍了如何使用 Google Cloud 无服务器技术来实现项目需求。在这个过程中，我们将初步的客户需求分解，并将其与现有的 Google
    Cloud 产品相匹配。采取这种方法大大缩短了我们的开发周期，并减少了所需的测试量。
- en: Working with serverless architectures on Google Cloud presents a number of opportunities
    to build some exciting applications. As we have seen in this chapter, the design
    and development process can be extremely rewarding. In most instances, working
    with the system to minimize both the code developed and the complexity of the
    application is time well spent. Our application example clearly demonstrates how
    using existing packages can significantly increase overall productivity and deliver
    on customer requirements. Hopefully, this chapter has ignited your imagination
    and provided the inspiration needed to build the next great application.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Google Cloud 上使用无服务器架构为构建一些令人兴奋的应用程序提供了许多机会。正如我们在本章中看到的，设计和开发过程可以非常有回报。在大多数情况下，与系统合作，减少开发的代码量和应用程序的复杂度，都是值得花时间去做的。我们的应用程序示例清楚地展示了如何使用现有的软件包显著提高整体生产力并满足客户需求。希望本章激发了你的想象力，并为你提供了构建下一个伟大应用程序的灵感。
- en: In the next chapter, we will introduce a more advanced example in which multiple
    services are run at the same time.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍一个更高级的示例，其中多个服务同时运行。
- en: Questions
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What command is used to access Google Cloud Storage from the command line?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用什么命令可以从命令行访问 Google Cloud Storage？
- en: When would Stackdriver Logging be the most useful?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Stackdriver 日志记录在什么情况下最有用？
- en: What is the purpose of a Docker manifest file?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker 清单文件的作用是什么？
- en: Where does Cloud Build store the images it creates?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cloud Build 会将它创建的镜像存储在哪里？
- en: The `curl` command can test GET and POST requests? (True or False)
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`curl` 命令可以测试 GET 和 POST 请求吗？（对还是错）'
- en: Why would you use the `gsutil` command with the `-m` parameter?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么要使用带有 `-m` 参数的 `gsutil` 命令？
- en: What type of permission is required to call a service?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用服务需要什么类型的权限？
- en: Further reading
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '**Connecting to Cloud Storage Buckets**: [https://cloud.google.com/compute/docs/disks/gcs-buckets](https://cloud.google.com/compute/docs/disks/gcs-buckets)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接到 Cloud Storage 存储桶**: [https://cloud.google.com/compute/docs/disks/gcs-buckets](https://cloud.google.com/compute/docs/disks/gcs-buckets)'
- en: '**Stackerdriver Logging**: [https://cloud.google.com/logging/docs/view/logs_index](https://cloud.google.com/logging/docs/view/logs_index)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Stackdriver 日志记录**: [https://cloud.google.com/logging/docs/view/logs_index](https://cloud.google.com/logging/docs/view/logs_index)'
- en: '**Qwiklabs Serverless Workshop**: [qwiklabs.com/quests/98](http://qwiklabs.com/quests/98)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qwiklabs 无服务器工作坊**: [qwiklabs.com/quests/98](http://qwiklabs.com/quests/98)'
