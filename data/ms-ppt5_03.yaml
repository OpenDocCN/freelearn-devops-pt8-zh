- en: Extending Puppet
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展Puppet
- en: The Puppet ecosystem, which is over 10 years old now, was originally written
    in Ruby.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet生态系统已有超过10年的历史，最初是用Ruby编写的。
- en: 'There has been a lot of progress made toward moving the main code base to the
    Clojure language (especially the main Puppet Server and PuppetDB components);
    however, there are still several parts of the ecosystem that can still be accessed
    at the Ruby level for the purposes of extending Puppet to suit more advanced use
    cases, namely the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管已经在将主代码库迁移到Clojure语言方面取得了很大进展（特别是主Puppet服务器和PuppetDB组件），但生态系统的某些部分仍然可以通过Ruby层进行访问，以便根据更高级的使用案例扩展Puppet，具体如下：
- en: Custom facts
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义Facts
- en: Custom functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义函数
- en: Types and providers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Types和Providers
- en: Let's consider each of these in turn, and see how we can extend Puppet on both
    the client and server side using firstly some rudimentary and then later some
    more advanced understanding of Ruby code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一考虑这些内容，看看如何利用最初的一些基础知识以及稍后的Ruby代码的更深入理解，在客户端和服务器端扩展Puppet。
- en: Custom facts
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义Facts
- en: Custom facts are a client-side technology for extracting arbitrary information
    from the node during the execution of the agent run, and they may be utilized
    in Puppet manifests or templates, along with any other distributed facts. Facts
    are executed on the Puppet agent.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义Facts是一种客户端技术，用于在执行代理运行期间从节点提取任意信息，并且可以在Puppet清单或模板中与任何其他分发的facts一起使用。Facts在Puppet代理上执行。
- en: The best way to create and distribute a new custom fact is to place it in a
    module, in the `facter` subdirectory of the `lib` directory, and it will then
    be distributed to the agent machine via `pluginsync`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和分发新的自定义fact的最佳方式是将其放置在一个模块中，放在`lib`目录的`facter`子目录中，然后通过`pluginsync`将其分发到代理机器。
- en: This documentation page at [https://puppet.com/docs/puppet/5.3/plugins_in_modules.html#adding-plug-ins-to-a-module](https://puppet.com/docs/puppet/5.3/plugins_in_modules.html#adding-plug-ins-to-a-module) shows
    you exactly where in a module to place your code, and the section at [https://puppet.com/docs/puppet/5.3/plugins_in_modules.html#installing-plug-ins](https://puppet.com/docs/puppet/5.3/plugins_in_modules.html#installing-plug-ins),
    in the same documentation, shows the technical details for `pluginsync`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇文档页面[https://puppet.com/docs/puppet/5.3/plugins_in_modules.html#adding-plug-ins-to-a-module](https://puppet.com/docs/puppet/5.3/plugins_in_modules.html#adding-plug-ins-to-a-module)准确地展示了在模块中放置代码的位置，而同一文档中的[https://puppet.com/docs/puppet/5.3/plugins_in_modules.html#installing-plug-ins](https://puppet.com/docs/puppet/5.3/plugins_in_modules.html#installing-plug-ins)部分则展示了`pluginsync`的技术细节。
- en: 'The following diagram illustrates the `pluginsync` process that precedes a
    normal catalog request. Usually, a `GET` method is called on the Puppet server
    using the FQDN, which then initiates the `pluginsync` process, and the appropriate
    facts, types, and providers are distributed back to the agent:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了在正常目录请求之前的`pluginsync`过程。通常，通过使用FQDN在Puppet服务器上调用`GET`方法，然后启动`pluginsync`过程，将适当的facts、types和providers分发回代理：
- en: '![](img/d31e01c4-ec1c-4801-a206-e03360fb7f18.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d31e01c4-ec1c-4801-a206-e03360fb7f18.png)'
- en: You can review the exact details for all the HTTPS communication between the
    Puppet agent and Puppet Server at [https://puppet.com/docs/puppet/5.3/subsystem_agent_master_comm.html](https://puppet.com/docs/puppet/5.3/subsystem_agent_master_comm.html).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看Puppet代理和Puppet服务器之间所有HTTPS通信的详细信息，访问[https://puppet.com/docs/puppet/5.3/subsystem_agent_master_comm.html](https://puppet.com/docs/puppet/5.3/subsystem_agent_master_comm.html)。
- en: 'Most of the time, I have found that a fact is generally just an execution of
    an arbitrary command-line expression, and that is a good way to think generally
    about facts: they effectively consist of a Ruby wrapper, usually around a command-line
    expression that makes itself available to the Puppet ecosystem via Facter.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，我发现fact通常只是执行一个任意的命令行表达式，这也是一般理解facts的好方法：它们实际上是一个Ruby包装器，通常围绕一个命令行表达式，使其通过Facter对Puppet生态系统可用。
- en: 'The following code would be a good snippet to use as a template for further
    development:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个不错的代码片段，可以作为进一步开发的模板：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Do make sure that you `confine` your fact appropriately. There's nothing worse
    than when you introduce a new operating system to your infrastructure only to
    find that you are now executing failing facts because they don't use a certain
    command syntax. Or, what if we suddenly introduce a handful of Windows nodes,
    only to find that Windows doesn't, of course, understand most Linux commands?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你适当地`confine`你的事实。没有什么比当你为基础设施引入一个新操作系统时，发现因为它们没有使用特定的命令语法而执行失败的事实更糟糕了。或者，如果我们突然引入一批Windows节点，结果发现Windows当然不理解大多数Linux命令，那该怎么办？
- en: Bear this in mind during your authoring of custom facts.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写自定义事实时，请记住这一点。
- en: Debugging facts
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试事实
- en: 'You can debug Facter by using a `facter.debug` statement anywhere in your custom
    fact''s Ruby code, as shown in the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在自定义事实的Ruby代码中使用`facter.debug`语句来调试Facter，如下所示：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'During debugging, running Facter by itself won''t pick up your new custom fact
    since it would usually require the `pluginsync` process to distribute it. You
    must set the `FACTERLIB` environment variable to shortcut this process when you
    are developing and debugging the new code on your development node. Let''s say
    you have the `some_facts` and `some_other_facts` subdirectories in your personal
    working directory, where you are editing the Ruby code for a new fact you are
    developing. You would set the code up as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试过程中，单独运行Facter不会识别你新增的自定义事实，因为它通常需要`pluginsync`过程来分发。你必须设置`FACTERLIB`环境变量，以便在开发和调试新代码时简化这个过程。假设你在个人工作目录中有`some_facts`和`some_other_facts`子目录，里面是你正在编辑的新事实的Ruby代码。你可以按如下方式设置代码：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Custom functions
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义函数
- en: This is where custom facts allow us to run arbitrary code on the client side.
    Custom functions are a *server-side* technology that assist you in the compilation
    of a catalog. Functions are executed on the Puppet server. Puppet already includes
    several functions that are built-in, and additional ones are contained in Puppet
    Forge modules, particularly the `stdlib` module (see [https://forge.puppet.com/puppetlabs/stdlib](https://forge.puppet.com/puppetlabs/stdlib)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义事实允许我们在客户端运行任意代码。这是一个*服务器端*技术，帮助你编译目录。函数在Puppet服务器上执行。Puppet已经包含了多个内置函数，额外的函数可以通过Puppet
    Forge模块获得，尤其是`stdlib`模块（参见[https://forge.puppet.com/puppetlabs/stdlib](https://forge.puppet.com/puppetlabs/stdlib)）。
- en: 'There are, in fact, three possible ways to create custom functions, although
    you are unlikely to use the first two, so I will just leave you with some links
    to the Puppet documentation for those options:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，有三种可能的方式来创建自定义函数，尽管你不太可能使用前两种方式，所以我会提供一些链接到Puppet文档，以供参考这些选项：
- en: You could write the function in Puppet DSL (see [https://puppet.com/docs/puppet/5.3/lang_write_functions_in_puppet.html](https://puppet.com/docs/puppet/5.3/lang_write_functions_in_puppet.html)),
    although you'll be unable to take advantage of the more powerful Ruby API.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用Puppet DSL编写函数（参见[https://puppet.com/docs/puppet/5.3/lang_write_functions_in_puppet.html](https://puppet.com/docs/puppet/5.3/lang_write_functions_in_puppet.html)），尽管你将无法利用更强大的Ruby
    API。
- en: You could write the function in the legacy Ruby functions API (see [https://puppet.com/docs/puppet/5.3/functions_legacy.html](https://puppet.com/docs/puppet/5.3/functions_legacy.html)),
    although this is to be avoided unless you must specifically support Puppet 3.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用旧版Ruby函数API来编写函数（参见[https://puppet.com/docs/puppet/5.3/functions_legacy.html](https://puppet.com/docs/puppet/5.3/functions_legacy.html)），尽管除非你必须特别支持Puppet
    3，否则应该避免使用这种方式。
- en: You could write the function in the modern Ruby function API. This is what we'll
    concentrate on for the remainder of this section.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用现代Ruby函数API来编写函数。这也是我们在本节剩余部分将要集中讨论的内容。
- en: 'The best way to create and distribute a new custom function is to place it
    in a module, in the `puppet/functions/<modulename>` subdirectory of the `lib`
    directory, and it will then be distributed via `pluginsync`, as shown in the following
    code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和分发新自定义函数的最佳方式是将其放在模块中，在`lib`目录下的`puppet/functions/<modulename>`子目录中，然后通过`pluginsync`进行分发，如下所示：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Types and providers
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型和提供者
- en: Puppet already has a very rich lexicon of built-in resource types (see [https://puppet.com/docs/puppet/5.3/type.html](https://puppet.com/docs/puppet/5.3/type.html)),
    and these have also been extended with additional modules. Windows-specific resource
    types would be a very good example of where Puppet has had its resource types
    successfully extended (see [https://puppet.com/docs/puppet/5.3/resources_windows_optional.html](https://puppet.com/docs/puppet/5.3/resources_windows_optional.html)).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 已经有一个非常丰富的内置资源类型词汇表（请参见 [https://puppet.com/docs/puppet/5.3/type.html](https://puppet.com/docs/puppet/5.3/type.html)），这些词汇表也通过额外的模块得到了扩展。Windows
    特定的资源类型就是 Puppet 成功扩展其资源类型的一个很好的例子（请参见 [https://puppet.com/docs/puppet/5.3/resources_windows_optional.html](https://puppet.com/docs/puppet/5.3/resources_windows_optional.html)）。
- en: 'The following are some indications that you may want to consider writing a
    type and provider as an alternative to regular modules and manifests in Puppet
    DSL:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些你可能需要考虑编写类型和提供程序，作为 Puppet DSL 中常规模块和清单的替代方案的迹象：
- en: You have several `exec` statements in your Puppet DSL with convoluted `onlyif`
    and `unless` conditional properties
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的 Puppet DSL 中有多个 `exec` 语句，带有复杂的 `onlyif` 和 `unless` 条件属性
- en: 'Puppet doesn''t handle situation very well where:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet 在以下情况的处理并不理想：
- en: Your Puppet DSL is not a powerful-enough API, and you need access to pure Ruby
    to manipulate data
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的 Puppet DSL 不是一个足够强大的 API，你需要访问纯 Ruby 来操作数据。
- en: Your Puppet DSL code has significant and quite convoluted conditional logic
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的 Puppet DSL 代码具有复杂且相当复杂的条件逻辑。
- en: Types
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型
- en: 'Go through the following steps to create your type:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建你的类型：
- en: Create and distribute the type
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并分发类型
- en: Add the `namevar` special attribute
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `namevar` 特殊属性
- en: Add additional type properties
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加额外的类型属性
- en: Add the optional `ensure` property
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加可选的`ensure`属性
- en: Add type parameters
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加类型参数
- en: Set the property and parameter defaults
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置属性和参数的默认值
- en: Check the input value with a validate block
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用验证块检查输入值
- en: Check the input value against a `newvalues` array
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查输入值是否与`newvalues`数组匹配
- en: Check datatype compatibility with `munge`
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `munge` 检查数据类型兼容性
- en: Use `AutoRequire` for implicit relationships
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`AutoRequire`来处理隐式关系
- en: Use `Arrays`to list the values of an attribute
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Arrays`来列出属性的值。
- en: Use the `desc` method to add inline documentation
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`desc`方法添加内联文档
- en: Check out the official documentation page on Puppet types at [https://puppet.com/docs/puppet/5.3/custom_types.html](https://puppet.com/docs/puppet/5.3/custom_types.html). Gary
    Larizza's blog also offers an alternative set of useful examples of types at [http://garylarizza.com/blog/2013/11/25/fun-with-providers/](http://garylarizza.com/blog/2013/11/25/fun-with-providers/).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 查看官方文档页面上的 Puppet 类型：[https://puppet.com/docs/puppet/5.3/custom_types.html](https://puppet.com/docs/puppet/5.3/custom_types.html)。Gary
    Larizza 的博客也提供了一组有用的类型示例：[http://garylarizza.com/blog/2013/11/25/fun-with-providers/](http://garylarizza.com/blog/2013/11/25/fun-with-providers/)。
- en: Let's now go through each of these steps to create your new type in more detail
    in the following sections.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐步查看每个步骤，在接下来的部分中更详细地创建你的新类型。
- en: Creating and distributing the type
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建并分发类型
- en: The best way to create and distribute a new custom type is to place it into
    a module, in the `puppet/type` subdirectory of the `lib` directory, and it will
    then be distributed to the agent machine via `pluginsync`, as we already saw with
    custom facts in the previous section.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和分发一个新的自定义类型的最佳方式是将其放入模块中，放在 `lib` 目录下的 `puppet/type` 子目录中，然后通过 `pluginsync`
    将其分发到代理机器，就像我们在上一节中看到的自定义事实一样。
- en: 'The filename should match the name of the type under development, as shown
    in the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名应与正在开发的类型名称相匹配，如下方代码所示：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Adding the namevar special attribute
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 `namevar` 特殊属性
- en: 'After we make use of the special attribute of the type, that is its `namevar`,
    we can then actually use a declaration of our resource using the Puppet DSL. The
    `namevar` should identify the resource uniquely within the underlying operating
    system, and must be something that can be prespecified, as shown in the following
    code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用类型的特殊属性后，也就是它的`namevar`，我们就可以实际使用 Puppet DSL 来声明我们的资源。`namevar` 应该唯一地标识底层操作系统中的资源，并且必须是可以预先指定的，如下方代码所示：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we can declare our resource in the Puppet DSL. In this case, the `namevar`
    defaults to the resource title, as shown in the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在 Puppet DSL 中声明我们的资源。在这种情况下，`namevar` 默认为资源标题，如下方代码所示：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The resource title is used to make a reference to the resource uniquely inside
    the Puppet catalog. Hence, the `namevar` indicates the underlying system''s name
    for that resource, as shown in the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 资源标题用于在 Puppet 目录中唯一地引用该资源。因此，`namevar` 表示底层系统中该资源的名称，如以下代码所示：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, run the following command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行以下命令：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Adding additional type properties
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加额外的类型属性
- en: Type properties are attributes that reflect the current state of that resource
    on the underlying operating system.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 类型属性是反映底层操作系统中该资源当前状态的属性。
- en: 'During the Puppet run, these values are actively enforced, so they should be
    both *discoverable* and *updatable*. If the attribute can''t be updated, it could
    be implemented as a read-only property. In the following code, we are extending
    our example type''s interface to define a version property:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puppet 执行过程中，这些值会被积极执行，因此它们应该是*可发现的*和*可更新的*。如果属性不能更新，它可以作为只读属性来实现。在以下代码中，我们正在扩展示例类型的接口以定义一个版本属性：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we start to use that property in the Puppet DSL, as shown in the following
    code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始在 Puppet DSL 中使用该属性，如以下代码所示：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'But it won''t allow the catalog to compile yet, since there''s no implementation
    for that property in any corresponding provider, as shown in the following command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 但它还无法使目录编译，因为在任何相应的提供者中都没有该属性的实现，如以下命令所示：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Adding the optional ensure property
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加可选的 ensure 属性
- en: 'Although optional, most native Puppet resource types do have an `ensure` property,
    although there are exceptions—for example, `. exec` and `notify`. You simply give
    the resource type the `ensure` property by immediately calling `ensurable`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管是可选的，大多数原生 Puppet 资源类型确实有 `ensure` 属性，但也有一些例外——例如 `. exec` 和 `notify`。你只需通过立即调用
    `ensurable` 来为资源类型添加 `ensure` 属性：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The corresponding providers for this type would then implement the `ensure`
    property through the use of `create`, `exists?`, and `destroy` methods.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 该类型的相应提供者随后将通过使用 `create`、`exists?` 和 `destroy` 方法实现 `ensure` 属性。
- en: 'In Puppet DSL, the `ensure` property should be the first attribute in the resource
    (according to the Puppet style guidelines), and it supports the `present` and
    `absent` keywords (`present` being the default, so it may be omitted for the sake
    of brevity), as shown in the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puppet DSL 中，`ensure` 属性应该是资源中的第一个属性（根据 Puppet 风格指南），它支持 `present` 和 `absent`
    关键字（`present` 是默认值，因此为了简洁可以省略），如以下代码所示：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Adding type parameters
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加类型参数
- en: '`Type` parameters differ from properties in that they don''t directly relate
    to actual discoverable and updatable resources on the underlying system. Rather,
    they do one of the two following things:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Type` 参数不同于属性，因为它们不直接与底层系统上的实际可发现和可更新资源相关联。相反，它们执行以下两种操作之一：'
- en: Allow you to specify additional informational context for interacting with properties
    and resources on the underlying system
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许你为与底层系统上的属性和资源交互提供额外的信息上下文
- en: Provide a layer of abstraction allowing you to override the expected behavior
    on the underlying system
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个抽象层，允许你覆盖底层系统上的预期行为
- en: 'Let''s add a `source` parameter to our new type using the `newparam` method:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `newparam` 方法向我们的新类型添加一个 `source` 参数：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Setting property and parameter defaults
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置属性和参数默认值
- en: 'Let''s say we wanted to add an additional `override` parameter, which we wanted
    to configure with a default value of `false`. Here''s the Ruby code to express
    that:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要添加一个额外的 `override` 参数，我们希望它的默认值为 `false`。以下是表达该功能的 Ruby 代码：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Checking the input value with a validate block
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用验证块检查输入值
- en: 'We can validate the provided value of a new property called `version` with
    a `validate` block and, for example, a `regex` expression, as shown in the following
    code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `validate` 块和例如 `regex` 表达式来验证新属性 `version` 的提供值，如以下代码所示：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Checking the input value against a newvalues array
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将输入值与 newvalues 数组进行检查
- en: 'We can also validate the provided value of the property with an array of values
    using the `newvalues` method, as shown in the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `newvalues` 方法，用值数组验证属性提供的值，如以下代码所示：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Checking datatype compatibility with munge
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 munge 检查数据类型兼容性
- en: To decide whether an underlying provider property should be updated, a simple
    equality comparison is made between the provided value and the value retrieved
    using the provider.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了决定是否更新底层提供程序的属性，会对提供的值与通过提供程序获取的值进行简单的相等性比较。
- en: 'The `munge` method can ensure that the data supplied by the user has a consistent
    datatype with that expected to be returned from the provider. For example, we
    could call the `munge` method to make sure that the user-supplied datatype of
    `integer` or `numeric string` is compatible with the `integer` required by the
    provider, as shown in the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`munge`方法可以确保用户提供的数据与预期返回的提供程序数据类型一致。例如，我们可以调用`munge`方法，确保用户提供的`integer`或`numeric
    string`数据类型与提供程序要求的`integer`兼容，如以下代码所示：'
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using autorequire for implicit relationships
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`autorequire`来处理隐式关系
- en: To make it easier for users of your type, you can use `autorequire`  to avoid
    tediously specifying a lot of explicit relationships in longhand between resources.
    The `autorequire` method establishes implicit ordering between resources in the
    catalog. A typical example of this would be filing resources depending on their
    parent directories.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使您的类型用户更方便，您可以使用`autorequire`来避免在资源之间冗长地指定许多显式关系。`autorequire`方法在目录中建立了资源之间的隐式排序。一个典型的例子是文件资源依赖于其父目录。
- en: 'For example, in our type, if the `source` parameter is a file path, then we
    should ensure the corresponding `file` resource is managed first, as shown in
    the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的类型中，如果`source`参数是文件路径，那么我们应该确保首先管理相应的`file`资源，如以下代码所示：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Manually specified dependencies in the Puppet DSL have a higher precedence for
    the compiler than the implicit dependencies that are put in place by virtue of
    the `autorequire` method.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在Puppet DSL中手动指定的依赖关系比通过`autorequire`方法建立的隐式依赖关系具有更高的优先级。
- en: Using arrays to assign a list of values to an attribute
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数组将值列表分配给属性
- en: 'When the expected value of an attribute is an array, the `array_matching` option
    should be included in the call to `newproperty` with a value of `all`. All values
    of the array are then used for that attribute, as shown in the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当属性的预期值是数组时，`array_matching`选项应包含在调用`newproperty`时，并且其值应为`all`。然后，数组中的所有值都将用于该属性，如以下代码所示：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Using the desc method to add inline documentation
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`desc`方法添加内联文档
- en: 'Users of your new type can use the `puppet describe` and `puppet doc` commands
    to fetch the inline documentation you''ve configured. For a full description of
    all the types currently configured in your environment, including custom resources,
    run the following command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您的新类型的用户可以使用`puppet describe`和`puppet doc`命令来获取您配置的内联文档。要获取当前环境中所有已配置类型的完整描述，包括自定义资源，请运行以下命令：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s finish our type example now by adding some inline documentation using
    the `desc` method:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过使用`desc`方法添加一些内联文档来完成我们的类型示例：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Providers
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供程序
- en: Providers are the implementation of the resources on a system. Types express
    the interface used in describing the resources, whereas providers provide the
    implementation about how the resources interact with the underlying system.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 提供程序是资源在系统上的实现。类型表达了描述资源时使用的接口，而提供程序则提供了资源如何与底层系统交互的实现。
- en: The separation between the interface and its implementation allows multiple
    providers to be developed for a type.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接口与其实现之间的分离使得可以为一个类型开发多个提供程序。
- en: The `package` type provided as part of a Puppet installation, for example, has
    many separate providers that interact with systems, including `rpm`, `apt`, `yum`,
    `zipper`, `chocolatey`, and so on. All that's needed for a new provider to be
    developed is for it to adhere to the interface defined in its type.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Puppet安装的一部分提供的`package`类型，包含许多与系统交互的独立提供程序，例如`rpm`、`apt`、`yum`、`zipper`、`chocolatey`等。开发新的提供程序所需的唯一条件是它遵循在其类型中定义的接口。
- en: You can check out the official documentation pages on Puppet providers at [https://puppet.com/docs/puppet/5.3/custom_types.html#providers](https://puppet.com/docs/puppet/5.3/custom_types.html#providers)
    and [https://puppet.com/docs/puppet/5.3/provider_development.html](https://puppet.com/docs/puppet/5.3/provider_development.html). Gary
    Larizza's blog also offers an alternative set of useful examples on providers
    at [http://garylarizza.com/blog/2013/11/26/fun-with-providers-part-2/](http://garylarizza.com/blog/2013/11/26/fun-with-providers-part-2/).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看Puppet提供者的官方文档页面：[https://puppet.com/docs/puppet/5.3/custom_types.html#providers](https://puppet.com/docs/puppet/5.3/custom_types.html#providers)和[https://puppet.com/docs/puppet/5.3/provider_development.html](https://puppet.com/docs/puppet/5.3/provider_development.html)。Gary
    Larizza的博客也提供了一组有关提供者的有用示例：[http://garylarizza.com/blog/2013/11/26/fun-with-providers-part-2/](http://garylarizza.com/blog/2013/11/26/fun-with-providers-part-2/)。
- en: 'Go through the following steps to create a new provider for your type:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤为您的类型创建新提供者：
- en: Create and distribute your provider
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并分发您的提供者
- en: 'Indicate the suitability of the provider to the type in the following ways:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下方式可以指示提供者是否适合该类型：
- en: Using the `confine` method
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`confine`方法
- en: Using the `defaultfor` method
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`defaultfor`方法
- en: Using the `commands` method
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`commands`方法
- en: Implement the `ensure` property
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`ensure`属性
- en: Using the `exists?` method
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`exists?`方法
- en: Using the `create` and `destroy` methods
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`create`和`destroy`方法
- en: Use the `GET` and `SET` methods to manage type properties
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`GET`和`SET`方法来管理类型属性
- en: Implement the `self.instances` method
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`self.instances`方法
- en: Let's now go into more detail for each of these steps for creating your new
    provider in the following sections.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将详细介绍创建新提供者的每个步骤。
- en: Creating and distributing the provider
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建并分发提供者
- en: 'The best way to create and distribute a new provider for your type is to place
    it into the same module, in the `puppet/provider/<typename>` subdirectory of the
    `lib` directory, and it will then be distributed to the agent machine via `pluginsync`.
    Note that the filename should match the name of the provider, as shown in the
    following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和分发新提供者的最佳方式是将其放入相同模块中，位于`lib`目录下的`puppet/provider/<typename>`子目录中，然后通过`pluginsync`将其分发到代理机器。请注意，文件名应与提供者的名称匹配，如下代码所示：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Indicating the suitability of the provider to the type
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指示提供者是否适合该类型
- en: The `confine` and `commands` methods are used to ascertain which providers are
    valid for the type, and the `defaultfor` method is used to indicate the default
    provider where there are multiple providers. Let's take a look at each of these
    methods.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`confine`和`commands`方法用于确定哪些提供者对该类型有效，而`defaultfor`方法用于在有多个提供者时指示默认提供者。我们来看看这些方法的使用。'
- en: Using the confine method
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`confine`方法
- en: 'The `confine` method can be used with a fact, as shown in the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`confine`方法可以与fact一起使用，如下代码所示：'
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `confine` method could also use `exisits` to base its conditions on whether
    a certain file is present on the system under management. The following example
    demonstrates how the provider is restricted to only those systems where Puppet''s
    `.config` file exists:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`confine`方法也可以使用`exists`来基于系统管理下是否存在特定文件作为条件。以下示例演示了如何将提供者限制为仅在Puppet的`.config`文件存在的系统上：'
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Another possibility is to base the conditions of the `confine` method on certain
    Puppet features (they are all listed in the source code directory at [https://github.com/puppetlabs/puppet/tree/master/lib/puppet/feature](https://github.com/puppetlabs/puppet/tree/master/lib/puppet/feature)),
    as shown in the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是基于某些Puppet特性来设置`confine`方法的条件（这些特性都列在源码目录的[https://github.com/puppetlabs/puppet/tree/master/lib/puppet/feature](https://github.com/puppetlabs/puppet/tree/master/lib/puppet/feature)中），如下代码所示：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, `confine` can accept a Boolean expression to restrict your provider,
    as shown in the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`confine`可以接受一个布尔表达式来限制您的提供者，如下代码所示：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Using the defaultfor method
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`defaultfor`方法
- en: The `confine` method is fine, but its usage may still result in multiple valid
    providers for a particular resource type. In this circumstance, the type should
    specify its preferred provider using the `defaultfor` method.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`confine`方法很好，但其使用可能仍会导致特定资源类型有多个有效的提供者。在这种情况下，类型应该使用`defaultfor`方法指定其首选提供者。'
- en: The `defaultfor` method uses a fact name and value as its arguments, which are
    then used to determine the default provider for certain types of underlying system.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultfor`方法使用事实名称和值作为其参数，随后用于确定某些类型底层系统的默认提供者。'
- en: 'For example, on Red Hat systems, both `yum` and `rpm` would be valid as providers
    to the package resource type, but the `defaultfor` method would be used to indicate
    that for Red Hat systems, `yum` is in fact the default provider, as shown in the
    following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Red Hat系统上，`yum`和`rpm`都可以作为包资源类型的有效提供者，但`defaultfor`方法将用于指示对于Red Hat系统，`yum`实际上是默认提供者，如以下代码所示：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Using the commands method
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`commands`方法
- en: Confining providers may also be based on the availability of certain commands
    from the system path using the `commands` method.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 限定提供者也可以基于系统路径中某些命令的可用性，通过`commands`方法来实现。
- en: 'More importantly, by using the special methods generated by `commands`, we
    can also inform Puppet of the correct commands for interacting with the underlying
    system. This is preferable over Ruby''s own methods for command execution, such
    as `%x{cmd}` or `cmd` for the following reasons:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，通过使用`commands`生成的特殊方法，我们还可以告知Puppet与底层系统交互的正确命令。这比使用Ruby自带的命令执行方法（如`%x{cmd}`或`cmd`）更为可取，原因如下：
- en: Puppet displays commands invoked this way when the `--debug` flag is set
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当设置`--debug`标志时，Puppet会显示以这种方式调用的命令
- en: They are documented as a requirement for the provider
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们作为提供者的要求已被记录
- en: Exceptions are handled consistently by raising a `Puppet::ExecutionFalure`
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常通过抛出`Puppet::ExecutionFalure`一致地处理
- en: 'This is shown in the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了这一点：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Implementing the ensure property
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现`ensure`属性
- en: In order to implement the `ensure` property, the providers need to be able to
    ascertain whether the resource exists, create the resource where it doesn't exist,
    and destroy resources that exist. This is implemented by virtue of the `exists?`,
    `create`, and `destroy` methods, which we will look at in the following sections.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现`ensure`属性，提供者需要能够判断资源是否存在，在不存在时创建资源，并在存在时销毁资源。这是通过`exists?`、`create`和`destroy`方法实现的，接下来的部分将会详细介绍这些方法。
- en: Using the exists? method
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`exists?`方法
- en: 'The `exists?` method retrieves the `ensure` state of the resource. A Boolean
    is returned, as shown in the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`exists?`方法检索资源的`ensure`状态。返回布尔值，如以下代码所示：'
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Using the create and destroy methods
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`create`和`destroy`方法
- en: The existence state of a resource is modified with reference to the declaration
    of the resource with the `ensure` property by the user in the Puppet DSL by using
    the `create` and `destroy` methods.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 资源的存在状态通过参考用户在Puppet DSL中声明的带有`ensure`属性的资源声明，使用`create`和`destroy`方法进行修改。
- en: 'The `create` method is called when both of the following criteria have been
    met:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当满足以下两个条件时，调用`create`方法：
- en: The `ensure` property has been set to `present` in the resource declaration
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在资源声明中，`ensure`属性已设置为`present`
- en: The `false` value is returned by the `exists?` method (to indicate that the
    resource doesn't already exist)
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`false`值由`exists?`方法返回（表示资源不存在）'
- en: 'The `destroy` method is called when both of the following criteria have been
    met:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当满足以下两个条件时，调用`destroy`方法：
- en: The `ensure` property has been set as `absent` in the resource declaration
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在资源声明中，`ensure`属性已设置为`absent`
- en: The `true` value is returned by the `exists?` method (to indicate that the resource
    already exists)
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`true`值由`exists?`方法返回（表示资源已存在）'
- en: 'The following code shows how you can use these methods:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何使用这些方法：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Using the GET and SET methods to manage type properties
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`GET`和`SET`方法来管理类型属性
- en: Each property defined in the type should implement a `GET` and `SET` method
    in the provider.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 类型中定义的每个属性应在提供者中实现`GET`和`SET`方法。
- en: 'Puppet will then invoke these methods during a Puppet run to manage the property
    as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet随后会在运行期间调用这些方法来管理属性，如下所示：
- en: The `GET` method is called initially to retrieve the current value
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GET`方法最初被调用以检索当前值'
- en: This is subsequently compared against the value declared by the user in the
    Puppet DSL
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这随后与用户在Puppet DSL中声明的值进行比较
- en: If the values are different, then the `SET` method is invoked to update that
    value if necessary.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果值不同，则调用`SET`方法根据需要更新该值。
- en: 'This is shown in the following code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这在以下代码中有所展示：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Implementing the self.instances method
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现`self.instances`方法
- en: Puppet provides an additional mode of operation, that being the discovery of
    resources using the `puppet resource` command. The `self.instances` method should
    implement the return of any instances of a particular resource type that the provider
    is able to find on the underlying system.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 提供了额外的操作模式，即使用 `puppet resource` 命令来发现资源。`self.instances` 方法应实现返回提供程序能够在底层系统上找到的特定资源类型的任何实例。
- en: 'The following example illustrates the use of the `rpm -qa` command to query
    for all packages installed on the underlying Red Hat system:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何使用 `rpm -qa` 命令查询底层 Red Hat 系统上安装的所有软件包：
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Each resource returned by `self.instances` stores the attributes in the `@property_hash` instance
    variable. All the other methods in the provider have access to the property hash,
    so we could implement the `exists?` and `version` methods in our provider in a
    much simpler way, as shown in the following code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.instances` 返回的每个资源都会将属性存储在 `@property_hash` 实例变量中。提供程序中的所有其他方法都可以访问该属性哈希，因此我们可以以更简单的方式实现
    `exists?` 和 `version` 方法，如以下代码所示：'
- en: '[PRE35]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at extending Puppet with client-side facts, server-side
    custom functions, and custom types and providers. You can see that with some Ruby
    know-how, you can easily extend the Puppet ecosystem to cover some of your own
    unique requirements.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何通过客户端事实、服务器端自定义函数以及自定义类型和提供程序来扩展 Puppet。你可以看到，凭借一些 Ruby 知识，你可以轻松地扩展
    Puppet 生态系统，以满足你自己独特的需求。
- en: In the next chapter, we'll be taking a look at Hiera 5, which we'll use to create
    a separation between code and business data.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 Hiera 5，我们将使用它在代码与业务数据之间创建分离。
