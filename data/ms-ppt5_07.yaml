- en: Continuous Integration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: Continuous Integration as a practice is ensuring that each time code is committed,
    it is built and tested the same way consistently. We use Continuous Integration
    systems to automate this practice, making it practical for use on every commit.
    Some Continuous Integration pipelines eventually evolve into Continuous Delivery
    or Continuous Deployment pipelines. The key difference between Continuous Integration
    and delivery is that delivery ensures that every time code is committed, it is
    also wrapped up (or packaged) and delivered to the doorstep of the server it needs
    to run on. Continuous Delivery requires the ability to deploy your entire infrastructure
    and application consistently with a single orchestration command. Continuous Deployment
    requires an end-to-end suite of tests for every component in your infrastructure,
    but is the simple task of automating that single orchestration command when every
    test passes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成作为一种实践，确保每次提交代码时，代码都能以一致的方式进行构建和测试。我们使用持续集成系统来自动化这一实践，使其可以在每次提交时都能实际使用。一些持续集成管道最终会演变为持续交付或持续部署管道。持续集成与交付的关键区别在于，交付确保每次提交代码时，代码也会被打包并交付到所需运行的服务器上。持续交付要求能够通过单一的协调命令一致地部署整个基础设施和应用程序。持续部署要求为基础设施中的每个组件提供端到端的测试套件，但它的任务非常简单，就是在每个测试通过时自动执行该单一协调命令。
- en: How these systems become useful to the individual application and infrastructure
    is unique to every company and organization, much like any other business rule.
    There are some common use cases and business rules that are nearly universal in
    everyone's Continuous Integration pipelines, and some that teams strive for.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些系统如何为单个应用程序和基础设施提供价值，对每个公司和组织来说都是独一无二的，就像任何其他业务规则一样。有一些常见的使用案例和几乎在每个人的持续集成管道中普遍存在的业务规则，也有一些是团队所追求的目标。
- en: 'In this chapter, we will do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下几件事：
- en: Set up a Continuous Integration system (Jenkins) using Puppet
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Puppet设置一个持续集成系统（Jenkins）
- en: Create a job for a profile module
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为配置模块创建一个作业
- en: Set up our first test
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置我们的第一个测试
- en: Integrate the **Puppet Development Kit** (**PDK**) test suite
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成**Puppet开发工具包**（**PDK**）测试套件
- en: Write RSPec unit tests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写RSPec单元测试
- en: Set up Puppet integration tests with Test Kitchen
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Test Kitchen设置Puppet集成测试
- en: Continuous Integration systems
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成系统
- en: Our Continuous Integration system is a panel that keeps track of our code repositories.
    For each of these repositories, you'll find what is commonly referred to as a
    job. A job is a series of steps, usually written in code, that informs the system
    of what it should do when a build is triggered through a button or CLI. A build
    is simply a single instance of that job that is running or has already run. Finally,
    that build contains log files, key information about the build, and any artifacts
    (objects) you want the system to store or ship off closer to the endpoint.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的持续集成系统是一个面板，用于跟踪我们的代码仓库。对于每个这些仓库，你将看到通常所称的作业。作业是一系列步骤，通常是用代码编写的，用来告诉系统在通过按钮或命令行触发构建时应该做什么。构建只是该作业的一个实例，正在运行或已运行。最后，构建包含日志文件、关于构建的关键信息以及任何你希望系统存储或发送到终端的工件（对象）。
- en: We'll build our CI system using Puppet, which will eventually manage our Puppet
    code. This is a common scenario when you start with CI in an existing environment
    in an organization.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Puppet构建我们的CI系统，最终由它来管理我们的Puppet代码。这是当你在一个已有环境中开始使用CI时的常见场景。
- en: Puppet Pipelines
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Puppet Pipelines
- en: 'Puppet Pipelines is a new product by Puppet. In September of 2017, Puppet acquired
    Distelli so that they could build the new Puppet Pipelines program. This CI system
    is still heavily geared toward containers and applications, but work is being
    done to improve its feature set for Puppet as well. Puppet Pipelines can still
    be used for a Continuous Integration system for puppet code, but may undergo quite
    a few changes in the next year around Puppet code. For this chapter, we''ll be
    using a very popular open source Continuous Integration system: Jenkins.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet Pipelines是Puppet推出的新产品。2017年9月，Puppet收购了Distelli，以便开发新的Puppet Pipelines程序。这个CI系统仍然主要面向容器和应用程序，但也在努力改善其Puppet功能。Puppet
    Pipelines仍然可以用于Puppet代码的持续集成系统，但在未来一年中，关于Puppet代码的功能可能会经历很多变化。本章中，我们将使用一个非常流行的开源持续集成系统：Jenkins。
- en: Jenkins
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jenkins
- en: Jenkins is one of the oldest and most common Continuous Integration systems
    fielded today. It began as Hudson initially, in 2005, and grew into the fork of
    Jenkins that we see today. Jenkins is both a powerful and complicated system in
    comparison to most other CI systems due to its highly pluggable nature. There
    are a plethora of Jenkins plugins designed to add features to the CI system, from
    source code management, to graphs and viewing, to orchestration and automated
    testing and linting for nearly every language. With this wide feature set, Jenkins
    can also often be complicated. Out of the box, Jenkins doesn't do a whole lot
    outside of running shell commands on the system. In this section, we'll be exploring
    how to build a bare basic Jenkins setup for our needs, using Puppet, to manage
    our Puppet code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 是目前最古老、最常用的持续集成系统之一。它最初是作为 Hudson 于 2005 年开始的，并逐渐发展成我们今天看到的 Jenkins
    分支。与大多数其他持续集成系统相比，Jenkins 因其高度插件化的特性，既强大又复杂。有大量的 Jenkins 插件用于为持续集成系统添加功能，从源代码管理、图表和视图，到编排、自动化测试和几乎所有编程语言的代码风格检查。凭借这些广泛的功能集，Jenkins
    也常常变得复杂。开箱即用的 Jenkins 除了在系统上运行 shell 命令外并没有太多功能。在本节中，我们将探索如何使用 Puppet 构建一个基本的
    Jenkins 配置，以便管理我们的 Puppet 代码。
- en: Managing Jenkins with Puppet
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Puppet 管理 Jenkins
- en: We're using Puppet to manage the Continuous Integration system, because it's
    a system. We're using Jenkins to manage our configuration management code, because
    it's code. This is why we'll build Jenkins with Puppet, and then check our Puppet
    code into Jenkins.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Puppet 来管理持续集成系统，因为它是一个系统。我们使用 Jenkins 来管理我们的配置管理代码，因为它是代码。这就是为什么我们要用 Puppet
    来构建 Jenkins，然后将我们的 Puppet 代码提交到 Jenkins。
- en: rtyler/jenkins
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: rtyler/jenkins
- en: We should always seek a forge module when building new software, so I'm going
    to reach for `rtyler/jenkins` on the forge. This module will cover our basic needs
    for installing our Jenkins LTS server, installing our Jenkins plugins, and each
    package we'll need to run our builds.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建新软件时，我们应该始终寻找现成的模块，因此我打算从 Forge 中使用 `rtyler/jenkins` 模块。这个模块将覆盖我们安装 Jenkins
    LTS 服务器、安装 Jenkins 插件和每个运行构建所需包的基本需求。
- en: In larger infrastructures, we wouldn't run builds on our Jenkins server, we'd
    run it on the Jenkins agents attached to it. Because this setup has no agents,
    Jenkins will act as our build agent and run the jobs for us. Therefore, we'll
    need to install Git and the PDK so that it can run commands for us. We use the
    Git plugin to provide us with a direct connection to our code, and the pipelines
    plugin gives us a DSL to write our steps in.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在较大的基础设施中，我们不会在 Jenkins 服务器上运行构建，而是在附加的 Jenkins 代理上运行构建。由于此设置没有代理，Jenkins 将充当我们的构建代理并为我们运行作业。因此，我们需要安装
    Git 和 PDK，以便它可以为我们运行命令。我们使用 Git 插件来直接连接到我们的代码，而 Pipelines 插件为我们提供了一种 DSL 来编写我们的步骤。
- en: 'We''re going to build a new module with the PDK by creating a profile directory,
    a manifests directory inside of that, and create a `jenkins.pp` in that folder:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过创建一个配置文件目录、在其中创建一个 manifests 目录，并在该文件夹中创建一个 `jenkins.pp` 来使用 PDK 构建一个新模块：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We're going to install our plugins manually. `rtyler/jenkins` does support plugins
    for Jenkins, but does not support dependencies. There are quite a few dependencies
    in these build pipelines, so we're going to manually install the plugins to highlight
    the two main plugins.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将手动安装插件。`rtyler/jenkins` 确实支持 Jenkins 插件，但不支持插件依赖性。构建流水线中有相当多的依赖关系，因此我们将手动安装插件，以突出显示两个主要插件。
- en: 'After our profile has been applied to the node, we''ve got a fresh Jenkins
    installation with our desired plugins. We can reach our new Jenkins node via the
    web URL on port `8080`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的配置文件应用到节点后，我们就拥有了一个全新的 Jenkins 安装，并且安装了我们所需的插件。我们可以通过 `8080` 端口的网页 URL 访问我们的新
    Jenkins 节点：
- en: '![](img/a5deb6e9-2b6b-4cf0-9016-f13510da225a.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5deb6e9-2b6b-4cf0-9016-f13510da225a.png)'
- en: Managing our plugins
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理我们的插件
- en: If you want to Puppetize each plugin, you can use the `jenkins::plugin` resource
    provided by this Jenkins module. You can find each plugin installed on your Jenkins
    master in the `/var/lib/jenkins/plugins` file, or in the Installed plugins tab
    of your Jenkins instance.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想为每个插件实现 Puppet 化，你可以使用这个 Jenkins 模块提供的`jenkins::plugin`资源。你可以在`/var/lib/jenkins/plugins`文件中，或者在
    Jenkins 实例的已安装插件选项卡中找到每个安装的插件。
- en: 'The resource syntax is as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 资源语法如下：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We''re going to grab two key plugins for our CI/CD workflow in this section:
    Git and Pipeline. We can reach the plugin page by clicking on Manage Jenkins on
    the left-hand side of the screen, and then Manage Plugins near the bottom of the
    menu. There is an ever-growing amount of plugins for Jenkins, and we need to select
    the appropriate ones:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将获取CI/CD工作流的两个关键插件：Git和Pipeline。我们可以通过点击屏幕左侧的“管理Jenkins”，然后在菜单底部点击“管理插件”来进入插件页面。Jenkins的插件数量不断增加，我们需要选择合适的插件：
- en: It can be difficult to locate a plugin by name only, so try using some of the
    descriptions to locate these within the list.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过名称定位插件可能会很困难，因此可以尝试使用一些描述信息在列表中查找这些插件。
- en: '![](img/7a9de370-44f1-435e-8643-81e69e14a585.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a9de370-44f1-435e-8643-81e69e14a585.png)'
- en: 'Once we select these plugins, and click Download and Install after Restart,
    we''ll be taken to a page listing all plugins that have an installation pending,
    in progress, or successful. At the bottom of this page is a checkmark that allows
    us to restart the server when the full download is complete. Make sure that you
    check that box:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们选择了这些插件，并点击“下载并安装（重启后）”，我们将被带到一个页面，列出所有待安装、正在安装或安装成功的插件。在这个页面的底部有一个复选框，允许我们在整个下载完成后重启服务器。确保勾选该复选框：
- en: '![](img/c72b99c8-ced7-41b6-a75f-506786105c12.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c72b99c8-ced7-41b6-a75f-506786105c12.png)'
- en: Creating our first build
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个构建
- en: After our required plugins are installed in Jenkins, we can start putting together
    our first build. We'll start at the bare minimum for a code repository, and then
    demonstrate how to have Jenkins read that repository and automatically run a build
    when new code is checked in.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jenkins中安装了所需的插件后，我们可以开始构建我们的第一个构建。我们将从代码仓库的最低要求开始，然后演示如何让Jenkins读取该仓库并在新的代码被提交时自动运行构建。
- en: This project will need a Git repository available for Jenkins. If you don't
    have an already accessible Git repository, open up an account on GitHub and use
    a public repository. We're not writing anything sensitive, so it's okay that the
    world can see your repository.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目将需要一个可供Jenkins访问的Git仓库。如果你没有现成的Git仓库，可以在GitHub上开设一个账户并使用公共仓库。我们没有写任何敏感信息，所以让世界看到你的仓库是可以的。
- en: Building our profile module
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的个人资料模块
- en: 'We wrote some code that defined our Jenkins server in the form of a profile
    at the beginning of this chapter. First, let''s inspect the directory structure
    that we''re working with for our already existing code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章开始时写了一些代码，通过个人资料的形式定义了我们的Jenkins服务器。首先，让我们检查一下我们当前工作目录的结构，看看我们现有代码所在的目录：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is a pretty bare minimum profiles module, with a single manifest. We''ll
    turn this simple module into a Git repository first:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简化的个人资料模块，只有一个清单。我们将首先把这个简单的模块转换为Git仓库：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we run `git status`, we''ll see that the `manifests` directory is checked
    in. Every file in this repository right now is new, so we''ll need to add each
    file and check them into our first commit, often called the `''initial commit''`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行`git status`，我们会看到`manifests`目录已经被检查。此仓库中的每个文件目前都是新的，因此我们需要将每个文件添加并提交到我们的第一次提交中，这通常被称为`'initial
    commit'`：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We''re then ready to send off our initial commit to the remote repository:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们准备将初始提交发送到远程仓库：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Building our Jenkinsfile
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的Jenkinsfile
- en: 'The Pipeline plugin we installed on our Jenkins node allows us to declare our
    pipeline directly in the same repository as our code, as a script called a Jenkinsfile.
    This Jenkinsfile describes the details of our build steps, which can be automatically
    read by Jenkins to execute our build. We''ll begin with a very simple Jenkinsfile
    that checks to make sure that all of our manifests pass a `puppet parser validate`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Jenkins节点上安装的Pipeline插件允许我们直接在与代码相同的仓库中声明流水线，作为一个名为Jenkinsfile的脚本。这个Jenkinsfile描述了我们的构建步骤的细节，Jenkins可以自动读取它来执行我们的构建。我们将从一个非常简单的Jenkinsfile开始，确保我们的所有清单都通过`puppet
    parser validate`：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This Jenkinsfile describes a pipeline that can be run on any agent (we only
    have one: our Jenkins node). It has stages, but only a single stage named `Test`,
    with a single step that runs `puppet parser validate` on every file ending in
    `.pp` (every manifest).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Jenkinsfile描述了一个可以在任何代理上运行的流水线（我们只有一个代理：我们的Jenkins节点）。它有多个阶段，但只有一个名为`Test`的阶段，并且只有一个步骤，该步骤在每个以`.pp`结尾的文件上运行`puppet
    parser validate`（每个清单）。
- en: Then, we send this file up to our remote repository so that it can be found
    by Jenkins through the normal Git workflow we've been using.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将这个文件发送到远程仓库，以便Jenkins通过我们一直在使用的正常Git工作流程找到它。
- en: Connecting Jenkins to our repository
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Jenkins 连接到我们的仓库
- en: 'Now that we have a build declared in our Jenkinsfile, we can build our first
    job. We''ll start by clicking New Item in the top left corner, and create a new
    Multibranch Pipeline job called profile:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在 Jenkinsfile 中声明了构建任务，可以开始构建我们的第一个作业。我们从点击左上角的“新建项目”开始，并创建一个新的多分支流水线作业，命名为
    profile：
- en: '![](img/abf72a1d-4f04-47f3-8986-9ad471522e7b.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/abf72a1d-4f04-47f3-8986-9ad471522e7b.png)'
- en: 'For our build, we''ll need to edit the Branch Sources by adding the Project
    Repository and set our scan interval to run every minute. This is a public repository
    for me, so I don''t need to attach any credentials. I''ll use the default behaviors
    and property strategy:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的构建，我们需要通过添加项目仓库来编辑分支源，并将扫描间隔设置为每分钟运行一次。这个对我来说是一个公共仓库，所以我不需要附加任何凭证。我将使用默认行为和属性策略：
- en: '![](img/f4913669-a762-4116-9b68-40c370629c14.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4913669-a762-4116-9b68-40c370629c14.png)'
- en: Some hosted Git repositories, such as GitHub Enterprise, allow for the scanning
    of all repositories in an organization. It can save a lot of time managing Jenkins
    if all repositories are automatically discovered.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一些托管的 Git 仓库，例如 GitHub Enterprise，允许扫描组织中的所有仓库。如果所有仓库都能被自动发现，这将节省大量管理 Jenkins
    的时间。
- en: '![](img/03867273-3a61-4d54-b81b-1cd5af16c22c.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03867273-3a61-4d54-b81b-1cd5af16c22c.png)'
- en: 'After I click Scan, an immediate job will be run to discover branches on that
    repository. Although this screen looks just like a Jenkins build, its pass or
    fail status is entirely based on the ability to connect to your Git repository
    and find a Jenkinsfile on a branch. Let''s check on our first build by returning
    to the home page:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我点击扫描后，将立即运行一个任务来发现该仓库中的分支。尽管这个界面看起来就像是 Jenkins 构建，它的通过或失败状态完全取决于是否能够连接到 Git
    仓库并在分支上找到 Jenkinsfile。让我们返回主页查看我们的第一次构建：
- en: '![](img/8dbdd6f1-81eb-4068-8aa7-e6e1c7ebd1e7.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8dbdd6f1-81eb-4068-8aa7-e6e1c7ebd1e7.png)'
- en: Our splash page has our first build in it! The sun represents a passing build,
    indicating that each step in our build returned a positive exit status. On the
    far right of the build is a run build button, which is for if we'd like to run
    the build again. For now, click on the name profile and enter the details of the
    build. Because this is a multibranch pipeline, we'll also want to click the master
    branch to bring us into our status. You'll see that our build has run, and you
    can inspect each step of the way from this menu.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的启动页面展示了我们的第一次构建！太阳图标代表一次成功的构建，表示构建中的每一步都返回了正向的退出状态。在构建的最右侧是一个运行构建按钮，点击它可以再次运行构建。现在，点击名称档案并进入构建的详细信息。因为这是一个多分支流水线，我们还需要点击主分支以查看我们的状态。你会看到我们的构建已经运行，并且你可以从这个菜单检查每一步的详细情况。
- en: To ensure that this exercise does not require us to put our Jenkins somewhere
    publicly accessible, we'll be using repository polling. While this will work for
    most, the most effective strategy is really using a Git hook to trigger Jenkins
    to run after every build.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保这个操作不需要将我们的 Jenkins 放到一个公开可访问的地方，我们将使用仓库轮询。虽然这对于大多数情况有效，但最有效的策略是使用 Git 钩子，在每次构建后触发
    Jenkins 运行。
- en: 'At this part of the phase, we have a set of commands that can be run on demand.
    To really make Continuous Integration work, we''ll need to have our code test
    itself. Within our job, we can select View Configuration to come to the configuration
    page. We''ll be setting our Build Triggers to poll the SCM every minute:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们有一组可以按需执行的命令。为了让持续集成真正发挥作用，我们需要让我们的代码自行测试。在我们的作业中，我们可以选择查看配置来进入配置页面。我们将设置我们的构建触发器，以每分钟轮询
    SCM：
- en: '![](img/0a897ff3-9201-40ea-ba25-caea875f6903.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a897ff3-9201-40ea-ba25-caea875f6903.png)'
- en: 'Once we''ve saved this configuration, Jenkins will automatically check our
    remote repository for changes every minute. We now have the simplest form of Continuous
    Integration: code that tests itself on every commit. With such a small amount
    of code coverage, our Continuous Integration pipeline doesn''t provide us with
    much value, other than alerting us when we''ve created a malformed manifest.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们保存了这个配置，Jenkins 将自动每分钟检查一次我们的远程仓库是否有变化。现在我们拥有了最简单形式的持续集成：每次提交时，代码都会进行自我测试。由于代码覆盖范围很小，我们的持续集成流水线并未为我们提供太多价值，除了在我们创建了格式错误的清单时提醒我们。
- en: Integrating the PDK
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成 PDK
- en: The Puppet PDK provides us with a framework for repeatable Continuous Integration.
    We'll be taking our bare bones module and converting it with PDK, and then we
    will begin by using PDK validate to replace our basic `puppet parser validate`
    command. Because the PDK is available on our Jenkins master, all PDK commands
    will also be available for use.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet PDK 为我们提供了一个可重复的持续集成框架。我们将把我们的基础模块转换为 PDK 模块，然后我们将开始使用 PDK validate 来替代我们基本的
    `puppet parser validate` 命令。因为 PDK 已经在我们的 Jenkins 主节点上可用，所以所有 PDK 命令也可以使用。
- en: 'Our first step will be to change branches so that we don''t impact the master
    as we''re adding new code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是切换分支，以便在添加新代码时不会影响主分支：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, let''s convert our existing module with the PDK convert command. We''ll
    be prompted with a series of questions, mostly aimed at publishing modules to
    the forge. The final question asks which operating system this is relevant to
    and actually does help form our test bindings, so we''ll minimize this to just
    the targeted operating system: Red Hat-based Linux. Simply run `pdk convert` and
    follow the prompts.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用 PDK convert 命令转换我们现有的模块。我们会被提示一系列问题，这些问题主要用于将模块发布到 Forge。最后一个问题询问该模块适用于哪个操作系统，实际上有助于形成我们的测试绑定，因此我们将其最小化为仅针对目标操作系统：基于
    Red Hat 的 Linux。只需运行 `pdk convert` 并按照提示进行操作。
- en: 'The default PDK template contains three files not relevant to us: `.gitlab-ci.yml`,
    `.travis.yml`, and `appveyor.yml`, which are used for other CI systems. We''ll
    then add our new files and commit them into a new code commit:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 PDK 模板包含三个与我们无关的文件：`.gitlab-ci.yml`、`.travis.yml` 和 `appveyor.yml`，这些文件用于其他
    CI 系统。接下来，我们将添加我们的新文件并将其提交到新的代码提交中：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we''ll change our Jenkinsfile `Test` stage to use the `pdk validate`
    utility:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将修改我们的 Jenkinsfile 中的 `Test` 阶段，使用 `pdk validate` 工具：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We''ll push that back up to our remote repository with our Git workflow, and
    our Jenkins instance will automatically pick up our job on our new PDK branch
    after sending it remotely with `git push origin pdk`. Back on our profile page,
    we will now see a new branch:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过 Git 工作流将其推送回我们的远程仓库，Jenkins 实例将在通过 `git push origin pdk` 远程发送后自动接收我们在新
    PDK 分支上的作业。在我们的配置文件页面上，我们现在会看到一个新的分支：
- en: '![](img/df3b12e7-d078-4a10-80d0-9c31074e90ef.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df3b12e7-d078-4a10-80d0-9c31074e90ef.png)'
- en: 'The inside of this PDK branch should appear similar to our previous branch,
    but we want to inspect the logs of our test. Inside, we''ll see that a few `puppet-lint`
    warnings were triggered, but did not fail the build. Puppet lint warnings by default
    provide an exit status of `0`, allowing your build to still pass:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 PDK 分支的内部应该与我们之前的分支类似，但我们想查看我们测试的日志。在日志中，我们会看到一些 `puppet-lint` 警告被触发，但并未导致构建失败。默认情况下，Puppet
    lint 警告的退出状态为 `0`，这允许构建仍然通过：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I like the Warnings plugin for viewing lint syntax. It shows trends over time,
    but is by no means necessary for proper Continuous Integration.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢使用 Warnings 插件来查看 lint 语法。它展示了随时间变化的趋势，但对于适当的持续集成来说，它并不是必需的。
- en: 'Before we do a pull request of this code into master, let''s clean up our lint
    warnings by adding a comment to the top of our manifest, and aligning the arrows
    within the PDK package:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将这段代码通过拉取请求合并到 master 之前，先通过在清单的顶部添加注释并对齐 PDK 包中的箭头来清理我们的 lint 警告：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can then add these changes and push them back up to our remote repository.
    Our Jenkins scan will then pick up these changes within a minute and give us the
    all clear. Once we're happy with these results, you can merge your code with a
    pull request back at the remote repository, and watch this test run again on our
    master branch.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以添加这些更改并将其推送回远程仓库。我们的 Jenkins 扫描将在一分钟内捕获这些更改并给出清晰信号。一旦我们对这些结果感到满意，就可以通过远程仓库上的拉取请求将代码合并回主分支，并再次观察该测试在主分支上的运行。
- en: Now that we have some basic validation in place, we can start building some
    basic test coverage to rely on our profiles not losing features over time, or
    regressing.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一些基本的验证，可以开始构建一些基本的测试覆盖率，以确保我们的配置文件不会随着时间的推移而失去功能，或者发生回归。
- en: Unit testing with Puppet RSpec
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Puppet RSpec 进行单元测试
- en: 'Unit testing is testing focused around the smallest unit of code. In the case
    of Puppet, the smallest functional unit of code is the manifest. RSpec provides
    us with a unit testing framework for Puppet code, which is fast and effective
    at checking that our Puppet code is producing the Puppet catalogs we expect. Whatever
    tests we write in RSpec, we''re essentially asking: *would what I want be in the
    Puppet catalog when I execute this code?*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是围绕最小的代码单元进行的测试。在 Puppet 中，最小的功能单元是清单。RSpec 为我们提供了一个用于 Puppet 代码的单元测试框架，它能够快速有效地检查我们的
    Puppet 代码是否生成了我们预期的 Puppet 清单。不论我们在 RSpec 中编写什么测试，实际上我们是在问：*当我执行这段代码时，所需的内容是否会出现在
    Puppet 清单中？*
- en: RSpec as a system is run on the command line, and does not involve a new virtual
    machine or container. It is now included in the Puppet PDK under the command `pdk
    test unit`. We're going to look at the files involved in running unit tests, and
    writing simple unit tests from the templates provided by the PDK.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: RSpec 作为一个系统是在命令行上运行的，并不涉及新的虚拟机或容器。它现在已经包含在 Puppet PDK 中，通过命令 `pdk test unit`
    运行。我们将查看运行单元测试和使用 PDK 提供的模板编写简单单元测试所涉及的文件。
- en: 'We''re beginning a new feature set, so we''ll want to start from master, pull
    down the remote commits, and start on a new branch:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在开始一个新的功能集，因此我们需要从主分支开始，拉取远程提交，并开始一个新分支：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Before we begin with RSpec, we''ll want a sample set of files we can work with.
    At the time of writing this book, there is no command in the PDK to create a unit
    test without creating a new manifest. To overcome this limitation, we''ll simply
    rename our `jenkins.pp` file, create a new class with the PDK, and place our existing
    file back in place over it:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用 RSpec 之前，我们需要一组可以操作的示例文件。在撰写本书时，PDK 中没有命令可以创建单元测试而不创建新的清单。为了克服这个限制，我们只需重命名我们的`jenkins.pp`文件，使用
    PDK 创建一个新类，然后将现有文件重新放回原位覆盖它：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We'll now have our `jenkins_spec.rb` built from template, and will be ready
    to begin writing unit tests in RSpec.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的 `jenkins_spec.rb` 文件已经根据模板构建完成，准备开始编写 RSpec 单元测试。
- en: Relevant RSpec files
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关的 RSpec 文件
- en: 'With our files in place, let''s inspect the most relevant files we''ll work
    with during the testing of classes:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 文件就位后，让我们检查一下在测试类时，我们将使用的最相关的文件：
- en: '`.fixtures.yml`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.fixtures.yml`'
- en: '`spec/classes/jenkins_spec.rb`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec/classes/jenkins_spec.rb`'
- en: '`spec/spec_helper.rb` provides configuration and variables to every test in
    your suite. We won''t be editing it in this example, but know that this is essentially
    your global configuration file for all of the modules tests.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`spec/spec_helper.rb` 为测试套件中的每个测试提供配置和变量。我们在本例中不会编辑它，但请注意，这基本上是所有模块测试的全局配置文件。'
- en: .fixtures.yml
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .fixtures.yml
- en: 'Our `fixtures` file lets our tests know what dependencies are required for
    our manifests. It is placed at the base of the repository, as `profile/.fixtures.yml`.
    For our particular profile, we''ll build a fixtures file that contains `rtyler/jenkins`
    and all of its dependencies in order to support our test:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `fixtures` 文件让我们的测试知道清单所需的依赖项。它位于仓库的根目录，命名为 `profile/.fixtures.yml`。对于我们特定的配置文件，我们将构建一个包含
    `rtyler/jenkins` 及其所有依赖项的配置文件，以支持我们的测试：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We use this file to declare a module in our test, and use a pointer to a repository
    to find it. In the preceding case, we're grabbing the latest version of each module
    except Jenkins, which we've pinned at 1.7.0 as we're using in our Puppetfile.
    Depending on your strategy for code, you may or may not want to tag a specific
    reference to a version, like I did previously.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个文件在测试中声明一个模块，并通过指向仓库的引用来找到它。在前面的例子中，我们获取了每个模块的最新版本，除了 Jenkins，我们将其固定在
    1.7.0，因为我们在 Puppetfile 中使用了这个版本。根据你的代码策略，你可能会选择或不选择指定特定版本的引用，就像我之前所做的那样。
- en: Documentation on fixtures can be found in the `spec_helper.rb` GitHub repository
    at [https://github.com/puppetlabs/puppetlabs_spec_helper#fixtures-examples](https://github.com/puppetlabs/puppetlabs_spec_helper#fixtures-examples).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 关于配置文件的文档可以在 `spec_helper.rb` GitHub 仓库中找到，地址是 [https://github.com/puppetlabs/puppetlabs_spec_helper#fixtures-examples](https://github.com/puppetlabs/puppetlabs_spec_helper#fixtures-examples)。
- en: jenkins_spec.rb
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jenkins_spec.rb
- en: 'After our fixtures are in place, let''s inspect our `jenkins_spec.rb`, as provided
    by the PDK:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的配置文件就位之后，让我们检查一下 PDK 提供的 `jenkins_spec.rb` 文件：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding simple test just ensures that the catalog compiles for each and
    every operating system listed in `metadata.json`. Normally, we'd run this test
    and we'd receive a passing status. In this particular case, `rtyler/jenkins` requires
    us to supply an additional fact of `systemd` that is not available in the base
    `on_supported_os` function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的简单测试只是确保目录在`metadata.json`中列出的每个操作系统上都能编译。通常，我们会运行这个测试，并收到一个通过的状态。在这个特定的情况下，`rtyler/jenkins`要求我们提供一个额外的`systemd`事实，而这个事实在基础的`on_supported_os`函数中不可用。
- en: Check popular modules on the forge for samples of code, especially in cases
    where you're testing profiles against existing modules. Often, the upstream module
    has a fix, like the one we're about to implement.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在forge上检查流行模块的代码示例，尤其是在你将配置文件与现有模块进行测试时。通常，上游模块已经有了修复，就像我们即将实现的修复一样。
- en: 'We''ll edit our existing `spec` class to introduce a new fact to our system
    to support `systemd`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编辑现有的`spec`类，向我们的系统引入一个新事实，以支持`systemd`：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, our test will be able to compile, as the upstream Jenkins module will
    have the `systemd` fact it needs to compile. Let''s go ahead and compile our tests:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的测试将能够编译，因为上游的Jenkins模块将拥有它需要的`systemd`事实。我们来编译一下我们的测试：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You may have noticed that we have four passing tests. Although we wrote just
    one test, our `on_supported_os` function looked in our `metadata.json` file and
    provided a test for each listed operating system, all within the Red Hat family.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们有四个通过的测试。尽管我们只写了一个测试，但我们的`on_supported_os`函数查看了我们的`metadata.json`文件，并为每个列出的操作系统提供了一个测试，所有这些操作系统都属于红帽（Red
    Hat）家族。
- en: Extending our Jenkinsfile
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展我们的Jenkinsfile
- en: 'We''re going to change up our Jenkinsfile to support our new RSpec test. We''re
    going to remove our original `Test` stage and be more clear by creating the `Validate`
    and `Unit Test` stages. We''ll simply incorporate the two as `pdk validate` and
    `pdk test unit`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更改我们的Jenkinsfile，以支持我们新的RSpec测试。我们将删除原来的`测试`阶段，并通过创建`验证`和`单元测试`阶段来更加清晰。我们将这两个阶段简单地整合为`pdk
    validate`和`pdk test unit`：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will change our pipeline to three distinct phases: checkout `SCM`, `Validate`,
    and `Unit Test`. We''ll be able to see where our build passes or fails along each
    step in Jenkins.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把我们的流水线分为三个独立的阶段：`SCM`检出、`验证`和`单元测试`。我们将能够看到在Jenkins中每个步骤的构建是通过还是失败。
- en: 'Now that we have a basic framework for our test laid out, let''s get our code
    back to the remote repository:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为测试奠定了基本框架，让我们将代码推送回远程仓库：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Back in our Jenkins instance, we can see the new RSpec branch and the new logs
    for our test. Notice each section, and that we're also seeing our Jenkins instance
    pass our four RSpec tests.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的Jenkins实例，我们可以看到新的RSpec分支和我们测试的日志。请注意每个部分，此外，我们还可以看到我们的Jenkins实例通过了我们的四个RSpec测试。
- en: Extending our test
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展我们的测试
- en: Now that we can write a test, we'll write one simple test that simply mirrors
    our manifest. This test will help us prevent regression, as changing an existing
    value or removing an existing resource will cause the test to fail. If this change
    is intended, the test must also be changed. Although this intuitively feels like
    it would slow down development, it saves even more time in integration when you
    can ensure that no new errors have been introduced.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经能够编写测试了，我们将编写一个简单的测试，这个测试只是简单地镜像我们的清单。这个测试将帮助我们防止回归，因为更改现有的值或删除现有资源会导致测试失败。如果这是一个预期的更改，测试也必须进行相应的修改。虽然直观上感觉这会拖慢开发速度，但在集成时它能节省更多的时间，因为你可以确保没有引入新的错误。
- en: 'Here is our RSpec test containing the mirror of our original profile:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的RSpec测试，包含我们原始配置文件的镜像：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When we create a commit with this new test, and send it back up to Jenkins,
    we'll see our build actually perform this test. Up to this point, we've never
    intentionally broken a test. Let's go ahead and prove our test now. Comment out
    one resource in your original manifest, or change some configuration before sending
    this repository back to the remote server. After pushing this, you should be able
    to see a failed test in Jenkins! Simply uncomment out your resources and push
    a new commit up to your remote, and you'll see Jenkins pass this build. Once your
    build is passing, go ahead and merge into master so that we can continue onto
    our next section of integration testing.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个包含此新测试的提交，并将其推送到 Jenkins 时，我们将看到构建实际上会执行这个测试。到目前为止，我们从未故意让测试失败。现在我们来证明我们的测试。注释掉原始清单中的一个资源，或者在将该仓库提交到远程服务器之前更改某些配置。推送后，你应该能在
    Jenkins 中看到一个失败的测试！只需取消注释你的资源，并向远程仓库推送一个新的提交，你将看到 Jenkins 通过这个构建。一旦构建通过，继续合并到主分支，以便我们可以继续进行下一部分的集成测试。
- en: There is great documentation on writing RSpec tests out there at [http://rspec-puppet.com/](http://rspec-puppet.com/).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 关于编写 RSpec 测试的文档可以参考 [http://rspec-puppet.com/](http://rspec-puppet.com/)。
- en: Acceptance testing with Test Kitchen
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Test Kitchen 进行验收测试
- en: An acceptance test is a test that is performed to validate that requirements
    are met. While RSpec is a fast way to check that a catalog is compiled the way
    you expect it to be, it does not actually run the catalog on the system and verify
    that the expected results can be seen. An acceptance test, in the context of Puppet,
    is applying your selected manifest to a system and verifying that the system meets
    the requirements after the catalog is applied, preferably with a method that isn't
    the Puppet Agent itself.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 验收测试是为了验证是否满足需求而执行的测试。虽然 RSpec 是一种快速检查目录是否按预期编译的方式，但它并不实际在系统上运行目录，也无法验证是否能够看到预期的结果。在
    Puppet 中，验收测试是将你选择的清单应用到系统上，并验证在目录应用后系统是否满足要求，最好使用一种不是 Puppet Agent 本身的方法。
- en: In this chapter, we're going to build an acceptance test for our Jenkins Profile
    that ensures that Jenkins is running and that we can reach it on port `8080` so
    that we can view the web page. This extends beyond the ability of RSpec, as Rspec
    doesn't actually build a node we can verify on. When we use an acceptance testing
    harness in Puppet, we also tie it to a hypervisor so that it can manage a node,
    or **System Under Test** (**SUT**).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为我们的 Jenkins 配置文件构建一个验收测试，确保 Jenkins 正在运行，并且我们可以通过端口`8080`访问它，以便查看网页。这超出了
    RSpec 的能力，因为 RSpec 实际上并没有构建一个我们可以验证的节点。当我们在 Puppet 中使用验收测试工具时，我们还将它与一个虚拟机管理器（hypervisor）绑定，以便它能够管理一个节点，或称为**被测试系统**（**SUT**）。
- en: Beaker
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Beaker
- en: Puppet provides a perfectly adequate acceptance testing harness in Beaker. Beaker
    is designed to connect to a hypervisor and spin up nodes as defined in configuration
    files and apply the Puppet tests. It uses a simple language called Serverspec
    to define tests. It also has the benefit of checking for idempotence by running
    a second time. Puppet themselves have also connected it to another application
    called VMPooler, which preemptively spins up a pool of virtual machines to act
    as SUTs and replaces themselves when the test is done, providing rapid response
    time to acceptance tests. If you, as an organization, are far along in your CI/CD
    process, and require virtual machines, I highly recommend Beaker. For this section,
    we'll do our acceptance testing in Test Kitchen, simply because I believe it's
    easier to work with and provides more options for workstation development.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 提供了一个完全足够的验收测试工具——Beaker。Beaker 旨在连接到虚拟机管理器并根据配置文件中的定义启动节点，应用 Puppet
    测试。它使用一种简单的语言叫做 Serverspec 来定义测试。它还有一个优点是通过再次运行测试来检查幂等性。Puppet 本身也将它与另一个名为 VMPooler
    的应用程序连接，VMPooler 会预先启动一池虚拟机作为 SUT，并在测试完成后替换它们，从而为验收测试提供快速响应时间。如果你所在的组织已经在 CI/CD
    流程中走得很远，并且需要虚拟机，我强烈推荐 Beaker。在本节中，我们将在 Test Kitchen 中进行验收测试，仅仅因为我认为它更容易使用，并且提供更多的工作站开发选项。
- en: Test Kitchen and kitchen-puppet
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Test Kitchen 和 kitchen-puppet
- en: Test Kitchen is actually the testing framework built by Chef. It is very simple
    to use and get started with, and uses a language even easier to work with than
    Serverspec called Inspec. We'll be extending Test Kitchen to support Puppet using `rubygem
    kitchen-puppet`, found at [https://github.com/neillturner/kitchen-puppet](https://github.com/neillturner/kitchen-puppet).
    We'll need to prepare our Jenkins node to start taking advantage of Test Kitchen
    and running another set of validation tests.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 测试厨房实际上是 Chef 构建的测试框架。它非常简单易用，而且使用一种比 Serverspec 更容易操作的语言，叫做 Inspec。我们将扩展测试厨房，使用
    `rubygem kitchen-puppet` 来支持 Puppet，该项目可以在 [https://github.com/neillturner/kitchen-puppet](https://github.com/neillturner/kitchen-puppet)
    找到。我们需要准备我们的 Jenkins 节点，以便开始利用测试厨房并运行另一组验证测试。
- en: Preparing Test Kitchen on our Jenkins node
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的 Jenkins 节点上准备测试厨房
- en: Test Kitchen directly supports the development activities of our Puppet code.
    We'll be using a single composite command from Test Kitchen in our CI/CD run: `kitchen
    test`. Kitchen test is an orchestration of the destroy, create, converge, setup,
    verify, and commands, taking us through cleaning up, building, applying code,
    and testing each run. You can run Test Kitchen locally, as well as on our CI/CD
    system, which is one of the greatest strengths of using kitchen-puppet. We'll
    be adding a lot of code in this section, from updating our Jenkins Profile to
    supporting Test Kitchen, to building the test and Test Kitchen configuration.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 测试厨房直接支持我们 Puppet 代码的开发活动。在我们的 CI/CD 运行中，我们将使用来自测试厨房的一个复合命令：`kitchen test`。Kitchen
    test 是 destroy、create、converge、setup、verify 等命令的编排，带领我们完成清理、构建、应用代码以及测试每一次运行。你可以在本地运行测试厨房，也可以在我们的
    CI/CD 系统上运行，这是使用 kitchen-puppet 的最大优势之一。在本节中，我们将添加大量代码，从更新我们的 Jenkins 配置文件到支持测试厨房，再到构建测试和测试厨房配置。
- en: Jenkins Profile
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jenkins 配置文件
- en: 'We''ll change up our profile first. In the following example, we''ll add the
    following resources and features:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将修改我们的配置文件。在以下示例中，我们将添加以下资源和功能：
- en: Install Docker, if the node is not already a Docker Container
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果节点尚未是 Docker 容器，则安装 Docker
- en: Install RVM, Ruby 2.4.1 and all RubyGems needed for Kitchen
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 RVM、Ruby 2.4.1 及所有测试厨房所需的 RubyGems
- en: 'We have added the preceding resources and features in the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在以下代码中添加了前述资源和功能：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We'll need to deploy this new profile to our Jenkins node before we continue
    through the rest of the section. Make sure you deploy this to your Puppet Master
    before continuing on editing the build. Working with your CI/CD system can sometimes
    feel like a series of chicken before the egg scenarios. This is normal, but the
    concepts extend beyond our CI/CD system.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续执行本节的其余部分之前，我们需要将这个新配置文件部署到我们的 Jenkins 节点。确保在继续编辑构建之前，将其部署到你的 Puppet Master
    上。与 CI/CD 系统的工作有时会让人感觉像是一系列“先有鸡还是先有蛋”的情境。这是正常现象，但这些概念不仅仅局限于我们的 CI/CD 系统。
- en: .kitchen.yml
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .kitchen.yml
- en: 'The first file we''ll work with is our `.kitchen.yml`. This file determines
    how Test Kitchen performs the build. This YAML file provides us with the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将处理的第一个文件是 `.kitchen.yml`。这个文件决定了测试厨房如何执行构建。这个 YAML 文件为我们提供了以下内容：
- en: '**Driver**: This is used for running the build in Docker as a privileged user
    starting with the init process. If you''re unfamiliar with working with containers,
    we''re setting it up this way to act more like a traditional VM, and less like
    a wrapper around an application.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Driver**：用于以特权用户身份在 Docker 中运行构建，启动时从 init 进程开始。如果你不熟悉容器的工作方式，我们这样设置是为了让它更像传统的虚拟机，而不是仅仅作为一个应用程序的包装器。'
- en: '**Provisioner**: We''re setting up Test Kitchen to use the Puppet provisioner
    with a local manifests and modules path in our build.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Provisioner**：我们正在设置测试厨房，使用 Puppet 配置器并指定本地清单和模块路径来构建。'
- en: '**Verifier**: Use Inspec for testing.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Verifier**：使用 Inspec 进行测试。'
- en: '**Platforms**: We are going to configure our container to use the CentOS SystemD
    container. We''re passing additional commands to ensure that SSH works properly,
    and that init scripts are available for our Jenkins run.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Platforms**：我们将配置我们的容器以使用 CentOS SystemD 容器。我们传递额外的命令以确保 SSH 正常工作，并且初始化脚本可供
    Jenkins 运行使用。'
- en: '**Suites**: This is used for describing each test suite we run. This first
    one is defined with `jenkins.pp` in our test directory, which is a simple `include
    profile::jenkins`, like we may see in an `example.pp`. Notice our pre-verify stage
    in this one, giving our Jenkins instance 30 seconds to finish coming up before
    we test:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**套件**：这个术语用于描述我们运行的每一个测试套件。第一个套件是通过我们测试目录中的 `jenkins.pp` 定义的，这是一个简单的 `include
    profile::jenkins`，就像我们在 `example.pp` 中可能看到的那样。请注意这个套件中的预验证阶段，它给我们的 Jenkins 实例
    30 秒的时间来完成启动，然后再进行测试：'
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`.kitchen.yml` will work for us locally as well, allowing us to run tests and
    verify them before sending our code up to our remote repository. We can also use `kitchen
    converge` to build the machine and apply the code if we want to inspect the end-state
    on our local system.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`.kitchen.yml` 也适用于本地环境，让我们可以在将代码推送到远程代码库之前运行测试并验证它们。如果我们想检查本地系统上的最终状态，我们也可以使用
    `kitchen converge` 来构建机器并应用代码。'
- en: Puppetfile
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Puppetfile
- en: 'The kitchen-puppet gem runs via Puppetfile. Underneath the covers, it''s using
    a tool called librarian-puppet to pull down all modules and dependencies found
    in the Puppetfile. Librarian and r10k came around the same time, with r10k providing
    no automatic dependency resolution, preferring explicit naming. Due to our use
    of Puppet Librarian, we''re explicitly adding an exclusion for Java and Apt, which
    our 2-year old Puppet module locks to old versions. Our Jenkins module works just
    fine with modern versions of Java and Apt, but this automatic dependency resolution
    has to be muted so that we do not fail:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: kitchen-puppet gem 通过 Puppetfile 运行。在后台，它使用一个叫做 librarian-puppet 的工具来拉取 Puppetfile
    中的所有模块和依赖项。Librarian 和 r10k 是同时出现的，r10k 不提供自动依赖解析，更倾向于显式命名。由于我们使用了 Puppet Librarian，我们明确添加了对
    Java 和 Apt 的排除，因为我们两年前的 Puppet 模块锁定了旧版本。我们的 Jenkins 模块在现代 Java 和 Apt 版本下运行得很好，但必须禁止自动依赖解析，以避免构建失败：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Jenkinsfile
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jenkinsfile
- en: 'I''m adding two new objects to our Jenkinsfile: an integration test provided
    by a shell script, and a post action that tells Jenkins to clean up our workspace.
    We''re using an external script instead of running inline for ease of management,
    as each `sh` step is an independent shell in Jenkins. Our post cleanup action
    just makes sure that we don''t retain any artifacts from a previous build:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我在我们的 Jenkinsfile 中添加了两个新对象：一个由 shell 脚本提供的集成测试，以及一个后置操作，告诉 Jenkins 清理我们的工作空间。我们使用外部脚本而不是内联执行，是为了更容易进行管理，因为每个
    `sh` 步骤都是 Jenkins 中的独立 shell。我们的后置清理操作确保我们不会保留来自上次构建的任何遗留物：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: acceptance.sh
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: acceptance.sh
- en: 'Our acceptance shell script is relatively small, but allows Jenkins to have
    a path for this build and sources in RVM prior to running Kitchen Test. We want
    to make sure that the build stays consistent, so we want to control the environment
    around the build as well:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的接受脚本相对较小，但允许 Jenkins 在运行 Kitchen 测试之前，在 RVM 中为这个构建和源代码提供路径。我们希望确保构建保持一致，因此也希望控制构建周围的环境：
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Test
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: 'Our actual test itself is one of the simplest files in our new iteration. We''re
    placing it in the default folder, so it''s found by the default suite we mentioned
    previously. We''re building a single control or set of tests, with three tests:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实际测试本身是我们新迭代中最简单的文件之一。我们将其放置在默认文件夹中，这样它就能被我们之前提到的默认套件找到。我们正在构建一个单一的控制或测试集，共包含三个测试：
- en: Ensure that the Jenkins package is installed
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保 Jenkins 包已安装
- en: Ensure that the Jenkins service is running
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保 Jenkins 服务正在运行
- en: 'Ensure that Jenkins can be reached on the localhost at `8080`, and returns
    a 200 exit status:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保 Jenkins 可以在本地主机的 `8080` 端口访问，并返回 200 的退出状态：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Performing the test
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行测试
- en: Now that we have all of the pieces in place, let's go ahead and deploy our code
    to our repository, and let Jenkins run the job. If you haven't already run our
    new Jenkins Profile, you'll need to make sure it's deployed to your master and
    that your Jenkins node has already converged on it. Once we push our test to the
    CI/CD system, it will read our code and begin the test. Of particular note, this
    test will take significantly longer than the tests we've written previously, as
    the container will need to be downloaded, built, spun up, converged, and tested,
    compared to our PDK commands that simply checked syntax or compiled a quick catalog.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经把所有组件准备好，接下来让我们把代码部署到我们的代码库，并让 Jenkins 运行任务。如果你还没有运行新的 Jenkins 配置文件，你需要确保它已经部署到主机，并且
    Jenkins 节点已经同步完毕。一旦我们将测试推送到 CI/CD 系统，它将读取我们的代码并开始测试。特别需要注意的是，这个测试将比我们之前编写的测试花费显著更长的时间，因为容器需要被下载、构建、启动、同步和测试，而不像我们的
    PDK 命令仅仅检查语法或编译快速目录。
- en: 'We''ve built a lot of files during this chapter, so let''s take a quick look
    at just the files we''ve managed, ignoring anything automatically built by software:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们创建了许多文件，接下来快速回顾一下我们管理过的文件，忽略软件自动生成的文件：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Summary
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we focused on building out a CI System (Jenkins) and performing
    a validation check, a unit test, and an acceptance test. CI/CD is a continual
    journey, and there is always room for improvement in our workflows. Continuous
    Integration provides us with a valuable safety net for development, allowing us
    to develop without worrying about feature loss or regression.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们专注于构建 CI 系统（Jenkins）并执行验证检查、单元测试和验收测试。CI/CD 是一个持续的过程，我们的工作流总是有改进的空间。持续集成为我们提供了一个宝贵的安全网，让我们在开发过程中无需担心功能丢失或回归问题。
- en: Where are some places to go to from here? Integrate your Git system closer to
    Jenkins by using Git hooks to deploy code, and providing a status back before
    a pull request is added. You can also add notifications to developers, alerting
    them when their tests have gone from passing to failing. If you find some of these
    warnings to be too much, tune the system providing the warning to avoid some of
    these errors. Everyone has a different CI/CD journey, so explore for yourself
    and figure out what works for you!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，有哪些地方可以去呢？通过使用 Git 钩子将 Git 系统与 Jenkins 更紧密地集成，部署代码并在拉取请求添加之前提供状态反馈。你还可以向开发者发送通知，提醒他们测试结果从通过变为失败。如果你觉得这些警告有些过多，可以调整提供警告的系统，以避免某些错误的出现。每个人的
    CI/CD 之路都是不同的，所以自己去探索，找出适合你的方法！
- en: The next chapter covers Puppet Tasks and Puppet Discovery. Puppet Tasks allows
    us to run ad-hoc commands and use them as building blocks for imperative scripts.
    We'll be building a task to inspect log files and planning to build an aggregated
    log file for our Puppet Master. Puppet Discovery allows us to inspect our existing
    infrastructure and determine ground truth on packages, services, users, and various
    other components of a virtual machine or container.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍 Puppet 任务和 Puppet 探索。Puppet 任务让我们可以运行临时命令，并将其作为命令式脚本的构建块。我们将构建一个任务来检查日志文件，并计划为我们的
    Puppet 主机构建一个汇总的日志文件。Puppet 探索让我们能够检查现有的基础设施，并确定虚拟机或容器中的软件包、服务、用户以及其他各种组件的真实情况。
