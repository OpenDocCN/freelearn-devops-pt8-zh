- en: Chapter 9. Managing files with templates
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章. 使用模板管理文件
- en: '|   | *Simplicity does not precede complexity, but follows it.* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *简洁并非复杂之前的状态，而是复杂之后的产物。* |   |'
- en: '|   | --*Alan Perlis* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*艾伦·珀里斯* |'
- en: 'In this chapter, we''ll learn about an important and powerful feature of Puppet:
    the **template**. We''ll see how to use a simple template to interpolate the values
    of Puppet variables, facts, and Hiera data into a file, and we''ll also introduce
    more complex templates using iteration and conditional statements to generate
    dynamic configuration files.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解 Puppet 的一个重要且强大的功能：**模板**。我们将学习如何使用一个简单的模板将 Puppet 变量、事实和 Hiera 数据的值插入到文件中，还将介绍使用迭代和条件语句的更复杂模板来生成动态配置文件。
- en: '![Managing files with templates](img/8880_09_01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![使用模板管理文件](img/8880_09_01.jpg)'
- en: What are templates?
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是模板？
- en: 'In previous chapters, we''ve used Puppet to manage the **contents of files**
    on the node by various means, including setting the contents to a literal string
    using the `content` attribute, and copying a file from a Puppet module using the
    `source` attribute. While these methods are very useful, they are limited in one
    respect: they can only use **static text**, rather than building the contents
    of the file dynamically, based on Puppet data.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们通过多种方式使用 Puppet 管理节点上的 **文件内容**，包括使用 `content` 属性将内容设置为字面字符串，以及使用
    `source` 属性从 Puppet 模块复制文件。虽然这些方法非常有用，但它们在一个方面是有限制的：它们只能使用 **静态文本**，而不能基于 Puppet
    数据动态生成文件内容。
- en: The dynamic data problem
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态数据问题
- en: 'To see why this is a problem, consider a common Puppet file management task
    such as a backup script. There are a number of site- and node-specific things
    the backup script needs to know: the local directories to back up, the destination
    to copy them to, and any credentials needed to access the backup storage. While
    we could insert these into the script as literal values, this is rather inflexible.
    We might have to maintain several versions of the script, each identical to the
    others except for a backup location, for example. This is clearly less than satisfactory.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解为什么这是一个问题，考虑一个常见的 Puppet 文件管理任务，如备份脚本。备份脚本需要知道一些特定于站点和节点的内容：本地备份的目录、将其复制到的目标位置，以及访问备份存储所需的任何凭据。虽然我们可以将这些内容作为字面值插入脚本中，但这并不灵活。我们可能不得不维护多个版本的脚本，每个版本与其他版本相同，除了备份位置不同。这显然是不令人满意的。
- en: 'Consider a configuration file for an application where some of the settings
    depend on specific information about the node: the available memory, perhaps.
    Obviously, we don''t want to have to maintain multiple versions of an almost identical
    config file, each containing a suitable value for all the different sizes of memory
    we may come across. We have a way of obtaining that information directly in Puppet,
    as we''ve seen in [Chapter 5](ch05.html "Chapter 5. Variables, expressions, and
    facts"), *Variables, expressions, and facts*, and we also have a flexible, powerful
    database for configuration data, as we saw in [Chapter 6](ch06.html "Chapter 6. Managing
    data with Hiera"), *Managing data with Hiera*. The question is how we can insert
    this data dynamically into text files.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个应用程序的配置文件，其中一些设置依赖于关于节点的特定信息：例如可用的内存。显然，我们不希望维护多个几乎相同的配置文件版本，每个版本都包含适合我们可能遇到的不同内存大小的值。正如我们在[第
    5 章](ch05.html "第 5 章. 变量、表达式和事实") *变量、表达式和事实*中看到的那样，我们有一种方法可以直接在 Puppet 中获取这些信息，我们也有一个灵活且强大的配置数据数据库，正如我们在[第
    6 章](ch06.html "第 6 章. 使用 Hiera 管理数据") *使用 Hiera 管理数据*中看到的那样。问题是，我们如何能将这些数据动态插入到文本文件中。
- en: Puppet template syntax
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Puppet 模板语法
- en: 'Puppet''s **template** mechanism is one way to achieve this. A template is
    simply an ordinary text file, containing special placeholder markers which Puppet
    will replace with the relevant data values. The following example shows what these
    markers look like (`aws_credentials.epp`):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 的 **模板**机制就是实现这一目标的一种方式。模板只是一个普通的文本文件，包含特殊的占位符标记，Puppet 会用相关的数据值替换这些标记。以下示例展示了这些标记的样子（`aws_credentials.epp`）：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Everything outside the `<%=` and `%>` delimiters is literal text and will be
    rendered as-is by Puppet.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`<%=` 和 `%>` 分隔符之外的内容是字面文本，Puppet 会原样渲染这些内容。'
- en: The text inside the delimiters, however, is interpreted as a Puppet expression
    (in this case, just the variable `$aws_access_key`), which will be evaluated when
    the template is compiled, and the result will be interpolated into the text.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，分隔符内的文本会被解释为Puppet表达式（在这个例子中，仅为变量`$aws_access_key`），在模板编译时会被评估，并将结果插入到文本中。
- en: 'For example, if the variable `$aws_access_key` has the value `AKIAIAF7V6N2PTOIZVA2`,
    then when the template is processed by Puppet the resulting output text will look
    like the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果变量`$aws_access_key`的值为`AKIAIAF7V6N2PTOIZVA2`，那么当模板被Puppet处理时，生成的输出文本将如下所示：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can have as many of these delimited expressions (called **tags**) in the
    template as you like, and they will all be evaluated and interpolated when the
    template is used.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在模板中使用任意多的这些分隔符表达式（称为**标签**），它们将在模板使用时被评估并插入。
- en: Puppet's template mechanism is called **EPP** (for **Embedded Puppet**), and
    template files have the extension `.epp`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet的模板机制称为**EPP**（**嵌入式Puppet**），模板文件的扩展名为`.epp`。
- en: Using templates in your manifests
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的清单中使用模板
- en: 'Since the end result of a template is a file, you won''t be surprised that
    we use Puppet''s `file` resource to work with templates. In fact, we use an attribute
    of the `file` resource that you''ve seen before: the `content` attribute.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模板的最终结果是一个文件，你不会惊讶于我们使用Puppet的`file`资源来处理模板。实际上，我们使用的是`file`资源的一个属性，你之前见过：`content`属性。
- en: Referencing template files
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用模板文件
- en: 'Recall from [Chapter 2](ch02.html "Chapter 2. Creating your first manifests"),
    *Creating your first manifests*, that you can use the `content` attribute to set
    a file''s contents to a literal string:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第2章](ch02.html "第2章。创建第一个清单")，*创建第一个清单*，你可以使用`content`属性将文件的内容设置为字面字符串：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And, of course, you can interpolate the value of Puppet expressions into that
    string:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以将Puppet表达式的值插入到该字符串中：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So far, so familiar, but we can take one further step and replace the literal
    string with a call to the `epp()` function (`file_epp.pp`):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你应该已经很熟悉了，但我们可以再进一步，使用`epp()`函数（`file_epp.pp`）替代字面字符串：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Puppet will compile the template file referenced by `backup.sh.epp`, replacing
    any tags with the value of their expressions, and the resulting text will be written
    to the file `/usr/local/bin/backup`. The template file might look something like
    the following (`backup.sh.epp`):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet将编译由`backup.sh.epp`引用的模板文件，替换任何标签为其表达式的值，生成的文本将写入文件`/usr/local/bin/backup`。模板文件可能如下所示（`backup.sh.epp`）：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can use the `epp()` function anywhere a string is expected, but it's most
    common to use it to manage a file, as shown in the example.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何期望字符串的地方使用`epp()`函数，但最常见的用法是在管理文件时使用它，如示例所示。
- en: 'To reference a template file from within a module (for example, in our NTP
    module from [Chapter 7](ch07.html "Chapter 7. Mastering modules"), *Mastering
    modules*), put the file in the `modules/pbg_ntp/templates/` directory, and prefix
    the filename with `pbg_ntp/`, as in the following example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要在模块内引用模板文件（例如，在我们的NTP模块中，来自[第7章](ch07.html "第7章。掌握模块")，*掌握模块*），将文件放入`modules/pbg_ntp/templates/`目录，并将文件名以`pbg_ntp/`为前缀，如以下示例所示：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Remember**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**记住**'
- en: Don't include `templates/` as part of the path. Puppet knows it's a template,
    so it will automatically look in the `templates/` directory of the named module.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将`templates/`作为路径的一部分。Puppet知道这是一个模板，因此它会自动在指定模块的`templates/`目录中查找。
- en: Inline templates
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内联模板
- en: 'Your template text need not be in a separate file: if it''s a short template,
    you can put it in a literal string in your Puppet manifest and use the `inline_epp()`
    function to compile it (`file_inline_epp.pp`):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你的模板文本不必放在单独的文件中：如果是一个简短的模板，你可以将其放在Puppet清单中的字面字符串中，并使用`inline_epp()`函数编译它（`file_inline_epp.pp`）：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that we used a **single-quoted string** to specify the inline template
    text. If we'd used a double-quoted string, Puppet would have interpolated the
    values of `$web_root` and `$backup_dir` *before* processing the template, which
    is not what we want.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用了**单引号字符串**来指定内联模板文本。如果我们使用了双引号字符串，Puppet会在处理模板之前*插入*`$web_root`和`$backup_dir`的值，这并不是我们想要的结果。
- en: In general, though, it's better and more readable to use a separate template
    file for all but the simplest templates.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，最好且更具可读性的是，为除了最简单的模板之外的所有模板使用单独的模板文件。
- en: Template tags
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板标签
- en: 'The tag we''ve been using in the examples so far in this chapter is known as
    an **expression-printing tag**:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章示例中使用的标签被称为**表达式打印标签**：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Puppet expects the contents of this tag to have a value, which will then be
    inserted into the template in place of the tag.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet期望此标签的内容具有一个值，该值将被插入模板中，代替标签的位置。
- en: 'A **non-printing tag** is very similar, but will not generate any output. It
    has no `=` sign in the opening delimiter:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**非打印标签**与之非常相似，但不会生成任何输出。它的开头定界符中没有`=`符号：'
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can also use a **comment tag** to add text which will be removed when Puppet
    compiles the template:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用**注释标签**来添加文本，这些文本将在Puppet编译模板时被移除：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Computations in templates
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板中的计算
- en: So far, we've simply interpolated the value of a variable into our template,
    but we can do more. Template tags can contain any valid Puppet expression.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是将一个变量的值插入到模板中，但我们可以做得更多。模板标签可以包含任何有效的Puppet表达式。
- en: It's very common for certain values in config files to be **computed** from
    other values, such as the amount of physical memory on the node. We saw an example
    of this in [Chapter 5](ch05.html "Chapter 5. Variables, expressions, and facts"),
    *Variables, expressions, and facts*, where we computed a config value based on
    the value of `$facts['memory']['system']['total_bytes']`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置文件中，某些值通常是从其他值**计算**出来的，比如节点的物理内存量。我们在[第5章](ch05.html "第5章. 变量、表达式与事实")，*变量、表达式和事实*中看到过一个示例，我们基于`$facts['memory']['system']['total_bytes']`的值计算了一个配置值。
- en: 'Naturally, whatever we can do in Puppet code, we can also do in a template,
    so here''s the same computation in template form (`template_compute.epp`):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，我们在Puppet代码中能做的事情，也能在模板中做。所以这是相同的计算逻辑，用模板形式表示（`template_compute.epp`）：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The generated output (on my Vagrant box) is as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的输出（在我的Vagrant环境中）如下所示：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You're not restricted to numerical computations; you can do anything a Puppet
    expression can do, including string manipulation, array and hash lookups, fact
    references, function calls, and so on.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你不局限于数字计算；你可以做任何Puppet表达式能做的事情，包括字符串操作、数组和哈希查找、事实引用、函数调用等等。
- en: Conditional statements in templates
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板中的条件语句
- en: You might not be very impressed with templates so far, pointing out that you
    can already interpolate the values of Puppet expressions in strings, and hence
    files, without using a template. That said, templates allow you to interpolate
    data into much bigger files than it would be practical or desirable to create
    with a literal string in your Puppet manifest.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能对模板并不印象深刻，因为你已经可以在字符串中插入Puppet表达式的值，从而无需使用模板就可以处理文件。话虽如此，模板允许你将数据插入到比通过Puppet清单中的字面字符串更大且更实际的文件中。
- en: 'Templates also allow you to do something else very useful: **include or exclude
    sections of text** based on the result of some Puppet conditional expression.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 模板还允许你做其他非常有用的事情：**根据某些Puppet条件表达式的结果包含或排除文本块**。
- en: 'We''ve already met conditional statements in manifests in [Chapter 5](ch05.html
    "Chapter 5. Variables, expressions, and facts"), *Variables, expressions, and
    facts*, where we used them to conditionally include sets of Puppet resources (`if.pp`):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第5章](ch05.html "第5章. 变量、表达式与事实")，*变量、表达式和事实*中已经遇到过清单中的条件语句，我们使用它们来有条件地包含Puppet资源集（`if.pp`）：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Since the content of template tags is just Puppet code, you can use an `if`
    statement in a template too. Here''s a similar example to the previous one, but
    this time controlling inclusion of a block of configuration in a template (`template_if.epp`):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模板标签的内容就是Puppet代码，你也可以在模板中使用`if`语句。这是与之前类似的示例，但这次控制的是在模板中是否包含配置块（`template_if.epp`）：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This looks a little more complicated, but it's actually exactly the same logic
    as in the previous example. We have an `if` statement which tests the value of
    a Boolean variable, `$ssl_enabled`, and depending on the result, the following
    block is either included or excluded.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来稍微复杂一些，但实际上它与前面的示例逻辑完全相同。我们有一个`if`语句，用来测试一个布尔变量`$ssl_enabled`的值，根据结果，以下的代码块要么被包含，要么被排除。
- en: 'You can see that the `if` statement and the closing `}` are enclosed in non-printing
    tags, so they generate no output themselves, and as Puppet compiles the template,
    it will execute the Puppet code within the tags and that will determine the output.
    If `$ssl_enabled` is true, the file generated by the template will contain the
    following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，`if`语句和结束的`}`被包含在非打印标签中，因此它们本身不会生成任何输出，而当Puppet编译模板时，它将执行标签内的Puppet代码，这将决定输出内容。如果`$ssl_enabled`为真，模板生成的文件将包含以下内容：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Otherwise, this part of the template will be omitted. This is a very useful
    way of conditionally including blocks in a configuration file.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，这部分模板将被省略。这是一种非常有用的条件包含配置文件中块的方法。
- en: Just as with `if` statements in manifest files, you can also use `else` to include
    an alternative block instead, if the conditional statement is false.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在清单文件中的`if`语句一样，你也可以使用`else`来包含一个备用块，如果条件语句为假。
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Notice that the closing tags in the previous example had an extra leading hyphen:
    `-%>`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的示例中，关闭标签有一个额外的前导连字符：`-%>`。
- en: When you use this syntax, Puppet suppresses any trailing whitespace and linebreak
    after the tag. It's common to use this syntax with non-printing template tags,
    because otherwise you'd end up with empty lines in the output.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用这个语法时，Puppet会抑制标签后面的任何尾随空格和换行符。通常我们会将此语法与非打印模板标签一起使用，否则你会在输出中看到空行。
- en: Iteration in templates
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板中的迭代
- en: If we can generate parts of a file from Puppet expressions, and also include
    or exclude parts of the file depending on conditions, could we generate parts
    of the file with a Puppet loop? That is to say, could we **iterate over an array
    or hash**, generating template content for each element? Indeed we can. This is
    a very powerful mechanism which enables us to generate files of arbitrary size,
    based on Puppet variables, or Hiera and Facter data.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够从Puppet表达式生成文件的部分内容，并且根据条件包括或排除文件的部分内容，那么我们能否通过Puppet循环生成文件的部分内容呢？也就是说，我们能否**对数组或哈希进行迭代**，为每个元素生成模板内容？实际上，我们可以。这是一个非常强大的机制，它使我们能够基于Puppet变量、Hiera和Facter数据生成任意大小的文件。
- en: Iterating over Facter data
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历Facter数据
- en: Our first example generates part of the config file for an application which
    captures network packet data. To tell it which interfaces to listen on, we need
    to generate a list of all the live network interfaces on the node.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个示例生成了一个应用程序的配置文件的一部分，该应用程序用于捕获网络数据包。为了告诉它监听哪些接口，我们需要生成节点上所有活动网络接口的列表。
- en: How can we generate this output? We know Facter can give us a list of all the
    network interfaces available, with `$facts['networking']['interfaces']`. This
    is actually a hash, where the key is the name of the interface, and the value
    is a hash of the interface's attributes, such as the IP address and netmask.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何生成这个输出？我们知道Facter可以通过`$facts['networking']['interfaces']`给我们一个所有可用网络接口的列表。实际上，这是一个哈希，键是接口的名称，值是接口属性的哈希，例如IP地址和子网掩码。
- en: 'You may recall from [Chapter 5](ch05.html "Chapter 5. Variables, expressions,
    and facts"), *Variables, expressions, and facts* that in order to iterate over
    a hash, we use a syntax like the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得在[第5章](ch05.html "第5章 变量、表达式与事实")，*变量、表达式与事实*中提到过，为了遍历哈希，我们使用类似以下的语法：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'So let''s apply this pattern to the Facter data and see what the output looks
    like (`template_iterate.epp`):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们来将这个模式应用到Facter数据中，看看输出结果是什么样的（`template_iterate.epp`）：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Each time round the loop, the values of `$interface` and `$attrs` will be set
    to the next key and value of the hash returned by `$facts['networking']['interfaces']`.
    As it happens, we will not be using the value of `$attrs`, but we still need to
    declare it as part of the loop syntax.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每次循环时，`$interface`和`$attrs`的值将设置为由`$facts['networking']['interfaces']`返回的哈希中的下一个键和值。实际上，我们不会使用`$attrs`的值，但我们仍然需要将其声明为循环语法的一部分。
- en: 'Each time round the loop, the value of `$interface` is set to the name of the
    next interface in the list, and a new output line like the following is generated:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每次循环时，`$interface`的值将设置为列表中下一个接口的名称，并生成像下面这样的新输出行：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'At the end of the loop, we have generated as many output lines as we have interfaces,
    which is the desired result. Here''s the final output, on a node with lots of
    network interfaces:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环结束时，我们生成了与接口数量相同的输出行，这是我们期望的结果。以下是最终输出，在一个有很多网络接口的节点上：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Iterating over structured facts
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历结构化事实
- en: The next configuration data required for our application is a list of IP addresses
    associated with the node, which we can generate in a similar way to the previous
    example.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序所需的下一个配置数据是与节点相关的 IP 地址列表，这可以通过类似前一个示例的方法生成。
- en: We can use more or less the same Puppet code as in the previous example, only
    this time we will be using each interface's `$attrs` hash to get the IP address
    of the associated interface.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用与前一个示例中几乎相同的 Puppet 代码，不过这一次我们将使用每个接口的 `$attrs` 哈希表来获取相关接口的 IP 地址。
- en: 'The following example shows how this works (`template_iterate2.epp`):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了这一过程是如何工作的（`template_iterate2.epp`）：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The loop is the same as in the previous example, but this time each output line
    contains, not the value of `$interface`, but the value of `$attrs['bindings'][0]['address']`,
    which contains the IP address of each interface.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 循环与前一个示例相同，但这次每行输出的不是 `$interface` 的值，而是 `$attrs['bindings'][0]['address']`
    的值，其中包含每个接口的 IP 地址。
- en: 'Here''s the final output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最终输出：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Iterating over Hiera data
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历 Hiera 数据
- en: In [Chapter 6](ch06.html "Chapter 6. Managing data with Hiera"), *Managing data
    with Hiera* we used a Hiera array of users to generate Puppet resources for each
    user. Let's use the same Hiera data now to build a dynamic configuration file
    using iteration in a template.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章：使用 Hiera 管理数据")，*使用 Hiera 管理数据*中，我们使用了一个 Hiera 用户数组来为每个用户生成
    Puppet 资源。现在我们使用相同的 Hiera 数据，通过在模板中进行迭代来构建一个动态配置文件。
- en: The SSH daemon `sshd` can be configured to allow SSH access only by a list of
    named users (with the `AllowUsers` directive), and, indeed, it's good practice
    to do this.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 守护进程 `sshd` 可以配置为仅允许通过一个用户列表进行 SSH 访问（使用 `AllowUsers` 指令），而且，实际上，最好这样做。
- en: Tip
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Security tip**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全提示**'
- en: Most servers accessible from the public Internet regularly receive brute-force
    login attempts for random usernames, and dealing with these can use up a lot of
    resources. If `sshd` is configured to allow only specified users, it can quickly
    reject any users not in this list, without having to process the request further.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数可以从公共互联网访问的服务器会定期收到针对随机用户名的暴力登录尝试，处理这些登录尝试可能会消耗大量资源。如果 `sshd` 配置为仅允许指定的用户，它可以迅速拒绝任何不在此列表中的用户，而无需进一步处理该请求。
- en: If our users are listed in Hiera, then it's easy to use a template to generate
    this `AllowUsers` list for the `sshd_config` file.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的用户列在 Hiera 中，那么使用模板生成 `sshd_config` 文件的 `AllowUsers` 列表就变得简单了。
- en: 'Just as we did when generating Puppet `user` resources, we will make a call
    to `lookup()` to get the array of users, and iterate over this using `each`. The
    following example shows what this looks like in the template (`template_hiera.epp`):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在生成 Puppet `user` 资源时所做的那样，我们将调用 `lookup()` 来获取用户数组，并使用 `each` 对其进行迭代。以下示例展示了在模板中（`template_hiera.epp`）是如何实现的：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note the leading space on the second line, which results in the usernames in
    the output being space-separated. Note also the use of the leading hyphen to the
    closing tag (`-%>`) which, as we saw earlier in the chapter, will suppress any
    trailing whitespace on the line.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第二行前面的空格，这会导致输出中的用户名之间以空格分隔。还要注意前导连字符的使用（`-%>`），正如我们在本章前面所看到的，它将抑制该行末尾的任何空白字符。
- en: 'Here''s the result:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Working with templates
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模板
- en: One potential problem with templates (since they can include Puppet code, variables,
    and Hiera data) is that it's not always clear from the Puppet manifest what **variables**
    the template is going to use. Conversely, it's not easy to see from the template
    code where any referenced variables are coming from. This can make it hard to
    maintain or update templates, and also to debug any problems caused by incorrect
    data being fed into the template.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 模板的一个潜在问题（因为它们可以包含 Puppet 代码、变量和 Hiera 数据）是，从 Puppet 清单中并不总是能清楚地知道模板将使用哪些**变量**。相反，从模板代码中也不容易看出任何引用的变量来自哪里。这可能使得维护或更新模板变得困难，也增加了调试因错误数据传入模板而导致问题的难度。
- en: Ideally, we would like to be able to specify in the Puppet code exactly what
    variables the template is going to receive, and this list would also appear in
    the template itself. For extra credit, we would like to be able to specify the
    **data type** of input variables, in just the same way that we do for classes
    and defined resource types (see [Chapter 8](ch08.html "Chapter 8. Classes, roles,
    and profiles"), *Classes, roles, and profiles*, for more about this.)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望能够在Puppet代码中精确地指定模板将接收哪些变量，并且这些变量的列表也会出现在模板中。作为附加内容，我们希望能够指定输入变量的**数据类型**，就像我们为类和定义的资源类型所做的那样（有关更多信息，请参见[第8章](ch08.html
    "第8章 类、角色和配置文件")，*类、角色和配置文件*）。
- en: The good news is that EPP templates allow you to declare the parameters you
    want passed to your template, along with the required data types, in exactly the
    same way as you can for classes. While it's not compulsory to declare parameters
    for your EPP templates, it's a very good idea to do so. With declared and typed
    parameters, you will be able to catch most data errors at the template compilation
    stage, which makes troubleshooting much easier.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，EPP模板允许你像为类那样声明传递给模板的参数，并指定所需的数据类型。虽然不强制要求为EPP模板声明参数，但这么做是一个非常好的主意。通过声明并类型化的参数，你将能够在模板编译阶段捕捉到大多数数据错误，从而使故障排除变得更加容易。
- en: Passing parameters to templates
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向模板传递参数
- en: 'To declare parameters for a template, list them between pipe characters (`|`)
    inside a non-printing tag, as shown in the following example (`template_params.epp`):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明模板的参数，请将它们列在管道符号（`|`）之间，放在一个非打印标签内，如以下示例所示（`template_params.epp`）：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When you declare parameters in a template, you must pass those parameters explicitly,
    in hash form, as the second argument to the `epp()` function call. The following
    example shows how to do this (`epp_params.pp`):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中声明参数时，必须将这些参数以哈希形式显式地传递作为`epp()`函数调用的第二个参数。以下示例展示了如何做到这一点（`epp_params.pp`）：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This form of the `epp()` function call takes two parameters: the path to the
    template file, and a hash containing all the required template parameters. The
    keys to the hash are the parameter names, and the values are the values. (These
    need not be literal values; they could be Hiera lookups, for example.)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式的`epp()`函数调用接受两个参数：模板文件的路径和一个包含所有必需模板参数的哈希。哈希的键是参数名，值是对应的值。（这些值不一定是字面量值；例如，它们可以是Hiera查找的结果。）
- en: It's very likely that you will be using Hiera data in templates, and although
    in our previous `AllowUsers` example we called `lookup()` directly from the template
    to look up the data, this isn't really the best way to do it. Now that we know
    how to declare and pass parameters to templates, we should do the same thing with
    Hiera data.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能你会在模板中使用Hiera数据，虽然在我们之前的`AllowUsers`示例中我们直接从模板中调用`lookup()`来查找数据，但这并不是最好的做法。现在我们知道如何声明并传递参数到模板，我们应该用相同的方法来处理Hiera数据。
- en: 'Here is an updated version of the `AllowUsers` example where we do the Hiera
    lookup in the manifest, as part of the `epp()` call. First, we need to declare
    a `$users` parameter in the template (`template_hiera_params.epp`):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是更新后的`AllowUsers`示例，我们在清单中执行了Hiera查找，作为`epp()`调用的一部分。首先，我们需要在模板中声明一个`$users`参数（`template_hiera_params.epp`）：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, when we compile the template with `epp()`, we pass in the Hiera data
    by calling `lookup()` in the parameters hash (`epp_hiera.pp`):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们使用`epp()`编译模板时，我们通过在参数哈希中调用`lookup()`来传递Hiera数据（`epp_hiera.pp`）：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you have declared a parameter list in the template, you must pass it exactly
    those parameters in the `epp()` call, and no others. EPP templates declare parameters
    in the same way as classes do: parameters can be given default values, and any
    parameter without a default value is mandatory.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在模板中声明了参数列表，必须在`epp()`调用中准确地传递这些参数，而不能传递其他任何参数。EPP模板声明参数的方式与类相同：参数可以具有默认值，任何没有默认值的参数都是必需的。
- en: It's clear from the previous example that declaring parameters makes it much
    easier to see what information the template is going to use from the calling code,
    and we now have the benefit of automated checking of the parameters and their
    types.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的示例中可以清楚地看出，声明参数使得查看模板将从调用代码中使用哪些信息变得更加容易，现在我们还可以享受到自动检查参数及其类型的好处。
- en: Note, however, that even templates with a parameter list can still access any
    Puppet variable or fact in the template body; Puppet does not prevent the template
    from using variables which have not been declared as parameters, or getting data
    directly from Hiera. It should be clear by now, though, that bypassing the parameter
    checking machinery in this way is a bad idea.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意，即使是包含参数列表的模板，仍然可以访问模板主体中的任何 Puppet 变量或事实；Puppet 不会阻止模板使用未声明为参数的变量，或者直接从
    Hiera 获取数据。不过，应该清楚的是，通过这种方式绕过参数检查机制是一个不好的做法。
- en: Tip
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Best practices**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: Use EPP templates for dynamically-generated files, declare typed parameters
    in the template, and pass those parameters as a hash to the `epp()` function.
    To make your template code easier to understand and maintain, always pass data
    explicitly to the template. If the template needs to look up Hiera data, do the
    lookup in your Puppet manifest and have the template declare a parameter to receive
    the data.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 EPP 模板来生成动态文件，在模板中声明类型化参数，并将这些参数作为哈希传递给 `epp()` 函数。为了使模板代码更易于理解和维护，始终显式地将数据传递给模板。如果模板需要查找
    Hiera 数据，应在 Puppet 清单中执行查找，并让模板声明一个参数来接收数据。
- en: Validating template syntax
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证模板语法
- en: We've seen in this chapter that templates can contain complex logic and iteration
    that can generate almost any output required. The downside of this power and flexibility
    is that it can be difficult to read and debug template code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中看到，模板可以包含复杂的逻辑和迭代，几乎可以生成任何所需的输出。这种强大灵活性的缺点是，模板代码可能很难阅读和调试。
- en: 'Fortunately, Puppet includes a tool to check and validate your templates on
    the command line: `puppet epp validate`. To use it, run the following command
    against your template file:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Puppet 提供了一个工具，可以在命令行中检查和验证你的模板：`puppet epp validate`。要使用它，请运行以下命令检查你的模板文件：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If there is no output, the template is valid. If the template contains an error,
    you will see an error message, something like the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有输出，模板是有效的。如果模板包含错误，你将看到错误信息，类似如下：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Rendering templates on the command line
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在命令行渲染模板
- en: 'As any programmer knows, even programs with valid syntax don''t necessarily
    produce the correct results. It can be very useful to see exactly what output
    the template is going to produce, and Puppet also provides a tool to do this:
    `puppet epp render`.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如任何程序员所知道的，即使程序具有有效的语法，也不一定会产生正确的结果。查看模板将要生成的输出非常有用，Puppet 也提供了一个工具来实现这一点：`puppet
    epp render`。
- en: 'To use it, run the following command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该工具时，运行以下命令：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `--values` argument allows you to pass in a hash of parameter-value pairs,
    just as you would when calling the `epp()` function in your Puppet manifest.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`--values` 参数允许你传入一对参数值的哈希，就像你在 Puppet 清单中调用 `epp()` 函数时一样。'
- en: 'Alternatively, you can use the `--values_file` argument to reference a Puppet
    manifest file containing the hash of parameters:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `--values_file` 参数来引用一个包含参数哈希的 Puppet 清单文件：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can pass parameters both on the command line with `--values`, and from
    a file with `--values_file`, simultaneously. Parameters given on the command line
    will take priority over those from the file:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过命令行使用 `--values` 传递参数，也可以通过 `--values_file` 从文件中传递参数，二者可以同时使用。命令行传递的参数将优先于文件中的参数：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can also use `puppet epp render` to test inline template code, using the
    `-e` switch to pass in a literal template string:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `puppet epp render` 来测试内联模板代码，通过 `-e` 选项传入一个字面模板字符串：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Just as when testing your manifests, you can also use `puppet apply` to test
    your templates directly, using a command similar to the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 就像测试你的清单一样，你也可以直接使用 `puppet apply` 来测试模板，使用类似以下的命令：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: One advantage of this approach is that all Puppet variables, facts, and Hiera
    data will be available to your template.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个优势是，所有 Puppet 变量、事实和 Hiera 数据都将可供模板使用。
- en: Legacy ERB templates
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旧版 ERB 模板
- en: 'You''ll probably come across references to a different type of Puppet template
    in older code and documentation: the **ERB template**. ERB (for Embedded Ruby)
    was the only template mechanism provided in Puppet up until version 3.5, when
    EPP support was added, and EPP has now replaced ERB as Puppet''s default template
    format.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在旧代码和文档中遇到另一种类型的 Puppet 模板：**ERB 模板**。ERB（嵌入式 Ruby）是 Puppet 在版本 3.5 之前提供的唯一模板机制，直到增加了对
    EPP 的支持，现在 EPP 已经取代 ERB 成为 Puppet 的默认模板格式。
- en: 'ERB template syntax looks quite similar to EPP. The following example is a
    snippet from an ERB template:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ERB模板的语法与EPP相似。以下是一个ERB模板的代码片段：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The difference is that the template language inside the tags, is Ruby, not Puppet.
    Early versions of Puppet were rather limited in language features (for example,
    there was no `each` function to iterate over variables), so it was common to use
    Ruby code embedded in templates to work around this.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在于，标签内部的模板语言是Ruby，而不是Puppet。早期版本的Puppet在语言特性上相对有限（例如，缺少`each`函数来遍历变量），因此通常在模板中嵌入Ruby代码来解决这一问题。
- en: 'This required some complicated plumbing to manage the interface between Puppet
    and Ruby; for example, accessing variables in non-local scope in ERB templates
    requires the use of the `scope` hash, as in the previous example. Similarly, in
    order to access Puppet functions such as `strftime()`, you have to call:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一些复杂的操作来管理Puppet和Ruby之间的接口；例如，在ERB模板中访问非本地作用域的变量需要使用`scope`哈希，如前面的示例所示。同样，为了访问Puppet函数，如`strftime()`，你必须调用：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ERB templates also do not support declared parameters or type checking. I recommend
    you use only EPP templates in your own code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ERB模板也不支持声明参数或类型检查。我建议你在自己的代码中仅使用EPP模板。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we've looked at one of the most powerful tools in Puppet's toolbox,
    the template file. We've examined the EPP tag syntax and seen the different kinds
    of tags available, including printing and non-printing tags.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Puppet工具箱中最强大的工具之一——模板文件。我们研究了EPP标签语法，并了解了不同种类的标签，包括打印标签和非打印标签。
- en: We've learned that not only can you simply insert values from variables into
    templates, but that you can also include or exclude whole blocks of text, depending
    on the value of Puppet expressions, or generate templates of arbitrary size by
    iterating over arrays and hashes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到，你不仅可以简单地将变量中的值插入模板中，还可以根据Puppet表达式的值包含或排除整个文本块，或者通过遍历数组和哈希生成任意大小的模板。
- en: We've looked at some real-life examples of dynamically generating config files
    from Facter and Hiera data, and seen seen how to declare typed parameters in the
    template file, and pass in values for those parameters when calling the `epp()`
    function in your Puppet manifest.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看了一些从Facter和Hiera数据动态生成配置文件的实际示例，并且了解了如何在模板文件中声明类型化参数，并在调用`epp()`函数时为这些参数传入值。
- en: We've seen how to check the syntax of templates using `puppet epp validate`,
    and how to render the output of a template using `puppet epp render`, passing
    in canned values for the template parameters using `--values` and `--values_file`,
    or using `puppet apply` to render the template directly.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了如何使用`puppet epp validate`检查模板的语法，如何使用`puppet epp render`渲染模板的输出，并使用`--values`和`--values_file`传递模板参数的预设值，或者直接使用`puppet
    apply`渲染模板。
- en: Finally, we've touched on legacy ERB templates, where they come from, how they
    compare to EPP templates, and why, although you may still encounter ERB templates
    in the wild, you should only use EPP in your own code.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了遗留的ERB模板，它们的来源，如何与EPP模板进行比较，以及为什么尽管你仍可能在实际使用中遇到ERB模板，但你应该仅在自己的代码中使用EPP。
- en: In the next chapter, we'll explore the popular topic of containers, and look
    at how to manage the Docker engine and Docker containers with Puppet, and deal
    with the vexed issue of how to manage configuration in containers.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将探索一个热门话题——容器，了解如何使用Puppet管理Docker引擎和Docker容器，以及如何处理如何在容器中管理配置这一棘手问题。
