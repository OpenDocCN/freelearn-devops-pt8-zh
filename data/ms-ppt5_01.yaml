- en: Authoring Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写模块
- en: Authoring Puppet modules and manifests is the real heart of the work for your
    Puppet ecosystem.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 Puppet 模块和清单是 Puppet 生态系统工作的真正核心。
- en: So, you've perhaps already written at least a few modules for software components
    in your infrastructure, and there's already a great guide to getting started writing
    modules in the Puppet documentation at [https://puppet.com/docs/pe/2017.3/quick_start_guides/writing_modules_nix_getting_started_guide.html](https://puppet.com/docs/pe/2017.3/quick_start_guides/writing_modules_nix_getting_started_guide.html),
    so I won't waste any time going over that material again. But I'm sure that, in
    pursuit of mastering Puppet v5, what you would really like to do is to write those
    modules correctly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你可能已经为你的基础设施中的软件组件编写了至少几个模块，而且 Puppet 文档中有一个很好的入门指南：[https://puppet.com/docs/pe/2017.3/quick_start_guides/writing_modules_nix_getting_started_guide.html](https://puppet.com/docs/pe/2017.3/quick_start_guides/writing_modules_nix_getting_started_guide.html)，所以我不会浪费时间再讲解这些内容。但我敢肯定，在掌握
    Puppet v5 的过程中，你真正想要做的是正确地编写这些模块。
- en: Let's take that step together toward better quality modules in this chapter.
    I've spent a lot of time in the trenches over the last few years, gathering together
    best practices from some of the best projects across Europe and applying practices
    and software principles I've learned from both my university education and 15+
    years in the industry. I hope I can introduce you to some shortcuts and make your
    life easier!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在本章中一起迈出提高模块质量的一步。我在过去几年里花了大量时间深入一线，收集来自欧洲一些最佳项目的最佳实践，并应用我从大学教育和 15 年以上的行业经验中学到的实践和软件原则。我希望能向你介绍一些捷径，让你的工作更轻松！
- en: 'The following are a set of recommendations that I feel will really get you
    on the right path to higher quality Puppet modules and manifests:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我认为会真正帮助你走上高质量 Puppet 模块和清单正确路径的一些建议：
- en: Using a decent IDE and plugins
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用合适的 IDE 和插件
- en: 'Using a good module class structure:'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用良好的模块类结构：
- en: Following the class-naming conventions
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循类命名约定
- en: Having a single point of entry to the module
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为模块提供一个单一入口点
- en: Using high cohesion and loose coupling principles
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高内聚和低耦合原则
- en: Using the encapsulation principle
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用封装原则
- en: Strongly typing your module variables
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强类型化你的模块变量
- en: 'Using the new Puppet Development Kit commands:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新的 Puppet 开发工具包命令：
- en: Creating the module framework and metadata
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建模块框架和元数据
- en: Creating the `init.pp`
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `init.pp`
- en: Creating further classes
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建更多的类
- en: Validating your module
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证你的模块
- en: Unit testing your module
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对模块进行单元测试
- en: Staying on the lookout for code smells
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续关注代码气味
- en: Making sure you are not working with dead code
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你没有在处理死代码
- en: Working with the community
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与社区合作
- en: Using Puppet Forge
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Puppet Forge
- en: Writing great documentation
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写优秀的文档
- en: Adding module dependencies
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加模块依赖
- en: Adding compatibility data for your modules
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的模块添加兼容性数据
- en: Operating systems support
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统支持
- en: Puppet and PE version support
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet 和 PE 版本支持
- en: Using the new Hiera 5 module level data
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新的 Hiera 5 模块级别数据
- en: Upgrading your templates from ERB to ERP syntax
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将模板从 ERB 语法升级到 ERP 语法
- en: Let's examine each of these best practices now in turn.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们依次检查这些最佳实践。
- en: Using a decent IDE and plugins
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用合适的 IDE 和插件
- en: Using a decent text editor with the plugins that equip you to write well for
    Puppet is a really  good step toward better quality. There are quite a few options
    out there, and it's best to use whatever suits your own unique writing style.
    Personally, I have used Atom ([https://atom.io](https://atom.io)) most successfully,
    and recently installed it locally on my workstation. I used Eclipse many years
    ago (this has also been known previously as Geppetto), which I in fact felt was
    unwieldy due to a large memory footprint. It's also nice to remain fairly handy
    with Vim, especially for working on the command line server-side, or if you use
    a Linux OS on your workstation. There's also TextMate, for an macOS X only editor
    that has all of Apple's look and feel.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个合适的文本编辑器并配合插件进行编写，绝对是提高质量的好步骤。有很多选项可以选择，最好选择适合你个人写作风格的工具。就我个人而言，我最成功地使用了
    Atom（[https://atom.io](https://atom.io)），并最近将其安装在我的工作站上。我多年前使用过 Eclipse（这个工具也曾被称为
    Geppetto），不过我觉得它由于较大的内存占用显得笨重。保持一定的 Vim 熟练度也很不错，尤其是在服务器端的命令行操作，或者如果你在工作站上使用 Linux
    操作系统的话。另外，还有适用于 macOS X 的 TextMate 编辑器，它拥有 Apple 风格的界面。
- en: Let's take a look at some of the various options for an **Integrated Development
    Machine **(**IDE**) available to us as Puppet developers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下作为 Puppet 开发者可用的各种 **集成开发环境（IDE）** 选项。
- en: Vim
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vim
- en: Vim ([http://www.vim.org](http://www.vim.org)) is, of course, still a mainstay
    for text file editing. It has a very long history in the Unix world, and it's
    a very lightweight command-line text editor. Vim is just about as raw a text editor
    as you can get. It can be used as a lightning fast and efficient IDE if you have
    the memory and patience to learn the myriad keyboard commands. My advice is to
    start out with a few basic commands, and make an effort to pick up a few more
    each time you use Vim.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Vim ([http://www.vim.org](http://www.vim.org)) 当然仍然是文本文件编辑的主流工具。它在 Unix 世界有着悠久的历史，是一个非常轻量级的命令行文本编辑器。Vim
    可以说是最原始的文本编辑器之一。如果你有足够的内存并且有耐心学习各种键盘命令，它可以作为一个闪电般快速且高效的 IDE 使用。我的建议是从几个基本命令开始，每次使用
    Vim 时都尽量学习一些新命令。
- en: You can pimp your Vim and make it better suited for editing Puppet manifests.
    Let's take a look at that, assuming you've just grabbed a fresh Vim installation,
    and you have Git installed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以优化你的 Vim，使其更适合编辑 Puppet 清单。假设你刚安装了一个全新的 Vim，并且已经安装了 Git，我们来看看如何操作。
- en: 'Move to your home directory and clone the given repository with the following
    commands:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 进入你的主目录并使用以下命令克隆给定的仓库：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Cloning the repository into your home directory''s `.vim` directory will configure
    your Vim settings for you. The repository contains several submodules containing
    the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将仓库克隆到你的主目录的 `.vim` 目录中，将为你配置 Vim 设置。该仓库包含几个子模块，包含以下内容：
- en: '**Pathogen** ([https://github.com/tpope/vim-pathogen](https://github.com/tpope/vim-pathogen))
    is Vim guru Tim Pope''s general-purpose add-on that allows you to manage your
    Vim *runtimepath* with ease and install Vim plugins and runtime files each in
    their own private directories, rather than having file collisions.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pathogen** ([https://github.com/tpope/vim-pathogen](https://github.com/tpope/vim-pathogen))
    是 Vim 大师 Tim Pope 的通用插件，它让你可以轻松管理 Vim 的 *runtimepath*，并将 Vim 插件和运行时文件安装到各自独立的目录中，避免文件冲突。'
- en: '**Vim-puppet** ([https://github.com/rodjek/vim-puppet](https://github.com/rodjek/vim-puppet))
    is the original Vim plugin written by Tim Sharpe, making Vim much more Puppet-friendly.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Vim-puppet** ([https://github.com/rodjek/vim-puppet](https://github.com/rodjek/vim-puppet))
    是 Tim Sharpe 编写的原始 Vim 插件，使 Vim 更加适合 Puppet 开发。'
- en: '**snipmate.vim** ([https://github.com/msanders/snipmate.vim](https://github.com/msanders/snipmate.vim))
    is a Vim script that implements some of TextMate''s snippet features for Vim.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**snipmate.vim** ([https://github.com/msanders/snipmate.vim](https://github.com/msanders/snipmate.vim))
    是一个 Vim 脚本，它实现了 TextMate 的一些代码片段功能。'
- en: '**Syntastic** ([https://github.com/vim-syntastic/syntastic](https://github.com/vim-syntastic/syntastic))
    is a syntax-checking plugin that runs files through external syntax checkers and
    displays any resulting errors. This can be done from the command line with the
    `pdk validate` command, or automatically as files are saved.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Syntastic** ([https://github.com/vim-syntastic/syntastic](https://github.com/vim-syntastic/syntastic))
    是一个语法检查插件，它通过外部语法检查器检查文件，并显示任何出现的错误。这可以通过命令行的 `pdk validate` 命令完成，也可以在文件保存时自动进行检查。'
- en: '**Tabular** ([https://github.com/godlygeek/tabular](https://github.com/godlygeek/tabular))
    is used to line up your fat arrows (=>) according to the *Puppet Style Guide*,
    so that it will pass running the `pdk validate` command. (We will cover the `pdk
    validate` command in full later.)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tabular** ([https://github.com/godlygeek/tabular](https://github.com/godlygeek/tabular))
    用于根据 *Puppet 风格指南*对你的箭头符号 (=>) 进行对齐，以便通过运行 `pdk validate` 命令（我们稍后会详细介绍 `pdk validate`
    命令）。'
- en: '**vim-fugitive** ([https://github.com/tpope/vim-fugitive](https://github.com/tpope/vim-fugitive))
    provides deep Git integration for Vim.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**vim-fugitive** ([https://github.com/tpope/vim-fugitive](https://github.com/tpope/vim-fugitive))
    提供了 Vim 的深度 Git 集成功能。'
- en: I can't promise this will be a perfect Vim setup for your own personal Vim style,
    but it will certainly get you on the right path, and you will have Pathogen installed,
    so you can further tweak your Vim settings until you have it just how you like
    it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我不能保证这将是一个完美符合你个人 Vim 风格的 Vim 设置，但它肯定会让你走上正确的道路，并且你将安装 Pathogen，这样你就可以进一步调整你的
    Vim 设置，直到它符合你的需求。
- en: You might also want to fork this repository in GitHub, so you can keep all your
    settings and share them with your team.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想在 GitHub 上 fork 这个仓库，这样你可以保存所有的设置并与团队共享。
- en: TextMate
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TextMate
- en: 'TextMate ([http://macromates.com](http://macromates.com)) is an macOS X only
    editor, and there''s a TextMate bundle available ([https://github.com/masterzen/puppet-textmate-bundle](https://github.com/masterzen/puppet-textmate-bundle))
    for editing Puppet manifests. First, install TextMate and Git (available with
    the command-line developer tools), and follow these commands to set up the Puppet
    bundle:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: TextMate ([http://macromates.com](http://macromates.com)) 是一个仅适用于 macOS X 的编辑器，且有一个专门的
    TextMate bundle 可用于编辑 Puppet 清单 ([https://github.com/masterzen/puppet-textmate-bundle](https://github.com/masterzen/puppet-textmate-bundle))。首先，安装
    TextMate 和 Git（可以通过命令行开发者工具获取），然后按照以下命令设置 Puppet bundle：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now select a manifest and open it with TextMate. In the TextMate dialog, select
    Puppet and Install Bundle, and you are all ready to rock.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在选择一个清单并用 TextMate 打开。在 TextMate 对话框中，选择 Puppet 并安装 Bundle，之后你就准备好开始了。
- en: Atom
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Atom
- en: 'Here''s the IDE that I would recommend based on my own personal style, using
    my MacBook as the host OS. Atom ([https://atom.io](https://atom.io)) is a fully
    featured IDE described as, *A hackable text editor for the 21st Century* and contains
    all the functionality you''d expect: cross-platform, package (that is, plugin)
    manager, auto-completion, file browser, multiple panes, find and replace, and
    so on.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我基于个人风格推荐的 IDE，使用我的 MacBook 作为主机操作系统。Atom ([https://atom.io](https://atom.io))
    是一个功能齐全的 IDE，被描述为 *一个适用于 21 世纪的可黑客化文本编辑器*，它包含了你期望的所有功能：跨平台、包（即插件）管理器、自动补全、文件浏览器、多个面板、查找和替换等。
- en: GitHub has developed Atom, and they have built it with the goal of combining
    the convenience of a fully fledged IDE with the deep configurability of a classic
    but complex editor such as Vim.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 开发了 Atom，并且他们的目标是将一个完整的 IDE 的便利性与像 Vim 这样的经典复杂编辑器的深度可配置性结合起来。
- en: 'There are literally thousands of open source packages that add new features
    and functionality to Atom, and here are the ones I recommend specifically for
    Puppet development:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Atom 上有成千上万的开源包，为其增加了新的功能，下面是我特别推荐用于 Puppet 开发的那些：
- en: '`language-puppet` (adds syntax highlighting and snippets to Puppet files)'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`language-puppet`（为 Puppet 文件添加语法高亮和片段）'
- en: '`linter-puppet-lint` (provides linter support to your Puppet manifests)'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`linter-puppet-lint`（为你的 Puppet 清单提供 linting 支持）'
- en: '`aligner-puppet` (aligns the fat arrows according to the Puppet Style Guide)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aligner-puppet`（根据 Puppet 风格指南对胖箭头进行对齐）'
- en: '`erb-snippets` (snippets and hotkeys for writing Puppet ERB templates)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`erb-snippets`（用于编写 Puppet ERB 模板的片段和快捷键）'
- en: '`linter-js-yaml` (parses your YAML files with JS-YAML)'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`linter-js-yaml`（使用 JS-YAML 解析你的 YAML 文件）'
- en: '`tree-view-git-status` (displays the Git status of files in the tree view)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tree-view-git-status`（在树视图中显示文件的 Git 状态）'
- en: Visual Studio
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio
- en: If you're a developer in the Windows and .NET world, then look no further than
    the Puppet language support for Visual Studio Code extension ([https://marketplace.visualstudio.com/items?itemName=jpogran.puppet-vscode](https://marketplace.visualstudio.com/items?itemName=jpogran.puppet-vscode)).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是 Windows 和 .NET 世界的开发者，那么不妨看看 Visual Studio Code 插件中的 Puppet 语言支持 ([https://marketplace.visualstudio.com/items?itemName=jpogran.puppet-vscode](https://marketplace.visualstudio.com/items?itemName=jpogran.puppet-vscode))。
- en: 'It contains all the features you would expect for Puppet development in the
    Visual Studio IDE: syntax highlighting, code snippets, file validation, linting
    according to the Puppet Style Guide, IntelliSense for resources and parameters,
    importing from the `puppet resource` command, node graph previewing, and now,
    **Puppet Development Kit** (**PDK**) integration.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含了你在 Visual Studio IDE 中开发 Puppet 时所期望的所有功能：语法高亮、代码片段、文件验证、根据 Puppet 风格指南进行
    linting、资源和参数的 IntelliSense、从 `puppet resource` 命令导入、节点图预览，现已集成 **Puppet Development
    Kit** (**PDK**)。
- en: Using good module and class structure
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用良好的模块和类结构
- en: This section contains a set of recommendations surrounding good module and class
    design. Bear in mind that Puppet development is, in principle, just like any other
    type of software development, and we've learned over many years in software development,
    and especially at O&O software, that certain modular and class design principles
    make our development better. I also feel that part of our journey toward *infrastructure
    as code* is making our Puppet code just as well-designed, structured, and tested
    as any other application code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含一系列关于良好的模块和类设计的建议。请记住，Puppet 开发本质上就像任何其他类型的软件开发一样，我们通过多年的软件开发经验，特别是在 O&O
    软件公司，我们学到了一些模块化和类设计的原则，它们使我们的开发变得更好。我还认为，通向 *基础设施即代码* 的一部分是让我们的 Puppet 代码与其他应用程序代码一样设计良好、结构清晰且经过充分测试。
- en: Following the class-naming conventions
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遵循类命名约定
- en: 'There''s a certain class-naming convention that has developed over time within
    the Puppet community, and it''s really worth taking these into account when structuring
    your classes:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puppet 社区中，随着时间的推移，已经形成了一定的类命名约定，结构化类时考虑这些约定非常重要：
- en: '`init.pp`: `init.pp` contains the class named the same as the module, and is
    the main entry point for the module.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init.pp`：`init.pp` 包含与模块同名的类，是模块的主要入口点。'
- en: '`params.pp`: The `params.pp` pattern (more on this later in the chapter) is
    an elegant little hack, taking advantage of Puppet''s class inheritance behavior.
    Any of the other classes in the module inherit from the `params` class, so have
    their parameters set appropriately.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`params.pp`：`params.pp` 模式（稍后将在本章中详细介绍）是一个优雅的小技巧，利用了 Puppet 的类继承行为。模块中的其他任何类都会继承
    `params` 类，因此可以适当地设置它们的参数。'
- en: '`install.pp`: The resources related to installing the software should be placed
    in an `install` class. The install class must be named `<modulename>::install`
    and must be located in the `install.pp` file.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`install.pp`：与安装软件相关的资源应放在 `install` 类中。`install` 类必须命名为 `<modulename>::install`，并且必须位于
    `install.pp` 文件中。'
- en: '`config.pp`: The resources related to configuring the installed software should
    be placed in a `config` class. The `config` class must be named `<modulename>::config`
    and must be located in the `config.pp` file.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config.pp`：与配置已安装软件相关的资源应放在 `config` 类中。`config` 类必须命名为 `<modulename>::config`，并且必须位于
    `config.pp` 文件中。'
- en: '`service.pp`: The resources related to managing the service for the software
    should be placed in a `service` class. The service class must be named `<modulename>::service`
    and must be located in the `service.pp` file.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`service.pp`：与管理软件服务相关的资源应放在 `service` 类中。服务类必须命名为 `<modulename>::service`，并且必须位于
    `service.pp` 文件中。'
- en: 'For software that is configured in a client/server style, see the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于配置为客户端/服务器风格的软件，请参见以下内容：
- en: '`<modulename>::client::install` and `<modulename>::server::install` would be
    the class names for the `install.pp` file placed in the `client` and `server`
    directories accordingly'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<modulename>::client::install` 和 `<modulename>::server::install` 将是分别放置在 `client`
    和 `server` 目录中的 `install.pp` 文件的类名'
- en: '`<modulename>::client::config` and `<modulename>::server::install` would be
    the class names for the `config.pp` file placed in the `client` and `server` directories
    accordingly'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<modulename>::client::config` 和 `<modulename>::server::install` 将是分别放置在 `client`
    和 `server` 目录中的 `config.pp` 文件的类名'
- en: '`<modulename>::client::service` and `<modulename>::server::service` would be
    the class names for the `service.pp` files placed in the `client` and `server`
    directories accordingly'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<modulename>::client::service` 和 `<modulename>::server::service` 将是分别放置在 `client`
    和 `server` 目录中的 `service.pp` 文件的类名'
- en: Having a single point of entry to the module
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拥有一个单一的入口点来访问模块
- en: '`init.pp` should be the single entry point for the module. In this way, someone
    reviewing the documentation in particular, as well as the code in `init.pp`, can
    have a complete overview of the module''s behavior.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`init.pp` 应该是模块的唯一入口点。这样，尤其是审查文档的人，以及查看 `init.pp` 代码的人，都能对模块的行为有一个完整的概览。'
- en: If you've used encapsulation effectively and used descriptive class names, you
    can get a very good sense just by looking at `init.pp` of how the module actually
    manages the software.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有效地使用了封装并且使用了描述性的类名，那么仅通过查看 `init.pp` 你就可以很好地了解模块是如何实际管理软件的。
- en: Modules that have configurable parameters should be configurable in a single
    way and in this single place. The only exception to this would be, for example,
    a module such as the Apache module, where one or more virtual directories are
    also configurable.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 具有可配置参数的模块应该以单一方式并在此单一位置进行配置。唯一的例外是，例如，像 Apache 模块这样的模块，可能还需要配置一个或多个虚拟目录。
- en: 'Ideally, you can use your module with a simple include statement, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你可以通过一个简单的包含语句来使用你的模块，如下所示：
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can also use it with the use of a class declaration, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用类声明来使用它，如下所示：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The *Apache virtual directory* style of configuring a number of defined types
    would be the third way to use your new module:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*Apache 虚拟目录* 风格的配置方式将是使用你的新模块的第三种方式：'
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The anti-pattern to this recommendation would be to have a number of classes
    other than `init.pp` and your defined types with parameters expecting to be set.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与此建议相反的反模式是，除了 `init.pp` 和你的定义类型外，还存在其他类，且这些类的参数期望被设置。
- en: Using high cohesion and loose coupling principles
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用高内聚和低耦合原则
- en: As far as possible, Puppet modules should be made up of classes with a single
    responsibility. In software engineering, we call this high, functional cohesion.
    Cohesion in software engineering is the degree to which the elements of a certain
    module belong together. Try to make each class have a single responsibility, and
    don't arbitrarily mix together unrelated functionalities in your classes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能地，Puppet 模块应该由具有单一责任的类组成。在软件工程中，我们称之为高内聚性。软件工程中的内聚性是指一个模块的各个元素在多大程度上属于同一类别。尽量确保每个类只有一个责任，避免在类中随意混合不相关的功能。
- en: Using the encapsulation principle
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用封装原则
- en: As far as possible, these classes should use encapsulation to hide the implementation
    details from the user; for example, users of your module don't need to be aware
    of individual resource names. In software engineering, we call this encapsulation.
    For example, in a `config` class, we can use several resources, but the user doesn't
    need to know all about them. Rather, they just simply know that they should use
    the `config` class for the configuration of the software to work correctly.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能地，这些类应使用封装来隐藏实现细节，避免用户了解具体的资源名称。例如，你模块的用户无需了解个别资源的名称。在软件工程中，我们称之为封装。例如，在
    `config` 类中，我们可以使用多个资源，但用户不需要知道所有细节。相反，他们只需要知道应该使用 `config` 类来正确配置软件。
- en: Having classes contain other classes can be very useful, especially in larger
    modules where you want to improve code readability. You can move chunks of functionality
    into separate files, and then use the contain keyword to refer to these separated
    chunks of functionality.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将类包含在其他类中非常有用，尤其是在大型模块中，你希望提高代码的可读性。你可以将功能块移动到独立的文件中，然后使用 `contain` 关键字来引用这些分离的功能块。
- en: See [https://puppet.com/docs/puppet/5.3/lang_containment.html](https://puppet.com/docs/puppet/5.3/lang_containment.html) website
    for a reminder about the contain keyword.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 [https://puppet.com/docs/puppet/5.3/lang_containment.html](https://puppet.com/docs/puppet/5.3/lang_containment.html)
    网站，获取关于 `contain` 关键字的提醒。
- en: Providing sensible, well-thought-out parameter defaults
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供合理且经过深思熟虑的参数默认值
- en: If the vast majority of the people using your module will use the module with
    a certain parameter set, then of course it makes sense to set that parameter with
    a default.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果绝大多数使用你模块的人都将使用某个特定参数设置，那么当然有必要为该参数设置默认值。
- en: Carefully think through how your module is used, and put yourself in the position
    of a nonexpert user of your own module.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细考虑你的模块是如何使用的，并站在非专家用户的角度来审视自己的模块。
- en: Present the available module parameters in a sensible order, with more often
    accessed settings before least accessed settings, as opposed to some arbitrary
    order, such as alphabetical order.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 按照合理的顺序展示可用的模块参数，将常用的设置放在最前面，而不是随意的顺序（如字母顺序）。
- en: Strongly typing your module variables
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强烈类型化你的模块变量
- en: 'In versions of Puppet proper to the new language features which came out in
    version 4, we would create `class` parameters with undefined data types, and then,
    if we were being very nice, we would use the `stdlib validate_<datatype>` functions
    to check appropriate values for those variables:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puppet 的早期版本中（在版本 4 发布之前的版本），我们会创建没有定义数据类型的 `class` 参数，然后，如果我们非常友好的话，我们会使用
    `stdlib validate_<datatype>` 函数来检查这些变量的适当值：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Puppet 4 and 5 have an in-built way of defining the data type that a parameterized
    class accepts. See the following example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 4 和 5 内建了定义参数化类接受的数据类型的方法。请参阅以下示例：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using the new Puppet Development Kit commands
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用新的 Puppet 开发工具包命令
- en: Some features to improve quality in your Puppet development, such as `puppet-lint`,
    `puppet-rspec`, and commands such as `puppet module create` have been around for
    some time, but previously, you had to discover these tools out there in the wild,
    install them, and figure out how to use them effectively yourself.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一些可以提高 Puppet 开发质量的功能，例如 `puppet-lint`、`puppet-rspec` 和像 `puppet module create`
    这样的命令，已经存在了一段时间，但之前，你必须自己去发现这些工具，安装它们，并弄清楚如何有效地使用它们。
- en: Puppet decided back in August 2017 to bring these things all together on the
    client side and make them a breeze to use with the new Puppet Development Kit
    version 1.0\. I can certainly recall `puppet-rspec` always took some time to set
    up and get working correctly. Now it's all really easy.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 在 2017 年 8 月决定将这些工具整合到客户端，并通过新的 Puppet 开发工具包版本 1.0 使其变得易于使用。我清楚地记得，`puppet-rspec`
    总是需要一些时间来设置并使其正常工作。现在一切都变得非常简单。
- en: Let's take a whistle-stop tour of the module development process using the new
    PDK 1.0.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览一下使用新版本 PDK 1.0 的模块开发流程。
- en: '**Creating the module framework and metadata**: The `pdk new module`  command
    runs in the same way as the old `puppet module create` command, as follows:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建模块框架和元数据**：`pdk new module` 命令的运行方式与旧的 `puppet module create` 命令相同，具体如下：'
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Creating the** `init.pp`: There is now a set of creation commands for manifests
    inside modules, as follows:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建** `init.pp`：现在有一套创建模块内部清单的命令，具体如下：'
- en: '`pdk new class` ([https://puppet.com/docs/pdk/1.0/pdk_reference.html#pdk-new-class-command](https://puppet.com/docs/pdk/1.0/pdk_reference.html#pdk-new-class-command))'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pdk new class`（[https://puppet.com/docs/pdk/1.0/pdk_reference.html#pdk-new-class-command](https://puppet.com/docs/pdk/1.0/pdk_reference.html#pdk-new-class-command)）'
- en: '`pdk new defined_type` ([https://puppet.com/docs/pdk/1.0/pdk_reference.html#pdk-new-definedtype-command](https://puppet.com/docs/pdk/1.0/pdk_reference.html#pdk-new-definedtype-command))'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pdk new defined_type`（[https://puppet.com/docs/pdk/1.0/pdk_reference.html#pdk-new-definedtype-command](https://puppet.com/docs/pdk/1.0/pdk_reference.html#pdk-new-definedtype-command)）'
- en: '`pdk new task` ([https://puppet.com/docs/pdk/1.0/pdk_reference.html#pdk-new-task-command](https://puppet.com/docs/pdk/1.0/pdk_reference.html#pdk-new-task-command))—see
    [Chapter 6](0d435242-d7ac-4727-b632-71957c064919.xhtml), *Workflow*, for more
    details on the new Puppet task functionality.'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pdk new task`（[https://puppet.com/docs/pdk/1.0/pdk_reference.html#pdk-new-task-command](https://puppet.com/docs/pdk/1.0/pdk_reference.html#pdk-new-task-command)）——有关新
    Puppet 任务功能的更多详细信息，请参见[第 6 章](0d435242-d7ac-4727-b632-71957c064919.xhtml)，*工作流程*。'
- en: 'So, just use the name of the module to create `init.pp`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，只需使用模块的名称来创建 `init.pp`：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These commands now negate any need for snippets in your text editor to create
    the comments, declarations, and other boilerplate code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令现在可以完全避免在文本编辑器中使用片段来创建注释、声明和其他样板代码。
- en: '**Creating further classes**: Create any further classes using the same command.
    See the following example:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建更多类**：使用相同的命令创建任何更多的类。请参见以下示例：'
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Validating your module
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证您的模块
- en: 'As you are working, you can use the new `pdk validate` command ([https://puppet.com/docs/pdk/1.0/pdk_reference.html#pdk-validate-command](https://puppet.com/docs/pdk/1.0/pdk_reference.html#pdk-validate-command))
    to assist with checking that the module compiles, conforms to the Puppet Style
    Guide, and has valid metadata:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作过程中，您可以使用新的 `pdk validate` 命令（[https://puppet.com/docs/pdk/1.0/pdk_reference.html#pdk-validate-command](https://puppet.com/docs/pdk/1.0/pdk_reference.html#pdk-validate-command)）来帮助检查模块是否能编译、是否符合
    Puppet 风格指南，以及是否拥有有效的元数据：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Unit testing your module
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对您的模块进行单元测试
- en: The number one most important thing you can do to bring quality to your modules
    is to test them! Testing really is one of the most important aspects of software
    quality assurance in any field of software development. In the agile development
    community, we've been banging on the table about automated testing for more than
    10 years!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 提升模块质量的最重要的一件事就是对它们进行测试！测试确实是任何软件开发领域中软件质量保证的一个重要方面。在敏捷开发社区，我们已经对自动化测试坚持了超过
    10 年！
- en: Puppet RSpec ([http://rspec-puppet.com/tutorial](http://rspec-puppet.com/tutorial))
    has been allowing the Puppet community to unit test their modules for quite some
    time, but it's even easier now with the new PDK 1.0, as everything is set up ready,
    and you can just add your testing code and run the tests.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet RSpec（[http://rspec-puppet.com/tutorial](http://rspec-puppet.com/tutorial)）已经让
    Puppet 社区能够对其模块进行单元测试有一段时间了，但现在使用新版本 PDK 1.0 更加容易，因为所有设置都已准备好，您只需添加测试代码并运行测试。
- en: From a Puppet perspective, unit testing means *checking the output from the
    compiler*. Are the resources contained in the compiled relationship resource catalog,
    and is their order as expected, given the parameters passed and/or facts present?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Puppet 的角度来看，单元测试意味着 *检查编译器的输出*。编译后的关系资源目录中是否包含资源？它们的顺序是否符合预期，具体取决于传递的参数和/或存在的事实？
- en: When you begin to write tests in Puppet-RSpec, it seems at first like all you
    are doing is rewriting the Puppet manifests in another Ruby-like language. There
    is, however, really more to it than that. If there is some reasonable complexity
    to the module's functionality, for example, testing the dynamic content produced
    by Puppet templates, support for multiple operating systems, and different actions
    according to the passed parameters, then these tests actually form a safety net
    when editing or adding new functionality to your modules, protecting against regressions
    when refactoring, or upgrading to a new Puppet release.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始在 Puppet-RSpec 中编写测试时，最初看似你只是在用另一种类似 Ruby 的语言重写 Puppet 清单。然而，实际上远不止如此。如果模块的功能具有一定复杂性，例如测试
    Puppet 模板生成的动态内容，支持多个操作系统，或根据传入的参数执行不同的操作，那么这些测试实际上形成了一张安全网，在编辑或添加新功能时可以防止回归，或者在重构或升级到新版本的
    Puppet 时提供保护。
- en: 'Let''s carry on from the previous two sections and use the development kit
    to unit test our module. Whenever you generate a class using the `pdk new class`
    command, PDK creates a corresponding unit test file. This file, located in your
    module''s `/spec/classes` folder, already includes a template for writing your
    unit tests (see [http://rspec-puppet.com/tutorial](http://rspec-puppet.com/tutorial)).
    You can then run the tests using the following command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前两个部分，并使用开发工具包对我们的模块进行单元测试。每当你使用`pdk new class`命令生成一个类时，PDK 会创建一个对应的单元测试文件。这个文件位于模块的`/spec/classes`文件夹中，已经包含了编写单元测试的模板（参见
    [http://rspec-puppet.com/tutorial](http://rspec-puppet.com/tutorial)）。你可以使用以下命令运行测试：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Staying on the lookout for code smells
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注意代码异味
- en: 'Be on the lookout for code smells, especially as your Puppet code base ages!
    The following link is a research project that describes a bunch of Puppet *code
    smells*, which is an XP (extreme programming) term meaning code issues—usually
    meaning either a poor design or implementation: [http://www.tusharma.in/wp-content/uploads/2016/03/ConfigurationSmells_preprint.pdf](http://www.tusharma.in/wp-content/uploads/2016/03/ConfigurationSmells_preprint.pdf)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 Puppet 代码库逐渐增大时，要特别注意代码异味！以下链接是一个研究项目，描述了一些 Puppet *代码异味*，这是一种极限编程（XP）术语，指的是代码问题——通常意味着设计或实现不佳：[http://www.tusharma.in/wp-content/uploads/2016/03/ConfigurationSmells_preprint.pdf](http://www.tusharma.in/wp-content/uploads/2016/03/ConfigurationSmells_preprint.pdf)
- en: 'Let''s quickly run through using the `Puppeteer` Python-based tool used in
    the preceding research project:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下如何使用前面研究项目中使用的基于 Python 的`Puppeteer`工具：
- en: Ensure you have the latest Java SDK installed.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你已经安装了最新的 Java SDK。
- en: 'Move to your `workspace` directory `~/workspace`, and clone the following Git
    repository:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入你的`workspace`目录`~/workspace`，并克隆以下 Git 仓库：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Download the PMD tool ([https://github.com/pmd/pmd](https://github.com/pmd/pmd)
    ) and update the path in the shell script. PMD is an extensible static code analyzer
    with **copy-paste-detector** (**CPD**) built-in.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 PMD 工具（[https://github.com/pmd/pmd](https://github.com/pmd/pmd)），并在 shell
    脚本中更新路径。PMD 是一个可扩展的静态代码分析器，内置 **复制粘贴检测器**（**CPD**）。
- en: Update the folder path where all the Puppet repositories are placed.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新所有 Puppet 仓库存放的文件夹路径。
- en: Execute the `cpdRunner.sh` shell script to carry out clone detection using the
    PMD-CPD tool.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`cpdRunner.sh` shell 脚本，使用 PMD-CPD 工具进行克隆检测。
- en: Update the `REPO_ROOT` constant in `SmellDetector/Constants.py`, which represents
    the folder path where all the Puppet repositories are placed.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`SmellDetector/Constants.py`中的`REPO_ROOT`常量，它表示存放所有 Puppet 仓库的文件夹路径。
- en: Execute `Puppeteer.py`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`Puppeteer.py`。
- en: Analyze Puppet repository with `puppet-lint` (optional).
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`puppet-lint`分析 Puppet 仓库（可选）。
- en: Execute `puppet-lintRunner.py` after setting the repository root.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置好仓库根目录后，执行`puppet-lintRunner.py`。
- en: Set the repository root in `Puppet-lint_aggregator/PLConstants.py`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Puppet-lint_aggregator/PLConstants.py`中设置仓库根目录。
- en: Execute `PuppetLintRules.py`, it will generate a consolidated summary of the
    analysis for all the analyzed projects.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`PuppetLintRules.py`，它将生成所有分析项目的汇总总结。
- en: Working with dead code
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理死代码
- en: Another issue that can often hit you as your Puppet code base ages is unused
    code in your codebase. But, there's a tool out there in the wild we can use to
    keep on top of this issue.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见问题是，随着 Puppet 代码库的增长，代码中可能存在未使用的代码。但幸运的是，我们可以使用一个工具来解决这个问题。
- en: '`puppet-ghostbuster` essentially compares what is actually being used (stored
    in PuppetDB) to what you think you are using (in your code base directory). This
    give you the opportunity to slash and burn anything that''s really unused. This
    is great from the point of view of software maintainability. A smaller code base
    is simply cheaper to maintain!'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`puppet-ghostbuster` 实质上将实际使用的内容（存储在 PuppetDB 中）与您认为正在使用的内容（在您的代码库目录中）进行比较。这给了您一个机会，删除和清理那些真正未使用的内容。从软件可维护性的角度来看，这是非常有益的。较小的代码库显然更便宜、更容易维护！'
- en: Let's quickly run through using this Ruby gem.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速了解如何使用这个 Ruby gem。
- en: 'Make the following settings in your environment variables:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的环境变量中进行以下设置：
- en: '`HIERA_YAML_PATH`: The location of the `hiera.yaml` file. It defaults to `/etc/puppetlabs/code/hiera.yaml`.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HIERA_YAML_PATH`：`hiera.yaml` 文件的位置。默认值为`/etc/puppetlabs/code/hiera.yaml`。'
- en: '`PUPPETDB_URL`: The URL or the PuppetDB. It defaults to `http://puppetdb:8080`.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUPPETDB_URL`：PuppetDB 的 URL。默认值为 `http://puppetdb:8080`。'
- en: '`PUPPETDB_CACERT_FILE`: Your site''s CA certificate.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUPPETDB_CACERT_FILE`：您站点的 CA 证书。'
- en: '`PUPPETDB_CERT_FILE`: A SSL certificate signed by your site''s Puppet CA.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUPPETDB_CERT_FILE`：由您站点的 Puppet CA 签名的 SSL 证书。'
- en: '`PUPPETDB_KEY_FILE`: The private key for that certificate.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUPPETDB_KEY_FILE`：该证书的私钥。'
- en: 'Run the command as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式运行命令：
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can add to and remove from the comma-delimited items to check for unused
    classes, defined types, facts, files, functions, Hiera files, templates, and types.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向逗号分隔的项中添加或删除内容，以检查未使用的类、定义的类型、事实、文件、函数、Hiera 文件、模板和类型。
- en: Using Puppet Forge
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Puppet Forge
- en: It maybe goes without saying that there's no reason to reinvent the wheel when
    you are authoring your Puppet modules. A few minutes in Puppet Forge ([https://forge.puppet.com](https://forge.puppet.com/))
    can really save you days and days of editing. There are, at the time of writing,
    more than 5,000 Forge modules, so it makes a great deal of sense to leverage all
    that hard work done by the Puppet community. Search the Forge first for that bit
    of software; it's more than likely that something already exists.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 也许不言而喻，当你编写 Puppet 模块时，完全没有必要重新发明轮子。在 Puppet Forge 上花几分钟时间（[https://forge.puppet.com](https://forge.puppet.com/)）真的可以为你节省几天的编辑工作。到目前为止，Forge
    上已经有超过 5000 个模块，因此充分利用 Puppet 社区所做的所有辛勤工作是非常有意义的。首先在 Forge 上搜索该软件，很可能已经存在类似的模块。
- en: In my experience, I have found there is often something that *almost* does the
    job. Maybe there's a module (usually an unsupported and unapproved one) that maybe,
    for example, performs the management for the software you require, but it's only
    for Ubuntu, and you're using Red Hat. It's usually a better approach to fork that
    module, whatever shape it's in, and work on that, rather than start from scratch.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，我发现通常总有一些*几乎*能够完成任务的东西。可能有一个模块（通常是一个不受支持且未经批准的模块），也许它能够执行你所需要的软件管理，但它只适用于
    Ubuntu，而你正在使用的是 Red Hat。通常来说，更好的做法是对该模块进行分叉，不管它的状态如何，然后在此基础上进行修改，而不是从头开始。
- en: Working with the community
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与社区合作
- en: The best way for me to describe this best practice is to use an anti-pattern
    as an example.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我最好的描述这个最佳实践的方法是用反模式作为例子。
- en: I once came across a Puppet developer who would start a module completely from
    scratch, and then copy and paste lines of code from a Forge module into the new
    module. From then on, that module exists entirely outside the community! It's
    not a fork even, so to integrate changes that have been made over time from the
    community becomes a real pain. You would have to cherry-pick those changes to
    get the functionality into your own, and you will probably still be left with
    regression problems. Generally, a best practice is to always at the very least
    fork the Forge module! This means you get the Git history, which often contains
    the thoughts that have gone into producing that module.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾遇到一个 Puppet 开发者，他会从头开始编写模块，然后将 Forge 模块中的代码行复制并粘贴到新模块中。从那时起，该模块完全存在于社区之外！它甚至不是一个分叉，因此将时间积累下来的社区更改集成进来变得非常麻烦。你必须挑选这些更改，以将功能集成到自己的模块中，而且你可能仍然会遇到回归问题。通常，最佳实践是至少要分叉
    Forge 模块！这样你就能获得 Git 历史记录，通常这些记录包含了在制作该模块过程中所付出的思考和努力。
- en: 'You see, if you were ever a reader of the great book *The Cathedral & the Bazaar:
    Musings on Linux and Open Source by an Accidental Revolutionary* ([https://www.amazon.com/Cathedral-Bazaar-Musings-Accidental-Revolutionary/dp/0596001088](https://www.amazon.com/Cathedral-Bazaar-Musings-Accidental-Revolutionary/dp/0596001088)),
    then you will understand that the Linux-orientated philosophy of software development
    through a *bazaar*, collaborative working style trumps spinning off development
    into a cathedral, independent working style. Well, that''s my take on this developer''s
    working style. He was working cathedral-ly, as opposed to bazaar-ly. Effectively,
    you are making the decision to pit your cathedral team against the multitude of
    the bazaar, and to my mind, that''s simply not wise project management when it
    comes to giving you a competitive advantage in the internet age.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你看，如果你曾经读过那本伟大的书《教堂与集市：一位偶然革命者的Linux与开源思考》（[https://www.amazon.com/Cathedral-Bazaar-Musings-Accidental-Revolutionary/dp/0596001088](https://www.amazon.com/Cathedral-Bazaar-Musings-Accidental-Revolutionary/dp/0596001088)），你就会明白，Linux导向的软件开发哲学通过一个*集市*，协作的工作方式，超越了将开发工作分割成一个教堂式的独立工作方式。好吧，这是我对这个开发者工作风格的看法。他是在教堂式工作，而不是集市式工作。实际上，你是在做出决定，把你的教堂团队与集市中的大量人员对抗，在我看来，这在互联网时代，作为项目管理并没有给你带来竞争优势，是不明智的。
- en: Sometimes, modules on the Forge get a bit out of date. If the metadata for the
    module is out of date, you can always produce that again using the PDK `new module`
    command ([https://puppet.com/docs/pdk/1.0/pdk_generating_modules.html#create-a-module-with-pdk](https://puppet.com/docs/pdk/1.0/pdk_generating_modules.html))
    and commit the new metadata.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，Forge上的模块会有些过时。如果模块的元数据过时了，你可以通过使用PDK的`new module`命令 ([https://puppet.com/docs/pdk/1.0/pdk_generating_modules.html#create-a-module-with-pdk](https://puppet.com/docs/pdk/1.0/pdk_generating_modules.html))
    来重新生成，并提交新的元数据。
- en: Of course, to be a great Puppet community member, it would be an even better
    practice to make pull requests for the changes you have made and contribute to
    the work of the community.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，作为一个优秀的Puppet社区成员，做出的更好实践是将你所做的更改提交为pull请求，并为社区的工作做出贡献。
- en: Writing great documentation
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 撰写优秀文档
- en: Another important recommendation is to simply write great documentation. There's
    nothing worse, I feel, as a developer, than to have to dig into the code to understand
    how a module works; it's like having to lift the hood of the car to understand
    how to drive a vehicle!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的建议是：简单地写出优秀的文档。作为开发者，我认为没有什么比需要深入代码才能理解一个模块如何工作更糟糕了；这就像必须掀开汽车引擎盖来理解如何驾驶汽车一样！
- en: Get good at writing English to convey technical ideas! I really think it's a
    skill that every good developer really needs to master.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 提高用英语表达技术思想的能力！我真的认为这是每个优秀开发者必须掌握的技能。
- en: Grabbing yourself a Markdown editor
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取一个Markdown编辑器
- en: Puppet modules use markdown for their documentation formatting. So it makes
    sense to use either a standalone Markdown editor, or some plugins for your IDE,
    so that you can create your quality documentation appropriately. Following on
    from our selection of code IDEs that we considered earlier in the chapter, the
    corresponding markdown plugins follow.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet模块使用markdown格式来编写文档。因此，使用独立的Markdown编辑器或一些IDE插件是有意义的，这样你就可以恰当地创建高质量的文档。接下来是我们在本章中考虑过的代码IDE的选择，随之而来的对应markdown插件如下。
- en: Vim
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vim
- en: You can use the vim-instant-markdown plugin ([https://github.com/suan/vim-instant-markdown](https://github.com/suan/vim-instant-markdown))
    if you're a vim fan.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是vim粉丝，可以使用vim-instant-markdown插件 ([https://github.com/suan/vim-instant-markdown](https://github.com/suan/vim-instant-markdown))。
- en: TextMate
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TextMate
- en: You can use the TextMate markdown bundle ([https://github.com/textmate/markdown.tmbundle](https://github.com/textmate/markdown.tmbundle))
    if you enjoy the Apple look and feel of TextMate.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢TextMate的苹果风格，可以使用TextMate markdown包 ([https://github.com/textmate/markdown.tmbundle](https://github.com/textmate/markdown.tmbundle))。
- en: Atom
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Atom
- en: If, like me, you enjoy using Atom, you can use the Markdown Preview Plus package ([https://atom.io/packages/markdown-preview-plus](https://atom.io/packages/markdown-preview-plus)).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果像我一样，你喜欢使用Atom，你可以使用Markdown Preview Plus包 ([https://atom.io/packages/markdown-preview-plus](https://atom.io/packages/markdown-preview-plus))。
- en: Visual Studio
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio
- en: If you're a developer in the Windows and .NET world, then look no further than
    the Markdown editor extension ([https://marketplace.visualstudio.com/items?itemName=MadsKristensen.MarkdownEditor](https://marketplace.visualstudio.com/items?itemName=MadsKristensen.MarkdownEditor)).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是 Windows 和 .NET 世界的开发者，那么不妨试试 Markdown 编辑器扩展（[https://marketplace.visualstudio.com/items?itemName=MadsKristensen.MarkdownEditor](https://marketplace.visualstudio.com/items?itemName=MadsKristensen.MarkdownEditor)）。
- en: Standalone Markdown editors
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 独立的 Markdown 编辑器
- en: If you would rather use a standalone Markdown editor, I can recommend personally
    MacDown for macOS X. My (very) short list of standalone Markdown editors for various
    operating systems follows.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢使用独立的 Markdown 编辑器，我个人推荐 macOS X 上的 MacDown。以下是我为各种操作系统列出的独立 Markdown
    编辑器的（非常）简短列表。
- en: Remarkable
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Remarkable
- en: If you're using Linux, then Remarkable is probably the best standalone editor.
    It also works on Windows. Some of its features include live preview, exporting
    to PDF and HTML, GitHub markdown, custom CSS, syntax highlighting, and keyboard
    shortcuts.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Linux，Remarkable 可能是最好的独立编辑器。它也支持 Windows。它的一些功能包括实时预览、导出为 PDF 和 HTML、GitHub
    Markdown、定制 CSS、语法高亮和快捷键。
- en: MacDown
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MacDown
- en: If you would rather use a standalone Markdown editor, I can recommend MacDown
    for macOS X, which is free (open source). It's heavily inspired by Mou, and is
    designed with web developers in mind. It has configurable syntax highlighting,
    live preview, and auto-completion. If you're looking for a lean, fast, configurable
    standalone Markdown editor, this might be the one for you.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢使用独立的 Markdown 编辑器，我可以推荐 MacDown for macOS X，它是免费的（开源）。它深受 Mou 启发，并且专为
    web 开发者设计。它具有可配置的语法高亮、实时预览和自动补全功能。如果你正在寻找一个精简、快速、可配置的独立 Markdown 编辑器，这可能是适合你的选择。
- en: Adding module dependencies
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加模块依赖
- en: 'Edit the module''s `metadata.json` file to add module dependencies. See the
    following example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑模块的 `metadata.json` 文件以添加模块依赖。请参见以下示例：
- en: '[PRE14]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `name` key is the name of the requirement, namely, `"pe"` or `"puppet"`.
    The `version_requirement` key is a semver ([http://semver.org](http://semver.org))
    value or range. See the following examples:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`name` 键是需求的名称，即 `"pe"` 或 `"puppet"`。`version_requirement` 键是 semver（[http://semver.org](http://semver.org)）值或范围。参见以下示例：'
- en: '`1.18.0`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1.18.0`'
- en: '`1.18.x`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1.18.x`'
- en: '`>= 1.18.x`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>= 1.18.x`'
- en: '`>=1.18.x <2.x.x`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>=1.18.x <2.x.x`'
- en: These would all be valid values for `version_requirement`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是有效的 `version_requirement` 值。
- en: 'Check the `metadata.json` file for validity afterwards using the new PDK command,
    as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，请使用新的 PDK 命令检查 `metadata.json` 文件的有效性，命令如下：
- en: '[PRE15]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The great thing about adding module dependencies is the fact that, when you
    run the `puppet module download` command, Puppet will download all the module
    dependencies accordingly.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 添加模块依赖的好处是，当你运行 `puppet module download` 命令时，Puppet 会相应地下载所有模块依赖。
- en: Adding compatibility data for your modules
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为你的模块添加兼容性数据
- en: This section introduces you to adding compatibility data for the module designed
    for your version of Puppet or Puppet Enterprise and the operating system you want
    to work with. To begin with, Edit the module's `metadata.json` file to add compatibility
    data.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了如何为适用于你所使用版本的 Puppet 或 Puppet Enterprise 及操作系统的模块添加兼容性数据。首先，编辑模块的 `metadata.json`
    文件以添加兼容性数据。
- en: Operating systems support
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作系统支持
- en: 'Express the operating systems your module supports in the module''s `metadata.json`,
    as shown in the following example:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块的 `metadata.json` 中表达该模块支持的操作系统，示例如下：
- en: '[PRE16]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The Facter facts `operatingsystem` and `operatingsystemrelease` are expected.
    Here''s a more complete example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 预期会有 Facter facts `operatingsystem` 和 `operatingsystemrelease`。以下是一个更完整的示例：
- en: '[PRE17]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Check the `metadata.json` file for validity afterwards using the new `pdk`
    command:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，请使用新的 `pdk` 命令检查 `metadata.json` 文件的有效性：
- en: '[PRE18]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Puppet and PE version support
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Puppet 和 PE 版本支持
- en: 'The `requirements` key in the `metadata.json` file is a list of external requirements
    for the module in the following format:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`metadata.json` 文件中的 `requirements` 键是一个外部需求的列表，格式如下：'
- en: '[PRE19]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`name` is the name of the requirement, for example `"pe"` or `"puppet"`. `version_requirement`
    can be a semver ([http://semver.org](http://semver.org)) version range, similar
    to dependencies.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`name` 是需求的名称，例如 `"pe"` 或 `"puppet"`。`version_requirement` 可以是一个 semver（[http://semver.org](http://semver.org)）版本范围，类似于依赖项。'
- en: 'Again, you can check the `metadata.json` file for validity afterwards using
    the new PDK command, as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以使用新的 PDK 命令检查 `metadata.json` 文件的有效性，命令如下：
- en: '[PRE20]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Using the new Hiera 5 module level data
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用新的 Hiera 5 模块级数据
- en: 'For quite some time when module writing, we''ve been using the `params.pp`
    pattern. One class in the module, by convention called `<MODULENAME>::params`,
    sets the variables for any of the other classes:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块编写过程中，我们已经使用了相当长一段时间的`params.pp`模式。模块中的一个类，按照惯例被称为`<MODULENAME>::params`，为其他任何类设置变量：
- en: '[PRE21]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: So, you can see here that we are using some conditional logic depending on the
    `os::family` fact, so that the `service_name` variable can be set appropriately.
    We are also exposing the `autoupdate` variable, and giving it a default value.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们在这里使用了一些条件逻辑，这取决于`os::family`事实，从而可以适当地设置`service_name`变量。我们还暴露了`autoupdate`变量，并给它设置了默认值。
- en: 'This `params.pp` pattern is an elegant little hack, which takes advantage of
    Puppet''s idiosyncratic class inheritance behavior (using inheritance is generally
    not recommended in Puppet). Then, any of the other classes in the module inherit
    from the `params` class, to have their parameters set appropriately, as shown
    in the following example:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`params.pp`模式是一个优雅的小技巧，它利用了Puppet特有的类继承行为（在Puppet中通常不建议使用继承）。然后，模块中的任何其他类都继承自`params`类，以适当地设置它们的参数，如下例所示：
- en: '[PRE22]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since the release of Hiera 5, we are able to simplify our module complexity
    considerably. By using Hiera-based defaults, we can simplify our module's main
    classes, and they no longer need to inherit from `params.pp`. Additionally, you
    no longer need to explicitly set a default value with the `=` operator in the
    parameter declaration.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Hiera 5发布以来，我们能够大大简化模块的复杂性。通过使用基于Hiera的默认值，我们可以简化模块的主类，它们不再需要继承自`params.pp`。此外，你也不再需要在参数声明中显式地使用`=`运算符设置默认值。
- en: Let's look at the equivalent configuration to the `params.pp` pattern using
    Hiera 5.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下使用Hiera 5与`params.pp`模式等效的配置。
- en: 'First of all, in order to use this new functionality, the `data_provider` key
    needs to be set to the `heira` value in the module''s `metadata.json` file:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了使用这个新功能，需要在模块的`metadata.json`文件中将`data_provider`键设置为`heira`值：
- en: '[PRE23]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we need to add a `hiera.yaml` file to the root directory of the module:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将`hiera.yaml`文件添加到模块的根目录：
- en: '[PRE24]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can then add three files to the `/data` directory (note that the `datadir`
    setting in the `hiera.yaml` file). The first file of these three is used to set
    the AIX `service_name` variable:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将三个文件添加到`/data`目录中（请注意`hiera.yaml`文件中的`datadir`设置）。这三者中的第一个文件用于设置AIX的`service_name`变量：
- en: '[PRE25]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The second file is used to set the Debian `service_name` variable:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个文件用于设置Debian的`service_name`变量：
- en: '[PRE26]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And finally, there is the common file, and Hiera will fall through to this
    file to find its values if it doesn''t find a corresponding operating system file
    when looking for the `service_name` setting, or a value for `autoupdate` when
    searching the previous two files:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是公共文件，如果Hiera在查找`service_name`设置或`autoupdate`值时没有找到对应的操作系统文件，它会退回到此文件来查找其值：
- en: '[PRE27]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We will look at Hiera 5 in much more detail in [Chapter 4](cea19359-3ab3-4ee7-99d5-be2e4cd1f992.xhtml),
    *Hiera 5*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第4章](cea19359-3ab3-4ee7-99d5-be2e4cd1f992.xhtml)中更加详细地探讨Hiera 5，*Hiera
    5*。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have covered a lot of ground, and I've introduced a bunch
    of best practices you can use to produce better quality component modules.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了很多内容，我介绍了一些最佳实践，你可以利用它们来编写更高质量的组件模块。
- en: 'In the next chapter, we''ll still be covering development in Puppet DSL, and
    turn our attention to two special modules: role and profile, which can help us
    to build reusable, configurable, and refactorable site-wide configuration code.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们仍然会讨论Puppet DSL的开发，并将注意力转向两个特殊模块：角色和配置文件，它们可以帮助我们构建可重用、可配置、可重构的全站配置代码。
