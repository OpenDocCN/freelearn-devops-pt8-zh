- en: Chapter 2. Provisioning IaaS with Terraform
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 使用Terraform提供IaaS
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下教程：
- en: Configuring the Terraform AWS provider
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Terraform AWS提供商
- en: Creating and using an SSH key pair to use on AWS
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用一个SSH密钥对用于AWS
- en: Using AWS security groups with Terraform
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Terraform管理AWS安全组
- en: Creating an Ubuntu EC2 instance with Terraform
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Terraform创建一个Ubuntu EC2实例
- en: Generating meaningful outputs with Terraform
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Terraform生成有意义的输出
- en: Using contextual defaults with Terraform
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Terraform的上下文默认值
- en: Managing S3 storage with Terraform
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Terraform管理S3存储
- en: Creating private Docker repositories with Terraform
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Terraform创建私有Docker仓库
- en: Creating a PostgreSQL RDS database with Terraform
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Terraform创建一个PostgreSQL RDS数据库
- en: Enabling CloudWatch Logs for Docker with Terraform
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Terraform启用Docker的CloudWatch日志
- en: Managing IAM users with Terraform
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Terraform管理IAM用户
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: A modern infrastructure often uses multiple providers **Amazon Web Services**
    (**AWS**), OpenStack, Google Cloud, Digital Ocean, and many others), combined
    with multiple external services (DNS, mail, monitoring, and others). Many providers
    propose their own automation tool, but the power of Terraform is that it allows
    you to manage it all from one place, all using code. With it, you can dynamically
    create machines at two IaaS providers depending on the environment, register their
    names at another DNS provider, enable monitoring at a third-party monitoring company,
    while configuring the company GitHub account and sending the application logs
    to an appropriate service. On top of that, it can delegate configuration to those
    who do it well (configuration management tools such as Chef, Puppet, and so on),
    all with the same tool. The state of your infrastructure is described, stored,
    versioned, and shared.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现代基础设施通常使用多个提供商（**Amazon Web Services**（**AWS**）、OpenStack、Google Cloud、Digital
    Ocean等），并结合多个外部服务（DNS、邮件、监控等）。许多提供商提出了他们自己的自动化工具，但Terraform的优势在于它允许你从一个地方管理所有内容，全部使用代码。使用它，你可以根据环境动态创建两个IaaS提供商上的机器，在另一个DNS提供商处注册它们的名称，在第三方监控公司启用监控，同时配置公司GitHub帐户并将应用日志发送到适当的服务。此外，它还可以将配置委托给那些擅长此事的工具（如Chef、Puppet等），一切都能用同一个工具完成。你的基础设施状态被描述、存储、版本化并共享。
- en: In this chapter, we'll discover how to use Terraform to bootstrap a fully capable
    infrastructure on AWS. You'll know everything from launching fine-tuned EC2 instances
    and optimized RDS databases dynamically in different regions, to creating tight
    security groups, deploying SSH key pairs and securing IAM access keys, enabling
    log storage with CloudWatch, generating useful outputs, handling infinite **Simple
    Storage Service** (**S3**) storage, and using private Docker repositories.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用Terraform在AWS上引导一个完整的基础设施。你将学习如何从启动精细调优的EC2实例和在不同区域动态优化RDS数据库，到创建紧密的安全组、部署SSH密钥对和保护IAM访问密钥、启用CloudWatch日志存储、生成有用的输出、处理无限的**简单存储服务**（**S3**）存储以及使用私有Docker仓库。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Terraform version in use for this book is 0.7.2.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用的Terraform版本是0.7.2。
- en: Configuring the Terraform AWS provider
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Terraform AWS提供商
- en: We can use Terraform with many IaaS providers, such as Google Cloud or Digital
    Ocean. Here, we'll configure Terraform to be used with AWS and stick with this
    provider for the rest of the chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以与许多IaaS提供商一起使用Terraform，例如Google Cloud或Digital Ocean。在这里，我们将配置Terraform以便与AWS一起使用，并在本章的其余部分继续使用该提供商。
- en: For Terraform to interact with an IaaS, it needs to have a *provider* configured.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Terraform与IaaS交互，它需要配置一个*提供商*。
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行这个教程，你需要以下内容：
- en: An AWS account with keys
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有密钥的AWS账户
- en: A working Terraform installation
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个工作中的Terraform安装
- en: An empty directory to store your infrastructure code
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个空目录来存储你的基础设施代码
- en: An Internet connection
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个互联网连接
- en: How to do it…
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'To configure the AWS provider in Terraform, we''ll need the following three
    files:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Terraform中配置AWS提供商，我们需要以下三个文件：
- en: A file declaring our variables, an optional description, and an optional default
    for each (`variables.tf`)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个声明我们变量的文件，一个可选的描述，以及每个变量的可选默认值（`variables.tf`）
- en: A file setting the variables for the whole project (`terraform.tfvars`)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个为整个项目设置变量的文件（`terraform.tfvars`）
- en: A provider file (`provider.tf`)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个提供商文件（`provider.tf`）
- en: 'Lets declare our variables in the `variables.tf` file. We can start by declaring
    what''s usually known as the `AWS_DEFAULT_REGION`, `AWS_ACCESS_KEY_ID`, and `AWS_SECRET_ACCESS_KEY`
    environment variables:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `variables.tf` 文件中声明我们的变量。我们可以从声明通常称为 `AWS_DEFAULT_REGION`、`AWS_ACCESS_KEY_ID`
    和 `AWS_SECRET_ACCESS_KEY` 的环境变量开始：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Set the two variables matching the AWS account in the `terraform.tfvars` file.
    It''s not recommended to check this file into source control: it''s better to
    use an example file instead (that is: `terraform.tfvars.example`). It''s also
    recommended to use a dedicated Terraform user for AWS, not the root account keys:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `terraform.tfvars` 文件中设置与 AWS 账户匹配的两个变量。不建议将此文件提交到源代码管理中：最好使用示例文件（即：`terraform.tfvars.example`）。同时，建议为
    AWS 使用专门的 Terraform 用户，而不是 root 账户的密钥：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let''s tie all this together into a single file, `provider.tf`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把所有这些整合到一个文件中，即 `provider.tf`：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Apply the following Terraform code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 应用以下 Terraform 代码：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It only means the code is valid, not that it can really authenticate with AWS
    (try with a bad pair of keys). For this, we'll need to create a resource on AWS.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅意味着代码有效，而不意味着它能真正与 AWS 进行身份验证（尝试使用一对无效的密钥）。为此，我们需要在 AWS 上创建一个资源。
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You now have a new file named `terraform.tfstate` that has been created at
    the root of your repository. This file is critical: it''s the stored state of
    your infrastructure. Don''t hesitate to look at it, it''s a text file.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一个名为 `terraform.tfstate` 的新文件，它已经在你的仓库根目录下创建。这个文件非常关键：它是你基础设施的存储状态。不要犹豫去查看它，它是一个文本文件。
- en: How it works…
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'This first encounter with **HashiCorp Configuration Language** (**HCL**), the
    language used by Terraform, and other Hashicorp products looks pretty familiar:
    it''s a structured language fully compatible with JSON. We can find more information
    about HCL here: [https://github.com/hashicorp/hcl](https://github.com/hashicorp/hcl).
    In this case, we''ve declared variables with an optional description for reference.
    We could have declared them simply with the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一次接触**HashiCorp 配置语言**（**HCL**），这是 Terraform 以及其他 HashiCorp 产品使用的语言，看起来相当熟悉：它是与
    JSON 完全兼容的结构化语言。我们可以在这里找到关于 HCL 的更多信息：[https://github.com/hashicorp/hcl](https://github.com/hashicorp/hcl)。在这个例子中，我们声明了变量，并为参考提供了可选的描述。我们也可以简单地用以下方式声明它们：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'All variables are referenced to use the following structure:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所有变量都参考以下结构：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If the variable has been declared with a default, as our `aws_region` has been
    declared with a default of `eu-west-1`; this value will be used if there's no
    override in the `terraform.tfvars` file.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量已经声明了默认值，就像我们的 `aws_region` 声明了 `eu-west-1` 的默认值；如果在 `terraform.tfvars`
    文件中没有覆盖该值，它将会使用这个默认值。
- en: 'What would have happened if we didn''t provide a safe default for our variable?
    Terraform would have asked us for a value when executed:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有为变量提供安全的默认值，会发生什么情况？ Terraform 在执行时会要求我们输入一个值：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There's more…
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'We''ve used values directly inside the Terraform code to configure our AWS
    credentials. If you''re already using AWS on the command line, chances are you
    already have a set of standard environment variables:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们直接在 Terraform 代码中使用了值来配置我们的 AWS 凭证。如果你已经在命令行中使用 AWS，很可能你已经有一组标准的环境变量：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If not, you can simply set them as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，你可以按以下方式简单设置它们：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Then Terraform can use them directly, and the only code you have to type would
    be to declare your provider! That's handy when working with different tools.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 Terraform 可以直接使用它们，你唯一需要输入的代码就是声明你的提供者！当使用不同工具时，这非常方便。
- en: 'The `provider.tf` will then look as simple as this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`provider.tf` 文件看起来就会像这样简单：'
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Creating and using an SSH key pair to use on AWS
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建并使用一对 SSH 密钥以在 AWS 上使用
- en: Now we have our AWS provider configured in Terraform, let's add a SSH key pair
    to use on a default account of the virtual machines we intend to launch soon.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在 Terraform 中配置了 AWS 提供者，接下来让我们为即将启动的虚拟机的默认账户添加一对 SSH 密钥。
- en: Getting ready
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To step through this recipe, you will need the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随这个步骤，你将需要以下内容：
- en: A working Terraform installation
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可工作的 Terraform 安装
- en: An AWS provider configured in Terraform
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已在 Terraform 中配置的 AWS 提供者
- en: 'Generate a pair of SSH keys somewhere you remember, for example, in the `keys`
    folder at the root of your repo:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你能记住的地方生成一对 SSH 密钥，例如，在你的仓库根目录下的 `keys` 文件夹中：
- en: '[PRE10]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: An Internet connection
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要一个互联网连接
- en: How to do it…
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The resource we want for this is named `aws_key_pair`. Let''s use it inside
    a `keys.tf` file, and paste the public key content:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要的资源名为 `aws_key_pair`。让我们在 `keys.tf` 文件中使用它，并粘贴公钥内容：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will simply upload your public key to your AWS account under the name
    `admin_key`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这将简单地将你的公钥上传到你的 AWS 账户，名为 `admin_key`：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you manually navigate to your AWS account, in **EC2** | **Network & Security**
    | **Key Pairs**, you''ll now find your key:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你手动访问你的 AWS 账户，在 **EC2** | **网络与安全** | **密钥对** 中，你现在应该能找到你的密钥：
- en: '![How to do it…](img/B05671_02_01.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作……](img/B05671_02_01.jpg)'
- en: Another way to use our key with Terraform and AWS would be to read it directly
    from the file, and that would show us how to use file interpolation with Terraform.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种使用我们的密钥与 Terraform 和 AWS 的方法是直接从文件中读取，这将展示如何在 Terraform 中使用文件插值。
- en: 'To do this, let''s declare a new empty variable to store our public key in
    `variables.tf`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，让我们在 `variables.tf` 中声明一个新的空变量来存储我们的公钥：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Initialize the variable to the path of the key in `terraform.tfvars`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `terraform.tfvars` 中初始化变量，指定密钥的路径：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now let''s use it in place of our previous `keys.tf` code, using the `file()`
    interpolation:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用 `file()` 插值替换之前的 `keys.tf` 代码：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is a much clearer and more concise way of accessing the content of the
    public key from the Terraform resource. It's also easier to maintain, as changing
    the key will only require to replace the file and nothing more.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种更清晰、更简洁的方式，来访问 Terraform 资源中的公钥内容。它也更易于维护，因为更换密钥时只需替换文件，无需其他操作。
- en: How it works…
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何运作……
- en: Our first resource, `aws_key_pair` takes two arguments (a key name and the public
    key content). That's how all resources in Terraform work.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个资源 `aws_key_pair` 接受两个参数（一个密钥名称和公钥内容）。这就是 Terraform 中所有资源的工作方式。
- en: We used our first *file* interpolation, using a variable, to show how to use
    a more dynamic code for our infrastructure.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了第一个 *文件* 插值，使用变量，展示了如何使用更动态的代码来管理我们的基础设施。
- en: There's more…
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'Using Ansible, we can create a *role* to do the same job. Here''s how we can
    manage our EC2 key pair using a variable, with the name `admin_key`. For simplification,
    we''re using the three usual environment variables—`AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`,
    and `AWS_DEFAULT_REGION`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Ansible，我们可以创建一个 *角色* 来做同样的工作。下面是如何使用变量来管理 EC2 密钥对，名称为 `admin_key`。为简化，我们使用了三个常见的环境变量——`AWS_ACCESS_KEY_ID`，`AWS_SECRET_ACCESS_KEY`，和
    `AWS_DEFAULT_REGION`：
- en: 'Here''s a typical Ansible file hierarchy:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个典型的 Ansible 文件层次结构：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the main file (`main.yml`), let''s declare that our host (`localhost`) will
    apply the role dedicated to manage our keys:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在主文件（`main.yml`）中，让我们声明我们的主机（`localhost`）将应用用于管理密钥的角色：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the `ec2_keys` main task file, create the EC2 key (`roles/ec2_keys/tasks/main.yml`):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ec2_keys` 主任务文件中，创建 EC2 密钥（`roles/ec2_keys/tasks/main.yml`）：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Execute the code with the following command:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令执行代码：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Using AWS security groups with Terraform
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Terraform 中使用 AWS 安全组
- en: Amazon's security groups are similar to traditional firewalls, with ingress
    (incoming traffic) and egress (outgoing traffic) rules applied to EC2 instances.
    Those rules can be updated on-demand. We'll create an initial security group allowing
    ingress **Secure Shell** (**SSH**) traffic only for our own IP address, while
    allowing all outgoing traffic.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊的安全组类似于传统防火墙，适用于 EC2 实例的入站（传入流量）和出站（传出流量）规则。这些规则可以按需更新。我们将创建一个初始的安全组，只允许从我们自己的
    IP 地址访问 **安全外壳协议**（**SSH**）流量，同时允许所有的出站流量。
- en: Getting ready
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正在准备中
- en: 'To step through this recipe, you will need the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行这个配方，你需要以下资源：
- en: A working Terraform installation
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的 Terraform 安装
- en: An AWS provider configured in Terraform (refer to the previous recipe)
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Terraform 中配置的 AWS 提供者（请参阅之前的配方）
- en: An Internet connection
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个互联网连接
- en: How to do it…
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'The resource we''re using is called `aws_security_group`. Here''s the basic
    structure:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的资源叫做 `aws_security_group`。这是基本的结构：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We know we want to allow inbound TCP/22 for SSH only for our own IP (replace
    1.2.3.4/32 with yours!), and allow everything outbound. Here''s how it looks:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们只想允许从我们自己的 IP 地址访问 TCP/22 端口（将 1.2.3.4/32 替换为你的 IP 地址！），并允许所有出站流量。它看起来是这样的：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can add a name tag for easier reference later:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加一个名称标签，以便以后更容易参考：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Apply this and you''re good to go:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 应用这个，你就可以开始了：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can see your newly created security group by logging into the AWS Console
    and navigating to **EC2 Dashboard** | **Network & Security** | **Security Groups**:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过登录到 AWS 控制台并导航到 **EC2 仪表盘** | **网络与安全** | **安全组** 来查看你新创建的安全组：
- en: '![How to do it…](img/B05671_02_02.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作……](img/B05671_02_02.jpg)'
- en: 'Another way of accessing the same AWS Console information is through the AWS
    command line:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种访问相同 AWS 控制台信息的方法是通过 AWS 命令行：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There's more…
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'We can achieve the same result using Ansible. Here''s the equivalent of what
    we just did with Terraform in this recipe:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 Ansible 来实现相同的结果。以下是使用 Terraform 在本配方中所做操作的等效 Ansible 实现：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Creating an Ubuntu EC2 instance with Terraform
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Terraform 创建一个 Ubuntu EC2 实例
- en: We have previously created the requirements to launch a standard virtual machine
    on AWS EC2 (an SSH key pair and a security group). Let's now launch this virtual
    machine on EC2, using the specified SSH key pair to log into it and placed inside
    the security group, so (in our case) SSH is only available from a specific IP
    address.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经创建了在 AWS EC2 上启动标准虚拟机的必要条件（一个 SSH 密钥对和一个安全组）。现在，让我们在 EC2 上启动这个虚拟机，使用指定的
    SSH 密钥对登录并将其放入安全组中，这样（在我们的案例中）SSH 只会从特定的 IP 地址可用。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This example uses the `t2.micro` instance available for free in the AWS Free
    Tier.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例使用的是 AWS 免费套餐中提供的 `t2.micro` 实例。
- en: Getting ready
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要按步骤操作此方法，你需要以下内容：
- en: A working Terraform installation
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的 Terraform 安装
- en: An AWS provider, a SSH key pair, and a Security Group configured in Terraform
    (refer to the previous recipes)
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 AWS 提供程序，一个 SSH 密钥对，以及在 Terraform 中配置的安全组（参见前面的配方）
- en: An Internet connection
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个互联网连接
- en: How to do it…
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'First, you need to find the correct AMI for your machine. An AMI is like a
    system disk image for AWS, and is referred to by its ID (that is: ami-df3bceb0
    or ami-f2fc9d81). In the Ubuntu case, you can find the AMI you want by going to
    their Amazon EC2 AMI Locator page ([https://cloud-images.ubuntu.com/locator/ec2/](https://cloud-images.ubuntu.com/locator/ec2/)).
    In this case, I selected a Xenial release (16.04 LTS), on the eu-west-1 zone (Ireland),
    running on HVM virtualization and backed by SSD disks. This leaves us with one
    result—`ami-ee6b189d`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要找到适合你机器的 AMI。AMI 就像是 AWS 的系统磁盘映像，并通过其 ID 来引用（例如：ami-df3bceb0 或 ami-f2fc9d81）。以
    Ubuntu 为例，你可以通过访问其 Amazon EC2 AMI 定位器页面（[https://cloud-images.ubuntu.com/locator/ec2/](https://cloud-images.ubuntu.com/locator/ec2/)）来找到你需要的
    AMI。在本例中，我选择了一个 Xenial 版本（16.04 LTS），位于欧盟西部（爱尔兰）的 eu-west-1 区域，使用 HVM 虚拟化，并且由
    SSD 磁盘支持。这样我们得到了一个结果——`ami-ee6b189d`：
- en: '![How to do it…](img/B05671_02_03.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/B05671_02_03.jpg)'
- en: 'Start by declaring this variable in the `variables.tf` file started in the
    first recipe, using a default value corresponding to the AMI ID we found previously:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `variables.tf` 文件中声明此变量开始，该文件在第一个配方中已经创建，使用一个与我们之前找到的 AMI ID 对应的默认值：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now let''s declare the instance type, specifying it as a default:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们声明实例类型，并将其指定为默认值：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s use those variables to create the Terraform `aws_instance` resource.
    Locally declared variables are available using the `${var.variable_name}` structure,
    and internal resource attributes are accessed using the `${resource_type.resource_name.attribute}`
    structure:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这些变量来创建 Terraform `aws_instance` 资源。局部声明的变量可以通过 `${var.variable_name}`
    结构来访问，而内部资源属性则通过 `${resource_type.resource_name.attribute}` 结构来访问：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Apply the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 应用以下代码：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Navigate to the AWS EC2 dashboard under **Instances** | **Instances**, select
    your instance and note the public IP:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到 AWS EC2 仪表盘下的 **实例** | **实例**，选择你的实例并记录下公共 IP：
- en: '![How to do it…](img/B05671_02_04.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/B05671_02_04.jpg)'
- en: 'Try to log into it:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试登录：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can apply and apply by refreshing its state against Amazon's as Terraform
    knows remote and local states are the same, and therefore it doesn't recreate
    endlessly new VMs each time.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过刷新其状态来应用 Terraform，因为 Terraform 知道远程和本地状态是相同的，因此它不会每次都重新创建新的虚拟机。
- en: You've successfully launched your first AWS EC2 instance using repeatable Terraform
    code!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经成功使用可重复的 Terraform 代码启动了第一个 AWS EC2 实例！
- en: Scaling the number of instances
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展实例数量
- en: 'What if you want to launch two similar instances, maybe for debugging purposes,
    or for instant action behind a load balancer? It''s very easy with Terraform,
    just use the `count` option inside the `aws_instance` resource, and that will
    launch the required amount of instances:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想启动两个相似的实例，可能是为了调试，或者是为了在负载均衡器后面进行即时操作，应该怎么做？使用 Terraform 很容易，只需在 `aws_instance`
    资源中使用 `count` 选项，它会启动所需数量的实例：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, `terraform apply` this and observe Terraform automatically creating a
    new machine according to the counter:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`terraform apply` 这个配置并观察 Terraform 根据计数器自动创建一台新机器：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The second server shows up in the AWS Console:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 第二台服务器出现在 AWS 控制台中：
- en: '![Scaling the number of instances](img/B05671_02_05.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![扩展实例数量](img/B05671_02_05.jpg)'
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember, the command to destroy a Terraform infrastructure is `terraform destroy`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，销毁 Terraform 基础设施的命令是 `terraform destroy`。
- en: There's more…
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'We can achieve similar results using Ansible. Here''s how it looks, using `admin_key`
    and `base_security_group` created in the previous recipes:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Ansible 达到类似的效果。以下是使用在前面教程中创建的 `admin_key` 和 `base_security_group` 的示例：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Generating meaningful outputs with Terraform
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Terraform 生成有意义的输出
- en: Wouldn't it be great if Terraform could show us useful, informational output
    after a successful run? Following what we've done so far, it would be helpful
    to know how to connect to the instance, what are the local and public IP addresses,
    or see the security groups used. That's what Terraform's outputs are for.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Terraform 在成功运行后能够显示一些有用的信息输出，那该多好？根据我们到目前为止所做的内容，了解如何连接到实例、查看本地和公网 IP 地址，或查看使用的安全组将是非常有帮助的。这正是
    Terraform 输出的用途。
- en: Getting ready
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个教程，你需要以下内容：
- en: A working Terraform installation
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的 Terraform 安装
- en: An AWS provider and an EC2 instance (using a SSH keypair and a Security Group),
    all configured in Terraform (refer to the previous recipes)
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 AWS 提供者和一个 EC2 实例（使用 SSH 密钥对和安全组），都在 Terraform 中配置（参见前面的教程）
- en: An Internet connection
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个互联网连接
- en: How to do it…
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: Thankfully, we can use the same syntax we're already using to access variables
    and attributes of references, but this time in an `output` resource.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以使用我们已经使用的相同语法来访问变量和引用的属性，这次是在 `output` 资源中。
- en: 'Let''s start by simply adding a line in `outputs.tf` that would show us how
    to connect to our virtual machine, using the `public_ip` attribute of our `dev`
    EC2 instance:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在 `outputs.tf` 中简单地添加一行，来显示如何连接到我们的虚拟机，使用我们 `dev` EC2 实例的 `public_ip` 属性：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When applying terraform next time, it will display the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下次应用 Terraform 时，它将显示以下内容：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: No doubt it's much quicker than having to log into the AWS dashboard, find the
    instance, and copy and paste the IP in the terminal.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 毋庸置疑，这比登录 AWS 控制台，找到实例并复制粘贴 IP 到终端要快速得多。
- en: 'What if it''s important for us to know at a glimpse under what security groups
    our EC2 instance is running? We know security groups can be multiple, so it''s
    an array. We can access the content of this array using the `formatlist` interpolation
    syntax as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想快速了解我们的 EC2 实例运行在哪些安全组下，怎么办？我们知道安全组可以有多个，所以它是一个数组。我们可以使用 `formatlist` 插值语法来访问这个数组的内容，方法如下：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'So now, at the next `terraform apply`, we''ll instantly know our security groups:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在，在下次执行 `terraform apply` 时，我们会立即知道我们的安全组：
- en: '[PRE37]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Also, if we have a lot of information to display from multiple sources, we
    can use the same syntax:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们有很多来自多个来源的信息需要显示，我们也可以使用相同的语法：
- en: '[PRE38]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This will display the instance ID and its local and public IP addresses.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示实例 ID 及其本地和公网 IP 地址。
- en: There's more…
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: Note that we used `${aws_instance.dev.public_ip}` in the first output and `aws_instance.dev.*.public_ip`
    in our last output. If you use the latter, the output will iterate through all
    available machines. It's very useful if you launch more than one instance using
    the `count=n` parameter in the `aws_instance` Terraform resource.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在第一次输出中使用了`${aws_instance.dev.public_ip}`，而在最后一次输出中使用了`aws_instance.dev.*.public_ip`。如果使用后者，输出将遍历所有可用的机器。如果你使用
    `aws_instance` Terraform 资源的 `count=n` 参数启动多个实例，这将非常有用。
- en: Using contextual defaults with Terraform
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Terraform 中的上下文默认值
- en: We've seen how to declare and use default values in our Terraform code, such
    as the Ubuntu AMI for our region or our VM size. An interesting feature in Terraform
    is the ability to declare and use *maps* of values, so, depending on a key, the
    variable can have a different value. We'll see how it applies to the correct AMI
    of the corresponding AWS.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何在 Terraform 代码中声明和使用默认值，比如为我们区域选择的 Ubuntu AMI 或我们的虚拟机大小。Terraform 中一个有趣的功能是能够声明和使用*映射*值，因此，根据键的不同，变量可以有不同的值。我们将看到如何将它应用到对应
    AWS 的正确 AMI 上。
- en: Getting ready
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个教程，你需要以下内容：
- en: A working Terraform installation
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的 Terraform 安装
- en: An AWS provider and an EC2 instance (using a SSH key pair and a security group),
    all configured in Terraform (refer to the previous recipes)
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 AWS 提供者和一个 EC2 实例（使用 SSH 密钥对和安全组），都在 Terraform 中配置（参见前面的教程）
- en: An Internet connection
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个互联网连接
- en: How to do it…
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'Here''s how we simply declared the AMI we wanted for the `eu-west-1` region
    in the `variables.tf` file:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们在`variables.tf`文件中为`eu-west-1`区域声明我们希望使用的 AMI：
- en: '[PRE39]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We accessed it easily like this in the `instances.tf` file:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样在`instances.tf`文件中轻松访问它：
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'A similar, but more explicit way would be to use a map, so we know which region
    the value refers to:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一种相似但更加明确的方法是使用映射，这样我们就能知道值所指向的具体区域：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here''s how we access the same value in a map:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们如何在映射中访问相同的值：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now let''s add more valid AMI IDs for other regions:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为其他区域添加更多有效的 AMI ID：
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `ami` variable can now be valid for either of the three regions if accessed
    correctly in the `instances.tf` file:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`instances.tf`文件中正确访问，`ami`变量现在可以适用于这三个区域中的任何一个：
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now is a good time to start managing the AWS region directly in the code, for
    better portability. Add the following to `variables.tf` to use `eu-west-1` as
    a default region:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候直接在代码中管理 AWS 区域，以提高可移植性了。将以下内容添加到`variables.tf`中，以将`eu-west-1`作为默认区域：
- en: '[PRE45]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You can now use this variable in the `provider.tf` file to set the region:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以在`provider.tf`文件中使用此变量来设置区域：
- en: '[PRE46]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now the region variable is globally available, let''s use it to access our
    map in `instances.tf`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在区域变量在全局范围内可用，让我们在`instances.tf`中使用它来访问我们的映射：
- en: '[PRE47]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We now have an easily geographically deployable infrastructure that anyone in
    your team can launch close to him or her without the need to change code.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个易于地理部署的基础设施，团队中的任何人都可以在不修改代码的情况下，将其部署到离他们最近的位置。
- en: There's more…
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'We can perform the same dynamic access to a map using the `lookup()` function
    in Terraform:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Terraform 中的`lookup()`函数对映射进行动态访问：
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Managing S3 storage with Terraform
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Terraform 管理 S3 存储
- en: 'Storing and accessing files easily and in a scalable way is an essential part
    of a modern infrastructure. Amazon S3 is Amazon''s answer to this need. S3 stores
    "objects" in "buckets" and has no storage limit (one exception is the bucket name:
    it has to be unique on Amazon''s S3, the namespace being shared). We''ll see how
    to make the best use of S3 with Terraform.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 轻松且可扩展地存储和访问文件是现代基础设施的一个重要部分。Amazon S3 是 Amazon 对此需求的回应。S3 将“对象”存储在“桶”中，并且没有存储限制（唯一的例外是桶名称：它必须在
    Amazon S3 上唯一，因为命名空间是共享的）。我们将看看如何利用 Terraform 充分使用 S3。
- en: Getting ready
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此步骤，你需要以下内容：
- en: A working Terraform installation
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的 Terraform 安装
- en: An AWS provider configured in Terraform (refer to the previous recipes)
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个在 Terraform 中配置的 AWS 提供商（请参考之前的配方）
- en: An Internet connection
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个互联网连接
- en: How to do it…
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We''ll start by creating a simple and explicitly public bucket on S3 named
    `iac-book`, using the `aws_s3_bucket` resource (and a tag for the sake of it):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从在 S3 上创建一个简单且明确公开的桶 `iac-book` 开始，使用 `aws_s3_bucket` 资源（并附带一个标签以示说明）：
- en: '[PRE49]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'After a `terraform apply`, your bucket is immediately available for storing
    objects. You can see it on the AWS S3 Console ([https://console.aws.amazon.com/s3/](https://console.aws.amazon.com/s3/)):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行`terraform apply`之后，你的桶立即可用于存储对象。你可以在 AWS S3 控制台上看到它（[https://console.aws.amazon.com/s3/](https://console.aws.amazon.com/s3/)）：
- en: '![How to do it…](img/B05671_02_06.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/B05671_02_06.jpg)'
- en: 'Let''s store a first object right now, a very simple file containing a simple
    string (`"Hello Infrastructure-as-Code Cookbook!"`). The resource is named `aws_s3_bucket_object`,
    and you need to reference the bucket previously created, the destination name
    (`index.html`), and its content. The ACL is here again explicitly public:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们存储第一个对象，一个非常简单的文件，包含一个简单的字符串（`"Hello Infrastructure-as-Code Cookbook!"`）。该资源名为
    `aws_s3_bucket_object`，你需要引用之前创建的桶、目标名称（`index.html`）及其内容。ACL 在这里再次明确为公开：
- en: '[PRE50]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You can alternatively provide a file directly instead of its content:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以直接提供一个文件，而不是其内容：
- en: '[PRE51]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If you navigate to the AWS S3 Console, you can see it available with some extended
    information:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你访问 AWS S3 控制台，你可以看到它有一些扩展的信息：
- en: '![How to do it…](img/B05671_02_07.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/B05671_02_07.jpg)'
- en: 'It would be awesome if we could know easily the URL of our file right from
    Terraform, so we could give it to others. Unfortunately, there''s no easy function
    for that. However, we know how URLs are constructed: `http://s3-<region>.amazonaws.com/bucket_name/object_name`.
    Let''s create an output containing this information:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能直接从 Terraform 获取到文件的 URL 并提供给其他人，那就太棒了。不幸的是，目前没有简单的函数来做到这一点。然而，我们知道 URL
    是如何构建的：`http://s3-<region>.amazonaws.com/bucket_name/object_name`。让我们创建一个输出，包含这些信息：
- en: '[PRE52]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Paste the link in a web browser and you'll be able to access your file.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 将链接粘贴到网页浏览器中，你将能够访问你的文件。
- en: 'A workaround is to use the *static website hosting* feature of S3 by simply
    adding the following to your `aws_s3_bucket` resource:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方法是通过简单地在你的 `aws_s3_bucket` 资源中添加以下内容，使用 S3 的 *静态网站托管* 功能：
- en: '[PRE53]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'An optional output will give you its static hosting URL (in our case, [iac-book.s3-website-eu-west-1.amazonaws.com](http://iac-book.s3-website-eu-west-1.amazonaws.com)
    instead of [http://s3-eu-west-1.amazonaws.com/iac-book/index.html](http://s3-eu-west-1.amazonaws.com/iac-book/index.html)):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可选输出将为你提供其静态托管 URL（在我们的案例中，是 [iac-book.s3-website-eu-west-1.amazonaws.com](http://iac-book.s3-website-eu-west-1.amazonaws.com)
    而不是 [http://s3-eu-west-1.amazonaws.com/iac-book/index.html](http://s3-eu-west-1.amazonaws.com/iac-book/index.html)）：
- en: '[PRE54]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: There's more…
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'Using Ansible, there are many ways to create a bucket. Here''s a simple bucket
    with public read permissions, using the classic `s3` module:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Ansible，有很多方法可以创建一个存储桶。以下是一个简单的存储桶，具有公共读取权限，使用经典的`s3`模块：
- en: '[PRE55]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that Ansible 2.2 also comes with an `s3_website` module for specifically
    handling S3 websites.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Ansible 2.2 还带有一个`s3_website`模块，专门用于处理 S3 网站。
- en: 'Here''s how we would simply upload our previous `index.html` file using the
    same `s3` module:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们如何使用相同的 `s3` 模块简单上传我们之前的 `index.html` 文件：
- en: '[PRE56]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Creating private Docker repositories with Terraform
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Terraform 创建私有 Docker 仓库
- en: 'To host your Docker images, you need what''s called a **registry**. This registry
    is either run by you or as a service. It stores your images for you and sometimes
    builds them too. The Docker Hub and Quay.io from CoreOS are the main Docker-managed
    registries you can subscribe to. Both are interesting in terms of features or
    pricing. However, an interesting alternative is AWS **Elastic Container Registry**
    (**ECR**): pricing is different and fully integrated in the AWS ecosystem. Let''s
    create countless repositories simply with Terraform!'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要托管 Docker 镜像，你需要一个被称为 **注册表** 的东西。这个注册表可以是你自己运行的，也可以是作为服务提供的。它为你存储镜像，有时也会构建它们。Docker
    Hub 和 CoreOS 的 Quay.io 是你可以订阅的主要 Docker 管理注册表。它们在功能或定价上都很有吸引力。然而，一个有趣的替代方案是 AWS
    **弹性容器注册表** (**ECR**)：定价不同，并且完全集成在 AWS 生态系统中。让我们通过 Terraform 简单地创建无数个仓库！
- en: Getting ready
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: 'To step through this recipe, you will need the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此操作，你将需要以下内容：
- en: A working Terraform installation
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正在运行的 Terraform 安装
- en: An AWS provider configured in Terraform (refer to the previous recipes)
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已在 Terraform 中配置的 AWS 提供程序（参考前面的食谱）
- en: A configured AWS CLI ([http://docs.aws.amazon.com/cli/latest/userguide/installing.html](http://docs.aws.amazon.com/cli/latest/userguide/installing.html))
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已配置的 AWS CLI ([http://docs.aws.amazon.com/cli/latest/userguide/installing.html](http://docs.aws.amazon.com/cli/latest/userguide/installing.html))
- en: An Internet connection
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个互联网连接
- en: How to do it…
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Let''s say you want to store your application container in a repository named
    `myapp`, so you can deploy it easily. It''s very simple with Terraform. Add the
    following code to a file named `ecr.tf`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想将你的应用容器存储在一个名为`myapp`的仓库中，以便轻松部署。使用 Terraform 非常简单。将以下代码添加到一个名为`ecr.tf`的文件中：
- en: '[PRE57]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If you want to know the URL to access your new repository, you can create an
    output using the corresponding exported attribute:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道访问新仓库的 URL，可以使用相应的导出属性创建输出：
- en: '[PRE58]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If you''re used to the other Docker registries, the first step is to authenticate
    so you create private repositories. Here, no login or password are provided by
    AWS. We need to use the official AWS command line to authenticate, and that will
    give us temporary Docker credentials. The output of this command is the Docker
    command to type:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯了其他 Docker 注册表，第一步是进行身份验证，以便创建私有仓库。这里，AWS 不提供登录或密码。我们需要使用官方的 AWS 命令行进行身份验证，这将为我们提供临时的
    Docker 凭证。此命令的输出是需要输入的 Docker 命令：
- en: '[PRE59]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now we can `docker build`, `tag`, and `push` images at will! (See more about
    using Docker images in the dedicated chapter of this book.)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以随意进行 `docker build`、`tag` 和 `push` 镜像！（关于使用 Docker 镜像的更多内容，请参阅本书的专门章节。）
- en: A nice advanced feature is the ability to use fine-grained policies for each
    repository created.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的高级功能是能够为每个创建的仓库使用精细的策略。
- en: Creating a PostgreSQL RDS database with Terraform
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Terraform 创建 PostgreSQL RDS 数据库
- en: '**Amazon Relational Database Service** (**RDS**) is an on-demand, ready-to-use,
    and resizable EC2 instance specifically tailored and configured to run the requested
    database server. You can launch many different relational database servers on
    RDS, and we''ll focus on PostgreSQL for this recipe.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**Amazon 关系型数据库服务** (**RDS**) 是一种按需、可随时使用并可调整大小的 EC2 实例，专门定制和配置来运行所请求的数据库服务器。你可以在
    RDS 上启动多种不同的关系型数据库服务器，我们在这个例子中将重点使用 PostgreSQL。'
- en: Getting ready
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To step through this recipe, you will need the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此教程，你需要以下内容：
- en: A working Terraform installation
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的 Terraform 安装
- en: An AWS provider configured in Terraform (refer to the previous recipes)
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Terraform 中配置一个 AWS 提供程序（参考之前的教程）
- en: An Internet connection
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个互联网连接
- en: How to do it…
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'There are many parameters at play in a database deployment, even a simple one.
    To be certain of what we''ll deploy, we''ll start by filling a simple table with
    the database requirements, and build on it:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库部署中有许多参数需要考虑，即使是一个简单的部署。为了确保我们将部署的内容，我们将从填写一个简单的表格开始，列出数据库需求，并在此基础上进行构建：
- en: '| Parameter | Variable name | Value |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 变量名 | 值 |'
- en: '| --- | --- | --- |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| RDS Database Engine | `rds_engine` | `postgresql` |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| RDS 数据库引擎 | `rds_engine` | `postgresql` |'
- en: '| RDS Database Engine Version | `rds_engine_version` | `9.5.2` |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| RDS 数据库引擎版本 | `rds_engine_version` | `9.5.2` |'
- en: '| RDS Instance Name | `rds_identifier` | `db` |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| RDS 实例名称 | `rds_identifier` | `db` |'
- en: '| RDS Instance Type | `rds_instance_type` | `db.t2.micro` |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| RDS 实例类型 | `rds_instance_type` | `db.t2.micro` |'
- en: '| RDS Storage Size (GB) | `rds_storage_size` | `5` |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| RDS 存储大小（GB） | `rds_storage_size` | `5` |'
- en: '| RDS First Database Name | `rds_db_name` | `iac_book_db` |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| RDS 第一个数据库名称 | `rds_db_name` | `iac_book_db` |'
- en: '| RDS Administrator Username | `rds_admin_user` | `dbadmin` |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| RDS 管理员用户名 | `rds_admin_user` | `dbadmin` |'
- en: '| RDS Administrator Password | `rds_admin_password` | `super_secret_password`
    |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| RDS 管理员密码 | `rds_admin_password` | `super_secret_password` |'
- en: '| RDS Publicly Accessible | `rds_publicly_accessible` | `true` |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| RDS 是否公开可访问 | `rds_publicly_accessible` | `true` |'
- en: 'Let''s set all those variables in our `variables.tf` file:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `variables.tf` 文件中设置所有这些变量：
- en: '[PRE60]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'As we''re running PostgreSQL and we want it to be available on the Internet
    (though generally not a good idea for production), we''ll need a security group
    allowing just the default PgSQL port (TCP/5432) for our IP address (refer to the
    *Using AWS security groups with Terraform* recipe), in `securitygroups.tf`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们运行的是 PostgreSQL 并且希望它能够通过互联网访问（虽然一般不推荐用于生产环境），我们需要一个安全组，允许仅允许我们的 IP 地址通过默认的
    PgSQL 端口（TCP/5432）访问（参考 *使用 AWS 安全组与 Terraform* 教程），在 `securitygroups.tf` 文件中：
- en: '[PRE61]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now we have everything in place to construct the `aws_db_instance` resource:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经具备了构建 `aws_db_instance` 资源所需的一切：
- en: '[PRE62]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'As we did previously, a quick output giving us the FQDN of our new database
    will help us to use it quickly, in `outputs.tf`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所做的，快速输出我们的新数据库的 FQDN 将帮助我们快速使用它，输出内容放在 `outputs.tf` 中：
- en: '[PRE63]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Let''s `terraform apply` now and try the result:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行 `terraform apply` 并查看结果：
- en: '[PRE64]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: There are many more useful options you can use or set, such as maintenance windows,
    backup retention periods, dedicated database subnets, storage encryption, and
    master/slave configuration.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多你可以使用或设置的有用选项，如维护窗口、备份保留期限、专用数据库子网、存储加密和主从配置等。
- en: There's more…
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'How would that work when using Ansible to do a similar job with the same values?
    Just as easy as usual:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Ansible 做类似的工作，且值相同的时候，这该如何运作？和往常一样简单：
- en: '[PRE65]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: After executing this playbook, a similar PostgreSQL server will run on RDS as
    we just did with Terraform.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 执行完这个 playbook 后，类似的 PostgreSQL 服务器将运行在 RDS 上，就像我们之前使用 Terraform 所做的那样。
- en: Enabling CloudWatch Logs for Docker with Terraform
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Terraform 为 Docker 启用 CloudWatch 日志
- en: '**CloudWatch Logs** is a log aggregation service by Amazon you can use to send
    your logs to. It''s very useful to keep some logs centralized, share access to
    them, receive alarms when errors happen, or simply store them safely. We''ll see
    how to create a CloudWatch Log group and use it to stream logs from a Docker container
    logs inside it.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**CloudWatch Logs** 是 Amazon 提供的一项日志聚合服务，你可以使用它将日志发送到 CloudWatch。它非常有用，可以将一些日志集中存储，分享访问权限，收到错误发生时的警报，或者仅仅是安全地存储它们。我们将学习如何创建
    CloudWatch 日志组，并使用它来流式传输来自 Docker 容器中的日志。'
- en: Getting ready
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To step through this recipe, you will need the following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此教程，你需要以下内容：
- en: A working Terraform installation
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的 Terraform 安装
- en: An AWS provider configured in Terraform (refer to the previous recipes)
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Terraform 中配置一个 AWS 提供程序（参考之前的教程）
- en: An Internet connection
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个互联网连接
- en: A Docker Engine running on Linux for the optional usage demonstration
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个在 Linux 上运行的 Docker 引擎，用于可选的使用演示
- en: How to do it…
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s say we want the log group to be named `docker_logs`, and that we want
    to keep those logs for seven days. In the `variables.tf` file, that would look
    like this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望日志组命名为 `docker_logs`，并且希望将这些日志保存七天。在 `variables.tf` 文件中，这看起来是这样的：
- en: '[PRE66]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Also, in a new `cloudwatch.tf` file, we can use the simple `aws_cloudwatch_log_group`
    resource:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在一个新的 `cloudwatch.tf` 文件中，我们可以使用简单的 `aws_cloudwatch_log_group` 资源：
- en: '[PRE67]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: After a `terraform apply`, if you navigate to the AWS CloudWatch page, you'll
    see the newly created group under the **Log Groups** entry on the left ([https://eu-west-1.console.aws.amazon.com/cloudwatch/](https://eu-west-1.console.aws.amazon.com/cloudwatch/)).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `terraform apply` 后，如果你进入 AWS CloudWatch 页面，你会在左侧的 **日志组** 项下看到新创建的组（[https://eu-west-1.console.aws.amazon.com/cloudwatch/](https://eu-west-1.console.aws.amazon.com/cloudwatch/)）。
- en: '![How to do it…](img/B05671_02_08.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/B05671_02_08.jpg)'
- en: Amazon CloudWatch Logs Docker logging driver
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Amazon CloudWatch Logs Docker 日志驱动程序
- en: 'You can now use this group to create a log stream from an application or a
    container. Using it as recommended by AWS is well documented, so let''s use it
    with Docker instead. It only requires to give the Docker daemon access to the
    `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` environment variables (configuring
    the Docker daemon is out of the scope of this chapter, but that''s under `/etc/sysconfig/docker`
    for Red Hat-based systems such as Fedora or CentOS, and `/etc/default/docker`
    for Debian/Ubuntu systems). Restart the daemon and start logging your containers
    output using a new Docker logging driver, using the log group name specified in
    Terraform earlier (`docker_logs`):'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用此组从应用程序或容器创建日志流。按照 AWS 推荐的方式使用它是有详细文档说明的，所以我们来改用 Docker。只需要给 Docker
    守护进程访问 `AWS_ACCESS_KEY_ID` 和 `AWS_SECRET_ACCESS_KEY` 环境变量的权限（配置 Docker 守护进程超出了本章的范围，但对于基于
    Red Hat 的系统，如 Fedora 或 CentOS，它位于 `/etc/sysconfig/docker`，对于 Debian/Ubuntu 系统，它位于
    `/etc/default/docker`）。重新启动守护进程并开始使用新的 Docker 日志驱动程序记录容器输出，使用 Terraform 中之前指定的日志组名称（`docker_logs`）：
- en: '[PRE68]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Generate some activity on the container:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器上生成一些活动：
- en: '[PRE69]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Refresh the AWS CloudWatch page and you'll see a new entry named `nginx` with
    the container logs. You can run all your containers in your infrastructure like
    this and get centralized logging very easily!
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新 AWS CloudWatch 页面，你会看到一个名为 `nginx` 的新条目，里面有容器日志。你可以像这样在你的基础设施中运行所有容器，并轻松获得集中式日志记录！
- en: '![Amazon CloudWatch Logs Docker logging driver](img/B05671_02_09.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![Amazon CloudWatch Logs Docker 日志驱动程序](img/B05671_02_09.jpg)'
- en: Managing IAM users with Terraform
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Terraform 管理 IAM 用户
- en: An essential part of using AWS is controlling access to the resources. We've
    seen with all the previous recipes how often we need to use the AWS Access Keys,
    and it's surely not a good idea to use a single key for all your activities. Imagine
    what would happen if a single one of your services was hacked—the intruder would
    get the main AWS key and would be able to do everything on your behalf.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AWS 的一个关键部分是控制对资源的访问。我们在之前的所有示例中看到，我们经常需要使用 AWS 访问密钥，显然，使用单个密钥进行所有操作并不是一个好主意。试想，如果你其中一个服务被黑客入侵——入侵者将获得主
    AWS 密钥，并且可以代表你执行任何操作。
- en: A good secure setup would be dedicated keys with a dedicated scope of access
    rights for every person in your team and every service in your infrastructure.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的安全设置是为团队中的每个人和基础设施中的每个服务分配专用密钥和专用访问权限范围。
- en: Thankfully, **Identity and Access Management** (**IAM**) is there just for that.
    We'll see how to use it with Terraform.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，**身份与访问管理**（**IAM**）正是为此而存在。我们将看到如何使用它与 Terraform 配合。
- en: Getting ready
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To step through this recipe, you will need the following:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此示例，你需要以下内容：
- en: A working Terraform installation
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可用的 Terraform 安装
- en: An AWS provider configured in Terraform (refer to the previous recipes)
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Terraform 中配置的 AWS 提供程序（参考之前的示例）
- en: An Internet connection
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个互联网连接
- en: How to do it…
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s start with a simple case: two members of a team (Mary and Joe) need
    to access resources on AWS. They currently all share the same main key, which
    is a disaster if a leakage happens. So let''s ask them what exactly they need
    to access in the AWS space:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的案例开始：一个团队的两名成员（Mary 和 Joe）需要访问 AWS 上的资源。他们目前共享相同的主密钥，一旦发生泄漏，将是灾难性的。所以让我们问问他们到底需要在
    AWS 空间中访问哪些内容：
- en: '| **Mary** | S3 in read and write |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| **Mary** | S3 读写权限 |'
- en: '| **Joe** | EC2 in read only |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| **Joe** | EC2 只读 |'
- en: As expected, neither user really needs full access!
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，两个用户实际上都不需要完全访问权限！
- en: 'Amazon helps by offering prebuilt security policies for IAM. If those aren''t
    enough, you can tailor the ones you need:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊通过提供预构建的IAM安全策略来帮助我们。如果这些不够，你还可以定制你需要的策略：
- en: '![How to do it…](img/B05671_02_10.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![How to do it…](img/B05671_02_10.jpg)'
- en: Note
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find all AWS Managed IAM Policies at [https://console.aws.amazon.com/iam/home#policies](https://console.aws.amazon.com/iam/home#policies).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://console.aws.amazon.com/iam/home#policies](https://console.aws.amazon.com/iam/home#policies)找到所有AWS托管的IAM策略。
- en: An IAM user for S3 access
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于S3访问的IAM用户
- en: 'Let''s create a first IAM user for Mary in a new `iam.tf` file using the `aws_iam_user`
    resource:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在新的`iam.tf`文件中为Mary创建第一个IAM用户，使用`aws_iam_user`资源：
- en: '[PRE70]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The `path` is purely optional and informative, I'm simply suggesting structured
    paths. So we'll have `/apps/` as well later.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`path`是纯粹可选的，仅供参考，我只是建议使用结构化的路径。所以以后我们还会有`/apps/`路径。'
- en: 'We can now create an AWS Access Key for our user Mary, using the `aws_iam_access_key`
    resource with reference to our user:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为Mary的用户创建一个AWS访问密钥，使用`aws_iam_access_key`资源并引用我们的用户：
- en: '[PRE71]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'And finally, as we know, we want to attach to this user the `AmazonS3FullAccess`
    managed policy, let''s use the dedicated resource:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如我们所知，我们希望将`AmazonS3FullAccess`托管策略附加到这个用户上，我们使用专用资源：
- en: '[PRE72]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Let''s write an `output` so we know both parts of the key in `outputs.tf`:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`outputs.tf`中写一个`output`，这样我们就知道密钥的两部分：
- en: '[PRE73]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Also, `terraform apply` this to create the `mary` user:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`terraform apply`此操作以创建`mary`用户：
- en: '[PRE74]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Testing the restrictions
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试限制
- en: 'Now, `terraform apply` this, and confirm using an S3 browser that you can access
    S3! Here''s an example of creating a simple S3 bucket with `s3cmd`:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`terraform apply`这个，然后通过S3浏览器确认你可以访问S3！下面是使用`s3cmd`创建简单S3桶的示例：
- en: '[PRE75]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Is this account really limited to S3, as it pretends to be? Let''s try to list
    EC2 hosts with Mary''s account using the `aws` command line (provided you configured
    the `aws` tool accordingly):'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这个账户真的仅限于S3吗？就像它所声称的那样吗？让我们尝试使用Mary的账户通过`aws`命令行列出EC2主机（前提是你已按要求配置了`aws`工具）：
- en: '[PRE76]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: So it all looks good and secure! Mary can do her job on S3 safely.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 所以一切看起来都很好且安全！Mary可以安全地在S3上完成她的工作。
- en: An IAM user for EC2 in read-only
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于EC2只读访问的IAM用户
- en: Is there a similar managed policy for Joe, with a read-only scope on EC2? Fortunately,
    there is! It's creatively named `AmazonEC2ReadOnlyAccess`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有类似的托管策略可以为Joe提供只读EC2访问权限？幸运的是，有！它被创意地命名为`AmazonEC2ReadOnlyAccess`。
- en: 'Let''s create our second user, with this IAM policy in the `iam.tf` file:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建第二个用户，使用`iam.tf`文件中的这个IAM策略：
- en: '[PRE77]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Don''t forget the useful output that comes with it:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了附带的有用输出：
- en: '[PRE78]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Next, `terraform apply` this once again, and can the Joe user see what''s on
    S3? No, he can''t:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，再次`terraform apply`这个，那么Joe用户能看到S3上的内容吗？不，他不能：
- en: '[PRE79]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'But can the Joe user simply list the EC2 VMs as he needs to, with the same
    command that was forbidden to Mary? Yes, he can:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，Joe用户能否像他需要的那样列出EC2虚拟机，使用Mary被禁止使用的同一个命令？是的，他可以：
- en: '[PRE80]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: We're on track to securely manage our infrastructure access using code!
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在通过代码安全地管理我们的基础设施访问！
- en: An application user IAM – CloudWatch Logs
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序用户IAM – CloudWatch Logs
- en: We've used the CloudWatch Logs service in a previous recipe. If you remember,
    you had to enter once again your keys in the Docker Engine configuration. If you
    had 100 servers, your master keys would be on each of them. This is rather unnecessary,
    if you consider that the scope of this configuration in Docker is just to send
    logs. Fortunately, there's a managed IAM policy for that named `CloudWatchLogsFullAccess`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的配方中使用了CloudWatch日志服务。如果你还记得，你需要在Docker引擎配置中再次输入你的密钥。如果你有100台服务器，你的主密钥将会出现在每一台服务器上。如果考虑到Docker中这个配置的范围只是发送日志，这就显得有些不必要了。幸运的是，有一个名为`CloudWatchLogsFullAccess`的托管IAM策略可以解决这个问题。
- en: 'So let''s create another user, exactly as before for Mary and Joe, except this
    one will be for our Docker Engines and not for a real user in `iam.tf`. I suggest
    using a different path, just to separate real users and application users. However,
    that''s totally optional and opinionated:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们再创建一个用户，和之前为Mary和Joe创建的完全一样，只不过这个是为我们的Docker引擎创建的，而不是为一个真实用户创建的，位于`iam.tf`中。我建议使用不同的路径，只是为了区分真实用户和应用程序用户。然而，这完全是可选的，取决于个人偏好：
- en: '[PRE81]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The relevant `output` in `outputs.tf` is as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在`outputs.tf`中相关的`output`如下：
- en: '[PRE82]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now, `terraform apply` this and try the *Enabling CloudWatch Logs for Docker
    with Terraform* recipe again with those credentials instead of the master keys:
    it will still work on the CloudWatch scope, but if something goes wrong, it will
    never put the rest of your infrastructure in danger. The worst that can happen
    in this area is the total waste of the logs.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`terraform apply`并再次尝试使用这些凭据而不是主密钥来执行*使用Terraform启用CloudWatch日志记录*配方：它仍然可以在CloudWatch范围内正常工作，但如果出现问题，它将永远不会让你的其余基础设施处于危险之中。在这一领域，最糟糕的情况就是日志的完全浪费。
- en: '[PRE83]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '![An application user IAM – CloudWatch Logs](img/B05671_02_11.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序用户IAM – CloudWatch日志](img/B05671_02_11.jpg)'
- en: There's more…
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'If you''d prefer to see how this would work using Ansible, it''s a bit different.
    IAM support is not equivalent, as there''s no IAM Managed Policies support. However,
    you can simply create users like this:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更愿意看到使用Ansible的实现方式，它稍微有些不同。IAM的支持并不完全相同，因为没有IAM托管策略的支持。然而，你可以像这样简单地创建用户：
- en: '[PRE84]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'As there''s currently no IAM Managed Policy support, a workaround is to use
    the JSON from the IAM Policy we want, such as `AmazonS3FullAccess` for our user
    Mary. It''s easy to find in the AWS Console in the **Policies** section ([https://console.aws.amazon.com/iam/home#policies](https://console.aws.amazon.com/iam/home#policies)).
    Paste the following JSON content in `AmazonS3FullAccess.json` at the root of the
    `Ansible` folder:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 由于当前没有IAM托管策略的支持，一个解决方法是使用我们想要的IAM策略的JSON文件，例如给我们的用户Mary使用`AmazonS3FullAccess`。在AWS控制台的**策略**部分（[https://console.aws.amazon.com/iam/home#policies](https://console.aws.amazon.com/iam/home#policies)）可以很容易找到。将以下JSON内容粘贴到`Ansible`文件夹根目录下的`AmazonS3FullAccess.json`文件中：
- en: '[PRE85]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Use this local policy in the `iam_policy` module:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在`iam_policy`模块中使用此本地策略：
- en: '[PRE86]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
