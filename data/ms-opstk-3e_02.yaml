- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Kicking Off the OpenStack Setup – The Right Way (DevSecOps)
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动 OpenStack 设置 – 正确的方式（DevSecOps）
- en: “In the middle of difficulty lies opportunity.”
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: “困难中蕴藏着机遇。”
- en: – Albert Einstein
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ——阿尔伯特·爱因斯坦
- en: The OpenStack ecosystem, as discussed in the previous chapter, presents a vast
    array of design patterns, coupled with choices of hardware and tools to deploy
    a robust private cloud setup. With the Antelope release, there have been no significant
    changes to the core architecture system, but a few parts have been updated, with
    some additions and features. But that comes with the cost of increased complexity
    when it comes to the deployment and operation stages. The good news is that the
    OpenStack community, since its earliest releases, has created different approaches
    to avoid an arduous OpenStack operation experience. The key mechanism for this
    task is *automation* . There is, without a doubt, a high risk of getting into
    endless troubleshooting if the automation craft is overlooked. There are several
    tools maintained by vendors such as Puppet, Ansible, Chef, and a few others that
    are used in thousands of production deployments. To get an OpenStack setup up
    and running is not the goal of the journey but, rather, the deployment journey
    itself. That is where we will take advantage of automation and agile tools to
    bring the OpenStack operation to the next level, by adopting a DevOps path. Although
    that sounds like an amazing step toward a robust deployment process, it is still
    not complete without incubating security aspects from the early days of the deployment.
    Developing and operating the infrastructure process should be reimagined, from
    a DevOps picture to a DevSecOps one.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章节所述，OpenStack 生态系统呈现了各种设计模式，并提供了硬件和工具的选择，用于部署强大的私有云设置。随着 Antelope 版本的发布，核心架构系统没有发生重大变化，但一些部分进行了更新，并增加了一些新功能。这也带来了部署和操作阶段复杂度的增加。好消息是，自
    OpenStack 最早的版本以来，社区已经创建了不同的方法，以避免繁琐的 OpenStack 操作体验。这个任务的关键机制是*自动化*。毫无疑问，如果忽视了自动化的实现，会面临无休止的故障排除风险。像
    Puppet、Ansible、Chef 等供应商维护了多个工具，这些工具已在成千上万的生产环境中使用。搭建一个 OpenStack 系统并不是旅程的最终目标，而是部署过程本身。我们将利用自动化和敏捷工具，通过采用
    DevOps 路径，将 OpenStack 的运维提升到一个新水平。虽然这听起来是朝着强大部署过程迈出的惊人一步，但如果从部署初期就没有将安全性纳入考虑，这个过程仍然是不完整的。开发和运维基础设施的流程应当重新构思，从
    DevOps 的视角转变为 DevSecOps 的视角。
- en: 'This chapter presents the backbone of the future deployment and operational
    processes for an OpenStack private cloud setup by covering the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 OpenStack 私有云设置未来部署和运维流程的骨干，涵盖以下主题：
- en: Revisiting the DevOps philosophy behind the OpenStack deployment life cycle
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新审视 OpenStack 部署生命周期背后的 DevOps 哲学
- en: Rethinking DevOps and introducing DevSecOps to see how it fits into our journey
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新思考 DevOps，并引入 DevSecOps 以查看它如何适应我们的旅程
- en: Discovering a modern approach to deploying OpenStack in containers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索将 OpenStack 部署到容器中的现代方法
- en: Iterating through automation tools and preparing for deployment
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代自动化工具并为部署做好准备
- en: Running a first iteration of an OpenStack deployment via Continuous Integration/Continuous
    Delivery ( CI/CD) tools
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过持续集成/持续交付（CI/CD）工具运行 OpenStack 部署的第一次迭代
- en: Preparing for a large-scale deployment via code and Continuous Integration/Continuous
    Delivery ( CI/CD) pipelines
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过代码和持续集成/持续交付（CI/CD）管道为大规模部署做准备
- en: Integrating security checks in each deployment step in an automated fashion
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个部署步骤中以自动化方式集成安全检查
- en: Removing silos – DevOps
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打破壁垒 – DevOps
- en: The term **DevOps** has been popping up for almost a decade, pushing organizations
    to rethink how to structure their internal teams to achieve what DevOps promises.
    Dozens of definitions of the word *DevOps* can be found everywhere, but it can
    simply be summarized as a *silo remover* . DevOps comes with the philosophy of
    bringing the main software product’s direct contributors to the same table, including
    operations, testers, and developers. The aim of this movement is based on a few
    principles that motivate organizations to implement them practically – knowledge
    and responsibility sharing, respect, automating everything, monitoring continuously,
    embracing failure, and designing for reusability. However, DevOps has never been
    a tool or software but, rather, a set of principles that define processes and
    workflows to boost a company’s productivity. What makes this movement shine takes
    us back to the simple definition – *silo remover* . As operations and developers
    are not hindered by the wall sitting between them, more collaboration and knowledge
    are shared toward the same goal – decreasing the time to market with the highest
    possible quality and degree of efficiency. Without the existence of many tools,
    reflecting this idea in real life would be more difficult. **Continuous Integration**
    ( **CI** ) and **Continuous Delivery** or **Deployment** ( **CD** ) tools are
    examples that have contributed immensely to reflecting that idea. Another set
    of tools that gives more trust to machines than to humans is the concept of *automation*
    . CI/CD tools leave all the manual and routine build, testing, and deployment
    stages to a few pipelines running on a server. Meanwhile, teams focus on more
    interesting tasks with higher business values. The rise of the cloud era has brought
    another giant set of opportunities to accelerate the software development cycle
    with automation – **infrastructure automation** . This is one of the areas that
    OpenStack focuses on with some of its services, such as **Heat** . Treating **Infrastructure
    as Code** ( **IaC** ) inspires the gathered teams, Dev and Ops, to bring knowledge
    from the traditional software development life cycle and apply it at the infrastructure
    level.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**DevOps** 这个词汇已经出现了将近十年，推动了组织重新思考如何构建内部团队，以实现 DevOps 所承诺的目标。关于 *DevOps* 的定义随处可见，但它可以简单地总结为一个
    *打破孤岛* 的方法。DevOps 提出了将软件产品的主要贡献者——包括运维人员、测试人员和开发人员——聚集在同一张桌子旁的理念。该运动的目标基于几个原则，激励组织在实践中实施它们——知识和责任共享、尊重、自动化一切、持续监控、接纳失败和设计可重用性。然而，DevOps
    从来不是一个工具或软件，而是一组定义过程和工作流的原则，旨在提高公司的生产力。这个运动的亮点可以追溯到最简单的定义—— *打破孤岛*。由于运维人员和开发人员不再受隔阂的限制，更多的协作和知识在朝着同一个目标——以最高的质量和效率减少市场上市时间——共享。没有许多工具的存在，将这个理念付诸实践将会更加困难。**持续集成**（**CI**）和**持续交付**或**部署**（**CD**）工具就是体现这一理念的重要例子。另一类将更多信任交给机器而非人类的工具是
    *自动化* 的概念。CI/CD 工具将所有手动和常规的构建、测试和部署阶段交给服务器上运行的几个流水线来处理。与此同时，团队可以专注于更有趣、更具商业价值的任务。云时代的崛起带来了另一套巨大的机会，通过自动化加速软件开发周期——**基础设施自动化**。这是
    OpenStack 一些服务（如 **Heat**）关注的领域之一。将 **基础设施即代码**（**IaC**）的理念付诸实践，激励 Dev 和 Ops 团队将传统软件开发生命周期中的知识应用到基础设施层面。'
- en: 'It is no longer a case of *that is not my business* but, rather, *it is my
    business too* . What really matters is focusing on the delivery of business products
    in a reasonably reduced amount of time, getting to market faster, and not missing
    out on a race with the competition. This can be summarized with a DevOps toolchain
    for different software deployments across the Dev and Ops stages, as shown in
    the following diagram:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 不再是 *那不是我的事*，而是 *这也是我的事*。真正重要的是专注于在合理的时间内交付商业产品，更快地进入市场，并在与竞争对手的赛跑中不落后。这可以通过以下图示中展示的
    DevOps 工具链来总结，用于跨 Dev 和 Ops 阶段的不同软件部署：
- en: '![Figure 2.1 – The DevOps toolchain](img/B21716_02_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – DevOps 工具链](img/B21716_02_01.jpg)'
- en: Figure 2.1 – The DevOps toolchain
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – DevOps 工具链
- en: By adopting the same philosophy, we will deploy our OpenStack private cloud.
    But before reaching that stage, we need to acknowledge an important fact – there
    is no rule of thumb when it comes to applying what DevOps dictates. The structure
    of teams in organizations may differ, and IT disciplines can be in several dedicated
    pods per function or merged into one. The pursuit of *DevOps happiness* can be
    confusing if an organization does not assign and refactor its team’s structure,
    seek out subject matter experts, have cross-functional team members based on specialized
    knowledge, and so on. Some of these issues have revealed obstacles, due to the
    gaps left in terms of security and compliance. This is what we will uncover in
    the following section before bringing the pieces of OpenStack together.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采纳相同的理念，我们将部署我们的OpenStack私有云。但在达到这一阶段之前，我们需要承认一个重要的事实——在应用DevOps的要求时，并没有放之四海而皆准的法则。组织中的团队结构可能会有所不同，IT领域可以根据职能分布在多个专门的工作小组中，或者合并为一个团队。在没有重新分配和重构团队结构、寻找主题专家、基于专业知识配备跨职能团队成员等情况下，追求*DevOps幸福*可能会让人感到困惑。由于在安全性和合规性方面的空白，一些问题暴露了出障碍。接下来的部分我们将揭示这些问题，然后将OpenStack的各个部分拼接起来。
- en: Shifting to the left – DevSecOps
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向左转——DevSecOps
- en: The *billion-dollar* idea of the DevOps philosophy is to bring people together
    – all disciplines, including Ops, Devs, and **Quality Assurance** ( **QA** ).
    Organizations should make it clear where silos are raised among all product contributors.
    That should include the security discipline in their agile ways of working. The
    *2021 State of DevSecOps* study ( [https://www.securitycompass.com/reports/2021-state-of-devsecops/](https://www.securitycompass.com/reports/2021-state-of-devsecops/)
    ) elaborated by *Security Compass* , a cybersecurity consultancy services provider,
    shows that 75% of responders (IT professionals and DevOps practitioners) agreed
    that security slows down the processes of product releases, leading to an increase
    in the time to market. That goes against what DevOps was created for. Focusing
    on speed to market might skip the security aspect. This *sacrifice* has triggered
    some scary numbers in some large enterprises, where there was an increase in the
    volume of data breaches or the number of cybersecurity attacks. Treating security
    as something to act upon reactively instead of proactively can cost in terms of
    budget and time for each security incident. There are a few chief reasons that
    capture the root cause of why cybersecurity and DevOps are left in two different
    silos – more manual security intervention during the development process and a
    lack of knowledge of tools. Investing in security is required to comply with standards
    and gain trust. Sacrificing that for speed to market will certainly lead to major
    losses later on. That leads us to the next bridge that needs to be built between
    DevOps and security, forming a DevSecOps alliance. In the same way that Dev and
    Ops merged, security should no longer be considered an afterthought. DevOps principles
    can be inherited to make a security fusion possible. That is how DevSecOps has
    become a new trend. Imagine the whole pressure of security eased across each discipline
    and pointing to the same product goal, armed with automation and faster feedback.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 哲学的**十亿美金**理念就是将人们聚集在一起——包括运营（Ops）、开发（Devs）以及**质量保证**（**QA**）等各个领域。组织应该明确指出在所有产品贡献者之间出现的各个“孤岛”。这应该包括安全领域，确保他们能够在敏捷工作方式中得到体现。*2021年DevSecOps现状*研究（[https://www.securitycompass.com/reports/2021-state-of-devsecops/](https://www.securitycompass.com/reports/2021-state-of-devsecops/)）由网络安全咨询服务公司*Security
    Compass*发布，研究表明，75%的受访者（IT专业人员和DevOps从业者）同意安全性会延缓产品发布流程，从而导致上市时间的增加。这与DevOps的初衷背道而驰。过分注重市场速度可能会忽视安全性。这样的*牺牲*在一些大型企业中引发了一些可怕的统计数据，这些企业在数据泄露或网络安全攻击的数量上出现了增加。将安全性视为反应性而非主动性的问题来处理，每一次安全事件的处理都会带来预算和时间的成本。造成网络安全和DevOps处于两个不同“孤岛”的主要原因有几个——开发过程中需要更多的手动安全干预和对工具的了解不足。投资安全是为了遵守标准并获得信任。为了追求市场速度而牺牲安全，最终肯定会导致后续的重大损失。这就引出了下一个需要在DevOps与安全之间建立的桥梁，形成一个DevSecOps联盟。正如开发和运营已经融合一样，安全性不应再被视为事后的考虑。DevOps的原则可以被继承，以使安全融合成为可能。这就是为什么DevSecOps成为了一种新趋势。想象一下，整个安全压力在各个领域得到缓解，所有部门都指向相同的产品目标，并配备了自动化和更快速的反馈。
- en: We can sum up the right approach for our future OpenStack deployments – DevOps
    with security at different stages of the process, as shown in the following toolchain.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以总结出未来 OpenStack 部署的正确方法——在流程的不同阶段加入安全性的 DevOps，如下所示的工具链。
- en: '![Figure 2.2 – Integrating security into the DevOps toolchain](img/B21716_02_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 将安全性整合到 DevOps 工具链中](img/B21716_02_02.jpg)'
- en: Figure 2.2 – Integrating security into the DevOps toolchain
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 将安全性整合到 DevOps 工具链中
- en: Embracing the deployment of a complex environment such as an OpenStack private
    cloud would require a DevSecOps approach, and a few best practices are covered
    in the next section.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 部署像 OpenStack 私有云这样复杂环境的实现需要采用 DevSecOps 方法，下一节将介绍一些最佳实践。
- en: Securing the cloud – moving with DevSecOps
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 云安全 – 与 DevSecOps 一起前进
- en: Adopting DevOps practices is definitely a big deal to stay competitive in the
    market, increase productivity, and bring new possibilities for innovation. Conversely,
    with a lack of security, any product will be at risk of losing both trust and
    failure. Hence, the DevOps chain must be enforced with security and compliance
    insurance. One of the fundamental aspects of DevOps is automation and reusability.
    In an infrastructure context, we are not dealing with *pets* but with *cattle*
    . The *pets and cattle* analogy is a famous one, with on-prem servers referred
    to as *pets* . If there was any change, update, or failure of that pet server,
    a problem would arise. They are the long-lived and indispensable pieces of the
    infrastructure that should be taken more care of. On the other side of the analogy,
    *cattle* refer to servers in large on-demand environments such as the cloud. A
    cattle failure should not stop the business from running, and cattle can be replaced
    *immediately* . If we adopt the *cattle* analogy servers in the cloud should be
    instrumented to keep them immutable. That is where IaC comes into play. With one
    single source of truth and a shared pipeline, the *Sec* part becomes much easier
    to merge into the *DevOps* flow. With this capability, moving security from the
    right to the left becomes more feasible.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 采用 DevOps 实践无疑是保持市场竞争力、提高生产力并带来创新新可能的重要举措。相反，缺乏安全性将使任何产品面临失去信任和失败的风险。因此，必须加强
    DevOps 链条，确保安全性和合规性。DevOps 的一个基本方面是自动化和可重用性。在基础设施的背景下，我们面对的不是 *宠物* 而是 *牲畜*。*宠物和牲畜*
    类比是一种著名的比喻，指的是将本地服务器称为 *宠物*。如果该宠物服务器发生任何变化、更新或故障，就会引发问题。它们是基础设施中长期存在、不可或缺的部分，需要更多的关怀。另一方面，*牲畜*
    指的是云等大规模按需环境中的服务器。牲畜的故障不应妨碍业务的运行，牲畜可以 *立即* 被替换。如果我们采用 *牲畜* 类比，云中的服务器应该被设计成不可更改的。这就是基础设施即代码（IaC）发挥作用的地方。通过一个单一的真实来源和共享管道，*安全*
    部分更容易与 *DevOps* 流程融合。拥有这一能力后，将安全性从右侧移到左侧变得更加可行。
- en: DevSecOps and OpenStack
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DevSecOps 与 OpenStack
- en: The challenge of deploying a complex OpenStack ecosystem is made easier through
    DevOps, but what should not be overlooked as a cloud provider is protecting the
    first layer that runs a user’s workload(s). As we will explore in the next part
    of this section, there are several ways to deploy a complete OpenStack environment
    from code. Emphasizing security before starting to think about the code structure
    is vital to not miss a DevSecOps opportunity. As a rule of thumb, any code designed
    for an application infrastructure is subject to vulnerabilities. Although the
    different modules of OpenStack services are developed with security in mind, the
    gazillions of ways of configuring and parameterizing within a specific network
    architecture should be tested for security anomalies at every stage. Before welcoming
    any workload on top of the OpenStack infrastructure, the cloud itself must be
    ready with security controls and compliant with major standards.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 部署复杂的 OpenStack 生态系统的挑战通过 DevOps 变得更加简易，但作为云服务提供商，不能忽视的是保护运行用户工作负载的第一层。正如我们将在本节的下一部分探讨的那样，从代码部署完整的
    OpenStack 环境有多种方法。在开始考虑代码结构之前，强调安全性是至关重要的，以免错失 DevSecOps 的机会。一般来说，任何为应用基础设施设计的代码都有可能存在漏洞。尽管
    OpenStack 服务的不同模块在开发时已经考虑到了安全性，但在特定网络架构中配置和参数化的无数种方式都应在每个阶段进行安全性异常测试。在任何工作负载部署到
    OpenStack 基础设施上之前，云本身必须做好安全控制，并符合主要标准。
- en: Coding the cloud
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写云代码
- en: 'One of the biggest challenges of dealing with an OpenStack environment is the
    ways of handling its deployment and daily operations. If you consider a manual
    deployment for even a small environment, then in all likelihood, your OpenStack
    management processes, including updates, will face difficulties that cannot be
    avoided. That is where DevSecOps practices come in, with the fundamental mantra
    of IaC. A consistent approach is to treat the OpenStack ecosystem as code. The
    good news is that OpenStack code is provided with each stable release and is ready
    for deployment once configured and customized. But before we grasp a technical
    deployment, we should take into account a few common considerations to start building
    our toolchain:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 处理 OpenStack 环境时，最大的挑战之一就是如何处理其部署和日常运维。如果你考虑手动部署，即使是一个小型环境，那么很可能你的 OpenStack
    管理流程，包括更新，都将面临不可避免的困难。这时，DevSecOps 实践就派上用场了，其基本口号是 IaC。一个一致的方法是将 OpenStack 生态系统视为代码。好消息是，OpenStack
    代码会随着每个稳定版本发布，并且一旦配置和定制好，就可以准备好部署了。但在我们掌握技术部署之前，我们应该考虑一些常见的注意事项来开始构建我们的工具链：
- en: Map each OpenStack service as code per module.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将每个 OpenStack 服务映射为每个模块的代码。
- en: Define target systems to run OpenStack services with one specific role or several
    roles. For example, a compute role is defined with the Nova service deployed.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义目标系统来运行具有一个特定角色或多个角色的 OpenStack 服务。例如，定义一个计算角色，并部署 Nova 服务。
- en: Draft the initial configuration for each service (role).
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 草拟每个服务（角色）的初始配置。
- en: Think of roles as reusable code that can be deployed in different target environments.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将角色视为可重用的代码，可以在不同的目标环境中部署。
- en: Make sure you integrate functional test stages between role setups.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保在角色设置之间集成功能测试阶段。
- en: Consider the integration of security rules and tools from the start. Map each
    nominated tool in each stage of the pipeline, from coding to the release phases.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一开始就考虑安全规则和工具的集成。将每个指定的工具映射到管道的每个阶段，从编码到发布阶段。
- en: Avoid *Big Bang* coding practices and implement smaller changes in an automated
    continuous deployment fashion.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免 *Big Bang* 编码实践，并以自动化持续部署的方式实现更小的变更。
- en: 'Prepare to continuously monitor the following deployment metrics:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备持续监控以下部署指标：
- en: '**Deployment frequency** : How often IaC is deployed (daily/weekly/monthly)'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署频率**：IaC 部署的频率（每日/每周/每月）'
- en: '**Change lead time** : The window of time starting from the moment code has
    been committed to the time it is successfully deployed'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变更交付时间**：从代码提交时开始到成功部署的时间窗口'
- en: '**Change failure rate** : The total percentage of committed IaC changes leading
    to system impairment or outage (including hotfixes and rollbacks)'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变更失败率**：导致系统损坏或停机的提交 IaC 变更的总百分比（包括热修复和回滚）'
- en: '**Mean Time to Repair** ( **MTTR** ): The time needed to restore service outage
    from the moment it’s impaired'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修复平均时间**（**MTTR**）：从服务中断开始到恢复服务所需的时间'
- en: Use a trunk-based development approach to facilitate code monitor changes and
    increase security visibility integration.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于 trunk 的开发方法来促进代码监控变更，并增加安全性可视化集成。
- en: Important note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Trunk-based software development is a coding practice that allows developers
    to regularly merge changes into a common trunk code base. The trunk-based practice
    dictates more frequent code releases with smaller changes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 trunk 的软件开发是一种编码实践，允许开发人员定期将变更合并到公共的 trunk 代码库中。基于 trunk 的实践要求更频繁的代码发布，并进行较小的变更。
- en: The following section will cover the different tools that will be used to deploy
    an OpenStack environment in the DevSecOps style.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将介绍用于以 DevSecOps 风格部署 OpenStack 环境的不同工具。
- en: Deploying in the cloud
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在云端部署
- en: Since the first release of OpenStack, several deployment tools and wrappers
    have been developed to assist OpenStack operators with more enhanced, easier ways
    to set up a fully running OpenStack environment. With the rise of system management
    tools such as Chef, Puppet, SaltStack, and Ansible, the OpenStack community has
    dedicated different channels to each system management tool to develop different
    classes and modules through the OpenStack ecosystem evolution. Which one of these
    tools we choose is down to familiarity or the technical requirements of cloud
    operators. In this section, Ansible will be the system management tool we use.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 OpenStack 首次发布以来，已经开发了多种部署工具和包装器，帮助 OpenStack 操作员以更增强、更简便的方式设置完全运行的 OpenStack
    环境。随着 Chef、Puppet、SaltStack 和 Ansible 等系统管理工具的兴起，OpenStack 社区已经为每个系统管理工具设立了不同的渠道，通过
    OpenStack 生态系统的演变开发不同的类和模块。我们选择这些工具中的哪一个，取决于熟悉程度或云操作员的技术要求。在本节中，我们将使用 Ansible
    作为系统管理工具。
- en: Ansible in a nutshell
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible 简介
- en: 'Like any other system management tool, Ansible uses its own glossary and terms
    to define infrastructure components, modules, relationships, and parameters. Conversely,
    unlike other tools, Ansible comes with a simple architecture setup that makes
    it a popular choice, and it can be summarized as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他任何系统管理工具一样，Ansible 使用自己的词汇和术语来定义基础设施组件、模块、关系和参数。相反，与其他工具不同，Ansible 拥有简单的架构设置，这使得它成为一种流行的选择，可以总结如下：
- en: It has the flexibility to handle interdependent complex service modules.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有处理相互依赖的复杂服务模块的灵活性。
- en: It uses an agentless transport mechanism to connect and update target systems
    without the need to install additional packages. It exposes only the *master*
    server where the Ansible software is running.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用无代理传输机制连接和更新目标系统，无需安装额外的软件包。它仅暴露运行 Ansible 软件的 *主* 服务器。
- en: Modules executed on target systems are auto-cleaned once installed.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在目标系统上执行的模块安装后会自动清理。
- en: It is rich in core automation modules to extend more features.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它拥有丰富的核心自动化模块，以扩展更多功能。
- en: The infrastructure collection code written in YAML is organized in Ansible playbooks.
    YAML is easier to learn and master than other languages, such as Ruby for Chef.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用 YAML 编写的基础设施代码被组织在 Ansible playbooks 中。YAML 比其他语言（如 Chef 的 Ruby）更容易学习和掌握。
- en: Due to the simplicity of the Ansible architecture, scalability is much simpler
    to implement compared to other tools that require running agents.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 Ansible 架构的简单性，扩展性比其他需要运行代理的工具更容易实现。
- en: As a declarative method of programming, it focuses on describing the output
    of the desired state, rather than diving into how to do it and which steps must
    be taken to reach the resulting output.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一种声明式编程方法，它专注于描述期望状态的输出，而不是深入探讨如何实现这一目标以及必须采取哪些步骤才能达到预期的输出。
- en: 'When dealing with the complexity of the OpenStack ecosystem, with all its sets
    of components, subcomponents, and parameter flavors, it is essential to briefly
    skim the surface of the Ansible terminology :'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理复杂的 OpenStack 生态系统时，考虑到其中的所有组件、子组件和参数类型，了解 Ansible 术语的基本概念至关重要：
- en: '**Playbooks** : These consist of the main configuration file(s) that describes
    a series of actions to run on one or a group of hosts. The tasks are written in
    YAML and executed in order, from top to bottom, to accomplish full deployment
    or a configuration change.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Playbooks**：这些由描述在一个或一组主机上运行一系列操作的主要配置文件组成。任务以 YAML 编写，并按照从上到下的顺序执行，以完成全面部署或配置更改。'
- en: '**Roles** : These present the organizational structure of playbooks by collecting
    different Ansible assets, such as tasks, variables, and modules, to deploy a service
    on one or a group of hosts.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角色**：这些通过收集不同的 Ansible 资源（如任务、变量和模块）来呈现 playbooks 的组织结构，以便在一个或一组主机上部署服务。'
- en: '**Modules** : These are an abstract representation of a specific unit of code
    functionality. Modules can be written and customized to control system resources,
    files, and services. Ansible is shipped with some modules referred to as module
    libraries (core modules) that can be executed via customized playbooks.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块**：这些是特定代码功能单元的抽象表示。模块可以编写和定制，以控制系统资源、文件和服务。Ansible 附带了一些模块，称为模块库（核心模块），可以通过定制的
    playbooks 执行。'
- en: '**Variables** : These are dynamic values used in roles and playbooks to reflect
    the desired configuration. Similar to programming language variables, Ansible
    variables enable the propagation of different states across different environments
    through the same role or playbook.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量**：这些是用于角色和 playbook 中的动态值，用来反映所需的配置。类似于编程语言中的变量，Ansible 变量通过相同的角色或 playbook
    使不同的状态在不同环境中传播。'
- en: '**Inventory** : This is a listing of managed hosts in the target environment.
    Ansible uses a configuration file in the **INI** format, which defines the name
    and IP of the managed target host. Hosts can be declared in inventory files using
    different patterns by nesting hosts by role, or by specifying a series of hosts
    via a combination and numeric patterns.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**库存**：这是目标环境中已管理主机的列表。Ansible 使用 **INI** 格式的配置文件，定义了已管理目标主机的名称和 IP。可以通过不同的模式在库存文件中声明主机，或通过角色嵌套主机，或通过组合和数字模式指定一系列主机。'
- en: 'The CI/CD system triggers Ansible to install and run playbooks across target
    OpenStack nodes defined in its inventory, as depicted in the following figure:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD 系统触发 Ansible 安装并在其库存中定义的目标 OpenStack 节点上运行 playbook，如下图所示：
- en: '![Figure 2.3 – An OpenStack environment management through Ansible](img/B21716_02_03.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 通过 Ansible 管理 OpenStack 环境](img/B21716_02_03.jpg)'
- en: Figure 2.3 – An OpenStack environment management through Ansible
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 通过 Ansible 管理 OpenStack 环境
- en: Integrating system management tools such as Ansible in OpenStack ecosystem life
    cycle management has introduced a significant change in the way such a complex
    ecosystem is managed and operated. Not surprisingly, the hunger to move quickly
    to adopt a private cloud setup and maximize the agility of its deployment has
    led to other challenges. That brings us to the root causes of OpenStack-tied dependencies
    between services. Thinking long term, the development of new OpenStack releases
    and feature integrations in an existing environment presents one of the ultimate
    challenges for a private cloud operation mission. Driving major upgrades has always
    been a blocker to seamlessly jumping to a new OpenStack release in a running production
    setup. That makes the upgrade case a very cautious operation and puts your **Service-Level
    Agreement** ( **SLA** ) at risk if one or several dependencies crash, due to a
    code compatibility version that has been overlooked. Although tests can help to
    identify such anomalies, a massive number of tests for each component should be
    in place in advance, and that could be costly in terms of resources and human
    interactions. The other facet of these challenges is the lack of rollback mechanisms.
    Rolling back a change that causes an issue will definitely bring one or several
    parts of a whole system down, as you wait for your management tools to redeploy,
    restart the affected services, and test and wait for a complete synchronization
    between other dependent services to run them again. The most common OpenStack
    deployment options involve bare-metal machines or virtual machines, making such
    operational tasks heavier to roll, requiring full management of machine images,
    and it becomes costly when testing in an isolated environment. For example, upgrading
    or updating an OpenStack component version would require all inter-dependent services
    to be deployed in a different testing environment before propagating the change
    in the production one. Within the latest OpenStack releases, several organizations
    have been experimenting with the rise of containers for a fully containerized
    OpenStack cloud. Let’s unleash the container dilemma in the next section and explore
    what opportunities are in store for OpenStack deployment and management.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenStack 生态系统生命周期管理中集成 Ansible 等系统管理工具，带来了对如此复杂生态系统管理和操作方式的重大变革。毫不奇怪，快速迁移到采用私有云设置并最大化其部署灵活性的需求，带来了其他挑战。这引出了
    OpenStack 服务之间依赖关系的根本原因。从长远来看，开发新的 OpenStack 版本和将新功能集成到现有环境中，成为私有云操作任务的终极挑战之一。推动大规模升级一直是顺利迁移到新
    OpenStack 版本时的障碍，尤其是在生产环境中运行时。这使得升级操作变得非常谨慎，并且如果其中一个或多个依赖项因版本兼容性问题崩溃，可能会让你的**服务级别协议**（**SLA**）面临风险。尽管测试可以帮助识别此类异常，但每个组件需要提前进行大量的测试，这在资源和人工互动上会非常昂贵。另一个方面的挑战是缺乏回滚机制。回滚一个导致问题的更改必然会导致系统的某些部分或整个系统崩溃，因为你需要等待管理工具重新部署、重启受影响的服务、测试并等待其他依赖服务之间的完全同步，才能重新运行它们。最常见的
    OpenStack 部署选项包括裸金属机器或虚拟机，使得此类操作任务更加复杂，需要全面管理机器镜像，并且在隔离环境中进行测试时会增加成本。例如，升级或更新
    OpenStack 组件版本时，需要在不同的测试环境中部署所有相互依赖的服务，然后再在生产环境中传播更改。在最新的 OpenStack 版本中，一些组织已经开始尝试使用容器化的方式构建完全容器化的
    OpenStack 云。让我们在下一节解锁容器难题，探索 OpenStack 部署和管理的潜在机会。
- en: Containerizing the cloud
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器化云计算
- en: Container technology has been around for more than a decade, and companies have
    started deploying their workloads in containers to take advantage of resource
    optimization, environment isolation, and portability. Running different pieces
    of your software in lightweight, self-contained, and independent containers brings
    more flexibility to managing a complex software system. Running in an isolated
    mode, operations such as upgrades and rolling back become much easier and can
    be performed with more confidence.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 容器技术已经存在超过十年，企业开始将工作负载部署到容器中，以便利用资源优化、环境隔离和可移植性。将软件的不同部分运行在轻量级、自包含和独立的容器中，为管理复杂的软件系统带来了更大的灵活性。在隔离模式下运行时，像升级和回滚这样的操作变得更加容易，并且可以更有信心地执行。
- en: 'By referring to our infrastructure code, we can see the benefit of the OpenStack
    software architecture’s modular design, which offers a great deal by taking advantage
    of container technology, where each module can live in a separate, stateless environment.
    Looking at the current state of container trends, an extended list of container
    and orchestration engines can be found, such as LXC, Docker, and Kubernetes. The
    OpenStack community did not miss the chance to adopt containerization technology
    early on, when containers started to become the standard for modern software development.
    Within the Antelope and later releases, we can find several deployment methods
    based on containers, combined with configuration management tools, as summarized
    in the following table:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过参考我们的基础设施代码，我们可以看到OpenStack软件架构的模块化设计的优势，利用容器技术，每个模块可以在一个独立、无状态的环境中运行。通过查看当前容器趋势，可以找到一系列容器和编排引擎，如LXC、Docker和Kubernetes。OpenStack社区没有错过容器化技术的早期采用机会，尤其是在容器开始成为现代软件开发标准时。在Antelope及后续版本中，我们可以找到多种基于容器的部署方法，这些方法结合了配置管理工具，具体总结如下表：
- en: '| **Deployment project** | **Container** | **Project** | **Source** |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| **部署项目** | **容器** | **项目** | **来源** |'
- en: '| OpenStack-Ansible | LXC | Ansible | [https://docs.openstack.org/openstack-ansible/latest/](https://docs.openstack.org/openstack-ansible/latest/)
    |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| OpenStack-Ansible | LXC | Ansible | [https://docs.openstack.org/openstack-ansible/latest/](https://docs.openstack.org/openstack-ansible/latest/)
    |'
- en: '| Kolla-Ansible | Docker | Ansible | [https://docs.openstack.org/kolla-ansible/latest/](https://docs.openstack.org/kolla-ansible/latest/)
    |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| Kolla-Ansible | Docker | Ansible | [https://docs.openstack.org/kolla-ansible/latest/](https://docs.openstack.org/kolla-ansible/latest/)
    |'
- en: '| OpenStack-Helm | Docker | Kubernetes and Helm | [https://docs.openstack.org/openstack-helm/latest/](https://docs.openstack.org/openstack-helm/latest/)
    |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| OpenStack-Helm | Docker | Kubernetes和Helm | [https://docs.openstack.org/openstack-helm/latest/](https://docs.openstack.org/openstack-helm/latest/)
    |'
- en: '| Triple-O (currently no longer supported) | Docker | Ansible | [https://docs.openstack.org/tripleo-ansible/latest/](https://docs.openstack.org/tripleo-ansible/latest/)
    |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| Triple-O（目前不再支持） | Docker | Ansible | [https://docs.openstack.org/tripleo-ansible/latest/](https://docs.openstack.org/tripleo-ansible/latest/)
    |'
- en: Table 2.1 – A list of OpenStack deployment tools running containers
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1 – 运行容器的OpenStack部署工具列表
- en: The **OpenStack-Ansible** ( **OSA** ) project is one of the most widespread
    deployments based on LXC containers. The deployment of LXC containers running
    OpenStack services is orchestrated by Ansible.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenStack-Ansible** (**OSA**) 项目是基于LXC容器最广泛使用的部署之一。运行OpenStack服务的LXC容器的部署由Ansible进行编排。'
- en: In our next deployment, we will adopt another emerging OpenStack project, named
    **Kolla-Ansible** . Similarly to OSA, the Kolla project uses Docker as a containerization
    tool by building a Docker container for each OpenStack service. Besides the design
    differences between LXC and Docker, Kolla extends the parameterization layout,
    making its containers more configurable, with an array of choices between the
    base operating system and template engines. This is not to mention Docker’s design
    advantages as a container technology, with the layered nature of its images, versioning,
    and portability for sharing capabilities.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个部署中，我们将采用另一个新兴的OpenStack项目，名为**Kolla-Ansible**。与OSA类似，Kolla项目使用Docker作为容器化工具，为每个OpenStack服务构建一个Docker容器。除了LXC和Docker之间的设计差异外，Kolla扩展了参数化布局，使其容器更加可配置，提供了基础操作系统和模板引擎之间的一系列选择。更不用说Docker作为容器技术的设计优势，其镜像的分层特性、版本控制和便于共享的可移植性。
- en: Important note
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Kolla has been integrated officially within the OpenStack subproject since the
    Liberty release. As per the official OpenStack definition of the Kolla project,
    *“Kolla’s mission is to provide production-ready containers and deployment tools
    for operating* *OpenStack clouds.”*
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Kolla自Liberty版本以来正式集成进OpenStack子项目。根据OpenStack官方对Kolla项目的定义，*“Kolla的使命是提供用于操作*
    *OpenStack云的生产就绪容器和部署工具。”*
- en: Those extra advantages make Docker more suitable for our deployment pipeline,
    where we will deal with a container service as an artifact that can be easily
    deployed through different environments, before promoting it to a production environment.
    As depicted in the following high-level schema, for each merged change in the
    code repository, the CI/CD tool builds an artifact composed of a software package
    encapsulated in a Docker image. The generated image will be committed to a private
    Docker registry, where Ansible will download it and orchestrate its setup in the
    designated OpenStack node.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些额外的优势使得Docker更适合我们的部署管道，在这个管道中，我们将处理作为工件的容器服务，该工件可以通过不同的环境轻松部署，然后再推广到生产环境。如以下高层次架构图所示，对于每次合并的代码库变更，CI/CD工具会构建一个由封装在Docker镜像中的软件包组成的工件。生成的镜像将被提交到私有Docker注册表，Ansible会下载该镜像并在指定的OpenStack节点中进行部署。
- en: '![Figure 2.4 – High-level CI/CD pipeline OpenStack deployment](img/B21716_02_04.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – 高层次CI/CD管道OpenStack部署](img/B21716_02_04.jpg)'
- en: Figure 2.4 – High-level CI/CD pipeline OpenStack deployment
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 高层次CI/CD管道OpenStack部署
- en: The other component of the deployment tool stack is the **Jinja2** templating
    tool. This is mainly used by Docker for the dynamic assignment of variables, based
    on defined parameters generated by Ansible. Jinja2 is designed mainly for Dockerfiles
    to support full system call interface compatibility for both RPM and DEB container
    distributions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 部署工具栈的另一个组件是**Jinja2**模板工具。它主要由Docker用于基于Ansible生成的定义参数动态分配变量。Jinja2主要设计用于Dockerfile，以支持RPM和DEB容器分发版的完整系统调用接口兼容性。
- en: Important note
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Jinja2 templating in the Kolla context provides an array of ways of building
    Docker images of different source distributions, including CentOS, Debian, Fedora,
    Ubuntu, and RHEL container operating systems that can be parameterized per OpenStack
    service code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kolla环境中使用Jinja2模板提供了多种构建不同源分发的Docker镜像的方法，包括CentOS、Debian、Fedora、Ubuntu和RHEL容器操作系统，这些镜像可以按OpenStack服务代码进行参数化配置。
- en: As our main motivation is to solve the complexity of dependencies and provide
    a simpler and more scalable development experience, Kolla is the way to go, and
    indeed since its official first stable release, several production deployments
    have been performed the Kolla way.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的主要目标是解决依赖关系的复杂性，并提供更简单、更具可扩展性的开发体验，Kolla是最佳选择。事实上，自从Kolla正式发布第一个稳定版本以来，已经有多个生产环境的部署按照Kolla方式进行。
- en: Building the picture
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建图像
- en: Treating OpenStack deployment as IaC will help us to inherit and use most of
    the software tools and processes to deliver code artifacts, ready for deployment,
    with more confidence. Having a robust integration and deployment pipeline is vital
    to ensure that our software-defined data center does not fail on production day.
    Modern software development techniques involve several tools that increase automation
    and agility and, hence, faster feedback between each deployment.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将OpenStack部署视为IaC将帮助我们继承并使用大多数软件工具和流程，以更有信心地交付准备好的代码工件以进行部署。拥有强大的集成和部署管道对于确保我们的软件定义数据中心在生产日不发生故障至关重要。现代软件开发技术涉及多个工具，这些工具提高了自动化和敏捷性，从而加快了每次部署之间的反馈。
- en: 'The following tools will be employed for our OpenStack infrastructure code
    development:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下工具将用于我们的OpenStack基础设施代码开发：
- en: '**A version control system** : GitHub will be our code repository for the OpenStack
    infrastructure code.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制系统**：GitHub将作为我们OpenStack基础设施代码的代码库。'
- en: '**A CI/CD tool** : Jenkins will be installed on the deployer machine and grant
    extra plugins to build and run deployment pipelines.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CI/CD工具**：Jenkins将安装在部署机上，并提供额外的插件来构建和运行部署管道。'
- en: '**A system management tool** : The Ansible packages will be installed on the
    deployer machine and provide the OpenStack playbooks to be deployed inside the
    containers, in tandem with Kolla.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统管理工具**：Ansible包将安装在部署机上，并提供要在容器内部署的OpenStack剧本，与Kolla一起使用。'
- en: '**An image builder** : Dedicated to OpenStack containers, Kolla builds container
    images running different OpenStack services.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**镜像构建器**：专门用于OpenStack容器，Kolla构建运行不同OpenStack服务的容器镜像。'
- en: 'The Kolla-Ansible project code repository will be our starting point for the
    first OpenStack deployment, with minimum customization to have a rolling deployment
    pipeline initially. The official latest master stable branch of the project code
    can be found here: [https://github.com/openstack/kolla-ansible](https://github.com/openstack/kolla-ansible)
    .'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Kolla-Ansible 项目的代码库将作为我们首次 OpenStack 部署的起点，最小化定制以便最初拥有一个滚动部署管道。该项目代码的最新稳定主分支可以在此找到：[https://github.com/openstack/kolla-ansible](https://github.com/openstack/kolla-ansible)。
- en: Kolla-Ansible supports both all-in-one as well as multi-node OpenStack setups.
    As we’re aiming for a production setup, as discussed in the initial design draft
    in [*Chapter 1*](B21716_01.xhtml#_idTextAnchor014) , *Revisiting OpenStack –Design
    Considerations* , we will make sure our initial draft is the first deployment
    iteration ready for deployment.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Kolla-Ansible 支持一体化和多节点的 OpenStack 设置。由于我们目标是生产设置，如 [*第一章*](B21716_01.xhtml#_idTextAnchor014)《重新审视
    OpenStack - 设计考虑》中的初步设计草案所讨论的，我们将确保我们的初步草案准备好进行首次部署迭代。
- en: Setting up a development environment
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置开发环境
- en: Setting up a development environment mimicking a production one is highly recommended
    to ensure faster feedback during the development stages, as well as to fix any
    anomalies in code before promoting it to a production setup. Although running
    services in a container increases the flexibility of rolling back if issues are
    detected after deployment into production, a best practice is to act proactively
    by running service containers in an isolated environment through different deployment
    and testing stages. Upon successful deployment in the test environment, services’
    containers will be promoted and tagged as production-ready for deployment.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个模拟生产环境的开发环境是强烈推荐的，以确保在开发阶段更快速地反馈，并在将代码推向生产设置之前修复任何异常。虽然将服务运行在容器中增加了在生产环境中检测到问题后回滚的灵活性，但最佳实践是通过不同的部署和测试阶段在隔离环境中运行服务容器，采取主动措施。在测试环境中成功部署后，服务容器将被提升并标记为可用于生产部署。
- en: Depending on how many physical machines will be invested in your development
    environments, the DevSecOps team will require an isolated environment for each
    member to run tests, before committing their changes to a main development branch
    that targets deployment in the development environment.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 根据开发环境将投入多少台物理机器，DevSecOps 团队将要求为每个成员提供一个隔离的环境，以便在将其更改提交到主要开发分支之前进行测试，该分支目标是在开发环境中进行部署。
- en: Preparing the local environment
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备本地环境
- en: Vagrant is a revolutionary tool created by HashiCorp that can create, modify,
    and manage visualized environments through simple Vagrant command lines. The other
    exciting part of Vagrant is managing a local development environment through it.
    Vagrant configuration is highly customizable and supports a variety of local hypervisors
    to run virtual machines, such as VirtualBox, HyperV, and VMware.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant 是由 HashiCorp 创建的一种革命性工具，可以通过简单的 Vagrant 命令行创建、修改和管理可视化环境。Vagrant 的另一个令人兴奋的部分是通过它来管理本地开发环境。Vagrant
    配置高度可定制，支持多种本地虚拟化软件运行虚拟机，如 VirtualBox、HyperV 和 VMware。
- en: 'Our next setup will consider a local VirtualBox environment, depending on your
    development operating system machine; most Linux, Mac, and Windows distributions
    are supported and can be found here: [https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads)
    .'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个设置将考虑本地 VirtualBox 环境，具体取决于你的开发操作系统机器；大多数 Linux、Mac 和 Windows 发行版都被支持，可以在这里找到：[https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads)。
- en: 'Once VirtualBox is installed, download the base image where the OpenStack environment
    will run. A good practice for VirtualBox development in Vagrant is to use the
    same operating system distribution for both the development and production environments.
    The chosen operating system in the next setup is Ubuntu **22.04 LTS** . In the
    following wizard, we will go through the different steps to prepare the Vagrant
    file before starting to deploy a local OpenStack environment:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 VirtualBox 后，下载 OpenStack 环境将运行的基础镜像。对于 Vagrant 中的 VirtualBox 开发，最佳实践是开发环境和生产环境使用相同的操作系统发行版。在接下来的设置中，选择的操作系统是
    Ubuntu **22.04 LTS**。在以下的向导中，我们将逐步准备 Vagrant 文件，准备开始部署本地 OpenStack 环境：
- en: 'Generate a Vagrant file by firing the following command line:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令行生成 Vagrant 文件：
- en: '[PRE0]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Modify the **box** stanza configuration section by providing the operating
    system image:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 **box** 配置段，通过提供操作系统镜像来进行配置：
- en: '[PRE1]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Important note
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Vagrant boxes can be created locally by backing up an image of any operating
    system, using tools such as **Packer** . Vagrant boxes can be shared and tagged
    with the version in the Vagrant cloud repository, as detailed here: [https://developer.hashicorp.com/vagrant/vagrant-cloud/boxes/create](https://developer.hashicorp.com/vagrant/vagrant-cloud/boxes/create)
    .'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过备份任何操作系统的镜像来在本地创建 Vagrant box，使用的工具如 **Packer**。Vagrant box 可以在 Vagrant
    云库中共享，并标记版本，详细信息请参见：[https://developer.hashicorp.com/vagrant/vagrant-cloud/boxes/create](https://developer.hashicorp.com/vagrant/vagrant-cloud/boxes/create)。
- en: 'The local development machine should have a minimum of hardware specs, such
    as RAM and CPU, to accommodate a minimal setup of an OpenStack environment, as
    depicted in the following Vagrant configuration section:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地开发机器应具备最低硬件规格，如 RAM 和 CPU，以支持 OpenStack 环境的最小配置，具体配置请参见以下 Vagrant 配置段：
- en: '[PRE2]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Set the virtual disk space to a minimum of 50 GB in the new **box** stanza
    line:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的 **box** 配置段行中，将虚拟磁盘空间设置为至少 50 GB：
- en: '[PRE3]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Important note
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Make sure to have the **vagrant-disksize** plugin installed by running the following
    command line – **vagrant plugin** **install vagrant-disksize** .
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 确保已安装 **vagrant-disksize** 插件，可以通过运行以下命令行来安装：**vagrant plugin** **install vagrant-disksize**。
- en: 'Optionally, add a synced folder to sync the OpenStack infrastructure code on
    the development machine:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，添加一个同步文件夹，将开发机器上的 OpenStack 基础设施代码同步：
- en: '[PRE4]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Important note
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Make sure the synced folder in the local machine exists by creating the **openstack_deploy**
    folder.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 确保本地机器中的同步文件夹存在，可以通过创建 **openstack_deploy** 文件夹来实现。
- en: 'Networking can be configured to forward port access to specific services from
    the development machine to the guest box. Accessing OpenStack Horizon, for example,
    would require port forwarding on port **80** from the guest machine, which can
    be adjusted as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以配置网络以转发端口访问，允许从开发机器到来宾 box 特定服务的访问。例如，访问 OpenStack Horizon 需要将端口 **80** 从来宾机器进行端口转发，可以按以下方式调整：
- en: '[PRE5]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Start the Vagrant box by firing the following command line:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令行来启动 Vagrant box：
- en: '[PRE6]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once started without errors, the Vagrant box is ready for access. The default
    login uses a Vagrant user that can be elevated to root to proceed with the next
    setup:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦启动且没有错误，Vagrant box 就可以访问了。默认的登录使用的是 Vagrant 用户，可以提升为 root 以继续进行下一步设置：
- en: '[PRE7]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once the Vagrant box is up and running, you should be able to start installing
    the required packages to deploy an all-in-one OpenStack environment.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Vagrant box 启动并运行，您应该能够开始安装部署一体机 OpenStack 环境所需的软件包。
- en: Running the local cloud
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行本地云
- en: 'The Kolla-Ansible project code includes different ways of installing OpenStack
    in all-in-one or multi-nodes. As part of the infrastructure code process, we will
    adjust a few settings to run an all-in-one mode on the development machine. But
    first, we need to install the Git package on our local development host:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Kolla-Ansible 项目代码包含了多种在一体机或多节点上安装 OpenStack 的方式。作为基础设施代码的一部分，我们将调整一些设置，以便在开发机器上运行一体机模式。但首先，我们需要在本地开发主机上安装
    Git 包：
- en: '[PRE8]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Clone the OpenStack-Kolla repository to the designated local folder setup created
    in the previous section. The Vagrant configuration file will make any changes
    to the local folder, **openstack_deploy/** , visible to the guest box. Ideally,
    cloning the repositories should be done from your local Git server of choice.
    In this example, a private Git repository is used ( **ci.os** ). The following
    command clones the local repository running on the CI/CD instance:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将 OpenStack-Kolla 仓库克隆到先前设置的本地文件夹中。Vagrant 配置文件将使对本地文件夹 **openstack_deploy/**
    的任何更改对来宾 box 可见。理想情况下，克隆仓库应从您选择的本地 Git 服务器进行。在此示例中，使用了一个私有 Git 仓库（**ci.os**）。以下命令克隆运行在
    CI/CD 实例上的本地仓库：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Important note
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Here is a simple guide to optionally set up a local Git server running NGINX
    on the latest version of Ubuntu: [https://www.howtoforge.com/tutorial/ubuntu-git-server-installation/](https://www.howtoforge.com/tutorial/ubuntu-git-server-installation/)
    . The local Git server uses the latest stable master branch, cloned locally from
    the Kolla-Ansible repository: [https://github.com/openstack/kolla-ansible.git](https://github.com/openstack/kolla-ansible.git)
    .'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的指南，可选地设置一个本地 Git 服务器，运行 NGINX，并使用最新版本的 Ubuntu：[https://www.howtoforge.com/tutorial/ubuntu-git-server-installation/](https://www.howtoforge.com/tutorial/ubuntu-git-server-installation/)。本地
    Git 服务器使用从 Kolla-Ansible 仓库克隆的最新稳定主分支：[https://github.com/openstack/kolla-ansible.git](https://github.com/openstack/kolla-ansible.git)。
- en: 'Optionally, create your development branch from the master to track local changes
    before pushing them to the next development branch:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，从主分支创建你的开发分支，以便在将本地更改推送到下一个开发分支之前进行追踪：
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Important note
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Ideally, pushed changes should be made in a dedicated development branch of
    your choice before propagating them to the master branch.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，应在你选择的专用开发分支中进行更改，然后再将更改合并到主分支中。
- en: 'Log in to your Vagrant box and proceed to install environment dependencies
    and create a virtual environment. Make sure to change the path of your environment
    on the guest host:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到你的 Vagrant box，并继续安装环境依赖项并创建虚拟环境。确保更改来宾主机上环境的路径：
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Install Ansible. Make sure a minimum version of 2.16 is installed:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Ansible。确保安装至少 2.16 版本：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Install the **kolla-ansible** runtime:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 **kolla-ansible** 运行时：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Since OpenStack Yoga, a few additional dependencies need to be installed, which
    can be solved by running the following command line:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 从 OpenStack Yoga 开始，需要安装一些额外的依赖项，可以通过运行以下命令行来解决：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The Kolla-Ansible repository comes with two essential files that we will edit
    to run our local deployment – **globals.yml** and **passwords.yml** . Copy the
    files to a directory of your choice, which can be created, and make sure that
    the running guest user owns the files:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Kolla-Ansible 仓库包含两个我们需要编辑的关键文件来运行本地部署——**globals.yml** 和 **passwords.yml**。将这些文件复制到你选择的目录中（该目录可以新建），并确保运行中的来宾用户拥有这些文件：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The **globals.yml** file includes several settings and adjustable configurations
    for different OpenStack control plane services, as well as shared ones. As part
    of our minimal test environment, we will edit the following settings to the copied
    **globals.yml** file under the **/** **etc/** **kolla/** folder:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**globals.yml** 文件包含了多个设置和可调配置，适用于不同的 OpenStack 控制平面服务以及共享服务。作为我们最小化测试环境的一部分，我们将在
    **/** **etc/** **kolla/** 文件夹下的复制 **globals.yml** 文件中编辑以下设置：'
- en: 'Use Ubuntu to run as the base Linux distribution for the containers:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ubuntu 作为容器的基础 Linux 发行版：
- en: '[PRE16]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Ensure that HAProxy is out of the scope of our initial setup in the test environment:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保 HAProxy 不在我们初始设置的测试环境范围内：
- en: '[PRE17]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Select the network interface name to be assigned for all types of OpenStack
    networks:'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择要分配给所有类型 OpenStack 网络的网络接口名称：
- en: '[PRE18]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Dedicate a second interface for the Neutron external network:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Neutron 外部网络分配一个专用接口：
- en: '[PRE19]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Assign a Keepalived floating IP, which should be reserved as a virtual IP for
    HA:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配一个 Keepalived 浮动 IP，这应该保留作为 HA 的虚拟 IP：
- en: '[PRE20]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The **passwords.yml** file centralizes all the OpenStack purposes and other
    services’ passwords. To generate random password sets in one command instead of
    running them manually for each, Kolla comes with a simple command tool that generates
    passwords, which will be used during the deployment, as follows:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**passwords.yml** 文件集中存储所有 OpenStack 相关用途及其他服务的密码。为了通过一条命令生成随机密码集，而不是手动为每个密码生成，Kolla
    提供了一个简单的命令工具来生成密码，这些密码将在部署过程中使用，如下所示：'
- en: '[PRE21]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Make sure that the generated passwords are saved in the **passwords.yml** file
    under your custom directory.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保将生成的密码保存在你自定义目录下的 **passwords.yml** 文件中。
- en: 'The other crucial file is under the **inventory** folder, which describes and
    instructs Kolla-Ansible on which hosts will be the target to apply the configuration.
    Inventory files are defined with the Ansible host group format and can be customized,
    based on the available hosts and assigned roles. The default available files are
    designed to run inventories for all-in-one and multi-hosts. To run a clean host
    target setup, make a copy of the files under the **inventory** directory:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关键文件位于**inventory**文件夹中，描述并指示 Kolla-Ansible 哪些主机将是应用配置的目标。库存文件使用 Ansible
    主机组格式定义，可以根据可用主机和分配的角色进行自定义。默认的可用文件设计用于运行所有-in-one 和多主机的库存。要运行干净的主机目标设置，请复制**inventory**目录下的文件：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The all-in-one Ansible inventory file will not require any changes for our
    development setup purposes. The format of the file is straightforward, where each
    host role section describes the name of the host or IP address. For the local
    test environment, all host roles will be configured with **localhost** , as shown
    in the following snippet:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的开发设置目的，all-in-one Ansible 库存文件不需要任何更改。该文件的格式非常简单，每个主机角色部分描述主机的名称或 IP 地址。对于本地测试环境，所有主机角色将配置为**localhost**，如以下片段所示：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Fire the **kolla-ansible** command line to install the bootstrap servers. The
    command will run the Ansible playbook against each host-assigned role in the inventory
    file. So far, all roles are gathered in the same localhost:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 执行**kolla-ansible**命令行以安装引导服务器。该命令将对库存文件中分配给每个主机角色的主机运行 Ansible playbook。到目前为止，所有角色都汇集在同一个
    localhost 上：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following is the output:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![Figure 2.5 – The kolla-ansible bootstrap servers’ output](img/B21716_02_05.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – kolla-ansible 引导服务器输出](img/B21716_02_05.jpg)'
- en: Figure 2.5 – The kolla-ansible bootstrap servers’ output
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – kolla-ansible 引导服务器输出
- en: 'Optionally, run a few deployment checks to closely monitor the bootstrapping
    process and detect possible failures:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，运行一些部署检查，以密切监控引导过程并检测可能的失败：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here’s the output:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '![Figure 2.6 – The kolla-ansible prechecks’ output](img/B21716_02_06.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – kolla-ansible 预检查输出](img/B21716_02_06.jpg)'
- en: Figure 2.6 – The kolla-ansible prechecks’ output
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – kolla-ansible 预检查输出
- en: 'Once the bootstrapping process is finished without any detected failures, perform
    the deployment of the OpenStack environment, which will take a long time to create
    all the containers’ services and chain them together:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦引导过程完成且没有检测到任何失败，即可执行 OpenStack 环境的部署，这将需要较长时间来创建所有容器服务并将其链在一起：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here’s the output:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '![Figure 2.7 – The kolla-ansible deployment output](img/B21716_02_07.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7 – kolla-ansible 部署输出](img/B21716_02_07.jpg)'
- en: Figure 2.7 – The kolla-ansible deployment output
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – kolla-ansible 部署输出
- en: Important note
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: The Ansible deployment will apply the playbooks and OpenStack roles using container
    images from the default OpenStack Docker repository. For the next development
    stage, make sure to build and push further images to a local repository. The next
    sections and chapters will discuss how to build local container images for different
    services and manage them locally.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 部署将应用 playbook 和 OpenStack 角色，使用来自默认 OpenStack Docker 仓库的容器镜像。对于下一个开发阶段，请确保构建并推送更多镜像到本地仓库。接下来的章节将讨论如何为不同服务构建本地容器镜像并进行本地管理。
- en: 'The deployment of the minimal setup of the OpenStack containers should result
    in zero failures by the end of the **kolla-ansible deploy** command line. The
    following Docker command line lists all the running containers deployed in the
    previous step that should be noted as healthy. Some containers will still be in
    the process of communicating with other system services, which will take a few
    minutes, before starting to evaluate the OpenStack services:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: OpenStack 容器的最小部署设置应在**kolla-ansible deploy**命令行结束时没有任何失败。以下的 Docker 命令行列出了在前一步部署中所有正在运行的容器，这些容器应被视为健康。某些容器仍在与其他系统服务进行通信，这将需要几分钟时间，才能开始评估
    OpenStack 服务：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here’s the output:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '![Figure 2.8 – A list of the running OpenStack service containers](img/B21716_02_08.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8 – 正在运行的 OpenStack 服务容器列表](img/B21716_02_08.jpg)'
- en: Figure 2.8 – A list of the running OpenStack service containers
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – 正在运行的 OpenStack 服务容器列表
- en: 'Let’s try to see OpenStack running in containers by firing a client test command.
    To fire a quick test, install the OpenStack client package:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过运行客户端测试命令来查看 OpenStack 是否在容器中运行。要进行快速测试，请安装 OpenStack 客户端包：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To interact with OpenStack API services, admin credentials are required, which
    can be generated by the **kolla-ansible post deploy** command, as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要与 OpenStack API 服务交互，必须使用管理员凭据，这些凭据可以通过 **kolla-ansible 后部署** 命令生成，如下所示：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here’s the result:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是结果：
- en: '![Figure 2.9 – The kolla-ansible OpenStack post-deployment output](img/B21716_02_09.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.9 – kolla-ansible OpenStack 部署后的输出](img/B21716_02_09.jpg)'
- en: Figure 2.9 – The kolla-ansible OpenStack post-deployment output
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 – kolla-ansible OpenStack 部署后的输出
- en: 'The previous command will generate the **cloud.yaml** file, which contains
    different OpenStack admin credentials to interact with OpenStack services via
    the client command line. The content of the file variables can be populated by
    exporting the path of the generated **cloud.yaml** file, as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将生成 **cloud.yaml** 文件，该文件包含与 OpenStack 服务交互的不同 OpenStack 管理员凭据。文件变量的内容可以通过导出生成的
    **cloud.yaml** 文件的路径来填充，如下所示：
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Validate the running OpenStack environment by listing, for example, the **nova**
    host:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通过列出正在运行的 OpenStack 环境，例如 **nova** 主机，来验证环境：
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here’s the output:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![Figure 2.10 – The OpenStack host list output](img/B21716_02_10.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.10 – OpenStack 主机列表输出](img/B21716_02_10.jpg)'
- en: Figure 2.10 – The OpenStack host list output
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – OpenStack 主机列表输出
- en: 'OpenStack services can be managed easily through the Docker container command-line
    interface. For example, Keystone container service logs can be viewed by running
    the following command line:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过 Docker 容器命令行接口轻松管理 OpenStack 服务。例如，可以通过运行以下命令查看 Keystone 容器服务日志：
- en: '[PRE32]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The other option to inspect an OpenStack service container and report back
    container information, such as IP address and networking settings, can be performed
    by using the generic **docker inspect** command line, as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种检查 OpenStack 服务容器并返回容器信息（例如 IP 地址和网络设置）的方法，可以通过使用通用的 **docker inspect** 命令行来执行，如下所示：
- en: '[PRE33]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Despite the flexibility of the usage of containers and the simplicity of destroying
    and building new ones in almost no time, in some cases, you might need to investigate
    a defined OpenStack service issue or configuration via shell access, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管容器的使用灵活性和几乎可以在短时间内销毁并重建新容器的简便性，但在某些情况下，您可能需要通过 shell 访问调查特定的 OpenStack 服务问题或配置，如下所示：
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: An all-in-one setup helps to develop and test code locally. Larger environments,
    including staging and production, would require an extended setup, which will
    be detailed in the next section.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一体化设置有助于在本地开发和测试代码。更大的环境，包括预发布和生产环境，将需要扩展设置，具体内容将在下一节中详细说明。
- en: Extending the deployment
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展部署
- en: Expanding on our initial physical design, discussed in [*Chapter 1*](B21716_01.xhtml#_idTextAnchor014)
    , *Revisiting OpenStack – Design Considerations* , will require the evaluation
    of different hardware specifications and options for the chosen design. As we
    have narrowed down the methods of deployment and the different sets of tools to
    build our first production iteration, we will start splitting the roles of OpenStack
    components across different physical systems. Unlike a testing environment, a
    production environment should follow a well-architected design pattern, based
    on the isolation of services, fault tolerance, scalability, and redundancy on
    each layer. We will deep-dive into the extension of those architectural aspects
    in [*Chapter 3*](B21716_03.xhtml#_idTextAnchor108) , *OpenStack Control Plane
    – Shared Services* , and [*Chapter 7*](B21716_07.xhtml#_idTextAnchor174) , *Running
    a Highly Available Cloud – Meeting* *the SLA* .
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展我们在[*第1章*](B21716_01.xhtml#_idTextAnchor014)中讨论的初步物理设计，*重访 OpenStack – 设计考虑因素*，将需要评估不同的硬件规格和为所选设计提供的选项。随着我们逐步确定部署方式和构建首个生产版本所需的不同工具集，我们将开始将
    OpenStack 组件的角色划分到不同的物理系统上。与测试环境不同，生产环境应遵循良好的架构设计模式，基于服务隔离、容错性、可扩展性和每层的冗余性。我们将在[*第3章*](B21716_03.xhtml#_idTextAnchor108)中深入探讨这些架构方面的扩展，*OpenStack
    控制平面 – 共享服务*，以及[*第7章*](B21716_07.xhtml#_idTextAnchor174)中，*运行高可用云 – 满足* *SLA*。
- en: Our deployment pipeline will be the source of truth to deploy any environment
    if you consider going through a minimal all-in-one setup testing environment to
    a staging one, mimicking the production that will be promoted to production if
    all stages of the pipeline tests, including security ones, are executed with 0
    errors.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果考虑通过最小化的全一体测试环境到仿真生产环境的所有阶段，我们的部署流水线将是部署任何环境的真相源，如果管道测试的所有阶段（包括安全阶段）都以0个错误执行，则将其提升为生产环境。
- en: Important note
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Make sure to not introduce any user production workloads before getting a minimum
    level of redundancy in each control and data plane across your OpenStack environment.
    More details on extending to a highly available setup will be discussed in [*Chapter
    7*](B21716_07.xhtml#_idTextAnchor174) , *Running a Highly Available Cloud – Meeting*
    *the SLA* .
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenStack环境的每个控制平面和数据平面至少达到最低冗余级别之前，请确保不要引入任何用户生产工作负载。有关扩展到高可用设置的详细信息将在[*第7章*](B21716_07.xhtml#_idTextAnchor174)讨论，*运行高可用云
    - 满足SLA*。
- en: The deployment expansion for the environment should take an incremental approach
    by splitting the roles whenever feasible, and you should take into consideration
    that some services can be optionally separated on their own physical servers.
    A good practice is to start splitting additional roles in the physical layout
    once the core services are rolling and after gaining more operational expertise
    for each iteration. As the deployment pipeline feeds back the state of each new
    deployment, more technical decisions will need to be made to introduce improvements
    to the physical infrastructure layout, and you can choose which services can be
    moved to their own server in the next iteration. To safely start the deployment
    journey, we will need to install and configure our deployer before proceeding
    with infrastructure deployment.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 环境的部署扩展应采用增量方法，在可行时分割角色，并应考虑某些服务可以选择在其自己的物理服务器上分离。一个良好的实践是在核心服务滚动后并在每次迭代中获取更多操作经验后开始分割附加角色的物理布局。随着部署流水线反馈每个新部署的状态，将需要做出更多技术决策以引入对物理基础架构布局的改进，并且您可以选择在下一次迭代中将哪些服务移动到它们自己的服务器上。为了安全地开始部署旅程，我们将需要在继续进行基础设施部署之前安装和配置我们的部署程序。
- en: Installing the deployer
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装部署程序
- en: 'Our deployer host will be installed with the following software and hardware
    settings:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的部署程序主机将安装以下软件和硬件设置：
- en: '**Software** :'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件**：'
- en: Jenkins version 2.414.1
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins版本2.414.1
- en: Docker version 1.12.6 or greater
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker版本1.12.6或更高版本
- en: Ansible 2.3.1 or greater
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 2.3.1或更高版本
- en: Docker Python 1.10.0 or greater
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Python 1.10.0或更高版本
- en: Kolla-Ansible 16.1.0-16 – an OpenStack Antelope release or later
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kolla-Ansible 16.1.0-16 - OpenStack Antelope版本或更高版本
- en: Git version control
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git版本控制
- en: '**Operating system** : Ubuntu 22.04 LTS'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统**：Ubuntu 22.04 LTS'
- en: pip and Python dependencies including **python-dev**
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: pip和Python依赖项，包括**python-dev**
- en: '**Hardware** :'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬件**：'
- en: '**CPU** : At least 4 CPU cores and 64 bits x86'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU**：至少4个CPU核心和64位x86'
- en: '**Memory** : At least 4 GB of RAM'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存**：至少4 GB的RAM'
- en: '**Disk space** : At least 50 GB of free disk space'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**磁盘空间**：至少50 GB的可用磁盘空间'
- en: '**Network** : At least two network interfaces'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络**：至少两个网络接口'
- en: 'Start by installing Jenkins, by updating your local system and Java runtime:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 首先通过更新本地系统和Java运行时来安装Jenkins：
- en: '[PRE35]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add the required GPG key for the Jenkins repository files:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为Jenkins存储库文件添加所需的GPG密钥：
- en: '[PRE36]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following command will address the local system repository to download
    a recent version of Jenkins:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将定位本地系统存储库以下载Jenkins的最新版本：
- en: '[PRE37]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Run an update of the **apt** package list and install Jenkins:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 运行更新**apt**软件包列表并安装Jenkins：
- en: '[PRE38]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Make sure Jenkins is running by firing the following command:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 确保Jenkins正在运行，通过执行以下命令：
- en: '[PRE39]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If the Jenkins daemon is not running, issue the **start** command to launch
    its process:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Jenkins守护程序未运行，请发出**start**命令启动其进程：
- en: '[PRE40]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Once the Jenkins service is up and running, point to the CI/CD server address
    in a browser on the default **8080** port to access the user interface, and then
    proceed with the preliminary setup of the server:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Jenkins服务启动运行，通过默认**8080**端口在浏览器中指向CI/CD服务器地址以访问用户界面，然后继续进行服务器的初步设置：
- en: '![Figure 2.11 – Jenkins home page](img/B21716_02_11.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图2.11 – Jenkins首页](img/B21716_02_11.jpg)'
- en: Figure 2.11 – Jenkins home page
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 – Jenkins首页
- en: 'First, we will need to add a few plugins before building the pipeline, starting
    with **Git SCM** plugins. To do this, click on **Manage Jenkins** on the upper-left
    corner tab. Type **git** in the search bar on the **Available Plugin** tab and
    click **Install** **without restart** :'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在构建流水线之前添加一些插件，从**Git SCM** 插件开始。为此，点击左上角的**管理 Jenkins**选项卡。在**可用插件**标签页的搜索框中输入**git**，然后点击**安装**
    **（无需重启）**：
- en: '![Figure 2.12 – Jenkins’ Git SCM plugin setup](img/B21716_02_12.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.12 – Jenkins Git SCM 插件设置](img/B21716_02_12.jpg)'
- en: Figure 2.12 – Jenkins’ Git SCM plugin setup
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12 – Jenkins Git SCM 插件设置
- en: Once Jenkins and its required plugins are installed, we can move forward by
    setting up the CI/CD pipeline and different stages for future deployment.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 Jenkins 和其所需的插件，我们就可以继续配置 CI/CD 流水线和不同的阶段，以便进行未来的部署。
- en: Actioning the deployer
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行部署操作
- en: 'Our Jenkins file can be checked into the repository. The SCM pipeline will
    run the job definition with the configured path. The Jenkins pipeline definition
    can be summarized in high level in the following steps:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Jenkins 文件可以提交到仓库中。SCM 流水线将使用配置的路径运行作业定义。Jenkins 流水线定义可以在高层次上总结为以下步骤：
- en: Create a local test environment on the destination testing host.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目标测试主机上创建本地测试环境。
- en: Check out the repository from a defined branch.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从定义的分支中检查仓库。
- en: Install the required testing packages, including **kolla-** **ansible** and
    Docker runtimes.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装所需的测试包，包括**kolla-** **ansible** 和 Docker 运行时。
- en: Initialize the bootstrap server script.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化引导服务器脚本。
- en: Run Kolla prechecks on the bootstrapped testing environment.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在引导的测试环境上运行 Kolla 预检查。
- en: Deploy the OpenStack testing environment.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署 OpenStack 测试环境。
- en: Important note
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Depending on the target environments you plan to run through the CI/CD pipeline,
    make sure to adjust the configuration layout of the main **globals.yml** and **inventory.yml**
    files separately in each environment. Each environment should run with a dedicated
    Jenkins pipeline file.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您计划通过 CI/CD 流水线运行的目标环境，请确保在每个环境中分别调整主**globals.yml**和**inventory.yml**文件的配置布局。每个环境都应该使用专门的
    Jenkins 流水线文件运行。
- en: 'The next step is to create our first pipeline for the testing environment.
    Jenkins provides different options to create the job pipeline definition, either
    via the user interface wizard or by simply creating a Jenkins file that can live
    in the main directory of the OpenStack infrastructure as a code repository. For
    this purpose, our first job definition will follow the SCM method. The following
    snippets define the Jenkins deployment pipeline, starting with the first stage,
    where a virtual Python environment will be sourced to run each build in its own
    local environment:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为测试环境创建我们的第一个流水线。Jenkins 提供了多种选项来创建作业流水线定义，可以通过用户界面向导，或直接创建一个 Jenkins 文件，将其放在
    OpenStack 基础设施的代码仓库主目录中。为此，我们的第一个作业定义将采用 SCM 方法。以下代码片段定义了 Jenkins 部署流水线，从第一阶段开始，在该阶段，将创建一个虚拟的
    Python 环境来运行每个构建在其各自的本地环境中：
- en: '[PRE41]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The next stage will install all required dependencies, including **pip** ,
    the Ansible runtime, and the **kolla-ansible** package:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 下一阶段将安装所有必需的依赖项，包括**pip**、Ansible 运行时和**kolla-ansible**包：
- en: '[PRE42]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Once all the required packages are installed locally, the next stage will define
    the file structure of the infrastructure code under the **/etc/kolla** directory
    and set a few parameters in the **globals.yml** file, such as the network interface
    and the type of distribution Kolla will use:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有必需的包都在本地安装完成，下一阶段将定义基础设施代码在**/etc/kolla**目录下的文件结构，并在**globals.yml**文件中设置一些参数，如网络接口和
    Kolla 将使用的发行版类型：
- en: '[PRE43]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The next step will generate different secrets for all OpenStack services in
    their configurations. The secret file will inject each secret for each service
    during the OpenStack service installation:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将为所有 OpenStack 服务生成不同的密钥，注入每个服务的密钥到 OpenStack 服务安装过程中：
- en: '[PRE44]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, the pipeline will instruct Jenkins to prepare the container scripts for
    booting, including the system configuration:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，流水线将指示 Jenkins 准备启动容器脚本，包括系统配置：
- en: '[PRE45]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The next stage will run a precheck task to make sure that the bootstrap step
    was performed without issues:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 下一阶段将运行预检查任务，以确保引导步骤没有问题：
- en: '[PRE46]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The final stage is to deploy the services, pull the images, and run the services
    in containers:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一阶段是部署服务，拉取镜像，并在容器中运行服务：
- en: '[PRE47]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Make sure to have a new testing branch:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 确保创建一个新的测试分支：
- en: '[PRE48]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Commit and push the created file to the source code repository with the new
    branch:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 提交并推送创建的文件到源代码库的新分支：
- en: '[PRE49]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Important note
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Using the Jenkins file the SCM way enables us to treat the pipeline definition
    as code. Make sure that all changes and updates for any job definition go through
    the pipeline code. The pipeline file is written in Groovy syntax. A recommendation
    is to use an IDE to highlight the Jenkins file code format in the same way as
    for YAML. If your IDE does not highlight the Groovy syntax, add **#!/usr/bin/env
    groovy** to the top of the pipeline Jenkins file.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Jenkins 文件的 SCM 方式使我们能够将流水线定义视为代码。确保所有作业定义的更改和更新都通过流水线代码进行。流水线文件使用 Groovy
    语法编写。建议使用 IDE 来突出显示 Jenkins 文件代码格式，就像对 YAML 文件一样。如果您的 IDE 不突出显示 Groovy 语法，请在流水线
    Jenkins 文件顶部添加 **#!/usr/bin/env groovy**。
- en: 'From the Jenkins user interface, select **New Item** from the top-left menu.
    Select **Pipeline** as the type of job, with the desired name to run the test
    pipeline. The next wizard creates a pipeline item, named **openstack-dev** :'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Jenkins 用户界面中，从左上角菜单选择 **新建项目**。选择作业类型为 **Pipeline**，并为要运行测试流水线的名称选择 **openstack-dev**。下一个向导会创建一个名为
    **openstack-dev** 的流水线项目：
- en: '![Figure 2.13 – Jenkins pipeline creation](img/B21716_02_13.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.13 – Jenkins 流水线创建](img/B21716_02_13.jpg)'
- en: Figure 2.13 – Jenkins pipeline creation
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13 – Jenkins 流水线创建
- en: 'Select the pipeline script from SCM in the **Configure** tab and Git by specifying
    the repository URL. Make sure to configure the script of the Jenkins file in the
    repository directory path:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '在 **配置** 选项卡中从 SCM 选择 Jenkins 文件的流水线脚本，并通过指定存储库 URL 来使用 Git。确保在存储库目录路径中配置 Jenkins
    文件的脚本： '
- en: '![Figure 2.14 – The Jenkins pipeline SCM job definition](img/B21716_02_14.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.14 – Jenkins 流水线 SCM 作业定义](img/B21716_02_14.jpg)'
- en: Figure 2.14 – The Jenkins pipeline SCM job definition
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.14 – Jenkins 流水线 SCM 作业定义
- en: 'Our first deployment setup for the testing environment is ready to go. All
    that is left is to push the button. Click on **Build Now** on the left-hand side
    of the newly created job definition in Jenkins, where the different stages declared
    in the pipeline code will be visible:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为测试环境准备的第一个部署设置已经准备就绪。剩下的就是按按钮。在 Jenkins 中新创建的作业定义的左侧，点击 **立即构建**，可以看到在流水线代码中声明的不同阶段：
- en: '![Figure 2.15 – The Jenkins OpenStack test deployment pipeline](img/B21716_02_15.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.15 – Jenkins OpenStack 测试部署流水线](img/B21716_02_15.jpg)'
- en: Figure 2.15 – The Jenkins OpenStack test deployment pipeline
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15 – Jenkins OpenStack 测试部署流水线
- en: 'Jenkins jobs that are running can be monitored by clicking on the **Console
    Output** tab, where each stage defined in the pipeline file is reported to support
    further debugging and troubleshooting when possible errors occur:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 运行中的 Jenkins 作业可以通过点击 **控制台输出** 选项卡进行监控，在这里，流水线文件中定义的每个阶段都会报告以支持进一步调试和故障排除，以应对可能发生的错误：
- en: '![Figure 2.16 – Jenkins OpenStack test deployment output](img/B21716_02_16.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.16 – Jenkins OpenStack 测试部署输出](img/B21716_02_16.jpg)'
- en: Figure 2.16 – Jenkins OpenStack test deployment output
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16 – Jenkins OpenStack 测试部署输出
- en: The Jenkins console output is very handy for troubleshooting any possible issues
    that could occur during the Ansible run. Make sure the **failed** status is **0**
    . When the deployment status ends with the **SUCCESS** value, we can enforce the
    pipeline with additional security checks.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 控制台输出在排除 Ansible 运行期间可能出现的任何问题时非常方便。确保 **失败** 状态为 **0**。当部署状态以 **SUCCESS**
    值结束时，我们可以通过额外的安全检查来强化流水线。
- en: Deploying with security
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带安全性部署
- en: As we emphasized at the start of this chapter, security should be considered
    in the early steps of building and deployment projects. That is what has been
    defined as a *shift to the left* . The craft of automating security checks should
    be learned in testing environments to report any potential vulnerabilities before
    promoting the infrastructure to a production environment.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头强调的那样，安全性应该在构建和部署项目的早期步骤中考虑进去。这就是被定义为*向左转移*的内容。自动化安全检查的技艺应该在测试环境中学习，以便在将基础架构推广到生产环境之前报告任何潜在的漏洞。
- en: 'Our first security enforcement will be conducted by installing an additional
    Jenkins plugin, which will be an interesting asset to our DevSecOps pipeline.
    As we are dealing with containers as the main artifacts, we will install a container
    inspection plugin to perform security scans on the built containers at a later
    stage. **Anchore** is one of the most widely used container vulnerability-scanning
    platforms, providing seamless integration with CI/CD tools, source code, and even
    container registries for both Docker and Kubernetes. The Anchore plugin exists
    for Jenkins and can be installed straightforwardly in the same way we installed
    the Git plugin. On the **Available plugins** tab, search for **anchore** :'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个安全执行将通过安装额外的Jenkins插件来完成，这将成为我们DevSecOps管道中的一个有趣资产。由于我们主要处理容器作为构建产物，因此我们将安装一个容器检查插件，用于在后续阶段对构建的容器进行安全扫描。**Anchore**是最广泛使用的容器漏洞扫描平台之一，能够无缝集成CI/CD工具、源代码，甚至Docker和Kubernetes的容器注册表。Anchore插件适用于Jenkins，并且可以像安装Git插件一样直接安装。在**可用插件**选项卡中，搜索**anchore**：
- en: '![Figure 2.17 – Searching for the Jenkins Anchore plugin](img/B21716_02_17.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![图2.17 – 搜索Jenkins Anchore插件](img/B21716_02_17.jpg)'
- en: Figure 2.17 – Searching for the Jenkins Anchore plugin
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17 – 搜索Jenkins Anchore插件
- en: 'Select the **Anchore Container Image Scanner** plugin and click on **Install**
    **without restart** :'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**Anchore Container Image Scanner**插件并点击**安装（不重启）**：
- en: '![Figure 2.18 – The Jenkins Anchore plugin setup](img/B21716_02_18.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图2.18 – Jenkins Anchore插件设置](img/B21716_02_18.jpg)'
- en: Figure 2.18 – The Jenkins Anchore plugin setup
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.18 – Jenkins Anchore插件设置
- en: Important note
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'More details about the Anchore platform can be found here: [https://anchore.com/container-vulnerability-scanning/](https://anchore.com/container-vulnerability-scanning/)
    .'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到更多关于Anchore平台的详细信息：[https://anchore.com/container-vulnerability-scanning/](https://anchore.com/container-vulnerability-scanning/)。
- en: 'Once the plugin is installed, we need to adjust our settings to instruct our
    deployer to use a Docker repository at a specific address and port. For this example,
    the image registry will be deployed in the deployer host, named **master_registry**
    , by running the following command:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 插件安装完成后，我们需要调整设置，指示我们的部署工具使用特定地址和端口的Docker仓库。以此示例，镜像注册表将在部署主机上以**master_registry**命名，通过运行以下命令部署：
- en: '[PRE50]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Make sure to update the **globals.yml** file to use the local Docker registry
    by editing the following configuration lines:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 确保更新**globals.yml**文件，使用本地Docker注册表，方法是编辑以下配置行：
- en: '[PRE51]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Commit and push your changes to the main infrastructure code repository so
    that our CI/CD will point to the local registry in later image build steps:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的更改提交并推送到主基础设施代码仓库，以便我们的CI/CD可以在后续的镜像构建步骤中指向本地注册表：
- en: '[PRE52]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Before getting the image build pipeline running, we will install the Anchore
    engine to run the container inspection later. The Anchore open source version
    comes as a Docker image that can run standalone. Proceed by downloading the Anchore
    engine **docker-compose** file, as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动镜像构建管道之前，我们将安装Anchore引擎，以便稍后运行容器检查。Anchore开源版本作为Docker镜像提供，可以独立运行。接下来，请下载Anchore引擎的**docker-compose**文件，如下所示：
- en: '[PRE53]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Optionally, reset the admin password defined by the **ANCHORE_ADMIN_PASSWORD**
    configuration line in the **docker-compose.yaml** file. That will be needed for
    later steps.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，重置**docker-compose.yaml**文件中通过**ANCHORE_ADMIN_PASSWORD**配置行定义的管理员密码。该密码将在后续步骤中使用。
- en: Important note
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: For permanent access to the Anchore engine interface, export the Anchore endpoint,
    username, and password to the **ANCHORE_CLI_URL** , **ANCHORE_CLI_USER** , and
    **ANCHORE_CLI_PASS** environment variables, respectively. If the variables are
    not populated within the operating system, you will need to export them in each
    run of the CI/CD pipeline execution.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 为了长期访问Anchore引擎接口，将Anchore端点、用户名和密码分别导出为**ANCHORE_CLI_URL**、**ANCHORE_CLI_USER**和**ANCHORE_CLI_PASS**环境变量。如果这些变量未在操作系统中填充，你需要在每次运行CI/CD管道执行时导出它们。
- en: 'Now, let’s create and run the Anchore engine Docker container:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建并运行Anchore引擎的Docker容器：
- en: '[PRE54]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The Anchore CLI is very handy to interact with the engine and can be installed
    as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Anchore CLI非常方便与引擎进行交互，可以通过以下方式安装：
- en: '[PRE55]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'On the Jenkins dashboard, configure the installed Anchore plugin by pointing
    to **Manage Jenkins** and clicking on **System** . Provide the engine username
    of **admin** , the password, and the engine URL defined in the **docker-compose.yaml**
    file for the Anchore engine:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jenkins 仪表板上，配置已安装的 Anchore 插件，方法是指向**管理 Jenkins**并点击**系统**。提供**admin**的引擎用户名、密码和在**docker-compose.yaml**文件中定义的
    Anchore 引擎 URL：
- en: '![Figure 2.19 – The Jenkins Anchore engine configuration](img/B21716_02_19.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.19 – Jenkins Anchore 引擎配置](img/B21716_02_19.jpg)'
- en: Figure 2.19 – The Jenkins Anchore engine configuration
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.19 – Jenkins Anchore 引擎配置
- en: Important note
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The Anchore engine open source project is not maintained anymore but is still
    available on GitHub and Docker Hub for evaluation, along with its Jenkins plugin.
    An enterprise edition has replaced the open source version. More info on the open
    source Anchore engine can be found here: [https://github.com/anchore/anchore-engine](https://github.com/anchore/anchore-engine)
    . Other similar container security inspection solutions can be found at [https://github.com/anchore/syft](https://github.com/anchore/syft)
    and [https://github.com/anchore/grype](https://github.com/anchore/grype) .'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: Anchore 引擎开源项目不再维护，但仍可在 GitHub 和 Docker Hub 上供评估使用，以及其 Jenkins 插件。企业版已取代了开源版本。有关开源
    Anchore 引擎的更多信息，请参见：[https://github.com/anchore/anchore-engine](https://github.com/anchore/anchore-engine)。其他类似的容器安全检查解决方案可以在
    [https://github.com/anchore/syft](https://github.com/anchore/syft) 和 [https://github.com/anchore/grype](https://github.com/anchore/grype)
    中找到。
- en: 'Building images and pushing them to the local registry can be automated by
    optionally using a dedicated pipeline, with the following steps:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 构建镜像并将其推送到本地注册表，可以通过可选的专用管道自动化，步骤如下：
- en: Build an OpenStack service Docker image using Kolla.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Kolla 构建 OpenStack 服务 Docker 镜像。
- en: Run an Anchore security check on the pushed image.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对推送的镜像运行 Anchore 安全检查。
- en: Push the created OpenStack service Docker image using Kolla if no specific vulnerabilities
    have been detected by Anchore.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 Anchore 没有检测到特定漏洞，则使用 Kolla 推送已创建的 OpenStack 服务 Docker 镜像。
- en: 'Our image pipeline script is structured in three stages – build images, Anchore
    security scans, and push images – if the vulnerability scans are successful. This
    can be depicted as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的镜像管道脚本分为三个阶段 – 构建镜像、Anchore 安全扫描和推送镜像 – 如果漏洞扫描成功。这可以如下表示：
- en: '[PRE56]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Save the pipeline script in Jenkins and run the pipeline from the new job definition:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 将管道脚本保存在 Jenkins 中，并从新的作业定义中运行管道：
- en: '![Figure 2.20 – Running the OpenStack inspection image pipeline](img/B21716_02_20.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.20 – 运行 OpenStack 检查镜像管道](img/B21716_02_20.jpg)'
- en: Figure 2.20 – Running the OpenStack inspection image pipeline
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.20 – 运行 OpenStack 检查镜像管道
- en: Running the OpenStack security scan image pipeline will generate a useful vulnerability
    assessment and trigger a **stop** action so that the pipeline will fail. Anchore
    reports the cause of the failure from the previous run, which did not comply with
    the engine policy.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 OpenStack 安全扫描镜像管道将生成有用的漏洞评估，并触发**停止**操作，导致管道失败。Anchore 会报告先前运行失败的原因，该失败未符合引擎策略。
- en: Automating the OpenStack deployment by starting with a development environment
    helps to deliver a higher code quality empowered by security guardrails. Cloud
    operators will learn about possible issues during the cloud infrastructure deployment
    and master how to solve them earlier. It goes hand in hand with security and anomaly
    detection practices, which should support the move to production with more confidence.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从开发环境开始自动化部署 OpenStack，可以交付更高质量的代码，并提供安全防护。云运维人员将在云基础设施部署过程中了解可能的问题，并能更早掌握解决方法。这与安全性和异常检测实践密切相关，能够在更有信心的情况下支持生产环境的迁移。
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has been a quite milestone in defining the right way and best practices
    to run a complete OpenStack deployment in a DevSecOps style. Inheriting modern,
    agile software development practices in infrastructure management is considered
    a great opportunity for cloud operators, and hence for DevSecOps, to focus on
    infrastructure improvement and extension, rather than being blocked by traditional,
    manual operations tasks. The OpenStack ecosystem, with the latest additional services
    and functions, can be cumbersome to manage if no proper agile methods are considered
    from the start of the journey. This chapter has highlighted security fusion from
    day one. Silos should no longer exist between infrastructure and security duties.
    Undoubtedly, that is a game changer toward a successful deployment experience,
    armed with security and automation. As we have built a solid draft together with
    the right tooling and processes, we will take our momentum to the next chapter
    to extend our production design and deployment, cover OpenStack clustering, define
    its various services’ roles, and deploy them in a DevSecOps way.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 本章在定义以DevSecOps风格运行完整OpenStack部署的正确方式和最佳实践方面是一个重要的里程碑。将现代敏捷软件开发实践应用于基础设施管理被认为是云操作人员的一个巨大机遇，因此也是DevSecOps的一个机遇，使其能够专注于基础设施的改进和扩展，而不是被传统的手动操作任务所阻碍。OpenStack生态系统，随着最新的附加服务和功能，如果从一开始就没有考虑到适当的敏捷方法，可能会变得繁琐难以管理。本章强调了从第一天起就融合安全性。基础设施和安全职责之间不应再有孤岛。毫无疑问，这是朝着成功部署经验迈进的关键因素，借助安全性和自动化武装自己。随着我们与正确的工具和流程共同构建了一个坚实的草案，我们将带着这一势头进入下一章，扩展我们的生产设计和部署，涵盖OpenStack集群，定义其各种服务的角色，并以DevSecOps方式进行部署。
