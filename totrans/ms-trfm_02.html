<html><head></head><body>
<div id="_idContainer034">
<h1 class="chapter-number" id="_idParaDest-36"><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-37"><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.2.1">Using HashiCorp Configuration Language</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the first chapter, we examined Terraform’s architecture. </span><span class="koboSpan" id="kobo.3.2">It is a simple command-line tool that takes in code and creates a plan that it can later execute at the user’s behest. </span><span class="koboSpan" id="kobo.3.3">In this chapter, we will examine how to leverage Terraform’s language—</span><strong class="bold"><span class="koboSpan" id="kobo.4.1">HashiCorp Configuration Language</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">HCL</span></strong><span class="koboSpan" id="kobo.7.1">)—to define </span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.8.1">infrastructure as code so that we can build sophisticated cloud-based architectures </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">using Terraform.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">The chapter covers the </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.12.1">Resources and </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">data sources</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Locals </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">and types</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Variables </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">and outputs</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.18.1">Meta arguments</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Loops </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">and iterations</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.21.1">Expressions</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.22.1">Functions</span></span><a id="_idTextAnchor098"/></li>
</ul>
<h1 id="_idParaDest-38"><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.23.1">Resources and data sources</span></h1>
<p><span class="koboSpan" id="kobo.24.1">Resources and data sources play a critical role in Terraform and are probably the most important language constructs to understand as they allow you to access existing and create </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">new resources.</span></span></p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.26.1">Resources</span></h2>
<p><span class="koboSpan" id="kobo.27.1">Resources</span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.28.1"> are the most common block that you use when coding in HCL. </span><span class="koboSpan" id="kobo.28.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.29.1">resource</span></strong><span class="koboSpan" id="kobo.30.1"> block is what Terraform is all about. </span><span class="koboSpan" id="kobo.30.2">You can think of each resource as a digital twin of something Terraform will provision in the </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">real world:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.32.1">
    resource "random_string" "foobar" {
      length  = 4
      upper   = false
      special = false
    }</span></pre> <p><span class="koboSpan" id="kobo.33.1">A block’s definition has</span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.34.1"> three parts: the </span><strong class="bold"><span class="koboSpan" id="kobo.35.1">block type</span></strong><span class="koboSpan" id="kobo.36.1">, the </span><strong class="bold"><span class="koboSpan" id="kobo.37.1">resource type</span></strong><span class="koboSpan" id="kobo.38.1">, and the </span><strong class="bold"><span class="koboSpan" id="kobo.39.1">reference name</span></strong><span class="koboSpan" id="kobo.40.1">. </span><span class="koboSpan" id="kobo.40.2">In the preceding example, the block type is </span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">resource</span></strong><span class="koboSpan" id="kobo.42.1">, the resource type is </span><strong class="source-inline"><span class="koboSpan" id="kobo.43.1">random_string</span></strong><span class="koboSpan" id="kobo.44.1">, and the reference name is </span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">foobar</span></strong><span class="koboSpan" id="kobo.46.1">. </span><span class="koboSpan" id="kobo.46.2">To create dependencies between resources, we use the reference name and type to access output values from </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">the resource:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.48.1">
    resource "azurerm_resource_group" "foobar" {
      name     = "rg-${random_string.foobar.result}"
      location = var.location
    }</span></pre> <p><span class="koboSpan" id="kobo.49.1">In the preceding code, we create an Azure resource group by referencing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">foobar</span></strong><span class="koboSpan" id="kobo.51.1"> random string’s output </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">value, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">result</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">Each resource within a Terraform provider is a tiny semi-independent computer program designed to manage a particular underlying system architecture. </span><span class="koboSpan" id="kobo.55.2">These resources define a schema that allows you to control the configuration of those underlying components. </span><span class="koboSpan" id="kobo.55.3">Sometimes, this schema is straightforward; at other times, it can be very complex, composed of primitive type attributes and additional custom block definitions nested within the </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">resource block.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">These nested blocks allow you to declare one or more sub-resources within a resource. </span><span class="koboSpan" id="kobo.57.2">The resource dictates the number of each type of nested block it expects. </span><span class="koboSpan" id="kobo.57.3">Sometimes, resources allow many instances of the same nested block, while at other times, they may allow </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">precisely one.</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">For example, the Azure Cosmos DB service allows you to create hyper-scale NoSQL databases and quickly set up replication across multiple geo-locations. </span><span class="koboSpan" id="kobo.59.2">Each geo-location is a nested block within the Cosmos DB </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">resource</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.61.1"> block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.62.1">
    resource "azurerm_cosmosdb_account" "db" {
      name                = "cosmos-foobar"
      location            = azurerm_resource_group.foobar.location
      resource_group_name = azurerm_resource_group.foobar.name
      offer_type          = "Standard"
      kind                = "MongoDB"
      consistency_policy {
        consistency_level = "Eventual"
      }
      geo_location {
        location          = "westus"
        failover_priority = 0
      }
      geo_location {
        location          = "eastus"
        failover_priority = 1
      }
    }</span></pre> <p><span class="koboSpan" id="kobo.63.1">As you can see, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">geo_location</span></strong><span class="koboSpan" id="kobo.65.1"> block is repeated</span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.66.1"> multiple times within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">azurerm_cosmosdb_account</span></strong><span class="koboSpan" id="kobo.68.1"> block. </span><span class="koboSpan" id="kobo.68.2">Each instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">geo_location</span></strong><span class="koboSpan" id="kobo.70.1"> nested block tells this Cosmos DB account where to replicate the MongoDB databases </span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.71.1">and the </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">failover prior</span><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.73.1">ity.</span></span></p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.74.1">Data sources</span></h2>
<p><span class="koboSpan" id="kobo.75.1">In its most primitive form, Terraform is about provisioning resources, but as we saw, there is a lot more to it than that. </span><span class="koboSpan" id="kobo.75.2">Once Terraform provisions the resources, then what? </span><span class="koboSpan" id="kobo.75.3">What happens when you provision a resource by some other means? </span><span class="koboSpan" id="kobo.75.4">Can you still reference it from Terraform? </span><span class="koboSpan" id="kobo.75.5">Resources create something new. </span><span class="koboSpan" id="kobo.75.6">Data sources </span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.76.1">access something that </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">already exists.</span></span></p>
<p><span class="koboSpan" id="kobo.78.1">Data sources are less prolific but still play a critical role. </span><span class="koboSpan" id="kobo.78.2">First, they allow you to reference resources provisioned outside the current Terraform workspace no matter how they were provisioned—through a GUI, another automation tool, or another </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">Terraform workspace:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.80.1">
    data "azurerm_resource_group" "bar" {
      name     = "rg-foo"
      location = "westus"
    }</span></pre> <p><span class="koboSpan" id="kobo.81.1">Like the resource, a data source block’s definition has three parts: the block type, the resource type, and the reference name. </span><span class="koboSpan" id="kobo.81.2">In the preceding example, the block type is </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">data</span></strong><span class="koboSpan" id="kobo.83.1">, the resource type is </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">azurerm_resource_group</span></strong><span class="koboSpan" id="kobo.85.1">, and the reference name is </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">bar</span></strong><span class="koboSpan" id="kobo.87.1">. </span><span class="koboSpan" id="kobo.87.2">To create dependencies between resources and data sources, we use the reference name and type to access output values from the data source just like we did with a resource, but we also need to prefix the reference with </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">data</span></strong><span class="koboSpan" id="kobo.89.1"> to clarify to Terraform whether this reference is to a new item or an </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">existing one:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.91.1">
resource "azurerm_storage_account" "fizzbuzz" {
name                     = "stfizzbuzz"
resource_group_name      = data.azurerm_resource_group.bar.name
location                 = data.azurerm_resource_group.bar.location
account_tier             = "Standard"
account_replication_type = "GRS"
}</span></pre> <p><span class="koboSpan" id="kobo.92.1">In the preceding code, we </span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.93.1">create an Azure Storage account by referencing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">bar</span></strong><span class="koboSpan" id="kobo.95.1"> Azure resource group’s output values: </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">name</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.97.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">location</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.100.1">Now that we understand the core components that Terraform is responsible for (resources and data sources—something new and something old), let’s look at the data types we will use for internal and external </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">data structures.</span></span></p>
<h1 id="_idParaDest-41"><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.102.1">Locals and types</span></h1>
<p><span class="koboSpan" id="kobo.103.1">After resources and data sources, the next most important thing to be familiar with is how to work with locals, which allow us to create internal variables and types that allow us to manipulate data within our </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">Terraform solution.</span></span></p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.105.1">Locals</span></h2>
<p><span class="koboSpan" id="kobo.106.1">Terraform allows you</span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.107.1"> to perform sophisticated operations on a variety of types. </span><span class="koboSpan" id="kobo.107.2">Sometimes, it’s necessary to use intermediate values that store a calculated value you can reference across your code base. </span><span class="koboSpan" id="kobo.107.3">It’s essential to understand how to do this, and what data types are available when working with internal data inside a module and when defining the contract between your </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">Terraform modules.</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">locals</span></strong><span class="koboSpan" id="kobo.111.1"> block allows you to declare local variables. </span><span class="koboSpan" id="kobo.111.2">You can think of these as member variables in a class or local variables in a function, except they merge into one construct within the flattened scope of a </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">Terraform workspace.</span></span></p>
<p><span class="koboSpan" id="kobo.113.1">You can define a local variable anywhere in your HCL code simply by declaring a </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">locals</span></strong><span class="koboSpan" id="kobo.115.1"> block and declaring and defining a local variable within it. </span><span class="koboSpan" id="kobo.115.2">You must specify a value when declaring a </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">local variable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.117.1">
    locals {
      foo = "bar"
    }</span></pre> <p><span class="koboSpan" id="kobo.118.1">The preceding code declares a local variable called </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">foo</span></strong><span class="koboSpan" id="kobo.120.1">. </span><span class="koboSpan" id="kobo.120.2">Terraform infers the type to be </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">string</span></strong><span class="koboSpan" id="kobo.122.1"> simply by the use of </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">double quotes.</span></span></p>
<p><span class="koboSpan" id="kobo.124.1">You can declare as many </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">locals</span></strong><span class="koboSpan" id="kobo.126.1"> blocks as you want in any </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">.tf</span></strong><span class="koboSpan" id="kobo.128.1"> file. </span><span class="koboSpan" id="kobo.128.2">As in other languages, you can nest local variables inside the value of other local variables. </span><span class="koboSpan" id="kobo.128.3">You can do this by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">local</span></strong><span class="koboSpan" id="kobo.130.1"> object prefix. </span><span class="koboSpan" id="kobo.130.2">Using the element’s type to reference it from elsewhere in the code is similar to referencing resources and </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">data sources:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.132.1">
    locals {
      foo = "foo"
      bar = "bar"
      foobar = "${local.foo}${local.bar}"
    }</span></pre> <p><span class="koboSpan" id="kobo.133.1">It can be tricky to remember, but locals are always declared in a plural block name (</span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">locals</span></strong><span class="koboSpan" id="kobo.135.1"> versus </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">local</span></strong><span class="koboSpan" id="kobo.137.1">) and referenced in the singular, </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">local.*</span></strong><span class="koboSpan" id="kobo.139.1">. </span><span class="koboSpan" id="kobo.139.2">The mixture of singular and plural terminology can seem strange as most other blocks in Terraform are declared in a singular block </span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.140.1">and referenced in </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">the s</span><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.142.1">ingular.</span></span></p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.143.1">Primitive types</span></h2>
<p><span class="koboSpan" id="kobo.144.1">By design, HCL supports</span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.145.1"> a limited number of data types. </span><span class="koboSpan" id="kobo.145.2">This design encourages simplicity in your</span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.146.1"> code and avoids overly complex logic around type conversion. </span><span class="koboSpan" id="kobo.146.2">In principle, you should avoid doing complex logic in HCL and rely on the consistent input-output model ingrained into Terraform’s modular architecture to do any heavy lifting outside of Terraform and pass in a known good value as input in one of the </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">supported types.</span></span></p>
<p><span class="koboSpan" id="kobo.148.1">There are only three primitive types: </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">string</span></strong><span class="koboSpan" id="kobo.150.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">number</span></strong><span class="koboSpan" id="kobo.152.1">,</span><a id="_idTextAnchor107"/> <span class="No-Break"><span class="koboSpan" id="kobo.153.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">bool</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.156.1">String</span></h3>
<p><span class="koboSpan" id="kobo.157.1">While there are </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">number</span></strong><span class="koboSpan" id="kobo.159.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">bool</span></strong><span class="koboSpan" id="kobo.161.1">, their </span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.162.1">use or function is not very complicated. </span><span class="koboSpan" id="kobo.162.2">However, </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">string</span></strong><span class="koboSpan" id="kobo.164.1"> can become very difficult very quickly. </span><span class="koboSpan" id="kobo.164.2">If you go spelunking in GitHub</span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.165.1"> for HCL code, you will see a predisposition for complex string manipulation operations embedded in the code. </span><span class="koboSpan" id="kobo.165.2">Just because you can doesn’t mean you should. </span><span class="koboSpan" id="kobo.165.3">This is </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">the way.</span></span></p>
<p><span class="koboSpan" id="kobo.167.1">Avoid complex string manipulation where possible, and when it is necessary, encapsulate it into a local value so that it can be easily output for testing purposes before yo</span><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.168.1">u </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">run </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">apply</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">.</span></span></p>
<h4><span class="koboSpan" id="kobo.172.1">String interpolation</span></h4>
<p><strong class="bold"><span class="koboSpan" id="kobo.173.1">String interpolation</span></strong><span class="koboSpan" id="kobo.174.1"> is a </span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.175.1">pervasive operation, but try to avoid it where possible. </span><span class="koboSpan" id="kobo.175.2">Avoid using a complex expression when you can pass in a reference to a single </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">string</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.177.1"> object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.178.1">
    resource "aws_vpc" "main" {
      cidr_block       = "10.0.0.0/16"
      tags {
        Name = "${var.application_name}-${var.environment_name}"
      }
    }</span></pre> <p><span class="koboSpan" id="kobo.179.1">In the preceding example, we pass in two variables and concatenate them to construct the </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">Name</span></strong><span class="koboSpan" id="kobo.181.1"> tag, commonly used by the </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">AWS console:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.183.1">
    locals {
      name = "${var.application_name}-${var.environment_name}"
    }</span></pre> <p><span class="koboSpan" id="kobo.184.1">Alternatively, we can declare a </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">local</span></strong><span class="koboSpan" id="kobo.186.1"> that constructs the name and directly sets the tag with the value of </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">local</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.190.1">
    resource "aws_vpc" "main" {
      cidr_block       = "10.0.0.0/16"
      tags {
        Name = local.name
      }
    }</span></pre> <p><span class="koboSpan" id="kobo.191.1">It simplifies our resource block for the AWS VPC by eliminating the string interpolation syntax (consisting of two double quotes, </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">"</span></strong><span class="koboSpan" id="kobo.193.1">, and two interpolation blocks, </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">${ ... </span><span class="koboSpan" id="kobo.194.2">}</span></strong><span class="koboSpan" id="kobo.195.1">). </span><span class="koboSpan" id="kobo.195.2">It also creates a reusable </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">local</span></strong><span class="koboSpan" id="kobo.197.1"> that we can use to tag our resources consistently. </span><span class="koboSpan" id="kobo.197.2">This can improve the readability and, ultimately, the maintainability of the code, especially if the string needs to be </span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.198.1">reused across </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">multi</span><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.200.1">ple resources.</span></span></p>
<h4><span class="koboSpan" id="kobo.201.1">A string that spans multiple lines</span></h4>
<p><span class="koboSpan" id="kobo.202.1">Depending on the</span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.203.1"> provider and resource you use, sometimes you must embed large strings spanning multiple lines. </span><span class="koboSpan" id="kobo.203.2">Terraform uses a </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">heredoc</span></strong><span class="koboSpan" id="kobo.205.1"> style of declaring </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">multi-line strings:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.207.1">
    locals {
      shopping_list = &lt;&lt;EOT
    apples
    oranges
    grapes
    bananas
    EOT
    }</span></pre> <p><span class="koboSpan" id="kobo.208.1">String content can be structured or unstructured. </span><span class="koboSpan" id="kobo.208.2">If HCL supports the structure of your string, you should consider using native syntax to represent the content. </span><span class="koboSpan" id="kobo.208.3">The most common cases of structured content embedded in HCL are JSON or YAML formatted strings because many cloud platforms have services that define their configuration schema that you must supply in either of these two formats. </span><span class="koboSpan" id="kobo.208.4">In this case, you should use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">jsonencode</span></strong><span class="koboSpan" id="kobo.210.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">yamlencode</span></strong><span class="koboSpan" id="kobo.212.1"> functions to convert objects declared in native HCL into the appropriately formatted string. </span><span class="koboSpan" id="kobo.212.2">More on this later in </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.214.1">Another consideration is if there is an excellent reason to maintain the content in its original string format. </span><span class="koboSpan" id="kobo.214.2">Here are a couple of situations where this might be </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">the case:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.216.1">Too large</span></strong><span class="koboSpan" id="kobo.217.1">: If the content is substantial and thus quite laborious to convert into HCL, it may not be cost-effective to do </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">the conversion.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.219.1">Reusable artifact</span></strong><span class="koboSpan" id="kobo.220.1">: If you are trying to share the content between two tools, you’ll want to maintain it in the original format (either JSON or YAML). </span><span class="koboSpan" id="kobo.220.2">Keeping two copies of the same configuration in HCL and one in the original format won’t make sense. </span><span class="koboSpan" id="kobo.220.3">In this situation, you can have both tools use the same content—in its original</span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.221.1"> form—by having Terraform reference the content from a file using th</span><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.222.1">e </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">file</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.224.1"> function.</span></span></li>
</ul>
<h2 id="_idParaDest-44"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.225.1">Collection types</span></h2>
<p><span class="koboSpan" id="kobo.226.1">HCL </span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.227.1">supports </span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.228.1">only two collection ty</span><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.229.1">pes: </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">list</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.231.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">map</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.234.1">List</span></h3>
<p><span class="koboSpan" id="kobo.235.1">If you have done any</span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.236.1"> development before working with Terraform or programming with HCL, you will no doubt be familiar with the concept of an array. </span><span class="koboSpan" id="kobo.236.2">Every programming language uses different syntaxes, types, and classes to represent this concept. </span><span class="koboSpan" id="kobo.236.3">A </span><strong class="bold"><span class="koboSpan" id="kobo.237.1">list</span></strong><span class="koboSpan" id="kobo.238.1"> is</span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.239.1"> an ordered list of objects where items in that list can be accessed using the index of the </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">desired item:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.241.1">C# and Java</span></strong><span class="koboSpan" id="kobo.242.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">    string[] array = { "westus", "</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">eastus" }</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.245.1">Go</span></strong><span class="koboSpan" id="kobo.246.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">          array := [</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">4]string{"westus", "eastus"}</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.249.1">Python</span></strong><span class="koboSpan" id="kobo.250.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">       array = ["</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">westus", "eastus"]</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.253.1">JavaScript</span></strong><span class="koboSpan" id="kobo.254.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">     var array = ["</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">westus", "eastus"];</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.257.1">HCL</span></strong><span class="koboSpan" id="kobo.258.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">         array = ["</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">westus", "eastus"]</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.261.1">Notice any similarities with any of the languages we’ve looked at? </span><span class="koboSpan" id="kobo.261.2">Python is the clear winner in the similarity contest. </span><span class="koboSpan" id="kobo.261.3">JavaScript is a close second—simply with some extra semi-colons </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">and such.</span></span></p>
<p><span class="koboSpan" id="kobo.263.1">As might be expected, items contained within an HCL list are accessed similarly across all of </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">these languages:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.265.1">
    a = array[1]</span></pre> <p><span class="koboSpan" id="kobo.266.1">The value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">a</span></strong><span class="koboSpan" id="kobo.268.1"> would </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">be </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">eastus</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.272.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">list</span></strong><span class="koboSpan" id="kobo.274.1"> object </span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.275.1">type is fantastic for situations where we want to provision a</span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.276.1"> corresponding resource for </span><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.277.1">each item in </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">the list.</span></span></p>
<h3><span class="koboSpan" id="kobo.279.1">Map</span></h3>
<p><span class="koboSpan" id="kobo.280.1">Like the concept of an </span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.281.1">array, a map</span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.282.1"> in HCL corresponds to another prevalent collection type that goes by many names in other programming languages. </span><span class="koboSpan" id="kobo.282.2">From </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">Dictionary</span></strong><span class="koboSpan" id="kobo.284.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">KeyValuePair</span></strong><span class="koboSpan" id="kobo.286.1"> and back to </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">map</span></strong><span class="koboSpan" id="kobo.288.1">. </span><span class="koboSpan" id="kobo.288.2">They all share this concept of a key—guaranteed unique within the collection—and associated with a corresponding value. </span><span class="koboSpan" id="kobo.288.3">To look up the value, you don’t access it with its index within the collection; you can access it with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">key</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.290.1"> value:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.291.1">
    networks = {
      "westus" = "10.0.0.0/16"
      "eastus" = "10.1.0.0/16"
    }</span></pre> <p><span class="koboSpan" id="kobo.292.1">When we want to access the value for the particular network, we specify the region name we </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">are using:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.294.1">
    a = networks["westus"]</span></pre> <p><span class="koboSpan" id="kobo.295.1">The value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">a</span></strong><span class="koboSpan" id="kobo.297.1"> would </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">be </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">10.1.0.0/16</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.301.1">This solution only works when the collection’s key is unique. </span><span class="koboSpan" id="kobo.301.2">In the preceding example, this allows us to quickly set up one network for every region we choose; however, with the current design, we cannot do that if we want to set up two networks for the </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">same region:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.303.1">
    networks = {
      "westus" = "10.0.0.0/16"
      "eastus" = "10.1.0.0/16"
      "eastus" = "10.2.0.0/16"
    }</span></pre> <p><span class="koboSpan" id="kobo.304.1">We can’t because adding a second entry for any region would produce an error. </span><span class="koboSpan" id="kobo.304.2">The error would be subtle. </span><span class="koboSpan" id="kobo.304.3">When </span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.305.1">we attempted to access </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">eastus</span></strong><span class="koboSpan" id="kobo.307.1"> values in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">map</span></strong><span class="koboSpan" id="kobo.309.1">, only their last matching entry would come back. </span><span class="koboSpan" id="kobo.309.2">Therefore, it is the same as if </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">10.1.0.0/16</span></strong><span class="koboSpan" id="kobo.311.1"> did not exist. </span><span class="koboSpan" id="kobo.311.2">Having such a discrepancy in your code and what Terraform provisions can lead to</span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.312.1"> confusion and misaligned expectations, so remember that when working with </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">map</span></strong><span class="koboSpan" id="kobo.314.1">, you should reserve it for situation</span><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.315.1">s where the key </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">is unique.</span></span></p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.317.1">Complex objects</span></h2>
<p><span class="koboSpan" id="kobo.318.1">HCL is not </span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.319.1">object-oriented; therefore, it does not have a mechanism for defining classes like other languages that represent complex types. </span><span class="koboSpan" id="kobo.319.2">However, it does support complex objects. </span><span class="koboSpan" id="kobo.319.3">It uses dynamic types, meaning Terraform will evaluate the object’s type </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">at runtime.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.321.1">Dynamic typing</span></strong><span class="koboSpan" id="kobo.322.1"> can be a </span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.323.1">blessing and a curse. </span><span class="koboSpan" id="kobo.323.2">It is a blessing because we don’t have to conform to strict structures of objects. </span><span class="koboSpan" id="kobo.323.3">If we need another attribute, we can quickly add it. </span><span class="koboSpan" id="kobo.323.4">It is a curse because it means we need an official source of truth for how the object should be structured, and we’ll have to rely on reference tracing when refactoring the structure of objects passed from one module or resource </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">to another:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.325.1">
    network_config = {
      name    = "westus"
      network = "10.0.0.0/16"
    }</span></pre> <p><span class="koboSpan" id="kobo.326.1">Defining an object is as simple as declaring the object reference and setting it to the value of a block—as indicated by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">{</span></strong><span class="koboSpan" id="kobo.328.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">}</span></strong><span class="koboSpan" id="kobo.330.1"> symbols. </span><span class="koboSpan" id="kobo.330.2">This block can contain any number of primitive types, collections, or </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">complex objects.</span></span></p>
<p><span class="koboSpan" id="kobo.332.1">Now that we understand the data types that Terraform recognizes and how to use them to construct internal </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">local</span></strong><span class="koboSpan" id="kobo.334.1"> variables, we can look externally to see how we can define the data contract between our module and the outside wo</span><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.335.1">rld: its inputs </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">and outputs.</span></span></p>
<h1 id="_idParaDest-46"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.337.1">Inputs and outputs</span></h1>
<p><span class="koboSpan" id="kobo.338.1">Next, let's look at how to get data into and out of Terraform using input variables </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">and outputs.</span></span></p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.340.1">Inputs</span></h2>
<p><span class="koboSpan" id="kobo.341.1">As we learned in the previous chapter, Terraform operates within the context of a module. </span><span class="koboSpan" id="kobo.341.2">That module is scoped physically within a directory. </span><span class="koboSpan" id="kobo.341.3">The </span><strong class="bold"><span class="koboSpan" id="kobo.342.1">root module</span></strong><span class="koboSpan" id="kobo.343.1"> is a special case where its directory is the same as Terraform’s </span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.344.1">working directory. </span><span class="koboSpan" id="kobo.344.2">Whenever you are writing HCL, you are writing within the context of a module, whether the root module or some other module; therefore, you need to consider how to get data into your module and how to get data out </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">of it.</span></span></p>
<p><span class="koboSpan" id="kobo.346.1">Input variables</span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.347.1"> are an essential design consideration because Terraform modules are simple machines that take inputs and </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">produce outputs.</span></span></p>
<p><span class="koboSpan" id="kobo.349.1">The input is all about what information the module needs to provision itself, and those inputs can come from wherever. </span><span class="koboSpan" id="kobo.349.2">As you design inputs, they should </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">be atomic.</span></span></p>
<p><span class="koboSpan" id="kobo.351.1">The module should be able to take the input without any additional manipulation or logic to parse the input variable’s value. </span><span class="koboSpan" id="kobo.351.2">You should parse the value outside of the module. </span><span class="koboSpan" id="kobo.351.3">That doesn’t mean that inputs can’t be complex objects or collections, but keeping the interface as simple as possible is a good idea. </span><span class="koboSpan" id="kobo.351.4">The more complex your inputs are, the more complex your module will be—whether it’s your root module or reusable modules that you share </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">across workspaces.</span></span></p>
<p><span class="koboSpan" id="kobo.353.1">Your root module will likely have the most complex inputs. </span><span class="koboSpan" id="kobo.353.2">Consider your input’s structure for root modules based on how you inject the parameter into the variable. </span><span class="koboSpan" id="kobo.353.3">If you use a variable file written in HCL, using complex types that span multiple lines, whether a list, a map, or a complex object, is effortless. </span><span class="koboSpan" id="kobo.353.4">However, suppose you plan to use a </span><strong class="bold"><span class="koboSpan" id="kobo.354.1">Linux environment variable</span></strong><span class="koboSpan" id="kobo.355.1"> or </span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.356.1">command-line argument method to pass in the parameter. </span><span class="koboSpan" id="kobo.356.2">In that case, you should reconsider using complex objects as inputs, as they can be challenging to troubleshoot and verify that you are getting the correct value into </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">that input.</span></span></p>
<p><span class="koboSpan" id="kobo.358.1">When you use Linux environment variables, it’s important to remember they are not very good at storing structured data with complex schema. </span><span class="koboSpan" id="kobo.358.2">The most complex schema you see in a Linux environment variable is some delimited text. </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">PATH</span></strong><span class="koboSpan" id="kobo.360.1"> is an excellent example of this, as it is a delimited text value. </span><span class="koboSpan" id="kobo.360.2">You could use a delimited text value as an input variable to simplify injecting the value. </span><span class="koboSpan" id="kobo.360.3">The downside is that you’ll have to parse the value after you get it </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">into Terraform.</span></span></p>
<p><span class="koboSpan" id="kobo.362.1">In the case of a</span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.363.1"> root module, this could be desirable because it reduces the complexity of the interface of the two tools: Terraform and other executables. </span><span class="koboSpan" id="kobo.363.2">This sort of integration is widespread within automation pipelines where separate pipeline tasks execute different tools, and you pipe the output from one tool into the inputs of the other. </span><span class="koboSpan" id="kobo.363.3">Passing values into Terraform from the command-line interface is similar to how we pipe the outputs of one module into the inputs of another module. </span><span class="koboSpan" id="kobo.363.4">However, this is more seamless within Terraform because HCL can be used to transfer the value. </span><span class="koboSpan" id="kobo.363.5">In contrast, with command-line tools, you would need additional parsing steps to transform the value into the desired format for Terraform to </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">consume quickly:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.365.1">
    variable "foo" {
      type        = string
      description = "This is the value for foo. </span><span class="koboSpan" id="kobo.365.2">It is needed because 'reasons'. </span><span class="koboSpan" id="kobo.365.3">Its value must be less than 6 characters."
</span><span class="koboSpan" id="kobo.365.4">    }</span></pre> <p><span class="koboSpan" id="kobo.366.1">In the preceding code, we declare an input variable, </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">foo</span></strong><span class="koboSpan" id="kobo.368.1">, with a type of </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">string</span></strong><span class="koboSpan" id="kobo.370.1"> and provide some guidance to the user of our module on how to use this in</span><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.371.1">put variable </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">within </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">description</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.375.1">Sensitive data</span></h3>
<p><span class="koboSpan" id="kobo.376.1">Sometimes, you may need to input sensitive data</span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.377.1"> such as a password, connection string, or access key. </span><span class="koboSpan" id="kobo.377.2">You must annotate your input variables to ensure that Terraform knows not to display them in its output, as this can lead to secret leakage through the operational logs that </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">Terraform emits:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.379.1">
    variable "super_secret_password" {
      type        = string
      description = "Password that I get from somewhere else"
</span><strong class="bold"><span class="koboSpan" id="kobo.380.1">      sensitive   = true</span></strong><span class="koboSpan" id="kobo.381.1">
    }</span></pre> <p><span class="koboSpan" id="kobo.382.1">In the preceding</span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.383.1"> code, we are annotating our super secret password with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">sensitive</span></strong><span class="koboSpan" id="kobo.385.1"> attribute to prevent this secr</span><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.386.1">et from being output </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">by Terraform.</span></span></p>
<h3><span class="koboSpan" id="kobo.388.1">Optional</span></h3>
<p><span class="koboSpan" id="kobo.389.1">When building modules that can </span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.390.1">support many scenarios, you will often need to provide input variables to support the data needs of each scenario. </span><span class="koboSpan" id="kobo.390.2">Each supported scenario may only require a subset of the input variables to be specified. </span><span class="koboSpan" id="kobo.390.3">In this situation, we should make our input </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">variable optional.</span></span></p>
<p><span class="koboSpan" id="kobo.392.1">For primitive types, you can accomplish this quite simply by setting the default value </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">null</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.396.1">
    variable "totally_optional_field" {
      type        = string
      description = "Yes, No, or Maybe"
</span><strong class="bold"><span class="koboSpan" id="kobo.397.1">      default     = null</span></strong><span class="koboSpan" id="kobo.398.1">
    }</span></pre> <p><span class="koboSpan" id="kobo.399.1">In the preceding code, we set </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">default</span></strong><span class="koboSpan" id="kobo.401.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">null</span></strong><span class="koboSpan" id="kobo.403.1">, allowing the user to ignore this input </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">variable completely.</span></span></p>
<p><span class="koboSpan" id="kobo.405.1">Setting an input variable to be optional can be more complicated when working with complex objects, as we may want the entire object or its attributes to </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">be optional.</span></span></p>
<p><span class="koboSpan" id="kobo.407.1">Consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.409.1">
    variable "person" {
      type = object({
        first_name  = string
        middle_name = string
        last_name   = string
      })
    }</span></pre> <p><span class="koboSpan" id="kobo.410.1">In the preceding code, we declare a variable called </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">person</span></strong><span class="koboSpan" id="kobo.412.1">. </span><span class="koboSpan" id="kobo.412.2">Unfortunately, not only is it a non-optional input variable, but every attribute on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">person</span></strong><span class="koboSpan" id="kobo.414.1"> object needs to </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">be specified.</span></span></p>
<p><span class="koboSpan" id="kobo.416.1">Let’s see whether we can loosen </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">things up:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.418.1">
    variable "person" {
      type = object({
        first_name  = string
        middle_name = optional(string)
        last_name   = string
      })
      default = null
    }</span></pre> <p><span class="koboSpan" id="kobo.419.1">In the preceding code, notice that adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">default = null</span></strong><span class="koboSpan" id="kobo.421.1"> on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">person</span></strong><span class="koboSpan" id="kobo.423.1"> variable block allows users of this</span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.424.1"> module to ignore this input variable completely. </span><span class="koboSpan" id="kobo.424.2">Additionally, if the user supplies a </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">person</span></strong><span class="koboSpan" id="kobo.426.1"> object, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">middle_name</span></strong><span class="koboSpan" id="kobo.428.1"> attribute is not required. </span><span class="koboSpan" id="kobo.428.2">Now, the supported inputs are much more flexible for </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">the user.</span></span></p>
<p><span class="koboSpan" id="kobo.430.1">The following value sets the entire object </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">null</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.434.1">
person = null</span></pre> <p><span class="koboSpan" id="kobo.435.1">The following value sets the input variable to an object but omits the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">middle_name</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.437.1"> attribute:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.438.1">
    person = {
      first_name = "Keyser"
      last_name  = "Söze"
    }</span></pre> <p><span class="koboSpan" id="kobo.439.1">Lastly, we set the input variable to an object and specify values for </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">all attributes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.441.1">
    person = {
      first_name  = "Keyser"
      middle_name = ""
      last_name   = "Söze"
    }</span></pre> <p><span class="koboSpan" id="kobo.442.1">Thanks to the </span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.443.1">inclusion of </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">default</span></strong><span class="koboSpan" id="kobo.445.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">optional</span></strong><span class="koboSpan" id="kobo.447.1"> within our input variable declaration, all are equally v</span><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.448.1">alid parameter values for </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">our module.</span></span></p>
<h3><span class="koboSpan" id="kobo.450.1">Validation</span></h3>
<p><span class="koboSpan" id="kobo.451.1">When creating modules you will use</span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.452.1"> more broadly in your organization, consider adding some basic validations to your modules’ inputs. </span><span class="koboSpan" id="kobo.452.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">validation</span></strong><span class="koboSpan" id="kobo.454.1"> block provides a way to add primitive data validation on incoming input </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">variable values.</span></span></p>
<p><span class="koboSpan" id="kobo.456.1">Adding validation can significantly reduce apply-time failures that can plague your user if an input value has requirements from the underlying provider that may not be evident through your module’s interface. </span><span class="koboSpan" id="kobo.456.2">For example, a cloud platform may impose naming conventions on resources such as alpha-numeric only, all lowercase, less than 30 characters, and so on. </span><span class="koboSpan" id="kobo.456.3">Unless the consumer of your module is aware of the platform-specific constraints, they could encounter difficulties using your module as they attempt to figure out how to get the correct set of values as inputs—especially if your module abstracts the underlying cloud platform’s resources in </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">any way:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.458.1">
    variable "name" {
      type        = string
      description = "Name of the thing"
      validation {
        condition     = length(name) &lt; 30
        error_message = "Length of name must be less than 30"
      }
    }</span></pre> <p><span class="koboSpan" id="kobo.459.1">In the preceding code, we specify a condition that checks that the length of the input variable is less than </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">30</span></strong><span class="koboSpan" id="kobo.461.1">. </span><span class="koboSpan" id="kobo.461.2">We could use any valid Boolean expression. </span><span class="koboSpan" id="kobo.461.3">We are good if it returns either </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">true</span></strong><span class="koboSpan" id="kobo.463.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">false</span></strong><span class="koboSpan" id="kobo.465.1">. </span><span class="koboSpan" id="kobo.465.2">We can use any number of functions that Terraform supports. </span><span class="koboSpan" id="kobo.465.3">However, prior to version 1.9.0 of Terraform, we can only reference the variable that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">validation</span></strong><span class="koboSpan" id="kobo.467.1"> block lives on—meaning, we</span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.468.1"> can’t reference other variables to create complex multi-variable input validation, nor can we make validation conditional on other elements declared within Terraform, be they other variables, resourc</span><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.469.1">es, data sources, locals, or otherwise. </span><span class="koboSpan" id="kobo.469.2">This all changed in version 1.9.0 of Terraform, where input variable validation was opened up to referencing other blocks within the module. </span><span class="koboSpan" id="kobo.469.3">This allows you to implement much more sophisticated validation using locals and data sources that might be useful to </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">verify inputs</span></span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">.</span></span></p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.472.1">Outputs</span></h2>
<p><span class="koboSpan" id="kobo.473.1">Output variables</span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.474.1"> are an essential consideration as well. </span><span class="koboSpan" id="kobo.474.2">It’s crucial to only output values that you will need. </span><span class="koboSpan" id="kobo.474.3">You should avoid putting unnecessary outputs—this is a pretty easy rule to follow within the root module. </span><span class="koboSpan" id="kobo.474.4">Still, when authoring reusable modules, it becomes more difficult because it is harder to predict what the consumer of your module </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">will need:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.476.1">
    output "foo" {
      value       = "bar"
      description = "This is my output for foo"
    }</span></pre> <p><span class="koboSpan" id="kobo.477.1">In the preceding code, we declare an output called </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">foo</span></strong><span class="koboSpan" id="kobo.479.1"> that returns a constant value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">bar</span></strong><span class="koboSpan" id="kobo.481.1">. </span><span class="koboSpan" id="kobo.481.2">While this example could be more practical, its simplicity will be instructive. </span><span class="koboSpan" id="kobo.481.3">Namely, that output values can be any valid expression in HCL. </span><span class="koboSpan" id="kobo.481.4">I draw your attention to this because you will no doubt encounter dozens of examples that output an attribute on a resource, but the output block is much more potent than that. </span><span class="koboSpan" id="kobo.481.5">Coupled with all the tools available within HCL—many that we’ll get into later in this chapter—you can construct any value you need. </span><span class="koboSpan" id="kobo.481.6">Knowledge of this capability is crucial in enabling you to smooth the edges between how you integrate Terraform and </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">other tools.</span></span></p>
<p><span class="koboSpan" id="kobo.483.1">It is a good practice to annotate your outputs with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">description</span></strong><span class="koboSpan" id="kobo.485.1"> attribute to inform the consumer of your module (whether it is a user using your module via the command-line tool or from within another Terraform module) of what you intend the output to be and its purpose and what type of data they </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">can expect.</span></span></p>
<h3><span class="koboSpan" id="kobo.487.1">Sensitive data</span></h3>
<p><span class="koboSpan" id="kobo.488.1">Sometimes, you may need to </span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.489.1">output sensitive data such as a password, connection string, or access key. </span><span class="koboSpan" id="kobo.489.2">Most resources will define which attributes are considered sensitive, so Terraform will warn you </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">if necessary:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.491.1">
    output "super_secret_password" {
      value        = "NewEnglandClamChowder"
      is_sensitive = true
    }</span></pre> <p><span class="koboSpan" id="kobo.492.1">In the preceding code, we annotate our super secret password with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">is_sensitive</span></strong><span class="koboSpan" id="kobo.494.1"> attribute to inform Terraform that this is not data that we would like it to shout to the world from </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">the rooftops!</span></span></p>
<p><span class="koboSpan" id="kobo.496.1">Now that we understand how to declare inputs and outputs within our Terraform modules and the basic structures—resources, data sources, and locals—that we work with so frequently, we are ready to move on to some more complex structures in the language. </span><span class="koboSpan" id="kobo.496.2">Our first s</span><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.497.1">top is meta-arguments. </span><span class="koboSpan" id="kobo.497.2">Sounds </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">fun, right?</span></span></p>
<h1 id="_idParaDest-49"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.499.1">Meta-arguments</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.500.1">Meta-arguments</span></strong><span class="koboSpan" id="kobo.501.1"> are </span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.502.1">attributes that you can set on any resource block. </span><span class="koboSpan" id="kobo.502.2">They allow you to control different aspects of the resource related to its context, dependencies, and lifecycle. </span><span class="koboSpan" id="kobo.502.3">Each meta-argument enables finer-grained control over that resource by allowing the developer to give very focused re</span><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.503.1">source-specific instructions </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">to Terraform.</span></span></p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.505.1">Provider</span></h2>
<p><span class="koboSpan" id="kobo.506.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">provider</span></strong><span class="koboSpan" id="kobo.508.1"> meta-argument</span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.509.1"> is a</span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.510.1"> reference that allows you to specify under which provider context you would like to deploy the resource. </span><span class="koboSpan" id="kobo.510.2">The scope of the context is dependent on the provider you are using. </span><span class="koboSpan" id="kobo.510.3">The two most common scopes are which region you are deploying to within a public cloud and what authentication credential you </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">are using.</span></span></p>
<p><span class="koboSpan" id="kobo.512.1">You will need to understand the specific scoping mechanism of your providers. </span><span class="koboSpan" id="kobo.512.2">This book will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">aws</span></strong><span class="koboSpan" id="kobo.514.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">azurerm</span></strong><span class="koboSpan" id="kobo.516.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">google</span></strong><span class="koboSpan" id="kobo.518.1"> providers. </span><span class="koboSpan" id="kobo.518.2">Each provider defines its scope differently. </span><span class="koboSpan" id="kobo.518.3">The scope of the AWS provider is an AWS account and an AWS Region. </span><span class="koboSpan" id="kobo.518.4">The scope for the GCP provider is a GCP project and a GCP region. </span><span class="koboSpan" id="kobo.518.5">The Azure provider is scoped</span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.519.1"> only to an </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">Azure </span></span><span class="No-Break"><a id="_idIndexMarker147"/></span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">subscription:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.522.1">
    provider "aws" {
      region = "us-east-1"
    }
    provider "aws" {
      alias  = "secondary"
      region = "us-west-1"
    }</span></pre> <p><span class="koboSpan" id="kobo.523.1">Then, when attaching to resources, if you do not specify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">provider</span></strong><span class="koboSpan" id="kobo.525.1"> meta-argument, all the resources you declare will be provisioned by Terraform using the default </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">aws</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.527.1"> provider:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.528.1">
    resource "aws_instance" "foo" {
    }</span></pre> <p><span class="koboSpan" id="kobo.529.1">When you want to provision to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">secondary</span></strong><span class="koboSpan" id="kobo.531.1"> instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">aws</span></strong><span class="koboSpan" id="kobo.533.1"> provider, you will need to declare it using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">provider</span></strong><span class="koboSpan" id="kobo.535.1"> meta-argument on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">resource</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.537.1">block itself:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.538.1">
    resource "aws_instance" "bar" {
      provider = aws.secondary
    }</span></pre> <p><span class="koboSpan" id="kobo.539.1">Therefore, when</span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.540.1"> using AWS and GCP to do multi-region deployments, you will see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">provider</span></strong><span class="koboSpan" id="kobo.542.1"> meta-argument to provision resources to different AWS and GCP regions. </span><span class="koboSpan" id="kobo.542.2">However, on Azure, you’ll only see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">provider</span></strong><span class="koboSpan" id="kobo.544.1"> meta-argument to </span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.545.1">provision across multi</span><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.546.1">ple subscriptions—a very exotic </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">deployment type.</span></span></p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.548.1">Depends on</span></h2>
<p><span class="koboSpan" id="kobo.549.1">Sometimes, when</span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.550.1"> Terraform is planning, it needs help to get the dependency graph right. </span><span class="koboSpan" id="kobo.550.2">That’s because Terraform can only detect explicit dependencies—but sometimes, you can have implicit dependencies, depending on the provider and the resource within that provider. </span><span class="koboSpan" id="kobo.550.3">These implicit dependencies occur when a resource requires another, but there is no direct relationship between </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">the resources:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer028">
<span class="koboSpan" id="kobo.552.1"><img alt="Figure 2.1 – Implicit dependency between the Key Vault secret and Key Vault access policy" src="image/B21183_02_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.553.1">Figure 2.1 – Implicit dependency between the Key Vault secret and Key Vault access policy</span></p>
<p><span class="koboSpan" id="kobo.554.1">A great example</span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.555.1"> is whenever you use Azure Key Vault. </span><span class="koboSpan" id="kobo.555.2">You need permissions within the key vault itself before creating secrets. </span><span class="koboSpan" id="kobo.555.3">Therefore, by default, the identity running Terraform does not have access to create secrets within the key vault it </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">just created:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.557.1">
    resource "azurerm_key_vault" "top_secret" {
      name     = "kv-top-secret"
      sku_name = "standard"
    }
    resource "azurerm_key_vault_secret" "foo" {
      name         = "foo"
      value        = "bar"
      key_vault_id = azurerm_key_vault.top_secret.id
    }</span></pre> <p><span class="koboSpan" id="kobo.558.1">The preceding code will fail. </span><span class="koboSpan" id="kobo.558.2">You need to explicitly grant the identity that Terraform is running under access to Key Vault to</span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.559.1"> create secrets. </span><span class="koboSpan" id="kobo.559.2">You can do this by adding an </span><strong class="bold"><span class="koboSpan" id="kobo.560.1">access </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.561.1">policy resource</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.563.1">
    data "azurerm_client_config" "current" {}
    resource "azurerm_key_vault_access_policy" "terraform" {
      key_vault_id = azurerm_key_vault.top_secret.id
      tenant_id    = data.azurerm_client_config.current.tenant_id
      object_id    = data.azurerm_client_config.current.object_id
      secret_permissions = [
        "Get", "List", "Set"      ]
    }</span></pre> <p><span class="koboSpan" id="kobo.564.1">Unfortunately, after</span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.565.1"> adding this access policy resource, my code still won’t work. </span><span class="koboSpan" id="kobo.565.2">When I run </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">apply</span></strong><span class="koboSpan" id="kobo.567.1">, it will tell in my code! </span><span class="koboSpan" id="kobo.567.2">Because there is no explicit dependency between the secret and the access policy, Terraform thinks that both can be created in parallel—thus creating a race condition that will inevitably fail when Terraform attempts to make </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">the secret.</span></span></p>
<p><span class="koboSpan" id="kobo.569.1">Therefore, we need to make sure that we define the dependency of the secret on the access policy so that Terraform knows that it needs to create the access policy before we attempt to create </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">the secret:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.571.1">
    resource "azurerm_key_vault_secret" "foo" {
      name         = "foo"
      value        = "bar"
      key_vault_id = azurerm_key_vault.top_secret.id
      depends_on = [azurerm_key_vault_access_policy.terraform]
    }</span></pre> <p><span class="koboSpan" id="kobo.572.1">By explicitly declaring the dependency between the secret and the access policy, we will solve the problem in our Terrafo</span><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.573.1">rm plan that creates a race condition </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">between them.</span></span></p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.575.1">Lifecycle</span></h2>
<p><span class="koboSpan" id="kobo.576.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">lifecycle</span></strong><span class="koboSpan" id="kobo.578.1"> meta-argument</span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.579.1"> is a block that can appear on any resource </span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.580.1">block and is used to alter the control of that resource’s—well—lifecycle. </span><span class="koboSpan" id="kobo.580.2">That is the resource’s creation and deletion—the birth and death. </span><span class="koboSpan" id="kobo.580.3">Each option allows you to handle edge cases where</span><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.581.1"> you want Terraform to behave differently </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">than usual.</span></span></p>
<h3><span class="koboSpan" id="kobo.583.1">Create before destroy</span></h3>
<p><span class="koboSpan" id="kobo.584.1">This situation </span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.585.1">reminds me of that classic movie scene from </span><em class="italic"><span class="koboSpan" id="kobo.586.1">Indiana Jones and the Raiders of the Lost Ark</span></em><span class="koboSpan" id="kobo.587.1">, where Indy is in a booby-trapped Peruvian temple. </span><span class="koboSpan" id="kobo.587.2">To acquire the golden statue, he must replace it with something. </span><span class="koboSpan" id="kobo.587.3">First, Indy has to create a bag of dirt to replace the golden statue. </span><span class="koboSpan" id="kobo.587.4">Then, he must delicately replace the golden statue with it. </span><span class="koboSpan" id="kobo.587.5">The situation that our hero, Indy, finds himself in is the essence of </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">create_before_destroy</span></strong><span class="koboSpan" id="kobo.589.1">. </span><span class="koboSpan" id="kobo.589.2">In these situations, you need the new thing before you get rid of the old. </span><span class="koboSpan" id="kobo.589.3">There are many examples of this scenario. </span><span class="koboSpan" id="kobo.589.4">It can</span><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.590.1"> apply to certificates, security groups, and </span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">the like.</span></span></p>
<h3><span class="koboSpan" id="kobo.592.1">Lock resources</span></h3>
<p><span class="koboSpan" id="kobo.593.1">For some </span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.594.1">resources, you don’t want to take the chance that a less-than-careful administrator will blow them away without thoroughly analyzing </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">terraform plan</span></strong><span class="koboSpan" id="kobo.596.1">—an unfortunately common occurrence. </span><span class="koboSpan" id="kobo.596.2">This situation is where </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">prevent_destroy</span></strong><span class="koboSpan" id="kobo.598.1"> comes into play. </span><span class="koboSpan" id="kobo.598.2">By adding this meta-argument to your resources, you are adding yet another gate that the user must explicitly remove before they can destroy the resource. </span><span class="koboSpan" id="kobo.598.3">Many cloud services natively support this feature, but not all. </span><span class="koboSpan" id="kobo.598.4">Therefore, Terraform allows you to enable this feature within your HCL code on any resource vital to the environment’s health or may contain statef</span><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.599.1">ul data that you would lose in the case </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">of destruction.</span></span></p>
<h3><span class="koboSpan" id="kobo.601.1">Ignore changes</span></h3>
<p><span class="koboSpan" id="kobo.602.1">Sometimes, Terraform is</span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.603.1"> one of many tools that operate in an environment, or you want to allow manual administration of a particular feature after deployment. </span><span class="koboSpan" id="kobo.603.2">In this case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">ignore_changes</span></strong><span class="koboSpan" id="kobo.605.1"> option will enable you to provision the resource with Terraform but ignore changes made outside </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">of Terraform:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.607.1">
    lifecycle {
      ignore_changes = [
        tags
      ]
    }</span></pre> <p><span class="koboSpan" id="kobo.608.1">Ignore changes is an array of object references relative to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">resource</span></strong><span class="koboSpan" id="kobo.610.1"> block you defined. </span><span class="koboSpan" id="kobo.610.2">You can imagine </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">this</span></strong><span class="koboSpan" id="kobo.612.1"> before any reference within the list. </span><span class="koboSpan" id="kobo.612.2">You will get an</span><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.613.1"> error if you attempt to</span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.614.1"> reference an </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">external resource.</span></span></p>
<h3><span class="koboSpan" id="kobo.616.1">Replace triggered by</span></h3>
<p><span class="koboSpan" id="kobo.617.1">Many</span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.618.1"> Terraform resources already know what circumstances should cause Terraform to trigger a replacement. </span><span class="koboSpan" id="kobo.618.2">The cause is usually a change in the value of a critical attribute. </span><span class="koboSpan" id="kobo.618.3">However, sometimes, there are situations where you want Terraform to replace the resource when another resource is updated or replaced. </span><span class="koboSpan" id="kobo.618.4">Often, this can happen when there is no direct dependency between the resources, making it difficult for Terraform to determine that a destructive action is </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">taking place.</span></span></p>
<p><span class="koboSpan" id="kobo.620.1">For example, with an Azure Virtual Desktop host pool, the host pool and its </span><strong class="bold"><span class="koboSpan" id="kobo.621.1">virtual machines</span></strong><span class="koboSpan" id="kobo.622.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.623.1">VMs</span></strong><span class="koboSpan" id="kobo.624.1">) are </span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.625.1">declared independently. </span><span class="koboSpan" id="kobo.625.2">Still, they are associated with a third resource called a VM extension that will initiate the joining of the VM with the host pool. </span><span class="koboSpan" id="kobo.625.3">In this scenario, Terraform knows about the VM’s relationship with the VM extension and the VM extension’s relationship with the host pool. </span><span class="koboSpan" id="kobo.625.4">Still, because you create the host pool’s relationship with the VM through an attribute in the VM extension, it does not cause a replacement if it is updated. </span><span class="koboSpan" id="kobo.625.5">Therefore, the VM will never be reattached to the host pool if </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">it changes:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<span class="koboSpan" id="kobo.627.1"><img alt="Figure 2.2 – Implicit dependency between the host pool and VM prevent﻿s Terraform from replacing the VM if the host pool changes" src="image/B21183_02_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.628.1">Figure 2.2 – Implicit dependency between the host pool and VM prevent</span><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.629.1">s Terraform from replacing the VM if the host pool changes</span></p>
<p><span class="koboSpan" id="kobo.630.1">Now that we understand how to modify Terraform’s default behavior using meta-arguments, we can handle better edge cases specific to the cloud resources we plan on provisioning with whatever providers we want to use. </span><span class="koboSpan" id="kobo.630.2">Now, it’s time to scale things up by learning to turn Terraform into a resource factory—pumping out complex configurations without all </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">the copypasta!</span></span></p>
<h1 id="_idParaDest-53"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.632.1">Loops and iterations</span></h1>
<p><span class="koboSpan" id="kobo.633.1">There are three </span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.634.1">different ways to</span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.635.1"> iterate within HCL. </span><span class="koboSpan" id="kobo.635.2">The most common are two meta-arguments, </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">for_each</span></strong><span class="koboSpan" id="kobo.637.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">count</span></strong><span class="koboSpan" id="kobo.639.1">, which operate on a resource, module, or data source block. </span><span class="koboSpan" id="kobo.639.2">At the same time, the third option </span><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.640.1">uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">for</span></strong><span class="koboSpan" id="kobo.642.1"> expression, which operations on </span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">any collection.</span></span></p>
<p><span class="No-Break"><span class="koboSpan" id="kobo.644.1">Count</span></span></p>
<p><span class="koboSpan" id="kobo.645.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">count</span></strong><span class="koboSpan" id="kobo.647.1"> meta-argument</span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.648.1"> is Terraform’s oldest method of iterating resources: an </span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.649.1">oldie but a goodie. </span><span class="koboSpan" id="kobo.649.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">count</span></strong><span class="koboSpan" id="kobo.651.1"> meta-argument is excellent when you want to provision the same block multiple times and have no unique identifier to key off of. </span><span class="koboSpan" id="kobo.651.2">In this situation, you will use the item’s index in a list to determine its uniqueness. </span><span class="koboSpan" id="kobo.651.3">This approach can pose challenges in the future if the items in the list need to change in such a way that would cause the indices of each item </span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">to change.</span></span></p>
<p><span class="koboSpan" id="kobo.653.1">The best way to manage this is to treat your list as append-only, as this will avoid replacing related resources. </span><span class="koboSpan" id="kobo.653.2">Adding or removing items from the middle of the list will cause all the items below that item to shift their index, resulting in destruction </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">and recreation.</span></span></p>
<p><span class="koboSpan" id="kobo.655.1">For example, if you want to provision a five-node cluster, you wouldn’t remove a specific node from the cluster when you scale down. </span><span class="koboSpan" id="kobo.655.2">You would reduce the number of nodes. </span><span class="koboSpan" id="kobo.655.3">You don’t care which nodes get removed. </span><span class="koboSpan" id="kobo.655.4">You only care how many there are. </span><span class="koboSpan" id="kobo.655.5">In this situation, it is ideal to </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">use </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">count</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.659.1">
    resource "aws_instance" "node" {
      count = var.no</span><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.660.1">de_count
      # the rest of the configuration
    }</span></pre> <h2 id="_idParaDest-54"><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.661.1">For each</span></h2>
<p><span class="koboSpan" id="kobo.662.1">An alternative to </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">count</span></strong><span class="koboSpan" id="kobo.664.1"> is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">for_each</span></strong><span class="koboSpan" id="kobo.666.1"> meta-argument, which allows you to create multiple blocks from a </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">map</span></strong><span class="koboSpan" id="kobo.668.1"> collection. </span><span class="koboSpan" id="kobo.668.2">This approach can be a distinct improvement over the </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">count</span></strong><span class="koboSpan" id="kobo.670.1"> technique</span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.671.1"> because the order of the items in the collection does not </span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.672.1">matter—only the key. </span><span class="koboSpan" id="kobo.672.2">If you update the code to remove the key, Terraform will remove the corresponding item. </span><span class="koboSpan" id="kobo.672.3">If the item changes order with other items in the collection, it will not affect </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">Terraform’s plan.</span></span></p>
<p><span class="koboSpan" id="kobo.674.1">This approach is only possible with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">map</span></strong><span class="koboSpan" id="kobo.676.1"> collection as the source of the iteration because, with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">map</span></strong><span class="koboSpan" id="kobo.678.1"> collection type, each item must have a key that uniquely identifies it amongst </span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">its peers.</span></span></p>
<p><span class="koboSpan" id="kobo.680.1">As a result, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">for_each</span></strong><span class="koboSpan" id="kobo.682.1"> works well when deploying to multiple regions as, typically, you wouldn’t have more than one deployment in the same region; hence, the region name makes an excellent unique key for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">map</span></strong><span class="koboSpan" id="kobo.684.1"> that drives the </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">for_each</span></strong><span class="koboSpan" id="kobo.686.1"> loop. </span><span class="koboSpan" id="kobo.686.2">You can add or remove regions without worrying about shifting the index of the items in </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">the collection:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.688.1">
    locals {
      regions = {
        westus = {
          node_count = 5
        }
        eastus = {
          node_count = 8
        }
      }
    }</span></pre> <p><span class="koboSpan" id="kobo.689.1">Consider the preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">map</span></strong><span class="koboSpan" id="kobo.691.1"> configuration. </span><span class="koboSpan" id="kobo.691.2">Using this as the collection, we can drive any number of resources, data sources, </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">or modules:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.693.1">
    module "regional_deployment" {
      for_each = local.regions
      node_count = each.value.node_count
      # the rest of the configuration
    }</span></pre> <p><span class="koboSpan" id="kobo.694.1">In the preceding code, we</span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.695.1"> see that we are setting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">for_each</span></strong><span class="koboSpan" id="kobo.697.1"> source to be the</span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.698.1"> map stored in </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">local.regions</span></strong><span class="koboSpan" id="kobo.700.1">. </span><span class="koboSpan" id="kobo.700.2">We then can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">each</span></strong><span class="koboSpan" id="kobo.702.1"> prefix anywhere within the module block to access either the key or the value using </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">each.key</span></strong><span class="koboSpan" id="kobo.704.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">each.value</span></strong><span class="koboSpan" id="kobo.706.1">, respectively. </span><span class="koboSpan" id="kobo.706.2">No matter the value’s type, we can address it how</span><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.707.1"> we normally would, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">each.value</span></strong><span class="koboSpan" id="kobo.709.1"> as a reference to </span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">the object.</span></span></p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.711.1">For expressions</span></h2>
<p><span class="koboSpan" id="kobo.712.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">for</span></strong><span class="koboSpan" id="kobo.714.1"> expression</span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.715.1"> is a way of iterating within Terraform that does not require you to attach it to a block (i.e., resource, data source, or module). </span><span class="koboSpan" id="kobo.715.2">You can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">for</span></strong><span class="koboSpan" id="kobo.717.1"> expression to construct in-memory objects to apply object</span><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.718.1"> transformations to streamline block-based iteration or </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">for output.</span></span></p>
<h3><span class="koboSpan" id="kobo.720.1">Iterating over a list</span></h3>
<p><span class="koboSpan" id="kobo.721.1">When</span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.722.1"> iterating over a </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">list</span></strong><span class="koboSpan" id="kobo.724.1">, you must specify only one parameter to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">for</span></strong><span class="koboSpan" id="kobo.726.1"> expression. </span><span class="koboSpan" id="kobo.726.2">This parameter will represent each item within your </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">list</span></strong><span class="koboSpan" id="kobo.728.1"> so that you can access each item within the </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">output block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.730.1">
region_names_list = [
for s in var.regions : 
upper("${s.region}${s.country}")]</span></pre> <p><span class="koboSpan" id="kobo.731.1">In the preceding example, we are iterating over all the objects in </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">var.regions</span></strong><span class="koboSpan" id="kobo.733.1">. </span><span class="koboSpan" id="kobo.733.2">As we do, during each iteration, the current value is accessible in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">s</span></strong><span class="koboSpan" id="kobo.735.1"> parameter. </span><span class="koboSpan" id="kobo.735.2">We can use the output block to generate any object we desire</span><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.736.1"> to be created in the new list that this </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">for</span></strong><span class="koboSpan" id="kobo.738.1"> expression </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">will create.</span></span></p>
<h3><span class="koboSpan" id="kobo.740.1">Iterating over a map</span></h3>
<p><span class="koboSpan" id="kobo.741.1">When iterating</span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.742.1"> over a </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">map</span></strong><span class="koboSpan" id="kobo.744.1">, you must change how you structure your </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">for</span></strong><span class="koboSpan" id="kobo.746.1"> expression. </span><span class="koboSpan" id="kobo.746.2">You must specify two instead of one parameter declared immediately after the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">for</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.748.1"> keyword:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.749.1">
      region_array_from_map = [
        for k, v in var.regions :
        {
          region        = k,
          address_space = v.address_space
          node_count    = v.node_count
        }
      ]</span></pre> <p><span class="koboSpan" id="kobo.750.1">In the preceding example, you’ll see that we specify two parameters for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">for</span></strong><span class="koboSpan" id="kobo.752.1"> expression: </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">k</span></strong><span class="koboSpan" id="kobo.754.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">v</span></strong><span class="koboSpan" id="kobo.756.1">. </span><span class="koboSpan" id="kobo.756.2">We chose these names as a convention to help us remember what these variables mean within the scope of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">for</span></strong><span class="koboSpan" id="kobo.758.1"> expression. </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">k</span></strong><span class="koboSpan" id="kobo.760.1"> represents the map’s key, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">v</span></strong><span class="koboSpan" id="kobo.762.1"> represents the value. </span><span class="koboSpan" id="kobo.762.2">The value can be any type, be it a primitive, collection, or complex object. </span><span class="koboSpan" id="kobo.762.3">If we want to access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">value</span></strong><span class="koboSpan" id="kobo.764.1"> object, we access it based on its type. </span><span class="koboSpan" id="kobo.764.2">In this example, the value is a complex object with two attributes. </span><span class="koboSpan" id="kobo.764.3">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">for</span></strong><span class="koboSpan" id="kobo.766.1"> expression’s output block, we specify the structure of the object we want each item in the resulting array </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">to have.</span></span></p>
<p><span class="koboSpan" id="kobo.768.1">In this case, we are creating an array of objects with three attributes: </span><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">region</span></strong><span class="koboSpan" id="kobo.770.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">address_space</span></strong><span class="koboSpan" id="kobo.772.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">node_count</span></strong><span class="koboSpan" id="kobo.774.1">, essentially flattening the original map into an array of objects. </span><span class="koboSpan" id="kobo.774.2">The </span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.775.1">output looks </span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.777.1">
    region_array_from_map = [
      {
        "address_space" = "10.0.1.0/24"
        "node_count" = 5
        "region" = "eastus"
      },
      {
        "address_space" = "10.0.0.0/2</span><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.778.1">4"
        "node_count" = 8
        "region" = "westus"
      },
    ]</span></pre> <h3><span class="koboSpan" id="kobo.779.1">Outputting a list</span></h3>
<p><span class="koboSpan" id="kobo.780.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">for</span></strong><span class="koboSpan" id="kobo.782.1"> expression</span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.783.1"> will always output either a </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">list</span></strong><span class="koboSpan" id="kobo.785.1"> or an object. </span><span class="koboSpan" id="kobo.785.2">You can select the output type you want by the character in which you wrap the </span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">for</span></strong><span class="koboSpan" id="kobo.787.1"> block. </span><span class="koboSpan" id="kobo.787.2">If you wrap the </span><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">for</span></strong><span class="koboSpan" id="kobo.789.1"> expression in square brackets, then the expression will output </span><span class="No-Break"><span class="koboSpan" id="kobo.790.1">a </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">list</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.793.1">
    region_list = [for s in var.regions : "${s.region}${s.country}"]</span></pre> <p><span class="koboSpan" id="kobo.794.1">The preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">for</span></strong><span class="koboSpan" id="kobo.796.1"> expression will produce the </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">following output:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.798.1">
    region_list = [
      "westus",
      "eastus",
    ]</span></pre> <p><span class="koboSpan" id="kobo.799.1">Sometimes, the </span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.800.1">names of the module or resource outputs don’t align precisely with other resources’ desired inputs. </span><span class="koboSpan" id="kobo.800.2">Therefore, using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">for</span></strong><span class="koboSpan" id="kobo.802.1"> expression and outputting a list can help transform these incongruent output values in</span><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.803.1">to a format convenient for consumption within another part of </span><span class="No-Break"><span class="koboSpan" id="kobo.804.1">your code.</span></span></p>
<h3><span class="koboSpan" id="kobo.805.1">Outputting an object</span></h3>
<p><span class="koboSpan" id="kobo.806.1">Wrapping the </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">for</span></strong><span class="koboSpan" id="kobo.808.1"> expression </span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.809.1">with curly braces will output </span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">an object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.811.1">
    locals {
      region_config_object = {
        for s in var.regions : "${s.region}${s.country}" =&gt;
        {
          node_count = s.node_count
        }
      }
    }</span></pre> <p><span class="koboSpan" id="kobo.812.1">This approach will output an object with attributes for each item in the list of regions in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">regions</span></strong><span class="koboSpan" id="kobo.814.1"> input variable. </span><span class="koboSpan" id="kobo.814.2">Each attribute will take the name of the concatenation of the region and country names, and its value will be an object with a single attribute called </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">node_count</span></strong><span class="koboSpan" id="kobo.816.1">. </span><span class="koboSpan" id="kobo.816.2">The output will look </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.818.1">
    region_config_object = {
      "eastus" = {
        "node_count" = 8
      }
      "westus" = {
        "node_count" = 8
      }
    }</span></pre> <p><span class="koboSpan" id="kobo.819.1">Outputting an object can be very useful in scenarios where you need to generate a JSON or YAML payload. </span><span class="koboSpan" id="kobo.819.2">You can reference this payload in another resource or output it so another tool </span><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.820.1">can</span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.821.1"> extract that value from Terraform using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">terraform </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">output</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.824.1"> command.</span></span></p>
<h3><span class="koboSpan" id="kobo.825.1">Converting a list to a map</span></h3>
<p><span class="koboSpan" id="kobo.826.1">One common</span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.827.1"> problem is converting a list into a map. </span><span class="koboSpan" id="kobo.827.2">This is needed because, while a list is sometimes the most concise way of storing a simple collection, it cannot be used with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">for_each</span></strong><span class="koboSpan" id="kobo.829.1"> iterator. </span><span class="koboSpan" id="kobo.829.2">Therefore, if you want to have your cake and eat it too, you need to convert that list into a map. </span><span class="koboSpan" id="kobo.829.3">This can be done with a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">for</span></strong><span class="koboSpan" id="kobo.831.1"> expression that iterates over the list in memory and outputs </span><span class="No-Break"><span class="koboSpan" id="kobo.832.1">a map:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.833.1">
    locals {
      foo_list = ["A", "B", "C"]
      foo_map = {
        for idx, element in local.foo_list : element =&gt; idx
      }
    }</span></pre> <p><span class="koboSpan" id="kobo.834.1">In the preceding code, we are invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">for</span></strong><span class="koboSpan" id="kobo.836.1"> expression and outputting an object using curly braces (</span><strong class="source-inline"><span class="koboSpan" id="kobo.837.1">{}</span></strong><span class="koboSpan" id="kobo.838.1">). </span><span class="koboSpan" id="kobo.838.2">We are taking each element within the list and setting it as the key of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">map</span></strong><span class="koboSpan" id="kobo.840.1"> and taking the element’s index within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">list</span></strong><span class="koboSpan" id="kobo.842.1"> and setting it as the value. </span><span class="koboSpan" id="kobo.842.2">It’s important to note that this will only work when the items in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">list</span></strong><span class="koboSpan" id="kobo.844.1"> are </span><span class="No-Break"><span class="koboSpan" id="kobo.845.1">not duplicates.</span></span></p>
<p><span class="koboSpan" id="kobo.846.1">Now that we know how to loop, swoop, iterate, and cross-mojinate, we can avoid the pitfalls of copypasta by leveraging Terraform’s three extremely powerful iterators—</span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">count</span></strong><span class="koboSpan" id="kobo.848.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">for_each</span></strong><span class="koboSpan" id="kobo.850.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">for</span></strong><span class="koboSpan" id="kobo.852.1">—to build dynamic collections of resources, data sources, or </span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">anything really!</span></span></p>
<p><span class="koboSpan" id="kobo.854.1">We are nearing the end of our journey into the depths of HCL. </span><span class="koboSpan" id="kobo.854.2">Next, we will look at a few more language expressions that help us cope when we want to use dynamic collections and conditional logic to jazz up </span><span class="No-Break"><span class="koboSpan" id="kobo.855.1">our modules!</span></span></p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.856.1">Expressions</span></h1>
<p><span class="koboSpan" id="kobo.857.1">The HCL has some unique expressions</span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.858.1"> to handle complex scenarios such as conditional logic, referencing dynamic types, and iterating nested blocks. </span><span class="koboSpan" id="kobo.858.2">We will learn about these final language structures before</span><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.859.1"> we delve into the library of functions available to us within </span><span class="No-Break"><span class="koboSpan" id="kobo.860.1">the language.</span></span></p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.861.1">Conditional expressions</span></h2>
<p><span class="koboSpan" id="kobo.862.1">In other languages, this technique is</span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.863.1"> called a ternary conditional operator—namely, of the</span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.864.1"> imperative variety. </span><span class="koboSpan" id="kobo.864.2">That’s fancy talk for an </span><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">if</span></strong><span class="koboSpan" id="kobo.866.1"> statement in HCL. </span><span class="koboSpan" id="kobo.866.2">Typically, an </span><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">if</span></strong><span class="koboSpan" id="kobo.868.1"> block spans multiple lines of code and uses some method for scoping the </span><span class="No-Break"><span class="koboSpan" id="kobo.869.1">two conditions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.870.1">
    if (x == 5) {
      // do something
    } else {
      // do something else
    }</span></pre> <p><span class="koboSpan" id="kobo.871.1">This classic example shows how a conditional statement manifests in an imperative language. </span><span class="koboSpan" id="kobo.871.2">The curly brackets provide scope for the code that the computer will execute when the Boolean expression is </span><strong class="source-inline"><span class="koboSpan" id="kobo.872.1">true</span></strong><span class="koboSpan" id="kobo.873.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">false</span></strong><span class="koboSpan" id="kobo.875.1">. </span><span class="koboSpan" id="kobo.875.2">In imperative code, you can do anything inside these </span><span class="No-Break"><span class="koboSpan" id="kobo.876.1">scoped regions.</span></span></p>
<p><span class="koboSpan" id="kobo.877.1">The difference between this approach and using </span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.878.1">a </span><strong class="bold"><span class="koboSpan" id="kobo.879.1">ternary conditional operator</span></strong><span class="koboSpan" id="kobo.880.1"> is that, with the former, the goal is always to produce </span><span class="No-Break"><span class="koboSpan" id="kobo.881.1">a value.</span></span></p>
<p><span class="koboSpan" id="kobo.882.1">With a ternary conditional operator, each condition must return a value. </span><span class="koboSpan" id="kobo.882.2">Consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.883.1">following expression:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.884.1">
    y = x == 5 ? </span><span class="koboSpan" id="kobo.884.2">x * 10 : 0</span></pre> <p><span class="koboSpan" id="kobo.885.1">The preceding expression will set the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.886.1">y</span></strong><span class="koboSpan" id="kobo.887.1"> to be </span><strong class="source-inline"><span class="koboSpan" id="kobo.888.1">50</span></strong><span class="koboSpan" id="kobo.889.1"> when </span><strong class="source-inline"><span class="koboSpan" id="kobo.890.1">x</span></strong><span class="koboSpan" id="kobo.891.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.892.1">5</span></strong><span class="koboSpan" id="kobo.893.1">, and it will set the value to </span><strong class="source-inline"><span class="koboSpan" id="kobo.894.1">0</span></strong><span class="koboSpan" id="kobo.895.1"> for any other value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">x</span></strong><span class="koboSpan" id="kobo.897.1">. </span><span class="koboSpan" id="kobo.897.2">The equivalent </span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.898.1">imperative code would look </span><span class="No-Break"><span class="koboSpan" id="kobo.899.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.900.1">
    int y;
    if (x == 5) {
      y = x * 10
    } else {
      y = 0
    }</span></pre> <p><span class="koboSpan" id="kobo.901.1">The difference</span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.902.1"> between this imperative alternative and the ternary </span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.903.1">conditional operator statement is that the developer can do other things in the scope reg</span><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.904.1">ions that are either related or unrelated to setting the value of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.905.1">y</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.906.1"> appropriately.</span></span></p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.907.1">Splat expressions</span></h2>
<p><span class="koboSpan" id="kobo.908.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.909.1">splat expression</span></strong><span class="koboSpan" id="kobo.910.1"> is </span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.911.1">another way of</span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.912.1"> accessing an attribute of each item in a list of objects. </span><span class="koboSpan" id="kobo.912.2">You can use this expression to access a single attribute from a resource or module block with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.913.1">count</span></strong><span class="koboSpan" id="kobo.914.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.915.1">for_each</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.916.1">meta-argument attached:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.917.1">
    resource "aws_instance" "node" {
      count = var.node_count
      # the rest of the configuration
    }</span></pre> <p><span class="koboSpan" id="kobo.918.1">Consider this collection of AWS EC2 instances. </span><span class="koboSpan" id="kobo.918.2">This block uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.919.1">count</span></strong><span class="koboSpan" id="kobo.920.1"> meta-argument to create a dynamic number of these resources from </span><strong class="source-inline"><span class="koboSpan" id="kobo.921.1">0</span></strong><span class="koboSpan" id="kobo.922.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.923.1">n</span></strong><span class="koboSpan" id="kobo.924.1">, where </span><strong class="source-inline"><span class="koboSpan" id="kobo.925.1">n</span></strong><span class="koboSpan" id="kobo.926.1"> is the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.927.1">var.node_count</span></strong><span class="koboSpan" id="kobo.928.1">. </span><span class="koboSpan" id="kobo.928.2">As a result, we can’t just access output values from this resource like we usually would if it were singular. </span><span class="koboSpan" id="kobo.928.3">We need to access it using an index to specify which instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.929.1">resource</span></strong><span class="koboSpan" id="kobo.930.1"> block we want </span><span class="No-Break"><span class="koboSpan" id="kobo.931.1">to access:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.932.1">
    locals {
      first_instance_id = aws_instance.node[0].id
    }</span></pre> <p><span class="koboSpan" id="kobo.933.1">In this case, we specify the index of </span><strong class="source-inline"><span class="koboSpan" id="kobo.934.1">0</span></strong><span class="koboSpan" id="kobo.935.1"> and access its </span><strong class="source-inline"><span class="koboSpan" id="kobo.936.1">id</span></strong><span class="koboSpan" id="kobo.937.1"> attribute. </span><span class="koboSpan" id="kobo.937.2">But what if we wanted to get all of the values of </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">id</span></strong><span class="koboSpan" id="kobo.939.1"> for every EC2 instance simultaneously? </span><span class="koboSpan" id="kobo.939.2">Using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">for</span></strong><span class="koboSpan" id="kobo.941.1"> expression, we could iterate over the list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">aws_instance</span></strong><span class="koboSpan" id="kobo.943.1"> resources. </span><span class="koboSpan" id="kobo.943.2">However, there is a better way—using the </span><span class="No-Break"><span class="koboSpan" id="kobo.944.1">splat expression:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.945.1">
    locals {
      all_instance_ids = aws_instance.node[*].id
    }</span></pre> <p><span class="koboSpan" id="kobo.946.1">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">*</span></strong><span class="koboSpan" id="kobo.948.1"> instead of an</span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.949.1"> actual numeric index tells Terraform that we want to activate a </span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.950.1">splat expression. </span><span class="koboSpan" id="kobo.950.2">Instead of accessing a single object, we want to access all the objects in the a</span><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.951.1">rray. </span><span class="koboSpan" id="kobo.951.2">Once done, </span><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">id</span></strong><span class="koboSpan" id="kobo.953.1"> returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">list</span></strong><span class="koboSpan" id="kobo.955.1"> containing all the </span><strong class="source-inline"><span class="koboSpan" id="kobo.956.1">id</span></strong><span class="koboSpan" id="kobo.957.1"> values for our </span><span class="No-Break"><span class="koboSpan" id="kobo.958.1">EC2 instances.</span></span></p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.959.1">Dynamic blocks</span></h2>
<p><span class="koboSpan" id="kobo.960.1">We know that Terraform represents the objects it provisions as </span><strong class="source-inline"><span class="koboSpan" id="kobo.961.1">resource</span></strong><span class="koboSpan" id="kobo.962.1"> blocks, which, as we know, support nested blocks within them. </span><span class="koboSpan" id="kobo.962.2">When a nested block supports many instances, it can sometimes be helpful to declare them dynamically using an approach</span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.963.1"> called </span><strong class="bold"><span class="koboSpan" id="kobo.964.1">dynamic blocks</span></strong><span class="koboSpan" id="kobo.965.1">. </span><span class="koboSpan" id="kobo.965.2">With this approach, you essentially drive the number of nested block definitions within a </span><strong class="source-inline"><span class="koboSpan" id="kobo.966.1">resource</span></strong><span class="koboSpan" id="kobo.967.1"> block based on a collection </span><span class="No-Break"><span class="koboSpan" id="kobo.968.1">of objects.</span></span></p>
<p><span class="koboSpan" id="kobo.969.1">Let’s take the example of our Cosmos DB account that needs to replicate its databases across multiple geo-locations. </span><span class="koboSpan" id="kobo.969.2">We can add as many </span><strong class="source-inline"><span class="koboSpan" id="kobo.970.1">geo_location</span></strong><span class="koboSpan" id="kobo.971.1"> nested blocks as we want and configure them accordingly, but this can get tedious—especially if the configuration for each block is </span><span class="No-Break"><span class="koboSpan" id="kobo.972.1">relatively uniform:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.973.1">
    resource "azurerm_cosmosdb_account" "db" {
      name                = "cosmos-foobar"
      location            = azurerm_resource_group.foobar.location
      resource_group_name = azurerm_resource_group.foobar.name
      offer_type          = "Standard"
      kind                = "MongoDB"
      geo_location {
        location          = "westus"
        failover_priority = 0
      }
      geo_location {
        location          = "eastus"
        failover_priority = 1
      }
    }</span></pre> <p><span class="koboSpan" id="kobo.974.1">We can accomplish the</span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.975.1"> same thing using a dynamic block. </span><span class="koboSpan" id="kobo.975.2">Suppose we declare a map that defines the regions we want to replicate across and the failover priority of each region. </span><span class="koboSpan" id="kobo.975.3">In that case, we can use this map to drive a dynamic block that sets up our Cosmos DB account </span><span class="No-Break"><span class="koboSpan" id="kobo.976.1">correctly—and concisely:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.977.1">
    locals {
      regions = {
        westus = 0
        eastus = 1
      }
    }</span></pre> <p><span class="koboSpan" id="kobo.978.1">Now, with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.979.1">map</span></strong><span class="koboSpan" id="kobo.980.1"> configured with our replication region settings, we can use a dynamic block to instruct the Cosmos DB resource on how to set up its </span><strong class="source-inline"><span class="koboSpan" id="kobo.981.1">geo_location</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.982.1">nested blocks:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.983.1">
    resource "azurerm_cosmosdb_account" "db" {
      name                = "cosmos-foobar"
      location            = azurerm_resource_group.foobar.location
      resource_group_name = azurerm_resource_group.foobar.name
      offer_type          = "Standard"
      kind                = "MongoDB"
      dynamic "geo_location" {
        for_each = local.regions
        content {
          location          = geo_location.key
          failover_priority = geo_location.value
        }
      }
    }</span></pre> <p><span class="koboSpan" id="kobo.984.1">Notice that </span><strong class="source-inline"><span class="koboSpan" id="kobo.985.1">geo_location</span></strong><span class="koboSpan" id="kobo.986.1"> becomes a reference to each item in </span><strong class="source-inline"><span class="koboSpan" id="kobo.987.1">local.regions</span></strong><span class="koboSpan" id="kobo.988.1"> as we iterate through it, and </span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.989.1">because </span><strong class="source-inline"><span class="koboSpan" id="kobo.990.1">local.regions</span></strong><span class="koboSpan" id="kobo.991.1"> is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.992.1">map</span></strong><span class="koboSpan" id="kobo.993.1">, that means that </span><strong class="source-inline"><span class="koboSpan" id="kobo.994.1">geo_location</span></strong><span class="koboSpan" id="kobo.995.1"> is an item within this </span><strong class="source-inline"><span class="koboSpan" id="kobo.996.1">map</span></strong><span class="koboSpan" id="kobo.997.1">. </span><span class="koboSpan" id="kobo.997.2">That means that each </span><strong class="source-inline"><span class="koboSpan" id="kobo.998.1">geo_location</span></strong><span class="koboSpan" id="kobo.999.1"> is a key/value pair, and we can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1000.1">key</span></strong><span class="koboSpan" id="kobo.1001.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1002.1">value</span></strong><span class="koboSpan" id="kobo.1003.1"> to access the respective values when we set </span><strong class="source-inline"><span class="koboSpan" id="kobo.1004.1">location</span></strong><span class="koboSpan" id="kobo.1005.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1006.1">failover_priority</span></strong><span class="koboSpan" id="kobo.1007.1"> on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1008.1">content</span></strong><span class="koboSpan" id="kobo.1009.1"> of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1010.1">nested block.</span></span></p>
<p><span class="koboSpan" id="kobo.1011.1">That’s it! </span><span class="koboSpan" id="kobo.1011.2">We have completed all the concepts, syntax, and modifiers within HCL. </span><span class="koboSpan" id="kobo.1011.3">We are ready to start rocking the Terraform </span><span class="No-Break"><span class="koboSpan" id="kobo.1012.1">world, right?</span></span></p>
<p><span class="koboSpan" id="kobo.1013.1">Hold up—before we do that, let’s pack our </span><strong class="bold"><span class="koboSpan" id="kobo.1014.1">bat belt</span></strong><span class="koboSpan" id="kobo.1015.1"> with tools to help us out of many tricky </span><span class="No-Break"><span class="koboSpan" id="kobo.1016.1">situations: functions!</span></span></p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.1017.1">Functions</span></h1>
<p><span class="koboSpan" id="kobo.1018.1">HCL includes dozens of functions</span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.1019.1"> that you can use to help develop your infrastructure with Terraform. </span><span class="koboSpan" id="kobo.1019.2">However, I don’t plan on draining the ocean on every single function because I think many of them cover concepts that are outside the scope of this book. </span><span class="koboSpan" id="kobo.1019.3">I will focus o</span><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.1020.1">n the most pertinent and practical functions of developing excellent cloud infrastructure. </span><span class="koboSpan" id="kobo.1020.2">Another exciting new feature that is available in Terraform 1.8.0 is the introduction of provider-specific functions. </span><span class="koboSpan" id="kobo.1020.3">This allows provider authors (e.g., </span><strong class="source-inline"><span class="koboSpan" id="kobo.1021.1">aws</span></strong><span class="koboSpan" id="kobo.1022.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1023.1">azurerm</span></strong><span class="koboSpan" id="kobo.1024.1">, etc.) to create functions that provide useful functionality that is specific for that provider. </span><span class="koboSpan" id="kobo.1024.2">This could be for common utilities such as parsing and AWS ARN or an Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.1025.1">Resource Identifier</span></span><span class="No-Break"><span class="koboSpan" id="kobo.1026.1">.</span></span></p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.1027.1">Numeric functions</span></h2>
<p><span class="koboSpan" id="kobo.1028.1">Numeric functions </span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.1029.1">operate on objects of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1030.1">number</span></strong><span class="koboSpan" id="kobo.1031.1"> type. </span><span class="koboSpan" id="kobo.1031.2">The usual </span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.1032.1">suspects are present—everything from absolute value, ceiling/floor, min/max, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1033.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.1034.1">Given that these functions cover fundamental concepts in math, they are primarily outside the scope of this book. </span><span class="koboSpan" id="kobo.1034.2">I’d enco</span><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.1035.1">urage you to check out the excellent documentation provided by HashiCorp on </span><span class="No-Break"><span class="koboSpan" id="kobo.1036.1">these functions.</span></span></p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.1037.1">String functions</span></h2>
<p><span class="koboSpan" id="kobo.1038.1">String </span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.1039.1">functions operate on</span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.1040.1"> objects of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1041.1">string</span></strong><span class="koboSpan" id="kobo.1042.1"> type. </span><span class="koboSpan" id="kobo.1042.2">Like the numeric functions, the usual suspects </span><span class="No-Break"><span class="koboSpan" id="kobo.1043.1">are present.</span></span><a id="_idTextAnchor160"/></p>
<p><span class="koboSpan" id="kobo.1044.1">There are several functions related to string manipulation, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1045.1">split</span></strong><span class="koboSpan" id="kobo.1046.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1047.1">replace</span></strong><span class="koboSpan" id="kobo.1048.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1049.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1050.1">join</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1051.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.1052.1">Split</span></h3>
<p><span class="koboSpan" id="kobo.1053.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1054.1">split</span></strong><span class="koboSpan" id="kobo.1055.1"> function</span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.1056.1"> can be helpful when working with comma-delimited</span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.1057.1"> values that you might pass in as input variables. </span><span class="koboSpan" id="kobo.1057.2">You can use input variables of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1058.1">string</span></strong><span class="koboSpan" id="kobo.1059.1"> type to pass in a collection of values. </span><span class="koboSpan" id="kobo.1059.2">Using environment variables or command-line arguments makes it difficult to reliably pass in complex structures such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1060.1">list</span></strong><span class="koboSpan" id="kobo.1061.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1062.1">map</span></strong><span class="koboSpan" id="kobo.1063.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1064.1">object</span></strong><span class="koboSpan" id="kobo.1065.1">. </span><span class="koboSpan" id="kobo.1065.2">Therefore, it is widespread to simplify those complex structures into multiple comma-delimited </span><strong class="source-inline"><span class="koboSpan" id="kobo.1066.1">string</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1067.1">input variables.</span></span></p>
<p><span class="koboSpan" id="kobo.1068.1">Several functions are used</span><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.1069.1"> for cleansing data of unnecessary whitespaces, which can occur when you do </span><span class="No-Break"><span class="koboSpan" id="kobo.1070.1">string manipulation.</span></span></p>
<h3><span class="koboSpan" id="kobo.1071.1">Format</span></h3>
<p><span class="koboSpan" id="kobo.1072.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1073.1">format</span></strong><span class="koboSpan" id="kobo.1074.1"> function</span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.1075.1"> can be a cleaner way to perform string manipulation </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.1076.1">without really nasty string interpolation—which can degrade the readability of your code with all the extra </span><strong class="source-inline"><span class="koboSpan" id="kobo.1077.1">${}</span></strong><span class="koboSpan" id="kobo.1078.1"> symbols added to separate </span><span class="No-Break"><span class="koboSpan" id="kobo.1079.1">object tokens:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1080.1">
    locals {
      foo = "rg-${var.fizz}${var.buzz}${var.wizz}"
    }</span></pre> <p><span class="koboSpan" id="kobo.1081.1">You can replace the preceding code </span><span class="No-Break"><span class="koboSpan" id="kobo.1082.1">with this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1083.1">
    locals {
      foo = format("rg-%s%s%s, var.fizz, var.buzz, var.wizz)
    }</span></pre> <p><span class="koboSpan" id="kobo.1084.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1085.1">fizz</span></strong><span class="koboSpan" id="kobo.1086.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1087.1">buzz</span></strong><span class="koboSpan" id="kobo.1088.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1089.1">wizz</span></strong><span class="koboSpan" id="kobo.1090.1"> values are passed into the corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.1091.1">%s</span></strong><span class="koboSpan" id="kobo.1092.1">. </span><span class="koboSpan" id="kobo.1092.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1093.1">%s</span></strong><span class="koboSpan" id="kobo.1094.1"> symbol is a token to inject values passed in with specific formatting instructions. </span><span class="koboSpan" id="kobo.1094.2">There are different verbs for different data types and </span><span class="No-Break"><span class="koboSpan" id="kobo.1095.1">formatting options.</span></span></p>
<p><span class="koboSpan" id="kobo.1096.1">A variant of this function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1097.1">formatlist</span></strong><span class="koboSpan" id="kobo.1098.1"> does the same thing but operates on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1099.1">list(string)</span></strong><span class="koboSpan" id="kobo.1100.1">. </span><span class="koboSpan" id="kobo.1100.2">It is a convenience</span><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.1101.1"> function that avoids the additional complexity of wrapping a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1102.1">format</span></strong><span class="koboSpan" id="kobo.1103.1"> function in a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1104.1">for</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1105.1"> expression.</span></span></p>
<h3><span class="koboSpan" id="kobo.1106.1">Replace</span></h3>
<p><span class="koboSpan" id="kobo.1107.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1108.1">replace</span></strong><span class="koboSpan" id="kobo.1109.1"> function</span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.1110.1"> is another commonly used string function. </span><span class="koboSpan" id="kobo.1110.2">Many </span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.1111.1">cloud services have particular requirements for naming conventions, so </span><strong class="source-inline"><span class="koboSpan" id="kobo.1112.1">replace</span></strong><span class="koboSpan" id="kobo.1113.1"> is very useful when you want to cleanse your names of invalid characters when naming conditions are incongruent across </span><span class="No-Break"><span class="koboSpan" id="kobo.1114.1">different services:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1115.1">
    locals {
      full_name = "foo-bar"
    }</span></pre> <p><span class="koboSpan" id="kobo.1116.1">For example, Azure Storage accounts do not allow hyphens in their names, while Azure resource groups do. </span><span class="koboSpan" id="kobo.1116.2">Therefore, if you pass in an input variable to set a common prefix across all your resources and include a hyphen, you will run into trouble when Terraform attempts to provision the Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.1117.1">Storage account:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1118.1">
    locals {
      storage_account_name = replace(local</span><a id="_idTextAnchor163"/><span class="koboSpan" id="kobo.1119.1">.full_name, "-", "")
    }</span></pre> <p><span class="koboSpan" id="kobo.1120.1">Replace can be </span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.1121.1">used to eliminate</span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.1122.1"> this naming convention faux </span><span class="No-Break"><span class="koboSpan" id="kobo.1123.1">pax quickly.</span></span></p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor164"/><span class="koboSpan" id="kobo.1124.1">Collection functions</span></h2>
<p><span class="koboSpan" id="kobo.1125.1">Collection functions</span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.1126.1"> are an assortment of functions that let you work </span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.1127.1">with obje</span><a id="_idTextAnchor165"/><span class="koboSpan" id="kobo.1128.1">cts of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1129.1">list</span></strong><span class="koboSpan" id="kobo.1130.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1131.1">map</span></strong><span class="koboSpan" id="kobo.1132.1"> type. </span><span class="koboSpan" id="kobo.1132.2">These contain everyday set-based operations, Boolean checks, </span><span class="No-Break"><span class="koboSpan" id="kobo.1133.1">and accessors.</span></span></p>
<h3><span class="koboSpan" id="kobo.1134.1">Length</span></h3>
<p><span class="koboSpan" id="kobo.1135.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1136.1">length</span></strong><span class="koboSpan" id="kobo.1137.1"> function</span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.1138.1"> is probably the most common collection function. </span><span class="koboSpan" id="kobo.1138.2">It is</span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.1139.1"> often used with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1140.1">count</span></strong><span class="koboSpan" id="kobo.1141.1"> meta-argument as it provides a simple and dynamic method for obtaining the number of items in </span><span class="No-Break"><span class="koboSpan" id="kobo.1142.1">a list:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1143.1">
    locals {
      fault_domains = [1, 2, 3, 4, 5]
      fault_domain_count = length(local.fault_domains)
    }</span></pre> <p><span class="koboSpan" id="kobo.1144.1">In the preceding code, we calculate the number of fault domains using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1145.1">length</span></strong><span class="koboSpan" id="kobo.1146.1"> method on </span><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.1147.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1148.1">fault_domains</span></strong><span class="koboSpan" id="kobo.1149.1"> list. </span><span class="koboSpan" id="kobo.1149.2">This approach will produce a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1150.1">5</span></strong><span class="koboSpan" id="kobo.1151.1"> for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1152.1">fault_domain_count</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1153.1">local variable.</span></span></p>
<h3><span class="koboSpan" id="kobo.1154.1">Range</span></h3>
<p><span class="koboSpan" id="kobo.1155.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1156.1">range</span></strong><span class="koboSpan" id="kobo.1157.1"> function</span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.1158.1"> can be useful for taking a count and creating an array of </span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.1159.1">indices for them. </span><span class="koboSpan" id="kobo.1159.2">There are three overloads, but the most useful of the overloads is the one </span><span class="No-Break"><span class="koboSpan" id="kobo.1160.1">that follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1161.1">
    range(start, limit)</span></pre> <p><span class="koboSpan" id="kobo.1162.1">This overload of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1163.1">range</span></strong><span class="koboSpan" id="kobo.1164.1"> function takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1165.1">start</span></strong><span class="koboSpan" id="kobo.1166.1"> number and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1167.1">limit</span></strong><span class="koboSpan" id="kobo.1168.1"> number. </span><span class="koboSpan" id="kobo.1168.2">This capability is helpful because cloud platforms often have deployment boundaries that are important to how we structure our architecture. </span><span class="koboSpan" id="kobo.1168.3">These boundaries significantly impact the resiliency of our architecture—such as regions, Availability Zones, fault domains, and so on—so we must take </span><span class="No-Break"><span class="koboSpan" id="kobo.1169.1">them seriously.</span></span></p>
<p><span class="koboSpan" id="kobo.1170.1">A common problem we face when working within and across these boundaries is that our deployments often need to be very specific about which area to target within a boundary. </span><span class="koboSpan" id="kobo.1170.2">For example, I need to specify that my subnet is in Availability Zone 2 or that my VM needs to be in fault </span><span class="No-Break"><span class="koboSpan" id="kobo.1171.1">domain 3.</span></span></p>
<p><span class="koboSpan" id="kobo.1172.1">The problem arises because cloud platforms often don’t have a uniform or consistent way of telling us the domain of values for a particular boundary. </span><span class="koboSpan" id="kobo.1172.2">For example, rather than giving us a list of </span><em class="italic"><span class="koboSpan" id="kobo.1173.1">Availability Zone 1</span></em><span class="koboSpan" id="kobo.1174.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1175.1">Availability Zone 2</span></em><span class="koboSpan" id="kobo.1176.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.1177.1">Availability Zone 3</span></em><span class="koboSpan" id="kobo.1178.1">—the values we need to target our resources to the target area correctly—the cloud platform might give us a more cryptic </span><em class="italic"><span class="koboSpan" id="kobo.1179.1">“This region has 5 Availability Zones, Good Luck!”</span></em><span class="koboSpan" id="kobo.1180.1">. </span><span class="koboSpan" id="kobo.1180.2">When we need to be specific, they are generic. </span><span class="koboSpan" id="kobo.1180.3">This incongruence does not produce </span><span class="No-Break"><span class="koboSpan" id="kobo.1181.1">ideal outcomes.</span></span></p>
<p><span class="koboSpan" id="kobo.1182.1">If we are hardcoding our resources, this would be fine. </span><span class="koboSpan" id="kobo.1182.2">Still, when you want to provision to a dynamic list of Availability Zones, which allows you to iterate across the list of Availability Zones and provision some resources to each, you need to somehow convert a range into a discrete list of elements such that you can align each item in that list. </span><span class="koboSpan" id="kobo.1182.3">Queue the music; here comes </span><strong class="source-inline"><span class="koboSpan" id="kobo.1183.1">range</span></strong><span class="koboSpan" id="kobo.1184.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.1185.1">the rescue!</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1186.1">
    locals {
      max_fault_domains = 5
      fault_domains = range(1, local.max_fault_domains)
    }</span></pre> <p><span class="koboSpan" id="kobo.1187.1">In the preceding code, let’s pretend the</span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.1188.1"> cloud platform provided the hardcoded number of fault domains. </span><span class="koboSpan" id="kobo.1188.2">We need to create a list that we can iterate across to provision a VM </span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.1189.1">to each of the fault domains. </span><span class="koboSpan" id="kobo.1189.2">Thanks to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1190.1">range</span></strong><span class="koboSpan" id="kobo.1191.1">, we can produce the </span><span class="No-Break"><span class="koboSpan" id="kobo.1192.1">following list:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1193.1">
    fault_domains = [1, 2, 3, 4, 5]</span></pre> <p><span class="koboSpan" id="kobo.1194.1">With the preceding list, we can quickly iterat</span><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.1195.1">e to create a VM in the correct subnet using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1196.1">count</span></strong><span class="koboSpan" id="kobo.1197.1"> meta-argument and the length of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1198.1">fault_domains</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1199.1"> list.</span></span></p>
<h3><span class="koboSpan" id="kobo.1200.1">Flatten</span></h3>
<p><span class="koboSpan" id="kobo.1201.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1202.1">flatten</span></strong><span class="koboSpan" id="kobo.1203.1"> function</span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.1204.1"> can be helpful when you have homogenous </span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.1205.1">data elements stored within different arrays. </span><span class="koboSpan" id="kobo.1205.2">This situation might occur when you have a module return a collection </span><span class="No-Break"><span class="koboSpan" id="kobo.1206.1">of sub-resources:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer030">
<span class="koboSpan" id="kobo.1207.1"><img alt="Figure 2.3 – The Network module; each produces its list of subnets that you need to aggregate into a single list of subnets" src="image/B21183_02_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1208.1">Figure 2.3 – The Network module; each produces its list of subnets that you need to aggregate into a single list of subnets</span></p>
<p><span class="koboSpan" id="kobo.1209.1">In the preceding diagram, we can see that we have a module that provisions a network. </span><span class="koboSpan" id="kobo.1209.2">This module outputs a list of subnets. </span><span class="koboSpan" id="kobo.1209.3">Often, we want a module to encapsulate relevant sub-resources that are tightly coupled with the primary resource of the module. </span><span class="koboSpan" id="kobo.1209.4">While this approach makes the code more maintainable, it also creates difficulties upstream if we want to act uniformly across all the sub-resources </span><span class="No-Break"><span class="koboSpan" id="kobo.1210.1">it outputs.</span></span></p>
<p><span class="koboSpan" id="kobo.1211.1">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.1212.1">flatten</span></strong><span class="koboSpan" id="kobo.1213.1">, we can </span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.1214.1">collapse the list of lists into a single flattened</span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.1215.1"> list with each subnet as an ite</span><a id="_idTextAnchor168"/><span class="koboSpan" id="kobo.1216.1">m. </span><span class="koboSpan" id="kobo.1216.2">Doing so will enable us to work uniformly with all of the subnets from the consuming module we </span><span class="No-Break"><span class="koboSpan" id="kobo.1217.1">are developing.</span></span></p>
<h3><span class="koboSpan" id="kobo.1218.1">Transpose</span></h3>
<p><span class="koboSpan" id="kobo.1219.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1220.1">transpose</span></strong><span class="koboSpan" id="kobo.1221.1"> function</span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.1222.1"> is also beneficial </span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.1223.1">when working with hierarchies of objects with complex relationships with </span><span class="No-Break"><span class="koboSpan" id="kobo.1224.1">their children:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer031">
<span class="koboSpan" id="kobo.1225.1"><img alt="Figure 2.4 – Resource VMs associated with a collection of security groups" src="image/B21183_02_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1226.1">Figure 2.4 – Resource VMs associated with a collection of security groups</span></p>
<p><span class="koboSpan" id="kobo.1227.1">For example, in the preceding diagram, two VMs are associated with a collection of security groups. </span><span class="koboSpan" id="kobo.1227.2">We have set this up as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1228.1">map</span></strong><span class="koboSpan" id="kobo.1229.1"> collection in this situation. </span><span class="koboSpan" id="kobo.1229.2">The key would be the VM and the value of a collection of </span><span class="No-Break"><span class="koboSpan" id="kobo.1230.1">security groups.</span></span></p>
<p><span class="koboSpan" id="kobo.1231.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.1232.1">map</span></strong><span class="koboSpan" id="kobo.1233.1"> works excellently when we want to iterate over the top-level object—the VMs—but what if we’re going to iterate over the child objects, the security groups? </span><span class="koboSpan" id="kobo.1233.2">We flip this relationship upside down using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1234.1">transpose</span></strong><span class="koboSpan" id="kobo.1235.1"> function on </span><span class="No-Break"><span class="koboSpan" id="kobo.1236.1">this map!</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer032">
<span class="koboSpan" id="kobo.1237.1"><img alt="Figure 2.5 – Security groups associated with a collection of VMs" src="image/B21183_02_5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1238.1">Figure 2.5 – Security groups associated with a collection of VMs</span></p>
<p><span class="koboSpan" id="kobo.1239.1">The preceding diagram shows </span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.1240.1">that instead of having the top-level object be the </span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.1241.1">VM, it’s now the security groups. </span><span class="koboSpan" id="kobo.1241.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1242.1">transpose</span></strong><span class="koboSpan" id="kobo.1243.1"> operation has also replaced child objects with VMs. </span><span class="koboSpan" id="kobo.1243.2">However, you’ll notice that the function has mai</span><a id="_idTextAnchor169"/><span class="koboSpan" id="kobo.1244.1">ntained the relationships between parent and child—we’re just looking at the relationship through a </span><span class="No-Break"><span class="koboSpan" id="kobo.1245.1">different lens.</span></span></p>
<h3><span class="koboSpan" id="kobo.1246.1">Zipmap</span></h3>
<p><span class="koboSpan" id="kobo.1247.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1248.1">zipmap</span></strong><span class="koboSpan" id="kobo.1249.1"> function</span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.1250.1"> is handy </span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.1251.1">when you have two </span><strong class="source-inline"><span class="koboSpan" id="kobo.1252.1">list</span></strong><span class="koboSpan" id="kobo.1253.1"> objects, one containing the keys and the other containing the corresponding values. </span><span class="koboSpan" id="kobo.1253.2">Both list corresponding items in the same index, and the lists must be the </span><span class="No-Break"><span class="koboSpan" id="kobo.1254.1">same length.</span></span></p>
<p><span class="koboSpan" id="kobo.1255.1">The name is interesting as it is an attempt at word painting. </span><span class="koboSpan" id="kobo.1255.2">Imagine the construction of a zipper: two independent but parallel lists of notches, but when the zipper is applied sequentially, each notch on the left side is attached to the corresponding notch on the </span><span class="No-Break"><span class="koboSpan" id="kobo.1256.1">right side:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer033">
<span class="koboSpan" id="kobo.1257.1"><img alt="Figure 2.6 – VMs list and a corresponding security group list" src="image/B21183_02_6.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1258.1">Figure 2.6 – VMs list and a corresponding security group list</span></p>
<p><span class="koboSpan" id="kobo.1259.1">In the preceding diagram, we have two lists, one containing VMs and another containing security groups. </span><span class="koboSpan" id="kobo.1259.2">With</span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.1260.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1261.1">zipmap</span></strong><span class="koboSpan" id="kobo.1262.1"> function</span><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.1263.1">, we can create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1264.1">map</span></strong><span class="koboSpan" id="kobo.1265.1"> object </span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.1266.1">that creates an association between each element in the VM and security </span><span class="No-Break"><span class="koboSpan" id="kobo.1267.1">group lists.</span></span></p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.1268.1">Encoding functions</span></h2>
<p><span class="koboSpan" id="kobo.1269.1">Encoding functions let you </span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.1270.1">work with text of various encoding formats and convert </span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.1271.1">back and forth between them. </span><span class="koboSpan" id="kobo.1271.2">These include string-based operations such as Base64 and string-to-object encoding formats such as JSON </span><span class="No-Break"><span class="koboSpan" id="kobo.1272.1">and YAML.</span></span></p>
<p><span class="koboSpan" id="kobo.1273.1">Many services will often require input data to be encoded in Base64 to simplify the transmission of complex data, and the two corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.1274.1">encode</span></strong><span class="koboSpan" id="kobo.1275.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1276.1">decode</span></strong><span class="koboSpan" id="kobo.1277.1"> functions work as you would </span><span class="No-Break"><span class="koboSpan" id="kobo.1278.1">expect them.</span></span></p>
<p><span class="koboSpan" id="kobo.1279.1">The JSON and YAML </span><strong class="source-inline"><span class="koboSpan" id="kobo.1280.1">encode</span></strong><span class="koboSpan" id="kobo.1281.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1282.1">decode</span></strong><span class="koboSpan" id="kobo.1283.1"> functions work like typical serializers, with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1284.1">encode</span><a id="_idTextAnchor172"/></strong><span class="koboSpan" id="kobo.1285.1"> functions taking in an object and producing a string—while the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1286.1">decode</span></strong><span class="koboSpan" id="kobo.1287.1"> functions take in a string and produce </span><span class="No-Break"><span class="koboSpan" id="kobo.1288.1">an object.</span></span></p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.1289.1">Filesystem functions</span></h2>
<p><span class="koboSpan" id="kobo.1290.1">Filesystem functions</span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.1291.1"> provide a set of utilities that make it easier to work with local files, which</span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.1292.1"> can come in extremely handy if you need to drop a config file for the</span><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.1293.1"> next step in your automation pipeline or if you need to access files containing content needed for </span><span class="No-Break"><span class="koboSpan" id="kobo.1294.1">resource provisioning.</span></span></p>
<h3><span class="koboSpan" id="kobo.1295.1">File</span></h3>
<p><span class="koboSpan" id="kobo.1296.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1297.1">file</span></strong><span class="koboSpan" id="kobo.1298.1"> function</span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.1299.1"> simply loads the contents from the file at the specified </span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.1300.1">path on the disk into a string. </span><span class="koboSpan" id="kobo.1300.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1301.1">path.module</span></strong><span class="koboSpan" id="kobo.1302.1"> special variable is used to specify the current working directory of the current module. </span><span class="koboSpan" id="kobo.1302.2">This is useful during module development because it allows you to embed and use files to store content needed within </span><span class="No-Break"><span class="koboSpan" id="kobo.1303.1">your module:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1304.1">
locals {
  template_content = file("${path.module}/template.json")
}</span></pre> <p><span class="koboSpan" id="kobo.1305.1">This method is commonly used in conjunction with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1306.1">jsondecode</span></strong><span class="koboSpan" id="kobo.1307.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1308.1">yamldecode</span></strong><span class="koboSpan" id="kobo.1309.1"> functions to take the</span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.1310.1"> string content and convert it into an obj</span><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.1311.1">ect that can be used more easily</span><a id="_idIndexMarker233"/> <span class="No-Break"><span class="koboSpan" id="kobo.1312.1">within HCL:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1313.1">
locals {
  template = jsondecode(
    file("${path.module}/template.json")
  )
}</span></pre> <h3><span class="koboSpan" id="kobo.1314.1">Template file</span></h3>
<p><span class="koboSpan" id="kobo.1315.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1316.1">templatefile</span></strong><span class="koboSpan" id="kobo.1317.1"> function</span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.1318.1"> works just like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1319.1">file</span></strong><span class="koboSpan" id="kobo.1320.1"> function</span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.1321.1"> but with a twist. </span><span class="koboSpan" id="kobo.1321.2">It allows you to pass in parameters to be replaced with corresponding placeholders in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1322.1">file specified:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1323.1">
locals {
  template = jsondecode(
    templatefile(
      "${path.module}/template.json",
      {
        hostname   = "foo"
        ip_address = "10.0.1.8"
      }
    )
  )
}</span></pre> <p><span class="koboSpan" id="kobo.1324.1">The parameters of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1325.1">hostname</span></strong><span class="koboSpan" id="kobo.1326.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1327.1">ip_address</span></strong><span class="koboSpan" id="kobo.1328.1"> indicate the tokens that should be replaced in the file with their corresponding values, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1329.1">foo</span></strong><span class="koboSpan" id="kobo.1330.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1331.1">10.0.1.8</span></strong><span class="koboSpan" id="kobo.1332.1">, respectively. </span><span class="koboSpan" id="kobo.1332.2">If the contents of the file contain the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1333.1">${hostname}</span></strong><span class="koboSpan" id="kobo.1334.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1335.1">${ip_address}</span></strong><span class="koboSpan" id="kobo.1336.1"> tokens, they will be replaced with the corresponding value. </span><span class="koboSpan" id="kobo.1336.2">This can be a very convenient wa</span><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.1337.1">y to drop important </span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.1338.1">configuration details into your infrastructure</span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.1339.1"> that is only available after Terraform has executed </span><span class="No-Break"><span class="koboSpan" id="kobo.1340.1">its plan.</span></span></p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.1341.1">Date/time functions</span></h2>
<p><span class="koboSpan" id="kobo.1342.1">Date/time functions </span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.1343.1">provide a set of utilities for creating timestamps. </span><span class="koboSpan" id="kobo.1343.2">These</span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.1344.1"> functions can help set expiration dates for short-term access tokens or transform a date/time string into the correct format expected by the specific resource </span><span class="No-Break"><span class="koboSpan" id="kobo.1345.1">you use.</span></span></p>
<p><span class="koboSpan" id="kobo.1346.1">When working with time in Terraform, it’s important to note that there is no explicit date/time type. </span><span class="koboSpan" id="kobo.1346.2">Terraform handles date/time values using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1347.1">string</span></strong><span class="koboSpan" id="kobo.1348.1"> type. </span><span class="koboSpan" id="kobo.1348.2">The default format that Terraform uses is the RFC 3339 format, which looks </span><span class="No-Break"><span class="koboSpan" id="kobo.1349.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1350.1">
2023-09-14T13:24:19Z</span></pre> <p><span class="koboSpan" id="kobo.1351.1">The preceding value has the </span><span class="No-Break"><span class="koboSpan" id="kobo.1352.1">following format:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1353.1">
{YYYY}-{MM}-{DD}T{HH}:{mm}:{ss}Z</span></pre> <p><span class="koboSpan" id="kobo.1354.1">This behavior is essen</span><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.1355.1">tial to understand because all the date/time functions that are available will either take in or produce a timestamp in </span><span class="No-Break"><span class="koboSpan" id="kobo.1356.1">this format.</span></span></p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.1357.1">Hash/crypto functions</span></h2>
<p><span class="koboSpan" id="kobo.1358.1">Just like </span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.1359.1">the encoding functions, there are several options when it </span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.1360.1">comes to hashing and cryptographic functions. </span><span class="koboSpan" id="kobo.1360.2">These functions implement a variety of hashing algorithms such as MD5 and SHA and encryption algorithms such as RSA. </span><span class="koboSpan" id="kobo.1360.3">There are also corresponding file-based operations that allow you to read content from </span><span class="No-Break"><span class="koboSpan" id="kobo.1361.1">a file.</span></span></p>
<p><span class="koboSpan" id="kobo.1362.1">It’s important to remember that hashing is not the same </span><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.1363.1">thing as encryption and that when using encryption, you should secure the keys you use both inside and outside of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1364.1">Terraform state.</span></span></p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.1365.1">IP network functions</span></h2>
<p><span class="koboSpan" id="kobo.1366.1">The IP network functions </span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.1367.1">make it easier to work with CIDR blocks to split </span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.1368.1">address spaces </span><span class="No-Break"><span class="koboSpan" id="kobo.1369.1">into subnets.</span></span></p>
<p><span class="koboSpan" id="kobo.1370.1">Although Terraform’s networking functions support IPv4 and IPv6, we’ll look at IPv4 addresses in our examples to make it easier </span><span class="No-Break"><span class="koboSpan" id="kobo.1371.1">to understand.</span></span></p>
<p><span class="koboSpan" id="kobo.1372.1">An IPv4 address is a 32-bit value with 4 octets and 8 bits per octet. </span><span class="koboSpan" id="kobo.1372.2">We construct CIDR blocks to identify a range of IP addresses to allocate to a virtual network or a subnet within that </span><span class="No-Break"><span class="koboSpan" id="kobo.1373.1">virtual network.</span></span></p>
<p><span class="koboSpan" id="kobo.1374.1">Terraform has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1375.1">cidrsubnet</span></strong><span class="koboSpan" id="kobo.1376.1"> function, which calculates these CIDR block ranges, making it easier to generate CIDR block ranges dynamically rather than hardcoding them or using string manipulation to </span><span class="No-Break"><span class="koboSpan" id="kobo.1377.1">construct them:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1378.1">
cidrsubnet(prefix, newbits, netnum)</span></pre> <p><span class="koboSpan" id="kobo.1379.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1380.1">prefix</span></strong><span class="koboSpan" id="kobo.1381.1"> argument is the </span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.1382.1">network space you want to split up. </span><span class="koboSpan" id="kobo.1382.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1383.1">newbits</span></strong><span class="koboSpan" id="kobo.1384.1"> argument is how big we want the chunks that the prefix splits into to be—its value has an inverse relationship with the size of the address space chunks. </span><span class="koboSpan" id="kobo.1384.2">As the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1385.1">newbits</span></strong><span class="koboSpan" id="kobo.1386.1"> value goes up, the size of the chunks decreases. </span><span class="koboSpan" id="kobo.1386.2">As the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1387.1">newbits</span></strong><span class="koboSpan" id="kobo.1388.1"> goes down, the size of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1389.1">chunks increases:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1390.1">
locals {
  cidr_block_start    = "10.0.0.0/16"
  cidr_chunk_size     = 8
  cidr_block_list     = range(0, 4)
  dynamic_cidr_blocks = [for i in local.cidr_block_list :
cidrsubnet(local.cidr_block_start, local.chunk_size, i)]
}</span></pre> <p><span class="koboSpan" id="kobo.1391.1">In the preceding code, we are splitting up the address space of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1392.1">10.0.0.0/16</span></strong><span class="koboSpan" id="kobo.1393.1"> with chunks that have </span><strong class="source-inline"><span class="koboSpan" id="kobo.1394.1">8</span></strong><span class="koboSpan" id="kobo.1395.1"> additional bits. </span><span class="koboSpan" id="kobo.1395.2">That means we are looking for chunks with the size of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1396.1">/24</span></strong><span class="koboSpan" id="kobo.1397.1">—or 256 IP addresses. </span><span class="koboSpan" id="kobo.1397.2">If we used </span><strong class="source-inline"><span class="koboSpan" id="kobo.1398.1">6</span></strong><span class="koboSpan" id="kobo.1399.1"> instead, we would be looking to split into chunks of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1400.1">/22</span></strong><span class="koboSpan" id="kobo.1401.1">—or 1,024 IP </span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.1402.1">addresses. </span><span class="koboSpan" id="kobo.1402.2">As you can see, the fewer additional bits, the more IP addresses in each chunk, and the fewer chunks we can fit into the primary </span><span class="No-Break"><span class="koboSpan" id="kobo.1403.1">address space:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1404.1">
resource "aws_subnet" "subnet" {
  count      = 4
  cidr_block = cidrsubnet(var.cidr, local.chunk_size, count.index)
}</span></pre> <p><span class="koboSpan" id="kobo.1405.1">In the preceding</span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.1406.1"> code, we can use this function to construct the address </span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.1407.1">space for each subnet within an AWS VPC. </span><span class="koboSpan" id="kobo.1407.2">Thanks to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1408.1">count</span></strong><span class="koboSpan" id="kobo.1409.1"> meta-argument, we don’t need the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1410.1">for</span></strong><span class="koboSpan" id="kobo.1411.1"> expressio</span><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.1412.1">n to construct a list of address spaces. </span><span class="koboSpan" id="kobo.1412.2">We can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1413.1">count.index</span></strong><span class="koboSpan" id="kobo.1414.1"> to specify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1415.1">netnum</span></strong><span class="koboSpan" id="kobo.1416.1"> input to select which chunk we want our subnet </span><span class="No-Break"><span class="koboSpan" id="kobo.1417.1">to use.</span></span></p>
<h2 id="_idParaDest-69"><span class="koboSpan" id="kobo.1418.1">Type conv</span><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.1419.1">ersion functions</span></h2>
<p><span class="koboSpan" id="kobo.1420.1">Explicit </span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.1421.1">type</span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.1422.1"> conversions are exceptionally rare in Terraform, but several functions are available to aid you if necessary, e.g., </span><strong class="source-inline"><span class="koboSpan" id="kobo.1423.1">tonumber</span></strong><span class="koboSpan" id="kobo.1424.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1425.1">tobool</span></strong><span class="koboSpan" id="kobo.1426.1">, </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1427.1">tolist</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1428.1">, etc.</span></span></p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.1429.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1430.1">In this chapter, we took an in-depth look at the language that powers Terraform: HCL. </span><span class="koboSpan" id="kobo.1430.2">We looked at its core structures: resources, data sources, locals, and modules. </span><span class="koboSpan" id="kobo.1430.3">We looked at inputs and outputs that will help us design better contracts between our modules and the outside world. </span><span class="koboSpan" id="kobo.1430.4">We looked at language structures that allow us to build dynamic collections of resources—helping us scale our code without all the copypasta. </span><span class="koboSpan" id="kobo.1430.5">And lastly, we looked at an arsenal of functions that can help us when coding in HCL to solve complex problems quickly </span><span class="No-Break"><span class="koboSpan" id="kobo.1431.1">and efficiently.</span></span></p>
<p><span class="koboSpan" id="kobo.1432.1">In the next chapter, we will explore the utility providers HashiCorp publishes that provide critical cross-platform functionality to our </span><span class="No-Break"><span class="koboSpan" id="kobo.1433.1">Terraform solutions.</span></span></p>
</div>
</body></html>