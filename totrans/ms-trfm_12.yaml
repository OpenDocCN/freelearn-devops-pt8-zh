- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Go Serverless on Azure – Building Solutions with Azure Functions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Azure上使用无服务器架构——用Azure Functions构建解决方案
- en: Are you ready? We are about to turn the page on Microsoft Azure – but only after
    we take the final step of transitioning our application to Serverless architecture.
    Like we did on the **Amazon Web Services** (**AWS**) platform, in the last two
    chapters, we worked hard to implement our solution on Microsoft Azure using **virtual
    machines** (**VMs**) and then containers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你准备好了吗？我们即将翻开微软Azure的新篇章——但只有在将我们的应用迁移到无服务器架构的最后一步完成后，才会开始。如同在**亚马逊云服务**（**AWS**）平台上，我们在过去的两章中，努力通过**虚拟机**（**VMs**）和容器来实施解决方案。
- en: We’ve taken time to do some comparisons between how things work on AWS and Microsoft
    Azure to help us understand the subtle and sometimes not-so-subtle differences
    between the cloud platforms.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们花了一些时间对比了AWS和微软Azure上的工作方式，帮助我们理解这两种云平台之间微妙甚至有时并不那么微妙的差异。
- en: We’ve noticed that while our Terraform code has been changing pretty consistently
    between cloud platforms, our application code and the operating system configuration
    – either in Packer or Docker – haven’t. As we take our final step with Microsoft
    Azure, we’ll be going through a similar process to what we went through when we
    transitioned our application to **AWS Lambda**. We’ll have to completely refactor
    the application code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到，尽管我们的Terraform代码在不同云平台之间发生了相当一致的变化，但我们的应用代码和操作系统配置——无论是在Packer还是Docker中——都没有发生变化。当我们迈出微软Azure的最后一步时，我们将经历与将应用迁移到**AWS
    Lambda**时类似的过程。我们将不得不彻底重构应用代码。
- en: 'This chapter covers the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Laying the foundation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打下基础
- en: Designing the solution
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计解决方案
- en: Building the solution
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建解决方案
- en: Automating the deployment
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化部署
- en: Laying the foundation
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打下基础
- en: Our story continues through the lens of Söze Enterprises, founded by the enigmatic
    Turkish billionaire Keyser Söze. Our team has been hard at work building the next-generation
    autonomous vehicle orchestration platform. Our initial strategy involved minimizing
    change to allow the team to focus on driving features into our product. However,
    our elusive CEO had other ideas and pushed us to adopt container technology to
    make our product more flexible and scalable going forward. Working with Keyser,
    there is never a dull moment, but managing such radical change so quickly can
    be frustrating.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的故事通过Söze企业的视角继续展开，该公司由神秘的土耳其亿万富翁凯泽·索泽（Keyser Söze）创立。我们的团队一直在努力构建下一代自动驾驶车辆编排平台。我们的初步策略是尽量减少变化，以便团队能够专注于将功能加入到产品中。然而，我们那位难以捉摸的CEO有其他想法，他推动我们采用容器技术，使我们的产品在未来更加灵活和可扩展。与凯泽一起工作，永远不会有无聊的时刻，但如此迅速地管理如此剧烈的变化，有时确实令人沮丧。
- en: Meanwhile, in St. Barts, with the sun setting over the Caribbean and the cocktail
    party in full swing, Keyser has a chance encounter at the bar with Mark Russinovich,
    the CTO of Microsoft Azure. They immediately hit it off, chatting over mojitos.
    When Mark gets a glimpse of Keyser’s immense vision for the autonomous vehicle
    platform, he casually suggests that maybe Keyser shouldn’t concern himself with
    infrastructure at all. Mark explains how leveraging Azure Functions and other
    serverless offerings could free him from the shackles of infrastructure management,
    allowing him to focus entirely on his grand vision.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，在圣巴特岛，随着加勒比海的日落和鸡尾酒会的热烈进行，凯泽在酒吧偶遇微软Azure的首席技术官马克·鲁西诺维奇（Mark Russinovich）。两人一见如故，边喝莫吉托边聊天。当马克看到凯泽对自动驾驶平台的宏大愿景时，他随口提到，凯泽或许根本不需要担心基础设施问题。马克解释说，通过利用Azure
    Functions和其他无服务器服务，可以将凯泽从基础设施管理的束缚中解放出来，让他能够全身心地专注于宏伟的愿景。
- en: Thanks to Mark’s insights and Keyser’s whimsical decision-making, our team veers
    deeper into Microsoft Azure, explicitly transitioning from **Azure Kubernetes
    Service** (**AKS**) to **Azure Functions** for serverless computing. This might
    require a complete re-think of our application architecture, but it could free
    us from the significant operational overhead of managing low-level infrastructure.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了马克的洞察力和凯泽的异想天开，我们的团队更深入地进入了微软Azure，明确地从**Azure Kubernetes Service**（**AKS**）过渡到**Azure
    Functions**进行无服务器计算。这可能需要我们完全重新考虑应用架构，但这将使我们摆脱管理低层基础设施的重大运营负担。
- en: Designing the solution
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计解决方案
- en: 'In this section, we will be taking a look at the overall design of our solution,
    given the shift from VM and container-based architectures toward serverless architectures.
    As we saw in [*Chapter 9*](B21183_09.xhtml#_idTextAnchor446), at its core, serverless
    has a quintessential objective of eliminating heavy infrastructure from the stack.
    Therefore, we will be looking for ways to shed any Azure services that require
    significant fixed costs, such as VMs or Kubernetes clusters, and replace them
    with serverless options. This change in our operational context and technology
    landscape will likely require us to rethink some things about our solution, both
    in terms of its design, implementation, and deployment strategy:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将考察解决方案的整体设计，考虑到从基于虚拟机和容器的架构转向无服务器架构的转变。正如我们在[*第9章*](B21183_09.xhtml#_idTextAnchor446)中看到的那样，服务器无服务器架构的核心目标是消除堆栈中的重型基础设施。因此，我们将寻找方法来摆脱任何需要较大固定成本的Azure服务，例如虚拟机或Kubernetes集群，并将它们替换为无服务器选项。这种操作环境和技术景观的变化可能需要我们重新思考一些关于解决方案的设计、实现和部署策略：
- en: '![Figure 12.1 – Logical architecture for the autonomous vehicle platform](img/B21183_12_1.0.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 自动驾驶平台的逻辑架构](img/B21183_12_1.0.jpg)'
- en: Figure 12.1 – Logical architecture for the autonomous vehicle platform
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 自动驾驶平台的逻辑架构
- en: 'Our application’s architecture doesn’t change significantly, but we will be
    using different Azure services to host it. In this case, we’ll be using Azure
    Storage to host the application’s frontend, and we’ll be using Azure Functions
    to host the application’s backend:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的架构没有显著变化，但我们将使用不同的Azure服务来承载它。在这种情况下，我们将使用Azure Storage来承载应用程序的前端，使用Azure
    Functions来承载应用程序的后端：
- en: '![Figure 12.2 – Source control structure of our repository](img/B21183_12_2.0.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – 我们代码库的源控制结构](img/B21183_12_2.0.jpg)'
- en: Figure 12.2 – Source control structure of our repository
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 我们代码库的源控制结构
- en: In this solution, our code base will consist of four parts. First, we’ll have
    the Terraform code that provisions the environment and the GitHub Actions code
    that executes the deployment process. Then, we’ll have the two code bases for
    our application’s frontend and backend.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个解决方案中，我们的代码库将由四个部分组成。首先，我们将有用于配置环境的Terraform代码和执行部署过程的GitHub Actions代码。接着，我们将有用于应用程序前端和后端的两部分代码库。
- en: Cloud architecture
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 云架构
- en: In [*Chapter 10*](B21183_10.xhtml#_idTextAnchor474), our cloud-hosting solution
    was a set of dedicated VMs, and in [*Chapter 11*](B21183_11.xhtml#_idTextAnchor509),
    it was a set of shared VMs within our Kubernetes cluster’s node pool. Using VMs
    has the most sunk cost, whether they are standalone VMs or part of a Kubernetes
    node pool.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第10章*](B21183_10.xhtml#_idTextAnchor474)中，我们的云托管解决方案是一组专用虚拟机，在[*第11章*](B21183_11.xhtml#_idTextAnchor509)中，它是我们Kubernetes集群节点池中的一组共享虚拟机。使用虚拟机带来最大的沉没成本，无论它们是独立的虚拟机还是Kubernetes节点池的一部分。
- en: 'In [*Chapter 11*](B21183_11.xhtml#_idTextAnchor509), our entire solution was
    executed on containers that allowed the frontend and the backend to coexist as
    a set of containers on the same VMs. This saved us some money, but we still needed
    servers to host the workload. In this chapter, we have a new objective: to take
    advantage of the power of the cloud by leveraging cloud-native services that abstract
    the underlying infrastructure from us and allow us to truly pay for only what
    we use. Azure’s serverless offerings will be crucial to us in this endeavor.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第11章*](B21183_11.xhtml#_idTextAnchor509)中，我们的整个解决方案是在容器中执行的，这些容器允许前端和后端作为一组容器共存于相同的虚拟机上。这为我们节省了一些资金，但我们仍然需要服务器来承载工作负载。在这一章中，我们有了新的目标：利用云的力量，通过使用云原生服务，抽象化底层基础设施，并真正按需付费。Azure的无服务器服务将在这一过程中对我们至关重要。
- en: Frontend
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前端
- en: In previous chapters, we hosted our frontend on public-facing servers that returned
    the HTML and JavaScript that composed our web application. There, we still required
    a cloud-hosted solution to host the files and respond to requests.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们将前端托管在面向公众的服务器上，这些服务器返回构成我们Web应用程序的HTML和JavaScript。在那里，我们仍然需要一个云托管解决方案来托管文件并响应请求。
- en: However, due to the nature of the web application running within the end user’s
    browser, we don’t need to use cloud-hosted VMs to host what are essentially flat
    files. We can use simple cloud storage to host the frontend as a static website
    and rely on the cloud platform to shoulder the burden of returning the web content.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于 web 应用程序运行在最终用户的浏览器中，我们不需要使用云托管的虚拟机来托管这些本质上是静态文件的内容。我们可以使用简单的云存储来托管前端作为静态网站，并依赖云平台来承担返回网页内容的负担。
- en: 'For this, we can use Azure Storage. This service has several different storage
    capabilities built into it, but for our static website, we’ll be using Azure Blob
    storage. Blob storage allows us to host static web content that is internet accessible,
    and Azure Storage handles all the load balancing, SSL termination, and scaling
    up to meet huge spikes in demand:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对此，我们可以使用 Azure 存储。该服务内置了几种不同的存储功能，但对于我们的静态网站，我们将使用 Azure Blob 存储。Blob 存储允许我们托管互联网可访问的静态网页内容，并且
    Azure 存储处理所有负载均衡、SSL 终止以及应对巨大需求峰值时的扩展：
- en: '![Figure 12.3 – Azure Storage handles web page requests, while Azure Functions
    handles REST API requests](img/B21183_12_3.0.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.3 – Azure 存储处理网页请求，而 Azure Functions 处理 REST API 请求](img/B21183_12_3.0.jpg)'
- en: Figure 12.3 – Azure Storage handles web page requests, while Azure Functions
    handles REST API requests
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 – Azure 存储处理网页请求，而 Azure Functions 处理 REST API 请求
- en: To do this, we’ll need to have an `$web` to where we can publish the web content.
    All Azure Storage accounts have an internet-accessible public domain. When we
    activate the static websites feature of Azure Storage, internet traffic gets routed
    to content hosted in the `$web` storage container.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要一个 `$web`，以便发布网页内容。所有 Azure 存储帐户都有一个可以公开访问的互联网域。当我们启用 Azure 存储的静态网站功能时，互联网流量将被路由到存储在
    `$web` 存储容器中的内容。
- en: This will give us a huge advantage because Azure Storage has absolutely no sunk
    costs. When you create an Azure Storage account, it costs you absolutely zero
    dollars ($0) per month. Like other serverless offerings, it uses a set of micro-transactions
    to measure your activity and charge you for precisely what you use. In **Azure
    Blob storage**, this can be a bit complicated as several measurements incur costs.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们带来巨大的优势，因为 Azure 存储没有任何沉没成本。当您创建一个 Azure 存储帐户时，每月的费用为零（$0）。像其他无服务器服务一样，它使用一套微交易来衡量您的活动并根据您的使用量收取费用。在**Azure
    Blob 存储**中，这可能有些复杂，因为多个计量项会产生费用。
- en: 'The following table shows all the costs you will run into when using Azure
    Storage to host your static websites:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了当使用 Azure 存储来托管静态网站时，您可能遇到的所有费用：
- en: '| **Metric** | **Unit** | **Scale** | **Price** |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **计量** | **单位** | **规模** | **价格** |'
- en: '| Storage | GBs | 1,000 | $0.0518 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 存储 | GBs | 1,000 | $0.0518 |'
- en: '| Read transactions | Transactions | 10,000 | $0.004 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 读取事务 | 事务数 | 10,000 | $0.004 |'
- en: '| Write transactions | Transactions | 10,000 | $0.1125 |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 写入事务 | 事务数 | 10,000 | $0.1125 |'
- en: '| Other operations | Transactions | 10,000 | $0.004 |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 其他操作 | 事务数 | 10,000 | $0.004 |'
- en: Table 12.1 – Azure Storage micro-transactional pricing
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12.1 – Azure 存储微交易定价
- en: The pricing I chose is the most expensive option with geo-redundant, zone-redundant
    storage with additional read-only access in an alternate region. The prices that
    are listed here are for Azure’s West US 2 region, though the prices may have changed
    by the time you are reading this, so it’s best to check the latest prices for
    the most accurate cost estimation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择的定价是最昂贵的选项，具有地理冗余、区域冗余存储以及在备用区域的只读访问权限。这里列出的价格适用于 Azure 的西美国 2 区域，尽管在您阅读本文时价格可能已经发生变化，因此最好检查最新的价格，以获得最准确的成本估算。
- en: I included these prices to make a point. We can host a static website on a three-node
    Kubernetes cluster for approximately $300 a month or we can host a static website
    on Azure Storage for less than $0.01 a month on the most rock-solid storage tier
    that Azure has to offer. Which approach would you choose?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我列出了这些价格是为了说明一个问题。我们可以在一个三节点的 Kubernetes 集群上托管一个静态网站，费用大约为每月 $300，或者我们可以在 Azure
    存储上托管一个静态网站，费用不到每月 $0.01，使用 Azure 提供的最稳定的存储层。你会选择哪种方式？
- en: Backend
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后端
- en: 'Like our frontend, in previous chapters, our backend was also hosted on VMs
    in two different ways: dedicated VMs and shared VMs within the node pool on our
    Kubernetes cluster.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的前端一样，在前几章中，我们的后端也以两种不同的方式托管在虚拟机上：专用虚拟机和在 Kubernetes 集群节点池中的共享虚拟机。
- en: Unlike the frontend, our backend doesn’t have the option of running entirely
    client-side inside the end user’s web browser. In the backend, we have custom
    code that needs to run on a server. Therefore, we need to find a solution to host
    these components without all the overhead of a fleet of VMs.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与前端不同，我们的后台没有完全在最终用户的 Web 浏览器中客户端运行的选项。在后台，我们有需要在服务器上运行的自定义代码。因此，我们需要找到一种解决方案，在没有大量虚拟机开销的情况下托管这些组件。
- en: On Azure, we can use Azure Functions to accomplish this. Azure Functions is
    a managed service that allows you to deploy your code without paying the sunk
    costs for any of the underlying VMs. Like Azure Storage, it has a micro-transactional
    pricing model that charges you for precisely what you use.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure 上，我们可以使用 Azure Functions 来完成此任务。Azure Functions 是一项托管服务，允许你部署代码，而无需为任何底层虚拟机支付沉没成本。与
    Azure 存储类似，它采用微交易定价模式，只针对你实际使用的部分收费。
- en: 'The following table shows the costs that you will incur when deploying your
    code to Azure Functions:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格展示了将代码部署到 Azure Functions 时会产生的费用：
- en: '| **Metric** | **Unit** | **Scale** | **Price** |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| **度量** | **单位** | **规模** | **价格** |'
- en: '| Execution time | GB/s | 1 | $0.000016 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 执行时间 | GB/s | 1 | $0.000016 |'
- en: '| Total executions | Transactions | 1,000,000 | $0.020 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 总执行次数 | 交易 | 1,000,000 | $0.020 |'
- en: Table 12.2 – Azure Functions micro-transactional pricing
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12.2 – Azure Functions 微交易定价
- en: The first thing that you’ll probably notice is that, like Azure Storage, these
    prices are extremely small but they measure a very small amount of activity on
    the platform.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能首先注意到的是，与 Azure 存储一样，这些价格非常低，但它们衡量的是平台上非常少量的活动。
- en: For example, the execution time metric has a unit of GB/s, which is the amount
    of memory, in gigabytes, your Azure Function uses per second. Given that it measures
    at a *per-second* interval, you don’t have to be running Azure Functions very
    long to rack up quite a few of these.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，执行时间度量单位是 GB/s，表示你的 Azure Function 每秒使用的内存量（以 GB 为单位）。由于它是按*每秒*进行测量的，因此你不需要长时间运行
    Azure Functions 就能累积相当多的费用。
- en: The total executions is a rather simple metric that seemingly has no constraints,
    but Azure Functions have natural constraints built into them. For example, each
    of these executions is limited to 10 minutes. Now, if you are trying to respond
    to requests from a web application, you probably won’t want to design your Azure
    Function to take 10 minutes anyway, as this would be a pretty poor experience
    for the end user using the web browser. In this scenario, you want your Azure
    Function to return in no more than a few seconds. However, Azure Functions can
    be employed for many different tasks besides responding to HTTP requests from
    a browser, and sometimes, it makes sense to run long-running activities. For those
    situations, you can opt to host your Azure Functions on a Premium Azure Functions
    service plan. This removes the execution length duration because rather than paying
    per transaction, you are essentially reserving capacity.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 总执行次数是一个相对简单的度量，似乎没有限制，但 Azure Functions 本身有自然的限制。例如，每个执行的时间限制为 10 分钟。如果你正在尝试响应来自
    Web 应用的请求，你可能不希望将 Azure Function 设计为 10 分钟，这对于最终用户在浏览器中的体验来说显然是非常差的。在这种情况下，你希望
    Azure Function 能在几秒钟内返回。然而，除了响应浏览器中的 HTTP 请求，Azure Functions 还可以用于许多其他任务，有时，长时间运行的活动也是合适的。在这些情况下，你可以选择将
    Azure Functions 托管在高级 Azure Functions 服务计划上，这样就能移除执行时长限制，因为你支付的不是按交易计费，而是预留容量。
- en: 'Azure Functions have multiple hosting options. There is the **Premium service
    plan** that we discussed previously, which allows you to reserve capacity, connect
    to private networks, remove the 10-minute cap on Azure Function execution duration,
    and allow your Azure Functions to run up to 60 minutes. These Premium plans have
    sunk cost as you are pre-allocating Azure resources to ensure your Azure Functions
    operate at maximum performance. You can even select different hardware configurations
    (CPU and memory) to better fit your workload’s needs:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 有多种托管选项。我们之前讨论过的**高级服务计划**允许你预留容量，连接到私人网络，移除 Azure Function
    执行时长的 10 分钟限制，并允许 Azure Functions 最长运行 60 分钟。由于这些高级计划需要预先分配 Azure 资源以确保 Azure
    Functions 最大性能运行，因此它们具有沉没成本。你甚至可以选择不同的硬件配置（CPU 和内存），以更好地适应工作负载的需求：
- en: '![Figure 12.4 – Azure Functions are deployed to Function Apps, which are hosted
    on App Service plans](img/B21183_12_4.0.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.4 – Azure Functions 部署到功能应用，功能应用托管在应用服务计划中](img/B21183_12_4.0.jpg)'
- en: Figure 12.4 – Azure Functions are deployed to Function Apps, which are hosted
    on App Service plans
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 – Azure Functions 被部署到功能应用中，功能应用托管在应用服务计划上
- en: In stark contrast, there is the **Consumption service plan**, which has no sunk
    cost but more constraints on usage and no control over scaling and resource configuration
    of the host environment. The Consumption service plan is a good place to do development
    and testing, but if you’re going to run production workloads, I’d highly recommend
    sticking with a Premium service plan.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与此形成鲜明对比的是**消费服务计划**，它没有沉没成本，但在使用上有更多的限制，且无法控制主机环境的扩展和资源配置。消费服务计划非常适合开发和测试，但如果你打算运行生产工作负载，我强烈建议选择高级服务计划。
- en: Previously, our ASP.NET REST API was set up using a traditional ASP.NET project
    that used controllers to implement the REST API endpoints. However, when transitioning
    to Azure Functions, this solution structure is incompatible with the Azure Functions
    framework. To be able to host our REST API as Azure Functions, we need to conform
    to the framework that Azure Functions dictates. This means that the ASP.NET controller
    classes will need to be refactored so that they conform to this standard. In the
    next section, we’ll delve into the code that makes this possible.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们的 ASP.NET REST API 是使用传统的 ASP.NET 项目设置的，该项目通过控制器来实现 REST API 端点。然而，当过渡到
    Azure Functions 时，这种解决方案结构与 Azure Functions 框架不兼容。为了能够将我们的 REST API 托管为 Azure
    Functions，我们需要遵循 Azure Functions 所要求的框架。这意味着，ASP.NET 控制器类需要进行重构，以符合这一标准。在下一节中，我们将深入探讨使这一切成为可能的代码。
- en: Deployment architecture
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署架构
- en: Now that we have a good idea of what our cloud architecture is going to look
    like for our solution on Azure, we need to come up with a plan for how to provision
    our environments and deploy our code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 Azure 上的云架构有了一个清晰的了解，我们需要制定一个计划，来确定如何配置环境并部署我们的代码。
- en: In [*Chapter 10*](B21183_10.xhtml#_idTextAnchor474), when we deployed our application
    to VMs, we baked our compiled application code into a VM image using Packer. Similarly,
    in [*Chapter 11*](B21183_11.xhtml#_idTextAnchor509), when we deployed our application
    to containers on our Kubernetes cluster, we baked our application code into container
    images using Docker. With serverless, this completely changes because Azure’s
    serverless offerings completely abstract away the operating system. This means
    that all we are responsible for is producing a compatible deployment package.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 10 章*](B21183_10.xhtml#_idTextAnchor474)中，当我们将应用程序部署到虚拟机时，我们通过 Packer 将编译后的应用程序代码打包到虚拟机镜像中。同样，在[*第
    11 章*](B21183_11.xhtml#_idTextAnchor509)中，当我们将应用程序部署到 Kubernetes 集群中的容器时，我们使用
    Docker 将应用程序代码打包成容器镜像。对于无服务器架构，这完全改变了，因为 Azure 的无服务器服务完全抽象了操作系统。这意味着我们只需要负责生成一个兼容的部署包。
- en: Creating the deployment package
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建部署包
- en: 'As we discussed in the previous section, we have two components of our application:
    the frontend and the backend. Each has a different deployment target. We are going
    to deploy the frontend as a static website, while the backend is going to be deployed
    as an Azure Function. Since both are .NET projects, we will be using both .NET
    and Azure platform-specific tools to create deployment packages and deploy them
    to their target Azure services. The following diagram shows the process we’ll
    go through to provision our environment, package our application code, and deploy
    it to the target environment out in Azure:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上一节中讨论的，我们的应用程序有两个组成部分：前端和后端。它们各自有不同的部署目标。我们将把前端部署为静态网站，而后端则作为 Azure Function
    部署。由于这两者都是 .NET 项目，我们将使用 .NET 和 Azure 平台特定的工具来创建部署包并将其部署到目标 Azure 服务。下图展示了我们将要经历的过程，涉及到如何配置环境、打包应用程序代码并将其部署到
    Azure 的目标环境中：
- en: '![Figure 12.5 – Deployment pipeline to build our .NET application code for
    deployment to Azure](img/B21183_12_5.0.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.5 – 部署管道：构建我们的 .NET 应用程序代码并部署到 Azure](img/B21183_12_5.0.jpg)'
- en: Figure 12.5 – Deployment pipeline to build our .NET application code for deployment
    to Azure
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5 – 部署管道：构建我们的 .NET 应用程序代码并部署到 Azure
- en: For the frontend, this means enabling the feature to deploy our ASP.NET Blazor
    web application as a WebAssembly. This will allow the frontend to be hosted as
    a static website that can run completely client-side without any server-side rendering.
    This is only possible because of the way we have designed our frontend web application,
    which uses HTML, CSS, and JavaScript to interact with server-side REST APIs. It’s
    important to note that ASP.NET Blazor supports both hosting options, but we specifically
    chose to go down the client-side-only path and eliminate any dependency on server-side
    page rendering. As a result, when we use the .NET CLI to publish our ASP.NET Blazor
    project, it will emit a folder containing static web content. Then, using the
    Azure CLI, we can upload the contents of this folder to our Azure Blob storage
    account’s `$web` container to complete the deployment.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前端，这意味着启用功能将我们的 ASP.NET Blazor Web 应用程序部署为 WebAssembly。这将允许前端作为静态网站托管，并且可以完全在客户端运行，而不需要任何服务器端渲染。之所以能做到这一点，是因为我们设计前端
    Web 应用程序的方式，它使用 HTML、CSS 和 JavaScript 与服务器端 REST API 进行交互。需要注意的是，ASP.NET Blazor
    支持两种托管选项，但我们特别选择了只使用客户端的路径，并消除了对服务器端页面渲染的任何依赖。因此，当我们使用 .NET CLI 发布我们的 ASP.NET
    Blazor 项目时，它将生成一个包含静态 Web 内容的文件夹。然后，我们可以使用 Azure CLI 将该文件夹的内容上传到我们的 Azure Blob
    存储帐户的 `$web` 容器中，完成部署。
- en: For the backend, again using the .NET CLI, we need to publish our project. This
    will emit all the files needed to properly inform the Azure Functions service
    about our little Azure Function. Once this is done, we need to zip this folder
    up into a zip archive. Finally, we can use the Azure CLI to deploy this zip archive
    to our Azure Function.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于后端，再次使用 .NET CLI，我们需要发布我们的项目。这将生成所有需要的文件，以便正确地将我们的 Azure 函数告知 Azure Functions
    服务。一旦完成，我们需要将这个文件夹压缩成一个 zip 压缩包。最后，我们可以使用 Azure CLI 将这个 zip 压缩包部署到我们的 Azure Function。
- en: Now that we have a solid plan for how we will implement both the cloud architecture
    using Azure and the deployment architecture using GitHub Actions, let’s start
    building! In the next section, we’ll break down the **HashiCorp Configuration
    Language** (**HCL**) code we can use to implement the Terraform code and modify
    the application code so that it conforms to the Azure Functions framework.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个坚实的计划，来实施通过 Azure 构建云架构和使用 GitHub Actions 实现部署架构，接下来就开始构建吧！在接下来的部分中，我们将详细解析我们可以使用的**HashiCorp
    配置语言**（**HCL**）代码，用来实现 Terraform 代码，并修改应用程序代码，使其符合 Azure Functions 框架。
- en: Building the solution
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建解决方案
- en: Now that we have a solid design for our solution, we can begin building it.
    As we discussed in the previous section, because we’ll be using Azure serverless
    offerings such as Azure Storage and Azure Functions to host our application, we
    will need to make some changes to our application code. This is something that
    we never had to do in *Chapters 10* and *11* as we were able to deploy our application
    to the cloud by packaging it in either a VM image (using Packer) or in a container
    image (using Docker). Therefore, to build our solution, we need to write some
    Terraform code and update our application code in C#.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个稳固的解决方案设计，我们可以开始构建它了。正如我们在上一部分中讨论的那样，由于我们将使用 Azure 的无服务器服务，如 Azure 存储和
    Azure Functions 来托管我们的应用程序，因此我们需要对应用程序代码进行一些修改。这是我们在*第10章*和*第11章*中不需要做的事情，因为那时我们可以通过将应用程序打包成
    VM 镜像（使用 Packer）或容器镜像（使用 Docker）来部署到云端。因此，为了构建我们的解决方案，我们需要编写一些 Terraform 代码，并更新我们用
    C# 编写的应用程序代码。
- en: Terraform
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Terraform
- en: 'As we discussed in our design, our solution is made up of two application components:
    the frontend and the backend. Each has a code base of application code that needs
    to be deployed. Unlike previous chapters, where we had operating system configuration
    as well, now that we are using serverless offerings, this is no longer our responsibility
    as the platform takes care of it for us.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在设计中讨论的那样，我们的解决方案由两个应用程序组件组成：前端和后端。每个组件都有一个需要部署的应用程序代码库。与前几章不同，那时我们还需要操作系统配置，但现在我们使用无服务器服务时，这不再是我们的责任，因为平台会为我们处理这一部分。
- en: Much of the Terraform setup is very similar to what we have done in previous
    chapters, so we will only focus on new resources needed for our solution. You
    can check the full source code for this book, which is available in this book’s
    GitHub repository, if you want to work with the complete solution.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 设置的大部分内容与我们在前几章中做的非常相似，所以我们将只关注解决方案所需的新资源。如果你想使用完整的解决方案，可以查看本书的 GitHub
    仓库中的完整源代码。
- en: Frontend
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前端
- en: 'First, we need to provision a storage account where we can deploy our frontend
    to. The Azure Storage account is one of the most common Terraform resources to
    be provisioned as many other Azure services use storage accounts for different
    purposes. However, we need to configure our storage account differently by using
    an optional block called `static_website`. This block will enable the static website
    feature and will place the `$web` container in our storage account by default:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要配置一个存储帐户，用来部署我们的前端。Azure 存储帐户是最常见的 Terraform 资源之一，因为许多其他 Azure 服务都使用存储帐户来实现不同的目的。然而，我们需要通过使用一个名为
    `static_website` 的可选块来不同地配置我们的存储帐户。此块将启用静态网站功能，并默认将 `$web` 容器放置在我们的存储帐户中：
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Backend
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后端
- en: Azure Functions are deployed to a resource called a function app. They come
    in two varieties – one for Windows and another for Linux. This can be quite perplexing
    – isn’t the whole purpose of using a serverless offering so that you don’t have
    to think about the operating system? However, the underlying operating system
    can impact the types of runtimes that are supported for your Azure Function.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 被部署到一个叫做功能应用程序的资源上。它们有两种类型——一种是 Windows 类型，另一种是 Linux 类型。这可能会让人困惑——使用无服务器产品的主要目的不就是为了不用考虑操作系统吗？然而，底层操作系统可能会影响
    Azure Function 支持的运行时类型。
- en: 'To provide a function app, we need to have a service plan. As we mentioned
    in the previous section, there are multiple types of service plans. The two main
    types are Consumption and Premium. To use a Consumption service plan, you need
    to use `Y1` as the SKU name, and to use a Premium service plan, you need to use
    either `EP1`, `EP2`, or `EP3`. Each of the Premium service plan SKUs has a different
    set of compute and memory resources:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要提供一个功能应用程序，我们需要一个服务计划。正如我们在上一节中提到的，有多种类型的服务计划。主要有两种类型：消费型（Consumption）和高级型（Premium）。使用消费型服务计划时，你需要使用
    `Y1` 作为 SKU 名称，而使用高级型服务计划时，你需要选择 `EP1`、`EP2` 或 `EP3` 作为 SKU 名称。每种高级服务计划的 SKU 都有不同的计算和内存资源：
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that we have a service plan, we can provision one or more function apps
    for it. The function apps do not need to share the same resource group, so you
    could have a central team manage the service plans and have each team manage its
    own function apps that are hosted within the service plan:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了服务计划，我们可以为其配置一个或多个功能应用程序。功能应用程序不需要共享相同的资源组，因此你可以让一个中央团队管理服务计划，并让各个团队管理其在服务计划中托管的功能应用程序：
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The important thing is that the operating system of the service plan should
    match the function app’s Terraform resource type. Only `azurerm_windows_function_app`
    resources should be provisioned to service plans with an `os_type` value of `Windows`,
    and likewise, only `azurerm_linux_function_app` resources should be provisioned
    to service plans with an `os_type` value of `Linux`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，服务计划的操作系统应该与功能应用程序的 Terraform 资源类型匹配。只有 `azurerm_windows_function_app`
    资源应该部署到操作系统类型为 `Windows` 的服务计划上，同样，只有 `azurerm_linux_function_app` 资源应该部署到操作系统类型为
    `Linux` 的服务计划上。
- en: The function app also needs a storage account to be provisioned. This should
    be different than the storage account that’s used to provision the frontend. While
    it’s a common practice to provision a dedicated storage account for the function
    app, it’s technically possible to use the same storage account for both the function
    app and the frontend. However, given that there is no additional cost for an additional
    storage account, you only pay for the storage. I recommend provisioning a dedicated
    storage account to keep the separation between the two components of your architecture.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 功能应用程序也需要一个存储帐户。这个存储帐户应该与用于配置前端的存储帐户不同。虽然为功能应用程序配置一个专用存储帐户是一个常见做法，但技术上可以使用同一个存储帐户来同时配置功能应用程序和前端。然而，由于额外的存储帐户没有额外费用，你只需为存储付费。因此，我建议配置一个专用的存储帐户，以保持架构中两个组件之间的分离。
- en: Secrets management
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 密钥管理
- en: 'An important block for a function app is the `app_settings` block. This is
    where we can pass secrets to our Azure Functions, as well as other parameters
    that affect our deployment strategy and other runtime configurations:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 功能应用程序的一个重要块是 `app_settings` 块。在这里，我们可以将密钥传递给 Azure Functions，以及其他影响部署策略和运行时配置的参数：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, we are setting the connection string for the Azure Storage account that
    we will use to connect to blob and queue storage within the application. We can
    also use Key Vault to store these secrets using special syntax:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在设置用于连接到应用程序中的 Blob 和队列存储的 Azure Storage 帐户连接字符串。我们还可以使用 Key Vault 存储这些机密，使用特殊语法：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we replace the previous setting with the new one, we will no longer store
    the secret in the Azure Function app. The secret is only in Key Vault:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用新的设置替换之前的设置，我们将不再在 Azure Function 应用中存储机密。机密只存在于 Key Vault 中：
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This also requires us to set up a role assignment to grant the Azure Function’s
    user-assigned identity the necessary permissions to access the secrets stored
    in Key Vault. Without this necessary role assignment, even if we use the special
    syntax to refer to the Key Vault secret correctly, Azure Functions will not be
    able to access the secrets:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这也要求我们设置角色分配，以授予 Azure Function 用户分配的身份必要的权限，从而访问存储在 Key Vault 中的机密。没有这个必要的角色分配，即使我们使用特殊语法正确引用
    Key Vault 秘密，Azure Functions 也无法访问这些机密：
- en: '![Figure 12.6 – The structure of Azure Functions resources](img/B21183_12_6.0.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.6 – Azure Functions 资源结构](img/B21183_12_6.0.jpg)'
- en: Figure 12.6 – The structure of Azure Functions resources
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6 – Azure Functions 资源结构
- en: As you can see, the Azure function is a much more simple deployment. We don’t
    need a virtual network or any of the other surrounding resources that we provisioned
    in previous chapters just to get off the ground. For most applications, the built-in
    security of Azure Functions and Key Vault is sufficient. However, if we wanted
    to enable private networking because our application has to follow some regulatory
    compliance, we can do that, but otherwise, it is not required.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Azure Function 是一个更为简洁的部署。我们不需要虚拟网络或我们在前几章中配置的其他周边资源就可以启动。对于大多数应用程序，Azure
    Functions 和 Key Vault 的内建安全性就足够了。然而，如果我们想启用私有网络，因为我们的应用必须遵守某些法规合规要求，我们是可以做到的，但除此之外并不需要。
- en: Application code
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序代码
- en: Azure Functions are inherently event-based. Each Azure Function is triggered
    by a different type of event, and the Azure Functions SDK provides an extensible
    framework for triggering based on different types of events. Azure Functions has
    implemented several different triggers for all sorts of different Azure services,
    which makes it easy to design Azure Functions that can respond to all sorts of
    different activities taking place within your Azure environment. For this book,
    we’ll only focus on the HTTP trigger, but if you are interested, I recommend checking
    out all the other options that Azure Functions has – it’s quite extensive.tt
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 本质上是基于事件的。每个 Azure Function 都是由不同类型的事件触发的，Azure Functions SDK
    提供了一个可扩展的框架，用于根据不同类型的事件进行触发。Azure Functions 已经为各种不同的 Azure 服务实现了多个不同的触发器，这使得设计能够响应
    Azure 环境中发生的各种活动的 Azure Functions 变得容易。对于本书，我们只关注 HTTP 触发器，但如果你有兴趣，我建议你查看 Azure
    Functions 提供的所有其他选项——它非常广泛。
- en: 'In a traditional ASP.NET REST API solution, you have controller classes that
    embody a specific route and then methods that implement different operations at
    that route:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的 ASP.NET REST API 解决方案中，你有控制器类，它们体现了特定的路由，然后是实现该路由下不同操作的方法：
- en: '![Figure 12.7 – ASP.NET MVC controller class anatomy](img/B21183_12_7.0.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.7 – ASP.NET MVC 控制器类结构](img/B21183_12_7.0.jpg)'
- en: Figure 12.7 – ASP.NET MVC controller class anatomy
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7 – ASP.NET MVC 控制器类结构
- en: The controller class needs to be decorated with an `ApiController` attribute
    that informs the ASP.NET runtime that this class should be used to process incoming
    web requests at the route specified in the `Route` attribute.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器类需要使用`ApiController`特性进行装饰，以通知 ASP.NET 运行时该类应用于处理指定在`Route`特性中的路由的传入 Web
    请求。
- en: Each method is decorated with an attribute that denotes which HTTP verb the
    method should respond to. In the preceding example, we use `HttpGet`, but there
    are corresponding attributes for each of the supported HTTP verbs. The method
    can take strongly typed parameters that can either be part of the route, the query
    string, or the request body. The method returns `IActionResult` by default, which
    allows us to return different data structures, depending on the outcome of the
    request.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法都用一个特性进行装饰，表示该方法应响应哪种 HTTP 动词。在上面的示例中，我们使用了`HttpGet`，但每个支持的 HTTP 动词都有相应的特性。方法可以采用强类型参数，这些参数可以是路由的一部分、查询字符串的一部分或请求体的一部分。方法默认返回`IActionResult`，这使得我们可以根据请求的结果返回不同的数据结构。
- en: 'To implement a REST API using Azure Functions, we need to implement a class
    using the Azure Function SDK. This requires us to slightly adjust how we implement
    both our class and our method. We will employ different class and method attributes
    to achieve a similar outcome: defining an endpoint that responds to web requests
    at a specific route.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Azure Functions实现一个REST API，我们需要使用Azure Function SDK实现一个类。这要求我们稍微调整实现类和方法的方式。我们将使用不同的类和方法属性来实现一个类似的结果：定义一个响应特定路由的网页请求的端点。
- en: 'The Azure Function class is not decorated with any attributes:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Function类没有被修饰任何属性：
- en: '![Figure 12.8 – Azure Function class anatomy](img/B21183_12_8.0.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图12.8 – Azure Function类结构](img/B21183_12_8.0.jpg)'
- en: Figure 12.8 – Azure Function class anatomy
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8 – Azure Function类结构
- en: Only the methods should be decorated with a `FunctionName` attribute, which
    will correlate them with a named scope for the Azure Function framework. This
    attribute is similar to the `Route` attribute as it informs the base route of
    all of the methods implemented within this named context of Azure Functions. Azure
    Function classes can be implemented as static or non-static classes. I recommend
    using non-static classes as they allow you to use dependency injection to greatly
    improve the testability of your Azure Functions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 只有方法需要使用`FunctionName`属性进行修饰，这将使它们与Azure Function框架中的命名范围相关联。这个属性类似于`Route`属性，它告知所有在此命名上下文中实现的方法的基础路由。Azure
    Function类可以实现为静态类或非静态类。我推荐使用非静态类，因为它们允许你使用依赖注入，极大地提高了Azure Function的可测试性。
- en: The methods in an Azure Functions class are where we tie into the event-triggering
    framework of Azure Functions. When responding to a web request, we need the first
    parameter of our method to be of the `HttpRequest` type, and we need to use the
    `HttpTrigger` attribute on this method parameter. Since we decorated the method
    with the `FunctionName` attribute already, the Azure Functions framework knows
    to interrogate this method for any available event triggers. Hence, supplying
    `HttpRequest` with the `HttpTrigger` attribute attached will meet the match criteria,
    and Azure Functions will wire up this method so that it responds to incoming web
    traffic accordingly.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Function类中的方法是我们与Azure Functions的事件触发框架结合的地方。在响应网页请求时，我们需要方法的第一个参数为`HttpRequest`类型，并且我们需要在该方法参数上使用`HttpTrigger`属性。由于我们已经使用`FunctionName`属性修饰了该方法，Azure
    Function框架会知道检查此方法是否有可用的事件触发器。因此，提供附加`HttpTrigger`属性的`HttpRequest`将满足匹配条件，Azure
    Function会将该方法与传入的网页流量连接，以便做出相应响应。
- en: 'This pattern is very similar to the traditional ASP.NET implementation using
    controller classes. However, it takes on a slightly different structure. All the
    same anatomical elements are there but just in different places: HTTP verb, route
    to the endpoint, input parameters (either a query string or on the request body),
    and the response body.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式与传统的ASP.NET实现使用控制器类非常相似。然而，它采用了略有不同的结构。所有相同的解剖元素都存在，只是位置不同：HTTP动词、端点路由、输入参数（可以是查询字符串或请求体中的一部分）以及响应体。
- en: Unlike in a traditional ASP.NET project, the HTTP verb is not a method-level
    attribute. It’s a parameter of the `HttpTrigger` attribute. The method does allow
    us to add additional input parameters as either query string or part of the route
    but not part of the request body itself.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的ASP.NET项目不同，HTTP动词不是方法级别的属性。它是`HttpTrigger`属性的一个参数。该方法确实允许我们将额外的输入参数作为查询字符串或路由的一部分添加，但不能作为请求体的一部分。
- en: 'As we can see, the cloud architecture radically simplifies things, but one
    trade-off is that our backend code needs to be adapted to the Azure Functions
    framework. This will require development and testing efforts to transform our
    code base into this new hosting model. This stands in stark contrast to what we
    explored in previous chapters, where we hosted on VMs or containerized and hosted
    on a Kubernetes cluster. While conforming to the Azure Functions model does take
    work, its benefits are two-fold: first, it allows us to take advantage of close
    to zero sunk cost, and second, it allows us to fully abstract the underlying infrastructure
    from us and let the Azure platform take care of scalability and high availability.
    This allows us to focus more on the functionality of our solutions rather than
    the plumbing required to keep the lights on.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，云架构大大简化了事情，但其权衡是我们的后台代码需要适应 Azure Functions 框架。这将需要开发和测试工作来将我们的代码库转换为这种新的托管模型。这与我们在前几章中探讨的内容形成鲜明对比，在前几章中，我们是托管在虚拟机上，或者将应用程序容器化并托管在
    Kubernetes 集群上。虽然适应 Azure Functions 模型需要一定的工作，但它的好处是双重的：首先，它使我们能够利用接近零的沉没成本；其次，它让我们可以完全抽象化底层基础设施，Azure
    平台可以负责可伸缩性和高可用性。这使得我们能够更多地专注于解决方案的功能，而不是维持系统运行所需的底层基础设施。
- en: Now that we have implemented Terraform to provision our solution and made changes
    to our application code so that it conforms to the Azure Functions framework,
    in the next section, we’ll dive into YAML and Bash and implement the necessary
    GitHub Actions workflows.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实施了 Terraform 来配置我们的解决方案，并修改了应用程序代码以使其符合 Azure Functions 框架，接下来的章节中，我们将深入探讨
    YAML 和 Bash，并实施必要的 GitHub Actions 工作流。
- en: Automating the deployment
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化部署
- en: As we discussed in the previous section, serverless offerings such as Azure
    Functions and Azure Storage abstract away the operating system configuration.
    Therefore, when we deploy, we just need an application package that’s compatible
    with the target platform. In this section, we’ll create an automation pipeline
    using GitHub Actions that will provision our application to its new serverless
    home in Azure.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中讨论的那样，无服务器服务，如 Azure Functions 和 Azure Storage，抽象化了操作系统的配置。因此，当我们进行部署时，我们只需要一个与目标平台兼容的应用程序包。在本节中，我们将使用
    GitHub Actions 创建一个自动化流水线，将我们的应用程序部署到 Azure 中新的无服务器环境。
- en: Terraform
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Terraform
- en: 'The first thing that we need to do is provision our environment to Azure. This
    is going to be extremely similar to the way we did this in the previous chapters.
    In [*Chapter 10*](B21183_10.xhtml#_idTextAnchor474), we needed to ensure that
    our VM images were built and available before we executed Terraform because the
    Terraform code base referenced the VM images when it provisioned the VMs. This
    means that with our VM architecture, application deployment happens before Terraform
    provisions the environment:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是将环境配置到 Azure。这将与我们在前几章中所做的非常相似。在[*第 10 章*](B21183_10.xhtml#_idTextAnchor474)中，我们需要确保虚拟机镜像已经构建并可用，然后才能执行
    Terraform，因为 Terraform 的代码库在配置虚拟机时引用了这些虚拟机镜像。这意味着，在我们的虚拟机架构中，应用程序部署发生在 Terraform
    配置环境之前：
- en: '![Figure 12.9 – Packer-produced VM images are a prerequisite for Terraform](img/B21183_12_9.0.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.9 – Packer 生产的虚拟机镜像是 Terraform 的前提条件](img/B21183_12_9.0.jpg)'
- en: Figure 12.9 – Packer-produced VM images are a prerequisite for Terraform
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.9 – Packer 生产的虚拟机镜像是 Terraform 的前提条件
- en: 'In [*Chapter 11*](B21183_11.xhtml#_idTextAnchor509), when we provisioned our
    Kubernetes cluster using Azure Kubernetes, we had no such prerequisite. The application
    deployment occurred after the Kubernetes cluster was online. This means that with
    container-based architecture, application deployment happens after Terraform provisions
    the environment:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 11 章*](B21183_11.xhtml#_idTextAnchor509)中，当我们使用 Azure Kubernetes 配置 Kubernetes
    集群时，并没有这样的前提条件。应用程序部署发生在 Kubernetes 集群上线之后。这意味着，在基于容器的架构中，应用程序部署发生在 Terraform
    配置环境之后：
- en: '![Figure 12.10 – Docker-produced container images are provisioned to Kubernetes
    after Terraform executes](img/B21183_12_10.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.10 – Docker 生产的容器镜像在 Terraform 执行后被提供给 Kubernetes](img/B21183_12_10.jpg)'
- en: Figure 12.10 – Docker-produced container images are provisioned to Kubernetes
    after Terraform executes
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.10 – Docker 生产的容器镜像在 Terraform 执行后被提供给 Kubernetes
- en: When using Azure’s serverless offerings, the deployment process mirrors that
    of what we saw when deploying our application as containers to Kubernetes. Just
    like with this approach, we need to build a deployment artifact for Azure’s serverless
    offerings. For the frontend, that means simply generating the static web content,
    and for the backend, that means generating an Azure Functions ZIP archive. These
    artifacts share a similar purpose to the Docker images in that they are a target
    service-compatible way of packaging our application for deployment.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Azure 的无服务器服务时，部署过程与我们将应用程序部署为容器到 Kubernetes 时看到的过程相似。就像这种方法一样，我们需要为 Azure
    的无服务器服务构建部署工件。对于前端，这意味着仅仅生成静态网页内容，而对于后端，这意味着生成 Azure Functions 的 ZIP 压缩包。这些工件与
    Docker 镜像类似，都是将我们的应用程序打包为目标服务兼容的部署方式。
- en: 'As shown in the following figure, the serverless deployment looks very similar
    to the approach we used with the container-based architecture:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，无服务器部署与我们在基于容器的架构中使用的方法非常相似：
- en: '![Figure 12.11 – The .NET CLI produces deployment artifacts that are provisioned
    to Azure after Terraform executes](img/B21183_12_11.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.11 – .NET CLI 生成的部署工件，在 Terraform 执行后被提供到 Azure](img/B21183_12_11.jpg)'
- en: Figure 12.11 – The .NET CLI produces deployment artifacts that are provisioned
    to Azure after Terraform executes
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.11 – .NET CLI 生成的部署工件，在 Terraform 执行后被提供到 Azure
- en: That’s because Azure is fulfilling the role that Kubernetes played when using
    a serverless approach. Azure just has custom tools to facilitate the deployment
    of the application.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 Azure 在使用无服务器方法时，扮演了 Kubernetes 的角色。Azure 只是提供了自定义工具来促进应用程序的部署。
- en: Deployment
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署
- en: Now that Terraform has provisioned the Azure infrastructure that we need for
    our serverless solution, we need to take the final step of deploying both deployment
    artifacts to the appropriate locations in Azure.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Terraform 已经为我们的无服务器解决方案提供了所需的 Azure 基础设施，我们需要执行最后一步，将这两个部署工件部署到 Azure 中的相应位置。
- en: We will use .NET and Azure custom tools to produce the artifacts and deploy
    them to these target locations.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 .NET 和 Azure 自定义工具来生成工件并将其部署到这些目标位置。
- en: Frontend
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前端
- en: As we saw in other chapters, our .NET application code needs to follow a continuous
    integration process where the code is built and tested using automated unit testing
    and other built-in quality controls. Nothing changes here, except that we need
    to add some special handling to the deployment artifact that these processes produce
    to make sure it is available to our GitHub Action’s job that deploys the workload
    to the appropriate location.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在其他章节中看到的，我们的 .NET 应用程序代码需要遵循一个持续集成的过程，其中代码通过自动化单元测试和其他内置的质量控制进行构建和测试。在这里没有什么变化，唯一需要注意的是，我们需要为这些过程生成的部署工件添加一些特殊处理，确保它能够在将工作负载部署到合适位置的
    GitHub Action 工作中可用。
- en: 'The `dotnet publish` command is used to output the deployment artifact of the
    .NET application code. For the ASP.NET Blazor web application, this output is
    a folder container, a collection of loose files containing HTML, JavaScript, and
    CSS. To pass all these files efficiently from one GitHub Actions job to another,
    we need to zip them up into a single file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`dotnet publish` 命令用于输出 .NET 应用程序代码的部署工件。对于 ASP.NET Blazor Web 应用程序，这个输出是一个文件夹容器，包含
    HTML、JavaScript 和 CSS 等松散的文件。为了高效地将这些文件从一个 GitHub Actions 工作传递到另一个，我们需要将它们打包成一个单独的文件：'
- en: '[PRE6]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that the static web content has been zipped into a ZIP archive, we can
    use the `upload-artifact` GitHub Action to save this file to GitHub Actions. This
    will make the file available for future jobs that are executed within the pipeline:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，静态网页内容已经被压缩成一个 ZIP 文件，我们可以使用 `upload-artifact` GitHub Action 将此文件保存到 GitHub
    Actions 中。这将使得文件可以在未来的工作中被使用，该工作将在流水线中执行：
- en: '[PRE7]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Future jobs can simply download the artifact using a corresponding `download-artifact`
    GitHub Action and the same name that was used to upload it:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 未来的工作可以使用相应的 `download-artifact` GitHub Action，通过上传时使用的相同名称简单地下载工件：
- en: '[PRE8]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Because the ASP.NET Blazor web application is going to be hosted as static
    web content on our Azure Storage account, we need to ensure that we unzip it to
    upload the contents to Azure Blob storage. If we were to upload the zip archive
    to Blob storage, the web application wouldn’t work correctly because all of the
    web content would be trapped inside the archive file:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 ASP.NET Blazor Web 应用程序将作为静态网页内容托管在我们的 Azure 存储帐户中，所以我们需要确保解压缩它以将内容上传到 Azure
    Blob 存储。如果我们直接将 ZIP 文件上传到 Blob 存储，Web 应用程序将无法正常工作，因为所有网页内容都被困在压缩包内：
- en: '[PRE9]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now that the static web content has been unzipped to the staging directory,
    we can use the `az storage blob upload-batch` command to deploy all of the files
    to the `$``web` container:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在静态网页内容已经被解压到暂存目录，我们可以使用 `az storage blob upload-batch` 命令将所有文件部署到 `$``web`
    容器中：
- en: '[PRE10]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We need to make sure that we authenticate with Azure and that we are targeting
    the right Azure subscription that has the Azure Storage account that we want to
    target. Therefore, we need to execute the `az login` command to authenticate and
    then use `az account set` to ensure we are working on the right subscription.
    Once we’ve done that, we can execute `az storage blob upload-batch` to recursively
    upload all the files within the staging directory.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保与 Azure 进行身份验证，并确保我们正在使用具有目标 Azure 存储帐户的正确 Azure 订阅。因此，我们需要执行 `az login`
    命令进行身份验证，然后使用 `az account set` 来确保我们正在使用正确的订阅。完成这些操作后，我们就可以执行 `az storage blob
    upload-batch` 命令，将暂存目录中的所有文件递归上传。
- en: Azure Function
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Azure Function
- en: To deploy the Azure Function, the same process must be followed to pass the
    artifact from the GitHub Actions job that builds the deployment artifact to the
    job that deploys the artifact.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署 Azure Function，必须遵循相同的流程，将从 GitHub Actions 作业中构建的部署工件传递到部署工件的作业中。
- en: 'Like the `az storage blob upload-batch` command, we also need to authenticate
    and set the right Azure subscription. The only difference is that we are using
    the `az functionapp deployment source config-zip` command to provision a ZIP archive
    to the Azure Function:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 像 `az storage blob upload-batch` 命令一样，我们还需要进行身份验证并设置正确的 Azure 订阅。唯一的区别是，我们使用的是
    `az functionapp deployment source config-zip` 命令来将 ZIP 文件部署到 Azure Function：
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Unlike how we provisioned the frontend, we don’t need to unzip the deployment
    package for the Azure Function. Azure Functions is expecting our application code
    to be bundled into a ZIP archive:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们为前端提供的方式不同，我们不需要解压部署包来为 Azure Function 服务。Azure Functions 期望我们的应用代码已被打包成
    ZIP 文件：
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You might remember from the previous section where we set `app_settings` on
    the Azure Function that we set two settings – `SCM_DO_BUILD_DURING_DEPLOYMENT`
    and `WEBSITE_RUN_FROM_PACKAGE`. These two settings tell Azure Functions that our
    application code is already pre-compiled and bundled into a ZIP archive.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得在上一节中我们在 Azure Function 上设置的 `app_settings`，我们设置了两个配置项——`SCM_DO_BUILD_DURING_DEPLOYMENT`
    和 `WEBSITE_RUN_FROM_PACKAGE`。这两个配置项告诉 Azure Functions，我们的应用代码已经预编译并打包成一个 ZIP 文件。
- en: That’s it! With that, our application has been fully deployed to Azure Storage
    and Azure Functions!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！通过这个步骤，我们的应用程序已经成功部署到 Azure 存储和 Azure Functions！
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we designed, built, and automated the deployment of a complete
    end-to-end solution using serverless architecture using Azure Functions. To accomplish
    this, we finally had to make some major changes to our application code so that
    it conformed to the requirements of the serverless runtime. When adopting serverless
    offerings, you must make this distinct and considerable decision as it tightly
    couples your application code with the target cloud platform.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们设计、构建并自动化了使用 Azure Functions 构建完整端到端解决方案的部署。为了实现这一点，我们最终需要对应用程序代码进行一些重大更改，以便它符合无服务器运行时的要求。在采用无服务器服务时，你必须做出这个明显且重要的决策，因为它将你的应用代码与目标云平台紧密耦合。
- en: Throughout this journey, we have meticulously constructed three distinct solutions
    on the Azure platform by utilizing VMs, Kubernetes through **Azure Kubernetes
    Service** (**AKS**), and now, serverless with Azure Functions.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这整个过程中，我们通过利用虚拟机、通过**Azure Kubernetes 服务**（**AKS**）的 Kubernetes，以及现在的无服务器架构（Azure
    Functions），在 Azure 平台上精心构建了三种不同的解决方案。
- en: As we conclude this Azure-centric narrative, we stand on the brink of a thrilling
    new alternate reality. Guided by the enigmatic vision of our CEO, Keyser Söze,
    we are poised to embark on an adventurous collaboration with Google. This partnership
    is set to unfold in a realm of endless possibilities, mirroring our Azure achievements
    on Google Cloud. Our narrative will transition to exploring similar architectures
    on Google Cloud, so stay tuned as we venture into this *alternate universe* with
    Keyser Söze, delving into Google Cloud’s offerings and continuing to innovate
    our solutions in cloud computing.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们结束这个以Azure为中心的叙述，我们站在一个令人兴奋的新替代现实的边缘。在我们神秘的CEO Keyser Söze的远见引领下，我们准备开始与Google展开一次冒险性的合作。这个伙伴关系将在无限可能的领域中展开，反映我们在Azure上的成就，迁移到Google
    Cloud上。我们的叙述将转向探索Google Cloud上的类似架构，敬请关注，随着我们与Keyser Söze一起进入这个*替代宇宙*，深入挖掘Google
    Cloud的服务，并继续创新我们的云计算解决方案。
- en: 'Part 5: Building Solutions on Google Cloud'
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五部分：在Google Cloud上构建解决方案
- en: 'Armed with the conceptual knowledge of Terraform and architectural concepts
    that transcend the implementation details of the major public cloud platforms,
    we’ll explore building solutions on Google Cloud with three cloud computing paradigms:
    virtual machines, containers with Kubernetes, and serverless with Google Cloud
    Functions.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以Terraform的概念知识和超越主要公共云平台实现细节的架构概念为武器，探索使用三种云计算范式在Google Cloud上构建解决方案：虚拟机、使用Kubernetes的容器以及Google
    Cloud Functions的Serverless架构。
- en: 'This part has the following chapters:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 13*](B21183_13.xhtml#_idTextAnchor569), *Getting Started on Google
    Cloud – Building Solutions with GCE*'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B21183_13.xhtml#_idTextAnchor569)，*在Google Cloud上入门 – 使用GCE构建解决方案*'
- en: '[*Chapter 14*](B21183_14.xhtml#_idTextAnchor605), *Containerize on Google Cloud
    – Building Solutions with GKE*'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B21183_14.xhtml#_idTextAnchor605)，*在Google Cloud上容器化 – 使用GKE构建解决方案*'
- en: '[*Chapter 15*](B21183_15.xhtml#_idTextAnchor641), *Go Serverless on Google
    Cloud – Building Solutions with Google Cloud Functions*'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B21183_15.xhtml#_idTextAnchor641)，*在Google Cloud上使用Serverless – 使用Google
    Cloud Functions构建解决方案*'
