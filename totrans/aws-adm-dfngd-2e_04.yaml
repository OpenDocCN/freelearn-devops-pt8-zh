- en: Securing Workloads Using AWS WAF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned a lot about how to leverage Amazon Elastic
    Beanstalk as well as Amazon Elastic File System to build and deploy highly scalable
    and available applications with the utmost of ease! However, there is one critical
    aspect that we didn't talk too much about in the previous chapter, and that is,
    of course, security! "*How do I safeguard my applications and workloads against
    malicious software and threats?*" This is exactly the question we will try and
    answer through a combination of two simple, yet very powerful, AWS services, namely
    AWS Shield and AWS **Web Application Firewall**, or **WAF**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping this in mind, let''s have a quick look at the various topics that we
    will be covering in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing AWS WAF and how it works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing our WordPress site by leveraging WAF and using web ACLs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about additional WAF conditions for protection against cross-site scripting
    and SQL injections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated deployment and configuration of AWS WAF using CloudFormation templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring AWS WAF using Amazon CloudWatch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A brief introduction to AWS Shield and how it works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding AWS Shield Advanced and how to leverage it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is so much to do, so let's get started right away!
  prefs: []
  type: TYPE_NORMAL
- en: Introducing AWS Web Application Firewall
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security has always been, and always will be, a key concern for a lot of organizations
    that run their workloads and applications on the cloud. That is precisely why
    AWS offers a wide assortment of managed services that you, as a cloud administrator,
    should leverage in order to protect and safeguard your workloads from any compromises
    or threats. In this section, we are going to explore one such simple, yet really
    powerful, service, called AWS WAF, or Web Application Firewall.
  prefs: []
  type: TYPE_NORMAL
- en: AWS WAF is basically a firewall that helps you to protect your internet-facing
    applications from common web-based threats and exploits. It is basically a service
    that enables you to specify a set of web security rules or ACLs that can allow
    or restrict a certain type of web traffic across Amazon CloudFront as well as
    the **Application Load Balancer** (**ALB**). As of now, WAF can be used to create
    customized rules that can safeguard your applications against attacks, such as
    SQL injections, cross-site scripting, **Distributed Denial of Services** (**DDoS**),
    bad bots, scrapers, and much more! You can easily create new rules and attach
    them to your existing ACL list as per your requirements, enabling you to respond
    to and mitigate changing traffic patterns more rapidly.
  prefs: []
  type: TYPE_NORMAL
- en: WAF also comes equipped with a powerful API, by using which you can automate
    the deployments of ACL rules as well as manage them programmatically. Alternatively,
    for the UI people out there, WAF provides customization CloudFormation templates
    which will allow you to get started with a complete WAF-based security solution
    in less than a few minutes! We will be looking at how to deploy this template
    for securing our own WordPress application as well a bit later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: WAF is priced based on the number of ACL rules which you deploy, as well as
    on the number of web requests that your application receives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a quick summary of benefits that you can obtain by levering AWS WAF:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enhanced protection**: Apart from your standard VPC and security groups,
    you can additionally safeguard your applications against commonly occurring web
    attacks by leveraging WAF''s ACL rules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advanced traffic filtering**: Unlike your simple NACLs or security groups,
    WAFs provide you with an ability to define custom rules and conditions based on
    the characteristics of your incoming web request, such as values present in the
    headers, origin IP address of the request, whether the request has any SQL code
    present in it, and so on. Using these conditions, you now have the ability to
    basically allow, block, or filter traffic based on such preset conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy management**: With WAF rules defined and managed in one central location,
    you can easily reuse and propagate your custom ACLs across multiple CloudFront
    CDNs as well as Application Load Balancers, and monitor the traffic as well as
    mitigate any issues, all using the same WAF API or web user interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cost effective security solution**: One of the best parts of leveraging WAF
    is that there are absolutely no upfront fees or costs associated with it. You
    simply pay based on the number of rules you create using WAF as well as the amount
    of traffic your web application receives, and not a penny more!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this basic set of information, let's have a look at how WAF actually works!
  prefs: []
  type: TYPE_NORMAL
- en: Concepts and terminologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As discussed briefly, WAF can be enabled over your standard ALBs and over your
    CloudFront distributions. But before we get started with configuring WAF and its
    various rules and ACLs, we first need to understand some of its commonly used
    terms and terminologies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Conditions**: Conditions form the core of your WAF rulesets. These are basically
    configurable characteristics that you want WAF to monitor in each of your incoming
    web requests. At the time of writing this book, WAF supports the following list
    of conditions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IP match**: You can use this condition to check whether the incoming web
    request originated from a specified black/whitelisted IP addresses or not. You
    can then plot corresponding actions to be performed against the same based on
    your requirements, such as not allowing any incoming traffic other that the whitelisted
    IP range, and so on.  AWS WAF supports `/8`, `/16`, `/24`, `/32` CIDR blocks for
    an IPv4 address.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**String and regex match**: A string match or a regex match condition can be
    used to specify a part of an incoming web request and its corresponding text that
    you wish to control access to. For example, you can create a match or regex condition
    that checks the user agent headers and its value against a preset *string* or
    *expression*. If the condition matches, you can opt to either allow or block that
    particular traffic using WAF rules.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SQL injection match**: You can use this condition to inspect certain parts
    of your incoming web requests, such as the URI or query string, for any malicious
    SQL code. If a pattern matches, you can then opt to block all traffic originating
    from that particular request''s IP range.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-site scripting match**: Hackers and exploiters can often embed malicious
    scripts within web requests that can potentially harm your application. You can
    leverage the cross-site scripting match condition to inspect your incoming request
    URI or headers for any such scripts or code, and then opt to block the same using
    WAF rules.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Geographic match**: You can use this condition to list countries that your
    web request originated from and accordingly block or allow the same based on your
    requirements.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Size constraint match**: You can use the size constraint match condition
    to check the lengths of specified parts of your incoming web requests, such as
    the query string or the URI. For example, you can create a simple WAF rule to
    block all requests which have a query string greater than 100 bytes, and so on.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rules**: With your conditions defined, the next important aspect of configuring
    WAF are the rules. Rules basically allow you to combine one or more conditions
    into a logical statement, which can then be used to either allow, block, or count
    a particular incoming request. Rules are further classified into two categories:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regular rules**: Regular or standard rules, apply one or more conditions
    to your most recent batch of incoming web requests. For example, a rule to block
    all incoming traffic from the IP range `40.40.5.0/24` or if there is any SQL-like
    code in the query string of your request, and so on.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rate-based rules**: Rate-based rules are very much like your regular rules
    apart from one addition: the rate limit. You can now configure conditions and
    pass a rate limit along them as well. The rule will only trigger if the conditions
    match or exceed that particular rate limit which was set.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Rate limits are checked by WAF within a 5-minute window period.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you may configure a simple condition that blocks all incoming traffic
    from the IP range `40.40.5.0/24` with a rate limit of 10,000\. In this case, the
    rule will only trigger a corresponding action (allow, block, count) if the condition
    is met and the number of incoming requests in a 5-minute period exceed 10,000
    requests. Requests that do not meet both the conditions are simply not compared
    towards the rate limit and hence will not be blocked by this rule.
  prefs: []
  type: TYPE_NORMAL
- en: '**Web ACLs**: Once the rules are defined, you combine them into one or more
    web ACLs. Here, you have the ability to define an action for your rule if it gets
    triggered; for example, allow, block, count, or even perform a default action
    that gets triggered in case a request doesn''t match any of the conditions or
    rules specified. Web ACLs work on a priority basis, so the rule listed first is
    the one that gets compared to the incoming request first. This makes it extremely
    important to know the order in which you create and assign your rules in a web
    ACL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a simple representation of how conditions, rules, and web ACLs work
    together in WAF:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ed0bb58-5f5a-4ef5-80ca-4387460aece2.png)'
  prefs: []
  type: TYPE_IMG
- en: With the concepts out of the way, let's look at a few simple steps that allow
    you to set up and configure WAF Web ACLs for safeguarding your web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with WAF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to look at a few simple and easy-to-follow steps
    for getting started with AWS WAF. For demonstration purposes, we will be leveraging
    the same environments and application that we deployed from our previous chapter
    here, so, if you haven't gone through the use case, this might be a good time
    for a quick revisit!
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we leveraged Elastic Beanstalk as well as Elastic
    File System services to deploy a scalable and highly available WordPress application
    over the internet. In this section, we will leverage the same setup and secure
    it even further by introducing AWS WAF into it. Why use WAF for our WordPress
    application? Well, the simplest answer is to completely abstract the security
    checks from the underlying web server instance(s), and instead place the security
    checks at the point of entry of our application, as depicted in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/caa43ac4-8f03-4a43-8f5e-d8f132fc09d1.png)'
  prefs: []
  type: TYPE_IMG
- en: To get started, you will first need to ensure that your WordPress application
    has a CloudFront CDN attached to it, or alternatively an Application Load Balancer
    frontend its requests. This is a crucial step, as without a CloudFront CDN or
    an Application Load Balancer, WAF will simply not work! In my case, I have configured
    and deployed a simple CloudFront CDN for my production-grade WordPress application.
    You can refer to the following step-by-step guide for setting up your own CDN
    using CloudFront, at [http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/](http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the web ACL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you are done with your CDN, head over to the AWS Management Console and
    filter out WAF and Shield services using the dashboard, or alternatively, navigate
    to this URL [https://console.aws.amazon.com/waf/home](https://console.aws.amazon.com/waf/home)
    to bring up the WAF dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that this is the first time you are configuring WAF, you will be prompted
    by a welcome screen to either opt for AWS WAF or AWS Shield services. Select the
    Go to AWS WAF option. This will redirect you to the WAF dashboard, where we select
    the Configure web ACL option to get started.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Selecting the Configure web ACL option will bring up a Set up a web access control
    list (web ACL) wizard that will guide you through your first web ACL setup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first page on the wizard basically covers the concepts of conditions, rules,
    and ACLs, so simply select the Next option to proceed further.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Name web ACL page, provide a suitable Web ACL Name for your new ACL.
    You will notice that the CloudWatch metric name field gets correspondingly auto-populated
    with a matching name. You can change the name as per your requirements. This metric
    name will be later used to monitor our web ACLs using CloudWatch's dashboards.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Moving on, from the Region drop-down list, select either Global (CloudFront) or
    an alternative Region name, based on whether you want to secure a CDN or an Application
    Load Balancer. In my case, since I already have a CDN set up, I've opted for the
    Global (CloudFront) option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: WAF for the Application Load Balancer is currently supported only for the following
    regions: US East (N. Virginia), US West (N. California), US West (Oregon),  EU
    (Ireland), and  Asia Pacific (Tokyo).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the AWS resource to associate field, you can opt to select your CloudFront
    distribution or your Application Load Balancer using the drop-down list; however,
    for the sake of simplicity, do not configure this option for the time being. Remember,
    you can always associate your web ACLs with one or more AWS resources after completing
    this wizard! Once done, click Next to proceed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/10056b82-20c4-4f42-b737-1e5a648b0b0a.png)'
  prefs: []
  type: TYPE_IMG
- en: With the web ACL named, we move on to the next section where we can configure
    our conditions. On the Create conditions page, select an appropriate condition
    that you wish to configure for your web application. In this scenario, we will
    be configuring an IP match condition along with a string match condition. The
    idea here is to only grant access to our WordPress administrator login page (`wp-login.php`)
    from my local laptop's IP, and, conversely, for any other IP that wishes to access
    the `wp-login.php` page, the traffic should get dropped.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, conditions are configurable characteristics that you
    want WAF to monitor in each of your incoming web requests:'
  prefs: []
  type: TYPE_NORMAL
- en: To get started with a condition, select the Create condition option from the
    IP match conditions tile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, provide a suitable Name for your match condition and select the IPv4 option
    from the IP Version. Provide your desktop's or laptop's public IP in the Address field.
    You can alternatively provide a range of IP addresses here using either of the
    supported CIDR blocks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remember to select the Add IP address or range option before creating the match
    condition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0f9e052b-010e-4c08-abcb-2288ffb00b84.png)'
  prefs: []
  type: TYPE_IMG
- en: With the IP match condition created, let's move on to creating the second condition
    for our ACL as well. For this, select the Create condition option from the String
    and regex match conditions section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once again, we start by providing a suitable Name for our string match condition,
    followed by selecting the Type of string to match with. Here, select the String
    match option to begin with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, in the Part of the request to filter on section, select the appropriate
    section of your request that you wish to filter, using the match condition. In
    my case, I have selected the URI option as we need to match the resource `wp-login.php` from
    the URI. Alternatively, you can also opt to select the following values based
    on your requirements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Header`: Used to match a specific request header, such as user-agent.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTPMethod`: Used to indicate the type of operation the request intends to
    perform on the origin, such as `PUT`, `GET`, `DELETE`, and so on.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QueryString`: Used to define a query string in a URL.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Body`: Used to match the body of the request. In this case, WAF only inspects
    the first 8,192 bytes (8 KB) contained within the request''s body. You can alternatively
    set up a Size Constraint condition that blocks all requests that are greater than
    8 KB in size.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, in the Match type drop-down list, select the option Contains, as shown
    in the following screenshot. The Contains option means that the string to match
    can appear anywhere in the request. Alternatively, you can also opt to select
    from these options, based on your requirement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'ContainsWord: Used to specify a specific Value to match in the request'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exactly matches: Used to match the string and the request value exactly'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Starts with: Used to check for a matching string at the beginning of a request'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ends with: Used to check for a matching string at the end of the request'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/52df0987-8ebe-4b02-94a0-0905f6ed3b40.png)'
  prefs: []
  type: TYPE_IMG
- en: The Transformation field is handy when you need to re-format the web request
    before WAF inspects the same. This can involve Converting to lowercase, HTML decoding,
    Whitespace normalization, URL Decode, and so on. For this particular use case,
    we don't have any particular transformation to perform on the request, and hence
    I've selected the None option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, in the Value to match field, enter the text (`wp-login`) that we want
    WAF to search for in the web requests. Once completed, remember to click on the
    Add filter option before you proceed with the `Create` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this step completed, our basic conditions are in place. Alternatively,
    you can set up other relevant conditions based on your criteria and requirements.
    Once done, select the Next option to proceed with the wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With your conditions defined, we now move on to the next important aspect of
    configuring WAF: rules. Rules basically allow you to combine one or more condition,
    into a logical statement, which can then be used to either allow, block, or count
    a particular incoming request:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Create rules page, you can now merge the conditions we created a while
    back and assign each rule a corresponding action, such as allow, block, or count.
    To get started, select the Create rule option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Create rule popup, we will be creating two rules: one rule that will
    basically allow me to access the WordPress admin login page (`wp-login.php`) from
    my local laptop, and another rule that blocks traffic to the same login page.
    Let''s first create the Allow traffic rule.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To do so, type in a suitable Name for your rule. You will notice the corresponding
    CloudWatch metric name field auto-populate itself with the same name as well.
    You can choose to change this name as per your requirements, or leave it to its
    default value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, in the Rule type drop-down list, select whether you want this rule to
    be a Regular rule or a Rated rule. For this scenario, I''ve opted for the Regular
    rule, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fcd78b2e-1bf3-4202-9118-304dee3a97df.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once done, move on to the Add conditions section, where we can associate our
    rule with one or more conditions. Start by selecting the appropriate drop-down
    option to form the following rule:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what your new rule should look like once it is properly set up. Click
    on Create once completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5420d5a5-f35a-48bd-a446-9d1336c1dc26.png)'
  prefs: []
  type: TYPE_IMG
- en: With your Allow rule created, we use the same steps once again to create a Block
    rule as well. Select the Create rule option once again, and provide a suitable
    Name for your rule. Similar to the previous case, I've opted for a Regular rule here
    as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, in the Add conditions section, we first add a condition that matches
    the following statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, select the Add condition option to add the string match condition as
    well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what your rule should look like once both the conditions are added
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99faa3d2-619b-4df9-9e89-67950ab0437f.png)'
  prefs: []
  type: TYPE_IMG
- en: With the conditions in place, select the Create option to finally create your
    blocking rule.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that your two rules are created, you should see them both listed in the
    Add rules to a web ACL page, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5b32b5ad-3182-4188-be53-f0e4c75df03d.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, make sure you order your rules correctly, based on their precedence, by
    selecting the Order option as required. You can additionally configure the Default
    action for your web ACL as well. This default action will only get triggered if
    the request does not match any of the conditions mentioned in either the *allow
    or the blocking rules*. Once you are confident with your configurations, select
    the Review and create option, as shown earlier. And voila! Your basic WAF is now
    up and running!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assigning a WAF Web ACL to CloudFront distributions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the web ACL created, you can now easily assign it to one or more CloudFront
    distributions, as per your requirements. To do so, simply log in to your AWS dashboard
    and filter the CloudFront service, or alternatively, navigate to [https://console.aws.amazon.com/cloudfront/home](https://console.aws.amazon.com/cloudfront/home)
    to view the CloudFront dashboard directly:'
  prefs: []
  type: TYPE_NORMAL
- en: Once logged into the CloudFront dashboard, select the appropriate Distribution
    ID for which you wish to enable the WAF Web ACL rules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Edit option from the General tab to bring up your distribution's
    configurations and settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here, in the Edit Distribution page, select your newly created web ACL from
    the AWS WAF Web ACL drop-down list, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5b906b2d-1584-41af-b7e3-92251e32f5ff.png)'
  prefs: []
  type: TYPE_IMG
- en: Once the ACL is selected, I would also recommend that you enable the logging
    of your distribution in case you already haven't done that. This is just an added
    measure of precaution and security that is a must for any production-grade environment
    that you may be working on. Scroll down on the Edit Distribution page, and select
    the On option adjoining the Logging field. Provide your logging bucket's name
    in the Bucket for Logs field and click on the Yes, Edit option once the required
    fields are all filled in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The changes will take a good few minutes to propagate through the CloudFront
    distribution. You can then move on to testing your WAF once the distribution's
    Status has changed to Enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your WAF, simply open a browser and type in the URL of your WordPress
    application (`<http://YOUR_CLOUDFRONT_URL>/wp-login.php`) from your own laptop/desktop.
    In this case, you should be able to see the `wp-login.php` page without any issues
    whatsoever. However, if you try accessing the same page from a different laptop
    or machine, you will be thrown the following error on screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6cec3fcf-f199-42d9-9bae-941ec3a6ff30.png)'
  prefs: []
  type: TYPE_IMG
- en: At this point, your WordPress administrator login page is now protected from
    all IPs except those that you specified in your Web ACL's allow list! Amazing,
    isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: You can create a custom error page using the CloudFront distribution settings
    and redirect your users to this page rather than showing them the standard *error
    page*, as depicted in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we come towards the end of this basic web ACL configuration section.
    In the next section, we will be looking at how to enhance your basic ACL setup
    with more conditions, with more emphasis towards SQL injections and cross-site
    scripting.
  prefs: []
  type: TYPE_NORMAL
- en: Working with SQL injection and cross-site scripting conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides restricting access to a specific set of IP addresses, WAF additionally
    provides defense capabilities against more exploitative attacks, such as SQL injections
    and cross-site scripting. In this section, we will take a closer look at both
    of these conditions and how you can leverage them for protecting your own applications.
  prefs: []
  type: TYPE_NORMAL
- en: To start off, let's have a closer look at SQL injections. An SQL injection basically
    consists of the insertion of an SQL query within a request that is made from a
    client to your application.
  prefs: []
  type: TYPE_NORMAL
- en: SQL injections, if successfully implemented, can read as well as modify sensitive
    data from the database, and are even capable enough to execute administration
    operations on your database, such as restoring from a previous backed up file,
    shutting the database down completely, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a list of some common conditions and their associated configurations
    that you can choose to apply in your web ACL rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP request component to match** | **Relevant input transformations to
    apply** | **Justification** |'
  prefs: []
  type: TYPE_TB
- en: '| `QUERY_STRING` | `URL_DECODE`, `HTML_ENTITY_DECODE` | The most common component
    to match. Query string parameters are frequently used in database lookups. |'
  prefs: []
  type: TYPE_TB
- en: '| `URI` | `URL_DECODE`, `HTML_ENTITY_DECODE` | If your application is using
    friendly or clean URLs, then parameters might appear as part of the URL path segment,
    and not the query string. |'
  prefs: []
  type: TYPE_TB
- en: '| `BODY` | `URL_DECODE`, `HTML_ENTITY_DECODE` | A common component to match
    if your application accepts form input. AWS WAF only evaluates the first 8 KB
    of the body content. |'
  prefs: []
  type: TYPE_TB
- en: '| **HEADER**: **Cookie** | `URL_DECODE`, `HTML_ENTITY` | A less common component
    to match. But, if your application uses cookie-based parameters in database lookups,
    consider matching on this component as well. |'
  prefs: []
  type: TYPE_TB
- en: '| **HEADER**: **Authorization** | `URL_DECODE`, `HTML_ENTITY_DECODE _DECODE`
    | A less common component to match. But, if your application uses the value of
    this header for database validation, consider matching on this component as well.
    |'
  prefs: []
  type: TYPE_TB
- en: To configure your own SQL injection conditions and rules, log in to your WAF
    dashboard once again by navigating to [https://console.aws.amazon.com/waf/home](https://console.aws.amazon.com/waf/home).
  prefs: []
  type: TYPE_NORMAL
- en: Next, select the SQL Injection option from the navigation pane and, within that,
    select the Create condition to get started.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Create SQL injection match condition page, start off by providing a
    Name for your new condition. You can additionally select whether you want to enable
    this condition for your CloudFront CDNs (Global) or for your individual Application
    Load Balancers. In this case, I''ve opted for the Global (CloudFront) option,
    as depicted in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3ecbae94-ad63-4367-86b4-96ca15afca9c.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, in the Filter settings section, select the appropriate Part of the request
    to filter on as well as the associated Transformation section. You can refer to
    the SQL injection *common conditions* table, as discussed previously, for the
    same. Once the values are provided, click on the Add filter option to complete
    the process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, here's a really handy tip! There will definitely be cases where you will
    be writing more than one filter for your SQL injection condition based on different
    parts of the request you wish to filter, such as URI, query string, and so on.
    In such cases, it is always recommended to create multiple filters within the
    same SQL injection condition and then attach that one condition to a web ACL rule.
    The reason? A web request needs only to match one of the filters in the SQL injection
    match condition for WAF to allow or block the request based on that condition.
    On the other hand, if you add only one filter per SQL injection match condition,
    and you create more than one such SQL injection condition, the request has to
    match all the conditions in order for WAF to allow or block it.
  prefs: []
  type: TYPE_NORMAL
- en: The same can also be applied for protection against cross-site scripting or
    XSS. Cross-site scripting generally occurs when web applications include user-provided
    data in web pages that is sent to the browser without proper sanitization. If
    the data isn't properly validated or escaped, an attacker can use those vectors
    to embed scripts, inline frames, or other objects into the rendered page. These,
    in turn, can be used for a variety of malicious purposes, including stealing user
    credentials by using keyloggers, installing system malware, and much more. The
    impact of the attack is magnified if that user data persists on the server side
    in a data store and is then delivered to a larger set of users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a list of some common conditions and their associated configurations
    that you can choose to apply in your web ACL rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP request component to match** | **Relevant input transformations to
    apply** | **Justification** |'
  prefs: []
  type: TYPE_TB
- en: '| `BODY` | `URL_DECODE`, `HTML_ENTITY_DECODE` | A very common component to
    match if your application accepts form input. AWS WAF only evaluates the first
    8 KB of the body content. |'
  prefs: []
  type: TYPE_TB
- en: '| `QUERY_STRING` | `URL_DECODE`, `HTML_ENTITY_DECODE` | Recommended if query
    string parameters are reflected back into the web page. An example is the current
    page number in a paginated list. |'
  prefs: []
  type: TYPE_TB
- en: '| **HEADER**: **Cookie** | `URL_DECODE`, `HTML_ENTITY_DECODE` | A common component
    to match if your application accepts form input. Recommended if your application
    uses cookie-based parameters that are reflected back on the web page. For example,
    the name of the user who is currently logged in is stored in a cookie and embedded
    in the page header. WAF only evaluates the first 8 KB of the body content. |'
  prefs: []
  type: TYPE_TB
- en: '| `URI` | `URL_DECODE`, `HTML_ENTITY_DECODE` | Less common, but if your application
    is using friendly URLs, then parameters might appear as part of the URL path segment,
    not the query string (they are later rewritten server side). There are similar
    concerns as with query strings. |'
  prefs: []
  type: TYPE_TB
- en: To configure your own cross-site scripting conditions and rules, log in to your
    WAF dashboard once again by visiting [https://console.aws.amazon.com/waf/home](https://console.aws.amazon.com/waf/home).
  prefs: []
  type: TYPE_NORMAL
- en: Next, select the Cross-site scripting option from the navigation pane and, within
    that, select the Create condition to get started.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Create cross-site scripting match condition page, start off by providing
    a Name for your new condition. You can additionally select whether you want to
    enable this condition for your CloudFront CDNs (Global) or for your individual
    Application Load Balancers. In this case, I've opted for the Global (CloudFront) option
    for now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, from the Part of the request to filter on section, select the part of
    the request you wish WAF to filter on. You can choose between Header, HTTP method,
    Query string, URI, and Body as valid parameters. Note, however, that by selecting
    the Header option, you will be provided with an additional field in which you
    can either select the header from a list of headers or, alternatively, type in
    the name of the header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, select the appropriate Transformation operation you wish WAF to perform
    over the request before it is actually inspected. Once done, remember to select
    the Add filter option before completing the condition's creation process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You now have two additional conditions that you can add to your existing web
    ACL, or even, go ahead and create a new web ACL. In this way, you can create different
    filters and conditions based on your requirements and keep attaching them to your
    web ACL as and when required. But this manual way of setting up rules and conditions
    can get a bit tricky after some time, especially when you don't have a dedicated
    security team and need to deploy the ACLs a lot faster into your environment.
    That's precisely what we are going to cover in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Automating WAF Web ACL deployments using CloudFormation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with web ACLs can be really difficult at times, especially when you
    have a large, distributed environment and don't necessarily have a dedicated security
    team to create and manage the rules on a regular basis. Luckily for us, AWS makes
    things far simpler by providing easy to use and customize CloudFormation templates
    that can spin up a single web ACL, with all the basic security conditions configured,
    in a mere matter of minutes! The collective solution is called AWS WAF Security
    Automations, and, is available free of charge for all to use. All the end user
    has to do is specify which security feature is required, configure that, and deploy
    the solution! The rest is completely taken care of by AWS itself!
  prefs: []
  type: TYPE_NORMAL
- en: The architecture of the AWS WAF Security Automation solution is relatively simple,
    and comprises of a few more AWS services than AWS WAF, such as AWS Lambda, Amazon
    CloudWatch, Amazon API Gateway, and Amazon S3, as depicted in the diagram later
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the core of the solution is the WAF service that acts as the central point
    for making all security-related decisions and filtering. Based on the inputs specified
    by the user during the CloudFormation template''s configuration, the respective
    solution components get activated accordingly. These components are further explained
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Honeypot for bad bots and scraper protection (A)**: This security component
    automatically sets up a *honeypot* to lure and deflect a possible attack on your
    application. The solution provides you with an API Gateway endpoint that you need
    to insert into your web application as a trap to detect and lure inbound requests
    from various bots and scrapers. If a source accesses the trap request, an associated
    Lambda function intercepts that request, gathers its source IP address, and adds
    the same to the WAF''s web ACL block list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SQL injection protection (B) and cross-site scripting protection (C)**: Selecting
    this solution enables the creation of two AWS WAF rules that provide protection
    against commonly occurring SQL injection or cross-site scripting patterns:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/f2e94078-3e32-4445-a4a8-9e5a71901a81.png)'
  prefs: []
  type: TYPE_IMG
- en: '**HTTP flood, scanner and probe protection (D)**: Also called **log parsing
    protection**, this solution comes in handy when you want to analyze your web application''s
    access logs for any abnormalities that can cause a potential threat. This is performed
    by a dedicated AWS Lambda function that does the parsing of the access logs which
    get stored in a S3 bucket created by the CloudFormation template itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IP address whitelist/blacklist (E)**: Similar to the SQL injection and cross-site
    scripting solution, WAF creates two rules to allow you to manually enter IP addresses
    that you wish to either allow or block to your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Known-attacker protection (F)**: This solution also leverages a simple Lambda
    function that monitors certain third-party sites for a list of potential IP addresses
    to block against threats. The sites include *Spamhaus* ([https://www.spamhaus.org/drop/](https://www.spamhaus.org/drop/)),
    *Proofpoint* ([https://rules.emergingthreats.net/fwrules/emerging-Block-IPs.txt](https://rules.emergingthreats.net/fwrules/emerging-Block-IPs.txt)),
    and *TOR* ([https://check.torproject.org/exit-addresses](https://check.torproject.org/exit-addresses)),
    to name a few.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With these basics in mind, let''s quickly move on to deploying these solutions
    using the CloudFormation templates. At the time of writing this book, AWS WAF
    Security Automations provides two templates for use: one intended for the CloudFront
    CDN based deployments and the other for the Application Load Balancer. Both of
    the templates provide a default configuration that consists of a web ACL with
    eight pre-configured sets of rules that you can always change or extend as required.
    The following are the links to download the respective templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CloudFront CDN-based template**: [https://s3.amazonaws.com/solutions-reference/aws-waf-security-automations/latest/aws-waf-security-automations.template](https://s3.amazonaws.com/solutions-reference/aws-waf-security-automations/latest/aws-waf-security-automations.template)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application Load Balancer-based template**: [https://s3.amazonaws.com/solutions-reference/aws-waf-security-automations/latest/aws-waf-security-automations-alb.template](https://s3.amazonaws.com/solutions-reference/aws-waf-security-automations/latest/aws-waf-security-automations-alb.template)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can alternatively copy the links and deploy the stacks in CloudFormation.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the correct template downloaded, we can now move on to configuring and
    deploying the solution using CloudFormation:'
  prefs: []
  type: TYPE_NORMAL
- en: To do so, first log in to your CloudFormation dashboard by navigating to [https://console.aws.amazon.com/cloudformation/home](https://console.aws.amazon.com/cloudformation/home).
    Note that in this case, we will be deploying the CloudFront CDN-based template
    in the **N.Virginia** region.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the CloudFormation dashboard, select the option Create new stack to get
    started. Here, in the Select Template page, you can either choose to *upload* your
    downloaded template, or simply copy the template''s URL in the Specify an Amazon
    S3 template URL field, as shown in the following screenshot. Click on Next to
    continue with the setup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c291da88-0b7e-42e9-a831-1fabbb2a0816.png)'
  prefs: []
  type: TYPE_IMG
- en: In the Specify Details page, you can start off by providing a suitable Stack
    name for your CloudFormation stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, in the Parameters section, select the Protection services that you wish
    to opt for. Remember, these are the same services that we discussed at the beginning
    of this section. In this case, I've opted for a rather simple setup that involves
    activating protection against SQL injection, cross-site scripting, and bad bots.
    You can alternatively select your own protection services, as required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Moving on, in the CloudFront Access Log Bucket Name field, provide a unique
    name for the S3 bucket that will store your Amazon CloudFront's access logs. You
    can either provide the name of an existing bucket or a new one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, in the Advanced Settings section, you can additionally opt to modify
    a few parameters, such as Request Threshold, Error Threshold, and the WAF Block
    Period, as per your requirements. These parameters would come in handy especially
    if you select the HTTP Flood Protection or the Activate Scanners & Probes Protection,
    otherwise, you can leave these values to their defaults, as I have done in my
    case. Select Next to continue with the deployment process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Options page, you can specify Tags for the resources that will be created
    by the CloudFormation template, as well as opt to provide any special *IAM Role* to
    allow CloudFormation to create, modify, or delete the resources in the stack.
    Click on Next to review the changes made and, finally, go ahead with the stack's
    creation by selecting the Create option on the Review page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The stack takes a good few minutes to deploy successfully. Once done, you can
    verify the status of your stack''s completion by checking the Status column, as
    depicted in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1cb087cd-d113-430e-82b3-a96440b2ea05.png)'
  prefs: []
  type: TYPE_IMG
- en: Additionally, based on your Protection service selection, you can also verify
    the additional outputs created by the template for your application, such as the
    Honeypot Endpoint, that's actually an Amazon API Gateway endpoint that you need
    to insert somewhere in your application to capture bots and scrapers. In my case,
    the template created a Lambda function for bad bots scraping, WAF rules for SQL
    injections, IP whitelisting, and XSS detection, along with an API Gateway as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the stack up and running, you can additionally go back to the WAF dashboard
    and check out the individual rules that the template auto-populated against some
    of the protection services. In this case, the *SQL injection* and c*ross-site
    scripting* conditions were auto-populated; however, the *IP Whitelist* and *Bad
    Bot* rules still require you to manually provide the IP ranges and addresses to
    start off with, or allow the Lambda function to inject the IP addresses into the
    lists at runtime as well. Here is a snapshot of the list of rules created for
    the SQL injection condition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1b6b9c51-d01a-40ce-9bd2-107e28a9e293.png)'
  prefs: []
  type: TYPE_IMG
- en: With this we come to the end of this particular section. You can additionally
    use these templates to spin up newer web ACLs for your Application Load Balancers.
    Just remember to delete your stack once your testing is completed, to avoid incurring
    any unnecessary charges. In the next section, we will be briefly looking at how
    to effectively monitor your WAF rules using a few essential monitoring tools provided
    by AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring WAF using CloudWatch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Monitoring of your WAF rules, conditions, as well as your application''s web
    traffic, plays an important part towards identifying and mitigating possible attacks
    and exploits. AWS provides a wide assortment of tools and services that you, as
    an administrator, can leverage for the monitoring and reporting of such activities.
    The following are the list of services briefly explained:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AWS WAF dashboard**: Yes, you read it right! AWS WAF also provides a simple
    monitoring dashboard that lists the total requests made to your application via
    either the CloudFront CDN or the Application Load Balancer, as well as the number
    of requests that actually match to your specified rules. To view the dashboard,
    all you need to do is log in to your AWS WAF, select the Web ACLs page, and click
    on the Requests tab, as shown in the following screenshot:![](img/85e92692-509d-46b5-893f-de84f26e7367.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The graph aggregates and displays the requests on a five-minute period basis.
    You can alternatively open the same graph using Amazon CloudWatch for further
    analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '**Amazon CloudWatch**: Amazon CloudWatch has been around for some time, and
    definitely provides various metrics that you can select and configure as a part
    of a customized requests monitoring dashboard. Here is a list of the supported
    WAF metrics, with a brief description:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AllowedRequests`: Captures the number of allowed web requests. The valid dimensions
    for this metric are Rule and WebACL.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BlockedRequests`: Captures the number of blocked web requests. The valid dimensions
    for this metric are Rule and WebACL.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CountedRequests`: Typically used to test your web ACLs and rules, this metric
    provides a count of the web requests that match all of the conditions in a particular
    rule.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use these metrics to monitor your WAF rules, and even configure CloudWatch
    alarms to trigger and send notifications in case their threshold values are crossed.
    Based on your requirements, you can additionally take things a step further and
    configure CloudWatch events that trigger an appropriate Lambda function to mitigate
    against a possible attack, as we performed during the Security Automations solutions.
    You can even leverage Amazon CloudWatch to monitor the traffic flowing into the
    CloudFront CDNs as well as your Application Load Balancers.
  prefs: []
  type: TYPE_NORMAL
- en: '**AWS****CloudTrail**: AWS CloudTrail is yet another service that you can and
    should leverage for parsing and analyzing your application''s access and error
    logs, as well as logs generated by the AWS services'' logs themselves. Here is
    a sample of few Log Groups, created automatically by the Security Automations
    Solution, for capturing WAF traffic flow and events. We will be exploring more
    on AWS CloudTrail in the next chapter:![](img/428e3d3f-8e7c-4bfa-8f83-7ea9382cb4e0.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this, we come towards the end of yet another chapter, but before we sign
    off, here's some interesting things that I feel you ought to try out as a part
    of AWS WAF.
  prefs: []
  type: TYPE_NORMAL
- en: Planning your next steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, we have covered a lot of new features and services in this chapter. However,
    there are still a few things that I recommend you need to read up on on your own.
    First up is the AWS Shield service!
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to AWS Shield
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'AWS Shield is an extension of AWS WAF, but is targeted to provide security
    around potential DDoS attacks. It is a fully managed service that provides Always-on detection
    and automatic mitigations that minimize application downtime and latency. AWS
    Shield provides two tiers of services: **Standard** and **Advanced**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AWS Shield Standard**: Provided at no additional costs, this service is enabled
    on your account and AWS services by default, and is designed to protect your web
    applications against the most common and frequently occurring DDoS attacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS Shield Advanced**: Designed for providing a higher level of protection
    for your web applications, AWS Shield Advanced is intended to work with applications
    that are currently running on Elastic or Application Load Balancers, Amazon CloudFront,
    and Amazon Route 53 resources. AWS Shield Advanced also provides near real-time
    visibility into potential attacks, along with mitigation capabilities as well.
    To top it all, you also get access to a dedicated 24x7 **DDoS Response Team**
    (**DRT**) that looks into potential DDoS attacks occurring on your web application,
    and provides quick resolutions against the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS Shield Advanced is priced at $ 3,000 per month.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a brief comparison between the various services offered by AWS Shield
    Standard and Advanced tiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Features** | **AWS Shield Standard** | **AWS Shield Advanced** |'
  prefs: []
  type: TYPE_TB
- en: '| Network flow monitoring | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Automated application (layer 7) traffic monitoring | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Helps protect from common DDoS attacks, such as SYN floods and UDP reflection
    attacks | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Access to additional DDoS mitigation capacity | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Layer 3/4 attack notification and attack forensic and history reports | No
    | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Incident management during high-severity events | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Custom mitigations during attacks | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Post-attack analysis | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Reimburse related Route 53, CloudFront, and ELB DDoS charges | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: To activate AWS Shield Advanced for your environments, simply log in to your
    AWS WAF dashboard and select the Protected resources option present under the
    AWS Shield section in the navigation pane. Here, click on the Activate AWS Shield
    Advanced button to start your Shield Advanced protection plan. Here, you will
    be asked to select a particular Resource to protect against DDoS attacks. Select
    your CloudFront CDN or the Elastic/Application Load Balancer, based on the resource
    you wish to protect, and provide a suitable Name for the resources that you are
    specifying for protection. Finally, remember to select the Enable checkbox to
    associate your resources with a web ACL, if you have one created already. Once
    done, select the Add DDoS protection option, and voila! You are up and running
    with AWS Shield Advanced! Simple isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here's a quick round up of the topics that we have covered so far in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We started off by learning and understanding a bit about the Web Application
    Firewall service and how it works to protect against potential security threats
    and exploits. We later looked at how to get started with WAF by safeguarding our
    previously deployed WordPress application against restrictive access by leveraging
    the IP Match, as well as the string/regex match conditions. We also looked at
    how to mitigate and safeguard your applications by leveraging advanced WAF conditions
    in the form of SQL injection and cross-site scripting. Towards the end, we covered
    how to leverage certain pre-built CloudFormation templates to automate the deployments
    of our WAF rules and, finally, we concluded the chapter with a brief introduction
    to AWS Shield and its various tiers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will be continuing on our security journey and will
    cover two really amazing services as well: AWS CloudTrail and AWS Config, so stay
    tuned!'
  prefs: []
  type: TYPE_NORMAL
