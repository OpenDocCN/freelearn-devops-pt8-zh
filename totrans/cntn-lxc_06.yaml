- en: Chapter 6. Clustering and Horizontal Scaling with LXC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running applications inside LXC containers provides for a convenient way of
    allocating and limiting resources, as we saw in earlier chapters. LXC is also
    great for creating clusters of applications, for example, a web-server farm that
    can be scaled horizontally or vertically.
  prefs: []
  type: TYPE_NORMAL
- en: Horizontal scaling is a way of adding more computing power to a cluster or a
    group of resources performing a common task. This is usually accomplished by adding
    more servers, virtual machines, or in the case of LXC, more containers to run
    the applications. In contrast, vertical scaling is done by adding more hardware
    or virtual resources, such as CPU and memory, to physical servers, VMs, or containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to put all the knowledge you''ve gained so far
    toward do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple Apache cluster, running LXC on a minimal root filesystem with
    libvirt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a multinode web cluster with Apache and HAProxy using Open vSwitch
    and a mesh of GRE tunnels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Demonstrating how to add more containers by reusing the filesystem of existing
    LXC instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling applications with LXC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LXC is pretty well-suited for virtual machine replacement in sense that it can
    contain a complete root filesystem for a Linux distribution, in which case, the
    only shared component with the host OS is the kernel. Applications can be installed
    in the container's root filesystem so that the host or other containers cannot
    share them. This isolation is useful if we want to run different versions of the
    same application and its dependencies, or different Linux distributions altogether.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, libvirt LXC allows for the execution of a single process
    or a group of processes from a binary which is shared from the host OS by all
    containers. In this case, the containers share the host filesystem and only abstract
    certain directories. This helps in scenarios where the application might not need
    its own dedicated filesystem, if, for example, the Linux distribution in the container
    is the same as the host OS. Scaling such applications is a matter of ensuring
    that the service is installed on the host and the necessary config files are present
    on the minimal root filesystem in the container. We can then make a copy of the
    container's configuration file and the minimal root filesystem, and start it without
    many changes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next two sections, we'll explore both scenarios. We'll start by building
    minimal root filesystem Apache containers with libvirt and load balancing them
    with HAProxy, and then move on to build an Apache cluster with LXC, and dedicated
    filesystems and network isolation with Open vSwitch with a mesh of GRE tunnels.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling Apache in minimal root filesystem with libvirt LXC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we'll demonstrate how to run multiple Apache servers on the
    same host using libvirt LXC and a minimal root filesystem for each container.
    The Apache binary and libraries will be shared among containers. Even though this
    approach may not be most suitable for Apache, but rather simpler single-threaded
    processes, it will help us demonstrate this concept in a more practical manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we''ll use Ubuntu, but the same instructions apply to CentOS,
    as we demonstrated in [Chapter 2](ch02.html "Chapter 2. Installing and Running
    LXC on Linux Systems"), *Installing and Running LXC on Linux Systems*. Following
    are the steps for the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by updating the OS and ensure it''s running the latest kernel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The latest libvirt package on Ubuntu Xenial as of this writing is shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, install the libvirt packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Conveniently, libvirt created the bridge for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll be using the `default` libvirt network; let''s ensure it is present:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To examine the `default` network and gateway that libvirt will use, run the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The libvirt toolkit also started `dnsmasq`, which will assign the network settings
    to the LXC containers if we configure them to use DHCP:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll be using the default `dnsmasq` config, but let''s ensure the DHCP range
    matches what `libvirt-net` knows from the preceding output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creating the minimal root filesystem for the containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this example, we are not going to use the provided templates or use the
    `debootstrap` command to build a full-fledged filesystem for the container, but
    instead create a minimal directory structure to host the configuring files for
    Apache and the container. The rest will be in the same `mount` namespace as the
    host OS, with the exception of a few directories that we are going to bind to
    the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create the minimal root filesystem for the containers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating the directories; copy the necessary files and install
    Apache on the host:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create the `index.html` page for Apache and configure the web server
    with its own unique PID file, which will later allow us to start multiple Apache
    processes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure the network interfaces file to use DHCP, so we can leverage the `dnsmasq`
    server that `libvirtd` started earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Defining the Apache libvirt container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to build LXC containers with libvirt, we need to create the configuration
    file that contains the attributes of the containers. With the directory structure
    in place from the previous steps and Apache installed on the host, we can define
    the configuration file of the containers. We already saw a similar config when
    we talked about libvirt in [Chapter 3](ch03.html "Chapter 3. Command-Line Operations
    Using Native and Libvirt Tools"), *Command-Line Operations Using Native and Libvirt
    Tools*. To view the configuration, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'What is new in the preceding configuration is that, instead of specifying `/sbin/init`
    as the type of init system, we configure libvirt to use a custom script—`startup.sh`.
    The script can be anything we like; in this case, it will start the networking
    in the container, configure the shell, execute `dhclient` to obtain the network
    settings from `dnsmasq`, and then start Apache and bash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, make the script executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The root directory of the container should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Only two directories are present! We are now ready to define the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Starting the Apache libvirt container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With all the necessary components in place, let''s start the container and
    confirm that it''s running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When listing the processes on the host, notice how the container was started
    from the `libvirt_lxc` script, which is the parent process of the `startup.sh`
    script, which in turn launched Apache.
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect to the container and ensure it was able to obtain an IP address and
    default gateway from `dnsmasq`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s connect to Apache from the host OS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `192.168.122.70` IP address is what `dnsmasq` assigned to the container;
    you might need to replace it with whatever is the correct address on your system.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling Apache with libvirt LXC and HAProxy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For scaling Apache with libvirt LXC and HAProxy, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With one Apache container running, let''s quickly create a second one by copying
    the simple directory structure and libvirt config from the `http1` container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'All we need to change is the name of the container, the PID file for Apache,
    and its index file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the new container and examine the directory structure that contains
    the root filesystem and the configuration files for both containers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s start the new container and ensure both instances are running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To obtain more information about the Apache containers, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The `dominfo` output provides useful information about the container's memory
    and CPU utilization, which we can use for monitoring, alerting, and autoscaling,
    as we'll see in [Chapter 7](ch07.html "Chapter 7. Monitoring and Backups in a
    Containerized World"), *Monitoring and Backups in a Containerized World.* Note
    that the `OS Type` is set to `exe`, because the container's init system is a script.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s test connectivity to Apache in the new container; replace the IP of
    the instance as necessary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Both Apache processes are accessible from the host OS because of the common
    bridge they are all connected to. In order to access them from outside the host
    OS, we can install HAProxy on the server, with the IP addresses of the containers
    as its backend servers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The IP addresses specified in the server lines of the `backend` section of the
    HAProxy config are those of the libvirt LXC containers. Update the files as needed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the `frontend` section of the config, we tell HAProxy to listen on port `80`
    and bind to all interfaces. In the `backend` section, we specify the IPs of both
    LXC containers. You might need to replace the IPs of the containers with those
    that `dnsmasq` provided on your system.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Restart HAProxy, since on Ubuntu, it starts automatically after package installation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, ensure HAProxy is running and listening on port `80` on the host:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We configured HAProxy to use round robin for selecting backend nodes; let''s
    connect to it a few times and confirm we connected to Apache in each LXC container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can stop one of the containers and ensure HAproxy will remove it
    from rotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Apache might not be the best application to run in multiple containers on the
    same host. Nevertheless, it helps to demonstrate how easy it is to scale applications
    running in minimal LXC containers with libvirt LXC, behind a proxy, or how to
    build a multitenant environment. The added benefit in using shared binaries from
    all containers is that upgrading them will not require changes in each LXC instance,
    but rather changes on the host OS that will be visible from all containers on
    that server. The preceding setup might seem simple, but it provides a powerful
    way to scale services in lightweight LXC containers that will not require much
    disk space.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling Apache with a full LXC root filesystem and OVS GRE tunnels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Running multiple containers on the same host with a minimal filesystem for
    each is great in some scenarios, but let''s focus on a more complex multiserver
    deployment example next. The following diagram shows the deployment we are going
    to build in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scaling Apache with a full LXC root filesystem and OVS GRE tunnels](img/image_06_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Multiserver LXC deployment with LXC and GRE tunnels
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use three servers—`lxc-lb`, `lxc-node-01`, and `lxc-node-02`.
    Each one will have LXC and OVS installed. The `lxc-lb` host will host a container
    running HAProxy, and later, HAProxy on the server itself. The `lxc-node-01` and
    `lxc-node-02` servers will have containers running Apache. All LXC instances will
    communicate on a dedicated private network through a mesh of GRE tunnels connected
    to OVS. The OVS GRE mesh will create network isolation between the containers
    and the hosts, and potentially other containers and their networks. All containers
    will obtain their network configurations from `dnsmasq` running on the `lxc-lb`
    host.
  prefs: []
  type: TYPE_NORMAL
- en: For this deployment, we'll use three EC2 instances from AWS, running the latest
    Ubuntu Xenial release.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the load-balancer host
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To configure the load balancer host, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `lxc-lb` server. Examine what LXC versions are available
    and install the latest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After installing the LXC packages and templates, we ended up with the Linux
    bridge as well, however, we are not going to use it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, install OVS and create a new bridge named `lxcovsbr0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The default LXC network uses the `10.0.3.0/24` subnet; we are going to replace
    it with `192.168.0.0/24`. This helps in cases where there''s already an existing
    LXC network, and we would like to start a new one and isolate certain sets of
    containers, and also help demonstrate the concept:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the name of the default Linux bridge with the OVS bridge we just created,
    and change the network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `dnsmasq` service is configured for the `10.0.3.0/24` network, but after
    a restart, it should listen on the new subnet we specified earlier. Let''s reboot
    the server to ensure the changes will persist:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As expected, `dnsmasq` will now offer IPs from the `192.168.0.0/24` subnet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Examine the OVS bridge; it should be up and configured with an IP:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creating the load-balancer container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create the load-balancer container, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use the Ubuntu template to create the root filesystem of the
    HAProxy container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The OVS bridge should now have the containers interfaces added as a port—the
    `vethUY97FY`, in this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Attach to the new container and make sure it received an IP address from the
    DHCP server running on the same host:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The container should have connectivity to the host and the Internet. Let''s
    test that before moving on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If connectivity is not working, make sure the `dnsmasq` server properly assigned
    an IP address and that the container is connected to the OVS bridge, and the bridge
    interface is up with an IP address itself.
  prefs: []
  type: TYPE_NORMAL
- en: Building the GRE tunnels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Generic Routing Encapsulation** (**GRE**) is a tunneling protocol that allows
    for building virtual point-to-point networks over the **Internet Protocol** (**IP**).
    We can use it to create a network mesh between the OVS switches on the three hosts,
    thus connecting the LXC containers to an isolated network. Each server (or EC2
    instance in this example) will connect to each other. The OVS provides a convenient
    way for establishing the GRE tunnels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While still on the load-balancer host, create two GRE tunnels to the other
    two servers, replacing the IPs as necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that preceding IP addresses are those of the actual servers, not the
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing all ports on the bridge will now show the GRE ports as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are creating a network mesh between OVS, packet loops may occur. To
    prevent topology loops, we need to enable the **Spanning Tree Protocol** (**STP**)
    on OVS. STP is a layer-2 protocol that prevents network loops when creating redundant
    and interconnected links between switches. To enable it on the OVS switch, execute
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: With all of the preceding steps completed, the first host is now configured.
    In the next section, we are going to configure the rest of the servers in a similar
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Apache nodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To configure the Apache nodes, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the first Apache node, install LXC and OVS, and create the bridge:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the name of the bridge and change the subnet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the GRE tunnels to the other two servers, replacing the IPs as needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enable STP on the bridge:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s create an Ubuntu container named `apache`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Time to configure the last node in a similar fashion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the GRE tunnels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, enable STP on the switch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, create and start the Apache container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Installing Apache and HAProxy, and testing connectivity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With all the servers configured, the containers started, and the GRE tunnels
    established, let's test the connectivity between each LXC instance. Since all
    containers are part of the same network, connected to each other through the OVS
    switches with the GRE tunnels, they should be able to communicate with each other.
    Most importantly, the Apache containers will obtain their network configuration
    through DHCP from the `dnsmasq` service running on the `lxc-lb` server.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that each container received a lease, we can examine the `dnsmasq`
    lease file by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting a lease might take a few seconds; you might need to check the file
    a few times before any IP is recorded. Once all containers have IPs, we should
    be able to see them when listing the containers on each server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s install HAProxy in the `haproxy` container on the node `lxc-lb`
    server and test connectivity between containers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are building this example deployment on a cloud provider and `apt-get
    update` hangs, try reducing the MTU setting of the `eth0` interface inside the
    LXC containers as follows: `ifconfig eth0 mtu 1400`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s view the `haproxy.cfg` configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The HAProxy configuration is almost identical to the one we used earlier in
    this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the IP addresses in the `backend` section of the HAProxy configuration
    file are those of the Apache containers running on the `lxc-node-01/02` servers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Restart HAProxy and ensure it''s running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice, from the preceding output how, unlike the previous example with libvirt
    LXC we saw earlier in the chapter, the init process is the parent process in the
    container now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Install Apache in the other two containers and create an `index.html` page
    for each:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From within the `haproxy` container, connect to port `80` that HAProxy is listening
    on, and the load balancer should forward the requests to the Apache containers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should be able to connect to HAProxy from the `lxc-lb` host as well, since
    the host OS can talk to the containers through the OVS switch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding `192.168.0.26` address is the IP of the `haproxy` container; replace
    it with whatever `dnsmasq` assigned on your system.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we can install HAProxy on the `lxc-lb` server itself, which will allow
    us to connect to the Apache servers from the outside world, if, for example, the
    `lxc-lb` host has a public IP. In this case, we don''t have to run HAProxy in
    the container at all, though we can reuse the same config:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Copy the config from the container (listed earlier in this section) and restart
    HAProxy:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the `10.1.34.23` IP address is the address of the `lxc-lb` server
    in this example. If your server has more than one IP address or a public one,
    you can use any of them, since we configured HAProxy to bind to all interfaces.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With this, we have a simple setup that can be used in production to create highly
    available services and scale them horizontally by adding more servers and containers,
    behind a load balancer such as HAProxy or Nginx.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling the Apache service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Setups such as the preceding ones can be fully automated by creating snapshots
    of the container's filesystem and configuration files, with the services already
    installed; then use those copies to start new containers on demand.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how to manually scale Apache by adding more containers, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, stop one of the Apache instances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, copy its root filesystem and the LXC configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the name of the new container and remove the MAC address from the configuration
    file. LXC will dynamically assign a new one when the container starts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now have two containers on the host:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s start them both:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we copied the entire root filesystem from the original container, the
    Apache service is already installed in the new instance. Now, start it and ensure
    it''s running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A similar process to this can be fully automated with services such as Jenkins
    and distributed between different servers to achieve a level of service autoscaling.
    We'll explore this setup in further detail in [Chapter 7](ch07.html "Chapter 7. Monitoring
    and Backups in a Containerized World"), *Monitoring and Backups in a Containerized
    World*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using LXC to scale various workloads requires a proxy service such as HAProxy
    or Nginx, and the actual service running in containers. Network connectivity and
    segmentation can be achieved using software-defined networks with OVS and GRE
    tunnels.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we looked at how to run Apache in simple libvirt-based LXC
    containers that do not require an entire root filesystem, but rather a minimal
    set of directories with the shared binaries and libraries from the host OS. We
    also created an Apache cluster behind a load balancer on multiple servers, and
    demonstrated a simple yet effective way of scaling it by duplicating an LXC container.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll build on what you've learned so far, show how to
    monitor and back up LXC, and create an autoscaling service with Jenkins and Sensu.
  prefs: []
  type: TYPE_NORMAL
