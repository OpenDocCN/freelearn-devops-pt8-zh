<html><head></head><body>
  <div id="_idContainer195">
   <h1 class="chapter-number" id="_idParaDest-159">
    <a id="_idTextAnchor204">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     9
    </span>
   </h1>
   <h1 id="_idParaDest-160">
    <a id="_idTextAnchor205">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Benchmarking the Infrastructure – Evaluating Resource Capacity and Optimization
    </span>
   </h1>
   <p class="author-quote">
    <span class="koboSpan" id="kobo.3.1">
     “Save for a rainy day.”
    </span>
   </p>
   <p class="author-quote">
    <span class="koboSpan" id="kobo.4.1">
     – Aesop
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     One of the major challenges when operating a growing infrastructure is keeping different services up and running within the expected defined
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.6.1">
      Service Level Agreements
     </span>
    </strong>
    <span class="koboSpan" id="kobo.7.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.8.1">
      SLAs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.9.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.9.2">
     During the course
    </span>
    <a id="_idIndexMarker835">
    </a>
    <span class="koboSpan" id="kobo.10.1">
     of production, unexpected issues might arise, even though a proper monitoring solution has been put in place to act proactively when certain situations are detected, such as scaling cluster nodes up and down to accommodate more tenant workloads.
    </span>
    <span class="koboSpan" id="kobo.10.2">
     In a complex environment such as OpenStack, hitting system performance limits is considered a common issue due to its distributed and loose architecture.
    </span>
    <span class="koboSpan" id="kobo.10.3">
     The more services join the ecosystem, the more performance issues will be raised.
    </span>
    <span class="koboSpan" id="kobo.10.4">
     You might have a monitoring dashboard where all services are showing green but cloud tenant users are facing issues with spawning a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.11.1">
      Virtual Machine
     </span>
    </strong>
    <span class="koboSpan" id="kobo.12.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.13.1">
      VM
     </span>
    </strong>
    <span class="koboSpan" id="kobo.14.1">
     ) after several failed requests.
    </span>
    <span class="koboSpan" id="kobo.14.2">
     Logging, as we covered in the
    </span>
    <a id="_idIndexMarker836">
    </a>
    <span class="koboSpan" id="kobo.15.1">
     previous chapter, could help with deep diving into the root cause but not with tracing such reluctant events leading to user frustration due to undetected performance issues.
    </span>
    <span class="koboSpan" id="kobo.15.2">
     For this reason, a best practice is to keep profiling the cloud environment in each minor or major ecosystem.
    </span>
    <span class="koboSpan" id="kobo.15.3">
     One of the most highly recommended approaches is to include a benchmarking stage in your CI/CD pipeline for each change.
    </span>
    <span class="koboSpan" id="kobo.15.4">
     Another way is to conduct a profiler cycle on each OpenStack environment software or hardware update and collect performance metrics to compare to the existing SLA.
    </span>
    <span class="koboSpan" id="kobo.15.5">
     The OpenStack cloud environment does not come with infinite resources, and knowing your limits in advance is essential before making business and operational decisions to extend your service catalogs to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.16.1">
      cloud users.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.17.1">
     In this chapter, we will go through different options for running benchmarking exercises in OpenStack, detecting potential bottlenecks, and working on recommendations to avoid performance issues in production.
    </span>
    <span class="koboSpan" id="kobo.17.2">
     The following topics will
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.18.1">
      be covered:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.19.1">
      Improve database performance in OpenStack
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.20.1">
       using caching
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.21.1">
      Benchmark OpenStack and identify the source of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.22.1">
       performance bottlenecks
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.23.1">
      Optimize our cloud control and data plane
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.24.1">
       using Watcher
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.25.1">
      Learn how to trace requests traveling across OpenStack services to identify bottlenecks and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.26.1">
       improve performance
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-161">
    <a id="_idTextAnchor206">
    </a>
    <span class="koboSpan" id="kobo.27.1">
     Empowering the database
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.28.1">
     Databases in OpenStack are considered one of the
    </span>
    <a id="_idIndexMarker837">
    </a>
    <span class="koboSpan" id="kobo.29.1">
     most critical shared infrastructure services that require additional attention.
    </span>
    <span class="koboSpan" id="kobo.29.2">
     From a high-availability perspective, a multi-master cluster
    </span>
    <a id="_idIndexMarker838">
    </a>
    <span class="koboSpan" id="kobo.30.1">
     based on
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.31.1">
      Galera MariaDB
     </span>
    </strong>
    <span class="koboSpan" id="kobo.32.1">
     would satisfy the requirement for a resilient database setup would does not fully guarantee high-performing write or read transactions.
    </span>
    <span class="koboSpan" id="kobo.32.2">
     The database performance becomes an issue when the cloud environment keeps growing without measuring the new load.
    </span>
    <span class="koboSpan" id="kobo.32.3">
     Databases in OpenStack can grow massively and result in large tables.
    </span>
    <span class="koboSpan" id="kobo.32.4">
     Each read or write request and API call increases the load, leading to common scenarios encountered with databases, such as database inconsistency.
    </span>
    <span class="koboSpan" id="kobo.32.5">
     A tenant could fire an API request to disassociate a network interface from an instance but the record in the database would remain unchanged.
    </span>
    <span class="koboSpan" id="kobo.32.6">
     A quick fix is to log in to the database and change the record manually, which can be an error-prone process.
    </span>
    <span class="koboSpan" id="kobo.32.7">
     The other common pattern is
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.33.1">
      multiple writes concurrency
     </span>
    </strong>
    <span class="koboSpan" id="kobo.34.1">
     , whereby two services
    </span>
    <a id="_idIndexMarker839">
    </a>
    <span class="koboSpan" id="kobo.35.1">
     assign the same resource ID based on an incoherent status attribute.
    </span>
    <span class="koboSpan" id="kobo.35.2">
     For example, a new instance might be spawned and may be unable to associate floating IP resources that have been, at the same time, dissociated from a terminated instance.
    </span>
    <span class="koboSpan" id="kobo.35.3">
     Relational databases typically face performance challenges, and generally, cloud operators utilize database administrators to keep their large and complex database environments.
    </span>
    <span class="koboSpan" id="kobo.35.4">
     Each request in an OpenStack environment would reach a database for a read or write, and as we have learned in previous chapters, most OpenStack services interact with the database to fulfill a request, ideally within an acceptable
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.36.1">
      response time.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.37.1">
     Aside from possible ways to improve an OpenStack database setup through hardware upscaling and upgrades, it is important to keep track of generic metrics of the database, such as the number of reads or writes, input/output storage trends, and error rates.
    </span>
    <span class="koboSpan" id="kobo.37.2">
     That will help you conclude approximately when the database will present a bottleneck.
    </span>
    <span class="koboSpan" id="kobo.37.3">
     If the software and configuration tweaks won’t help bypass the surge, a hardware upgrade will be more convenient to ensure that there is less trouble in the next
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.38.1">
      production cycle.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-162">
    <a id="_idTextAnchor207">
    </a>
    <span class="koboSpan" id="kobo.39.1">
     Running with caching
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.40.1">
     One of the fastest ways to ensure an optimally performing database is to look at the hardware running the cluster.
    </span>
    <span class="koboSpan" id="kobo.40.2">
     The nature of physical disks has a great influence on their capability to perform a certain number of operations.
    </span>
    <span class="koboSpan" id="kobo.40.3">
     For example, using
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.41.1">
      Solid State Devices
     </span>
    </strong>
    <span class="koboSpan" id="kobo.42.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.43.1">
      SSDs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.44.1">
     ) for database nodes
    </span>
    <a id="_idIndexMarker840">
    </a>
    <span class="koboSpan" id="kobo.45.1">
     can be very beneficial in improving the access time and transfer data speed, as well
    </span>
    <a id="_idIndexMarker841">
    </a>
    <span class="koboSpan" id="kobo.46.1">
     as the input/output wait factors.
    </span>
    <span class="koboSpan" id="kobo.46.2">
     The latest generations will consider Flash storage devices that improve read/write operations and are capable of handling high operation concurrency rates.
    </span>
    <span class="koboSpan" id="kobo.46.3">
     On the other hand, there are better and more cost-effective ways to design a well-performing database solution, such as by reducing the disk input/output activities on the database side
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.47.1">
      via caching.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.48.1">
     Caching happens at every step along the way, from the servers to the browsers of end users.
    </span>
    <span class="koboSpan" id="kobo.48.2">
     From the end user’s perspective, caching can minimize unresponsive statuses when passing queries all the way to the database.
    </span>
    <span class="koboSpan" id="kobo.48.3">
     Additionally, caching might be suitable for moving a long queue of database queries entirely outside of the database server.
    </span>
    <span class="koboSpan" id="kobo.48.4">
     In such cases, you are better off looking at an external caching solution, such as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.49.1">
      Memcached
     </span>
    </strong>
    <span class="koboSpan" id="kobo.50.1">
     or
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.51.1">
      Redis
     </span>
    </strong>
    <span class="koboSpan" id="kobo.52.1">
     .
    </span>
    <span class="koboSpan" id="kobo.52.2">
     By exposing a
    </span>
    <a id="_idIndexMarker842">
    </a>
    <span class="koboSpan" id="kobo.53.1">
     memory server, the OpenStack database servers
    </span>
    <a id="_idIndexMarker843">
    </a>
    <span class="koboSpan" id="kobo.54.1">
     can benefit from a caching layer for Horizon to store OpenStack service data.
    </span>
    <span class="koboSpan" id="kobo.54.2">
     One important consideration is that the caching layer does not store data.
    </span>
    <span class="koboSpan" id="kobo.54.3">
     Once, for example, a Memcached instance restarts, the data will be lost.
    </span>
    <span class="koboSpan" id="kobo.54.4">
     Memcached is a typically adopted caching solution in OpenStack that runs in any type of configuration.
    </span>
    <span class="koboSpan" id="kobo.54.5">
     Large-scale OpenStack environments run the caching layer in dedicated cluster nodes to double
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.55.1">
      the performance.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.56.1">
     A typical Memcached setup only requires the usage of hardware with fewer CPU specifications in contrast to database requirements.
    </span>
    <span class="koboSpan" id="kobo.56.2">
     The following diagram depicts how Memcached is used in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.57.1">
      OpenStack environment:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer166">
     <span class="koboSpan" id="kobo.58.1">
      <img alt="Figure 9.1 – The Memcached integration in OpenStack" src="image/B21716_09_01.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.59.1">
     Figure 9.1 – The Memcached integration in OpenStack
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.60.1">
     This workflow diagram
    </span>
    <a id="_idIndexMarker844">
    </a>
    <span class="koboSpan" id="kobo.61.1">
     exposes a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.62.1">
      write-through caching mechanism
     </span>
    </strong>
    <span class="koboSpan" id="kobo.63.1">
     by getting data that is stored in Memcached
    </span>
    <a id="_idIndexMarker845">
    </a>
    <span class="koboSpan" id="kobo.64.1">
     while it performs a read to the MySQL database.
    </span>
    <span class="koboSpan" id="kobo.64.2">
     In the next section, we will deploy a Memcached layer in an existing OpenStack environment
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.65.1">
      using
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.66.1">
       kolla-ansible
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.67.1">
      .
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-163">
    <a id="_idTextAnchor208">
    </a>
    <span class="koboSpan" id="kobo.68.1">
     Deploying caching
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.69.1">
     Before we start deploying our Memcached instance in the existing OpenStack environment, it is essential to iterate
    </span>
    <a id="_idIndexMarker846">
    </a>
    <span class="koboSpan" id="kobo.70.1">
     through common workflows in OpenStack that would engage caching operations.
    </span>
    <span class="koboSpan" id="kobo.70.2">
     When firing an instance creation request, several API requests are generated and aligned to reach specific service endpoints.
    </span>
    <span class="koboSpan" id="kobo.70.3">
     This process involves requests from Horizon to Nova to launch the API request, Glance to fetch an image, Cinder to attach volumes, Neutron to assign network ports, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.71.1">
      so on.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.72.1">
     Upon each request, Keystone checks its records in the database to verify the validity of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.73.1">
      internal tokens.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.74.1">
     With a large number of similar API requests, Keystone would consume more CPU resources for the database to fetch those tokens and validate them accordingly.
    </span>
    <span class="koboSpan" id="kobo.74.2">
     That would increase latency in order to fulfill new incoming requests and lead to longer delays in lookups through the database table caused by expired tokens.
    </span>
    <span class="koboSpan" id="kobo.74.3">
     Caching can drastically reduce the load on the database by not saving the tokens in the database and instead using the caching layer.
    </span>
    <span class="koboSpan" id="kobo.74.4">
     Keystone will save all its token records in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.75.1">
      Memcached instance.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.76.1">
     In the following exercise, we will deploy a Memcached container as part of the control plane nodes.
    </span>
    <span class="koboSpan" id="kobo.76.2">
     As recommended
    </span>
    <a id="_idIndexMarker847">
    </a>
    <span class="koboSpan" id="kobo.77.1">
     previously, the Memcached layer can be run on a dedicated server of even clusters for the highest performance and would require clustering configuration separately, which falls outside of the scope of this book.
    </span>
    <span class="koboSpan" id="kobo.77.2">
     Update the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.78.1">
      multi_packtpub_prod
     </span>
    </strong>
    <span class="koboSpan" id="kobo.79.1">
     file to assign the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.80.1">
      memcached
     </span>
    </strong>
    <span class="koboSpan" id="kobo.81.1">
     role to cloud controller nodes,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.82.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.83.1">
...
</span><span class="koboSpan" id="kobo.83.2">[memcached:children]
control</span></pre>
   <p>
    <span class="koboSpan" id="kobo.84.1">
     The next step is to enable the Memcached service in the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.85.1">
       globals.yml
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.86.1">
      file:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.87.1">
...
</span><span class="koboSpan" id="kobo.87.2">enable_memcached: "yes"</span></pre>
   <p>
    <span class="koboSpan" id="kobo.88.1">
     Finally, run the pipeline and make sure that the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.89.1">
      memcached
     </span>
    </strong>
    <span class="koboSpan" id="kobo.90.1">
     container is created and up and running by executing the following command line on the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.91.1">
      controller node:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.92.1">
$ sudo docker ps | grep memcached</span></pre>
   <p>
    <span class="koboSpan" id="kobo.93.1">
     This is the output
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.94.1">
      we get:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer167">
     <span class="koboSpan" id="kobo.95.1">
      <img alt="Figure 9.2 – Listing the Memcached kolla container" src="image/B21716_09_02.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.96.1">
     Figure 9.2 – Listing the Memcached kolla container
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.97.1">
     Make sure that Keystone has been reconfigured to use caching, which can be checked in the Keystone configuration file in the cloud
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.98.1">
      controller node:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.99.1">
$ cat /etc/keystone/keystone.conf
[cache]
backend = oslo_cache.memcache_pool
enabled = True
memcache_servers = url:127.0.0.1:11211</span></pre>
   <p>
    <span class="koboSpan" id="kobo.100.1">
     Further checks can be
    </span>
    <a id="_idIndexMarker848">
    </a>
    <span class="koboSpan" id="kobo.101.1">
     performed on the Memcached instance by watching the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.102.1">
      get_hits
     </span>
    </strong>
    <span class="koboSpan" id="kobo.103.1">
     value increase when firing Keystone API calls, as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.104.1">
      depicted here:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.105.1">
$ watch -d -n 1 'memcached-tool 127.0.0.1:11211 stats'</span></pre>
   <p>
    <span class="koboSpan" id="kobo.106.1">
     We get the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.107.1">
      following output:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer168">
     <span class="koboSpan" id="kobo.108.1">
      <img alt="Figure 9.3 – Listing Memcached get_hits stats" src="image/B21716_09_03.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.109.1">
     Figure 9.3 – Listing Memcached get_hits stats
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.110.1">
     A few bounced usage statistic values are useful to verify the current behavior of the Keystone caching mechanism in
    </span>
    <a id="_idIndexMarker849">
    </a>
    <span class="koboSpan" id="kobo.111.1">
     real time, such as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.112.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.113.1">
       accepting_conns
      </span>
     </strong>
     <span class="koboSpan" id="kobo.114.1">
      : This is the number of accepted connections to the Memcached server.
     </span>
     <span class="koboSpan" id="kobo.114.2">
      Any newly added service configured to use Memcached as a cache backend will increase its value
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.115.1">
       by 1.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.116.1">
       bytes
      </span>
     </strong>
     <span class="koboSpan" id="kobo.117.1">
      : This is the number of bytes used for caching items in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.118.1">
       real time.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.119.1">
       bytes_read
      </span>
     </strong>
     <span class="koboSpan" id="kobo.120.1">
      : This is the number of incoming bytes to the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.121.1">
       Memcached server.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.122.1">
       bytes_written
      </span>
     </strong>
     <span class="koboSpan" id="kobo.123.1">
      : This is the number of outgoing bytes from the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.124.1">
       Memcached server.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.125.1">
       cmd_get
      </span>
     </strong>
     <span class="koboSpan" id="kobo.126.1">
      : This is the number of get commands received by the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.127.1">
       Memcached server.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.128.1">
       cmd_set
      </span>
     </strong>
     <span class="koboSpan" id="kobo.129.1">
      : This is the number of set commands processed by the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.130.1">
       Memcached server.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.131.1">
       get_hits
      </span>
     </strong>
     <span class="koboSpan" id="kobo.132.1">
      : This is the number of successful cache hits (get requests).
     </span>
     <span class="koboSpan" id="kobo.132.2">
      The hit rate can be obtained by dividing
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.133.1">
       get_hits
      </span>
     </strong>
     <span class="koboSpan" id="kobo.134.1">
      by the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.135.1">
       cmd_get
      </span>
     </strong>
     <span class="koboSpan" id="kobo.136.1">
      value and generating
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.137.1">
       the percentage.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.138.1">
       get_misses
      </span>
     </strong>
     <span class="koboSpan" id="kobo.139.1">
      : This is the number of failed cache hits (
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.140.1">
       get requests).
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.141.1">
     Most of the OpenStack services can
    </span>
    <a id="_idIndexMarker850">
    </a>
    <span class="koboSpan" id="kobo.142.1">
     take advantage of the caching layer, so Keystone can use Memcached servers to store the tokens for each service request instead of caching them by default in-process.
    </span>
    <span class="koboSpan" id="kobo.142.2">
     Once enabled,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.143.1">
      kolla-ansible
     </span>
    </strong>
    <span class="koboSpan" id="kobo.144.1">
     will roll out the caching layer and adjust the services configuration to use the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.145.1">
      Memcached layer.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.146.1">
     As Memcached is deployed through the cloud controller nodes, we can make sure that its clients are handled by the HAProxy load balancer and use multiple Memcached instances in TCP mode.
    </span>
    <span class="koboSpan" id="kobo.146.2">
     We can simply edit the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.147.1">
      enable_haproxy_memcached
     </span>
    </strong>
    <span class="koboSpan" id="kobo.148.1">
     variable in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.149.1">
      kolla-ansible/ansible/group_vars/all.yml
     </span>
    </strong>
    <span class="koboSpan" id="kobo.150.1">
     file,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.151.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.152.1">
...
</span><span class="koboSpan" id="kobo.152.2">enable_haproxy_memcached: "yes"</span></pre>
   <p>
    <span class="koboSpan" id="kobo.153.1">
     After running the pipeline, the Memcached cluster will be listed in HAProxy and served through its
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.154.1">
      virtual IP.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.155.1">
     We will need to tell Nova services that we already have multiple Memcached instances running in three different cloud controller nodes.
    </span>
    <span class="koboSpan" id="kobo.155.2">
     When
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.156.1">
      cc01.os
     </span>
    </strong>
    <span class="koboSpan" id="kobo.157.1">
     becomes unavailable,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.158.1">
      cc02.os
     </span>
    </strong>
    <span class="koboSpan" id="kobo.159.1">
     takes over, and so on.
    </span>
    <span class="koboSpan" id="kobo.159.2">
     We will set the following directive in each controller and compute node in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.160.1">
      /
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.161.1">
       etc/nova/nova.conf
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.162.1">
      file:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.163.1">
...
</span><span class="koboSpan" id="kobo.163.2">memcached_servers = cc01.os:11211,cc02.os:11211,cc03.os:11211
...</span></pre>
   <p>
    <span class="koboSpan" id="kobo.164.1">
     Memcached can also be beneficial for our dashboard.
    </span>
    <span class="koboSpan" id="kobo.164.2">
     We can tell Horizon to use Memcached for the Django web caching.
    </span>
    <span class="koboSpan" id="kobo.164.3">
     It just needs to point to the virtual IP, considering a scalable cloud controller
    </span>
    <a id="_idIndexMarker851">
    </a>
    <span class="koboSpan" id="kobo.165.1">
     setup.
    </span>
    <span class="koboSpan" id="kobo.165.2">
     The dashboard includes the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.166.1">
      CACHES
     </span>
    </strong>
    <span class="koboSpan" id="kobo.167.1">
     settings, which
    </span>
    <a id="_idIndexMarker852">
    </a>
    <span class="koboSpan" id="kobo.168.1">
     we need to edit or add.
    </span>
    <span class="koboSpan" id="kobo.168.2">
     On your cloud controller nodes, edit the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.169.1">
      /etc/openstackdashboard/local_settings.py
     </span>
    </strong>
    <span class="koboSpan" id="kobo.170.1">
     file
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.171.1">
      like this:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.172.1">
...
 </span><span class="koboSpan" id="kobo.172.2">CACHES = {
     'default': {
         'BACKEND':
              'django.core.cache.backends.memcached.'
</span><span class="koboSpan" id="kobo.172.3">              'MemcachedCache',
         'LOCATION': '10.0.0.100:11211',
     }
 }
...</span></pre>
   <p>
    <span class="koboSpan" id="kobo.173.1">
     Optionally, the next configuration snippet can be added to each HAProxy instance to boost a scalable Django dashboard, which will now use a scalable
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.174.1">
      Memcached setup:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.175.1">
listen horizon 10.0.0.47:80
balance roundrobin
maxconn 10000
mode tcp
server cc01.os 10.0.0.100:80 cookie cc01.os check inter 5s rise
2 fall 3
server cc02.os 10.0.0.101:80 cookie cc02.os check inter 5s rise
2 fall 3
server cc03.os 10.0.0.102:80 cookie cc03.os check inter 5s rise
2 fall 3</span></pre>
   <p>
    <span class="koboSpan" id="kobo.176.1">
     Reload the HAProxy configuration by firing the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.177.1">
      command line:
     </span>
    </span>
   </p>
   <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.178.1">$ service haproxy reload</span></strong></pre>
   <p>
    <span class="koboSpan" id="kobo.179.1">
     There are a gazillion use cases where managing the performance of databases is important; it is a large topic and demands more database expertise to find anomalies and tackle them immediately.
    </span>
    <span class="koboSpan" id="kobo.179.2">
     Memcached is one way to handle massive bursts of read operations, but that may not be enough.
    </span>
    <span class="koboSpan" id="kobo.179.3">
     Database performance can be more complicated to tackle when it grows and there are few tools available to automate database performance checks and remediation.
    </span>
    <span class="koboSpan" id="kobo.179.4">
     OpenStack comes with some tooling around its core ecosystem that supports cloud operators to benchmark, observe, and make architectural decisions to
    </span>
    <a id="_idIndexMarker853">
    </a>
    <span class="koboSpan" id="kobo.180.1">
     improve service performance.
    </span>
    <span class="koboSpan" id="kobo.180.2">
     In the next section, we will dive into the art of OpenStack benchmarking using
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.181.1">
      automated tooling.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-164">
    <a id="_idTextAnchor209">
    </a>
    <span class="koboSpan" id="kobo.182.1">
     Benchmarking the cloud
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.183.1">
     Scaling up hardware resources is the standard way to address capacity and performance limits.
    </span>
    <span class="koboSpan" id="kobo.183.2">
     With the help of a monitoring system, cloud operators can react proactively to add more resources in a
    </span>
    <a id="_idIndexMarker854">
    </a>
    <span class="koboSpan" id="kobo.184.1">
     defined window of time to accommodate the additional load.
    </span>
    <span class="koboSpan" id="kobo.184.2">
     However, monitoring systems are not enough to better know our limits.
    </span>
    <span class="koboSpan" id="kobo.184.3">
     In distributed computing systems, every circulated request incurs a performance hit.
    </span>
    <span class="koboSpan" id="kobo.184.4">
     In the OpenStack world, a load of API requests can be complicated to trace and develop an approximate measurement of how much a part or service
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.185.1">
      can handle.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.186.1">
     From the early stages of the cloud journey, cloud operators should define and develop a strategic approach to measure their cloud limits and performance metrics.
    </span>
    <span class="koboSpan" id="kobo.186.2">
     However, the challenging part is the absence of efficient tools that could be integrated into the life cycle of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.187.1">
      cloud deployments.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.188.1">
     To address this gap of performance measurement, one key factor is to benchmark the private cloud setup under load at scale for the control and data planes separately.
    </span>
    <span class="koboSpan" id="kobo.188.2">
     It is heartening to know that with the great success of OpenStack, more benchmarking tools are being developed around its ecosystem and for each plane.
    </span>
    <span class="koboSpan" id="kobo.188.3">
     In the next section, we will explore a sophisticated benchmarking tool to measure the control plane: the
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.189.1">
       Rally
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.190.1">
      tool.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-165">
    <a id="_idTextAnchor210">
    </a>
    <span class="koboSpan" id="kobo.191.1">
     Rally in action
    </span>
   </h2>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.192.1">
      kolla-ansible
     </span>
    </strong>
    <span class="koboSpan" id="kobo.193.1">
     does not support Rally out of the box for installation as Rally is not originally native or part of the OpenStack ecosystem.
    </span>
    <span class="koboSpan" id="kobo.193.2">
     Installing Rally can be done in various ways, and its package
    </span>
    <a id="_idIndexMarker855">
    </a>
    <span class="koboSpan" id="kobo.194.1">
     installation is available for many Linux
    </span>
    <a id="_idIndexMarker856">
    </a>
    <span class="koboSpan" id="kobo.195.1">
     distributions.
    </span>
    <span class="koboSpan" id="kobo.195.2">
     We will keep our installation platform-agnostic by using containers, but this is not
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.196.1">
      a must.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.197.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.198.1">
     You can still integrate the Rally service in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.199.1">
      kolla-ansible
     </span>
    </strong>
    <span class="koboSpan" id="kobo.200.1">
     code.
    </span>
    <span class="koboSpan" id="kobo.200.2">
     You will need to build your own Rally container, push it to your own private repository, and write the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.201.1">
      Ansible role.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.202.1">
     For the next installation exercise, we will use the latest Docker Rally image from Docker Hub that comes with the Rally service and different plugins for OpenStack.
    </span>
    <span class="koboSpan" id="kobo.202.2">
     In one of the cloud controller nodes, pull the Rally container by running the following command line in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.203.1">
      new directory:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.204.1">
$ docker pull xrally/rally-openstack</span></pre>
   <p>
    <span class="koboSpan" id="kobo.205.1">
     The pulled image version of Rally is 2.3.0, which is the latest version at the time of writing.
    </span>
    <span class="koboSpan" id="kobo.205.2">
     Database, configuration, and records of Rally can be stored by creating a Docker volume
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.206.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.207.1">
$ docker volume create --name rally_storage</span></pre>
   <p>
    <span class="koboSpan" id="kobo.208.1">
     The next command step is simply running the Rally Docker container by indicating the path where Rally will persist data under the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.209.1">
      /
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.210.1">
       home/rally/.rally
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.211.1">
      directory:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.212.1">
$ docker run -v rally_storage:/home/rally/.rally xrally/rally-openstack</span></pre>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.213.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.214.1">
     The Rally default configuration places the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.215.1">
      'rally.sqlite'
     </span>
    </strong>
    <span class="koboSpan" id="kobo.216.1">
     Rally database under the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.217.1">
      /home/rally/.rally
     </span>
    </strong>
    <span class="koboSpan" id="kobo.218.1">
     directory.
    </span>
    <span class="koboSpan" id="kobo.218.2">
     This default configuration can overridden by updating the available options located in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.219.1">
      /
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.220.1">
       etc/rally/rally.conf
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.221.1">
      file.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.222.1">
     We will need to register our
    </span>
    <a id="_idIndexMarker857">
    </a>
    <span class="koboSpan" id="kobo.223.1">
     OpenStack environment with Rally by
    </span>
    <a id="_idIndexMarker858">
    </a>
    <span class="koboSpan" id="kobo.224.1">
     providing a deployment file in which OpenStack environment variables, such as admin credentials,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.225.1">
      are required.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.226.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.227.1">
     Different variables of the admin username, password, and tenant are generated in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.228.1">
      /
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.229.1">
       etc/kolla/clouds.yaml
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.230.1">
      file.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.231.1">
     In the Rally container Bash prompt, create a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.232.1">
      deployment.json
     </span>
    </strong>
    <span class="koboSpan" id="kobo.233.1">
     file and make sure that the different variables are assigned values from the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.234.1">
      /
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.235.1">
       etc/kolla/clouds.yaml
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.236.1">
      file:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.237.1">
{
    "type": "cloud_my",
    "auth_url": "http://10.0.0.100:5000/v2.0",
    "region_name": "RegionOne",
    "admin": {
        "username": "admin",
        "password": "476212da112412",
        "tenant_name": "admin"
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.238.1">
     Using the Rally client command line, create a deployment using the previously
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.239.1">
      created file:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.240.1">
$ rally deployment create --file=deployment.json --name=perf_cloud</span></pre>
   <p>
    <span class="koboSpan" id="kobo.241.1">
     The output is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.242.1">
      as follows:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer169">
     <span class="koboSpan" id="kobo.243.1">
      <img alt="Figure 9.4 – Listing the Rally deployment status" src="image/B21716_09_04.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.244.1">
     Figure 9.4 – Listing the Rally deployment status
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.245.1">
     Source the generated
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.246.1">
      openrc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.247.1">
     file located
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.248.1">
      under
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.249.1">
       ~/.rally
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.250.1">
      :
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.251.1">
$ source ~/.rally/openrc</span></pre>
   <p>
    <span class="koboSpan" id="kobo.252.1">
     Verify the
    </span>
    <a id="_idIndexMarker859">
    </a>
    <span class="koboSpan" id="kobo.253.1">
     availability of the OpenStack deployment using the
    </span>
    <a id="_idIndexMarker860">
    </a>
    <span class="koboSpan" id="kobo.254.1">
     deployment check command,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.255.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.256.1">
$ rally deployment check</span></pre>
   <p>
    <span class="koboSpan" id="kobo.257.1">
     Here is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.258.1">
      the output:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer170">
     <span class="koboSpan" id="kobo.259.1">
      <img alt="Figure 9.5 – Listing the OpenStack services statuses" src="image/B21716_09_05.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.260.1">
     Figure 9.5 – Listing the OpenStack services statuses
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.261.1">
     Now that we have a Rally server installed and properly configured to talk to OpenStack APIs, it is time for cloud benchmarking.
    </span>
    <span class="koboSpan" id="kobo.261.2">
     By default, you may find numerous benchmarking scenarios under
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.262.1">
      /rally/sample/tasks/scenarios
     </span>
    </strong>
    <span class="koboSpan" id="kobo.263.1">
     for all OpenStack services, including other incubated projects such as Murano and Sahara.
    </span>
    <span class="koboSpan" id="kobo.263.2">
     We will concentrate on benchmarking our existing running OpenStack services.
    </span>
    <span class="koboSpan" id="kobo.263.3">
     Before starting our first benchmark test, it would be great to shine the spotlight on how Rally works in the first place.
    </span>
    <span class="koboSpan" id="kobo.263.4">
     Scenarios in Rally are performed based on tasks.
    </span>
    <span class="koboSpan" id="kobo.263.5">
     A task can include a set of running benchmarks against the OpenStack cloud written in sample JSON or YAML file format.
    </span>
    <span class="koboSpan" id="kobo.263.6">
     The former file generally has the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.264.1">
      following structure:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.265.1">
ScenarioClass.scenario_method:
-
args:
...
</span><span class="koboSpan" id="kobo.265.2">runner:
...
</span><span class="koboSpan" id="kobo.265.3">context
...
</span><span class="koboSpan" id="kobo.265.4">sla:
...</span></pre>
   <p>
    <span class="koboSpan" id="kobo.266.1">
     Each stanza block is defined
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.267.1">
      as follows:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.268.1">
       ScenarioClass.scenario_method
      </span>
     </strong>
     <span class="koboSpan" id="kobo.269.1">
      : This defines the name of the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.270.1">
       benchmark scenario.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.271.1">
       args
      </span>
     </strong>
     <span class="koboSpan" id="kobo.272.1">
      : Every method
     </span>
     <a id="_idIndexMarker861">
     </a>
     <span class="koboSpan" id="kobo.273.1">
      corresponding to a specific class scenario can be customized by passing
     </span>
     <a id="_idIndexMarker862">
     </a>
     <span class="koboSpan" id="kobo.274.1">
      parameters before launching
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.275.1">
       the benchmark.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.276.1">
       runner
      </span>
     </strong>
     <span class="koboSpan" id="kobo.277.1">
      : This defines the workload frequency type and the order of the benchmarking scenarios.
     </span>
     <span class="koboSpan" id="kobo.277.2">
      The runner stanza can support different types,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.278.1">
       as follows:
      </span>
     </span>
     <ul>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.279.1">
         constant
        </span>
       </strong>
       <span class="koboSpan" id="kobo.280.1">
        : This involves running the scenario for a fixed number of times.
       </span>
       <span class="koboSpan" id="kobo.280.2">
        For example, a scenario can be run 10 times in the total
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.281.1">
         test period.
        </span>
       </span>
      </li>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.282.1">
         constant_for_duration
        </span>
       </strong>
       <span class="koboSpan" id="kobo.283.1">
        : This involves running the scenario for a fixed number of times until a certain point
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.284.1">
         in time.
        </span>
       </span>
      </li>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.285.1">
         periodic
        </span>
       </strong>
       <span class="koboSpan" id="kobo.286.1">
        : This involves defining a certain period to run two consecutive
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.287.1">
         benchmark scenarios.
        </span>
       </span>
      </li>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.288.1">
         serial
        </span>
       </strong>
       <span class="koboSpan" id="kobo.289.1">
        : This involves running the scenario for a fixed number of times in a single
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.290.1">
         benchmark thread.
        </span>
       </span>
      </li>
     </ul>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.291.1">
       context
      </span>
     </strong>
     <span class="koboSpan" id="kobo.292.1">
      : This defines the environment type in which our benchmark scenario(s) can run.
     </span>
     <span class="koboSpan" id="kobo.292.2">
      Usually, the concept of context defines how many tenants and active users will be associated with a given OpenStack project.
     </span>
     <span class="koboSpan" id="kobo.292.3">
      It can also specify a quota per tenant or user within a certain
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.293.1">
       granted role.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.294.1">
       sla
      </span>
     </strong>
     <span class="koboSpan" id="kobo.295.1">
      : This is very useful for identifying the overall scenario average success rate of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.296.1">
       the benchmark.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.297.1">
     If you are hoping to find a convenient benchmarking scenario that will reveal more significant results from your current OpenStack deployment, you’ll have to keep looking for a real use case that is more specific to cloud operators.
    </span>
    <span class="koboSpan" id="kobo.297.2">
     For example, Rally can help developers easily run synthetic workloads such as VM provisioning and destroy instances for a limited period.
    </span>
    <span class="koboSpan" id="kobo.297.3">
     However, the case seems to be more complicated for cloud operators.
    </span>
    <span class="koboSpan" id="kobo.297.4">
     Such results generated from workloads are more high-level but allow you to identify bottlenecks in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.298.1">
      the cloud.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.299.1">
     Let’s consider a real-world example: companies have several applications that need to be deployed in different usage patterns.
    </span>
    <span class="koboSpan" id="kobo.299.2">
     If we have multiple concurrent instances of an application for QA/dev, they will be deployed in different versions of this application on the cloud several times per day.
    </span>
    <span class="koboSpan" id="kobo.299.3">
     Let’s take the use case of a large deployment, where there is a set number of teams running a bunch of standard stack applications and each application will contain a lot of VMs that need to be deployed at certain times in a day.
    </span>
    <span class="koboSpan" id="kobo.299.4">
     Such workload requirements are translated to OpenStack terms as follows: we will have
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.300.1">
      M
     </span>
    </em>
    <span class="koboSpan" id="kobo.301.1">
     number of users provisioning
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.302.1">
      N
     </span>
    </em>
    <span class="koboSpan" id="kobo.303.1">
     number of VMs within a specific flavor and time period in a concurrent way.
    </span>
    <span class="koboSpan" id="kobo.303.2">
     As we know, OpenStack is not a monolithic structure; it is a distributed system with different daemons
    </span>
    <a id="_idIndexMarker863">
    </a>
    <span class="koboSpan" id="kobo.304.1">
     and services talking to each other.
    </span>
    <span class="koboSpan" id="kobo.304.2">
     If we decompose a use case of provisioning
    </span>
    <a id="_idIndexMarker864">
    </a>
    <span class="koboSpan" id="kobo.305.1">
     an instance to the primitives, it helps us to understand where we spend most of the time during the VM provisioning phase and build records of historical data.
    </span>
    <span class="koboSpan" id="kobo.305.2">
     For example, by running the same benchmark several times but changing the parameters of database configuration or enabling Glance.
    </span>
    <span class="koboSpan" id="kobo.305.3">
     In the next subsection, we will use the same benchmarking approach to run against the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.306.1">
      Keystone service.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.307.1">
     Keystone under stress
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.308.1">
     Our example
    </span>
    <a id="_idIndexMarker865">
    </a>
    <span class="koboSpan" id="kobo.309.1">
     scenario is a benchmarking test based on the Rally method named
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.310.1">
      KeystoneBasic.authenticate_user_and_validate_token
     </span>
    </strong>
    <span class="koboSpan" id="kobo.311.1">
     .
    </span>
    <span class="koboSpan" id="kobo.311.2">
     The scenario is intended to measure the time to fetch and validate tokens issued by Keystone when authenticating users under a specific load.
    </span>
    <span class="koboSpan" id="kobo.311.3">
     An important note for the sake of the demonstration is that the load test will be applied on a specific Keystone configuration that does not support the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.312.1">
      WSGI
     </span>
    </strong>
    <span class="koboSpan" id="kobo.313.1">
     module for
    </span>
    <a id="_idIndexMarker866">
    </a>
    <span class="koboSpan" id="kobo.314.1">
     the Apache
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.315.1">
      web server.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.316.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.317.1">
     The latest version of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.318.1">
      kolla-ansible
     </span>
    </strong>
    <span class="koboSpan" id="kobo.319.1">
     comes with Keystone configured with the WSGI (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.320.1">
      mod_wsgi
     </span>
    </strong>
    <span class="koboSpan" id="kobo.321.1">
     ) module enabled by default for Apache.
    </span>
    <span class="koboSpan" id="kobo.321.2">
     You can disable the module manually in the Keystone configuration file or create a new Kolla container to test the first Rally scenario.
    </span>
    <span class="koboSpan" id="kobo.321.3">
     Make sure to perform the load exercise in a separate environment to not break the Keystone configuration and hence
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.322.1">
      other services.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.323.1">
     Let’s create a new file
    </span>
    <a id="_idIndexMarker867">
    </a>
    <span class="koboSpan" id="kobo.324.1">
     named
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.325.1">
      perf_keystone_pp.yaml
     </span>
    </strong>
    <span class="koboSpan" id="kobo.326.1">
     .
    </span>
    <span class="koboSpan" id="kobo.326.2">
     The content of the file task looks
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.327.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.328.1">
KeystoneBasic.authenticate_user_and_validate_token:
- args: {}
  runner:
    type: "constant"
    times: 50
    concurrency: 50
  context:
    users:
      tenants: 5
      users_per_tenant: 10
  sla:
failure_rate:
  max:1</span></pre>
   <p>
    <span class="koboSpan" id="kobo.329.1">
     The sample scenario will create a constant load of a Keystone scenario authenticating users and validating tokens 50 times without pausing by creating 5 different tenants with 10 users in each.
    </span>
    <span class="koboSpan" id="kobo.329.2">
     Note that in each iteration, 50 scenarios will run at the same time in concurrency mode to simulate multiple user access.
    </span>
    <span class="koboSpan" id="kobo.329.3">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.330.1">
      sla
     </span>
    </strong>
    <span class="koboSpan" id="kobo.331.1">
     section defines a condition where if one authentication attempt fails, then the task will
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.332.1">
      be aborted.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.333.1">
     Let’s run the previous benchmark using the Rally command line,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.334.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.335.1">
$ rally task start --abort-on-sla-failure perf_keystone_pp.yaml</span></pre>
   <p>
    <span class="koboSpan" id="kobo.336.1">
     Note that this time, we added a new option to our
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.337.1">
      abort-on-sla-failure
     </span>
    </strong>
    <span class="koboSpan" id="kobo.338.1">
     command.
    </span>
    <span class="koboSpan" id="kobo.338.2">
     This is a very useful argument if you are running such a benchmark scenario in a real OpenStack production environment.
    </span>
    <span class="koboSpan" id="kobo.338.3">
     Rally generates a heavy workload, which might cause
    </span>
    <a id="_idIndexMarker868">
    </a>
    <span class="koboSpan" id="kobo.339.1">
     performance troubles in the existing cloud.
    </span>
    <span class="koboSpan" id="kobo.339.2">
     Thus, we tell Rally to stop the load at a certain moment when the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.340.1">
      sla
     </span>
    </strong>
    <span class="koboSpan" id="kobo.341.1">
     conditions are met.
    </span>
    <span class="koboSpan" id="kobo.341.2">
     The output of our executed task is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.342.1">
      as follows:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer171">
     <span class="koboSpan" id="kobo.343.1">
      <img alt="Figure 9.6 – Listing Rally task stats" src="image/B21716_09_06.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.344.1">
     Figure 9.6 – Listing Rally task stats
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.345.1">
     The Rally benchmark results show that the scenario test has run 50 times and is completed with a 100% success rate.
    </span>
    <span class="koboSpan" id="kobo.345.2">
     To dive into more details, we can visualize the HTML report using the generated Rally task ID by running the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.346.1">
      following command:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.347.1">
$ rally task report c5493ee7-fba2-4290-b98c-36e47ed0fdb2 --out 
/var/www/html/bench/keystone_report01.html</span></pre>
   <p>
    <span class="koboSpan" id="kobo.348.1">
     Our first test iteration benchmark involves a simple SLA condition that was met during the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.349.1">
      Rally task:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer172">
     <span class="koboSpan" id="kobo.350.1">
      <img alt="Figure 9.7 – A Rally SLA failure_rate HTML report" src="image/B21716_09_07.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.351.1">
     Figure 9.7 – A Rally SLA failure_rate HTML report
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.352.1">
     From the same report dashboard, in the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.353.1">
      Overview
     </span>
    </strong>
    <span class="koboSpan" id="kobo.354.1">
     tab, a second pertinent chart,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.355.1">
      Load Profile
     </span>
    </strong>
    <span class="koboSpan" id="kobo.356.1">
     , illustrates how many iterations were running in parallel during the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.357.1">
      Rally task:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer173">
     <span class="koboSpan" id="kobo.358.1">
      <img alt="Figure 9.8 – The Load Profile report for the Keystone scenario, generated by Rally" src="image/B21716_09_08.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.359.1">
     Figure 9.8 – The Load Profile report for the Keystone scenario, generated by Rally
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.360.1">
     The
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.361.1">
      Load Profile
     </span>
    </strong>
    <span class="koboSpan" id="kobo.362.1">
     graph can be
    </span>
    <a id="_idIndexMarker869">
    </a>
    <span class="koboSpan" id="kobo.363.1">
     used to illustrate the variation of running iterations simultaneously over the workload period.
    </span>
    <span class="koboSpan" id="kobo.363.2">
     This information is useful for learning about the system behavior at certain peaks and planning how much load can be supported at any given time.
    </span>
    <span class="koboSpan" id="kobo.363.3">
     More details are provided in the second tab,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.364.1">
      Details
     </span>
    </strong>
    <span class="koboSpan" id="kobo.365.1">
     , where we can find
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.366.1">
      Atomic Action Durations
     </span>
    </strong>
    <span class="koboSpan" id="kobo.367.1">
     charts showing, in our case, two actions –
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.368.1">
      keystone_v2.fetch_token
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.369.1">
      and
     </span>
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.370.1">
       keystone_v2.validate_token
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.371.1">
      :
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer174">
     <span class="koboSpan" id="kobo.372.1">
      <img alt="Figure 9.9 – An Atomic Action Durations graph for Keystone steps, generated by Rally" src="image/B21716_09_09.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.373.1">
     Figure 9.9 – An Atomic Action Durations graph for Keystone steps, generated by Rally
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.374.1">
     The chart helps with seeing the variation of the scenario for each action and how the duration is affected and changed throughout the execution of iterations.
    </span>
    <span class="koboSpan" id="kobo.374.2">
     As we can see, both actions do not have the same duration as fetching and validating tokens are two different operations.
    </span>
    <span class="koboSpan" id="kobo.374.3">
     If our test case failed in terms of SLA conditions, such as a very long duration for scenario execution, we can use this chart to drive a granular analysis of which action the bottleneck
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.375.1">
      occurred on.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.376.1">
     We can adjust our success
    </span>
    <a id="_idIndexMarker870">
    </a>
    <span class="koboSpan" id="kobo.377.1">
     criteria parameters a bit in a second iteration for a stricter SLA to visualize a more realistic scenario.
    </span>
    <span class="koboSpan" id="kobo.377.2">
     For example, we can modify our
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.378.1">
      sla
     </span>
    </strong>
    <span class="koboSpan" id="kobo.379.1">
     section
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.380.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.381.1">
...
</span><span class="koboSpan" id="kobo.381.2">  sla:
    max_avg_duration: 5
    max_seconds_per_iteration: 5
  failure_rate:
  max: 0
  performance_degradation:
    max_degradation: 50
    outliers:
      max: 1</span></pre>
   <p>
    <span class="koboSpan" id="kobo.382.1">
     The new
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.383.1">
      sla
     </span>
    </strong>
    <span class="koboSpan" id="kobo.384.1">
     section defines
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.385.1">
      five conditions:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.386.1">
       max_avg_duration
      </span>
     </strong>
     <span class="koboSpan" id="kobo.387.1">
      : If the maximum average duration of an authentication is longer than five seconds, the task will
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.388.1">
       be aborted.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.389.1">
       max_seconds_per_iteration
      </span>
     </strong>
     <span class="koboSpan" id="kobo.390.1">
      : If the maximum duration of an authentication request is longer than five seconds, the task will
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.391.1">
       be aborted
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.392.1">
       failure_rate
      </span>
     </strong>
     <span class="koboSpan" id="kobo.393.1">
      : If more than one authentication fails, the task will be aborted defined by the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.394.1">
       parameter
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.395.1">
        max
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.396.1">
       .
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.397.1">
       performance_degradation
      </span>
     </strong>
     <span class="koboSpan" id="kobo.398.1">
      : If the difference between the maximum and minimum duration of completed iterations is more than 50 percent, the task will be aborted.
     </span>
     <span class="koboSpan" id="kobo.398.2">
      The maximum value is defined by
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.399.1">
        max_degradation
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.400.1">
       parameter.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.401.1">
      :
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.402.1">
       outlier
      </span>
     </strong>
     <span class="koboSpan" id="kobo.403.1">
      : The outlier limits the number of long-running iterations to a value of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.404.1">
       1
      </span>
     </strong>
     <span class="koboSpan" id="kobo.405.1">
      defined by the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.406.1">
        max
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.407.1">
       parameter.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.408.1">
     Once the Rally scenario has been modified, rerun the task
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.409.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.410.1">
$ rally task start --abort-on-sla-failure perf_keystone_pp.yaml</span></pre>
   <p>
    <span class="koboSpan" id="kobo.411.1">
     Let’s check our charts again by generating a new report with a different name so we can compare the difference
    </span>
    <a id="_idIndexMarker871">
    </a>
    <span class="koboSpan" id="kobo.412.1">
     in the results from the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.413.1">
      previous iteration:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.414.1">
$ rally task report 980957ef-4c4c-4e9b-a9c1-573839dcad80 --out 
/var/www/html/bench/keystone_report02.html</span></pre>
   <div>
    <div class="IMG---Figure" id="_idContainer175">
     <span class="koboSpan" id="kobo.415.1">
      <img alt="Figure 9.10 – An SLA for the Keystone load profile, generated by Rally" src="image/B21716_09_10.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.416.1">
     Figure 9.10 – An SLA for the Keystone load profile, generated by Rally
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.417.1">
     During the test, Rally detected a maximum value for the iteration of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.418.1">
      11.27
     </span>
    </strong>
    <span class="koboSpan" id="kobo.419.1">
     seconds, which does not comply with our
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.420.1">
      SLA requirement:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer176">
     <span class="koboSpan" id="kobo.421.1">
      <img alt="Figure 9.11 – A stacked overview of Keystone actions’ durations" src="image/B21716_09_11.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.422.1">
     Figure 9.11 – A stacked overview of Keystone actions’ durations
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.423.1">
     With the new SLA conditions, Rally execution stopped at the sixth iteration.
    </span>
    <span class="koboSpan" id="kobo.423.2">
     The demanded average time of authenticating a user and validating the token was not met and hence, this will affect the overall scenario execution duration time.
    </span>
    <span class="koboSpan" id="kobo.423.3">
     The next goal is to compete against that value and decrease it to below five seconds.
    </span>
    <span class="koboSpan" id="kobo.423.4">
     Our benchmark test showed that authenticating and validating user tokens at a certain peak of workload would not achieve our SLA requirements.
    </span>
    <span class="koboSpan" id="kobo.423.5">
     Moreover, the time spent authenticating one user increases and might be timed out as concurrency levels hit a specific threshold.
    </span>
    <span class="koboSpan" id="kobo.423.6">
     This performance challenge can be tweaked by revisiting our Keystone setup.
    </span>
    <span class="koboSpan" id="kobo.423.7">
     We can refer to an advanced Keystone design pattern that empowers our identity service performance within the OpenStack environment.
    </span>
    <span class="koboSpan" id="kobo.423.8">
     As many OpenStack components are developed to support the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.424.1">
      eventlet-based
     </span>
    </strong>
    <span class="koboSpan" id="kobo.425.1">
     process, the Keystone component can run in different ways by
    </span>
    <a id="_idIndexMarker872">
    </a>
    <span class="koboSpan" id="kobo.426.1">
     supporting the multi-threading process at the cost of our cloud controller’s CPU power.
    </span>
    <span class="koboSpan" id="kobo.426.2">
     One recommendation is to deploy Keystone in an Nginx server under WSGI or an Apache server with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.427.1">
      mod_wsgi
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.428.1">
      module enabled.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.429.1">
     Fronting our Keystone instance with a web server will bring facilities for handling parallel HTTP connections and advanced features to proxy authentication requests to our identity instance in a multi-threaded-based process mode.
    </span>
    <span class="koboSpan" id="kobo.429.2">
     By default, the community
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.430.1">
      kolla-ansible
     </span>
    </strong>
    <span class="koboSpan" id="kobo.431.1">
     code comes with the WSGI module enabled that will be used for this exercise.
    </span>
    <span class="koboSpan" id="kobo.431.2">
     The WSGI Keystone configuration is provided in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.432.1">
      wsgi-keystone.conf.j2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.433.1">
     template located under
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.434.1">
      the
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.435.1">
       /ansible/roles/keystone/templates
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.436.1">
      directory.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.437.1">
     The following snippet shows a basic WSGI configuration in Keystone with the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.438.1">
       VirtualHost
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.439.1">
      option:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.440.1">
...
</span><span class="koboSpan" id="kobo.440.2">&lt;VirtualHost *:{{ keystone_public_listen_port }}&gt;
    ServerName {{ keystone_public_url }}
    WSGIDaemonProcess keystone-public processes={{ keystone_api_workers }} threads=1  user=keystone group=keystone display-name=keystone-public
    WSGIProcessGroup keystone-public
    WSGIScriptAlias / {{ binary_path }}/keystone-wsgi-public
    WSGIApplicationGroup %{GLOBAL}
    WSGIPassAuthorization On
...</span></pre>
   <p>
    <span class="koboSpan" id="kobo.441.1">
     Note that the WSGI process group defines the number of threads to be run by the Keystone user (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.442.1">
      threads=1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.443.1">
     ) and processes (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.444.1">
      keystone_api_workers
     </span>
    </strong>
    <span class="koboSpan" id="kobo.445.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.445.2">
     We can increase the number of processed requests by adjusting the number for processes defined in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.446.1">
      keystone_api_workers
     </span>
    </strong>
    <span class="koboSpan" id="kobo.447.1">
     option and threads
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.448.1">
      in
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.449.1">
       WSGIDaemonProcessdirective
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.450.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.451.1">
...
</span><span class="koboSpan" id="kobo.451.2">WSGIDaemonProcess keystone-public processes={{ keystone_api_workers }} </span><strong class="bold"><span class="koboSpan" id="kobo.452.1">threads=30</span></strong><span class="koboSpan" id="kobo.453.1">  user=keystone group=keystone display-name=keystone-public
...</span></pre>
   <p>
    <span class="koboSpan" id="kobo.454.1">
     As we have introduced a configuration change, run the pipeline to pull and run the new configurations to be reflected in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.455.1">
      web server.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.456.1">
     Now we have Keystone
    </span>
    <a id="_idIndexMarker873">
    </a>
    <span class="koboSpan" id="kobo.457.1">
     backed by a web server and empowered by multi-threaded process mode by means of the WSGI module.
    </span>
    <span class="koboSpan" id="kobo.457.2">
     We have already defined the process daemons and threads that will help trace the limit of our hardware and Keystone capabilities against the same scenario by running it
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.458.1">
      once again:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.459.1">
# rally task start --abort-on-sla-failure perf_keystone_pp.yaml</span></pre>
   <p>
    <span class="koboSpan" id="kobo.460.1">
     Demonstrating the last Keystone settings, our cloud controller should be running more
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.461.1">
      apache2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.462.1">
     processes and hence using more CPU power.
    </span>
    <span class="koboSpan" id="kobo.462.2">
     That can be illustrated in the new performance results for authentication and validation
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.463.1">
      duration change:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.464.1">
# rally task report b36e4b72-0e86-4769-965d-cbe3662d647e --out 
/var/www/html/bench/keystone_report03.html</span></pre>
   <div>
    <div class="IMG---Figure" id="_idContainer177">
     <span class="koboSpan" id="kobo.465.1">
      <img alt="Figure 9.12 – The Keystone SLA upon web server threads increasing" src="image/B21716_09_12.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.466.1">
     Figure 9.12 – The Keystone SLA upon web server threads increasing
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.467.1">
     Now we have reached our goal by reducing the max number of seconds per iteration to below five seconds (4.19 seconds).
    </span>
    <span class="koboSpan" id="kobo.467.2">
     As we have achieved a
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.468.1">
      green
     </span>
    </em>
    <span class="koboSpan" id="kobo.469.1">
     SLA, we can analyze our new Keystone boost configuration from the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.470.1">
      Load
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.471.1">
       Profile
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.472.1">
      chart:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer178">
     <span class="koboSpan" id="kobo.473.1">
      <img alt="Figure 9.13 – ﻿Keystone load profile after increasing number of web server threads" src="image/B21716_09_13.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.474.1">
     Figure 9.13 – Keystone load profile after increasing number of web server threads
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.475.1">
     Compared to previous iterations, simultaneous requests can be handled by a pool of threads, so Keystone is
    </span>
    <a id="_idIndexMarker874">
    </a>
    <span class="koboSpan" id="kobo.476.1">
     able to face concurrent iterations during the workload timeline.
    </span>
    <span class="koboSpan" id="kobo.476.2">
     Although the currency level was set higher, we can notice that the maximum value of the load testing performed was only
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.477.1">
      24
     </span>
    </strong>
    <span class="koboSpan" id="kobo.478.1">
     .
    </span>
    <span class="koboSpan" id="kobo.478.2">
     That confirms that our thread and process settings for WSGI were heading in the right direction, leaving more free slots for more concurrency and less time for processing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.479.1">
      per iteration.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.480.1">
     There is more that can be done with Rally, but the scenarios described are sophisticated enough to start our benchmarking journey in OpenStack.
    </span>
    <span class="koboSpan" id="kobo.480.2">
     Rally is also a pluggable platform that allows operators to create and customize their benchmarking scenarios to meet certain special use cases.
    </span>
    <span class="koboSpan" id="kobo.480.3">
     Benchmarking is helpful to get insights into how your OpenStack is performing in regard to the defined SLA.
    </span>
    <span class="koboSpan" id="kobo.480.4">
     However, when performance anomalies are detected, benchmarking cannot help directly to remediate the issue.
    </span>
    <span class="koboSpan" id="kobo.480.5">
     For this reason, the profiling practice covered in the next section should be taken
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.481.1">
      into consideration.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-166">
    <a id="_idTextAnchor211">
    </a>
    <span class="koboSpan" id="kobo.482.1">
     Profiling the cloud
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.483.1">
     The OpenStack ecosystem is composed of multiple services that connect with each other to fulfill a request.
    </span>
    <span class="koboSpan" id="kobo.483.2">
     In some cases, a request can be processed extremely slowly and fail.
    </span>
    <span class="koboSpan" id="kobo.483.3">
     If the rate of request failures keeps increasing, cloud operators must investigate and understand the root cause of the issue.
    </span>
    <span class="koboSpan" id="kobo.483.4">
     Monitoring, debugging, and logging tools can partially be the answer to such scenarios, but they lack a request flow mechanism.
    </span>
    <span class="koboSpan" id="kobo.483.5">
     A tiny but great tool has been developed in the OpenStack
    </span>
    <a id="_idIndexMarker875">
    </a>
    <span class="koboSpan" id="kobo.484.1">
     ecosystem named
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.485.1">
      OSProfiler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.486.1">
     , which focuses on service tracing.
    </span>
    <span class="koboSpan" id="kobo.486.2">
     OSProfiler provides a view of requests as they travel through different OpenStack services and compiles data to be visualized in a timeline graph.
    </span>
    <span class="koboSpan" id="kobo.486.3">
     Cloud operators can determine bottlenecks in the OpenStack deployment and improve its performance by comparing trace sets with different conditions.
    </span>
    <span class="koboSpan" id="kobo.486.4">
     The OSProfiler tool is capable of providing valuable insights and tracing data that captures the response time of APIs, databases, drivers, and RPC calls.
    </span>
    <span class="koboSpan" id="kobo.486.5">
     Cloud operators can store the tracing information in persistent storage for further analysis, such as Redis, Elasticsearch, a simple file,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.487.1">
      or MongoDB.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.488.1">
     In a complex system such as OpenStack, tracing where a request is spent most of the time is extremely helpful to
    </span>
    <a id="_idIndexMarker876">
    </a>
    <span class="koboSpan" id="kobo.489.1">
     troubleshoot faster, identify bottlenecks, and prevent the issue from happening again.
    </span>
    <span class="koboSpan" id="kobo.489.2">
     Using OSProfiler, cloud operators can figure out the reason, for example, why launching a VM request takes ages.
    </span>
    <span class="koboSpan" id="kobo.489.3">
     OSProfiler is capable of showing the services involved in such requests, as well as their dependencies.
    </span>
    <span class="koboSpan" id="kobo.489.4">
     Operators can conclude which service presents the bottleneck and how to improve the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.490.1">
      response time.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.491.1">
     The next section will illustrate how to install and run OSProfiler in the existing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.492.1">
      OpenStack environment.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-167">
    <a id="_idTextAnchor212">
    </a>
    <span class="koboSpan" id="kobo.493.1">
     Profiler in action
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.494.1">
     Since the Antelope version, OSProfiler can trace all the OpenStack core services in addition to other projects.
    </span>
    <span class="koboSpan" id="kobo.494.2">
     The
    </span>
    <a id="_idIndexMarker877">
    </a>
    <span class="koboSpan" id="kobo.495.1">
     OpenStack community aims to use OSProfiler for all OpenStack projects without exception due to its light and powerful tracing capabilities.
    </span>
    <span class="koboSpan" id="kobo.495.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.496.1">
      kolla-ansible
     </span>
    </strong>
    <span class="koboSpan" id="kobo.497.1">
     infrastructure already supports OSProfiler, which can be installed easily.
    </span>
    <span class="koboSpan" id="kobo.497.2">
     OSProfiler can be enabled by configuring the following settings in the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.498.1">
       globals.yml
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.499.1">
      file:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.500.1">
enable_osprofiler: "yes"
enable_elasticsearch: "yes"</span></pre>
   <p>
    <span class="koboSpan" id="kobo.501.1">
     Note that OSProfiler uses Elasticsearch as a backend to store the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.502.1">
      tracing data.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.503.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.504.1">
     If
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.505.1">
      enable_elasticsearch
     </span>
    </strong>
    <span class="koboSpan" id="kobo.506.1">
     is set to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.507.1">
      "no"
     </span>
    </strong>
    <span class="koboSpan" id="kobo.508.1">
     , Kolla will install and use Redis as a default backend
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.509.1">
      for OSProfiler.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.510.1">
     OSProfiler does not need to be installed on a dedicated host.
    </span>
    <span class="koboSpan" id="kobo.510.2">
     At the time of writing, OpenStack
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.511.1">
      kolla-ansible
     </span>
    </strong>
    <span class="koboSpan" id="kobo.512.1">
     supports OSProfiler for Keystone, Nova, Glance, Cinder, Neutron, Placement, Swift, Heat, Trove, Senlin,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.513.1">
      and Vitrage.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.514.1">
     Once the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.515.1">
      globals.yml
     </span>
    </strong>
    <span class="koboSpan" id="kobo.516.1">
     file is updated and pushed, run the pipeline and the OSProfiler library should be installed.
    </span>
    <span class="koboSpan" id="kobo.516.2">
     Before starting a profiling exercise, we will need to retrieve the generated OSProfiler
    </span>
    <a id="_idIndexMarker878">
    </a>
    <span class="koboSpan" id="kobo.517.1">
     secret referenced by the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.518.1">
      osprofiler_secret
     </span>
    </strong>
    <span class="koboSpan" id="kobo.519.1">
     key in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.520.1">
      /etc/kolla/passwords.yml
     </span>
    </strong>
    <span class="koboSpan" id="kobo.521.1">
     file.
    </span>
    <span class="koboSpan" id="kobo.521.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.522.1">
      osprofiler_secret
     </span>
    </strong>
    <span class="koboSpan" id="kobo.523.1">
     key will be used to create profiler UUIDs with OpenStack client command lines for supported services.
    </span>
    <span class="koboSpan" id="kobo.523.2">
     The next example illustrates a tracing exercise of a Glance API call, as demonstrated in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.524.1">
      following steps:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.525.1">
      Use the official OpenStack Python client running in a cloud controller node to generate a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.526.1">
       tracing output:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.527.1">$ openstack --os-profile &lt;OSPROFILER_SECRET&gt; image list</span></strong></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.528.1">
       This is the output
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.529.1">
        we get:
       </span>
      </span>
     </p>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer179">
     <span class="koboSpan" id="kobo.530.1">
      <img alt="Figure 9.14 – OSProfiler image list" src="image/B21716_09_14.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.531.1">
     Figure 9.14 – OSProfiler image list
    </span>
   </p>
   <p class="list-inset">
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.532.1">
      &lt;OSPROFILER_SECRET&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.533.1">
     is the retrieved OSProfiler secret retrieved from the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.534.1">
      /etc/kolla/passwords.yml
     </span>
    </strong>
    <span class="koboSpan" id="kobo.535.1">
     file referenced in the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.536.1">
       osprofiler_secret
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.537.1">
      parameter.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.538.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.539.1">
     It is possible to customize the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.540.1">
      OSPROFILER_SECRET
     </span>
    </strong>
    <span class="koboSpan" id="kobo.541.1">
     value for each supported service by configuring the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.542.1">
      hmac_keys
     </span>
    </strong>
    <span class="koboSpan" id="kobo.543.1">
     setting in each configuration file that corresponds to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.544.1">
      that service.
     </span>
    </span>
   </p>
   <p class="list-inset">
    <span class="koboSpan" id="kobo.545.1">
     The command line returns an OSProfiler tracing command line,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.546.1">
      as follows:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer180">
     <span class="koboSpan" id="kobo.547.1">
      <img alt="Figure 9.15 – An OSProfiler trace command output" src="image/B21716_09_15.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.548.1">
     Figure 9.15 – An OSProfiler trace command output
    </span>
   </p>
   <ol>
    <li value="2">
     <span class="koboSpan" id="kobo.549.1">
      Use the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.550.1">
       osprofiler
      </span>
     </strong>
     <span class="koboSpan" id="kobo.551.1">
      command line to print the tracing graph in HTML format.
     </span>
     <span class="koboSpan" id="kobo.551.2">
      The retrieved tracing data can be stored locally in the created
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.552.1">
       Elasticsearch instance:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.553.1">$ osprofiler trace show --html 75da221e-ffe1-7dac-aae7-22eaed337761 --connection-string elasticsearch://localhost:9200 --out "/tmp/image_perf.html"</span></strong></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.554.1">
       An HTML report
      </span>
      <a id="_idIndexMarker879">
      </a>
      <span class="koboSpan" id="kobo.555.1">
       should be available locally under the
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.556.1">
        /
       </span>
      </strong>
      <span class="No-Break">
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.557.1">
         tmp
        </span>
       </strong>
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.558.1">
        directory.
       </span>
      </span>
     </p>
    </li>
    <li>
     <span class="koboSpan" id="kobo.559.1">
      Visualize the tracing results by accessing the generated
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.560.1">
       image_perf.html
      </span>
     </strong>
     <span class="koboSpan" id="kobo.561.1">
      file in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.562.1">
       a browser:
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer181">
     <span class="koboSpan" id="kobo.563.1">
      <img alt="Figure 9.16 – An example of OSProfiler tracing results" src="image/B21716_09_16.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.564.1">
     Figure 9.16 – An example of OSProfiler tracing results
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.565.1">
     The generated HTML report exposes, for each request made at the time of processing of each call, the nature of the service call (API, database, etc.) and its corresponding project.
    </span>
    <span class="koboSpan" id="kobo.565.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.566.1">
      Levels
     </span>
    </strong>
    <span class="koboSpan" id="kobo.567.1">
     column corresponds to a traced point that includes a low level of detailed information in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.568.1">
      JSON format.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.569.1">
     Tracing is a great practice to debug at a low level what cannot be detected in your monitoring system or overlooked in the log data.
    </span>
    <span class="koboSpan" id="kobo.569.2">
     Both profiling and benchmarking provide sufficient information about cloud performance and the trend of resource utilization.
    </span>
    <span class="koboSpan" id="kobo.569.3">
     As the cloud infrastructure keeps receiving new tenants, more hardware demands will increase.
    </span>
    <span class="koboSpan" id="kobo.569.4">
     If this is not watched and analyzed from the early days, the cost can rise and the risks will be out of control.
    </span>
    <span class="koboSpan" id="kobo.569.5">
     Operators should be provided with strategies and tooling to
    </span>
    <a id="_idIndexMarker880">
    </a>
    <span class="koboSpan" id="kobo.570.1">
     automate budget control and management.
    </span>
    <span class="koboSpan" id="kobo.570.2">
     One of the best approaches with limited resources is to seek optimization, which will be covered in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.571.1">
      next section.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-168">
    <a id="_idTextAnchor213">
    </a>
    <span class="koboSpan" id="kobo.572.1">
     Watching the cloud
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.573.1">
     Once your cloud environment has started to expand and more hardware resources are deployed, cloud operators should find ways to optimize costs.
    </span>
    <span class="koboSpan" id="kobo.573.2">
     There are niche use cases, such as optimizing the placement of VMs (VMs migrate between hosts in case of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.574.1">
      imbalance detection).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.575.1">
     The lack of tooling and efficient processes to conduct a resource optimization exercise presents a big challenge to private cloud operators.
    </span>
    <span class="koboSpan" id="kobo.575.2">
     Traditionally, OpenStack administrators needed to manually grab historical metrics on resource usage, analyze them in regular sprints, and make decisions based on the collected data.
    </span>
    <span class="koboSpan" id="kobo.575.3">
     However, manual processing in a large OpenStack deployment can be error prone.
    </span>
    <span class="koboSpan" id="kobo.575.4">
     To automate such a process, the OpenStack
    </span>
    <a id="_idIndexMarker881">
    </a>
    <span class="koboSpan" id="kobo.576.1">
     community has come up with an evolving incubated project code named
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.577.1">
      Watcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.578.1">
     .
    </span>
    <span class="koboSpan" id="kobo.578.2">
     The main objective of the Watcher project is to enable new ways for cloud operators to reduce the cloud’s
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.579.1">
      Total Cost of Ownership
     </span>
    </strong>
    <span class="koboSpan" id="kobo.580.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.581.1">
      TCO
     </span>
    </strong>
    <span class="koboSpan" id="kobo.582.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.582.2">
     Watcher is designed to
    </span>
    <a id="_idIndexMarker882">
    </a>
    <span class="koboSpan" id="kobo.583.1">
     monitor, analyze, and execute optimization tasks based on predefined goals.
    </span>
    <span class="koboSpan" id="kobo.583.2">
     The following diagram illustrates how Watcher’s continuous optimization loop is designed through a set
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.584.1">
      of steps:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer182">
     <span class="koboSpan" id="kobo.585.1">
      <img alt="Figure 9.17 – OpenStack’s Watcher steps workflow" src="image/B21716_09_17.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.586.1">
     Figure 9.17 – OpenStack’s Watcher steps workflow
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.587.1">
     It starts with the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.588.1">
      Monitor
     </span>
    </strong>
    <span class="koboSpan" id="kobo.589.1">
     state, where
    </span>
    <a id="_idIndexMarker883">
    </a>
    <span class="koboSpan" id="kobo.590.1">
     data metrics are collected from various data sources, such as the type of CPU, memory utilization, and energy consumption.
    </span>
    <span class="koboSpan" id="kobo.590.2">
     Then, the collected information is analyzed and aggregated.
    </span>
    <span class="koboSpan" id="kobo.590.3">
     Watcher then engages a profiler component that concludes a few patterns and uses that to predict VM resource utilization.
    </span>
    <span class="koboSpan" id="kobo.590.4">
     An optimization plan will be created by an
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.591.1">
      Optimizer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.592.1">
     component by taking
    </span>
    <a id="_idIndexMarker884">
    </a>
    <span class="koboSpan" id="kobo.593.1">
     a set of goals and constraints as inputs, for example, by creating some collocation rules such as affinity and anti-affinity rules in the Nova scheduler.
    </span>
    <span class="koboSpan" id="kobo.593.2">
     Watcher will make scheduling decisions based on such inputs and can leverage some of the other constraints defined by other projects.
    </span>
    <span class="koboSpan" id="kobo.593.3">
     The
    </span>
    <a id="_idIndexMarker885">
    </a>
    <span class="koboSpan" id="kobo.594.1">
     next stage runs the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.595.1">
      Planner
     </span>
    </strong>
    <span class="koboSpan" id="kobo.596.1">
     component, so Watcher builds action items, for example, if a VM needs to be migrated from one host to another.
    </span>
    <span class="koboSpan" id="kobo.596.2">
     In the Plan phase, Watcher puts a set of steps that can be acted upon and ordered to run serially or in parallel.
    </span>
    <span class="koboSpan" id="kobo.596.3">
     Finally, Watcher executes the action plan and applies the optimal state of the infrastructure as specified in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.597.1">
      defined goals.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.598.1">
     The next section will go through the installation of the Watcher project in the existing OpenStack environment using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.599.1">
      kolla-ansible
     </span>
    </strong>
    <span class="koboSpan" id="kobo.600.1">
     and demonstrate
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.601.1">
      its usage.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-169">
    <a id="_idTextAnchor214">
    </a>
    <span class="koboSpan" id="kobo.602.1">
     Watcher in action
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.603.1">
     The latest
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.604.1">
      kolla-ansible
     </span>
    </strong>
    <span class="koboSpan" id="kobo.605.1">
     code releases come with the Watcher playbook ready for installation.
    </span>
    <span class="koboSpan" id="kobo.605.2">
     Keystone, Nova, and Ceilometer must be running before installing Watcher.
    </span>
    <span class="koboSpan" id="kobo.605.3">
     In the following setup, all Watcher
    </span>
    <a id="_idIndexMarker886">
    </a>
    <span class="koboSpan" id="kobo.606.1">
     components, including
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.607.1">
      watcher-api
     </span>
    </strong>
    <span class="koboSpan" id="kobo.608.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.609.1">
      watcher-engine
     </span>
    </strong>
    <span class="koboSpan" id="kobo.610.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.611.1">
      watcher-applier
     </span>
    </strong>
    <span class="koboSpan" id="kobo.612.1">
     , will be part of the cloud controller node group.
    </span>
    <span class="koboSpan" id="kobo.612.2">
     To install
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.613.1">
      watcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.614.1">
     components, configure the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.615.1">
      multi_packtpub_prod
     </span>
    </strong>
    <span class="koboSpan" id="kobo.616.1">
     inventory file by adding the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.617.1">
      following section:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.618.1">
...
</span><span class="koboSpan" id="kobo.618.2">[watcher:children]
control
[watcher-api:children]
watcher
[watcher-engine:children]
watcher
[watcher-applier:children]
watcher</span></pre>
   <p>
    <span class="koboSpan" id="kobo.619.1">
     Next, enable the Watcher service in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.620.1">
      globals.yml
     </span>
    </strong>
    <span class="koboSpan" id="kobo.621.1">
     file by adjusting the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.622.1">
      configuration line:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.623.1">
enable_watcher: "yes"</span></pre>
   <p>
    <span class="koboSpan" id="kobo.624.1">
     The Watcher service comes with a Horizon plugin that will be visible on the Horizon dashboard once installed.
    </span>
    <span class="koboSpan" id="kobo.624.2">
     Commit the changes and run the pipeline.
    </span>
    <span class="koboSpan" id="kobo.624.3">
     Once finished, check the new Docker containers for the Watcher service by running the following command line in any of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.625.1">
      controller nodes:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.626.1">
$ sudo docker ps | grep watcher</span></pre>
   <p>
    <span class="koboSpan" id="kobo.627.1">
     Here is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.628.1">
      the output:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer183">
     <span class="koboSpan" id="kobo.629.1">
      <img alt="Figure 9.18 – A Watcher deployment check" src="image/B21716_09_18.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.630.1">
     Figure 9.18 – A Watcher deployment check
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.631.1">
     Before starting to use the Watcher service, it is important to highlight the different steps of a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.632.1">
      Watcher workflow:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.633.1">
      Create an optimization goal and associate it with
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.634.1">
       a strategy.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.635.1">
      Create an audit template that is associated with the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.636.1">
       optimization goal.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.637.1">
      Create an audit that will be triggered by the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.638.1">
       audit template.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.639.1">
      Generate an action plan by the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.640.1">
       created audit.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.641.1">
      Take action either manually or in an
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.642.1">
       automatic fashion.
      </span>
     </span>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.643.1">
     In the following part of
    </span>
    <a id="_idIndexMarker887">
    </a>
    <span class="koboSpan" id="kobo.644.1">
     this section, we will demonstrate a predefined Watcher strategy, which is referred to as the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.645.1">
      VM Workload Consolidation Strategy
     </span>
    </strong>
    <span class="koboSpan" id="kobo.646.1">
     .
    </span>
    <span class="koboSpan" id="kobo.646.2">
     The goal of such a
    </span>
    <a id="_idIndexMarker888">
    </a>
    <span class="koboSpan" id="kobo.647.1">
     strategy is to consolidate a running workload in the cloud and optimize the number of resources that
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.648.1">
      run it.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.649.1">
     To quickly check the predefined list of goals in Watcher, run the following command line and take note of the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.650.1">
      Server Consolidation
     </span>
    </strong>
    <span class="koboSpan" id="kobo.651.1">
     goal
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.652.1">
      UUID
     </span>
    </strong>
    <span class="koboSpan" id="kobo.653.1">
     or
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.654.1">
      Name
     </span>
    </strong>
    <span class="koboSpan" id="kobo.655.1">
     in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.656.1">
      the output:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.657.1">
$ openstack optimize goal list</span></pre>
   <p>
    <span class="koboSpan" id="kobo.658.1">
     The output is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.659.1">
      as follows:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer184">
     <span class="koboSpan" id="kobo.660.1">
      <img alt="Figure 9.19 – Watcher optimization goal listing" src="image/B21716_09_19.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.661.1">
     Figure 9.19 – Watcher optimization goal listing
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.662.1">
     Next, obtain the list of available strategies for the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.663.1">
      Server Consolidation
     </span>
    </strong>
    <span class="koboSpan" id="kobo.664.1">
     goal using the listed goal
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.665.1">
      UUID
     </span>
    </strong>
    <span class="koboSpan" id="kobo.666.1">
     or
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.667.1">
      Name
     </span>
    </strong>
    <span class="koboSpan" id="kobo.668.1">
     from the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.669.1">
      previous output:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.670.1">
$ openstack optimize strategy list --goal 8726da12-01da-42b5-65da-86165daca514</span></pre>
   <p>
    <span class="koboSpan" id="kobo.671.1">
     We get the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.672.1">
      output now:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer185">
     <span class="koboSpan" id="kobo.673.1">
      <img alt="Figure 9.20 – A Watcher optimization strategy listing" src="image/B21716_09_20.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.674.1">
     Figure 9.20 – A Watcher optimization strategy listing
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.675.1">
     From the returned list of strategies, we will use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.676.1">
      vm_workload_consolidation
     </span>
    </strong>
    <span class="koboSpan" id="kobo.677.1">
     strategy to minimize the number of hosts running a workload with respect to resource capacity constraints.
    </span>
    <span class="koboSpan" id="kobo.677.2">
     Before creating the audit template, we can check the distribution of the instances across different
    </span>
    <a id="_idIndexMarker889">
    </a>
    <span class="koboSpan" id="kobo.678.1">
     hypervisor machines before applying the selected optimization strategy in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.679.1">
      Watcher panel:
     </span>
    </span>
   </p>
   <p class="IMG---Figure">
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer186">
     <span class="koboSpan" id="kobo.680.1">
      <img alt="Figure 9.21 – The instance distribution state before the optimization is applied" src="image/B21716_09_21.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.681.1">
     Figure 9.21 – The instance distribution state before the optimization is applied
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.682.1">
     The
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.683.1">
      Hypervisor
     </span>
    </strong>
    <span class="koboSpan" id="kobo.684.1">
     list is composed of three compute nodes and the specific distribution of instances spread
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.685.1">
      across them.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.686.1">
     In the next step, create an audit template associated with the selected goal and the chosen strategy by running the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.687.1">
      command line:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.688.1">
$ openstack optimize audittemplate create consolidation_template 8726da12-01da-42b5-65da-86165daca514 --strategy cdc1244d-0eb2-3312-9871-987daca123da</span></pre>
   <p>
    <span class="koboSpan" id="kobo.689.1">
     Here is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.690.1">
      the output:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer187">
     <span class="koboSpan" id="kobo.691.1">
      <img alt="Figure 9.22 – Watcher optimization audit template creation" src="image/B21716_09_22.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.692.1">
     Figure 9.22 – Watcher optimization audit template creation
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.693.1">
     Next, run an audit from the
    </span>
    <a id="_idIndexMarker890">
    </a>
    <span class="koboSpan" id="kobo.694.1">
     created audit template,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.695.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.696.1">
$ openstack optimize audit create -a consolidation-template</span></pre>
   <p>
    <span class="koboSpan" id="kobo.697.1">
     The output is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.698.1">
      as follows:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer188">
     <span class="koboSpan" id="kobo.699.1">
      <img alt="Figure 9.23 – Watcher optimization audit creation" src="image/B21716_09_23.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.700.1">
     Figure 9.23 – Watcher optimization audit creation
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.701.1">
     Note that the audit creation may take longer to complete.
    </span>
    <span class="koboSpan" id="kobo.701.2">
     The
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.702.1">
      State
     </span>
    </strong>
    <span class="koboSpan" id="kobo.703.1">
     field shows
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.704.1">
      PENDING
     </span>
    </strong>
    <span class="koboSpan" id="kobo.705.1">
     .
    </span>
    <span class="koboSpan" id="kobo.705.2">
     During that state, the audit request is treated by the Watcher decision engine, which passes the
    </span>
    <a id="_idIndexMarker891">
    </a>
    <span class="koboSpan" id="kobo.706.1">
     requested audit to the next state.
    </span>
    <span class="koboSpan" id="kobo.706.2">
     If the Watcher decision engine finds at least one optimization option that can be applied within the set of the audited resources (compute nodes for the context of the current goal and strategy), the audit state will change
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.707.1">
      to
     </span>
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.708.1">
       SUCCEEDED
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.709.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.710.1">
     Use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.711.1">
      optimize audit show
     </span>
    </strong>
    <span class="koboSpan" id="kobo.712.1">
     command with the generated audit UUID and verify whether the status of the audit creation
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.713.1">
      is completed:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.714.1">
$ openstack optimize audit show da23a982-deaa-3231-3120-237dea123cba</span></pre>
   <p>
    <span class="koboSpan" id="kobo.715.1">
     Here is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.716.1">
      the output:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer189">
     <span class="koboSpan" id="kobo.717.1">
      <img alt="Figure 9.24 – Watcher optimization audit validation" src="image/B21716_09_24.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.718.1">
     Figure 9.24 – Watcher optimization audit validation
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.719.1">
     For each created audit, the optimization service generates an action plan.
    </span>
    <span class="koboSpan" id="kobo.719.2">
     An action plan defines which tasks need to be executed to achieve the goal set at the start.
    </span>
    <span class="koboSpan" id="kobo.719.3">
     Action plans use advanced algorithms and
    </span>
    <a id="_idIndexMarker892">
    </a>
    <span class="koboSpan" id="kobo.720.1">
     return some pertinent information, such as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.721.1">
      efficacy indicators
     </span>
    </strong>
    <span class="koboSpan" id="kobo.722.1">
     (reflects an improvement score based on the generated
    </span>
    <a id="_idIndexMarker893">
    </a>
    <span class="koboSpan" id="kobo.723.1">
     audit solution) and global efficacy (general scoring for the evaluated
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.724.1">
      action plan).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.725.1">
     Once the audit creation status changes to
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.726.1">
      SUCCEEDED
     </span>
    </strong>
    <span class="koboSpan" id="kobo.727.1">
     , run the following command line with the audit UUID to retrieve the action plan generated by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.728.1">
      the audit:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.729.1">
$ openstack optimize actionplan list --audit da23a982-deaa-3231-3120-237dea123cba</span></pre>
   <p>
    <span class="koboSpan" id="kobo.730.1">
     The output is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.731.1">
      as follows:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer190">
     <span class="koboSpan" id="kobo.732.1">
      <img alt="Figure 9.25 – Watcher optimization action plan listing" src="image/B21716_09_25.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.733.1">
     Figure 9.25 – Watcher optimization action plan listing
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.734.1">
     Note in the previous output that the Watcher planner has created an action plan that is waiting for operator validation.
    </span>
    <span class="koboSpan" id="kobo.734.2">
     The
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.735.1">
      RECOMMENDED
     </span>
    </strong>
    <span class="koboSpan" id="kobo.736.1">
     state is the last step performed by the Planner component.
    </span>
    <span class="koboSpan" id="kobo.736.2">
     From the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.737.1">
      Global efficacy
     </span>
    </strong>
    <span class="koboSpan" id="kobo.738.1">
     information, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.739.1">
      watcher-planner
     </span>
    </strong>
    <span class="koboSpan" id="kobo.740.1">
     process has concluded that around 33% of compute nodes can be pulled back while maintaining the same amount of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.741.1">
      running workloads.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.742.1">
     The returned action plan line is not sufficient to go through all the different action items.
    </span>
    <span class="koboSpan" id="kobo.742.2">
     There is a separate command line for that purpose.
    </span>
    <span class="koboSpan" id="kobo.742.3">
     Before applying any action plan, an operator should review
    </span>
    <a id="_idIndexMarker894">
    </a>
    <span class="koboSpan" id="kobo.743.1">
     the associated actions as follows.
    </span>
    <span class="koboSpan" id="kobo.743.2">
     Run the following command line with the action plan UUID generated in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.744.1">
      previous step:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.745.1">
$ openstack optimize action list --action-plan 23a766da-77da-2361-bca1-efeda124870d</span></pre>
   <p>
    <span class="koboSpan" id="kobo.746.1">
     The action plan lists all items that will be actioned.
    </span>
    <span class="koboSpan" id="kobo.746.2">
     The following list is a truncated version for a longer output that indicates the change of the Nova service’s state in the first line.
    </span>
    <span class="koboSpan" id="kobo.746.3">
     The following lines are the planned action based on the first item that will be executed serially.
    </span>
    <span class="koboSpan" id="kobo.746.4">
     Each following action item is a recommendation of the Watcher planner to migrate a set of instances once the parent action (the Nova service’s state)
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.747.1">
      is updated:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer191">
     <span class="koboSpan" id="kobo.748.1">
      <img alt="Figure 9.26 – Watcher optimization action listing" src="image/B21716_09_26.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.749.1">
     Figure 9.26 – Watcher optimization action listing
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.750.1">
     Once reviewed, an operator can go ahead and run the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.751.1">
      watcher-applier
     </span>
    </strong>
    <span class="koboSpan" id="kobo.752.1">
     process to execute the action plan by running the following command line with the action
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.753.1">
      plan UUID:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.754.1">
$ openstack optimize actionplan start 23a766da-77da-2361-bca1-efeda124870d</span></pre>
   <p>
    <span class="koboSpan" id="kobo.755.1">
     The output can be quite large
    </span>
    <a id="_idIndexMarker895">
    </a>
    <span class="koboSpan" id="kobo.756.1">
     due to the values assigned to action plan
    </span>
    <a id="_idIndexMarker896">
    </a>
    <span class="koboSpan" id="kobo.757.1">
     indicators (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.758.1">
      Efficacy indicators
     </span>
    </strong>
    <span class="koboSpan" id="kobo.759.1">
     and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.760.1">
      Global efficacy
     </span>
    </strong>
    <span class="koboSpan" id="kobo.761.1">
     embedded JSON values).
    </span>
    <span class="koboSpan" id="kobo.761.2">
     A simple truncated version can be visualized
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.762.1">
      as follows:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer192">
     <span class="koboSpan" id="kobo.763.1">
      <img alt="Figure 9.27 – Watcher optimization action start" src="image/B21716_09_27.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.764.1">
     Figure 9.27 – Watcher optimization action start
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.765.1">
     Most importantly, note the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.766.1">
      PENDING
     </span>
    </strong>
    <span class="koboSpan" id="kobo.767.1">
     state of the action plan execution.
    </span>
    <span class="koboSpan" id="kobo.767.2">
     That is expected to keep running for a longer time due to the migration of a set of instance tasks in the background.
    </span>
    <span class="koboSpan" id="kobo.767.3">
     The
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.768.1">
      Efficacy indicators
     </span>
    </strong>
    <span class="koboSpan" id="kobo.769.1">
     and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.770.1">
      Global efficacy
     </span>
    </strong>
    <span class="koboSpan" id="kobo.771.1">
     fields simply reflect a description of the
    </span>
    <a id="_idIndexMarker897">
    </a>
    <span class="koboSpan" id="kobo.772.1">
     recommended action plan that can be summarized
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.773.1">
      as follows:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.774.1">
       Efficacy indicators
      </span>
     </strong>
     <span class="koboSpan" id="kobo.775.1">
      : This refers to the number of compute nodes in which the
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.776.1">
       Applier
      </span>
     </strong>
     <span class="koboSpan" id="kobo.777.1">
      component is performing optimization actions.
     </span>
     <span class="koboSpan" id="kobo.777.2">
      In our example, we are dealing with three nodes.
     </span>
     <span class="koboSpan" id="kobo.777.3">
      As recommended, the audit aims to release one compute node from the three.
     </span>
     <span class="koboSpan" id="kobo.777.4">
      Additionally, the indicator keeps counting each migrated instance reported by the Nova service when accomplished.
     </span>
     <span class="koboSpan" id="kobo.777.5">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.778.1">
       instance_migrations_count
      </span>
     </strong>
     <span class="koboSpan" id="kobo.779.1">
      recommendation indicates that the number of instance migrations to be performed
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.780.1">
       is
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.781.1">
        2
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.782.1">
       .
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.783.1">
       Global efficacy
      </span>
     </strong>
     <span class="koboSpan" id="kobo.784.1">
      : This is the ratio of nodes aimed to be released once all action items are executed.
     </span>
     <span class="koboSpan" id="kobo.784.2">
      The ratio is obtained by dividing the number of released compute nodes by the total number of compute nodes in the audit scope.
     </span>
     <span class="koboSpan" id="kobo.784.3">
      In our case, the ratio will be
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.785.1">
       approximately 33%.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.786.1">
     You can run the previous command line several times and notice the change of the action plan execution state from
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.787.1">
      PENDING
     </span>
    </strong>
    <span class="koboSpan" id="kobo.788.1">
     to
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.789.1">
      ONGOING
     </span>
    </strong>
    <span class="koboSpan" id="kobo.790.1">
     .
    </span>
    <span class="koboSpan" id="kobo.790.2">
     Once all migration tasks are performed, the state of the action plan should be updated to
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.791.1">
      SUCCEEDED
     </span>
    </strong>
    <span class="koboSpan" id="kobo.792.1">
     with the execution summary in the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.793.1">
      Efficacy indicators
     </span>
    </strong>
    <span class="koboSpan" id="kobo.794.1">
     and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.795.1">
      Global
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.796.1">
       efficacy
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.797.1">
      fields:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.798.1">
$ openstack optimize actionplan start 23a766da-77da-2361-bca1-efeda124870d</span></pre>
   <p>
    <span class="koboSpan" id="kobo.799.1">
     The output is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.800.1">
      as follows:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer193">
     <span class="koboSpan" id="kobo.801.1">
      <img alt="Figure 9.28 – Watcher optimization action plan start" src="image/B21716_09_28.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.802.1">
     Figure 9.28 – Watcher optimization action plan start
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.803.1">
     By checking the Watcher dashboard, we can notice the change in the instance counts across the listed hypervisors where
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.804.1">
      cn01.os
     </span>
    </strong>
    <span class="koboSpan" id="kobo.805.1">
     becomes completely free.
    </span>
    <span class="koboSpan" id="kobo.805.2">
     Watcher has determined that a given workload
    </span>
    <a id="_idIndexMarker898">
    </a>
    <span class="koboSpan" id="kobo.806.1">
     can run in two compute nodes instead of three, leaving one hypervisor machine’s resources free,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.807.1">
      as shown:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer194">
     <span class="koboSpan" id="kobo.808.1">
      <img alt="Figure 9.29 – The instance distribution state after optimization is applied" src="image/B21716_09_29.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.809.1">
     Figure 9.29 – The instance distribution state after optimization is applied
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.810.1">
     With this optimization achievement, cloud operators should get more free resources to route requests to for future workloads.
    </span>
    <span class="koboSpan" id="kobo.810.2">
     Predefined goals are a great start to performing optimization exercises.
    </span>
    <span class="koboSpan" id="kobo.810.3">
     Operators can define custom strategies and goals for different cases based on workload needs as well as the scheduling mechanism that has already been configured.
    </span>
    <span class="koboSpan" id="kobo.810.4">
     From a big-picture perspective, a well-defined filtering and scheduling configuration is beneficial not only to tackle customization on compute resources and allocation but also to help the Watcher planner find the best optimization options.
    </span>
    <span class="koboSpan" id="kobo.810.5">
     That will save operational overhead and a good amount
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.811.1">
      of costs.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-170">
    <a id="_idTextAnchor215">
    </a>
    <span class="koboSpan" id="kobo.812.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.813.1">
     In this chapter, we brought our OpenStack setup to the next level by highlighting a few advanced settings that leverage its performance, such as the database.
    </span>
    <span class="koboSpan" id="kobo.813.2">
     You should now understand the necessity for undergoing rigorous and effective testing of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.814.1">
      cloud platform.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.815.1">
     There is a learning curve in the art of benchmarking, which gives insight into all facets of the components running in the OpenStack environment, including system hardware and software resources.
    </span>
    <span class="koboSpan" id="kobo.815.2">
     The chapter highlighted a tiny component, OSProfiler, that can be installed easily in OpenStack to trace and debug requests traveling across the OpenStack services.
    </span>
    <span class="koboSpan" id="kobo.815.3">
     With a complete view of requests, operators can collect more data and generate a detailed service map that can be used for further performance analytics.
    </span>
    <span class="koboSpan" id="kobo.815.4">
     The last part of the chapter drew upon best practices relating to resource optimization and automating recommendations when opportunities exist to reduce costs and improve performance.
    </span>
    <span class="koboSpan" id="kobo.815.5">
     With Watcher, operators will not need to seek a third-party solution unless more functionalities are required.
    </span>
    <span class="koboSpan" id="kobo.815.6">
     Benchmarking, profiling, and optimization practices should be performed periodically.
    </span>
    <span class="koboSpan" id="kobo.815.7">
     Although the chapter did not cover how to automate those practices, creating dedicated pipelines for each benchmarking, profiling, and optimization process is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.816.1">
      highly recommended.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.817.1">
     This chapter closes the second part of this book.
    </span>
    <span class="koboSpan" id="kobo.817.2">
     In the next part, we will look at some recent and modern approaches that leverage the benefits of private and public clouds.
    </span>
    <span class="koboSpan" id="kobo.817.3">
     In the next chapter, we will go through some common cloud hybrid design patterns where OpenStack continues
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.818.1">
      to shine.
     </span>
    </span>
   </p>
  </div>
 

  <div class="Content" id="_idContainer196">
   <h1 id="_idParaDest-171" lang="en-US" xml:lang="en-US">
    <a id="_idTextAnchor216">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     Part 3: Extending the OpenStack Cloud
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.2.1">
     The final part of the book will crystallize a trendy topic covering the adoption of a hybrid cloud setup.
    </span>
    <span class="koboSpan" id="kobo.2.2">
     Using OpenStack as a private cloud environment joined with a public cloud provider, this part of the book will demonstrate how to leverage both cloud models to spread workloads in the most efficient and cost-saving ways.
    </span>
    <span class="koboSpan" id="kobo.2.3">
     Empowered with microservices design patterns and containerization technology, this part will explore different tools and ways to run a workload based on Kubernetes across a running private cloud based on OpenStack and a public cloud based
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.3.1">
      on AWS.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.4.1">
     This part has the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.5.1">
      following chapters:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <a href="B21716_10.xhtml#_idTextAnchor217">
      <em class="italic">
       <span class="koboSpan" id="kobo.6.1">
        Chapter 10
       </span>
      </em>
     </a>
     <span class="koboSpan" id="kobo.7.1">
      ,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.8.1">
       OpenStack Hybrid Cloud – Design Patterns
      </span>
     </em>
    </li>
    <li>
     <a href="B21716_11.xhtml#_idTextAnchor230">
      <em class="italic">
       <span class="koboSpan" id="kobo.9.1">
        Chapter 11
       </span>
      </em>
     </a>
     <span class="koboSpan" id="kobo.10.1">
      ,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.11.1">
       A Hybrid Cloud Hyperscale Use Case – Scaling a Kubernetes Workload
      </span>
     </em>
    </li>
   </ul>
  </div>
  <div>
   <div id="_idContainer197">
   </div>
  </div>
  <div>
   <div id="_idContainer198">
   </div>
  </div>
  <div>
   <div id="_idContainer199">
   </div>
  </div>
  <div>
   <div id="_idContainer200">
   </div>
  </div>
  <div>
   <div id="_idContainer201">
   </div>
  </div>
  <div>
   <div class="Basic-Graphics-Frame" id="_idContainer202">
   </div>
  </div>
  <div>
   <div class="Basic-Graphics-Frame" id="_idContainer203">
   </div>
  </div>
  <div>
   <div id="_idContainer204">
   </div>
  </div>
  <div>
   <div id="_idContainer205">
   </div>
  </div>
  <div>
   <div class="Basic-Graphics-Frame" id="_idContainer206">
   </div>
  </div>
 </body></html>