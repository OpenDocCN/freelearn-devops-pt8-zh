- en: Enterprise Integration - Azure Service Bus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, to integrate our applications using messaging solutions, we need
    something more than a simple pipeline, which offers limited capabilities when
    it comes to distributing data and filtering it. Topics, filters, and many more
    features are available in Azure Service Bus, an enterprise-level solution designed
    for providing a reliable, scalable, and efficient way for sending messages to
    multiple receivers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with Azure Service Bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fundamentals—queues, topics, and relays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing Azure Service Bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The advanced features like geo-replication, sessions, or dead lettering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling outages and disasters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To perform the exercises in this chapter, you will need:'
  prefs: []
  type: TYPE_NORMAL
- en: Access to a Microsoft Azure subscription
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Visual Studio 2017 instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code (if you don't have a Visual Studio 2017 instance)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Service Bus fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have already learned about other messaging solutions, which allow you to
    ease communication between your services, and all are characterized by different
    features. In Azure Event Hub,you were able to process thousands of messages per
    second, while with Azure Storage Queuesyou were given a reliable and durable solution,
    which you could use to work asynchronously on ingested data. In this chapter,
    we will discuss Azure Service Bus, a multitenant cloud messaging service that
    introduces advanced concepts like first-in,first-out(FIFO) messaging, dead lettering,
    or transactions. It is an enterprise-class cloud component able to integrate many
    different services and applications.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Service Bus versus other messaging services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapters, we discussed the following services, which allowed
    us to process messages:'
  prefs: []
  type: TYPE_NORMAL
- en: Azure Event Hub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Storage Queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Event Grid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'They all have similarities, yet they are designed to serve different features
    and offer different capabilities. We often use the concepts of eventsand messagesalternately.
    In fact, there is a slight difference between them and understanding this is crucial
    to be able to use different messaging services successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event**: It carries the information that something happened—the fact that
    someone or something produced an event does not imply any expectations regarding
    how an event should be handled. Events, in general, are lightweight information
    carriers and do not bring the full data to the receiver.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message**: As opposed to an event, when a producer sends a message, it has
    some expectation about how it will be handled (so there is some kind of a contract
    between a producer and a consumer). What is more, a message carries the raw data
    while an event implies that something happened; a message indicates that a component
    has initialized a communication, which should be handled in the usual way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now you can recall what you have learned about, for example, Azure Event Gridor Azure
    Event Hub—they both have an eventin the name, but work in quite different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure Event Grid**: It is designed to distribute events and react to changes.
    It delivers only the metadata, and the actual message has to be fetched individually;
    thus, it can be said, that it distributes events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Event Hub**: It works as a big data pipeline and streams events to
    other services. Depending on your implementation, it can stream both eventsand messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s compare Service Bus:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure Service Bus**: It was created to support critical processes, which
    have high requirements regarding the order of processing and reliability of the
    messaging service. You can use it when a messagecannot be lost or duplicated.
    It does not work with the concept of events—instead, it allows you to push the
    whole data, which can be read by a consumer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Service Bus and Azure Storage Queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may wonder what the difference between Azure Service Busand Azure Storage
    Queues is. In fact, they are both messaging solutions, which are reliable, durable,
    and can handle multiple messages at once. However, looking more closely, you can
    see they are quite different services, built using different concepts and for
    a different purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: Azure Storage Queuesolutions are forced to poll the queue to receive a message—with Azure
    Service Busyou can establish a long-polling receive operation via TCP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Azure Storage Queue,you can store messages of up to 64 KB—Azure Service Bus
    changes that limit to 256 KB.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Service Busqueues can store less data than Azure Storage Queues—up to
    80 GB.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Service Bus supports consuming batches of messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Azure Storage Queues,the security model is quite basic—Azure Service Bussupports
    an RBAC model when it comes to securing queues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Storage Queuesdo not support transactional behaviour.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see, in Azure Service Busthere are many advanced features available,
    which can be very helpful in applications integrating different systems and applications,
    and also in third-party ones. Of course, those additional features cost extra
    as they require a more expensive tier. In Azure Service Bus,you have three tiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic**: Supports queues and scheduled messages only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Standard**: All features are available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Premium**: The maximum message size is extended to 1 MB, and brokered connections
    are included in the price. This tier also guarantees higher throughput and better
    performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you require only the basic functionality (without topics, transactions, or
    sessions), an Azure Service Businstance can be even cheaper than using Azure Storage
    Queues. It all depends on your requirements regarding your system.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Service Bus in Azure portal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create an instance of the Azure Service Bus, you have to search for the `Service
    Bus`service in the marketplace. You will see a short form where you fill in the
    most crucial information, like the name of the service, the pricing tier, and
    its location:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7cb2862e-d956-4578-a0e5-51bdc1db1d45.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For now, it is all you have to enter—just click on the Createbutton and wait
    a second until a service is created. The Overviewblade shows a bit more information,
    but as you can see, it is very similar to the one you saw when working with Azure
    Event Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f32e2b9-9097-4286-aa08-9a7abd4cecef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, you see that the+ Topicbutton is grayed out—this
    is because I selected the basictier for this exercise. By clicking on the + Queuebutton,
    you will be able to create a new queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb8d483d-8ca9-4ccb-833c-995abb0f4e89.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here things are getting a little bit more complicated:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: This is the unique name of a queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Max queue size: You can decide the maximum size of a queue (as opposed to a
    fixed size of 80 GB in Azure Storage Queue).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Message time to live: In Azure Storage Queues,the maximum lifetime of a message
    was 7 days. Here you can specify the custom lifetime of a message before it is
    deleted (or moved to a dead letter queue).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lock duration: When a message is picked up by a consumer, it is locked for
    a fixed time period to avoid duplicated reads. Here you can customize it (up to
    a maximum of 5 minutes).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enable duplicate detection: If you want to ensure the "exactly once" delivery
    model during a fixed time period, you can enable this option. It enables you to
    configure a duplicate detection window in which a history of processed messages
    will be kept.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enable dead lettering on message expiration: If a message expires, it is automatically
    deleted. To push it to a dead letter queue instead, enable this option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enable sessions: Sessions in Azure Service Busensure FIFO message processing.
    To make sure that the first message pushed to a service is the one to be processed,
    turn this feature on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enable partitioning: This option detaches a queue from a single messaging store,
    so in fact you are ending with multiple queues. This option ensures that even
    if a store has an outage, the whole queue or a topic will not go down. There are
    some limitations, however, regarding this feature—one is that with partitioning
    you cannot send messages belonging to different sessions in a single transaction.
    What is more, there is a limit of 100 partitioned queues or topics per namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partitioned queues and topics are not supported in the premiumtier of Azure
    Service Bus.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how a queue looks when partitioning is enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80879d97-97b3-494a-83ba-a16583f375fe.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the maximum size of a queue is displayed as 16 GB—this is because
    with partitioning enabled, we are ending with  16 partitions—each hosting a queue
    of the maximum size of 1 GB.
  prefs: []
  type: TYPE_NORMAL
- en: Because the maximum size of a single queue is set as 5 GB, you can achieve the
    maximum size of 80 GB by using partitioning. With that feature enabled, the maximum
    size will be 5 GB * 16 partitions = 80 GB.
  prefs: []
  type: TYPE_NORMAL
- en: Queues, topics, and relays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Azure Service Bussupports three different kinds of entities:'
  prefs: []
  type: TYPE_NORMAL
- en: Queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Topics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All three give you different options when handling communication.
  prefs: []
  type: TYPE_NORMAL
- en: Queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A queue is the simplest entity available in the service. You can define it
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/087852d2-cf23-4439-b557-4a794cfeb67c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding sample, you can see that we have the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Producer**: An application or a service, which pushes a message to a queue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Queue**: A container for messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consumer**: An application or a service, which reads messages from a queue
    using a pullmodel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pullmodel means that a producerhas actually to ask a queue to receive messages.
    Of course, there can be multiple producers and multiple consumers—this is where
    the lock durationfeature is especially helpful as it ensures that only a single
    consumer reads a message at any one time.
  prefs: []
  type: TYPE_NORMAL
- en: Topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Topics are a slightly different model than queues as they allow you to implement
    a pub/sub communication model. When a queue is a point-to-point communication,
    topics give you an option to distribute different messages to a different queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21559fcf-4dfc-4e8d-866d-39a4b4bfba69.png)'
  prefs: []
  type: TYPE_IMG
- en: This model makes it possible to filter messages and isolate them, so a consumer
    reads only those, which they are interested in.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, topics are not available in the basictier—you have to use at least
    the standard tier.
  prefs: []
  type: TYPE_NORMAL
- en: Relays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Both queues and topics are models, which are designed to deliver one-way communication
    only—a producer sends a message and a receiver reads it. If you want to implement
    bidirectional communication, you have to use a relay:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/640acb15-50ca-4b4d-a9bf-56137eb57804.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Azure Relayis, in fact, a separate service, and we will not cover it in this
    chapter. There are, however, many great features, which you may find helpful in
    your applications:'
  prefs: []
  type: TYPE_NORMAL
- en: It is designed to expose services securely, which are hosted within a corporate
    network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows different communication models like one-directional, pub/sub, andtwo-way
    communication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not alter the network as a VPN does, making it more stable and scoped
    to a single application endpoint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Service Bus design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Service Bus is often a central point of integration for many different
    cloud services—it can be used in a variety of scenarios, including data integration,
    broadcasting information, or even bidirectional communication. As the service
    is rich in different features, you can use it to implement various responsibilities.
    You can find many examples of design patterns for Azure Service Bus in the *Further
    reading* section in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Developing solutions with Azure Service Bus SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a rich database of many different examples for working with Azure
    Service Bus*, *available on GitHub (you can find a link in the *Further reading*section),
    so we will cover only the basic ones in this chapter. Here you can find the most
    simple way to send a message to a queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, all it requires (at least to get the basic functionality) is
    to use a `QueueClient`instance. If you want to work with a topic, you could use `TopicClient`instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, all you need is to install the `Microsoft.Azure.ServiceBus`NuGet package.
    After I ran the preceding code three times and checked my queue, this is what
    I saw in the portal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ff73501-5437-45ea-b680-d232a6a75cc6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, there are three active messages. That means that I have successfully
    published them and they are ready to be pulled. There are many different options
    for pulling a message—here you can find an example using `PeekAsync`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you only peek messages, you will not create a message store. To
    actually do that, you have to use `ReceiveAsync`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The difference will be visible when you read messages using both methods. `PeekAsync`will
    not change the state of messages (so they will be still visible as active, even
    if you set the `ReceiveMode`option to `ReceiveAndDelete`). `ReceiveAsync`will
    use the value of a `ReceiveMode`option and possibly act as an atomic `CompleteAsync`operation.
  prefs: []
  type: TYPE_NORMAL
- en: To mark messages as read after using `PeekAsync`** , **you can use `CompleteAsync`.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover more advanced scenarios later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Service Bus security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Azure Service Busis described as an enterprise-level cloud service designed
    for integrating different services, there are serious expectations regarding the
    security features it offers. Besides shared access tokens, there are new features
    in the preview, which allow much more flexible access management.
  prefs: []
  type: TYPE_NORMAL
- en: Managed Service Identity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Managed Service Identity** (**MSI**) is a feature in Azure Cloud, which eases
    authentication between services, without storing credentials in your code. The
    whole description can be found in the link in the *Further reading*section. When
    it comes to using it with Azure Service Bus, there is no additional blade available—what
    you need is just to find an identity in the access control (IAM) blade:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13c1bfba-f1f7-491e-bbfc-507df8058109.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, instead of using an SAS token or access policy, you can use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the flow becomes much simpler as you do not have to store credentials
    or keys, and instead let the provider handle the authentication.
  prefs: []
  type: TYPE_NORMAL
- en: RBAC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Azure Service Bus,there is also a possibility to leverage roles defined
    in Azure AD to grant access to a service. The whole feature relies on the assumption
    that a user will be able to take responsibility for granting access to a Service
    Bus instance. The first step is exactly the same as with MSI authentication: you
    have to add a user to a service, so it gains access and can start pushing and
    receiving messages. The full instructions can be found in the *Further reading*section.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that with the ability to tell explicitly how a user or an application can
    access Azure Service Bus, you are given much better control over how messages
    are published and received. This a great improvement over Azure Storage Queues*, *where
    such features are not available.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a possibility to use RBAC authentication to grant access to a
    service to another service (if MSI is not available). In that scenario, there
    will be no interactive login required as it is all handled by Azure AD.
  prefs: []
  type: TYPE_NORMAL
- en: Even if interactive login is required, it is not handled by an application so
    you can be sure that it will not handle any credentials directly.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced features of Azure Service Bus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already covered some of the basics of the Azure Service Bus,like SDK,
    the most crucial concepts, and security considerations. Now we will focus a little
    bit on more advanced use cases, like dead lettering, performance, sessions, and
    transactions. All those topics are crucial when developing a reliable and important
    service integrating many different applications and systems. Also remember to
    take a look at the Azure Service Busexamples in the *Further reading*section,
    as it points to a GitHub repository where you can find many different use cases
    and concepts when using this service.
  prefs: []
  type: TYPE_NORMAL
- en: Dead lettering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In general, dead letteringmeans that there are messages in a queue considered
    as dead (because there was no receiver interested in pulling them) and you have
    two options to proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: Either delete them permanently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Push them to an additional queue, named a dead letter queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Azure Service Bus,you have two options to push a message to a dead letter
    queue:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the maximum lifetime of a message—once it expires, it is automatically moved
    to a dead letter queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use the `DeadLetterAsync`method on `MessageReceiver`as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can find the complete example, and you can find a lock token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you push messages to a dead letter queue, their status will be visible
    in the portal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa7cb48a-a2d6-44c8-9464-886de3c75dc6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Of course, it is possible to fetch messages from a dead letter queue. To get
    the name, you can use the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Disaster recovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a disaster happens, you may lose a part or all of your data. In general,
    a disaster is defined as a temporal or permanent loss of the whole service with
    no guarantees that it will become available again. Such disasters are floods,
    earthquakes, or fires, just to name a few. Disasters tend to occur in a single
    region (the probability of disasters occurring in separate regions simultaneously
    is very small), so in general you need two different data centers to implement disaster
    recovery (DR).
  prefs: []
  type: TYPE_NORMAL
- en: Remember, using two different data centers may not be enough if they are close
    to each other—you have to select two that can satisfy your requirements, but at
    the same time are as far from each other as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to implementing DR in Azure Service Bus, the flow is the same
    as in Azure Event Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the primary region
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the secondary region
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the pairing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a trigger for failover
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In general, to create the pairing, you need the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding sample uses the `Microsoft.Azure.Management.ServiceBus`NuGet package
    for operating on a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a pairing is configured and created, it is up to you to trigger and initiate
    a failover. To do so, the following line is all you need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that a failover is initiated against the secondary region—this is crucial
    as the primary region may not be available at the time of initiating an operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a failover is finished, you can start handling messages using your secondary
    region. There is, however, one important thing to remember: in case another outage
    happens, you want to be able to fail over again. Because of that, it is also very
    important to set up another secondary namespace (and make the current one your
    primary) and pair them to be secure again.'
  prefs: []
  type: TYPE_NORMAL
- en: Sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Azure Service Bus,sessions are used to achieve a FIFO guarantee. In general, the
    service does not control the relationship between messages, so even if in most
    cases the order is preserved, it is not guaranteed. To put a message to a session,
    you have to leverage a `SessionId`property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To handle a session on the receiver side, you have to use the `RegisterSessionHandler`method
    on a `QueueClient`instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, you will have to implement `IMessageSession`**.**
  prefs: []
  type: TYPE_NORMAL
- en: Transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Transactions in Azure Service Busare a wide topic referring to many different
    entities, which you can work with in this service:'
  prefs: []
  type: TYPE_NORMAL
- en: Clients (`QueueClient`, `TopicClient`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Messages (by using operations like `Complete`, `Defer`, `Abandon` , and many
    more)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sessions (`GetState`/`SetState`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, there are no receive operations listed; this is because there
    is an assumption that they are atomic by design.
  prefs: []
  type: TYPE_NORMAL
- en: In general, there is a requirement for using the `ReceiveMode.PeekLock`mode
    when pulling messages and opening a transaction scope inside a loop or an `OnMessage`callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can refer to the following code snippet to get a better picture of what
    we are talking about in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above example, a processor (which at the same moment is responsible
    for producing a message) marks a message as complete, while transferring a new
    message to another queue. The whole model leverages the autoforwarding feature
    of Azure Service Bus. The following is an example of a topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When a transaction is implemented, you can be sure that committing to a queue
    log will only happen if the whole transaction succeeds; otherwise, there will
    be simply no trace of the messages that were handled inside it.
  prefs: []
  type: TYPE_NORMAL
- en: Handling outages and disasters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you make Azure Service Busthe center of your architecture—a service that
    is responsible for integrating dozens of services and handling the communication—you
    have to make sure that it is replicated and invulnerable to disasters. There are
    two topics to consider here: disaster recovery and handling outages. As those
    terms are completely different concepts, you have both to understand them and
    be able to implement a solution in case unexpected issues and accidents occur.
    In the last section of this chapter, you will learn how Azure Service Buscan be
    made into a durable cloud component, on which you and your applications can rely.'
  prefs: []
  type: TYPE_NORMAL
- en: Handling outages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While a disaster often means that some part of your data is lost, an outage
    may be described as a service being temporarily unavailable. This is why once
    it is resolved, you may want to synchronize both Service Bus namespaces. While
    this process is automatic, it may take a while. It is stated in the documentation
    that only 50-100 entities will be transferred per minute. For this reason, you
    may consider the concept of active/passive replication:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Active**: In such an approach, you have two active namespaces, which actively
    receive messages. Then a receiver always receives both of them—you have to tag
    them properly with the same unique identifier used to detect duplicates (you can
    use either the `MessageId`or `Label`property for that).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Passive**: Instead of actively using both queues (or topics), you can use
    the second one only if a message cannot be delivered to the primary namespace.
    This approach has its caveats, however: it may cause a message delivery delay
    (or even loss) or duplicates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, you can find an example of passive replication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it clearly shows how a duplicate of a message is passed to
    a backup queue. An example of active replication is slightly different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we are sending the same message to both namespaces, even if one of them
    fails. One more thing that should be considered to handle outages is using partitioned
    senders (though unavailable in the premiumtier). When using them, you are safe
    in case of an outage of a single messaging store, and you can still use other
    partitions to send and receive data. The following example enables partitioning
    on a topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this short chapter, you learned the basic concepts of Azure Service Busincluding
    queues, topics, SDK, and more advanced features like dead lettering, sessions,
    and transactions. There are still many things to learn: asynchronous messaging,
    **Advanced Message Queuing Protocol** (**AMQP**), and advanced transaction scenarios.
    In general, it is a great service for both simple and critical scenarios as it
    gives you enough flexibility to adjust it to most applications, and at the same
    time it is quite easy to learn how to get started. Remember, you can use the basictier
    for the simplest use cases, which gives you a cheap and reliable solution, a much
    richer option than Azure Storage Queue. In the next chapter, we will focus on
    monitoring services with Azure Application Insights*.*'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between a queue and a topic?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you use topics in the basictier?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the reason for using a dead letter queue?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are sessions for in Azure Service Bus?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the maximum size of a queue with partitioning enabled, when a single
    queue has the maximum size of 1 GB?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between active and passive replication?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is disaster recovery achieved in Azure Service Bus?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MSI overview: [https://docs.microsoft.com/pl-pl/azure/active-directory/managed-identities-azure-resources/overview](https://docs.microsoft.com/pl-pl/azure/active-directory/managed-identities-azure-resources/overview)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RBAC authentication: [https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-role-based-access-control](https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-role-based-access-control)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service Bus samples: [https://github.com/Azure/azure-service-bus/tree/master/samples/DotNet](https://github.com/Azure/azure-service-bus/tree/master/samples/DotNet)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Service Bus design patterns: [https://msdn.microsoft.com/en-us/magazine/mt845652.aspx](https://msdn.microsoft.com/en-us/magazine/mt845652.aspx)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
