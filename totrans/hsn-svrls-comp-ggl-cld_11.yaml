- en: Developing with Cloud Run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll look into the feature set of Cloud Run. As we saw in
    [Chapter 7](c29748cd-df95-4c66-9b16-cdb344d14be2.xhtml), *Introducing Cloud Run*,
    Cloud Run allows stateless containers to be provisioned and run on serverless
    infrastructure based on Google Cloud. In this chapter, we will focus on working
    with Cloud Run and how to use some of the available developer tools to develop
    serverless applications.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud Run is part of a wider ecosystem that provides us with the means to build
    web services at a wide scale. Interestingly, it can also exist within the Kubernetes
    ecosystem without changes needing to be made to the artifact configuration. If
    you have worked with Docker or Cloud Functions previously, much of the environment
    that supports Cloud Run will be familiar to you. At the time of writing, Cloud
    Run has just become generally available; however, some of the Google Cloud console
    components are still in alpha or beta stages and therefore are subject to change.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Cloud Run dashboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing with Cloud Run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a **Representation State Transfer** (**REST**) API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developer productivity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete the exercises in this chapter, you will need a Google Cloud Project
    or Qwiklabs account.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code files for this chapter in this book's GitHub repository,
    under the `ch08` subdirectory, at [https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch08](https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch08).
  prefs: []
  type: TYPE_NORMAL
- en: While you are going through the code snippets in the book, you will notice that,
    in a few instances, a few lines from the code/output have been removed and replaced
    with ellipses (`...`). The use of ellipses is only to show relevant code/output.
    The complete code is available on GitHub at the link mentioned previously.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Cloud Run dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Cloud Run interface on Google Cloud has several options available. These
    options relate to the build process and include information such as build triggers
    and historical views of prior builds. Starting with the Cloud Run dashboard, this
    menu option relies on the builds that are triggered within the project. At the
    time of writing, the page is currently undergoing testing, so expect further changes
    as the product matures:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0762d5b7-714c-4344-a473-9f1684a39db1.png)'
  prefs: []
  type: TYPE_IMG
- en: If you are not familiar with Cloud Build triggers, we will cover them in more
    detail later in this chapter. For now, all you need to know is that they are a
    way to automatically initiate a build and will be key when you use Cloud Run.
  prefs: []
  type: TYPE_NORMAL
- en: Developing with Cloud Run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At its most basic, Cloud Run allows container-based HTTP endpoints to be spun
    up and run in the cloud. In the previous chapter, we learned about the basics
    of how to create containers and build a simple application that was compatible
    with that environment. Understanding containers allows us to take whatever runtime
    language we want and make an artifact around our use case. At this point, we will
    take the opportunity to build our first Cloud Run application so that we can become
    familiar with both the environment and the product.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this first exercise, we will call upon some existing code and revisit the
    static website example (refer [Chapter 6](971cc339-7cda-4366-8e3d-919ceaf75d4d.xhtml),
    *Cloud Functions Labs*. Here, we will explore how we can potentially package an
    existing application. Remember that, in this example, the application is based
    on Node.js and incorporates peer dependencies. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To commence the project, we will need to retrieve the code from the GitHub
    repository using following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The source code for the web application, which was initially built as a Cloud
    Functions application, will now transition to Cloud Run. First, we will take a
    look at the compatibility between the two products. It is important to note that
    we don't need to change the application as this was previously built using the
    Functions Framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already seen that creating a container requires the creation of a Dockerfile
    manifest. This example application runs on Node.js; thus, we can take a shortcut
    and use a preexisting manifest template that is compatible with this framework.
    Taking this approach means that we don''t have to work out which packages are
    required and can quickly integrate them into our application requirements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To establish compatibility with our web application, we need to update the
    manifest so that it is aware of the application configuration we desire. We will
    only need to make minimal changes in order to achieve compatibility with our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: First, we needed to install the peer dependencies (for example, `functions-framework`
    and `pug`).
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the peer dependencies, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Doing so means we have these packages available within the image we created.
    Also, we correctly invocated the application by using the `npm start` command.
    Other than those changes, the manifest remains a pretty standard Node manifest.
    These changes are required to mirror the changes we might make when running via
    the command line.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, one thing to point out is the port that's being specified
    is `8080`; this is the default network port associated with Cloud Run applications.
    At the time of writing, I understand that further work is being done to support
    the use of alternative ports. Once this feature is available, it seems practical
    that it would be possible to specify the port requirements at the point of deployment.
    Therefore, the inclusion of this line provides a potential benefit.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the image, we will be using Cloud Build rather than Docker. We are
    doing this because we will be utilizing the Google ecosystem to manage our artifacts.
    Feel free to continue to use Docker to build; you will need to tag and upload
    your image for the Google Container Registry to do so. As a refresher, Cloud Build
    allows us to securely perform continuous integration on Google Cloud. This means
    that the build process can take place either locally or in the cloud. Cloud Build
    uses the GCloud SDK to initiate builds and post the resulting artifact to the
    Container Registry. Building our image can be done with the following line, in
    which we build a Docker image and tag the resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once the build has been successfully concluded, we will be able to see the output
    of the preceding command in the Container Registry. Holding assets in the repository
    enables a wide range of sharing options, both internally and externally, in relation
    to the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the container image exists, it is automatically added to the image
    repository. The next step is to deploy the code. This is as simple as referencing
    the artifact that we stored in our repository earlier. Note that to access the
    image that''s been saved, you need to use the full tag that''s been given to the
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Once the application has been successfully deployed, it responds in much the
    same way as a Cloud Functions deployment. The critical thing to note is how little
    work was required to transition from a Cloud Function to Cloud Run, using a Dockerfile
    manifest. In this instance, the manifest is straightforward and doesn't require
    much additional consideration to get it running. At this point, when returning
    to the Cloud Run console, we can not only see the deployed application but some
    ancillary information. Let's take a moment to explore this new information.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we had a brief tour of the Cloud Run interface and looked at
    the purpose of each of its components. Then, we built a simple container to render
    information on the screen. By doing this, we can develop our knowledge and skills
    by creating more compelling examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with containers and, more specifically, Cloud Run, it is essential
    to be able to incorporate existing applications. Creating a use case that is both
    informative and genuinely educational is a hard task, so massive props to the
    Google Cloud Run team for the PDF example. If you have not seen this example before,
    I would highly recommend viewing the Next 19 serverless sessions as these perfectly
    illustrate the ease and power of Cloud Run (reference link):'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/playlist?list=PLIivdWyY5sqLYz6HIadOZHE9PsKX-0CF8](https://www.youtube.com/playlist?list=PLIivdWyY5sqLYz6HIadOZHE9PsKX-0CF8)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove the existing service use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**gcloud run services delete hello-cloudrun --platform managed --region us-central1**`'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to adapt the example we looked at in this
    section in order to incorporate additional processing capability. Hopefully, this
    will highlight both the power and flexibility of the Google Cloud environment.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Representation State Transfer (REST) API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Providing an extensible API presents us with an opportunity to integrate other
    software into our application. We have already looked at how the building blocks
    have been put together in terms of developing serverless applications. With Cloud
    Run, we can expand this knowledge and build extensible interfaces that can expose
    access to selected parts of an application. If you come from a GNU/Linux background,
    this will be abundantly clear and something you may take for granted. For others,
    it can be a moment of clarity where an application allows you to do more than
    expected. There are times in which we might not even know that an implementation
    supports an interface that's being used for a task.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we will build a basic API that uses REST to demonstrate how
    Cloud Run can be used to meet this requirement. If you have not come across the
    term REST API, this typically refers to stateless operations, the most common
    of which are GET and POST. The API uses these operations to retrieve and send
    information using web resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first example will build a fundamental REST API that''s built on Cloud
    Run to provide access to backend data. It will have the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A basic API**: Used to retrieve retail data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A list of goods available**: The API will be provided with a code and retrieve
    the associated object information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From the preceding examples, it should be clear that the API provides us with
    a simple mechanism that we can use to retrieve information related to the data
    object. If we were to expand the data object, we would still be able to access
    this data, without any changes needing to be made to the API—that is, the power
    of abstracting information access away from the data so that it can be enhanced
    independently:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3b47e58-16b6-473f-a25f-c998b5a0965b.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding diagram, we can see that a number of API calls have been
    defined that will call the various endpoints. Each of the API endpoints has a
    specific job; for example, retrieving management reports, handling transactional
    information, and storing information in the data warehouse. Here, we can see that
    the **Business Endpoint** uses a post API call, which indicates that information
    is posted to the endpoint (perhaps a set of filter information) for further processing.
    Both the **Retail** and **Finance** endpoint calls use GET to pull back information
    for **Transactions** and **Data Warehouse**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some general rules that help define good practices when building
    compelling REST APIs. The key principles we want to introduce are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Base URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API consistency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API versioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To understand the theory and general rules behind this a bit more, we will explore
    the aforementioned key principles. This will assist us when we design an API later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Base URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want the base URL to have significance to the name query. A good starting
    point is to consider what the base URL is meant to represent and how this can
    be modeled to be representative of the underlying data.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this juncture in the development cycle, it seems rather sensible to have
    the means to access all of the data collection. It would also seem helpful to
    be able to isolate an element within that collection using the same API call.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we consider these requirements, the need for an intuitive base URL capable
    of meeting our requirements should become more apparent. In the following diagram,
    we can see how this API would work with the help of two queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d53dbf92-8f5f-4fa2-9c80-0e35cb6ac6af.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, the queries do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Query A will be capable of gathering all the books stored in the collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query B will be capable of gathering a specific item from within the collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding diagram illustrates a situation in which the base URL encompasses
    two use cases for data access:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/[collective noun]`: Access to a collection; for example, retrieve all books'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/[collective noun]/[element]`: Access to an element within the collection;
    for example, retrieve the books labeled `1234`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a collective noun to categorize the base URL allows us to access the full
    collection and individual items. Now, we have to simplify the base URL; our next
    consideration is how to achieve greater API consistency. In the next subsection,
    we will explore how to implement this using Cloud Run.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a base URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our first task is to implement a base URL. Fortunately, in our case, the job
    is relatively simple; however, it also illustrates the point we are trying to
    make. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `ch08` folder create a new directory called `baseURL` and move to
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the generated `package.json` file and add the following line to the script
    section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new file named `index.js` and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new file named `Dockerfile` and add the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Working in Cloud Shell provides a number of features that are easy to take
    for granted. One particular thing is the current project identifier. To get the
    value of this at the command line, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`gcloud config get-value project`**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even better, you can assign it to an environment variable by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`PROJECT_ID=$(gcloud config get-value project)`**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Build an image based on the application (note that `$PROJECT_ID` is an environment
    variable that''s been set to my Google Project Identifier):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Deploy the image to Cloud Run. Take note of the `SERVICE_URL` that''s returned
    from this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the app has been deployed, we can test our API from the Cloud Shell using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code, we can see that to implement a base URL, we need to
    choose something that complements our API. In this instance, the collective noun
    `books` also made for a good base URL.
  prefs: []
  type: TYPE_NORMAL
- en: When considering how to develop a URL, it is worth considering the use case
    for the API and applying some logic in terms of determining how the schema can
    be sensibly applied. Now that we have defined our base URL, we can look at how
    to develop a consistent interface for the API.
  prefs: []
  type: TYPE_NORMAL
- en: API consistency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The aim of API consistency is to simplify access to exposed information:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Resource** | **POST** | **GET** | **PUT** | **DELETE** |'
  prefs: []
  type: TYPE_TB
- en: '| `/books` | Create a new book | List books | Batch update | Delete the book
    collection |'
  prefs: []
  type: TYPE_TB
- en: '| `/books/1111` | Invalid | Show a book | Invalid | Delete a book |'
  prefs: []
  type: TYPE_TB
- en: In our example, the collections and elements can be made accessible through
    the use of HTTP verbs, as shown in the preceding table.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the preceding information, note how the API is used in relation to the
    HTTP verb. For example, we know the following to be true:'
  prefs: []
  type: TYPE_NORMAL
- en: POST events are used for sending data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GET events are used for listing (querying) data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PUT events are used for batch updates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DELETE events are used for removing items.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How would we use these capabilities in conjunction with our book API? As shown
    in the preceding table, the API being presented provides a consistent interface
    for expected outcomes. However, what would an implementation of this look like?
    We will look at this in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing API consistency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consistency is something all API developers strive for. To achieve this, we
    need to consider how the API will be used. In our example, we will update the
    API to provide a GET request for all the books, as well as a single book. Let''s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Edit the `index.js` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the HTTP `GET ID`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the HTTP `POST`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the HTTP `DELETE`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the HTTP `DELETE ID`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the HTTP `PUT`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the build image by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Redeploy the image to Cloud Run using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use the `curl` command to test the enhancements that were made
    to the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP verb** | **Test /books endpoint** | **Test result** | **Test /books/:id**
    | **Test result** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `curl [SERVICE_URL]/books` | `{"status":"GET"}` | `curl [SERVICE_URL]/books/1111`
    | `{"status":"GET ID"}` |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `curl --data "author=atwood" [SERVICE_URL]/books` | `{"status":"POST"}`
    | N/A | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | N/A | N/A | `curl -X PUT --data "author=atwood" [SERVICE_URL]/books`
    | `{"status":"PUT"}` |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | `curl -X [SERVICE_URL]/books/1111` | `{"status":"DELETE"}` | `curl
    -X [SERVICE_URL]/books/1111` | `{"status":"DELETE ID"}` |'
  prefs: []
  type: TYPE_TB
- en: From these changes, we can see that the API calls are now consistent in that
    a call to get an individual book or collection of books utilizes the same interface
    type. The commonality between interface calls provides continuity between calls
    so that the API developer is assured of the meaning of the call being made.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what makes up an API, let's move on to handling errors.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling error situations in code can be quite a complex affair. There's a wealth
    of HTTP status codes, but that doesn't mean an API should use all of them. In
    many respects, it can be clearer if a subset is used instead to indicate an error
    has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At a high level, there are three specific outcomes that most definitely need
    to be mapped, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`200`: The application is working as expected. Everything is OK.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`400`: The application is not working as expected. A client error has occurred;
    that is, bad client data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`500`: The API is not working as expected. A server error has occurred; that
    is, a bad server process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This list can be expanded to include a more detailed analysis, but the preceding
    messages provide a good baseline for any further API development.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is important to have a consistent and clear understanding of the types of
    errors that are being managed by the API. In our example, we''ll adopt the three
    outcomes we mapped previously. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Amend each API call to incorporate the return of a `success` status call, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a client- and server-side error response state (note that we don''t have
    any server-side resources, so this code is just being used as an example):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: By making the preceding code changes, we can see that the status of an API call
    is more clearly defined when an appropriate status code is returned. Being able
    to implement a clear interface together with a consistent response allows developers
    to have confidence in the use of the code that's provided. The final part of this
    section will cover how to approach versioning.
  prefs: []
  type: TYPE_NORMAL
- en: API versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A good rule of thumb is to always include a version number in the signature
    of the REST API to be released. Applying a version number to an API can be useful
    for managing defects and maintaining backward compatibility. There are a number
    of strategies that we can follow to include versioning within the URL; however,
    a good place to start is through the use of an ordinal number to signify the interface,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we relate the API to `v1`, which means we can clearly
    see which version is being applied for the query. If we introduce a `v2` API,
    again, it is clear to a user of the API which version is in play without needing
    additional support. Version changes will often be made to maintain backward compatibility
    or signify changes to the underlying API. Presenting developers with an opportunity
    to update their code without breaking existing integrations will be imperative
    to anyone using the API.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want an API that enables multiple revisions of the API to coexist, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If we need to integrate alternative versions of an API, this is one approach
    that works well.
  prefs: []
  type: TYPE_NORMAL
- en: Express versioning with routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Of course, we should also include versioning as part of our API. Here, we need
    to update the code to reflect that the code is based on `v1` of the book''s API
    by utilizing an awesome feature of express called **routing**. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy `index.js` to `bookapi_v1.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the `index.js` file and add the following declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove all `app.put`, `app.get`, `app.delete`, and `app.post` functions. Your
    code base should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to update our code so that it references our new book version.
    Follow these steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: Edit `bookapi_v1.js`.
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove all `app.listen` and `app.use` functions, as well as the `const` port
    definition.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The file should now look like this:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a definition for the express `Router` after the `express` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Rename all `app.` to `bookapi_v1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following reference to the bottom of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Rebuild the image and deploy it. You will notice that you need to append the
    version to the URL; for example, `[SERVICE_URL]/v1/books`. Now that the API has
    been integrated into the query, it is much easier to ascertain which version is
    being called. As an API matures, it will likely incorporate additional features
    or replace existing ones. These changes may not always be backward compatible,
    meaning that API developers need to be made aware of any incompatibilities. Versioning
    is a good strategy if you wish to manage expectations and gain access to feature
    sets as the API is developed.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should have a really good understanding of the type of things
    to consider when creating your own API. In the next section, we will look at developing
    an application using Cloud Run.
  prefs: []
  type: TYPE_NORMAL
- en: Developer productivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our second example, we will investigate the development tools that accompany
    the Cloud Run environment. Creating a PDF is something most of us now take for
    granted, and it is one of the easiest ways to share documentation. Many businesses
    utilize a service that sends out invoices or similar information to their customer
    base.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to Cloud Functions, becoming familiar with the environment and establishing
    a development workflow can increase your levels of productivity. In this section,
    we will also take a look at how to integrate other developer tools such as Cloud
    Run, Cloud Build, Source Repositories, and Container Registry, as these can be
    hugely beneficial when developing on Google Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we begin looking at the example, let''s take a moment to explore a typical
    development workflow. For many developers, their workflow resembles something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Code is held in a repository; for example, GitHub, Bitbucket, or Source Repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A build process is initiated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud Source Repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Cloud Source Repository is useful if you want to have a private repository
    for your code. However, it can also be used to mirror public repositories so that
    code assets are available within your project. Once the repository has been mirrored
    on Google Cloud, any commits that are pushed will be automatically synced to the
    Cloud Source Repository. This is important because it means you can continue to
    use your original repository and not be concerned about any maintenance tasks
    that ensure the repositories are kept in sync.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud Build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building source code is a dull activity. Whether it's a small or large component,
    the process is nothing more than a repetitive loop. Cloud Build, however, can
    take over this process and free up some of your time. While the main examples
    focus on building Dockerfile manifests, Cloud Build can actually build many other
    things (for example commands, `git`, `go`, `gcloud`, `gradle`, `kubectl`, and
    `npm`). Even better, it can be extended to build other things through the use
    of open source builders. Community builders are available for Helm, Flutter, and
    Android, and the list continues to grow.
  prefs: []
  type: TYPE_NORMAL
- en: Build events are triggered by changes that are made in the repository, at which
    point a predefined series of processes commence. In the Cloud Build history page
    (also in its alpha stage), access to prior builds is available. The page incorporates
    a range of fields with representative data, such as Build, Source, Commit, Time/Date
    created, and the duration of the build. Additional information totaling 13 fields
    is available, as well as a filter that can be applied to build a report.
  prefs: []
  type: TYPE_NORMAL
- en: The Triggers page is where the magic happens; if you have used Cloud Build previously,
    this page will be very familiar to you. While currently in its beta stage, the
    page specifies two views for active and inactive repositories, respectively. Active
    repositories have triggers associated with them, while inactive artifact repositories
    do not. A typical trigger would be **Push to any branch**, meaning that every
    addition of new code to a branch within the specified repository will mean the
    generation of an event. This event is associated with a build process, which enables
    a wide variety of predefined and custom processing to occur. We will cover more
    on triggers later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there is the Settings page, which is where service account management
    details are available. In order to use Cloud Build, you will need the service
    account to be bound to the permissions within the project. In most instances,
    the need for additional service account permissions for further access requires
    IAM. Bear in mind that in addition to screen, the majority of roles can be managed
    directly from the IAM section of the Google Cloud Console. Previously, we examined
    some of the core fundamentals of working with containers on Google Cloud. To baseline
    our shared understanding of this, in the next section, we will start with a simple
    introduction to Cloud Run and see how we can incorporate this knowledge into further
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: The continuous integration example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following example, we will create an instance in which we will build
    a development workflow that utilizes a repository and shows how simple it is to
    create such a workflow in Cloud Build. Let's imagine that some code exists in
    a repository and that we have a predefined trigger associated with it. Each time
    code is committed to the repository, a signal will be sent to Cloud Build to initiate
    the event related to the mirrored repository. In the preceding examples, we saw
    that a variety of languages are supported. In our case, we will initiate an action
    that's been defined within the Cloud Build environment that will replace having
    to start a build process from the local development machine manually. To invoke
    the automated build, we will have to push code to the repository, as would typically
    be the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our application is a simple one; the emphasis in this example will be on the
    tools rather than the code. In the `ch08` directory, change the current folder
    to be `node-ci`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the directory, notice that there is a `cloudbuild.yaml` file. It is this
    file that ensures the build steps are performed. The contents of the file are
    outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example we omit tests as we haven''t defined any. However
    if you want these to be included add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`- name: ''gcr.io/cloud-builders/npm''`'
  prefs: []
  type: TYPE_NORMAL
- en: '`args: [''test'']`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that three steps are defined in this file, all of which assist with our
    build process:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Npm package installation**: Installs the dependency packages'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Npm audit fix**: Performs a check to see whether the packages can be automatically
    fixed'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Docker build**: Builds an image based on the node application using a Dockerfile'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final line represents a timeout setting for the `cloudbuild.yaml` file
    and the build max duration. At the time of writing, this is set to 10 minutes.
    If we were to run the preceding commands, it would output a new build image based
    on the code given. We can manually invoke the builder from the command line, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: However, we don't want to run a `build` command manually; it should be run automatically
    when we push the code to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure the repository responds in the way we want it to, we need to add
    the Google Cloud Build action. Back in the Google Cloud console, find the Cloud
    Build option. From the resulting menu, choose the Triggers option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57b25748-57f7-4c78-ade1-f4a90ab269e2.png)'
  prefs: []
  type: TYPE_IMG
- en: If you haven't created a trigger before, the screen will look similar to this
    graphic (if you have existing triggers already configured they will be present
    in this screen).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc4a4509-d8f7-4185-ab97-05e564892308.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a trigger makes a link between a source repository and Cloud Build.
    The following graphic illustrates the information required to create a new trigger.
    The setup for the application is highly customisable, but let's take a base case
    for our example. First, we need to enable Google Cloud Build in our repository.
    In this example, note that the source repository being used is GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a26b7436-22fd-46f9-b61b-0b41d7d1fd7f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you add the application, you will be asked for permission to access the
    repository, as well as which repositories should be granted access. It is important
    to remember that not all the repositories need to be made available to the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47f19573-7348-4f3b-a193-beeb49a566dc.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have granted access, in the Google Cloud, we can use Cloud Build
    (alpha) to create a new trigger event based on the repository we have just configured.
    Use the connect repository option and set up the application so that whenever
    a branch is updated, the trigger will be invoked. The default settings are based
    on any branch within a repository being updated, but this can be amended to a
    tag or pull request. In addition, the build configuration can also be changed
    from implementing the auto-detect feature to using either a Dockerfile or Cloud
    Build configuration file (YAML or JSON).
  prefs: []
  type: TYPE_NORMAL
- en: Once you have set this up, update the code in order to push a change. You will
    see the backend code being triggered automatically. Congratulations! You have
    just become more productive by being able to automatically create an artifact
    by pushing code. In the next chapter, we will entertain a more intricate example
    of this workflow with multiple services.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked into the critical aspects of Cloud Run and worked
    through some everyday use cases. During this process, we observed many essential
    concepts, such as how to incorporate Cloud Build and Container Registry developer
    tooling into our workflow. For those of you who were unfamiliar with these tools,
    hopefully, you now know enough to use them in your day-to-day tasks. Building
    on our introduction of containerized environments (for example, Docker), we learned
    how Cloud Run removes much of the complexity of deploying consistent and isolated
    code. Once the container has been built successfully, it can be deployed. As with
    Google's other serverless products, Cloud Run scales to zero.
  prefs: []
  type: TYPE_NORMAL
- en: Support for serverless request/response messages is inherent in Cloud Run, so
    there is a consistent and straightforward method for developing components. Besides,
    adding a new language runtime can be achieved without distraction or negating
    the flexibility of the service. By utilizing the container artifact, Cloud Run
    can easily be enhanced to incorporate Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue our Cloud Run journey and explore the
    key differences when working on the Kubernetes platform.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a base URL?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is API versioning important?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What verbs would you expect to be available with a REST API?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is it appropriate to return an HTTP status code of 4xx?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the maximum duration setting for a Cloud Build?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cloud Build can be used for Android (True or False).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where are the errors for Cloud Build shown?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**CI/CD on Google Cloud**: [https://cloud.google.com/docs/ci-cd/](https://cloud.google.com/docs/ci-cd/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creating and managing build triggers**: [https://cloud.google.com/cloud-build/docs/running-builds/create-manage-triggers](https://cloud.google.com/cloud-build/docs/running-builds/create-manage-triggers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creating GitHub app triggers**: [https://cloud.google.com/cloud-build/docs/create-github-app-triggers](https://cloud.google.com/cloud-build/docs/create-github-app-triggers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Cloud APIs**: [https://cloud.google.com/apis/docs/overview](https://cloud.google.com/apis/docs/overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Cloud Podcast – HTTP/2, SPDY, and QUIC with Ilya Grigorik**: [https://www.gcppodcast.com/post/episode-6-http2-spdy-and-quic-with-ilya-grigorik/](https://www.gcppodcast.com/post/episode-6-http2-spdy-and-quic-with-ilya-grigorik/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container Registry**: [https://cloud.google.com/container-registry/](https://cloud.google.com/container-registry/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serverless Sessions - Google Cloud Next ''19**: [https://www.youtube.com/playlist?list=PLIivdWyY5sqLYz6HIadOZHE9PsKX-0CF8](https://www.youtube.com/playlist?list=PLIivdWyY5sqLYz6HIadOZHE9PsKX-0CF8)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
