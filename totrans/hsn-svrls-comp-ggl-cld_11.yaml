- en: Developing with Cloud Run
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Cloud Run 开发
- en: In this chapter, we'll look into the feature set of Cloud Run. As we saw in
    [Chapter 7](c29748cd-df95-4c66-9b16-cdb344d14be2.xhtml), *Introducing Cloud Run*,
    Cloud Run allows stateless containers to be provisioned and run on serverless
    infrastructure based on Google Cloud. In this chapter, we will focus on working
    with Cloud Run and how to use some of the available developer tools to develop
    serverless applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨 Cloud Run 的功能集。正如我们在 [第 7 章](c29748cd-df95-4c66-9b16-cdb344d14be2.xhtml)《介绍
    Cloud Run》中所看到的，*Cloud Run 允许无状态容器在基于 Google Cloud 的无服务器基础设施上进行部署和运行*。在本章中，我们将重点介绍如何使用
    Cloud Run 以及如何利用一些可用的开发工具来开发无服务器应用程序。
- en: Cloud Run is part of a wider ecosystem that provides us with the means to build
    web services at a wide scale. Interestingly, it can also exist within the Kubernetes
    ecosystem without changes needing to be made to the artifact configuration. If
    you have worked with Docker or Cloud Functions previously, much of the environment
    that supports Cloud Run will be familiar to you. At the time of writing, Cloud
    Run has just become generally available; however, some of the Google Cloud console
    components are still in alpha or beta stages and therefore are subject to change.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Run 是一个更广泛生态系统的一部分，提供了在大规模上构建 web 服务的手段。有趣的是，它也可以在 Kubernetes 生态系统内运行，而无需对工件配置进行任何更改。如果你之前使用过
    Docker 或 Cloud Functions，那么支持 Cloud Run 的大部分环境对你来说是熟悉的。在撰写本文时，Cloud Run 刚刚变得普遍可用；然而，Google
    Cloud 控制台的一些组件仍处于 alpha 或 beta 阶段，因此可能会发生变化。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Exploring the Cloud Run dashboard
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Cloud Run 仪表板
- en: Developing with Cloud Run
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Cloud Run 开发
- en: Building a **Representation State Transfer** (**REST**) API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 **表示性状态转移** (**REST**) API
- en: Developer productivity
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员生产力
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete the exercises in this chapter, you will need a Google Cloud Project
    or Qwiklabs account.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章中的练习，你需要一个 Google Cloud 项目或 Qwiklabs 帐号。
- en: You can find the code files for this chapter in this book's GitHub repository,
    under the `ch08` subdirectory, at [https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch08](https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch08).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的 GitHub 仓库中找到本章的代码文件，位于 `ch08` 子目录下，链接地址为 [https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch08](https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch08)。
- en: While you are going through the code snippets in the book, you will notice that,
    in a few instances, a few lines from the code/output have been removed and replaced
    with ellipses (`...`). The use of ellipses is only to show relevant code/output.
    The complete code is available on GitHub at the link mentioned previously.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本书中的代码片段时，你会注意到在一些情况下，代码/输出中的某些行被移除，并用省略号（`...`）替代。省略号的使用仅仅是为了展示相关的代码/输出。完整的代码可以在之前提到的
    GitHub 链接中找到。
- en: Exploring the Cloud Run dashboard
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Cloud Run 仪表板
- en: 'The Cloud Run interface on Google Cloud has several options available. These
    options relate to the build process and include information such as build triggers
    and historical views of prior builds. Starting with the Cloud Run dashboard, this
    menu option relies on the builds that are triggered within the project. At the
    time of writing, the page is currently undergoing testing, so expect further changes
    as the product matures:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cloud 上的 Cloud Run 界面有几个可用的选项。这些选项与构建过程有关，包括构建触发器和先前构建的历史视图等信息。从 Cloud
    Run 仪表板开始，此菜单选项依赖于在项目内触发的构建。在撰写本文时，该页面正在进行测试，因此随着产品的成熟，预计会有进一步的更改：
- en: '![](img/0762d5b7-714c-4344-a473-9f1684a39db1.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0762d5b7-714c-4344-a473-9f1684a39db1.png)'
- en: If you are not familiar with Cloud Build triggers, we will cover them in more
    detail later in this chapter. For now, all you need to know is that they are a
    way to automatically initiate a build and will be key when you use Cloud Run.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉 Cloud Build 触发器，我们将在本章后面详细介绍它们。目前，你只需要知道它们是一种自动启动构建的方式，并且在使用 Cloud Run
    时它们将是关键。
- en: Developing with Cloud Run
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Cloud Run 开发
- en: At its most basic, Cloud Run allows container-based HTTP endpoints to be spun
    up and run in the cloud. In the previous chapter, we learned about the basics
    of how to create containers and build a simple application that was compatible
    with that environment. Understanding containers allows us to take whatever runtime
    language we want and make an artifact around our use case. At this point, we will
    take the opportunity to build our first Cloud Run application so that we can become
    familiar with both the environment and the product.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从最基本的角度来看，Cloud Run 允许基于容器的 HTTP 端点在云中启动和运行。在上一章中，我们学习了如何创建容器以及如何构建一个与该环境兼容的简单应用程序。了解容器可以让我们选择任何我们想要的运行时语言，并围绕我们的用例创建一个工件。此时，我们将利用这个机会构建我们的第一个
    Cloud Run 应用程序，以便熟悉环境和产品。
- en: 'In this first exercise, we will call upon some existing code and revisit the
    static website example (refer [Chapter 6](971cc339-7cda-4366-8e3d-919ceaf75d4d.xhtml),
    *Cloud Functions Labs*. Here, we will explore how we can potentially package an
    existing application. Remember that, in this example, the application is based
    on Node.js and incorporates peer dependencies. Let''s get started:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个练习中，我们将调用一些现有代码，并重新回顾静态网站示例（参见 [第6章](971cc339-7cda-4366-8e3d-919ceaf75d4d.xhtml)，*Cloud
    Functions 实验*）。在这里，我们将探讨如何将现有应用程序进行打包。请记住，在这个示例中，应用程序是基于 Node.js 并且包含对等依赖项的。让我们开始吧：
- en: 'To commence the project, we will need to retrieve the code from the GitHub
    repository using following command:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启动项目，我们需要使用以下命令从 GitHub 仓库获取代码：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The source code for the web application, which was initially built as a Cloud
    Functions application, will now transition to Cloud Run. First, we will take a
    look at the compatibility between the two products. It is important to note that
    we don't need to change the application as this was previously built using the
    Functions Framework.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这款最初构建为 Cloud Functions 应用程序的 web 应用程序，现在将过渡到 Cloud Run。首先，我们将查看这两种产品之间的兼容性。需要注意的是，我们不需要更改应用程序，因为它之前就是使用
    Functions Framework 构建的。
- en: 'We have already seen that creating a container requires the creation of a Dockerfile
    manifest. This example application runs on Node.js; thus, we can take a shortcut
    and use a preexisting manifest template that is compatible with this framework.
    Taking this approach means that we don''t have to work out which packages are
    required and can quickly integrate them into our application requirements:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经看到，创建容器需要创建一个 Dockerfile 清单。这个示例应用程序运行在 Node.js 上，因此我们可以走捷径，使用一个与这个框架兼容的现有清单模板。采取这种方式意味着我们不需要再去弄清楚哪些软件包是必需的，可以快速将它们集成到我们的应用程序需求中：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To establish compatibility with our web application, we need to update the
    manifest so that it is aware of the application configuration we desire. We will
    only need to make minimal changes in order to achieve compatibility with our application:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了与我们的 web 应用程序建立兼容性，我们需要更新清单，使其能够识别我们所期望的应用程序配置。我们只需要做最少的更改，就能实现与应用程序的兼容：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: First, we needed to install the peer dependencies (for example, `functions-framework`
    and `pug`).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装对等依赖项（例如，`functions-framework` 和 `pug`）。
- en: 'To install the peer dependencies, run the following command:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装对等依赖项，请运行以下命令：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Doing so means we have these packages available within the image we created.
    Also, we correctly invocated the application by using the `npm start` command.
    Other than those changes, the manifest remains a pretty standard Node manifest.
    These changes are required to mirror the changes we might make when running via
    the command line.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做意味着我们在创建的镜像中已经包含了这些软件包。此外，我们通过使用`npm start`命令正确地调用了应用程序。除此之外，清单仍然是一个相当标准的
    Node 清单。这些更改是必需的，以便镜像我们在通过命令行运行时可能进行的更改。
- en: In the preceding example, one thing to point out is the port that's being specified
    is `8080`; this is the default network port associated with Cloud Run applications.
    At the time of writing, I understand that further work is being done to support
    the use of alternative ports. Once this feature is available, it seems practical
    that it would be possible to specify the port requirements at the point of deployment.
    Therefore, the inclusion of this line provides a potential benefit.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，有一点需要指出的是，指定的端口是`8080`；这是 Cloud Run 应用程序的默认网络端口。截止到本文写作时，我了解到正在进行进一步的工作，以支持使用替代端口。一旦这个功能可用，似乎在部署时指定端口需求将变得更加实际。因此，包含这一行代码提供了一个潜在的好处。
- en: 'To build the image, we will be using Cloud Build rather than Docker. We are
    doing this because we will be utilizing the Google ecosystem to manage our artifacts.
    Feel free to continue to use Docker to build; you will need to tag and upload
    your image for the Google Container Registry to do so. As a refresher, Cloud Build
    allows us to securely perform continuous integration on Google Cloud. This means
    that the build process can take place either locally or in the cloud. Cloud Build
    uses the GCloud SDK to initiate builds and post the resulting artifact to the
    Container Registry. Building our image can be done with the following line, in
    which we build a Docker image and tag the resource:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了构建镜像，我们将使用 Cloud Build 而不是 Docker。我们这么做是因为我们将利用 Google 生态系统来管理我们的构件。你可以继续使用
    Docker 来构建，但你需要标记并上传你的镜像到 Google 容器注册表。作为复习，Cloud Build 允许我们在 Google Cloud 上安全地执行持续集成。这意味着构建过程可以在本地或云端进行。Cloud
    Build 使用 GCloud SDK 来启动构建并将生成的构件上传到容器注册表。我们可以通过以下命令来构建镜像，其中我们构建一个 Docker 镜像并标记资源：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once the build has been successfully concluded, we will be able to see the output
    of the preceding command in the Container Registry. Holding assets in the repository
    enables a wide range of sharing options, both internally and externally, in relation
    to the project.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建成功完成，我们将能够在容器注册表中看到前面命令的输出。将资源保存在仓库中可以为项目提供广泛的共享选项，无论是内部的还是外部的。
- en: 'Now that the container image exists, it is automatically added to the image
    repository. The next step is to deploy the code. This is as simple as referencing
    the artifact that we stored in our repository earlier. Note that to access the
    image that''s been saved, you need to use the full tag that''s been given to the
    object:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在容器镜像已存在，它会自动添加到镜像仓库。下一步是部署代码。只需引用我们之前保存在仓库中的构件即可。请注意，访问已保存的镜像时，需要使用给定对象的完整标签：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once the application has been successfully deployed, it responds in much the
    same way as a Cloud Functions deployment. The critical thing to note is how little
    work was required to transition from a Cloud Function to Cloud Run, using a Dockerfile
    manifest. In this instance, the manifest is straightforward and doesn't require
    much additional consideration to get it running. At this point, when returning
    to the Cloud Run console, we can not only see the deployed application but some
    ancillary information. Let's take a moment to explore this new information.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用成功部署，它的响应方式与云函数的部署非常相似。需要注意的关键点是，从云函数到 Cloud Run 的过渡几乎不需要做太多工作，只需使用一个 Dockerfile
    清单。在这种情况下，清单非常简单，并且不需要太多额外的考虑就能使其运行。在此时，当我们返回到 Cloud Run 控制台时，我们不仅能看到已部署的应用程序，还能看到一些附加信息。让我们花点时间来探讨这些新信息。
- en: In this section, we had a brief tour of the Cloud Run interface and looked at
    the purpose of each of its components. Then, we built a simple container to render
    information on the screen. By doing this, we can develop our knowledge and skills
    by creating more compelling examples.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们简要浏览了 Cloud Run 界面，并了解了各个组件的用途。然后，我们构建了一个简单的容器来渲染屏幕上的信息。通过这样做，我们可以通过创建更具吸引力的示例来发展我们的知识和技能。
- en: 'When working with containers and, more specifically, Cloud Run, it is essential
    to be able to incorporate existing applications. Creating a use case that is both
    informative and genuinely educational is a hard task, so massive props to the
    Google Cloud Run team for the PDF example. If you have not seen this example before,
    I would highly recommend viewing the Next 19 serverless sessions as these perfectly
    illustrate the ease and power of Cloud Run (reference link):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理容器时，特别是在 Cloud Run 上工作时，能够整合现有应用程序是至关重要的。创建一个既有信息性又有教育性的用例是一项艰巨的任务，因此非常感谢
    Google Cloud Run 团队提供的 PDF 示例。如果你之前没有看到过这个示例，我强烈建议你观看 Next 19 无服务器技术会议的视频，因为这些视频完美地展示了
    Cloud Run 的简便性和强大功能（参考链接）：
- en: '[https://www.youtube.com/playlist?list=PLIivdWyY5sqLYz6HIadOZHE9PsKX-0CF8](https://www.youtube.com/playlist?list=PLIivdWyY5sqLYz6HIadOZHE9PsKX-0CF8)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.youtube.com/playlist?list=PLIivdWyY5sqLYz6HIadOZHE9PsKX-0CF8](https://www.youtube.com/playlist?list=PLIivdWyY5sqLYz6HIadOZHE9PsKX-0CF8)'
- en: 'To remove the existing service use the following command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除现有服务，请使用以下命令：
- en: '`**gcloud run services delete hello-cloudrun --platform managed --region us-central1**`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`**gcloud run services delete hello-cloudrun --platform managed --region us-central1**`'
- en: In the next section, we are going to adapt the example we looked at in this
    section in order to incorporate additional processing capability. Hopefully, this
    will highlight both the power and flexibility of the Google Cloud environment.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将对本节中讨论的例子进行适应，以便加入额外的处理能力。希望这能突出显示Google Cloud环境的强大功能和灵活性。
- en: Building a Representation State Transfer (REST) API
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建表示状态转移（REST）API
- en: Providing an extensible API presents us with an opportunity to integrate other
    software into our application. We have already looked at how the building blocks
    have been put together in terms of developing serverless applications. With Cloud
    Run, we can expand this knowledge and build extensible interfaces that can expose
    access to selected parts of an application. If you come from a GNU/Linux background,
    this will be abundantly clear and something you may take for granted. For others,
    it can be a moment of clarity where an application allows you to do more than
    expected. There are times in which we might not even know that an implementation
    supports an interface that's being used for a task.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 提供一个可扩展的API为我们提供了将其他软件集成到我们应用中的机会。我们已经看过如何在开发无服务器应用程序时将构建块组合在一起。通过Cloud Run，我们可以扩展这些知识，构建可扩展的接口，以暴露对应用程序特定部分的访问。如果你来自GNU/Linux背景，这一点会显而易见，并且可能会被视为理所当然。对其他人来说，这可能是一个清晰的时刻，在这个时刻，某个应用程序允许你做出超出预期的事情。有时，我们甚至不知道一个实现支持用于某个任务的接口。
- en: For this example, we will build a basic API that uses REST to demonstrate how
    Cloud Run can be used to meet this requirement. If you have not come across the
    term REST API, this typically refers to stateless operations, the most common
    of which are GET and POST. The API uses these operations to retrieve and send
    information using web resources.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将构建一个基本的API，使用REST来演示如何使用Cloud Run来满足这一需求。如果你还没有接触过REST API这个术语，通常它指的是无状态操作，其中最常见的是GET和POST。该API使用这些操作来通过Web资源检索和发送信息。
- en: 'Our first example will build a fundamental REST API that''s built on Cloud
    Run to provide access to backend data. It will have the following components:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个例子将构建一个基本的REST API，它基于Cloud Run来提供对后端数据的访问。它将包括以下组件：
- en: '**A basic API**: Used to retrieve retail data.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个基本的API**：用于检索零售数据。'
- en: '**A list of goods available**: The API will be provided with a code and retrieve
    the associated object information.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用商品列表**：API将提供一个代码，并检索相关的对象信息。'
- en: 'From the preceding examples, it should be clear that the API provides us with
    a simple mechanism that we can use to retrieve information related to the data
    object. If we were to expand the data object, we would still be able to access
    this data, without any changes needing to be made to the API—that is, the power
    of abstracting information access away from the data so that it can be enhanced
    independently:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中，我们可以清楚地看到，API为我们提供了一个简单的机制，可以用来检索与数据对象相关的信息。如果我们扩展数据对象，仍然可以访问这些数据，无需对API做任何修改——也就是说，将信息访问与数据分离，从而能够独立增强其功能：
- en: '![](img/e3b47e58-16b6-473f-a25f-c998b5a0965b.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3b47e58-16b6-473f-a25f-c998b5a0965b.png)'
- en: From the preceding diagram, we can see that a number of API calls have been
    defined that will call the various endpoints. Each of the API endpoints has a
    specific job; for example, retrieving management reports, handling transactional
    information, and storing information in the data warehouse. Here, we can see that
    the **Business Endpoint** uses a post API call, which indicates that information
    is posted to the endpoint (perhaps a set of filter information) for further processing.
    Both the **Retail** and **Finance** endpoint calls use GET to pull back information
    for **Transactions** and **Data Warehouse**.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的图示中，我们可以看到，已经定义了多个API调用来调用各个端点。每个API端点都有特定的任务；例如，检索管理报告、处理事务信息和将信息存储到数据仓库。在这里，我们可以看到，**业务端点**使用的是POST
    API调用，表示将信息（可能是一组过滤信息）发布到端点进行进一步处理。**零售**和**财务**端点调用使用GET方法来拉取**交易**和**数据仓库**的信息。
- en: 'The following are some general rules that help define good practices when building
    compelling REST APIs. The key principles we want to introduce are as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些帮助定义良好实践的通用规则，当构建引人注目的REST API时，我们希望介绍的关键原则如下：
- en: Base URL
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础URL
- en: API consistency
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API一致性
- en: Error handling
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理
- en: API versioning
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API版本控制
- en: To understand the theory and general rules behind this a bit more, we will explore
    the aforementioned key principles. This will assist us when we design an API later
    in this chapter.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更深入地理解背后的理论和通用规则，我们将探讨上述关键原则。这将帮助我们在本章后面设计 API 时。
- en: Base URL
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础 URL
- en: We want the base URL to have significance to the name query. A good starting
    point is to consider what the base URL is meant to represent and how this can
    be modeled to be representative of the underlying data.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望基础 URL 对查询名称具有意义。一个好的起点是考虑基础 URL 应该代表什么，以及如何将其建模以代表底层数据。
- en: Requirements
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求
- en: At this juncture in the development cycle, it seems rather sensible to have
    the means to access all of the data collection. It would also seem helpful to
    be able to isolate an element within that collection using the same API call.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发周期的这个阶段，拥有访问所有数据集合的手段似乎是非常合理的。能够通过相同的 API 调用将集合中的元素隔离开来也显得非常有用。
- en: 'If we consider these requirements, the need for an intuitive base URL capable
    of meeting our requirements should become more apparent. In the following diagram,
    we can see how this API would work with the help of two queries:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑这些要求，需求一个直观的基础 URL 以满足我们的需求应该变得更加明显。在接下来的图表中，我们可以看到在两个查询的帮助下，如何使这个 API
    工作：
- en: '![](img/d53dbf92-8f5f-4fa2-9c80-0e35cb6ac6af.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d53dbf92-8f5f-4fa2-9c80-0e35cb6ac6af.png)'
- en: 'Here, the queries do the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，查询执行以下操作：
- en: Query A will be capable of gathering all the books stored in the collection.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询 A 将能够获取集合中存储的所有书籍。
- en: Query B will be capable of gathering a specific item from within the collection.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询 B 将能够从集合中获取特定项目。
- en: 'The preceding diagram illustrates a situation in which the base URL encompasses
    two use cases for data access:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的图表展示了一种情况，其中基础 URL 涵盖了数据访问的两个用例：
- en: '`/[collective noun]`: Access to a collection; for example, retrieve all books'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/[集体名词]`：访问集合；例如，检索所有书籍'
- en: '`/[collective noun]/[element]`: Access to an element within the collection;
    for example, retrieve the books labeled `1234`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/[集体名词]/[元素]`：访问集合中的一个元素；例如，检索标签为 `1234` 的书籍'
- en: Using a collective noun to categorize the base URL allows us to access the full
    collection and individual items. Now, we have to simplify the base URL; our next
    consideration is how to achieve greater API consistency. In the next subsection,
    we will explore how to implement this using Cloud Run.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用集体名词来对基础 URL 进行分类，可以让我们访问整个集合和单个项目。现在，我们需要简化基础 URL；我们接下来的考虑是如何实现更高的一致性 API。在接下来的子章节中，我们将探讨如何使用
    Cloud Run 来实现这一点。
- en: Implementing a base URL
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现基础 URL
- en: 'Our first task is to implement a base URL. Fortunately, in our case, the job
    is relatively simple; however, it also illustrates the point we are trying to
    make. Let''s get started:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一项任务是实现一个基础 URL。幸运的是，在我们的案例中，工作相对简单；然而，它也说明了我们试图表达的观点。让我们开始吧：
- en: 'Within the `ch08` folder create a new directory called `baseURL` and move to
    it:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ch08` 文件夹中创建一个名为 `baseURL` 的新目录并进入：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Edit the generated `package.json` file and add the following line to the script
    section:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑生成的 `package.json` 文件，并在脚本部分添加以下行：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a new file named `index.js` and add the following code:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `index.js` 的新文件，并添加以下代码：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create a new file named `Dockerfile` and add the following content:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Dockerfile` 的新文件，并添加以下内容：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Working in Cloud Shell provides a number of features that are easy to take
    for granted. One particular thing is the current project identifier. To get the
    value of this at the command line, do the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cloud Shell 中工作提供了许多容易被忽视的功能。一个特别的功能是当前项目标识符。要在命令行中获取此值，请执行以下操作：
- en: '**`gcloud config get-value project`**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**`gcloud config get-value project`**'
- en: 'Even better, you can assign it to an environment variable by doing the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，你可以通过以下方式将其分配给环境变量：
- en: '**`PROJECT_ID=$(gcloud config get-value project)`**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**`PROJECT_ID=$(gcloud config get-value project)`**'
- en: 'Build an image based on the application (note that `$PROJECT_ID` is an environment
    variable that''s been set to my Google Project Identifier):'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于应用程序构建镜像（请注意，`$PROJECT_ID` 是一个已设置为我的 Google 项目标识符的环境变量）：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Deploy the image to Cloud Run. Take note of the `SERVICE_URL` that''s returned
    from this command:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将镜像部署到 Cloud Run。注意此命令返回的 `SERVICE_URL`：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once the app has been deployed, we can test our API from the Cloud Shell using
    the following command:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦应用程序部署完成，我们可以通过以下命令在 Cloud Shell 中测试我们的 API：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: From the preceding code, we can see that to implement a base URL, we need to
    choose something that complements our API. In this instance, the collective noun
    `books` also made for a good base URL.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码可以看到，要实现基本 URL，我们需要选择一个与我们的 API 互补的东西。在此示例中，集合名词 `books` 也很适合作为基本 URL。
- en: When considering how to develop a URL, it is worth considering the use case
    for the API and applying some logic in terms of determining how the schema can
    be sensibly applied. Now that we have defined our base URL, we can look at how
    to develop a consistent interface for the API.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑如何开发 URL 时，值得考虑 API 的使用场景，并应用一些逻辑来确定如何合理地应用模式。现在我们已经定义了基本 URL，接下来可以看看如何为
    API 开发一致的接口。
- en: API consistency
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 一致性
- en: 'The aim of API consistency is to simplify access to exposed information:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: API 一致性的目标是简化对公开信息的访问：
- en: '| **Resource** | **POST** | **GET** | **PUT** | **DELETE** |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| **资源** | **POST** | **GET** | **PUT** | **DELETE** |'
- en: '| `/books` | Create a new book | List books | Batch update | Delete the book
    collection |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `/books` | 创建新书籍 | 列出书籍 | 批量更新 | 删除书籍集合 |'
- en: '| `/books/1111` | Invalid | Show a book | Invalid | Delete a book |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `/books/1111` | 无效 | 显示一本书 | 无效 | 删除一本书 |'
- en: In our example, the collections and elements can be made accessible through
    the use of HTTP verbs, as shown in the preceding table.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，集合和元素可以通过使用 HTTP 动词来访问，如前表所示。
- en: Requirements
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求
- en: 'From the preceding information, note how the API is used in relation to the
    HTTP verb. For example, we know the following to be true:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的信息中，注意到 API 是如何与 HTTP 动词相关联使用的。例如，我们知道以下内容是正确的：
- en: POST events are used for sending data.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POST 事件用于发送数据。
- en: GET events are used for listing (querying) data.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GET 事件用于列出（查询）数据。
- en: PUT events are used for batch updates.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PUT 事件用于批量更新。
- en: DELETE events are used for removing items.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DELETE 事件用于删除项目。
- en: How would we use these capabilities in conjunction with our book API? As shown
    in the preceding table, the API being presented provides a consistent interface
    for expected outcomes. However, what would an implementation of this look like?
    We will look at this in the next subsection.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将这些功能与我们的书籍 API 一起使用呢？如前表所示，所呈现的 API 提供了一个一致的接口，用于预期的结果。然而，这种实现会是什么样子呢？我们将在下一小节中讨论这个问题。
- en: Implementing API consistency
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 API 一致性
- en: 'Consistency is something all API developers strive for. To achieve this, we
    need to consider how the API will be used. In our example, we will update the
    API to provide a GET request for all the books, as well as a single book. Let''s
    get started:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性是所有 API 开发者所追求的目标。为了实现这一目标，我们需要考虑 API 将如何被使用。在我们的示例中，我们将更新 API，提供一个 GET 请求来获取所有书籍以及单本书籍。我们开始吧：
- en: Edit the `index.js` file.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `index.js` 文件。
- en: 'Add the HTTP `GET ID`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 HTTP `GET ID`：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the HTTP `POST`:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 HTTP `POST`：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the HTTP `DELETE`:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 HTTP `DELETE`：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the HTTP `DELETE ID`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 HTTP `DELETE ID`：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the HTTP `PUT`:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 HTTP `PUT`：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Update the build image by running the following command:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令来更新构建镜像：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Redeploy the image to Cloud Run using the following command:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令重新部署镜像到 Cloud Run：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we can use the `curl` command to test the enhancements that were made
    to the API:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `curl` 命令来测试我们对 API 所做的增强：
- en: '| **HTTP verb** | **Test /books endpoint** | **Test result** | **Test /books/:id**
    | **Test result** |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP 动词** | **测试 /books 端点** | **测试结果** | **测试 /books/:id** | **测试结果**
    |'
- en: '| `GET` | `curl [SERVICE_URL]/books` | `{"status":"GET"}` | `curl [SERVICE_URL]/books/1111`
    | `{"status":"GET ID"}` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `curl [SERVICE_URL]/books` | `{"status":"GET"}` | `curl [SERVICE_URL]/books/1111`
    | `{"status":"GET ID"}` |'
- en: '| `POST` | `curl --data "author=atwood" [SERVICE_URL]/books` | `{"status":"POST"}`
    | N/A | N/A |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `curl --data "author=atwood" [SERVICE_URL]/books` | `{"status":"POST"}`
    | N/A | N/A |'
- en: '| `PUT` | N/A | N/A | `curl -X PUT --data "author=atwood" [SERVICE_URL]/books`
    | `{"status":"PUT"}` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | N/A | N/A | `curl -X PUT --data "author=atwood" [SERVICE_URL]/books`
    | `{"status":"PUT"}` |'
- en: '| `DELETE` | `curl -X [SERVICE_URL]/books/1111` | `{"status":"DELETE"}` | `curl
    -X [SERVICE_URL]/books/1111` | `{"status":"DELETE ID"}` |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | `curl -X [SERVICE_URL]/books/1111` | `{"status":"DELETE"}` | `curl
    -X [SERVICE_URL]/books/1111` | `{"status":"DELETE ID"}` |'
- en: From these changes, we can see that the API calls are now consistent in that
    a call to get an individual book or collection of books utilizes the same interface
    type. The commonality between interface calls provides continuity between calls
    so that the API developer is assured of the meaning of the call being made.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些变化中，我们可以看到 API 调用现在是一致的，即获取单个书籍或书籍集合的调用都使用相同的接口类型。接口调用之间的共性提供了调用之间的连续性，从而确保
    API 开发者能够理解所进行的调用的含义。
- en: Now that we know what makes up an API, let's move on to handling errors.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了构成 API 的要素，接下来我们来处理错误。
- en: Error handling
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: Handling error situations in code can be quite a complex affair. There's a wealth
    of HTTP status codes, but that doesn't mean an API should use all of them. In
    many respects, it can be clearer if a subset is used instead to indicate an error
    has occurred.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中处理错误情况可能相当复杂。虽然有很多 HTTP 状态码，但这并不意味着一个 API 应该使用所有状态码。从很多方面来看，如果只使用其中的一部分来指示发生了错误，反而会更加清晰。
- en: Requirements
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求
- en: 'At a high level, there are three specific outcomes that most definitely need
    to be mapped, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，有三个特定的结果是必须映射的，如下所示：
- en: '`200`: The application is working as expected. Everything is OK.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`200`: 应用程序按预期工作，一切正常。'
- en: '`400`: The application is not working as expected. A client error has occurred;
    that is, bad client data.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`400`: 应用程序没有按预期工作。发生了客户端错误；也就是说，客户端数据有误。'
- en: '`500`: The API is not working as expected. A server error has occurred; that
    is, a bad server process.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`500`: API 没有按预期工作。发生了服务器错误；也就是说，服务器进程有误。'
- en: This list can be expanded to include a more detailed analysis, but the preceding
    messages provide a good baseline for any further API development.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表可以扩展以包括更详细的分析，但前面的消息为进一步的 API 开发提供了一个良好的基础。
- en: Error handling
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'It is important to have a consistent and clear understanding of the types of
    errors that are being managed by the API. In our example, we''ll adopt the three
    outcomes we mapped previously. Let''s get started:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 API 管理的错误类型并保持一致和清晰是非常重要的。在我们的示例中，我们将采用之前映射的三种结果。让我们开始吧：
- en: 'Amend each API call to incorporate the return of a `success` status call, as
    follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改每个 API 调用，加入 `success` 状态调用，如下所示：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add a client- and server-side error response state (note that we don''t have
    any server-side resources, so this code is just being used as an example):'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加客户端和服务器端错误响应状态（请注意，我们没有服务器端资源，因此此代码仅作为示例使用）：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By making the preceding code changes, we can see that the status of an API call
    is more clearly defined when an appropriate status code is returned. Being able
    to implement a clear interface together with a consistent response allows developers
    to have confidence in the use of the code that's provided. The final part of this
    section will cover how to approach versioning.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过进行前述代码更改，我们可以看到，当返回适当的状态码时，API 调用的状态更加清晰明了。能够实现一个清晰的接口，并且响应一致，使得开发者能够对所提供的代码的使用充满信心。本节的最后部分将介绍如何处理版本控制。
- en: API versioning
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 版本控制
- en: 'A good rule of thumb is to always include a version number in the signature
    of the REST API to be released. Applying a version number to an API can be useful
    for managing defects and maintaining backward compatibility. There are a number
    of strategies that we can follow to include versioning within the URL; however,
    a good place to start is through the use of an ordinal number to signify the interface,
    as shown in the following example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的经验法则是始终在即将发布的 REST API 签名中包含版本号。为 API 添加版本号有助于管理缺陷并保持向后兼容性。我们可以采取多种策略在 URL
    中加入版本控制；然而，一个好的起点是使用序数来表示接口，如以下示例所示：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding example, we relate the API to `v1`, which means we can clearly
    see which version is being applied for the query. If we introduce a `v2` API,
    again, it is clear to a user of the API which version is in play without needing
    additional support. Version changes will often be made to maintain backward compatibility
    or signify changes to the underlying API. Presenting developers with an opportunity
    to update their code without breaking existing integrations will be imperative
    to anyone using the API.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们将 API 与 `v1` 版本相关联，这意味着我们可以清楚地看到查询所应用的版本。如果我们引入 `v2` API，用户仍然可以清楚地知道正在使用哪个版本，而无需额外的支持。版本变更通常是为了保持向后兼容性或表示底层
    API 的变化。为开发者提供更新代码的机会，而不破坏现有的集成，对于任何使用该 API 的人来说都是至关重要的。
- en: Requirements
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求
- en: 'We want an API that enables multiple revisions of the API to coexist, like
    so:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望有一个能够让多个版本共存的 API，像这样：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If we need to integrate alternative versions of an API, this is one approach
    that works well.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要集成不同版本的 API，这是一种行得通的方法。
- en: Express versioning with routing
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用路由的 Express 版本控制
- en: 'Of course, we should also include versioning as part of our API. Here, we need
    to update the code to reflect that the code is based on `v1` of the book''s API
    by utilizing an awesome feature of express called **routing**. Let''s get started:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也应该将版本控制作为 API 的一部分。这里，我们需要更新代码以反映该代码基于书籍 API 的 `v1` 版本，利用 express 提供的一个很棒的功能——**路由**。让我们开始吧：
- en: Copy `index.js` to `bookapi_v1.js`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `index.js` 复制到 `bookapi_v1.js`。
- en: 'Edit the `index.js` file and add the following declaration:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `index.js` 文件并添加以下声明：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Remove all `app.put`, `app.get`, `app.delete`, and `app.post` functions. Your
    code base should look like this:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除所有 `app.put`、`app.get`、`app.delete` 和 `app.post` 函数。你的代码库应该看起来像这样：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we need to update our code so that it references our new book version.
    Follow these steps to do so:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新代码，使其引用新的书籍版本。按照以下步骤操作：
- en: Edit `bookapi_v1.js`.
  id: totrans-162
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `bookapi_v1.js`。
- en: Remove all `app.listen` and `app.use` functions, as well as the `const` port
    definition.
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除所有 `app.listen` 和 `app.use` 函数，以及 `const` 端口定义。
- en: 'The file should now look like this:'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在文件应该是这样的：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add a definition for the express `Router` after the `express` variable:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `express` 变量后添加一个 `Router` 的定义：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Rename all `app.` to `bookapi_v1`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有 `app.` 重命名为 `bookapi_v1`。
- en: 'Add the following reference to the bottom of the file:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件底部添加以下引用：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Rebuild the image and deploy it. You will notice that you need to append the
    version to the URL; for example, `[SERVICE_URL]/v1/books`. Now that the API has
    been integrated into the query, it is much easier to ascertain which version is
    being called. As an API matures, it will likely incorporate additional features
    or replace existing ones. These changes may not always be backward compatible,
    meaning that API developers need to be made aware of any incompatibilities. Versioning
    is a good strategy if you wish to manage expectations and gain access to feature
    sets as the API is developed.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 重新构建镜像并部署。你会注意到需要在 URL 中添加版本号；例如，`[SERVICE_URL]/v1/books`。现在 API 已经集成到查询中，更容易确认调用的是哪个版本。随着
    API 的成熟，它可能会加入新的特性或替换现有的功能。这些变化可能并非总是向后兼容的，这意味着 API 开发者需要了解任何不兼容的地方。如果你希望管理预期并在
    API 开发过程中获取功能集，版本管理是一种不错的策略。
- en: At this point, you should have a really good understanding of the type of things
    to consider when creating your own API. In the next section, we will look at developing
    an application using Cloud Run.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你应该对创建自己 API 时需要考虑的事项有很好的理解。在下一部分，我们将学习如何使用 Cloud Run 开发应用。
- en: Developer productivity
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发者生产力
- en: In our second example, we will investigate the development tools that accompany
    the Cloud Run environment. Creating a PDF is something most of us now take for
    granted, and it is one of the easiest ways to share documentation. Many businesses
    utilize a service that sends out invoices or similar information to their customer
    base.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第二个例子中，我们将探讨随 Cloud Run 环境提供的开发工具。创建 PDF 是现在大多数人都会做的事情，它是分享文档的最简单方法之一。许多企业利用服务向客户发送发票或类似的信息。
- en: Similar to Cloud Functions, becoming familiar with the environment and establishing
    a development workflow can increase your levels of productivity. In this section,
    we will also take a look at how to integrate other developer tools such as Cloud
    Run, Cloud Build, Source Repositories, and Container Registry, as these can be
    hugely beneficial when developing on Google Cloud.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 Cloud Functions，熟悉环境并建立开发工作流可以提高你的生产力水平。在这一部分，我们还将看看如何集成其他开发者工具，如 Cloud
    Run、Cloud Build、源代码库和容器注册表，因为这些在 Google Cloud 上开发时能带来极大的帮助。
- en: 'Before we begin looking at the example, let''s take a moment to explore a typical
    development workflow. For many developers, their workflow resembles something
    like the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始查看示例之前，先花点时间来探索一个典型的开发工作流。对许多开发者来说，他们的工作流大致像下面这样：
- en: Code is held in a repository; for example, GitHub, Bitbucket, or Source Repository
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码保存在一个仓库中，例如 GitHub、Bitbucket 或 Source Repository
- en: A build process is initiated
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动构建过程
- en: Cloud Source Repository
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cloud Source Repository
- en: The Cloud Source Repository is useful if you want to have a private repository
    for your code. However, it can also be used to mirror public repositories so that
    code assets are available within your project. Once the repository has been mirrored
    on Google Cloud, any commits that are pushed will be automatically synced to the
    Cloud Source Repository. This is important because it means you can continue to
    use your original repository and not be concerned about any maintenance tasks
    that ensure the repositories are kept in sync.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Source Repository 如果你想要为你的代码拥有一个私有仓库，它非常有用。不过，它也可以用来镜像公共仓库，这样代码资产就可以在你的项目中使用。一旦仓库在
    Google Cloud 上被镜像，任何推送的提交将会自动同步到 Cloud Source Repository。这一点很重要，因为它意味着你可以继续使用原始仓库，而不必担心任何维护任务，确保仓库保持同步。
- en: Cloud Build
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cloud Build
- en: Building source code is a dull activity. Whether it's a small or large component,
    the process is nothing more than a repetitive loop. Cloud Build, however, can
    take over this process and free up some of your time. While the main examples
    focus on building Dockerfile manifests, Cloud Build can actually build many other
    things (for example commands, `git`, `go`, `gcloud`, `gradle`, `kubectl`, and
    `npm`). Even better, it can be extended to build other things through the use
    of open source builders. Community builders are available for Helm, Flutter, and
    Android, and the list continues to grow.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 构建源代码是一个枯燥的活动。不管是小的还是大的组件，过程无非是一个重复的循环。然而，Cloud Build 可以接管这个过程，释放出一些时间。虽然主要的示例集中在构建
    Dockerfile 清单上，但 Cloud Build 实际上可以构建许多其他东西（例如命令、`git`、`go`、`gcloud`、`gradle`、`kubectl`
    和 `npm`）。更棒的是，它可以通过使用开源构建器来扩展构建其他内容。社区构建器已经可以用于 Helm、Flutter 和 Android，且列表还在持续增长。
- en: Build events are triggered by changes that are made in the repository, at which
    point a predefined series of processes commence. In the Cloud Build history page
    (also in its alpha stage), access to prior builds is available. The page incorporates
    a range of fields with representative data, such as Build, Source, Commit, Time/Date
    created, and the duration of the build. Additional information totaling 13 fields
    is available, as well as a filter that can be applied to build a report.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对仓库所做的更改触发构建事件，此时会启动一系列预定义的过程。在 Cloud Build 历史页面（目前仍处于 alpha 阶段）中，可以访问到之前的构建记录。该页面包含了一些具有代表性的数据字段，如构建、源、提交、创建时间/日期和构建时长。还有13个额外的信息字段以及一个可应用的筛选器，用于生成报告。
- en: The Triggers page is where the magic happens; if you have used Cloud Build previously,
    this page will be very familiar to you. While currently in its beta stage, the
    page specifies two views for active and inactive repositories, respectively. Active
    repositories have triggers associated with them, while inactive artifact repositories
    do not. A typical trigger would be **Push to any branch**, meaning that every
    addition of new code to a branch within the specified repository will mean the
    generation of an event. This event is associated with a build process, which enables
    a wide variety of predefined and custom processing to occur. We will cover more
    on triggers later in this chapter.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there is the Settings page, which is where service account management
    details are available. In order to use Cloud Build, you will need the service
    account to be bound to the permissions within the project. In most instances,
    the need for additional service account permissions for further access requires
    IAM. Bear in mind that in addition to screen, the majority of roles can be managed
    directly from the IAM section of the Google Cloud Console. Previously, we examined
    some of the core fundamentals of working with containers on Google Cloud. To baseline
    our shared understanding of this, in the next section, we will start with a simple
    introduction to Cloud Run and see how we can incorporate this knowledge into further
    examples.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: The continuous integration example
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following example, we will create an instance in which we will build
    a development workflow that utilizes a repository and shows how simple it is to
    create such a workflow in Cloud Build. Let's imagine that some code exists in
    a repository and that we have a predefined trigger associated with it. Each time
    code is committed to the repository, a signal will be sent to Cloud Build to initiate
    the event related to the mirrored repository. In the preceding examples, we saw
    that a variety of languages are supported. In our case, we will initiate an action
    that's been defined within the Cloud Build environment that will replace having
    to start a build process from the local development machine manually. To invoke
    the automated build, we will have to push code to the repository, as would typically
    be the case.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Our application is a simple one; the emphasis in this example will be on the
    tools rather than the code. In the `ch08` directory, change the current folder
    to be `node-ci`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the directory, notice that there is a `cloudbuild.yaml` file. It is this
    file that ensures the build steps are performed. The contents of the file are
    outlined as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the preceding example we omit tests as we haven''t defined any. However
    if you want these to be included add the following line:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '`- name: ''gcr.io/cloud-builders/npm''`'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '`args: [''test'']`'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that three steps are defined in this file, all of which assist with our
    build process:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '**Npm package installation**: Installs the dependency packages'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Npm audit fix**: Performs a check to see whether the packages can be automatically
    fixed'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Docker build**: Builds an image based on the node application using a Dockerfile'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final line represents a timeout setting for the `cloudbuild.yaml` file
    and the build max duration. At the time of writing, this is set to 10 minutes.
    If we were to run the preceding commands, it would output a new build image based
    on the code given. We can manually invoke the builder from the command line, as
    follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: However, we don't want to run a `build` command manually; it should be run automatically
    when we push the code to the repository.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure the repository responds in the way we want it to, we need to add
    the Google Cloud Build action. Back in the Google Cloud console, find the Cloud
    Build option. From the resulting menu, choose the Triggers option:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57b25748-57f7-4c78-ade1-f4a90ab269e2.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: If you haven't created a trigger before, the screen will look similar to this
    graphic (if you have existing triggers already configured they will be present
    in this screen).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc4a4509-d8f7-4185-ab97-05e564892308.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
- en: Creating a trigger makes a link between a source repository and Cloud Build.
    The following graphic illustrates the information required to create a new trigger.
    The setup for the application is highly customisable, but let's take a base case
    for our example. First, we need to enable Google Cloud Build in our repository.
    In this example, note that the source repository being used is GitHub.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a26b7436-22fd-46f9-b61b-0b41d7d1fd7f.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: 'When you add the application, you will be asked for permission to access the
    repository, as well as which repositories should be granted access. It is important
    to remember that not all the repositories need to be made available to the application:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47f19573-7348-4f3b-a193-beeb49a566dc.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
- en: Now that we have granted access, in the Google Cloud, we can use Cloud Build
    (alpha) to create a new trigger event based on the repository we have just configured.
    Use the connect repository option and set up the application so that whenever
    a branch is updated, the trigger will be invoked. The default settings are based
    on any branch within a repository being updated, but this can be amended to a
    tag or pull request. In addition, the build configuration can also be changed
    from implementing the auto-detect feature to using either a Dockerfile or Cloud
    Build configuration file (YAML or JSON).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Once you have set this up, update the code in order to push a change. You will
    see the backend code being triggered automatically. Congratulations! You have
    just become more productive by being able to automatically create an artifact
    by pushing code. In the next chapter, we will entertain a more intricate example
    of this workflow with multiple services.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked into the critical aspects of Cloud Run and worked
    through some everyday use cases. During this process, we observed many essential
    concepts, such as how to incorporate Cloud Build and Container Registry developer
    tooling into our workflow. For those of you who were unfamiliar with these tools,
    hopefully, you now know enough to use them in your day-to-day tasks. Building
    on our introduction of containerized environments (for example, Docker), we learned
    how Cloud Run removes much of the complexity of deploying consistent and isolated
    code. Once the container has been built successfully, it can be deployed. As with
    Google's other serverless products, Cloud Run scales to zero.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Support for serverless request/response messages is inherent in Cloud Run, so
    there is a consistent and straightforward method for developing components. Besides,
    adding a new language runtime can be achieved without distraction or negating
    the flexibility of the service. By utilizing the container artifact, Cloud Run
    can easily be enhanced to incorporate Kubernetes.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue our Cloud Run journey and explore the
    key differences when working on the Kubernetes platform.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a base URL?
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is API versioning important?
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What verbs would you expect to be available with a REST API?
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is it appropriate to return an HTTP status code of 4xx?
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the maximum duration setting for a Cloud Build?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cloud Build can be used for Android (True or False).
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where are the errors for Cloud Build shown?
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**CI/CD on Google Cloud**: [https://cloud.google.com/docs/ci-cd/](https://cloud.google.com/docs/ci-cd/)'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creating and managing build triggers**: [https://cloud.google.com/cloud-build/docs/running-builds/create-manage-triggers](https://cloud.google.com/cloud-build/docs/running-builds/create-manage-triggers)'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creating GitHub app triggers**: [https://cloud.google.com/cloud-build/docs/create-github-app-triggers](https://cloud.google.com/cloud-build/docs/create-github-app-triggers)'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Cloud APIs**: [https://cloud.google.com/apis/docs/overview](https://cloud.google.com/apis/docs/overview)'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Cloud Podcast – HTTP/2, SPDY, and QUIC with Ilya Grigorik**: [https://www.gcppodcast.com/post/episode-6-http2-spdy-and-quic-with-ilya-grigorik/](https://www.gcppodcast.com/post/episode-6-http2-spdy-and-quic-with-ilya-grigorik/)'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container Registry**: [https://cloud.google.com/container-registry/](https://cloud.google.com/container-registry/)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serverless Sessions - Google Cloud Next ''19**: [https://www.youtube.com/playlist?list=PLIivdWyY5sqLYz6HIadOZHE9PsKX-0CF8](https://www.youtube.com/playlist?list=PLIivdWyY5sqLYz6HIadOZHE9PsKX-0CF8)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
