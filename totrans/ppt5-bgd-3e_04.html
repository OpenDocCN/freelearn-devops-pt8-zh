<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Understanding Puppet resources"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Understanding Puppet resources</h1></div></div></div><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><span class="emphasis"><em>Perplexity is the beginning of knowledge.</em></span></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<span class="attribution"><span class="emphasis"><em>Khalil Gibran</em></span></span></td></tr></table></div><p>We've already met three important types of Puppet resources: <code class="literal">package</code>, <code class="literal">file</code>, and <code class="literal">service</code>. In this chapter, we'll learn more about these, plus other important resource types for managing users, groups, SSH keys, cron jobs, and arbitrary commands.</p><div class="mediaobject"><img src="graphics/B08880_04_01.jpg" alt="Understanding Puppet resources"/></div><div class="section" title="Files"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec15"/>Files</h1></div></div></div><p>We saw in <a class="link" href="ch02.html" title="Chapter 2. Creating your first manifests">Chapter 2</a>, <span class="emphasis"><em>Creating your first manifests</em></span> that Puppet can manage files on a node using the <code class="literal">file</code> <a id="id92" class="indexterm"/>resource, and we looked at an example which sets the contents of a file to a particular string using the <code class="literal">content</code> attribute. Here it is again (<code class="literal">file_hello.pp</code>):</p><div class="informalexample"><pre class="programlisting">file { '/tmp/hello.txt':
  content =&gt; "hello, world\n",
}</pre></div><div class="section" title="The path attribute"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec28"/>The path attribute</h2></div></div></div><p>We've seen that every Puppet <a id="id93" class="indexterm"/>resource has a title (a quoted string followed by a colon). In the <code class="literal">file_hello</code> example, the title of the <code class="literal">file</code> resource is <code class="literal">'/tmp/hello.txt'</code>. It's easy to guess that Puppet is going to use this value as the path of the created file. In fact, <code class="literal">path</code> is one of the attributes you can specify for a <code class="literal">file</code>, but if you don't specify it, Puppet will use the title of the resource as the value of <code class="literal">path</code>.</p></div><div class="section" title="Managing whole files"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec29"/>Managing whole files</h2></div></div></div><p>While it's <a id="id94" class="indexterm"/>useful to be able to set the contents of a file to a short text string, most files we're likely to want to manage will be too large to include directly in our Puppet manifests. Ideally, we would put a copy of the file in the Puppet repo, and have Puppet simply copy it to the desired place in the filesystem. The <code class="literal">source</code> attribute does exactly that (<code class="literal">file_source.pp</code>):</p><div class="informalexample"><pre class="programlisting">file { '/etc/motd':
  source =&gt; '/examples/files/motd.txt',
}</pre></div><p>To try this example with your Vagrant box, run the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo puppet apply /examples/file_source.pp</strong></span>
<span class="strong"><strong>cat /etc/motd</strong></span>
The best software in the world only sucks. The worst software is significantly worse than that.
-Luke Kanies</pre></div><p>(From now on, I won't give you explicit instructions on how to run the examples; just apply them in the same way using <code class="literal">sudo puppet apply</code> as shown here. All the examples in this book are in the <code class="literal">examples/</code> directory of the GitHub repo, and I'll give you the name of the appropriate file for each example, such as <code class="literal">file_source.pp</code>.)</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip08"/>Tip</h3><p>Why do we have to run <code class="literal">sudo puppet apply</code> instead of just <code class="literal">puppet apply</code>? Puppet has the permissions of the user who runs it, so if Puppet needs to modify a file owned by <code class="literal">root</code>, it must be run with <code class="literal">root</code>'s permissions (which is what <code class="literal">sudo</code> does). You will usually run Puppet as <code class="literal">root</code> because it needs those permissions to do things like installing packages, modifying config files owned by <code class="literal">root</code>, and so on.</p></div></div><p>The value of the <a id="id95" class="indexterm"/>
<code class="literal">source</code> attribute can be a path to a file on the node, as here, or an HTTP URL, as in the following example (<code class="literal">file_http.pp</code>):</p><div class="informalexample"><pre class="programlisting">file { '/tmp/README.md':
  source =&gt; 'https://raw.githubusercontent.com/puppetlabs/puppet/master/README.md',
}</pre></div><p>Although this is a handy feature, bear in mind that every time you add an external dependency like this to your Puppet manifest, you're adding a potential point of failure.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip09"/>Tip</h3><p>Wherever you can, use a local copy of a file instead of having Puppet fetch it remotely every time. This particularly applies to software which needs to be built from a tarball downloaded from a website. If possible, download the tarball and serve it from a local webserver or file server. If this isn't practical, using a caching proxy server can help save time and bandwidth when you're building a large number of nodes.</p></div></div></div><div class="section" title="Ownership"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec30"/>Ownership</h2></div></div></div><p>On Unix-like systems, files <a id="id96" class="indexterm"/>are associated with an <span class="strong"><strong>owner</strong></span>, a <span class="strong"><strong>group</strong></span>, and a set of <span class="strong"><strong>permissions</strong></span> to read, write, or execute the file. Since we normally run Puppet with the permissions of the <code class="literal">root</code> user (via <code class="literal">sudo</code>), the files Puppet manages will be owned by that user:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ls -l /etc/motd</strong></span>
-rw-r--r-- 1 root root 109 Aug 31 04:03 /etc/motd</pre></div><p>Often, this is just fine, but if we need the file to belong to another user (for example, if that user needs to be able to write to the file), we can express this by setting the <code class="literal">owner</code> attribute (<code class="literal">file_owner.pp</code>):</p><div class="informalexample"><pre class="programlisting">file { '/etc/owned_by_ubuntu':
  ensure =&gt; present,
  owner  =&gt; 'ubuntu',
}
<span class="strong"><strong>ls -l /etc/owned_by_ubuntu</strong></span>
-rw-r--r-- 1 ubuntu root 0 Aug 31 04:48 /etc/owned_by_ubuntu</pre></div><p>You can see that Puppet has created the file and its owner has been set to <code class="literal">ubuntu</code>. You can also set the <a id="id97" class="indexterm"/>group ownership of the file using the <code class="literal">group</code> attribute (<code class="literal">file_group.pp</code>):</p><div class="informalexample"><pre class="programlisting">file { '/etc/owned_by_ubuntu':
  ensure =&gt; present,
  owner  =&gt; 'ubuntu',
  group  =&gt; 'ubuntu',
}
<span class="strong"><strong>ls -l /etc/owned_by_ubuntu</strong></span>
-rw-r--r-- 1 ubuntu ubuntu 0 Aug 31 04:48 /etc/owned_by_ubuntu</pre></div><p>Note that this time we didn't specify either a <code class="literal">content</code> or <code class="literal">source</code> attribute for the file, but simply <code class="literal">ensure =&gt; present</code>. In this case, Puppet will create a file of zero size.</p></div><div class="section" title="Permissions"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec31"/>Permissions</h2></div></div></div><p>Files on Unix-like systems <a id="id98" class="indexterm"/>have an associated <span class="strong"><strong>mode</strong></span> which determines access permissions for the file. It governs read, write, and execute permissions for the file's owner, any user in the file's group, and other users. Puppet supports setting permissions on files using the <code class="literal">mode</code> attribute. This takes an octal value (base 8, indicated by a leading 0 digit), with each digit representing a field of 3 binary bits: the permissions for owner, group, and other, respectively. In the following example, we use the <code class="literal">mode</code> attribute to set a mode of <code class="literal">0644</code> ("read and write for the owner, read-only for the group, and read-only for other users") on a file (<code class="literal">file_mode.pp</code>):</p><div class="informalexample"><pre class="programlisting">file { '/etc/owned_by_ubuntu':
  ensure =&gt; present,
  owner  =&gt; 'ubuntu',
  mode   =&gt; '0644',
}</pre></div><p>This will be quite familiar to experienced system administrators, as the octal values for file permissions are exactly the same as those understood by the Unix <code class="literal">chmod</code> command. For more information, run the command <code class="literal">man chmod</code>.</p></div><div class="section" title="Directories"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec32"/>Directories</h2></div></div></div><p>Creating or managing <a id="id99" class="indexterm"/>permissions on a <span class="strong"><strong>directory</strong></span> is a common task, and Puppet uses the <code class="literal">file</code> resource to do this too. If the value of the <code class="literal">ensure</code> attribute is <code class="literal">directory</code>, the file will be a directory (<code class="literal">file_directory.pp</code>):</p><div class="informalexample"><pre class="programlisting">file { '/etc/config_dir':
  ensure =&gt; directory,
}</pre></div><p>As with regular files, you <a id="id100" class="indexterm"/>can use the <code class="literal">owner</code>, <code class="literal">group</code>, and <code class="literal">mode</code> attributes to control access to directories.</p></div><div class="section" title="Trees of files"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec33"/>Trees of files</h2></div></div></div><p>We've already seen that <a id="id101" class="indexterm"/>Puppet can copy a single file to the node, but what about a whole directory of files, possibly including subdirectories (known as a <span class="strong"><strong>file tree</strong></span>)? The <code class="literal">recurse</code> attribute will take care of this (<code class="literal">file_tree.pp</code>):</p><div class="informalexample"><pre class="programlisting">file { '/etc/config_dir':
  source  =&gt; '/examples/files/config_dir',
  recurse =&gt; true,
}
<span class="strong"><strong>ls /etc/config_dir/</strong></span>
1  2  3</pre></div><p>When <code class="literal">recurse</code> is <code class="literal">true</code>, Puppet will copy all the files and directories (and their subdirectories) in the source directory (<code class="literal">/examples/files/config_dir/</code> in this example) to the target directory (<code class="literal">/etc/config_dir/</code>).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip10"/>Tip</h3><p>If the target directory already exists and has files in it, Puppet will not interfere with them, but you can change this behavior using the <code class="literal">purge</code> attribute. If this is <code class="literal">true</code>, Puppet will delete any files and directories in the target directory which are not present in the source directory. Use this attribute with care.</p></div></div></div><div class="section" title="Symbolic links"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec34"/>Symbolic links</h2></div></div></div><p>Another common <a id="id102" class="indexterm"/>requirement for managing files is to create or modify a <span class="strong"><strong>symbolic link</strong></span> (known as <a id="id103" class="indexterm"/>a <span class="strong"><strong>symlink</strong></span>, for short). You can have Puppet do this by <a id="id104" class="indexterm"/>setting <code class="literal">ensure =&gt; link</code> on the <code class="literal">file</code> resource and specifying the <code class="literal">target</code> attribute (<code class="literal">file_symlink.pp</code>):</p><div class="informalexample"><pre class="programlisting">file { '/etc/this_is_a_link':
  ensure =&gt; link,
  target =&gt; '/etc/motd',
}
<span class="strong"><strong>ls -l /etc/this_is_a_link</strong></span>
lrwxrwxrwx 1 root root 9 Aug 31 05:05 /etc/this_is_a_link -&gt; /etc/motd</pre></div></div></div></div>
<div class="section" title="Packages"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec16"/>Packages</h1></div></div></div><p>We've already seen how to <a id="id105" class="indexterm"/>install a package using the <code class="literal">package</code> resource, and this is all you need to do with most packages. However, the <code class="literal">package</code> resource has a few extra features which may be useful.</p><div class="section" title="Uninstalling packages"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec35"/>Uninstalling packages</h2></div></div></div><p>The <code class="literal">ensure</code> attribute <a id="id106" class="indexterm"/>normally takes the value <code class="literal">installed</code> in order to install a package, but if you specify <code class="literal">absent</code> instead, Puppet will <span class="strong"><strong>remove</strong></span> the package if it happens to be installed. Otherwise, it will take no action. The following example will remove the <code class="literal">apparmor</code> package if it's installed (<code class="literal">package_remove.pp</code>):</p><div class="informalexample"><pre class="programlisting">package { 'apparmor':
  ensure =&gt; absent,
}</pre></div><p>By default, when Puppet removes packages, it leaves in place any files managed by the package. To purge all the files associated with the package, use <code class="literal">purged</code> instead of <code class="literal">absent</code>.</p></div><div class="section" title="Installing specific versions"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec36"/>Installing specific versions</h2></div></div></div><p>If there are multiple <a id="id107" class="indexterm"/>versions of a package available to the system's package manager, specifying <code class="literal">ensure =&gt; installed</code> will cause Puppet to install the default version (usually the latest). But, if you need a specific version, you can specify that version string as the value of <code class="literal">ensure</code>, and Puppet will install that version (<code class="literal">package_version.pp</code>):</p><div class="informalexample"><pre class="programlisting">package { 'openssl':
  ensure =&gt; '1.0.2g-1ubuntu4.8',
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip11"/>Tip</h3><p>It's a good idea to specify an exact version whenever you manage packages with Puppet, so that all the nodes will get the same version of a given package. Otherwise, if you use <code class="literal">ensure =&gt; installed</code>, they will just get whatever version was current at the time they were built, leading to a situation where different nodes have different package versions.</p></div></div><p>When a newer version of the package is released, and you decide it's time to upgrade to it, you can update the version string specified in the Puppet manifest and Puppet will upgrade the package everywhere.</p></div><div class="section" title="Installing the latest version"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec37"/>Installing the latest version</h2></div></div></div><p>On the other <a id="id108" class="indexterm"/>hand, if you specify <code class="literal">ensure =&gt; latest</code> for a package, Puppet will make sure that the latest available version is installed <span class="emphasis"><em>every time the manifest is applied</em></span>. When a new version of the package becomes available, it will be installed automatically on the next Puppet run.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p>This is not generally what you want when using a package repository that's not under your control (for example, the main Ubuntu repository). It means that packages will be upgraded at unexpected times, which may break your application (or at least result in unplanned downtime). A better strategy is to tell Puppet to install a specific version which you know works, and test upgrades in a controlled environment before rolling them out to production.</p></div></div><p>If you maintain your own package repository and control the release of new packages to it, <code class="literal">ensure =&gt; latest</code> can be a useful feature: Puppet will update a package as soon as you push a new version to the repo. If you are relying on upstream repositories, such as the Ubuntu repositories, it's better to manage the version number directly by specifying an explicit version as the value of <code class="literal">ensure</code>.</p></div><div class="section" title="Installing Ruby gems"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec38"/>Installing Ruby gems</h2></div></div></div><p>Although the <a id="id109" class="indexterm"/>
<code class="literal">package</code> resource is most often used to install <a id="id110" class="indexterm"/>packages using the normal system package manager (in the case of Ubuntu, that's APT), it can install other kinds of packages as well. Library packages for the Ruby programming language are known as <span class="strong"><strong>gems</strong></span>. Puppet can install Ruby gems for you using the <code class="literal">provider =&gt; gem</code> attribute (<code class="literal">package_gem.pp</code>):</p><div class="informalexample"><pre class="programlisting">package { 'ruby':
  ensure =&gt; installed,
}

package { 'puppet-lint':
  ensure   =&gt; installed,
  provider =&gt; gem,
}</pre></div><p>
<code class="literal">puppet-lint</code> is a Ruby gem and therefore we have to specify <code class="literal">provider =&gt; gem</code> for this package so that Puppet doesn't think it's a standard system package and try to install it via APT. Since the <code class="literal">gem</code> provider is not available unless Ruby is installed, we install the <code class="literal">ruby</code> package first, then the <code class="literal">puppet-lint</code> gem.</p><p>The <code class="literal">puppet-lint</code> tool, by the way, is a good thing to have installed. It will check your Puppet manifests for <a id="id111" class="indexterm"/>common style errors and make sure they comply with the official Puppet style guide. Try it now:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>puppet-lint /examples/lint_test.pp</strong></span>
WARNING: indentation of =&gt; is not properly aligned (expected in column 11, but found it in column 10) on line 2</pre></div><p>In this example, <code class="literal">puppet-lint</code> is warning you that the <code class="literal">=&gt;</code> arrows are not lined up vertically, which the <a id="id112" class="indexterm"/>style guide says they should be:</p><div class="informalexample"><pre class="programlisting">file { '/tmp/lint.txt':
  ensure =&gt; file,
  content =&gt; "puppet-lint is your friend\n",
}</pre></div><p>When <code class="literal">puppet-lint</code> produces no output, the file is free of lint errors.</p></div><div class="section" title="Installing gems in Puppet's context"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec39"/>Installing gems in Puppet's context</h2></div></div></div><p>Puppet <a id="id113" class="indexterm"/>itself is written at least partly in Ruby, and <a id="id114" class="indexterm"/>makes use of several Ruby gems. To avoid any conflicts with the version of Ruby and gems which the node might need for other applications, Puppet packages its own version of Ruby and associated gems under the <code class="literal">/opt/puppetlabs/</code> directory. This means you can install (or remove) whichever system version of Ruby you like and Puppet will not be affected.</p><p>However, if you need to install a gem to extend Puppet's capabilities in some way, then doing it with a <code class="literal">package</code> resource and <code class="literal">provider =&gt; gem</code> won't work. That is, the gem will be installed, but only in the system Ruby context, and it won't be visible to Puppet.</p><p>Fortunately, the <code class="literal">puppet_gem</code> provider is available for exactly this purpose. When you use this provider, the gem will be installed in Puppet's context (and, naturally, won't be visible in the system context). The following example demonstrates how to use this provider (<code class="literal">package_puppet_gem.pp</code>):</p><div class="informalexample"><pre class="programlisting">package { 'r10k':
  ensure   =&gt; installed,
  provider =&gt; puppet_gem,
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip13"/>Tip</h3><p>To see the gems installed in Puppet's context, use Puppet's own version of the <code class="literal">gem</code> command with the following path:</p><p>
<code class="literal">/opt/puppetlabs/puppet/bin/gem list</code></p></div></div></div><div class="section" title="Using ensure_packages"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec40"/>Using ensure_packages</h2></div></div></div><p>To avoid potential <a id="id115" class="indexterm"/>package conflicts between different parts of your Puppet <a id="id116" class="indexterm"/>code or between your code and third-party modules, the Puppet standard library provides a useful wrapper for the <code class="literal">package</code> resource, called <code class="literal">ensure_packages()</code>. We'll cover this in detail in <a class="link" href="ch07.html" title="Chapter 7. Mastering modules">Chapter 7</a>, <span class="emphasis"><em>Mastering modules</em></span>.</p></div></div>
<div class="section" title="Services"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec17"/>Services</h1></div></div></div><p>Although services are <a id="id117" class="indexterm"/>implemented in a number of varied and complicated ways at the operating system level, Puppet does a good job of abstracting away most of this with the <code class="literal">service</code> resource and exposing just the two attributes of services which you most commonly need to manage: whether they're running (<code class="literal">ensure</code>) and whether they start at boot time (<code class="literal">enable</code>). We covered the use of these in <a class="link" href="ch02.html" title="Chapter 2. Creating your first manifests">Chapter 2</a>, <span class="emphasis"><em>Creating your first manifests</em></span>, and most of the time, you won't need to know any more about <code class="literal">service</code> resources.</p><p>However, you'll occasionally encounter services which don't play well with Puppet, for a variety of reasons. Sometimes, Puppet is unable to detect that the service is already running and keeps trying to start it. Other times, Puppet may not be able to properly restart the service when a dependent resource changes. There are a few useful attributes for <code class="literal">service</code> resources which can help resolve these problems.</p><div class="section" title="The hasstatus attribute"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec41"/>The hasstatus attribute</h2></div></div></div><p>When a <code class="literal">service</code> <a id="id118" class="indexterm"/>resource has the attribute <code class="literal">ensure =&gt; running</code> attribute, Puppet <a id="id119" class="indexterm"/>needs to be able to check whether the service is, in fact, running. The way it does this depends on the underlying operating system. On Ubuntu 16 and later, for example, it runs <code class="literal">systemctl is-active SERVICE</code>. If the service is packaged to work with <code class="literal">systemd</code>, that should be just fine, but in many cases, particularly with older software, it may not respond properly.</p><p>If you find that Puppet keeps attempting to start the service on every Puppet run, even though the service is running, it may be that Puppet's default service status detection isn't working. In this case, you can specify the <code class="literal">hasstatus =&gt; false</code> attribute for the service (<code class="literal">service_hasstatus.pp</code>):</p><div class="informalexample"><pre class="programlisting">service { 'ntp':
  ensure    =&gt; running,
  enable    =&gt; true,
  hasstatus =&gt; false,
}</pre></div><p>When <code class="literal">hasstatus</code> is false, Puppet knows not to try to check the service status using the default system service management command, and instead, will look in the process table for a running process <a id="id120" class="indexterm"/>which matches the name of the service. If it finds one, it <a id="id121" class="indexterm"/>will infer that the service is running and take no further action.</p></div><div class="section" title="The pattern attribute"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec42"/>The pattern attribute</h2></div></div></div><p>Sometimes, when <a id="id122" class="indexterm"/>using <code class="literal">hasstatus =&gt; false</code>, the service name as defined in <a id="id123" class="indexterm"/>Puppet doesn't actually appear in the process table, because the command that provides the service has a different name. If this is the case, you can tell Puppet exactly what to look for using the <code class="literal">pattern</code> attribute.</p><p>If <code class="literal">hasstatus</code> is <code class="literal">false</code> and <code class="literal">pattern</code> is specified, Puppet will search for the value of <code class="literal">pattern</code> in the process table to determine whether or not the service is running. To find the pattern you need, you can use the <code class="literal">ps</code> command to see the list of running processes:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ps ax</strong></span>
</pre></div><p>Find the process you're interested in and pick a string which will match only the name of that process. For example, if it's <code class="literal">ntpd</code>, you might specify the <code class="literal">pattern</code> attribute as <code class="literal">ntpd</code> (<code class="literal">service_pattern.pp</code>):</p><div class="informalexample"><pre class="programlisting">service { 'ntp':
  ensure    =&gt; running,
  enable    =&gt; true,
  hasstatus =&gt; false,
  pattern   =&gt; 'ntpd',
}</pre></div></div><div class="section" title="The hasrestart and restart attributes"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec43"/>The hasrestart and restart attributes</h2></div></div></div><p>When a service is <a id="id124" class="indexterm"/>notified (for example, if a <code class="literal">file</code> resource <a id="id125" class="indexterm"/>uses the <code class="literal">notify</code> attribute to tell the service its config file has <a id="id126" class="indexterm"/>changed, a common pattern which we looked at in <a class="link" href="ch02.html" title="Chapter 2. Creating your first manifests">Chapter 2</a>, <span class="emphasis"><em>Creating your first manifests</em></span>), Puppet's default behavior is to stop the service, then start it again. This usually works, but many services implement a <code class="literal">restart</code> command in their management scripts. If this is available, it's usually a good idea to use it: it may be faster or safer than stopping and starting the service. Some services take a while to shut down properly when stopped, for example, and Puppet may not wait long enough before trying to restart them, so that you end up with the service not running at all.</p><p>If you specify <code class="literal">hasrestart =&gt; true</code> for a service, then Puppet will try to send a <code class="literal">restart</code> command to it, using whatever service management command is appropriate for the current platform (<code class="literal">systemctl</code>, for example, on Ubuntu). The following example shows the use of <code class="literal">hasrestart</code> (<code class="literal">service_hasrestart.pp</code>):</p><div class="informalexample"><pre class="programlisting">service { 'ntp':
  ensure     =&gt; running,
  enable     =&gt; true,
  hasrestart =&gt; true,
}</pre></div><p>To further complicate things, the default system service <code class="literal">restart</code> command may not work, or you may <a id="id127" class="indexterm"/>need to take certain special actions when the <a id="id128" class="indexterm"/>service is restarted (disabling monitoring notifications, for example). You can specify any <code class="literal">restart</code> command you like for the service using the <code class="literal">restart</code> attribute (<code class="literal">service_custom_restart.pp</code>):</p><div class="informalexample"><pre class="programlisting">service { 'ntp':
  ensure  =&gt; running,
  enable  =&gt; true,
  restart =&gt; '/bin/echo Restarting &gt;&gt;/tmp/debug.log &amp;&amp; systemctl restart ntp',
}</pre></div><p>In this example, the <code class="literal">restart</code> command writes a message to a log file before restarting the service in the usual way, but it could, of course, do anything you need it to. Note that the <code class="literal">restart</code> command is only used when Puppet restarts the service (generally because it was notified by a change to some config file). It's not used when starting the service from a stopped state. If Puppet finds the service has stopped and needs to start it, it will use the normal system service start command.</p><p>In the extremely rare event that the service cannot be stopped or started using the default service management command, Puppet also provides the <code class="literal">stop</code> and <code class="literal">start</code> attributes so that you can specify custom commands to stop and start the service, just the same way as with the <code class="literal">restart</code> attribute. If you need to use either of these, though, it's probably safe to say that you're having a bad day.</p></div></div>
<div class="section" title="Users"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec18"/>Users</h1></div></div></div><p>A user on Unix-like systems <a id="id129" class="indexterm"/>does not necessarily correspond to a human person who logs in and types commands, although it sometimes does. A user is simply a named entity that can own files and run commands with certain permissions and that may or may not have permission to read or modify other users' files. It's very common, for sound security reasons, to run each service on a system with its own user account. This simply means that the service runs with the identity and permissions of that user.</p><p>For example, a web server will often run as the <code class="literal">www-data</code> user, which exists solely to own files the web server needs to read and write. This limits the danger of a security breach via the web server, because the attacker would only have the <code class="literal">www-data</code> user's permissions, which are very <a id="id130" class="indexterm"/>limited, rather than the <code class="literal">root</code> user's, which can modify any aspect of the system. It is generally a bad idea to run services exposed to the public Internet as the <code class="literal">root</code> user. The service user should have only the minimum permissions it needs to operate the service.</p><p>Given this, an important part of system configuration involves creating and managing users, and Puppet's <code class="literal">user</code> resource provides a model for doing just that. Just as we saw with packages and services, the details of implementation and the commands used to manage users vary widely from one operating system to another, but Puppet provides an abstraction which hides those details behind a common set of attributes for users.</p><div class="section" title="Creating users"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec44"/>Creating users</h2></div></div></div><p>The following example <a id="id131" class="indexterm"/>shows a typical <code class="literal">user</code> and <code class="literal">group</code> declaration in Puppet (<code class="literal">user.pp</code>):</p><div class="informalexample"><pre class="programlisting">group { 'devs':
  ensure =&gt; present,
  gid    =&gt; 3000,
}

user { 'hsing-hui':
  ensure =&gt; present,
  uid    =&gt; '3001',
  home   =&gt; '/home/hsing-hui',
  shell  =&gt; '/bin/bash',
  groups =&gt; ['devs'],
}</pre></div></div><div class="section" title="The user resource"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec45"/>The user resource</h2></div></div></div><p>The title of the <a id="id132" class="indexterm"/>resource is the username (login name) of the user; in this example, <code class="literal">hsing-hui</code>. The <code class="literal">ensure =&gt; present</code> attribute says that the user should exist on the system.</p><p>The <code class="literal">uid</code> attribute needs a little more explanation. On Unix-like systems, each user has an individual numerical id, known as the <span class="strong"><strong>uid</strong></span>. The text name associated with the user is merely a convenience for those (mere humans, for example) who prefer strings to numbers. Access permissions are in fact based on the uid and not the username.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip14"/>Tip</h3><p>Why set the <code class="literal">uid</code> attribute? Often, when creating users manually, we don't specify a uid, so the system will assign one automatically. The problem with this is that if you create the same user (<code class="literal">hsing-hui</code>, for example) on three different nodes, you may end up with three different uids. This would be fine as long as you have never shared files between nodes, or copied data from one place to another. But in fact, this happens all the time, so it's important to make sure that a given user's uid is the same across all the nodes in your infrastructure. That's why we specify the <code class="literal">uid</code> attribute in the Puppet manifest.</p></div></div><p>The <code class="literal">home</code> attribute sets the user's home directory (this will be the current working directory when the user logs in, if she does log in, and also the default working directory for cron jobs that run as the user).</p><p>The <code class="literal">shell</code> attribute <a id="id133" class="indexterm"/>specifies the command-line shell to run when the user logs in interactively. For humans, this will generally be a user shell, such as <code class="literal">/bin/bash</code> or <code class="literal">/bin/sh</code>. For service users, such as <code class="literal">www-data</code>, the shell should be set to <code class="literal">/usr/sbin/nologin</code> (on Ubuntu systems), which does not allow interactive access, and prints a message saying <code class="literal">This account is currently not available</code>. All users who do not need to log in interactively should have the <code class="literal">nologin</code> shell.</p><p>If the user needs to be a member of certain groups, you can pass the <code class="literal">groups</code> attribute an array of the group names (just <code class="literal">devs</code> in this example).</p><p>Although Puppet supports a <code class="literal">password</code> attribute for <code class="literal">user</code> resources, I don't advise you to use it. Service users don't need passwords, and interactive users should be logging in with SSH keys. In fact, you should configure SSH to disable password logins altogether (set <code class="literal">PasswordAuthentication no</code> in <code class="literal">sshd_config</code>).</p></div><div class="section" title="The group resource"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec46"/>The group resource</h2></div></div></div><p>The title of the resource is the <a id="id134" class="indexterm"/>name of the group (<code class="literal">devs</code>). You need not specify a <code class="literal">gid</code> attribute but, for the same reasons as the <code class="literal">uid</code> attribute, it's a good idea to do so.</p></div><div class="section" title="Managing SSH keys"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec47"/>Managing SSH keys</h2></div></div></div><p>I like to have as <a id="id135" class="indexterm"/>few interactive logins as possible on production nodes, because it reduces the attack surface. Fortunately, with configuration management, it should rarely be necessary to actually log in to a node. The most common reasons for needing an interactive login are for system maintenance and troubleshooting, and for deployment. In both cases there should be a single account named for this specific purpose (for example, <code class="literal">admin</code> or <code class="literal">deploy</code>), and it should be configured with the SSH keys of any users or systems that need to log in to it.</p><p>Puppet provides <a id="id136" class="indexterm"/>the <code class="literal">ssh_authorized_key</code> resource to control the SSH keys associated with a user account. The following example shows how to use <code class="literal">ssh_authorized_key</code> to add an SSH key (mine, in this instance) to the <code class="literal">ubuntu</code> user on our Vagrant VM (<code class="literal">ssh_authorized_key.pp</code>):</p><div class="informalexample"><pre class="programlisting">ssh_authorized_key { 'john@bitfieldconsulting.com':
  user =&gt; 'ubuntu',
  type =&gt; 'ssh-rsa',
  key  =&gt; 'AAAAB3NzaC1yc2EAAAABIwAAAIEA3ATqENg+GWACa2BzeqTdGnJhNoBer8x6pfWkzNzeM8Zx7/2Tf2pl7kHdbsiTXEUawqzXZQtZzt/j3Oya+PZjcRpWNRzprSmd2UxEEPTqDw9LqY5S2B8og/NyzWaIYPsKoatcgC7VgYHplcTbzEhGu8BsoEVBGYu3IRy5RkAcZik=',
}</pre></div><p>The title of the resource is the SSH key comment, which reminds us who the key belongs to. The <code class="literal">user</code> attribute specifies the user account which this key should be authorized for. The <code class="literal">type</code> attribute identifies the SSH key type, usually <code class="literal">ssh-rsa</code> or <code class="literal">ssh-dss</code>. Finally, the <code class="literal">key</code> attribute sets the key itself. When this manifest is applied, it adds the following to the <code class="literal">ubuntu</code> user's <code class="literal">authorized_keys</code> file:</p><div class="informalexample"><pre class="programlisting">ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAIEA3ATqENg+GWACa2BzeqTdGnJhNoBer8x6pfWkzNzeM8Zx7/2Tf2pl7kHdbsiTXEUawqzXZQtZzt/j3Oya+PZjcRpWNRzprSmd2UxEEPTqDw9LqY5S2B8og/NyzWaIYPsKoatcgC7VgYHplcTbzEhGu8BsoEVBGYu3IRy5RkAcZik= john@bitfieldconsulting.com</pre></div><p>A user account can have multiple SSH keys associated with it, and anyone holding one of the corresponding private keys and its passphrase will be able to log in as that user.</p></div><div class="section" title="Removing users"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec48"/>Removing users</h2></div></div></div><p>If you need to have Puppet <a id="id137" class="indexterm"/>remove user accounts (for example, as part of an employee leaving process), it's not enough to simply remove the <code class="literal">user</code> resource from the Puppet manifest. Puppet will ignore any users on the system that it doesn't know about, and it certainly will not remove anything it finds on the system that isn't mentioned in the Puppet manifest; that would be extremely undesirable (almost everything would be removed). So we need to retain the <code class="literal">user</code> declaration for a while, but set the <code class="literal">ensure</code> attribute to <code class="literal">absent</code> (<code class="literal">user_remove.pp</code>):</p><div class="informalexample"><pre class="programlisting">user { 'godot':
  ensure =&gt; absent,
}</pre></div><p>Once Puppet has run everywhere, you can remove the <code class="literal">user</code> resource if you like, but it does no harm to simply leave it in place, and in fact, it's a good idea to do this, unless you can verify manually that the <a id="id138" class="indexterm"/>user has been deleted from every affected system.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip15"/>Tip</h3><p>If you need to prevent a user logging in, but want to retain the account and any files owned by the user, for archival or compliance purposes, you can set their <code class="literal">shell</code> to <code class="literal">/usr/sbin/nologin</code>. You can also remove any <code class="literal">ssh_authorized_key</code> resources associated with their account, and set the <code class="literal">purge_ssh_keys</code> attribute to <code class="literal">true</code> on the <code class="literal">user</code> resource. This will remove any authorized keys for the user that are not managed by Puppet.</p></div></div></div></div>
<div class="section" title="Cron resources"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec19"/>Cron resources</h1></div></div></div><p>Cron is the mechanism on <a id="id139" class="indexterm"/>Unix-like systems which runs scheduled jobs, sometimes known as batch jobs, at specified times or intervals. For example, system housekeeping <a id="id140" class="indexterm"/>tasks, such as log rotation or checking for security updates, are run from cron. The details of what to run and when to run it are kept in a specially formatted file <a id="id141" class="indexterm"/>called <code class="literal">crontab</code> (short for <span class="strong"><strong>cron table</strong></span>).</p><p>Puppet provides the <code class="literal">cron</code> resource for managing scheduled jobs, and we saw an example of this in the <code class="literal">run-puppet</code> manifest we developed in <a class="link" href="ch03.html" title="Chapter 3. Managing your Puppet code with Git">Chapter 3</a>, <span class="emphasis"><em>Managing your Puppet code with Git</em></span> (<code class="literal">run-puppet.pp</code>):</p><div class="informalexample"><pre class="programlisting">cron { 'run-puppet':
  command =&gt; '/usr/local/bin/run-puppet',
  hour    =&gt; '*',
  minute  =&gt; '*/15',
}</pre></div><p>The title <code class="literal">run-puppet</code> identifies the cron job (Puppet writes a comment to the <code class="literal">crontab</code> file containing this name to distinguish it from other manually-configured cron jobs). The <code class="literal">command</code> attribute specifies the command for cron to run, and the <code class="literal">hour</code> and <code class="literal">minute</code> specify the time (<code class="literal">*/15</code> is a cron syntax, meaning "every 15 minutes").</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>For more information about cron and the possible ways to specify the times of scheduled jobs, run the command <code class="literal">man 5 crontab</code>.</p></div></div><div class="section" title="Attributes of the cron resource"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec49"/>Attributes of the cron resource</h2></div></div></div><p>The <code class="literal">cron</code> resource <a id="id142" class="indexterm"/>has a few other useful attributes which are shown in the following example (<code class="literal">cron.pp</code>):</p><div class="informalexample"><pre class="programlisting">cron { 'cron example':
  command     =&gt; '/bin/date +%F',
  user        =&gt; 'ubuntu',
  environment =&gt; ['MAILTO=admin@example.com', 'PATH=/bin'],
  hour        =&gt; '0',
  minute      =&gt; '0',
  weekday     =&gt; ['Saturday', 'Sunday'],
}</pre></div><p>The <code class="literal">user</code> attribute specifies who should run the cron job (if none is specified, the job runs as <code class="literal">root</code>). If the <code class="literal">environment</code> attribute is given, it sets any environment variables the cron job might need. A common use for this is to email any output from the cron job to a specified email address, using the <code class="literal">MAILTO</code> variable.</p><p>As before, the <code class="literal">hour</code> and <code class="literal">minute</code> attributes set the time for the job to run, while you can use the <code class="literal">weekday</code> attribute to specify a particular day, or days, of the week. (The <code class="literal">monthday</code> attribute works the same way, and can take any range or array of values between 1-31 to specify the day of the month.)</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip16"/>Tip</h3><p>One important point about cron scheduling is that the default value for any schedule attribute is <code class="literal">*</code>, which means <span class="emphasis"><em>all allowed values</em></span>. For example, if you do not specify an <code class="literal">hour</code> attribute, the cron job will be scheduled with an <code class="literal">hour</code> of <code class="literal">*</code>, meaning that it will run every hour. This is generally not what you want. If you do want it to run every hour, specify <code class="literal">hour =&gt; '*'</code> in your manifest, but otherwise, specify the particular hour it should run at. The same goes for <code class="literal">minute</code>. Accidentally leaving out the <code class="literal">minute</code> attribute and having a job run sixty times an hour can have amusing consequences, to say the least.</p></div></div></div><div class="section" title="Randomizing cron jobs"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec50"/>Randomizing cron jobs</h2></div></div></div><p>If you run a cron job <a id="id143" class="indexterm"/>on many nodes, it's a good idea to make sure the job doesn't run everywhere at the same time. Puppet provides a built-in function <code class="literal">fqdn_rand()</code> to help with this; it provides a random number up to a specified maximum value, which will be different on each node, because the random number generator is seeded with the node's hostname.</p><p>If you have several such jobs to run, you can also supply a further seed value to the <code class="literal">fqdn_rand()</code> function, which can be any string and which will ensure that the value is different for each <a id="id144" class="indexterm"/>job (<code class="literal">fqdn_rand.pp</code>):</p><div class="informalexample"><pre class="programlisting">cron { 'run daily backup':
  command =&gt; '/usr/local/bin/backup',
  minute  =&gt; '0',
  hour    =&gt; fqdn_rand(24, 'run daily backup'),
}

cron { 'run daily backup sync':
  command =&gt; '/usr/local/bin/backup_sync',
  minute  =&gt; '0',
  hour    =&gt; fqdn_rand(24, 'run daily backup sync'),
}</pre></div><p>Because we gave a different string as the second argument to <code class="literal">fqdn_rand</code> for each cron job, it will return a different random value for each <code class="literal">hour</code> attribute.</p><p>The range of values returned by <code class="literal">fqdn_rand()</code> includes 0, but does not include the maximum value you specify. So, in the previous example, the values for <code class="literal">hour</code> will be between 0 and 23, inclusive.</p></div><div class="section" title="Removing cron jobs"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec51"/>Removing cron jobs</h2></div></div></div><p>Just as with <code class="literal">user</code> <a id="id145" class="indexterm"/>resources, or any type of resource, removing the resource declaration from your Puppet manifest does not remove the corresponding configuration from the node. In order to do that you need to specify <code class="literal">ensure =&gt; absent</code> on the resource.</p></div></div>
<div class="section" title="Exec resources"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec20"/>Exec resources</h1></div></div></div><p>While the other <a id="id146" class="indexterm"/>resource types we've seen so far (<code class="literal">file</code>, <code class="literal">package</code>, <code class="literal">service</code>, <code class="literal">user</code>, <code class="literal">ssh_authorized_key</code>, and <code class="literal">cron</code>) have modeled some concrete piece of state on the node, such as a file, the <code class="literal">exec</code> resource is a little different. An <code class="literal">exec</code> allows you to run any arbitrary command on the node. This might create or modify state, or it might not; anything you can run from the command line, you can run via an <code class="literal">exec</code> resource.</p><div class="section" title="Automating manual interaction"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec52"/>Automating manual interaction</h2></div></div></div><p>The most common <a id="id147" class="indexterm"/>use for an <code class="literal">exec</code> resource is to simulate manual interaction on the command line. Some older software is not packaged for modern operating systems, and needs to be compiled and installed from source, which requires you to run certain commands. The authors of some software have also not realized, or don't care, that users may be trying to install their product automatically and have install scripts which prompt for user input. This can require the use of <code class="literal">exec</code> <a id="id148" class="indexterm"/>resources to work around the problem.</p></div><div class="section" title="Attributes of the exec resource"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec53"/>Attributes of the exec resource</h2></div></div></div><p>The following <a id="id149" class="indexterm"/>example shows an <code class="literal">exec</code> resource for building and installing an imaginary piece of software (<code class="literal">exec.pp</code>):</p><div class="informalexample"><pre class="programlisting">exec { 'install-cat-picture-generator':
  cwd     =&gt; '/tmp/cat-picture-generator',
  command =&gt; '/tmp/cat-picture/generator/configure &amp;&amp; /usr/bin/make install',
  creates =&gt; '/usr/local/bin/cat-picture-generator',
}</pre></div><p>The title of the resource can be anything you like, though, as usual with Puppet resources it must be unique. I tend to name <code class="literal">exec</code> resources after the problem they're trying to solve, as in this example.</p><p>The <code class="literal">cwd</code> attribute sets the working directory where the command will be run (<span class="strong"><strong>current working directory</strong></span>). When installing software, this is generally the software source directory.</p><p>The <code class="literal">command</code> attribute gives the command to run. This must be the full path to the command, but you can chain several commands together using the shell <code class="literal">&amp;&amp;</code> operator. This executes the next command only if the previous one succeeded, so in the example, if the <code class="literal">configure</code> command completes successfully, Puppet will go on to run <code class="literal">make install</code>, otherwise, it will stop with an error.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>If you apply this example, Puppet will give you an error like the following:</p><div class="informalexample"><pre class="programlisting">Error: /Stage[main]/Main/Exec[install-cat-picture-generator]/returns: change from notrun to 0 failed: Could not find command '/tmp/cat-picture/generator/configure'</pre></div><p>This is expected because the specified command does not, in fact, exist. In your own manifests, you may see this error if you give the wrong path to a command, or if the package that provides the command hasn't been installed yet.</p></div></div><p>The <code class="literal">creates</code> attribute specifies a file which should exist after the command has been run. If this file is present, Puppet will not run the command again. This is very useful because without a <code class="literal">creates</code> attribute, an <code class="literal">exec</code> resource will run every time Puppet runs, which is generally not what you want. The <code class="literal">creates</code> attribute tells Puppet, in effect, "Run the <code class="literal">exec</code> only if this file doesn't exist."</p><p>Let's see how this <a id="id150" class="indexterm"/>works, imagining that this <code class="literal">exec</code> is being run for the first time. We assume that the <code class="literal">/tmp/cat-picture/</code> directory exists and contains the source of the <code class="literal">cat-picture-generator</code> application.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Puppet checks the <code class="literal">creates</code> attribute and sees that the <code class="literal">/usr/local/bin/cat-picture-generator</code> file is not present; therefore, the <code class="literal">exec</code> resource must be run.</li><li class="listitem">Puppet runs the <code class="literal">/tmp/cat-picture-generator/configure &amp;&amp; /usr/bin/make install</code> command. As a side effect of these commands, the <code class="literal">/usr/local/bin/cat-picture-generator</code> file is created.</li><li class="listitem">Next time Puppet runs, it again checks the <code class="literal">creates</code> attribute. This time <code class="literal">/usr/local/bin/cat-picture-generator</code> exists, so Puppet does nothing.</li></ol></div><p>This <code class="literal">exec</code> resource will never be applied again so long as the file specified in the <code class="literal">creates</code> attribute exists. You can test this by deleting the file and applying Puppet again. The <code class="literal">exec</code> resource will be triggered and the file recreated.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip17"/>Tip</h3><p>Make sure that your <code class="literal">exec</code> resources always include a <code class="literal">creates</code> attribute (or a similar control attribute, such as <code class="literal">onlyif</code> or <code class="literal">unless</code>, which we'll look at later in this chapter). Without this, the <code class="literal">exec</code> command will be run every time Puppet runs, which is almost certainly not what you want.</p></div></div><p>Note that building and installing software from source is not a recommended practice for production systems. It's better to build the software on a dedicated build server (perhaps using Puppet code similar to this example), create a system package for it, and then use Puppet to install that package on production nodes.</p></div><div class="section" title="The user attribute"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec54"/>The user attribute</h2></div></div></div><p>If you don't specify a <a id="id151" class="indexterm"/>
<code class="literal">user</code> attribute for an <code class="literal">exec</code> resource, Puppet will run the <a id="id152" class="indexterm"/>command as the <code class="literal">root</code> user. This is often appropriate for installing system software or making changes to the system configuration, but if you need the command to run as a particular user, specify the <code class="literal">user</code> attribute, as in the following example (<code class="literal">exec_user.pp</code>):</p><div class="informalexample"><pre class="programlisting">exec { 'say-hello':
  command =&gt; '/bin/echo Hello, this is `whoami` &gt;/tmp/hello-ubuntu.txt',
  user    =&gt; 'ubuntu',
  creates =&gt; '/tmp/hello-ubuntu.txt',
}</pre></div><p>This will run the specified command as the <code class="literal">ubuntu</code> user. The <code class="literal">whoami</code> command returns the name of the user running it, so when you apply this manifest, the file <code class="literal">/tmp/hello-ubuntu.txt</code> will be created with the following contents:</p><div class="informalexample"><pre class="programlisting">Hello, this is ubuntu</pre></div><p>As with the earlier <a id="id153" class="indexterm"/>example, the <code class="literal">creates</code> attribute prevents Puppet from <a id="id154" class="indexterm"/>running this command more than once.</p></div><div class="section" title="The onlyif and unless attributes"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec55"/>The onlyif and unless attributes</h2></div></div></div><p>Suppose you only <a id="id155" class="indexterm"/>want an <code class="literal">exec</code> resource to be applied under certain <a id="id156" class="indexterm"/>conditions. For example, a command which <a id="id157" class="indexterm"/>processes incoming data files only needs to run if there are data files <a id="id158" class="indexterm"/>waiting to be processed. In this case, it's no good adding a <code class="literal">creates</code> attribute; we want the existence of a certain file to trigger the <code class="literal">exec</code>, not prevent it.</p><p>The <code class="literal">onlyif</code> attribute is a good way to solve this problem. It specifies a command for Puppet to run, and the exit status from this command determines whether or not the <code class="literal">exec</code> will be applied. On Unix-like systems, commands generally return an exit status of zero to indicate success and a non-zero value for failure. The following example shows how to use <code class="literal">onlyif</code> in this way (<code class="literal">exec_onlyif.pp</code>):</p><div class="informalexample"><pre class="programlisting">exec { 'process-incoming-cat-pictures':
  command =&gt; '/usr/local/bin/cat-picture-generator --import /tmp/incoming/*',
  onlyif  =&gt; '/bin/ls /tmp/incoming/*',
}</pre></div><p>The exact command isn't important here, but let's assume it's something that we would only want to run if there are any files in the <code class="literal">/tmp/incoming/</code> directory.</p><p>The <code class="literal">onlyif</code> attribute specifies the check command which Puppet should run first, to determine whether or not the <code class="literal">exec</code> resource needs to be applied. If there is nothing in the <code class="literal">/tmp/incoming/</code> directory, then <code class="literal">ls /tmp/incoming/*</code> will return a non-zero exit status. Puppet interprets this as failure, so does not apply the <code class="literal">exec</code> resource.</p><p>On the other hand, if there are files in the <code class="literal">/tmp/incoming/</code> directory, the <code class="literal">ls</code> command will return success. This tells Puppet the <code class="literal">exec</code> resource must be applied, so it proceeds to run the <code class="literal">/usr/local/bin/cat-picture-generator</code> command (and we can assume this command deletes the incoming files after processing).</p><p>You can think of the <code class="literal">onlyif</code> attribute as telling Puppet, "Run the <code class="literal">exec</code> resource <span class="emphasis"><em>only if</em></span> this command succeeds."</p><p>The <code class="literal">unless</code> attribute is exactly the same as <code class="literal">onlyif</code> but with the opposite sense. If you specify a command to the <code class="literal">unless</code> attribute, the <code class="literal">exec</code> will always be run unless the command returns a zero exit status. You can think of <code class="literal">unless</code> as telling Puppet, "Run the <code class="literal">exec</code> resource <span class="emphasis"><em>unless</em></span> this command succeeds."</p><p>When you apply your <a id="id159" class="indexterm"/>manifest, if you see an <code class="literal">exec</code> resource <a id="id160" class="indexterm"/>running every time which shouldn't be, check <a id="id161" class="indexterm"/>whether it specifies a <code class="literal">creates</code>, <code class="literal">unless</code>, or <code class="literal">onlyif</code> attribute. If it specifies the <code class="literal">creates</code> attribute, it may be looking for the wrong file; if the <a id="id162" class="indexterm"/>
<code class="literal">unless</code> or <code class="literal">onlyif</code> command is specified, it may not be returning what you expect. You can see what command is being run and what output it generates by running <code class="literal">sudo puppet apply</code> with the <code class="literal">-d</code> (debug) flag:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo puppet apply -d exec_onlyif.pp</strong></span>
Debug: Exec[process-incoming-cat-pictures](provider=posix): Executing check '/bin/ls /tmp/incoming/*'
Debug: Executing: '/bin/ls /tmp/incoming/*'
Debug: /Stage[main]/Main/Exec[process-incoming-cat-pictures]/onlyif: /tmp/incoming/foo</pre></div></div><div class="section" title="The refreshonly attribute"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec56"/>The refreshonly attribute</h2></div></div></div><p>It's quite common <a id="id163" class="indexterm"/>to use <code class="literal">exec</code> resources for one-off commands, such as rebuilding a database, or setting a system-tunable parameter. These generally only need to <a id="id164" class="indexterm"/>be triggered once, when a package is installed, or occasionally, when a config file is updated. If an <code class="literal">exec</code> resource needs to run only when some other Puppet resource is changed, we can use the <code class="literal">refreshonly</code> attribute to do this.</p><p>If <code class="literal">refreshonly</code> is <code class="literal">true</code>, the <code class="literal">exec</code> will never be applied unless another resource triggers it with <code class="literal">notify</code>. In the following example, Puppet manages the <code class="literal">/etc/aliases</code> file (which maps local usernames to email addresses), and a change to this file triggers the execution of the command <code class="literal">newaliases</code>, which rebuilds the system alias database (<code class="literal">exec_refreshonly.pp</code>):</p><div class="informalexample"><pre class="programlisting">file { '/etc/aliases':
  content =&gt; 'root: john@bitfieldconsulting.com',
  notify  =&gt; Exec['newaliases'],
}

exec { 'newaliases':
  command     =&gt; '/usr/bin/newaliases',
  refreshonly =&gt; true,
}</pre></div><p>When this manifest is applied for the first time, the <code class="literal">/etc/aliases</code> resource causes a change to the file's contents, so Puppet sends a <code class="literal">notify</code> message to the <code class="literal">exec</code> resource. This causes the <a id="id165" class="indexterm"/>
<code class="literal">newaliases</code> command to be run. If you apply the manifest again, you will see that the <code class="literal">aliases</code> file is not changed, so the <code class="literal">exec</code> is not run.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip18"/>Tip</h3><p>While the <code class="literal">refreshonly</code> attribute is occasionally extremely useful, over-use of it can make your Puppet manifests hard to understand and debug, and it can also be rather fragile. Felix Frank makes this point in a blog post, <span class="emphasis"><em>Friends Don't Let Friends Use Refreshonly</em></span>:</p><p>"With the <code class="literal">exec</code> resource type considered the last ditch, its <code class="literal">refreshonly</code> parameter should be seen as especially outrageous. To make an <code class="literal">exec</code> resource fit into Puppet's model better, you should use [the <code class="literal">creates</code>, <code class="literal">onlyif</code>, or <code class="literal">unless</code>] parameters instead." Refer to:</p><p>
<a class="ulink" href="http://ffrank.github.io/misc/2015/05/26/friends-don't-let-friends-use-refreshonly/">http://ffrank.github.io/misc/2015/05/26/friends-don't-let-friends-use-refreshonly/</a>
</p></div></div><p>Note that you don't need to use the <code class="literal">refreshonly</code> attribute in order to make the <code class="literal">exec</code> resource notifiable by other resources. Any resource can notify an <code class="literal">exec</code> resource in order to make it run; however, if you don't want it to run <span class="emphasis"><em>unless</em></span> it's notified, use <code class="literal">refreshonly</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip19"/>Tip</h3><p>By the way, if you actually want to manage email aliases on a node, use Puppet's built-in <code class="literal">mailalias</code> resource. The previous example is just to demonstrate the use of <code class="literal">refreshonly</code>.</p></div></div></div><div class="section" title="The logoutput attribute"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec57"/>The logoutput attribute</h2></div></div></div><p>When Puppet <a id="id166" class="indexterm"/>runs shell commands via an <code class="literal">exec</code> resource, the output is normally hidden from us. However, if the command doesn't seem to be working <a id="id167" class="indexterm"/>properly, it can be very useful to see what output it produced, as this usually tells us why it didn't work.</p><p>The <code class="literal">logoutput</code> attribute determines whether Puppet will log the output of the <code class="literal">exec</code> command along with the usual informative Puppet output. It can take three values: <code class="literal">true</code>, <code class="literal">false</code>, or <code class="literal">on_failure</code>.</p><p>If <code class="literal">logoutput</code> is set to <code class="literal">on_failure</code> (which is the default), Puppet will only log command output when the command fails (that is, returns a non-zero exit status). If you never want to see command output, set it to <code class="literal">false</code>.</p><p>Sometimes, however, the command returns a successful exit status but does not appear to do anything. Setting <code class="literal">logoutput</code> to <code class="literal">true</code> will force Puppet to log the command output regardless of <a id="id168" class="indexterm"/>exit status, which should help you figure <a id="id169" class="indexterm"/>out what's going on.</p></div><div class="section" title="The timeout attribute"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec58"/>The timeout attribute</h2></div></div></div><p>Sometimes, commands <a id="id170" class="indexterm"/>can take a long time to run, or never terminate at all. By default, Puppet allows an <code class="literal">exec</code> command to run for 300 seconds, at which point <a id="id171" class="indexterm"/>Puppet will terminate it if it has not finished. If you need to allow a little longer for the command to complete, you can use the <code class="literal">timeout</code> attribute to set this. The value is the maximum execution time for the command in seconds.</p><p>Setting a <code class="literal">timeout</code> value of <code class="literal">0</code> disables the automatic timeout altogether and allows the command to run forever. This should be the last resort, as a command which blocks or hangs could stop Puppet's automatic runs altogether if no timeout is set. To find a suitable value for <code class="literal">timeout</code>, try running the command a few times and choose a value which is perhaps twice as long as a typical run. This should avoid failures caused by slow network conditions, for example, but not block Puppet from running altogether.</p></div><div class="section" title="How not to misuse exec resources"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec59"/>How not to misuse exec resources</h2></div></div></div><p>The <code class="literal">exec</code> <a id="id172" class="indexterm"/>resource can do anything to the system that you could do from the command line. As you can imagine, such a powerful tool can be misused. In theory, Puppet is a declarative language: the manifest specifies the way things should be, and it is up to Puppet to take the necessary actions to make them so. Manifests are therefore what computer scientists call <span class="strong"><strong>idempotent</strong></span>: the system is always in the same state after the <a id="id173" class="indexterm"/>catalog has been applied, and however many times you apply it, it will always be in that state.</p><p>The <code class="literal">exec</code> resource rather spoils this theoretical picture, by allowing Puppet manifests to have side-effects. Since your <code class="literal">exec</code> command can do anything, it could, for example, create a new 1 GB file on disk with a random name, and since this will happen every time Puppet runs, you could rapidly run out of disk space. It's best to avoid commands with side-effects like this. In general, there's no way to know from within Puppet exactly what changes to a system were caused by an <code class="literal">exec</code> resource.</p><p>Commands run via <code class="literal">exec</code> are also sometimes used to bypass Puppet's existing resources. For example, if the <code class="literal">user</code> resource doesn't do quite what you want for some reason, you could create a user by running the <code class="literal">adduser</code> command directly from an <code class="literal">exec</code>. This is also a bad idea, since by doing this you lose the declarative and cross-platform nature of Puppet's built-in resources. <code class="literal">exec</code> resources potentially change the state of the node in a way that's invisible to Puppet's catalog.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip20"/>Tip</h3><p>In general, if you need to manage a concrete aspect of system state which isn't supported by Puppet's built-in resource types, you should think about creating a custom resource type and provider to do what you want. This extends Puppet to add a new resource type, which you can then use to model the state of that resource in your manifests. Creating custom types and providers is an advanced topic and not covered in this book, but if you want to know more, consult the Puppet documentation:</p><p>
<a class="ulink" href="https://docs.puppet.com/guides/custom_types.html">https://docs.puppet.com/guides/custom_types.html</a>
</p></div></div><p>You should also <a id="id174" class="indexterm"/>think twice before running complex commands via <code class="literal">exec</code>, especially commands which use loops or conditionals. It's a better idea to put any complicated logic in a shell script (or, even better, in a real programming language), which you can then deploy and run with Puppet (avoiding, as we've said, unnecessary side-effects).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip21"/>Tip</h3><p>As a matter of good Puppet style, every <code class="literal">exec</code> resource should have at least one of <code class="literal">creates</code>, <code class="literal">onlyif</code>, <code class="literal">unless</code>, or <code class="literal">refreshonly</code> specified, to stop it from being applied on every Puppet run. If you find yourself using <code class="literal">exec</code> just to run a command every time Puppet runs, make it a cron job instead.</p></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec21"/>Summary</h1></div></div></div><p>We've explored Puppet's <code class="literal">file</code> resource in detail, covering file sources, ownership, permissions, directories, symbolic links, and file trees. We've learned how to manage packages by installing specific versions, or the latest version, and how to uninstall packages. We've covered Ruby gems, both in the system context and Puppet's internal context. Along the way, we met the very useful <code class="literal">puppet-lint</code> tool.</p><p>We have looked at <code class="literal">service</code> resources, including the <code class="literal">hasstatus</code>, <code class="literal">pattern</code>, <code class="literal">hasrestart</code>, <code class="literal">restart</code>, <code class="literal">stop</code>, and <code class="literal">start</code> attributes. We've learned how to create users and groups, manage home directories, shells, UIDs, and SSH authorized keys. We saw how to schedule, manage, and remove cron jobs.</p><p>Finally, we've learned all about the powerful <code class="literal">exec</code> resource, including how to run arbitrary commands, and how to run commands only under certain conditions, or only if a specific file is not present. We've seen how to use the <code class="literal">refreshonly</code> attribute to trigger an <code class="literal">exec</code> resource when other resources are updated, and we've explored the useful <code class="literal">logoutput</code> and <code class="literal">timeout</code> attributes of <code class="literal">exec</code> resources.</p><p>In the next chapter, we'll find out how to represent data and variables in Puppet manifests, including strings, numbers, Booleans, arrays, and hashes. We'll learn how to use variables and conditional expressions to determine which resources are applied, and we'll also learn about Puppet's <code class="literal">facts</code> hash and how to use it to get information about the system.</p></div></body></html>