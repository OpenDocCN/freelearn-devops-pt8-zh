- en: Continuous Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuous Integration as a practice is ensuring that each time code is committed,
    it is built and tested the same way consistently. We use Continuous Integration
    systems to automate this practice, making it practical for use on every commit.
    Some Continuous Integration pipelines eventually evolve into Continuous Delivery
    or Continuous Deployment pipelines. The key difference between Continuous Integration
    and delivery is that delivery ensures that every time code is committed, it is
    also wrapped up (or packaged) and delivered to the doorstep of the server it needs
    to run on. Continuous Delivery requires the ability to deploy your entire infrastructure
    and application consistently with a single orchestration command. Continuous Deployment
    requires an end-to-end suite of tests for every component in your infrastructure,
    but is the simple task of automating that single orchestration command when every
    test passes.
  prefs: []
  type: TYPE_NORMAL
- en: How these systems become useful to the individual application and infrastructure
    is unique to every company and organization, much like any other business rule.
    There are some common use cases and business rules that are nearly universal in
    everyone's Continuous Integration pipelines, and some that teams strive for.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up a Continuous Integration system (Jenkins) using Puppet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a job for a profile module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up our first test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrate the **Puppet Development Kit** (**PDK**) test suite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write RSPec unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up Puppet integration tests with Test Kitchen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous Integration systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our Continuous Integration system is a panel that keeps track of our code repositories.
    For each of these repositories, you'll find what is commonly referred to as a
    job. A job is a series of steps, usually written in code, that informs the system
    of what it should do when a build is triggered through a button or CLI. A build
    is simply a single instance of that job that is running or has already run. Finally,
    that build contains log files, key information about the build, and any artifacts
    (objects) you want the system to store or ship off closer to the endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: We'll build our CI system using Puppet, which will eventually manage our Puppet
    code. This is a common scenario when you start with CI in an existing environment
    in an organization.
  prefs: []
  type: TYPE_NORMAL
- en: Puppet Pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Puppet Pipelines is a new product by Puppet. In September of 2017, Puppet acquired
    Distelli so that they could build the new Puppet Pipelines program. This CI system
    is still heavily geared toward containers and applications, but work is being
    done to improve its feature set for Puppet as well. Puppet Pipelines can still
    be used for a Continuous Integration system for puppet code, but may undergo quite
    a few changes in the next year around Puppet code. For this chapter, we''ll be
    using a very popular open source Continuous Integration system: Jenkins.'
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jenkins is one of the oldest and most common Continuous Integration systems
    fielded today. It began as Hudson initially, in 2005, and grew into the fork of
    Jenkins that we see today. Jenkins is both a powerful and complicated system in
    comparison to most other CI systems due to its highly pluggable nature. There
    are a plethora of Jenkins plugins designed to add features to the CI system, from
    source code management, to graphs and viewing, to orchestration and automated
    testing and linting for nearly every language. With this wide feature set, Jenkins
    can also often be complicated. Out of the box, Jenkins doesn't do a whole lot
    outside of running shell commands on the system. In this section, we'll be exploring
    how to build a bare basic Jenkins setup for our needs, using Puppet, to manage
    our Puppet code.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Jenkins with Puppet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're using Puppet to manage the Continuous Integration system, because it's
    a system. We're using Jenkins to manage our configuration management code, because
    it's code. This is why we'll build Jenkins with Puppet, and then check our Puppet
    code into Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: rtyler/jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We should always seek a forge module when building new software, so I'm going
    to reach for `rtyler/jenkins` on the forge. This module will cover our basic needs
    for installing our Jenkins LTS server, installing our Jenkins plugins, and each
    package we'll need to run our builds.
  prefs: []
  type: TYPE_NORMAL
- en: In larger infrastructures, we wouldn't run builds on our Jenkins server, we'd
    run it on the Jenkins agents attached to it. Because this setup has no agents,
    Jenkins will act as our build agent and run the jobs for us. Therefore, we'll
    need to install Git and the PDK so that it can run commands for us. We use the
    Git plugin to provide us with a direct connection to our code, and the pipelines
    plugin gives us a DSL to write our steps in.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to build a new module with the PDK by creating a profile directory,
    a manifests directory inside of that, and create a `jenkins.pp` in that folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We're going to install our plugins manually. `rtyler/jenkins` does support plugins
    for Jenkins, but does not support dependencies. There are quite a few dependencies
    in these build pipelines, so we're going to manually install the plugins to highlight
    the two main plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'After our profile has been applied to the node, we''ve got a fresh Jenkins
    installation with our desired plugins. We can reach our new Jenkins node via the
    web URL on port `8080`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5deb6e9-2b6b-4cf0-9016-f13510da225a.png)'
  prefs: []
  type: TYPE_IMG
- en: Managing our plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to Puppetize each plugin, you can use the `jenkins::plugin` resource
    provided by this Jenkins module. You can find each plugin installed on your Jenkins
    master in the `/var/lib/jenkins/plugins` file, or in the Installed plugins tab
    of your Jenkins instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resource syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to grab two key plugins for our CI/CD workflow in this section:
    Git and Pipeline. We can reach the plugin page by clicking on Manage Jenkins on
    the left-hand side of the screen, and then Manage Plugins near the bottom of the
    menu. There is an ever-growing amount of plugins for Jenkins, and we need to select
    the appropriate ones:'
  prefs: []
  type: TYPE_NORMAL
- en: It can be difficult to locate a plugin by name only, so try using some of the
    descriptions to locate these within the list.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a9de370-44f1-435e-8643-81e69e14a585.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we select these plugins, and click Download and Install after Restart,
    we''ll be taken to a page listing all plugins that have an installation pending,
    in progress, or successful. At the bottom of this page is a checkmark that allows
    us to restart the server when the full download is complete. Make sure that you
    check that box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c72b99c8-ced7-41b6-a75f-506786105c12.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating our first build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After our required plugins are installed in Jenkins, we can start putting together
    our first build. We'll start at the bare minimum for a code repository, and then
    demonstrate how to have Jenkins read that repository and automatically run a build
    when new code is checked in.
  prefs: []
  type: TYPE_NORMAL
- en: This project will need a Git repository available for Jenkins. If you don't
    have an already accessible Git repository, open up an account on GitHub and use
    a public repository. We're not writing anything sensitive, so it's okay that the
    world can see your repository.
  prefs: []
  type: TYPE_NORMAL
- en: Building our profile module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We wrote some code that defined our Jenkins server in the form of a profile
    at the beginning of this chapter. First, let''s inspect the directory structure
    that we''re working with for our already existing code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a pretty bare minimum profiles module, with a single manifest. We''ll
    turn this simple module into a Git repository first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run `git status`, we''ll see that the `manifests` directory is checked
    in. Every file in this repository right now is new, so we''ll need to add each
    file and check them into our first commit, often called the `''initial commit''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re then ready to send off our initial commit to the remote repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Building our Jenkinsfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Pipeline plugin we installed on our Jenkins node allows us to declare our
    pipeline directly in the same repository as our code, as a script called a Jenkinsfile.
    This Jenkinsfile describes the details of our build steps, which can be automatically
    read by Jenkins to execute our build. We''ll begin with a very simple Jenkinsfile
    that checks to make sure that all of our manifests pass a `puppet parser validate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This Jenkinsfile describes a pipeline that can be run on any agent (we only
    have one: our Jenkins node). It has stages, but only a single stage named `Test`,
    with a single step that runs `puppet parser validate` on every file ending in
    `.pp` (every manifest).'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we send this file up to our remote repository so that it can be found
    by Jenkins through the normal Git workflow we've been using.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting Jenkins to our repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a build declared in our Jenkinsfile, we can build our first
    job. We''ll start by clicking New Item in the top left corner, and create a new
    Multibranch Pipeline job called profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/abf72a1d-4f04-47f3-8986-9ad471522e7b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For our build, we''ll need to edit the Branch Sources by adding the Project
    Repository and set our scan interval to run every minute. This is a public repository
    for me, so I don''t need to attach any credentials. I''ll use the default behaviors
    and property strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4913669-a762-4116-9b68-40c370629c14.png)'
  prefs: []
  type: TYPE_IMG
- en: Some hosted Git repositories, such as GitHub Enterprise, allow for the scanning
    of all repositories in an organization. It can save a lot of time managing Jenkins
    if all repositories are automatically discovered.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03867273-3a61-4d54-b81b-1cd5af16c22c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After I click Scan, an immediate job will be run to discover branches on that
    repository. Although this screen looks just like a Jenkins build, its pass or
    fail status is entirely based on the ability to connect to your Git repository
    and find a Jenkinsfile on a branch. Let''s check on our first build by returning
    to the home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8dbdd6f1-81eb-4068-8aa7-e6e1c7ebd1e7.png)'
  prefs: []
  type: TYPE_IMG
- en: Our splash page has our first build in it! The sun represents a passing build,
    indicating that each step in our build returned a positive exit status. On the
    far right of the build is a run build button, which is for if we'd like to run
    the build again. For now, click on the name profile and enter the details of the
    build. Because this is a multibranch pipeline, we'll also want to click the master
    branch to bring us into our status. You'll see that our build has run, and you
    can inspect each step of the way from this menu.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that this exercise does not require us to put our Jenkins somewhere
    publicly accessible, we'll be using repository polling. While this will work for
    most, the most effective strategy is really using a Git hook to trigger Jenkins
    to run after every build.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this part of the phase, we have a set of commands that can be run on demand.
    To really make Continuous Integration work, we''ll need to have our code test
    itself. Within our job, we can select View Configuration to come to the configuration
    page. We''ll be setting our Build Triggers to poll the SCM every minute:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a897ff3-9201-40ea-ba25-caea875f6903.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we''ve saved this configuration, Jenkins will automatically check our
    remote repository for changes every minute. We now have the simplest form of Continuous
    Integration: code that tests itself on every commit. With such a small amount
    of code coverage, our Continuous Integration pipeline doesn''t provide us with
    much value, other than alerting us when we''ve created a malformed manifest.'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the PDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Puppet PDK provides us with a framework for repeatable Continuous Integration.
    We'll be taking our bare bones module and converting it with PDK, and then we
    will begin by using PDK validate to replace our basic `puppet parser validate`
    command. Because the PDK is available on our Jenkins master, all PDK commands
    will also be available for use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first step will be to change branches so that we don''t impact the master
    as we''re adding new code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s convert our existing module with the PDK convert command. We''ll
    be prompted with a series of questions, mostly aimed at publishing modules to
    the forge. The final question asks which operating system this is relevant to
    and actually does help form our test bindings, so we''ll minimize this to just
    the targeted operating system: Red Hat-based Linux. Simply run `pdk convert` and
    follow the prompts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The default PDK template contains three files not relevant to us: `.gitlab-ci.yml`,
    `.travis.yml`, and `appveyor.yml`, which are used for other CI systems. We''ll
    then add our new files and commit them into a new code commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll change our Jenkinsfile `Test` stage to use the `pdk validate`
    utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll push that back up to our remote repository with our Git workflow, and
    our Jenkins instance will automatically pick up our job on our new PDK branch
    after sending it remotely with `git push origin pdk`. Back on our profile page,
    we will now see a new branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df3b12e7-d078-4a10-80d0-9c31074e90ef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The inside of this PDK branch should appear similar to our previous branch,
    but we want to inspect the logs of our test. Inside, we''ll see that a few `puppet-lint`
    warnings were triggered, but did not fail the build. Puppet lint warnings by default
    provide an exit status of `0`, allowing your build to still pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: I like the Warnings plugin for viewing lint syntax. It shows trends over time,
    but is by no means necessary for proper Continuous Integration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we do a pull request of this code into master, let''s clean up our lint
    warnings by adding a comment to the top of our manifest, and aligning the arrows
    within the PDK package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can then add these changes and push them back up to our remote repository.
    Our Jenkins scan will then pick up these changes within a minute and give us the
    all clear. Once we're happy with these results, you can merge your code with a
    pull request back at the remote repository, and watch this test run again on our
    master branch.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have some basic validation in place, we can start building some
    basic test coverage to rely on our profiles not losing features over time, or
    regressing.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing with Puppet RSpec
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unit testing is testing focused around the smallest unit of code. In the case
    of Puppet, the smallest functional unit of code is the manifest. RSpec provides
    us with a unit testing framework for Puppet code, which is fast and effective
    at checking that our Puppet code is producing the Puppet catalogs we expect. Whatever
    tests we write in RSpec, we''re essentially asking: *would what I want be in the
    Puppet catalog when I execute this code?*'
  prefs: []
  type: TYPE_NORMAL
- en: RSpec as a system is run on the command line, and does not involve a new virtual
    machine or container. It is now included in the Puppet PDK under the command `pdk
    test unit`. We're going to look at the files involved in running unit tests, and
    writing simple unit tests from the templates provided by the PDK.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re beginning a new feature set, so we''ll want to start from master, pull
    down the remote commits, and start on a new branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we begin with RSpec, we''ll want a sample set of files we can work with.
    At the time of writing this book, there is no command in the PDK to create a unit
    test without creating a new manifest. To overcome this limitation, we''ll simply
    rename our `jenkins.pp` file, create a new class with the PDK, and place our existing
    file back in place over it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We'll now have our `jenkins_spec.rb` built from template, and will be ready
    to begin writing unit tests in RSpec.
  prefs: []
  type: TYPE_NORMAL
- en: Relevant RSpec files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our files in place, let''s inspect the most relevant files we''ll work
    with during the testing of classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.fixtures.yml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spec/classes/jenkins_spec.rb`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spec/spec_helper.rb` provides configuration and variables to every test in
    your suite. We won''t be editing it in this example, but know that this is essentially
    your global configuration file for all of the modules tests.'
  prefs: []
  type: TYPE_NORMAL
- en: .fixtures.yml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `fixtures` file lets our tests know what dependencies are required for
    our manifests. It is placed at the base of the repository, as `profile/.fixtures.yml`.
    For our particular profile, we''ll build a fixtures file that contains `rtyler/jenkins`
    and all of its dependencies in order to support our test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We use this file to declare a module in our test, and use a pointer to a repository
    to find it. In the preceding case, we're grabbing the latest version of each module
    except Jenkins, which we've pinned at 1.7.0 as we're using in our Puppetfile.
    Depending on your strategy for code, you may or may not want to tag a specific
    reference to a version, like I did previously.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on fixtures can be found in the `spec_helper.rb` GitHub repository
    at [https://github.com/puppetlabs/puppetlabs_spec_helper#fixtures-examples](https://github.com/puppetlabs/puppetlabs_spec_helper#fixtures-examples).
  prefs: []
  type: TYPE_NORMAL
- en: jenkins_spec.rb
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After our fixtures are in place, let''s inspect our `jenkins_spec.rb`, as provided
    by the PDK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding simple test just ensures that the catalog compiles for each and
    every operating system listed in `metadata.json`. Normally, we'd run this test
    and we'd receive a passing status. In this particular case, `rtyler/jenkins` requires
    us to supply an additional fact of `systemd` that is not available in the base
    `on_supported_os` function.
  prefs: []
  type: TYPE_NORMAL
- en: Check popular modules on the forge for samples of code, especially in cases
    where you're testing profiles against existing modules. Often, the upstream module
    has a fix, like the one we're about to implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll edit our existing `spec` class to introduce a new fact to our system
    to support `systemd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our test will be able to compile, as the upstream Jenkins module will
    have the `systemd` fact it needs to compile. Let''s go ahead and compile our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that we have four passing tests. Although we wrote just
    one test, our `on_supported_os` function looked in our `metadata.json` file and
    provided a test for each listed operating system, all within the Red Hat family.
  prefs: []
  type: TYPE_NORMAL
- en: Extending our Jenkinsfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to change up our Jenkinsfile to support our new RSpec test. We''re
    going to remove our original `Test` stage and be more clear by creating the `Validate`
    and `Unit Test` stages. We''ll simply incorporate the two as `pdk validate` and
    `pdk test unit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This will change our pipeline to three distinct phases: checkout `SCM`, `Validate`,
    and `Unit Test`. We''ll be able to see where our build passes or fails along each
    step in Jenkins.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a basic framework for our test laid out, let''s get our code
    back to the remote repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Back in our Jenkins instance, we can see the new RSpec branch and the new logs
    for our test. Notice each section, and that we're also seeing our Jenkins instance
    pass our four RSpec tests.
  prefs: []
  type: TYPE_NORMAL
- en: Extending our test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we can write a test, we'll write one simple test that simply mirrors
    our manifest. This test will help us prevent regression, as changing an existing
    value or removing an existing resource will cause the test to fail. If this change
    is intended, the test must also be changed. Although this intuitively feels like
    it would slow down development, it saves even more time in integration when you
    can ensure that no new errors have been introduced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our RSpec test containing the mirror of our original profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: When we create a commit with this new test, and send it back up to Jenkins,
    we'll see our build actually perform this test. Up to this point, we've never
    intentionally broken a test. Let's go ahead and prove our test now. Comment out
    one resource in your original manifest, or change some configuration before sending
    this repository back to the remote server. After pushing this, you should be able
    to see a failed test in Jenkins! Simply uncomment out your resources and push
    a new commit up to your remote, and you'll see Jenkins pass this build. Once your
    build is passing, go ahead and merge into master so that we can continue onto
    our next section of integration testing.
  prefs: []
  type: TYPE_NORMAL
- en: There is great documentation on writing RSpec tests out there at [http://rspec-puppet.com/](http://rspec-puppet.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance testing with Test Kitchen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An acceptance test is a test that is performed to validate that requirements
    are met. While RSpec is a fast way to check that a catalog is compiled the way
    you expect it to be, it does not actually run the catalog on the system and verify
    that the expected results can be seen. An acceptance test, in the context of Puppet,
    is applying your selected manifest to a system and verifying that the system meets
    the requirements after the catalog is applied, preferably with a method that isn't
    the Puppet Agent itself.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to build an acceptance test for our Jenkins Profile
    that ensures that Jenkins is running and that we can reach it on port `8080` so
    that we can view the web page. This extends beyond the ability of RSpec, as Rspec
    doesn't actually build a node we can verify on. When we use an acceptance testing
    harness in Puppet, we also tie it to a hypervisor so that it can manage a node,
    or **System Under Test** (**SUT**).
  prefs: []
  type: TYPE_NORMAL
- en: Beaker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Puppet provides a perfectly adequate acceptance testing harness in Beaker. Beaker
    is designed to connect to a hypervisor and spin up nodes as defined in configuration
    files and apply the Puppet tests. It uses a simple language called Serverspec
    to define tests. It also has the benefit of checking for idempotence by running
    a second time. Puppet themselves have also connected it to another application
    called VMPooler, which preemptively spins up a pool of virtual machines to act
    as SUTs and replaces themselves when the test is done, providing rapid response
    time to acceptance tests. If you, as an organization, are far along in your CI/CD
    process, and require virtual machines, I highly recommend Beaker. For this section,
    we'll do our acceptance testing in Test Kitchen, simply because I believe it's
    easier to work with and provides more options for workstation development.
  prefs: []
  type: TYPE_NORMAL
- en: Test Kitchen and kitchen-puppet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test Kitchen is actually the testing framework built by Chef. It is very simple
    to use and get started with, and uses a language even easier to work with than
    Serverspec called Inspec. We'll be extending Test Kitchen to support Puppet using `rubygem
    kitchen-puppet`, found at [https://github.com/neillturner/kitchen-puppet](https://github.com/neillturner/kitchen-puppet).
    We'll need to prepare our Jenkins node to start taking advantage of Test Kitchen
    and running another set of validation tests.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing Test Kitchen on our Jenkins node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test Kitchen directly supports the development activities of our Puppet code.
    We'll be using a single composite command from Test Kitchen in our CI/CD run: `kitchen
    test`. Kitchen test is an orchestration of the destroy, create, converge, setup,
    verify, and commands, taking us through cleaning up, building, applying code,
    and testing each run. You can run Test Kitchen locally, as well as on our CI/CD
    system, which is one of the greatest strengths of using kitchen-puppet. We'll
    be adding a lot of code in this section, from updating our Jenkins Profile to
    supporting Test Kitchen, to building the test and Test Kitchen configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins Profile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll change up our profile first. In the following example, we''ll add the
    following resources and features:'
  prefs: []
  type: TYPE_NORMAL
- en: Install Docker, if the node is not already a Docker Container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install RVM, Ruby 2.4.1 and all RubyGems needed for Kitchen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have added the preceding resources and features in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We'll need to deploy this new profile to our Jenkins node before we continue
    through the rest of the section. Make sure you deploy this to your Puppet Master
    before continuing on editing the build. Working with your CI/CD system can sometimes
    feel like a series of chicken before the egg scenarios. This is normal, but the
    concepts extend beyond our CI/CD system.
  prefs: []
  type: TYPE_NORMAL
- en: .kitchen.yml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first file we''ll work with is our `.kitchen.yml`. This file determines
    how Test Kitchen performs the build. This YAML file provides us with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Driver**: This is used for running the build in Docker as a privileged user
    starting with the init process. If you''re unfamiliar with working with containers,
    we''re setting it up this way to act more like a traditional VM, and less like
    a wrapper around an application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Provisioner**: We''re setting up Test Kitchen to use the Puppet provisioner
    with a local manifests and modules path in our build.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Verifier**: Use Inspec for testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Platforms**: We are going to configure our container to use the CentOS SystemD
    container. We''re passing additional commands to ensure that SSH works properly,
    and that init scripts are available for our Jenkins run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Suites**: This is used for describing each test suite we run. This first
    one is defined with `jenkins.pp` in our test directory, which is a simple `include
    profile::jenkins`, like we may see in an `example.pp`. Notice our pre-verify stage
    in this one, giving our Jenkins instance 30 seconds to finish coming up before
    we test:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`.kitchen.yml` will work for us locally as well, allowing us to run tests and
    verify them before sending our code up to our remote repository. We can also use `kitchen
    converge` to build the machine and apply the code if we want to inspect the end-state
    on our local system.'
  prefs: []
  type: TYPE_NORMAL
- en: Puppetfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The kitchen-puppet gem runs via Puppetfile. Underneath the covers, it''s using
    a tool called librarian-puppet to pull down all modules and dependencies found
    in the Puppetfile. Librarian and r10k came around the same time, with r10k providing
    no automatic dependency resolution, preferring explicit naming. Due to our use
    of Puppet Librarian, we''re explicitly adding an exclusion for Java and Apt, which
    our 2-year old Puppet module locks to old versions. Our Jenkins module works just
    fine with modern versions of Java and Apt, but this automatic dependency resolution
    has to be muted so that we do not fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Jenkinsfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''m adding two new objects to our Jenkinsfile: an integration test provided
    by a shell script, and a post action that tells Jenkins to clean up our workspace.
    We''re using an external script instead of running inline for ease of management,
    as each `sh` step is an independent shell in Jenkins. Our post cleanup action
    just makes sure that we don''t retain any artifacts from a previous build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: acceptance.sh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our acceptance shell script is relatively small, but allows Jenkins to have
    a path for this build and sources in RVM prior to running Kitchen Test. We want
    to make sure that the build stays consistent, so we want to control the environment
    around the build as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our actual test itself is one of the simplest files in our new iteration. We''re
    placing it in the default folder, so it''s found by the default suite we mentioned
    previously. We''re building a single control or set of tests, with three tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that the Jenkins package is installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that the Jenkins service is running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ensure that Jenkins can be reached on the localhost at `8080`, and returns
    a 200 exit status:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Performing the test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have all of the pieces in place, let's go ahead and deploy our code
    to our repository, and let Jenkins run the job. If you haven't already run our
    new Jenkins Profile, you'll need to make sure it's deployed to your master and
    that your Jenkins node has already converged on it. Once we push our test to the
    CI/CD system, it will read our code and begin the test. Of particular note, this
    test will take significantly longer than the tests we've written previously, as
    the container will need to be downloaded, built, spun up, converged, and tested,
    compared to our PDK commands that simply checked syntax or compiled a quick catalog.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve built a lot of files during this chapter, so let''s take a quick look
    at just the files we''ve managed, ignoring anything automatically built by software:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused on building out a CI System (Jenkins) and performing
    a validation check, a unit test, and an acceptance test. CI/CD is a continual
    journey, and there is always room for improvement in our workflows. Continuous
    Integration provides us with a valuable safety net for development, allowing us
    to develop without worrying about feature loss or regression.
  prefs: []
  type: TYPE_NORMAL
- en: Where are some places to go to from here? Integrate your Git system closer to
    Jenkins by using Git hooks to deploy code, and providing a status back before
    a pull request is added. You can also add notifications to developers, alerting
    them when their tests have gone from passing to failing. If you find some of these
    warnings to be too much, tune the system providing the warning to avoid some of
    these errors. Everyone has a different CI/CD journey, so explore for yourself
    and figure out what works for you!
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter covers Puppet Tasks and Puppet Discovery. Puppet Tasks allows
    us to run ad-hoc commands and use them as building blocks for imperative scripts.
    We'll be building a task to inspect log files and planning to build an aggregated
    log file for our Puppet Master. Puppet Discovery allows us to inspect our existing
    infrastructure and determine ground truth on packages, services, users, and various
    other components of a virtual machine or container.
  prefs: []
  type: TYPE_NORMAL
