- en: Chapter 4. Neutron – OpenStack Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to OpenStack networking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing networks, subnets, and ports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating provider networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating tenant networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating ports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating network attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting ports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing routers and floating IPs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching networks to routers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and assigning floating IPs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting routers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing security groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing load balancers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to OpenStack networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Networking in OpenStack is provided by a project that goes by the name of Neutron.
    Neutron is an API-driven system that manages physical and virtual networking resources
    in an OpenStack cloud. Operators and users can leverage the Neutron API to build
    rich network architectures that best suit the requirements of their applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Neutron utilizes a pluggable and extensible architecture that allows developers
    to write robust drivers that implement and configure virtual and physical network
    resources, including switches, routers, firewalls, and load balancers. Neutron
    is composed of an API server and various agents that are responsible for implementing
    the virtual network architected by users. The following diagram demonstrates how
    the Neutron API server interacts with various plugins and agents to construct
    networking in the cloud:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to OpenStack networking](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1
  prefs: []
  type: TYPE_NORMAL
- en: The figure demonstrates the interaction between the Neutron API service, Neutron
    plugins and drivers, and services such as L2 and L3 agents in a stock OpenStack-based
    cloud. As network actions are performed via the API or agents, Neutron publishes
    messages to a queue that are consumed and implemented by the agents.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will cover many common networking-related tasks, but will not go
    far into the details of any given topic. For an introduction to the fundamentals
    of Neutron networking, refer to *OpenStack Networking Essentials*, *Packt Publishing*,
    2016\. For a more in-depth look at Neutron features, including the core functionality
    of switching and routing, load balancing, VPN, and more, refer to *Learning OpenStack
    Networking, Second Edition*, *Packt Publishing*, 2015.
  prefs: []
  type: TYPE_NORMAL
- en: Managing networks, subnets, and ports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Networks, subnets, and ports make up the foundation of Neutron's logical network
    architecture. A network describes a layer 2 segment, and is typically used to
    define a boundary such as a VLAN. A subnet is an IPv4 or IPv6 address block that
    is associated with the network. Networks can be associated with one or more subnets.
    Lastly, a port represents a switch port on a logical switch that spans the entire
    cloud. A port object contains information about the device it is associated with,
    including its MAC addresses, IP addresses, and device ID. A device could be a
    virtual machine instance interface, a virtual router interface, or some other
    device that will be connected to the virtual network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Network objects in OpenStack have many attributes that describe how that network
    connects the physical and virtual infrastructures. The following table describes
    a few of these details:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Attribute` | `Description` |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `provider:physical_network` | This describes the physical interface used
    for this network. The label here is an alias for interfaces such as `eth0` and
    `bond1`. The alias is referred to as a **provider label** and is configured in
    the respective plugin and agent configuration files. This is used primarily by
    the `flat` and `vlan` type networks. |'
  prefs: []
  type: TYPE_TB
- en: '| `provider:segmentation_id` | This describes the segment ID, such as VLAN
    ID or VXLAN VNI. It may not be used for all network types. |'
  prefs: []
  type: TYPE_TB
- en: '| `provider:network_type` | This describes the network type, such as Flat,
    VLAN, VXLAN, and GRE. |'
  prefs: []
  type: TYPE_TB
- en: '| `router:external` | Boolean (true or false) is used to determine if the network
    is eligible for use as a floating IP pool. |'
  prefs: []
  type: TYPE_TB
- en: The role of the user creating a network determines which attributes can be specified
    by that user at network creation. An administrative user can specify details such
    as the physical network or segmentation ID when creating a network. Regular users
    must rely on Neutron to automatically provision the network based on details set
    in Neutron configuration files, including a pool of segmentation IDs per physical
    network from which to choose from. Networks that are created specifically to connect
    virtual devices to the physical network infrastructure are often referred to as
    **provider networks**, since their attributes are deliberately set based on the
    environment or data center in which they reside. Provider networks are typically
    shared across projects or tenants and often provide connectivity to upstream devices
    that can facilitate routing in and out of the environment. Networks that are created
    by regular users are referred to as **tenant networks**, and are typically only
    used by the project or tenant that created them. In most cases, tenant networks
    must be connected to virtual routers, which are in turn connected to provider
    networks, and can provide connectivity in and out of connected tenant networks.
    In the following sections, we will look at common tasks involving those resources.
  prefs: []
  type: TYPE_NORMAL
- en: Creating provider networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating a provider network in OpenStack, one must provide attributes that
    describe how the network is connected to the physical infrastructure. These attributes
    include the network type, network interface used by the server, and the segmentation
    ID of the network. Typically, provider networks are only created and managed by
    users with administrator-level permissions. Provider networks can be shared or
    private, and they can also be used as floating IP networks when connected to Neutron
    routers when the network's `router:external` attribute has been set to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When creating a provider network, you must be authenticated as an administrator.
    You will need the following details, at a minimum, for the network:'
  prefs: []
  type: TYPE_NORMAL
- en: Network name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provider label
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Segmentation ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For our example, the following will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Network name: `COOKBOOK_PROVIDER_NET`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Provider label: `vlan`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Network type: `vlan`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Segmentation ID: `200`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will need the following details, at a minimum, for the corresponding subnet:'
  prefs: []
  type: TYPE_NORMAL
- en: Subnet name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network name or ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subnet range (CIDR)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For our example, the following will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Subnet name: `COOKBOOK_PROVIDER_SUBNET`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Network name or ID: `COOKBOOK_PROVIDER_NET`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Subnet range (CIDR): `192.168.200.0/24`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the OpenStack client installed on our system, we are now able to create
    a provider network with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will resemble the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/00037.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Create the subnet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will resemble the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/00038.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Provider networks are created with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Creating a network creates a logical layer 2 segment, whose details are used
    to construct virtual network connections within the Cloud that connect virtual
    machines and other virtual network objects to the physical infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: The `provider-network-type` parameter defines the type of network. Options include
    `vlan`, `vxlan`, `gre`, `flat`, `geneve`, and `local`, and these must be supported
    by the configured network driver.
  prefs: []
  type: TYPE_NORMAL
- en: The `provider-physical-network` parameter defines the interface used for the
    network. In Neutron, interfaces are not referenced directly, but are mapped to
    a **provider label**. In an OpenStack-Ansible deployment, the default provider
    label is `vlan` and maps to a physical interface such as `bond1` or `eth1`.
  prefs: []
  type: TYPE_NORMAL
- en: The `provider-segment` parameter defines the layer 2 segmentation ID used by
    the network. For the `vlan` network types, the segmentation ID is VLAN ID. For
    the `vxlan` network types, the segmentation ID is VXLAN VNI. Segmentation IDs
    may not be used by all network types, and if not specified, may be automatically
    assigned by Neutron if required.
  prefs: []
  type: TYPE_NORMAL
- en: When specified, the `--external` option qualifies a network as a gateway network
    for a router. The network will serve as a floating IP network for attached instances.
    Networks are considered *internal* by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other optional network parameters that can be discovered using the
    `--help` flag shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `--help` flag can be appended to most commands within the OpenStack command-line
    utility, and will be helpful when constructing commands throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Subnets are created with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Creating a subnet creates a logical layer 3 routing domain, whose details are
    used to provide IP services to virtual machines and other virtual network objects.
    The `network` parameter maps the subnet to a layer 2 network defined in OpenStack.
    The `subnet-range` parameter defines the L3 address range used by the subnet and
    is written in CIDR notation. More than one subnet can be associated with a network,
    which is often the case when all addresses in a particular subnet have been consumed.
    While logically separated, multiple subnets in a network are all part of the same
    layer 2 broadcast domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a network and subnet are created in OpenStack, and DHCP is enabled, a
    corresponding network namespace is created on one or more nodes running the DHCP
    agent. The namespace can be identified using the `ip netns` command shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: A DHCP namespace has a prefix of `qdhcp-` and a suffix that corresponds to the
    network ID.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ip netns` command must be run by the `root` user or a user with `sudo`
    permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating tenant networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a tenant network is created in OpenStack, provider attributes that describe
    how the network is connected to the physical infrastructure are automatically
    determined by Neutron based on settings hard-coded in configuration files. Typically,
    tenant networks are created and managed by users within a particular project and
    are not shared with other projects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need the following details, at a minimum, for the network:'
  prefs: []
  type: TYPE_NORMAL
- en: Network name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For our example, the following network name will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Network name: `COOKBOOK_TENANT_NET_1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will need the following details, at a minimum, for the corresponding subnet:'
  prefs: []
  type: TYPE_NORMAL
- en: Subnet name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network name or ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subnet range (CIDR)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For our example, the following will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Subnet name: `COOKBOOK_TENANT_SUBNET_1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Network name or ID: `COOKBOOK_TENANT_NET_1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Subnet range (CIDR): `172.16.200.0/24`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the `openstack` client installed on our system, we are now able to create
    a tenant network with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will resemble the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/00039.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: As a non-admin user, certain network attributes may not be visible.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the subnet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will resemble the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/00040.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tenant networks are created with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When created as a non-admin user, a network's provider attributes are automatically
    determined by Neutron based on settings defined in the respective network plugin
    configuration files. Tenant networks are associated with the project that created
    them, and by default, are not visible or usable by other projects.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Neutron **role-based access control** (**RBAC**) can be used to share networks
    with other projects if desired. More information on using RBAC in the Pike release
    of OpenStack can be found at the following website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.openstack.org/neutron/pike/admin/config-rbac.html](https://docs.openstack.org/neutron/pike/admin/config-rbac.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating ports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ports in OpenStack can be created using the `openstack port create` command.
    Ports are automatically created by OpenStack upon server creation or can be created
    and attached to instances at a later time. Users may also create ports as a method
    of reserving IP addresses for later use or to avoid certain addresses from being
    allocated by OpenStack at all.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need the following details, at a minimum, for the port:'
  prefs: []
  type: TYPE_NORMAL
- en: Network name or ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For our example, the following will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Network name: `COOKBOOK_TENANT_NET_1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Port name: `COOKBOOK_TEST_PORT_1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the OpenStack client installed on our system, we are now able to create
    a port with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will resemble the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a port is created in OpenStack and associated with an instance or other
    virtual network device, it is bound to a Neutron agent on the respective node
    hosting the instance or device. Using details provided by the port, OpenStack
    services may construct a **virtual machine interface** (**vif**) or **virtual
    ethernet interface** (**veth**) on the host for use with a virtual machine, network
    namespace, or more depending on the application.
  prefs: []
  type: TYPE_NORMAL
- en: Updating network attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network attributes can be updated using the `openstack network set` and `openstack
    network unset` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When updating a network, ensure that you are authenticated as an administrator
    or are the owner of the network. You will need the following details:'
  prefs: []
  type: TYPE_NORMAL
- en: Network name or ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attribute to update
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For our example, the following will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Network name: `COOKBOOK_PROVIDER_NET`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Attribute to update: `router:external`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the OpenStack client installed on our system, we are now able to update
    the network with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: No output is returned.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Networks are updated with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `share` and `no-share` parameters dictate whether the network can be shared
    among projects or is limited to the owner of the network.
  prefs: []
  type: TYPE_NORMAL
- en: The `description` parameter allows users to provide a useful description of
    the network.
  prefs: []
  type: TYPE_NORMAL
- en: When specified, the `--external` option qualifies a network as a gateway network
    for a router. The network will serve as a floating IP network for attached instances.
    Networks are considered internal by default.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not all network plugins support updating certain network attributes for existing
    networks. If a change is required, the network may need to be deleted and recreated.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting ports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ports in OpenStack can be deleted with the `openstack port delete` command.
    OpenStack automatically deletes ports it creates, such as when a server or floating
    IP is created, but may not delete ports created by users and associated with instances
    at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Deleting ports associated with active instances may cause the instance to crash
    or can cause unexpected behavior in the instance.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When deleting a port, ensure that you are authenticated as an administrator
    or are the owner of the port. You will need the following details:'
  prefs: []
  type: TYPE_NORMAL
- en: Port name or ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For our example, the following will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Port name: COOKBOOK_TEST_PORT_1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the OpenStack client installed on our system, we are now able to delete
    a port with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: No output is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deleting a network in OpenStack is as easy as invoking the `openstack network
    delete` command. Neutron will delete any automatically-created ports associated
    with the network, like the ones created by/for the DHCP or router namespaces,
    and will return any automatically-assigned segmentation IDs to the respective
    pool for allocation to another network.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When deleting a network in OpenStack, ensure that all associated user-created
    ports have been deleted. This may require deleting instances, detaching and deleting
    ports from instances, or detaching and deleting ports from routers. When deleting
    a network, the following information will be necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: Network name or ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the OpenStack client installed on our system, we are able now to delete
    a network with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: No output is returned.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When invoked, the `openstack network delete` command will instruct Neutron to
    delete the specified network and any associated subnet(s), as long as all user-managed
    ports have been deleted. In a reference architecture, the layer 2 agents are responsible
    for deleting the respective virtual bridges and interfaces configured on the hosts,
    and all records of the network are purged from the OpenStack database.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Neutron does not maintain network information in the database once those objects
    have been deleted. Requests against the OpenStack API may be logged, but using
    third-party tools or proxies is highly recommended if an audit trail is required.
  prefs: []
  type: TYPE_NORMAL
- en: Managing routers and floating IPs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **router** in OpenStack represents a virtual routing device that provides
    routing capabilities to directly connected networks. To provide end-to-end connectivity
    to a virtual machine, a router must be connected to an external provider network
    and the tenant network where the instance resides. Typically, routers are created
    and managed by individual projects. By default, external provider networks are
    shared and available for use by all projects. The following diagram represents
    an external provider network owned by the `ADMIN` project and utilized by three
    other projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing routers and floating IPs](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 4.2*, three projects have routers connected to an external provider
    network. The external provider network not only provides connectivity to the routers
    and the networks behind them, but also provides a network from which floating
    IPs can be derived. Floating IPs provide 1-to-1 address translations that allow
    external clients to connect directly to instances.
  prefs: []
  type: TYPE_NORMAL
- en: Creating routers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Routers in OpenStack can be created using the `openstack router create` command.
    By default, routers are considered *internal* and can route only between directly-connected
    tenant networks. An *external* router, on the other hand, is capable of routing
    to an external gateway and can provide **network address translation** (**NAT**)
    services to connected networks.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of routers that can be created in an OpenStack reference
    architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: Standalone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Highly-Available** (**H**A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed (DVR)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standalone routers do not provide any level of resiliency, while highly available
    routers implement VRRP to provide redundancy should one or more Neutron nodes
    fail. Distributed virtual routers reside on compute nodes rather than on centralized
    network nodes, and provide higher performance than their counterparts for east/west
    traffic, or traffic between instances in different networks, since that traffic
    is forwarded between compute nodes without having to traverse a network node.
  prefs: []
  type: TYPE_NORMAL
- en: For non-admin users, the type of router that is created with the `openstack
    router create` command is determined automatically by settings defined in Neutron
    configuration files. Only users with administrator-level permissions can specify
    router types when creating routers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need the following details, at a minimum, for the router:'
  prefs: []
  type: TYPE_NORMAL
- en: Router name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For our examples, the following will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Router name: `COOKBOOK_ROUTER_STANDALONE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Router name: `COOKBOOK_ROUTER_HA`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Router name: `COOKBOOK_ROUTER_DVR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will need the following details, at a minimum, for networks attached to
    the router:'
  prefs: []
  type: TYPE_NORMAL
- en: External provider network name or ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tenant subnet name or ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For our example, the following will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'External provider network name: `COOKBOOK_PROVIDER_NET`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tenant subnet name: `COOKBOOK_TENANT_SUBNET`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the `openstack` client installed on our system, we are now able to create
    a router with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the standalone router:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will resemble the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/00043.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Create an HA router:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will resemble the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/00044.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Create a distributed router:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will resemble the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/00045.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When *any* router is created in OpenStack using the native routing services,
    a corresponding network namespace is created on one or more nodes running the
    `neutron-l3-agent` service. The namespace can be identified using the `ip netns`
    command shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: A router namespace has a prefix of `qrouter-` and a suffix that corresponds
    to the router ID. In environments where distributed virtual routers are configured,
    other namespaces needed to facilitate proper networking may exist, such as the
    `fip-` and `snat-` namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: By default, a non-admin user cannot specify the type of router being created.
    The router type is automatically determined by Neutron based on the layer 3 agent
    configuration file. The author recommends HA or distributed virtual routers, where
    possible, to limit the impact of failure for physical nodes hosting virtual routers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cloud operators can modify Neutron configuration files to change default behaviors.
    The `policy.json` file used by the Neutron API service can be modified to allow
    users and roles to perform actions usually reserved for administrators. Refer
    to community documentation for guidelines and caveats related to modifications
    to the `policy.json` files.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching networks to routers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Routers in OpenStack can connect to a single external provider network and
    one or more tenant networks, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Attaching networks to routers](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 4.3*, an external provider network provides external connectivity,
    while tenant networks provide connectivity to virtual machines and other virtual
    network devices within a project. The router's job is to facilitate end-to-end
    connectivity using routes and sometimes the NAT via floating IPs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The commands necessary to attach a network to a router may vary based on network
    and need:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Attaching a router to an external network:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Attaching a router to a tenant network using subnet ID or name:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Attaching a router to a tenant network using a specific port ID or name:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When attaching a router to a network, the following information will be necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: Router name or ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network name or ID, or Subnet name or ID, or Port name or ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember, when attaching a router to an external provider network, the network's
    `router:external` attribute must be set to `External` or `True`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To attach a network to a router in OpenStack, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Attach the router to the external provider network `COOKBOOK_PROVIDER_NET`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: No output is provided.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Attach the router to the `COOKBOOK_TENANT_SUBNET` subnet using the subnet name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: No output is provided.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When routers are attached to external provider networks, the router is assigned
    an IP address from the pool of addresses available for allocation from the network.
    The router is also configured with a default gateway that corresponds to the specified
    gateway for the respective provider subnet.
  prefs: []
  type: TYPE_NORMAL
- en: When a router is attached to a tenant network, the router becomes the gateway
    for the attached network and all instances within it. It is assigned the IP address
    specified as the gateway for the respective tenant subnet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ports attached to routers can be listed using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the following ports and corresponding subnets have been attached
    to the router:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the `ip netns exec` command, coupled with the name of the respective
    router namespace, we can see the router has two attached interfaces, `qg-ed006ed1-b8`
    and `qr-c69005cb-aa`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The names of the interfaces in the router namespace correspond to the first
    10 characters of the respective port ID. External, or gateway-side, interfaces
    are prefixed with `qg-`, while internal, or router-side, interfaces are prefixed
    with `qr-`. The naming scheme dates back to when the Neutron project was known
    as Quantum.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and assigning floating IPs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Floating IPs in OpenStack are static IPv4 addresses that are mapped to instances
    behind Neutron routers and provide direct inbound connectivity to those instances.
    Floating IPs can be used in a similar fashion to Elastic IPs in Amazon Web Services,
    where users can quickly remap an IP address from one instance to another in the
    event of failure. The heart of this functionality is network address translation.
    A floating IP is usually considered an *external* address that is mapped to the
    *internal* address configured on an instance. The NAT is implemented on the Neutron
    router connected to the instance's network. Floating IPs offer connectivity to
    instances that would otherwise be isolated behind a Neutron router on a non-routable
    network.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recall that instances are connected to ports that reflect the connected network
    and associated IP address. When creating a floating IP, the following information
    is required:'
  prefs: []
  type: TYPE_NORMAL
- en: External network name or ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When assigning a floating IP to a port, the following is necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: Floating IP ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal port name or ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For this example, create a new port in the existing tenant network named `COOKBOOK_TEST_PORT_2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a floating IP in OpenStack, issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will resemble the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Floating IPs are created with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Floating IPs can then be associated with a port, using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When a floating IP is associated with a port, Neutron uses the port information
    to determine which router to configure the NAT on. Once the NAT is in place, connections
    to the floating IP will be translated to the internal IP and forwarded to the
    respective instance. Responses from the instance will be forwarded to the router,
    translated from the internal to the floating IP, and routed back out to the origin.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, the instance''s port is associated with the `COOKBOOK_TENANT_NET`
    network, which in turn is connected to the `COOKBOOK_ROUTER_STANDALONE` router.
    Within the respective `qrouter` network namespace, we can see the source and destination
    NATs applied using `iptables`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Deleting routers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Routers in OpenStack can be deleted using the `openstack router delete` command.
    Before a router can be deleted, all subnets/ports attached to the router must
    be detached. This will cause a disruption of traffic for any instance connected
    to a network behind the router. Subnets can be detached using the `openstack router
    remove subnet` or `openstack router remove port` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When deleting a router, the following information will be necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: Router name or ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To delete a router in OpenStack, issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'No output is given. However, the operation can be verified using the `openstack
    router list` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Deleted routers will no longer appear in the list.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When invoked, the `openstack router delete` command will instruct Neutron to
    delete the specified router and associated resources. In a reference architecture,
    the layer 3 agents are responsible for deleting the respective network namespace(s)
    and virtual interfaces configured on the hosts, and all records of the router
    are purged from the OpenStack database.
  prefs: []
  type: TYPE_NORMAL
- en: Managing security groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In OpenStack, a security group describes a grouping of ports of similar security
    requirements. Security group rules are associated with security groups, and provide
    ingress and egress filtering capabilities to the group. Security group rules can
    reference other groups or remote networks using CIDR notation. The actual filtering
    takes place on the compute node at the "port" level, and may be implemented using
    iptables or as openflow rules depending on the firewall driver that is configured
    on a given node. Newly created projects each contain a security group named `default`
    that allows egress, or outbound, communication only. Ingress, or inbound, communication
    is denied.
  prefs: []
  type: TYPE_NORMAL
- en: Creating security groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Security groups in OpenStack can be created using the `openstack security group
    create` command. Security groups are project-owned objects and cannot be shared
    or referenced by other projects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When creating a security group, each port associated with the group will inherit
    the rules applied to the group. You will need the following details, at a minimum,
    for the group:'
  prefs: []
  type: TYPE_NORMAL
- en: Security group name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For our example, the following will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Security group name: `COOKBOOK_SG_WEB`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the OpenStack client installed on our system, we are now able to create
    a security group with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will resemble the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Security groups are created with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When a security group is created, OpenStack applies a default set of rules to
    the group that allows a port to communicate outbound (egress) over IPv4 and IPv6\.
    By default, all inbound traffic is denied.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a security group is only the first step in providing filtering to instances.
    The next steps, namely creating security group rules and applying security groups
    to ports, will be discussed in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Creating security group rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Security group rules in OpenStack can be created using the `openstack security
    group rule create` command. A security group rule provides information on filtering
    at a layer 3 and layer 4 level, which includes IP addresses and destination ports.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When creating a security group rule, remember that each port associated with
    the group will inherit the rules applied to the group. Therefore, it is important
    to limit the rules to only those needed to provide the desired access to the associated
    group. You will need the following details, at a minimum, for the rule:'
  prefs: []
  type: TYPE_NORMAL
- en: Security group name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For our example, the following will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Security group name: `COOKBOOK_SG_WEB`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Destination port: `80`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Protocol: TCP'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Direction: Ingress'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Source: All Addresses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the OpenStack client installed on our system, we are now able to create
    a security group rule with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will resemble the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Security groups are created with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Security group rules provide details to OpenStack that are used by Neutron agents
    to implement traffic filters on individual ports on compute nodes. In our environment,
    these rules are implemented as iptables rules.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a security group rule without providing any additional filtering information
    may result in a rule that allows ingress access from *all* source addresses. OpenStack
    assumes certain defaults when details are not specified, so it is important to
    verify the provided output to ensure the proper filtering is in place.
  prefs: []
  type: TYPE_NORMAL
- en: Applying security groups to instances
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Security groups are typically applied to instances upon boot, using the `openstack
    server create` command, but they can also be applied to individual ports, using
    the `openstack network port create` or `set` commands. When applied at boot, each
    listed security group is applied to each port associated with the instance. As
    a result, unnecessary rules may be applied to each interface that could result
    in a security risk or regression in performance of the underlying Neutron agent
    responsible for applying the rules. When applied to individual ports, users can
    ensure that if an instance is multihomed, the respective port has only the necessary
    rules needed to provide access to that interface.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The term multihomed refers to an instance that is connected to multiple networks
    via different interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When applying security groups to instances at boot, you will need the following
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: Security group name or ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When applying security groups to individual ports, you will need the following
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: Port name or ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security group name or ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For our examples, the following will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Port name: `COOKBOOK_TEST_PORT_1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Security group name: `COOKBOOK_SG_WEB`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instance name: `COOKBOOK_INSTANCE_WEB`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instance flavor: `COOKBOOK_FLAVOR_TINY`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instance image: `COOKBOOK_IMAGE_CIRROS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Network name: `COOKBOOK_TENANT_NET_1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the `openstack` client installed on our system we are able to apply security
    groups with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an instance and supply the security group at boot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Use flavors and images that are appropriate for your environment, or those that
    may have been created in [Chapter 5](part0062_split_000.html#1R42S1-189e69df43a248268db97cde1b1a8e47
    "Chapter 5. Nova – OpenStack Compute"), *Nova – OpenStack Compute* and [Chapter
    6](part0087_split_000.html#2IV0U1-189e69df43a248268db97cde1b1a8e47 "Chapter 6. Glance
    – OpenStack Image Service"), *Glance – OpenStack Image Service*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Alternatively, security groups can be applied during port creation or to existing
    ports. With the OpenStack client installed on our system we are able to apply
    security groups with the following stes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Apply a security group to a new port:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will resemble the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/00054.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Apply the security group to an existing port:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'No output is returned. However, the change can be confirmed by querying the
    security groups applied to the port using the `openstack port show` command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will resemble the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/00055.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Security groups can be applied to instances at boot, ports at creation, or to
    existing ports. Neutron plugin agents on compute nodes are responsible for applying
    the respective filtering rules to the port on the host. Multiple security groups
    can be applied to a port in all scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Security groups can be applied at boot with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Security groups can also be applied to new ports with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, security groups can be applied to existing ports with the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Ports are bound to Neutron plugin agents that reside on hosts within the environment.
    For example, ports belonging to instances are bound to the agent on the respective
    compute node where the instance lives. This agent is responsible for setting up
    the virtual networking for the port. When a security group is applied to a port,
    the Neutron agent where the port is bound implements the filtering rules on the
    host. Other agents throughout the environment are notified that the group has
    changed and are updated accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Managing load balancers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Neutron includes a service known as **Load Balancing as-a-Service** (**LBaaS**),
    which provides users with the ability to create load balancers that balance traffic
    to applications deployed across instances in the cloud. In a reference architecture,
    Neutron relies on an open source load balancing package known as HAProxy to provide
    the load balancing functionality. Much like the Neutron L3 agent handles virtual
    routers and the DHCP agent handles virtual DHCP servers, the Neutron LBaaS agent
    handles the construction and configuration of virtual load balancers upon request.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**LBaaS** should not be confused with another load balancing project known
    as Octavia. Both provide similar load balancing functions, but only LBaaS is covered
    here.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three major components to a load balancer in OpenStack:'
  prefs: []
  type: TYPE_NORMAL
- en: Pool members
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listeners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **pool member** describes a layer 4 object that is composed of the IP address
    and port of a service residing on an instance. For example, a pool member might
    be a web server with a configured address of `10.30.0.2` listening on TCP port
    `80`.
  prefs: []
  type: TYPE_NORMAL
- en: A **pool** is a group of pool members serving identical content.
  prefs: []
  type: TYPE_NORMAL
- en: A **listener** is an object that represents a **virtual IP** (**VIP**) and port
    that is listening on the load balancer itself. Traffic to the virtual IP will
    be balanced among the members of the associated pool.
  prefs: []
  type: TYPE_NORMAL
- en: Additional components, such as health monitors and L7 policies, help extend
    the usefulness and functionality of a load balancer, but are not required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The workflow for creating a functioning load balancer is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a load balancer object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create and associate listener
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create and associate a pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create and associate pool member(s)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create and associate health monitor(s) (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating load balancers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As of the Pike release of OpenStack, load balancer-related commands are not
    available in the OpenStack client. Instead, the `neutron` client should be used.
    Load balancers in OpenStack can be created using the `neutron lbaas-loadbalancer-create`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need the following details, at a minimum, for the load balancer:'
  prefs: []
  type: TYPE_NORMAL
- en: VIP subnet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A name is also recommended. For our example, the following will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: `COOKBOOK_LOADBALANCER_1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'VIP subnet: `COOKBOOK_TENANT_SUBNET_1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the Neutron client installed on our system, we are now able to create
    a load balancer object with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will resemble the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Load balancers are created with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: When a load balancer is created, OpenStack assigns an IP address known as a
    virtual IP. The VIP will be used by clients to access the load-balanced application.
    Creating a load balancer object is only the first step in load balancing traffic
    to instances. The next steps, creating a listener, pool, and health monitor will
    be discussed in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Creating pools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pools that are associated with load balancers are objects that represent a collection
    of instances that receive traffic sent to the VIP. Load balancing pools in OpenStack
    can be created using the `neutron lbaas-pool-create` command.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need the following details, at a minimum, for the pool:'
  prefs: []
  type: TYPE_NORMAL
- en: Balancing algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load balancer or listener
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A name is also recommended. For our example, the following will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: `COOKBOOK_POOL_1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Balancing algorithm: `ROUND_ROBIN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Protocol: `HTTP`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Load balancer: `COOKBOOK_LOADBALANCER_1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A load balancer can be associated with multiple listeners, which in turn can
    be associated with their own respective pool. A common scenario for this type
    of set up would be a load balancer with a listener on port `80` and another on
    port `443`, each with their respective backend pool.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the Neutron client installed on our system, we are now able to create
    a load balancer pool with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will resemble the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Load balancer pools are created with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Other load-balancing objects, such as members and monitors, reference pools
    and cannot be created without being applied to one at that time.
  prefs: []
  type: TYPE_NORMAL
- en: Creating members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Members are associated with pools, and are objects that represent a backend
    application listening on a particular IP and port. Pool members in OpenStack can
    be created using the `neutron lbaas-member-create` command.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need the following details, at a minimum, for the member:'
  prefs: []
  type: TYPE_NORMAL
- en: Subnet name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IP address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pool name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A name is also recommended. For our example, the following will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: `COOKBOOK_MEMBER_1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Subnet name: `COOKBOOK_TENANT_SUBNET_1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'IP Address: `172.16.200.11` (Corresponds to `COOKBOOK_TEST_PORT_2`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Port: `80`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pool name: `COOKBOOK_POOL_1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A member can only be associated with a single pool. However, the same IP address
    and application port combination can be used for multiple members.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the Neutron client installed on our system we are able to create a pool
    member with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will resemble the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pool members are created with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Creating listeners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Listeners are associated with load balancer objects, and they describe the relationship
    between the load balancer VIP and the port a service is listening on. Clients
    send traffic to the listener address and port, which is then proxied and sent
    to one member within pool of servers. Each listener can be configured to send
    traffic to a different pool. Listeners in OpenStack can be created using the `neutron
    lbaas-listener-create` command.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need the following details, at a minimum, for the listener:'
  prefs: []
  type: TYPE_NORMAL
- en: Load balancer name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A name and default pool are also recommended. For our example, the following
    will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: `COOKBOOK_LISTENER_1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Load balancer name: `COOKBOOK_LOADBALANCER_1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Protocol: `HTTP`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Port: `80`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Default pool: `COOKBOOK_POOL_1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the Neutron client installed on our system, we are now able to create
    a listener with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will resemble the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Listeners are created with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Access to the listener may be restricted by applying a security group to the
    respective port of the load balancer address. Use the `openstack port set` command
    described earlier in this chapter to apply a security group to the listener's
    port.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying connectivity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the workflow has been completed and the application on the pool members
    has been started, connectivity to the load balancer VIP can be verified using
    a web browser or the `curl` command from a client that can reach the VIP. In this
    example, a web server is running on the pool member configured in a previous section.
    We will be connecting from the `qlbaas` namespace associated with the load balancer,
    but you can also connect from the `qdhcp` namespace associated with the network
    from which the VIP address was sourced.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need the following details, at a minimum, to test connectivity
  prefs: []
  type: TYPE_NORMAL
- en: Network ID or Load balancer ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VIP address and port
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For our example, the following will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Load Balancer ID: `aa599cee-b49f-44f1-a0fd-51fa69ebf6db` (`COOKBOOK_LOADBALANCER_1`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'VIP address and port: `172.16.200.14:80`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From within the Neutron agent container, connectivity to the VIP can be confirmed
    using `curl` within the `qdhcp` or `qlbaas` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will resemble the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may need to install the `curl` utility for the command to work. In the Neutron
    agent container, this can be accomplished by running `apt install curl`. The configuration
    of the web server on the pool member is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: To provide access to the load balancer virtual IP from outside networks, it
    may be necessary to map a floating IP to the virtual IP. Instructions provided
    earlier in this chapter can assist with that task.
  prefs: []
  type: TYPE_NORMAL
