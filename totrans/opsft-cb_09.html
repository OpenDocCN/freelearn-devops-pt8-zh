<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;9.&#xA0;OpenShift for Node.js Developers"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09" class="calibre1"/>Chapter 9. OpenShift for Node.js Developers</h1></div></div></div><p class="calibre6">This chapter presents a number of recipes that will help you get started with Node.js web application development on OpenShift. The specific recipes of this chapter are:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Creating your first Node.js application</li><li class="listitem">Configuring Node supervisor options</li><li class="listitem">Managing Node.js application dependencies</li><li class="listitem">Using the use_npm marker</li><li class="listitem">Enabling hot deployment for Node.js applications</li><li class="listitem">Creating and deploying Express web applications using Node.js and MongoDB cartridges</li><li class="listitem">Working with Web Sockets</li><li class="listitem">Using CoffeeScript with OpenShift Node.js applications</li></ul></div></div>

<div class="book" title="Chapter&#xA0;9.&#xA0;OpenShift for Node.js Developers">
<div class="book" title="Introduction"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch09lvl1sec109" class="calibre1"/>Introduction</h1></div></div></div><p class="calibre6">Node.js<a id="id888" class="calibre1"/> is a server-side JavaScript platform built on top of Google's Chrome V8 JavaScript engine that developers can use to write applications. These applications can be web applications, command-line utilities, or scripts to automate tasks. Node.js is a very popular choice for web application development, as it allows web developers to use a single programming language, such as JavaScript, on both the client side and the server side. It is suitable for building highly concurrent, data-intensive, real-time web applications because of its asynchronous, event-driven, non-blocking I/O nature. Node has a small core that provides the basic building block APIs to write higher-level frameworks. The developers can then use the web frameworks to build their awesome web applications. </p><p class="calibre6">There are many web frameworks, such as Express<a id="id889" class="calibre1"/> (<a class="calibre1" href="http://expressjs.com/">http://expressjs.com/</a>), Sails.js<a id="id890" class="calibre1"/> (<a class="calibre1" href="http://sailsjs.org/">http://sailsjs.org/</a>), Restify<a id="id891" class="calibre1"/> (<a class="calibre1" href="http://mcavage.me/node-restify/">http://mcavage.me/node-restify/</a>), and Geddy<a id="id892" class="calibre1"/> (<a class="calibre1" href="http://geddyjs.org/">http://geddyjs.org/</a>), developed by the Node community that developers can use for their web applications. Many big tech giants, such as LinkedIn, Walmart<a id="id893" class="calibre1"/> (<a class="calibre1" href="http://venturebeat.com/2012/01/24/why-walmart-is-using-node-js/">http://venturebeat.com/2012/01/24/why-walmart-is-using-node-js/</a>), and Yahoo, are using Node.js for their production applications.</p><p class="calibre6">OpenShift provides web developers a hosting platform to deploy their Node.js web applications. You can run applications built using any of the Node.js web frameworks, such as Express or Geddy, on OpenShift. At the time of writing this book, OpenShift supports two versions of Node.js—0.6 and 0.10. The following command shows the currently supported Node.js versions:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ rhc cartridges | grep node</strong></span>
<span class="strong"><strong class="calibre7">nodejs-0.10         Node.js 0.10                            web</strong></span>
<span class="strong"><strong class="calibre7">nodejs-0.6          Node.js 0.6                             web</strong></span>
</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note31" class="calibre1"/>Note</h3><p class="calibre6">The Node Version 0.6 cartridge will get deprecated in the future, so you are advised not to use it for your web applications. This book will only cover Version 0.10.</p></div><p class="calibre6">The <span class="strong"><em class="calibre10">Creating your first Node.js application</em></span> recipe will walk you through creating your first OpenShift Node.js web application. We will look into the template application created by OpenShift and then write a simple HTTP server using Node's HTTP module and deploy it to OpenShift.</p><p class="calibre6">The Node.js web applications are very different from the traditional web applications that you might have written so far. The web applications themselves are web servers, so you do not need Apache or any other web server to host your web application. There are various ways to fire up Node applications, such as using the commands <code class="email">node &lt;app script file&gt;</code> and <code class="email">npm start</code>, <code class="email">supervisor &lt;app script file&gt;</code>. OpenShift uses a Node module called <span class="strong"><strong class="calibre7">node-supervisor</strong></span><a id="id894" class="calibre1"/> to run your application. The node-supervisor <a id="id895" class="calibre1"/>module (<a class="calibre1" href="https://github.com/isaacs/node-supervisor">https://github.com/isaacs/node-supervisor</a>) runs the Node application and watches for any changes. Once it detects changes, it restarts the application. In the <span class="strong"><em class="calibre10">Configuring Node supervisor options</em></span> recipe, you will learn how to customize a few supervisor options to take advantage of the hot reloading behavior. The alternative to using supervisor is to use the <code class="email">npm start</code> command to run Node applications. You can configure OpenShift Node.js applications to use <code class="email">npm start</code> instead of <code class="email">supervisor</code> by using a marker file. This will be covered in the <span class="strong"><em class="calibre10">Using the use_npm marker</em></span> recipe.</p><p class="calibre6">In the <span class="strong"><em class="calibre10">Managing Node.js application dependencies</em></span> recipe, you will learn how OpenShift uses <code class="email">npm</code> to install and manage your application dependencies.</p><p class="calibre6">The example application in this chapter will be developed using the Express web framework and MongoDB database. The <span class="strong"><em class="calibre10">Creating and deploying Express web applications using Node.js and MongoDB cartridges</em></span> recipe will walk you through all the steps required to build and deploy Express web applications on OpenShift. All the source code for this chapter is available on the OpenShift Cookbook GitHub organization (<a class="calibre1" href="https://github.com/OpenShift-Cookbook">https://github.com/OpenShift-Cookbook</a>).</p><p class="calibre6">Node.js is very popular for building real-time web applications using Web Sockets. In the <span class="strong"><em class="calibre10">Working with Web Sockets</em></span> recipe, you will build a simple, real-time application using the Node Socket.IO library.</p><p class="calibre6">Instead of using JavaScript to write Node applications, developers can also use CoffeeScript to write their Node applications. CoffeeScript compiles to JavaScript and is a popular choice among developers who don't like to use JavaScript. The <span class="strong"><em class="calibre10">Using CoffeeScript with OpenShift Node.js applications</em></span> recipe will cover this in detail.</p><p class="calibre6">To run the example applications that you will develop in this chapter on your local machine, you will need to install Node on your operating system. You can get the latest installer of Node.js<a id="id896" class="calibre1"/> for your operating system from the official website, <a class="calibre1" href="http://nodejs.org/download/">http://nodejs.org/download/</a>. The installer will also install npm for you. This chapter will also use the MongoDB database. You can get the latest installer of MongoDB<a id="id897" class="calibre1"/> for your operating system from their official website (<a class="calibre1" href="http://www.mongodb.org/downloads">http://www.mongodb.org/downloads</a>).</p><p class="calibre6">This chapter assumes that you are comfortable with Node web development basics, OpenShift application basics, and how to work with OpenShift database cartridges. If you are not comfortable with these topics, I recommend you first read <a class="calibre1" title="Chapter 3. Creating and Managing Applications" href="part0041_split_000.html#page">Chapter 3</a>, <span class="strong"><em class="calibre10">Creating and Managing Applications</em></span>, and <a class="calibre1" title="Chapter 6. Using MongoDB and Third-party Database Cartridges with OpenShift Applications" href="part0079_split_000.html#page">Chapter 6</a>, <span class="strong"><em class="calibre10">Using MongoDB and Third-party Database Cartridges with OpenShift Applications</em></span>, before continuing with this chapter.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Creating your first Node.js application"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec110" class="calibre1"/>Creating your first Node.js application</h1></div></div></div><p class="calibre6">In this recipe, you will learn how<a id="id898" class="calibre1"/> to create your first OpenShift Node.js application using the rhc command-line tool. After understanding the template application created by OpenShift, you will write a <code class="email">Hello World</code> Node.js application using Node's HTTP module.</p></div>

<div class="book" title="Creating your first Node.js application">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec430" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre6">To complete this recipe, you will need the rhc command-line client installed on your machine. Please refer to the <span class="strong"><em class="calibre10">Installing the OpenShift rhc command-line client</em></span> recipe in <a class="calibre1" title="Chapter 1. Getting Started with OpenShift" href="part0014_split_000.html#page">Chapter 1</a>, <span class="strong"><em class="calibre10">Getting Started with OpenShift</em></span>, for details. This application will consume one gear, so if you don't have an extra gear available for this recipe, use the <code class="email">rhc delete-app &lt;app_name&gt; --confirm</code> command to delete an existing application. To run this application on your local machine, you will need Node installed on your machine. You can get the latest installer of <a id="id899" class="calibre1"/>Node.js for your operating system from the official website, <a class="calibre1" href="http://nodejs.org/download/">http://nodejs.org/download/</a>.</p></div></div>

<div class="book" title="Creating your first Node.js application">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec431" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre6">Perform the following steps to create your <a id="id900" class="calibre1"/>first OpenShift Node.js application:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Open a new command-line terminal, and change the directory to a convenient location where you want to create the application. To create a Node.js 0.10 application, run the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ rhc create-app myapp nodejs-0.10</strong></span>
</pre></div></li><li class="listitem" value="2">Open your favorite web browser, and go to <code class="email">http://myapp-{domain-name}.rhcloud.com</code> to view the application. Please replace <code class="email">{domain-name}</code> with your OpenShift account domain name.</li><li class="listitem" value="3">The template application created by OpenShift is an Express web framework application. You can use your own template application by specifying your public Git repository using the <code class="email">--from-code</code> option. This was covered in the <span class="strong"><em class="calibre10">Specifying your own template Git repository URL</em></span> recipe in <a class="calibre1" title="Chapter 3. Creating and Managing Applications" href="part0041_split_000.html#page">Chapter 3</a>, <span class="strong"><em class="calibre10">Creating and Managing Applications</em></span>. In this recipe, you don't need the template code generated by OpenShift, so delete all the files and directories created by OpenShift except the <code class="email">.openshift</code> directory. On the *nix machine, you can use the <code class="email">rm</code> command to delete the files as shown in the following command. On Windows, you can use file explorer or the command-line equivalent to delete these files.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ cd myapp</strong></span>
<span class="strong"><strong class="calibre7">$ rm -rf deplist.txt index.html node_modules/ package.json server.js</strong></span>
</pre></div></li><li class="listitem" value="4">Create a new empty file named <code class="email">server.js</code> in the application root directory. On *nix machines, you can use the <code class="email">touch</code> command to create a new file. On Windows machines, you can use file explorer to create the new file. Run the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ touch server.js</strong></span>
</pre></div><p class="calibre14">Open the file in your favorite editor, and populate it with the following code:</p><div class="informalexample"><pre class="programlisting">var http = require('http');
var ip = process.env.OPENSHIFT_NODEJS_IP || '127.0.0.1';
var port = process.env.OPENSHIFT_NODEJS_PORT || 3000;
var server = http.createServer(function(req,res){
   res.writeHead(200, {'Content-Type':'text/plain'});
   res.end('Hello World!!');
});
server.listen(port,ip);
console.log('Server running at http://%s:%d',ip,port);</pre></div></li><li class="listitem" value="5">To run the application on your local machine, run the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ node server.js</strong></span>
</pre></div><p class="calibre14">To see the application in action, open the <code class="email">http://127.0.0.1:3000</code> in your favorite browser. You will see the <span class="strong"><strong class="calibre7">Hello World!!</strong></span> message rendered in your browser.</p></li><li class="listitem" value="6">To deploy the application on OpenShift, commit the code to the local Git repository, and then push the changes to the application gear:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ git add .</strong></span>
<span class="strong"><strong class="calibre7">$ git commit -am "Hello World Node.js application" </strong></span>
<span class="strong"><strong class="calibre7">$ git push</strong></span>
</pre></div></li><li class="listitem" value="7">After successful deployment, open the <code class="email">http://myapp-{domain-name}.rhcloud.com</code> in your favorite browser. The browser will render <span class="strong"><strong class="calibre7">Hello World!!</strong></span>. </li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Creating your first Node.js application">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec432" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre6">In the previous <a id="id901" class="calibre1"/>steps, you created a <code class="email">Hello World</code> Node.js application from scratch and deployed it on OpenShift. The <code class="email">Hello World</code> application that you wrote in the aforementioned steps is no different from the one you will write if you want to run this application on your local machine or elsewhere. There is no OpenShift-specific apart from the environment variables.</p><p class="calibre6">In step 1, you created an OpenShift Node.js 0.10 application using the rhc command-line tool. The <code class="email">rhc create-app</code> command<a id="id902" class="calibre1"/> will make an HTTP POST request to the OpenShift broker. The OpenShift broker will accept the request and then initiate the application creation process. You specified that OpenShift should create a Node.js 0.10 application with <code class="email">myapp</code> as the application name. OpenShift will use these details along with a few defaults to create the <code class="email">myapp</code> application. The defaults include small gear size, non-scalable application, and using the current directory to clone the Git repository. OpenShift behind the scenes did the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">OpenShift created a new application gear with the Node.js cartridge.</li><li class="listitem">It created a private Git repository for your application and populated it with a template application. The template application that OpenShift creates is an Express web framework application.</li><li class="listitem">It installed a Git action hook that will build the application. During the application build phase, it will download all the dependencies mentioned in <code class="email">package.json</code> using the <code class="email">npm install</code> command.</li><li class="listitem">It created a public DNS for your application so that it is accessible from the outside world.</li></ul></div><p class="calibre6">After successful<a id="id903" class="calibre1"/> application creation, you will have the <code class="email">myapp</code> directory inside the current directory. You can view the application by opening the application URL in your browser as mentioned in step 2. The application creation process was explained in detail in the <span class="strong"><em class="calibre10">Creating an OpenShift application using the rhc command-line client</em></span> recipe in <a class="calibre1" title="Chapter 3. Creating and Managing Applications" href="part0041_split_000.html#page">Chapter 3</a>, <span class="strong"><em class="calibre10">Creating and Managing Applications</em></span>.</p><p class="calibre6">Now, let's look at the template application created by OpenShift:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ cd myapp &amp;&amp; ls -ap</strong></span>
<span class="strong"><strong class="calibre7">.git/      README.md    index.html   package.json</strong></span>
<span class="strong"><strong class="calibre7">.openshift/   deplist.txt   node_modules/   server.js</strong></span>
</pre></div><p class="calibre6">The template application has five files—<code class="email">README.md</code>, <code class="email">index.html</code>, <code class="email">package.json</code>, <code class="email">deplist.txt</code>, and <code class="email">server.js</code>—and the <code class="email">node_modules</code> directory apart from the <code class="email">.openshift</code> and <code class="email">.git</code> directories. We have already talked about <code class="email">.openshift</code> and <code class="email">.git</code> in the <span class="strong"><em class="calibre10">Creating an OpenShift application using the rhc command-line client</em></span> recipe in <a class="calibre1" title="Chapter 3. Creating and Managing Applications" href="part0041_split_000.html#page">Chapter 3</a>, <span class="strong"><em class="calibre10">Creating and Managing Applications</em></span>, so I will not cover them here. Let's talk about the others one by one:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">README.md</code>: This is<a id="id904" class="calibre1"/> a standard Git repository markdown file where you can summarize your project. GitHub uses <code class="email">README.md</code> to generate the HTML summary of the project.</li><li class="listitem"><code class="email">index.html</code>: This <a id="id905" class="calibre1"/>file contains the HTML markup that you will see when you view the application in the browser. This is an HTML 5 file with Twitter Bootstrap styling.</li><li class="listitem"><code class="email">package.json</code>: This is <a id="id906" class="calibre1"/>your Node application descriptor. This is a JSON document that contains all the information about your application, such as name, description, version, and libraries, that this application depends on. The full documentation is available at <a class="calibre1" href="https://www.npmjs.org/doc/json.html">https://www.npmjs.org/doc/json.html</a>.</li><li class="listitem"><code class="email">deplists.txt</code>: This is a <a id="id907" class="calibre1"/>deprecated method to specify application dependencies in OpenShift Node.js applications. It is recommended not to use it, as this may get removed in the future. This file only exists for backward compatibility so that the application that uses it keeps running.</li><li class="listitem"><code class="email">server.js</code>: This file houses <a id="id908" class="calibre1"/>the template Express web framework application created by OpenShift. This application exposes a couple of routes, <code class="email">/</code> and <code class="email">/asciimo</code>. The <code class="email">/</code> route renders <code class="email">index.html</code>, and the second route renders an HTML page with images. The Express application will be covered in detail in the <span class="strong"><em class="calibre10">Creating and deploying Express web applications using Node.js and MongoDB cartridges</em></span> recipe, so we will not cover it in this recipe.</li><li class="listitem"><code class="email">node_modules</code>: This <a id="id909" class="calibre1"/>directory houses all the application dependencies you specify in <code class="email">package.json</code>. The <code class="email">npm install</code> command will download all the dependencies in the <code class="email">node_modules</code> directory.</li></ul></div><p class="calibre6">The template <a id="id910" class="calibre1"/>application generated by OpenShift is a standard Express web application. To run this application on your local machine, you can run the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ npm install</strong></span>
<span class="strong"><strong class="calibre7">$ node server.js</strong></span>
</pre></div><p class="calibre6">The application will be running at <code class="email">http://127.0.0.1:8080/</code>. The previous two commands did the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The <code class="email">npm install</code> command<a id="id911" class="calibre1"/> downloads all the dependencies mentioned in the <code class="email">package.json</code> file. The template application mentions <code class="email">express</code> as its dependency, so the <code class="email">npm install</code> command will download Express and all its transitive dependencies in the <code class="email">node_modules</code> directory.</li><li class="listitem">As mentioned in the introduction section, in Node, the server and the application are the same. So, you used the <code class="email">node server.js</code> command to fire up the application's server. This starts the HTTP server, and you can start making requests.</li></ul></div><p class="calibre6">The <code class="email">node server.js</code> command<a id="id912" class="calibre1"/> is one way to fire up the application. The other alternatives to start the application are the <code class="email">npm start</code> and <code class="email">supervisor server.js</code> commands. The <code class="email">npm start</code> command will run the package start script if one was provided. The start script can be mentioned in the <code class="email">package.json</code> file:</p><div class="informalexample"><pre class="programlisting">"scripts":{"start":"node server.js"}</pre></div><p class="calibre6">If the <code class="email">package.json</code> file does not contain the start script, the <code class="email">npm start</code> command will use the <code class="email">node server.js</code> command as the default start script.</p><p class="calibre6">OpenShift, by default, does not use the <code class="email">npm start</code> or <code class="email">node &lt;server script&gt;</code> command to run your application. It uses a module called node-supervisor to run the application. You can configure OpenShift Node applications to use the <code class="email">npm start</code> command instead of node-supervisor. This will be covered in the <span class="strong"><em class="calibre10">Using the use_npm marker</em></span> recipe. The main advantage of using the supervisor is that it can restart the application when they crash. Also, you can use the supervisor to achieve the hot reloading behavior. It can monitor a set of directories and files and restart the application when code changes.</p><p class="calibre6">If you want to use node-supervisor on your local machine, you can install the node-supervisor module using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ npm install supervisor -g</strong></span>
</pre></div><p class="calibre6">Now you can start the application using the <code class="email">supervisor server.js</code> command. This will restart the application every time you make changes to your source code. This can be very useful during the development time, as it will save the time required to restart the application.</p><p class="calibre6">In step 3, you <a id="id913" class="calibre1"/>deleted the template source code generated by OpenShift so that you can write a simple HTTP server from scratch. In step 4, you created a new file named <code class="email">server.js</code> and populated it with the <code class="email">Hello World</code> Node.js code. The code listing in step 4 does the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">You imported the Node HTTP module using the <code class="email">require()</code> function. This will be used to write the server.</li><li class="listitem">Then, you created two variables to hold the IP address and port. If the application runs on a local machine, OpenShift-specific environment variables will not be available. Hence, the IP and port will be <code class="email">127.0.0.1</code> and 3000 respectively.</li><li class="listitem">Next, you created the HTTP server using the HTTP module <code class="email">createServer()</code> function. You passed a callback that will be fired whenever a request happens. The callback function accepts two arguments—request and response—and writes <code class="email">Hello World</code> to the response.</li><li class="listitem">Finally, you instructed the server to listen on the IP and port variables.</li></ul></div><p class="calibre6">In step 5, you tested the <code class="email">Hello World</code> application on the local machine by running the <code class="email">node server.js</code> command. To deploy the application on OpenShift, you committed the code to the local Git repository and pushed the changes to the application gear in step 6.</p><p class="calibre6">When you push the source code to the OpenShift Node.js application Git repository, OpenShift will do the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">First, all the bits are pushed to the application Git repository.</li><li class="listitem">Then, if the <code class="email">package.json</code> file is present, and this is the first time you are pushing the source code, it will download all the dependencies mentioned in <code class="email">package.json</code>. On every subsequent push, only new dependencies that are already not present will be downloaded. All existing node modules will be cached.</li><li class="listitem">OpenShift will run the application using one of the three commands mentioned in the subsequent list. This will change when the <code class="email">use_npm</code> marker file is present and will be covered in the <span class="strong"><em class="calibre10">Using the use_npm marker</em></span> recipe.<div class="book"><ul class="itemizedlist1"><li class="listitem">If <code class="email">package.json</code> is not present, OpenShift will run the <code class="email">supervisor server.js</code> command.</li><li class="listitem">If <code class="email">package.json</code> is present and the name of the main file in the application is <code class="email">server.js</code>, OpenShift will run the <code class="email">supervisor server.js</code> command. The name of the main file is mentioned in the <code class="email">package.json</code> main element.</li><li class="listitem">If <code class="email">package.json</code> is present and the name of the main file in the application is something other than <code class="email">server.js</code> (like app.js), OpenShift will run the <code class="email">supervisor app.js</code> command.</li></ul></div></li></ul></div><p class="calibre6">As you did not <a id="id914" class="calibre1"/>include <code class="email">package.json</code>, OpenShift will run the application using the <code class="email">supervisor server.js</code> command. Once the application is started, you can open the application URL in the browser, and you will be greeted with <span class="strong"><strong class="calibre7">HelloWorld!!</strong></span> as shown in step 7.</p></div></div>

<div class="book" title="Creating your first Node.js application">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec433" class="calibre1"/>See also</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">The <span class="strong"><em class="calibre10">Configuring Node supervisor options</em></span> recipe</li><li class="listitem">The <span class="strong"><em class="calibre10">Enabling hot deployment for Node.js applications</em></span> recipe</li><li class="listitem">The <span class="strong"><em class="calibre10">Managing Node.js application dependencies</em></span> recipe</li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Configuring Node supervisor options"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec111" class="calibre1"/>Configuring Node supervisor options</h1></div></div></div><p class="calibre6">As mentioned in the <span class="strong"><em class="calibre10">Creating your first Node.js application</em></span> recipe, OpenShift uses the node-supervisor module<a id="id915" class="calibre1"/> to run your programs. In this recipe, you will<a id="id916" class="calibre1"/> learn how you can configure node-supervisor options. If you have the node-supervisor module installed on your machine, you can see all the supported options by running the following command. You can install node-supervisor by executing the <code class="email">npm install supervisor -g</code> command. The help option can be viewed using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ supervisor --help</strong></span>
</pre></div><p class="calibre6">OpenShift allows you to configure the node-supervisor watch and poll-interval options. The watch option allows you to specify a comma-delimited list of folders or JavaScript files that the supervisor watches for changes. The poll-interval option allows you to specify how often the supervisor should poll for changes.</p></div>

<div class="book" title="Configuring Node supervisor options">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec434" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre6">To complete this recipe, you will need the rhc command-line client installed on your machine. Please refer to the <span class="strong"><em class="calibre10">Installing the OpenShift rhc command-line client</em></span> recipe in <a class="calibre1" title="Chapter 1. Getting Started with OpenShift" href="part0014_split_000.html#page">Chapter 1</a>, <span class="strong"><em class="calibre10">Getting Started with OpenShift</em></span>, for details. This application will consume one gear, so if you don't have an extra gear available for this recipe, use the <code class="email">rhc delete app &lt;app_name&gt; --confirm</code> command to delete an existing application. To run this application on your local machine, you will need Node installed on your machine. You can get the latest installer of Node.js for your operating system from the official website, <a class="calibre1" href="http://nodejs.org/download/">http://nodejs.org/download/</a>.</p></div></div>

<div class="book" title="Configuring Node supervisor options">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec435" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre6">Perform the following <a id="id917" class="calibre1"/>steps to configure supervisor options:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">If you don't already<a id="id918" class="calibre1"/> have a Node.js application running, create a new application by executing the following command. This will create the application you created in the <span class="strong"><em class="calibre10">Creating your first Node.js application</em></span> recipe.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ rhc create-app myapp nodejs-0.10 --from-code https://github.com/OpenShift-Cookbook/chapter9-recipe1.git</strong></span>
</pre></div></li><li class="listitem" value="2">Change the directory to <code class="email">myapp</code>, and create two environment variables to configure the supervisor poll interval and directories to watch.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ cd myapp</strong></span>
<span class="strong"><strong class="calibre7">$ rhc env-set OPENSHIFT_NODEJS_POLL_INTERVAL=60000 OPENSHIFT_NODEJS_WATCH=$OPENSHIFT_REPO_DIR --app myapp</strong></span>
</pre></div><p class="calibre14">Replace the <code class="email">$OPENSHIFT_REPO_DIR</code> variable with the value of your application's <code class="email">$OPENSHIFT_REPO_DIR</code> environment variable. You can get the value of <code class="email">$OPENSHIFT_REPO_DIR</code> by running the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ rhc ssh --command "env |grep OPENSHIFT_REPO_DIR"</strong></span>
</pre></div></li><li class="listitem" value="3">Restart the application to allow it to pick the new environment variables:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ rhc restart-app --app myapp</strong></span>
</pre></div></li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Configuring Node supervisor options">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec436" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre6">The node-supervisor module helps OpenShift to restart Node applications when they die. This is very helpful for developers, as they do not have to restart the application themselves if applications can recover after restart. Another useful feature of node-supervisor is its support for hot reload. You can tell node-supervisor to watch directories or files, and when they change, the application will be restarted. This gives the hot reloading behavior.</p><p class="calibre6">In step 2, you created two environment variables that OpenShift exposes to configure the hot reloading behavior. The <code class="email">OPENSHIFT_NODEJS_WATCH</code> environment variable allows you to specify a comma-delimited list of folders or JavaScript files that the supervisor should watch for changes. You told the supervisor to monitor the <code class="email">$OPENSHIFT_REPO_DIR</code> variable. The <code class="email">OPENSHIFT_NODEJS_POLL_INTERVAL</code> environment variable allows you to specify in milliseconds how often the supervisor should poll for changes. The default value for polling is 10 seconds. You told the supervisor to poll <code class="email">$OPENSHIFT_REPO_DIR</code> every 60 seconds.</p><p class="calibre6">The node-supervisor hot reloading behavior is not suitable for the <code class="email">git push</code> deployment model but can be useful if you use OpenShift SFTP support<a id="id919" class="calibre1"/> (<a class="calibre1" href="https://www.openshift.com/blogs/getting-started-with-sftp-and-openshift">https://www.openshift.com/blogs/getting-started-with-sftp-and-openshift</a>). The reason it is not suitable for the <code class="email">git push</code> deployment model is that you are already pushing the code to application gear, which will update the <code class="email">$OPENSHIFT_REPO_DIR</code> variable with new code and restart the application. The preferred way to use hot deployment with <code class="email">git push</code> is by using the <code class="email">hot_deploy</code> marker file. This is explained in the <span class="strong"><em class="calibre10">Enabling hot deployment for Node.js applications</em></span> recipe. To see hot reload in action, we will SSH into the application gear and change the source code as follows:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">SSH into<a id="id920" class="calibre1"/> the OpenShift application gear using <a id="id921" class="calibre1"/>the <code class="email">rhc ssh</code> command. Instead of SSH, you can also use the SFTP client to connect with the application gear, as mentioned in the following blog: <a class="calibre1" href="https://www.openshift.com/blogs/using-filezilla-and-sftp-on-windows-with-openshift">https://www.openshift.com/blogs/using-filezilla-and-sftp-on-windows-with-openshift</a>.</li><li class="listitem" value="2">Once connected, change the directory to the <code class="email">app-root/repo</code> directory:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ cd app-root/repo</strong></span>
</pre></div></li><li class="listitem" value="3">Open the <code class="email">server.js</code> file using <code class="email">vim</code> and change <code class="email">"Hello World!!"</code> to <code class="email">"Hello OpenShift User!!"</code> and save the file.</li><li class="listitem" value="4">In the next polling cycle, the supervisor will detect the change and restart the application. You can view your change by opening the application URL in your favorite browser.</li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Configuring Node supervisor options">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec437" class="calibre1"/>See also</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">The <span class="strong"><em class="calibre10">Creating your first Node.js application</em></span> recipe</li><li class="listitem">The <span class="strong"><em class="calibre10">Enabling hot deployment for Node.js applications</em></span> recipe</li><li class="listitem">The <span class="strong"><em class="calibre10">Managing Node.js application dependencies</em></span> recipe</li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Managing Node.js application dependencies"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec112" class="calibre1"/>Managing Node.js application dependencies</h1></div></div></div><p class="calibre6">So far in this chapter, you didn't <a id="id922" class="calibre1"/>have to use any third-party library. The applications that you developed were simple <code class="email">Hello World</code> applications that didn't require any third-party library to do their work. In real applications, you have to use libraries written by others. Node makes it very easy for developers to consume third-party libraries using npm. npm is the package manager for Node.js that comes bundled with Node. It is a command-line tool that allows you to publish new modules, downloads existing modules from the npm registry, and installs third-party modules. In this recipe, you will write another simple application, but that will use the Express framework. The goal of the recipe was to introduce you to the Node dependency management without getting bogged down by the application details.</p></div>

<div class="book" title="Managing Node.js application dependencies">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec438" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre6">To complete this recipe, you will need the rhc command-line client installed on your machine. Please refer to the <span class="strong"><em class="calibre10">Installing the OpenShift rhc command-line client</em></span> recipe in <a class="calibre1" title="Chapter 1. Getting Started with OpenShift" href="part0014_split_000.html#page">Chapter 1</a>, <span class="strong"><em class="calibre10">Getting Started with OpenShift</em></span>, for details. This application will consume one gear, so if you don't have an extra gear available for this recipe, use the <code class="email">rhc delete app &lt;app_name&gt; --confirm</code> command to delete an existing application. To run this application on your local machine, you will need Node installed on your machine. You can get the latest installer of Node.js for your operating system from the official website (<a class="calibre1" href="http://nodejs.org/download/">http://nodejs.org/download/</a>).</p></div></div>

<div class="book" title="Managing Node.js application dependencies">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec439" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre6">In this recipe, you will create a <code class="email">Hello World</code> Express framework web application from scratch. Perform the following steps to create the application:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Recreate the application created in the <span class="strong"><em class="calibre10">Creating your first Node.js application</em></span> recipe by executing the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ rhc app create myapp nodejs-0.10 --from-code https://github.com/OpenShift-Cookbook/chapter9-recipe1.git</strong></span>
</pre></div></li><li class="listitem" value="2">Create a new file in the application root directory named <code class="email">package.json</code>. The <code class="email">package.json</code> file is an application descriptor file that you can use to define application metadata and its dependencies.<div class="informalexample"><pre class="programlisting">{
  "name": "myapp",
  "description": "My OpenShift Node.js Application",
  "version": "0.0.1"
}</pre></div></li><li class="listitem" value="3">The application will use the Express web framework, so install the express dependency using the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ npm install express --save</strong></span>
</pre></div><p class="calibre14">This will download the Express framework module and its dependencies in the <code class="email">node_modules</code> directory and populate the <code class="email">package.json</code> file with express dependency, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">{
  "name": "myapp",
  "description": "My OpenShift Node.js Application",
  "version": "0.0.1",
  "dependencies": {
    "express": "~4.3.1"
  }
}</pre></div></li><li class="listitem" value="4">Replace the code in <code class="email">server.js</code> with the following code:<div class="informalexample"><pre class="programlisting">var express = require('express');
var ip = process.env.OPENSHIFT_NODEJS_IP || '127.0.0.1';
var port = process.env.OPENSHIFT_NODEJS_PORT || 3000;
var app = express();
app.get('/',function(req,res){
   res.send('Hello World!!');
});
app.listen(port,ip);
console.log('Server running at http://%s:%d',ip,port);</pre></div></li><li class="listitem" value="5">Add<a id="id923" class="calibre1"/> the <code class="email">node_modules</code> directory to the <code class="email">.gitignore</code> file. We are adding the <code class="email">node_modules</code> directory to <code class="email">.gitignore</code> to allow OpenShift to download all the dependencies using npm. If you don't add <code class="email">node_modules</code> to <code class="email">.gitignore</code>, OpenShift will not download the dependencies but use dependencies from your <code class="email">node_modules</code> directory:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ echo "node_modules/" &gt; .gitignore</strong></span>
</pre></div></li><li class="listitem" value="6">Commit the code, and push the changes to the application gear:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ git add .</strong></span>
<span class="strong"><strong class="calibre7">$ git commit -am "used express"</strong></span>
<span class="strong"><strong class="calibre7">$ git push</strong></span>
</pre></div><p class="calibre14">After the application is successfully built and deployed, you will see the application running at <code class="email">http://myapp-{domain-name}.rhcloud.comhttp://myapp-{domain-name}.rhcloud.com</code>.</p></li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Managing Node.js application dependencies">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec440" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre6">Almost all real applications need to depend on third-party frameworks or libraries to do their work. In the following steps, you created a very simple Express web application.</p><p class="calibre6">In step 1, you recreated the application created in the <span class="strong"><em class="calibre10">Creating your first Node.js application</em></span> recipe. As the example application in this recipe needs to use the Express web framework, we have to declare the dependency in <code class="email">package.json</code>. In step 2, you created a minimalistic <code class="email">package.json</code> file with just the name, description, and version number. Then in step 3, you ran the <code class="email">npm install</code> command to install Express and all its transitive dependencies. All the modules will be downloaded to the <code class="email">node_modules</code> directory. The <code class="email">--save</code> option tells npm to update the <code class="email">package.json</code> file with the Express dependency.</p><p class="calibre6">In step 4, you <a id="id924" class="calibre1"/>replaced the content of <code class="email">server.js</code> with the Express application code. The code listing in step 4 does the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">You imported the Node Express module using the <code class="email">require()</code> function.</li><li class="listitem">Then, you created two variables to hold the IP address and port. If the application runs on the local machine, OpenShift's specific environment variables will not be available; hence, the IP address and port will be <code class="email">127.0.0.1</code> and 3000.</li><li class="listitem">Then, you created a new application instance by calling the <code class="email">express()</code> function.</li><li class="listitem">Now you defined a new route for the root URL. In this case, an HTTP GET request to <code class="email">/</code> will respond with <code class="email">Hello World</code>.</li><li class="listitem">Finally, you instructed the server to bind and listen on the IP and port variables for incoming connections.</li></ul></div><p class="calibre6">In step 5, you told Git to ignore the <code class="email">node_modules</code> directory by adding an entry to the <code class="email">.gitignore</code> file. The reason you did that is to allow OpenShift to download the dependencies mentioned in <code class="email">package.json</code>. This makes your Git repository light as well. If you commit the <code class="email">node_modules</code> directory, OpenShift will not download the dependencies and use the modules in the <code class="email">node_modules</code> directory. You can choose either of the two options, and OpenShift will just work. There is a lot of debate on this topic in the Node community, and different people have different opinions. You can refer to the following blog for a detailed discussion on this topic: <a class="calibre1" href="http://www.futurealoof.com/posts/nodemodules-in-git.html">http://www.futurealoof.com/posts/nodemodules-in-git.html</a>.</p><p class="calibre6">Finally, in step 6, you committed the code to the local Git repository and pushed the changes to the application gear. OpenShift will first download all the dependencies (and their transitive dependencies) mentioned in <code class="email">package.json</code>, as shown in the following code snippet, and then restart the application with updated code using the supervisor <code class="email">server.js</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">remote: npm http GET https://registry.npmjs.org/express</strong></span>
<span class="strong"><strong class="calibre7">remote: npm http 200 https://registry.npmjs.org/express</strong></span>
<span class="strong"><strong class="calibre7">remote: npm info retry fetch attempt 1 at 12:45:38</strong></span>
<span class="strong"><strong class="calibre7">remote: npm http GET https://registry.npmjs.org/express/-/express-4.3.1.tgz</strong></span>
<span class="strong"><strong class="calibre7">remote: npm http 200 https://registry.npmjs.org/express/-/express-4.3.1.tgz</strong></span>
<span class="strong"><strong class="calibre7">…</strong></span>
</pre></div></div></div>

<div class="book" title="Managing Node.js application dependencies">
<div class="book" title="There's more…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec441" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre6">In the <span class="strong"><em class="calibre10">Creating your first Node.js application</em></span> recipe, I mentioned that when you push the changes to the <a id="id925" class="calibre1"/>OpenShift application gear, OpenShift checks for the existence of the <code class="email">package.json</code> file. If the <code class="email">package.json</code> file exists, OpenShift uses the value of the main field as the primary entry point to your application. As you didn't define the main field in <code class="email">package.json</code>, OpenShift will use <code class="email">server.js</code> as the default entry point. Let's suppose you renamed the <code class="email">server.js</code> to <code class="email">app.js</code>. Then, to make this run on OpenShift, you will have to create an entry for the main field, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">{
  "name": "myapp",
  "description": "My OpenShift Node.js Application",
  "version": "0.0.1",
  "dependencies": {
    "express": "~4.3.1"
  },
  "main":"app.js"
}</pre></div></div></div>

<div class="book" title="Managing Node.js application dependencies">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch09lvl2sec442" class="calibre1"/>See also</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">The <span class="strong"><em class="calibre10">Creating your first Node.js application</em></span> recipe</li><li class="listitem">The <span class="strong"><em class="calibre10">Using the use_npm marker</em></span> recipe</li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Using the use_npm marker"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec113" class="calibre1"/>Using the use_npm marker</h1></div></div></div><p class="calibre6">OpenShift uses the node-supervisor module <a id="id926" class="calibre1"/>to run your Node apps, but you can also tell OpenShift to use the <code class="email">npm start</code> command to run the application. In this recipe, you will learn how to do that.</p></div>

<div class="book" title="Using the use_npm marker">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec443" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre6">To complete this recipe, you will need the rhc command-line client installed on your machine. Please refer to the <span class="strong"><em class="calibre10">Installing the OpenShift rhc command-line client</em></span> recipe in <a class="calibre1" title="Chapter 1. Getting Started with OpenShift" href="part0014_split_000.html#page">Chapter 1</a>, <span class="strong"><em class="calibre10">Getting Started with OpenShift</em></span>, for details. This application will consume one gear, so if you don't have an extra gear available for this recipe, use the <code class="email">rhc delete app &lt;app_name&gt; --confirm</code> command to delete an existing application. To run this application on your local machine, you will need Node installed on your machine. You can get the latest installer of Node.js for your operating system from their official website (<a class="calibre1" href="http://nodejs.org/download/">http://nodejs.org/download/</a>).</p></div></div>

<div class="book" title="Using the use_npm marker">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec444" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre6">Perform the following steps<a id="id927" class="calibre1"/> to use the <code class="email">npm start</code> command to run your applications:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Open a new command-line terminal, and recreate the application you created in the <span class="strong"><em class="calibre10">Managing Node.js application dependencies</em></span> recipe as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ rhc create-app myapp nodejs-0.10 --from-code https://github.com/OpenShift-Cookbook/chapter9-recipe3.git</strong></span>
</pre></div></li><li class="listitem" value="2">Create a marker file named <code class="email">use_npm</code> inside the <code class="email">.openshift/markers</code> directory. On the *nix machine, you can use the <code class="email">touch</code> command as shown in the following code. On Windows, you can use file explorer to create an empty file.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ cd myapp</strong></span>
<span class="strong"><strong class="calibre7">$ touch .openshift/markers/use_npm</strong></span>
</pre></div></li><li class="listitem" value="3">Commit the code, and push the changes to the application gear:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ git add .</strong></span>
<span class="strong"><strong class="calibre7">$ git commit -am "using use_npm marker"</strong></span>
<span class="strong"><strong class="calibre7">$ git push</strong></span>
</pre></div></li><li class="listitem" value="4">The <code class="email">git push</code> logs will clearly mention that the application is started using the <code class="email">npm start</code> command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">remote: *** NodeJS supervisor is disabled due to .openshift/markers/use_npm</strong></span>
<span class="strong"><strong class="calibre7">remote: *** Starting application using: npm start -d</strong></span>
</pre></div></li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Using the use_npm marker">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec445" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre6">In step 1, you created an Express framework web application that we created in the <span class="strong"><em class="calibre10">Managing Node.js application dependencies</em></span> recipe. The application just has two files—<code class="email">server.js</code> and <code class="email">package.json</code>. The <code class="email">server.js</code> file contains the application source code, and <code class="email">package.json</code> contains the application metadata and its dependencies.</p><p class="calibre6">Then, in step 2, you created a marker file, <code class="email">use_npm</code>. The presence of the <code class="email">use_npm</code> marker file tells OpenShift that you want to use the <code class="email">npm start</code> command to run the application instead of the <code class="email">node-supervisor</code> module. The <code class="email">npm start</code> command gives developers more flexibility to run their applications. It allows developers to specify their own start script in <code class="email">package.json</code>, which OpenShift will use to run their application. The <code class="email">package.json</code> is shown as follows:</p><div class="informalexample"><pre class="programlisting">{
  "name": "myapp",
  "description": "My OpenShift Node.js Application",
  "version": "0.0.1",
  "dependencies": {
    "express": "~4.3.1"
  }
}</pre></div><p class="calibre6">As you can see in the previous listing, it does not mention any start script. When there is no start script in the <code class="email">package.json</code> file, OpenShift will fall back to <code class="email">node server.js</code> as the start script:</p><div class="informalexample"><pre class="programlisting">"scripts": {"start": "node server.js"}</pre></div><p class="calibre6">This is the reason the application successfully started in step 4 after <code class="email">git push</code>.</p><p class="calibre6">Now let's suppose <a id="id928" class="calibre1"/>that you want to rename <code class="email">server.js</code> to <code class="email">app.js</code>. If you commit the source code now and push the changes, the application will fail to start. You will see the following message in the <code class="email">git push</code> logs:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">remote: *** NodeJS supervisor is disabled due to .openshift/markers/use_npm</strong></span>
<span class="strong"><strong class="calibre7">remote: *** Starting application using: npm start -d</strong></span>
<span class="strong"><strong class="calibre7">remote: Application 'myapp' failed to start 1</strong></span>
</pre></div><p class="calibre6">To make this application run again, you have to specify the start script as shown:</p><div class="informalexample"><pre class="programlisting">{
  "name": "myapp",
  "description": "My OpenShift Node.js Application",
  "version": "0.0.1",
  "dependencies": {
    "express": "~4.3.1"
  },
"scripts":{"start":"node app.js"}
}</pre></div></div></div>

<div class="book" title="Using the use_npm marker">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec446" class="calibre1"/>See also</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">The <span class="strong"><em class="calibre10">Creating and deploying Express web applications using Node.js and MongoDB cartridges</em></span> recipe</li><li class="listitem">The <span class="strong"><em class="calibre10">Managing Node.js application dependencies</em></span> recipe</li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Enabling hot deployment for Node.js applications"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec114" class="calibre1"/>Enabling hot deployment for Node.js applications</h1></div></div></div><p class="calibre6">In this recipe, you will learn how you can enable hot deployment for Node.js applications.</p></div>

<div class="book" title="Enabling hot deployment for Node.js applications">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec447" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre6">Perform the following steps to <a id="id929" class="calibre1"/>enable hot deployment for your<a id="id930" class="calibre1"/> application:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create a new Node.js application using the source code developed in the previous recipe:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ rhc app create myapp nodejs-0.10 --from-code https://github.com/OpenShift-Cookbook/chapter9-recipe3.git</strong></span>
</pre></div></li><li class="listitem" value="2">To enable hot deployment, create an empty file named <code class="email">hot_deploy</code> under the <code class="email">.openshift/markers</code> directory. This file is called the marker file, as this does not contain any content. On the *nix machine, you can use the <code class="email">touch</code> command to create the file. On Windows, you can use file explorer to create a new file. If you are not in the <code class="email">myapp</code> directory, first change directory to <code class="email">myapp</code>. Have a look at the following commands:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ cd myapp</strong></span>
<span class="strong"><strong class="calibre7">$ touch .openshift/markers/hot_deploy</strong></span>
</pre></div></li><li class="listitem" value="3">Add the file to the Git index, commit the file to the local Git repository, and then push changes to the application gear by typing the commands as shown:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ git commit -am "enabled hot deployment"</strong></span>
<span class="strong"><strong class="calibre7">$git push</strong></span>
</pre></div></li><li class="listitem" value="4">In the <code class="email">git push</code> logs, you will see a message that cartridges are not stopped because hot deployment is enabled:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">remote: Not stopping cartridge node.js because hot deploy is enabled</strong></span>
</pre></div></li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Enabling hot deployment for Node.js applications">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec448" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre6">Every time you make a change and push it to the OpenShift application gear, OpenShift first stops your gear (that is, all cartridges), copies the source code from your application Git repo to <code class="email">app-root/runtime/repo</code>, performs a build, prepares the artifact, and finally starts your gear (that is, all cartridges). This process takes time and does not suit rapid development and deployment. To enable rapid development and faster deployments, OpenShift supports hot deployment. Hot deployment means that you can deploy your changes without the need to restart all the application cartridges.</p><p class="calibre6">The presence of<a id="id931" class="calibre1"/> the <code class="email">hot_deploy</code> marker file <a id="id932" class="calibre1"/>informs OpenShift that you want to do hot deployment. Before stopping and starting the application cartridges, OpenShift checks for the existence of the <code class="email">hot_deploy</code> marker file. If the <code class="email">hot_deploy</code> marker file exists, OpenShift will not stop the cartridges, and changes will be deployed without cartridges restart. Hot deployment is ideal for development, and I recommend that you always use it during development.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note32" class="calibre1"/>Note</h3><p class="calibre6">If you set new environment variables with hot deployment enabled or install new cartridges, you have to restart the application to allow the server to pick the new environment variables.</p></div></div></div>

<div class="book" title="Enabling hot deployment for Node.js applications">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec449" class="calibre1"/>See also</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">The <span class="strong"><em class="calibre10">Creating and deploying Express web applications using Node.js and MongoDB cartridges</em></span> recipe</li><li class="listitem">The <span class="strong"><em class="calibre10">Configuring Node supervisor options</em></span> recipe</li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Creating and deploying Express web applications using Node.js and MongoDB cartridges"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec115" class="calibre1"/>Creating and deploying Express web applications using Node.js and MongoDB cartridges</h1></div></div></div><p class="calibre6">In this recipe, you will <a id="id933" class="calibre1"/>build a Node.js application from scratch using the Express web <a id="id934" class="calibre1"/>framework and MongoDB. I have chosen Express because it is very easy to use <a id="id935" class="calibre1"/>and is a popular web <a id="id936" class="calibre1"/>framework in the Node community. You can run any other web framework, such as Geddy, on OpenShift as well.</p><p class="calibre6">You will develop a job store application that will allow users to post job openings for a company. The application will be a single-page web application<a id="id937" class="calibre1"/> (<a class="calibre1" href="http://en.wikipedia.org/wiki/Single-page_application">http://en.wikipedia.org/wiki/Single-page_application</a>) built using the Backbone.js<a id="id938" class="calibre1"/> (<a class="calibre1" href="http://backbonejs.org/">http://backbonejs.org/</a>) frontend. The application can do the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">When a user goes to the <code class="email">/</code> URL of the application, the user will see a list of companies stored in the MongoDB database. Behind the scenes, the Backbone.js-based frontend will make a REST HTTP GET (<code class="email">'/api/v1/companies'</code>) call to fetch all the companies:<div class="mediaobject"><img src="../images/00105.jpeg" alt="Creating and deploying Express web applications using Node.js and MongoDB cartridges" class="calibre8"/></div><p class="calibre12"> </p></li><li class="listitem">Users can <a id="id939" class="calibre1"/>create a new company by<a id="id940" class="calibre1"/> visiting <code class="email">http://jobstore-{domain-name}.rhcloud.com/#companies/new</code> or by clicking on the <span class="strong"><strong class="calibre7">+</strong></span> icon. This will render a form where<a id="id941" class="calibre1"/> users <a id="id942" class="calibre1"/>can enter details about the new company, as shown in the following screenshot. When a user submits the form, the Backbone.js-based frontend will make an HTTP POST call to the REST backend and data related to a company is stored in MongoDB:<div class="mediaobject"><img src="../images/00106.jpeg" alt="Creating and deploying Express web applications using Node.js and MongoDB cartridges" class="calibre8"/></div><p class="calibre12"> </p></li><li class="listitem">When a user clicks on any company, they will see a list of job openings for that company. Behind the scenes, the Backbone.js-based frontend will make an HTTP GET (<code class="email">'/api/v1/companies/company_id/jobs'</code>) call to fetch all the available jobs for the selected company using its ID. Have a look at the following screenshot:<div class="mediaobject"><img src="../images/00107.jpeg" alt="Creating and deploying Express web applications using Node.js and MongoDB cartridges" class="calibre8"/></div><p class="calibre12"> </p></li><li class="listitem">Users<a id="id943" class="calibre1"/> can post new jobs for a <a id="id944" class="calibre1"/>company by <a id="id945" class="calibre1"/>clicking on <a id="id946" class="calibre1"/>the <span class="strong"><strong class="calibre7">New Job</strong></span> link. This will render a web form where users can enter their details. The Backbone.js-based frontend will make an HTTP POST call to the REST backend and data related to a job is stored in the MongoDB database:<div class="mediaobject"><img src="../images/00108.jpeg" alt="Creating and deploying Express web applications using Node.js and MongoDB cartridges" class="calibre8"/></div><p class="calibre12"> </p></li></ul></div><p class="calibre6">The source code for the application is available on GitHub at <a class="calibre1" href="https://github.com/OpenShift-Cookbook/chapter9-jobstore-nodejs-express">https://github.com/OpenShift-Cookbook/chapter9-jobstore-nodejs-express</a>.</p></div>

<div class="book" title="Creating and deploying Express web applications using Node.js and MongoDB cartridges">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec450" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre6">To complete <a id="id947" class="calibre1"/>this recipe, you will need the rhc<a id="id948" class="calibre1"/> command-line client <a id="id949" class="calibre1"/>installed on your machine. Please refer to the <span class="strong"><em class="calibre10">Installing the OpenShift rhc command-line client</em></span> recipe in <a class="calibre1" title="Chapter 1. Getting Started with OpenShift" href="part0014_split_000.html#page">Chapter 1</a>, <span class="strong"><em class="calibre10">Getting Started with OpenShift</em></span>, for details. This application will consume one gear, so if <a id="id950" class="calibre1"/>you don't have an extra gear available for this recipe, use the <code class="email">rhc delete app &lt;app_name&gt; --confirm</code> command to delete an existing application. To run this application on your local machine, you will need Node and MongoDB installed on your machine. You can get the latest installer of Node.js for your operating system from their official website (<a class="calibre1" href="http://nodejs.org/download/">http://nodejs.org/download/</a>). You can get the latest installer of MongoDB for your operating system from their official website (<a class="calibre1" href="http://www.mongodb.org/downloads">http://www.mongodb.org/downloads</a>).</p></div></div>

<div class="book" title="Creating and deploying Express web applications using Node.js and MongoDB cartridges">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec451" class="calibre1"/>How to do it…</h2></div></div></div><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Open a new command-line terminal, and navigate to a convenient location where you want to create the application. Run the command shown as follows to create the job store application:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ rhc create-app jobstore nodejs-0.10 mongodb-2.4</strong></span>
</pre></div><p class="calibre14">This command will create an application named <code class="email">jobstore</code> that uses Node.js and MongoDB cartridges.</p></li><li class="listitem" value="2">As the application will be built from scratch, we will delete the template source code generated by OpenShift. Change the directory to <code class="email">jobstore</code>, and delete the following files and directories using the <code class="email">rm</code> command on *nix machines. On Windows, you can use file explorer to delete the files and directories.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ cd jobstore</strong></span>
<span class="strong"><strong class="calibre7">$ rm -rf deplist.txt index.html node_modules/ package.json server.js</strong></span>
</pre></div><p class="calibre14">Add the <code class="email">node_modules</code> directory to the <code class="email">.gitignore</code> file by executing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ echo "node_modules/" &gt; .gitignore</strong></span>
</pre></div></li><li class="listitem" value="3">The Express team provides a project generator that you can use to create an Express template application. This generator will create an application skeleton using the latest Express version, that is, 4.2.0. It makes it easy for developers to get started with Express application development. You can install the <code class="email">express-generator</code> package globally by running the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ npm install -g express-generator</strong></span>
</pre></div><div class="note" title="Note"><h3 class="title2"><a id="note33" class="calibre1"/>Note</h3><p class="calibre6">Please make sure you install express-generator Version 4.2.0 or above. This recipe was written using express-generator Version 4.2.0. You can check the version by typing the <code class="email">express --version</code> command.</p></div></li><li class="listitem" value="4">Once the<a id="id951" class="calibre1"/> generator is installed <a id="id952" class="calibre1"/>globally, you <a id="id953" class="calibre1"/>can use <a id="id954" class="calibre1"/>the <code class="email">express</code> command-line tool to generate projects anywhere on your machine. Please make sure you are in the <code class="email">jobstore</code> directory, and create the project by running the following command: <div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ express --ejs . --force</strong></span>
</pre></div></li><li class="listitem" value="5">To run this application on your local machine, you will have to first install all the dependencies using npm:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ npm install</strong></span>
</pre></div><p class="calibre14">Now, to run the application, use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ DEBUG=jobstore ./bin/www</strong></span>
</pre></div><p class="calibre14">You can view the application in your favorite browser by visiting <code class="email">http://127.0.0.1:3000/</code>. The generated application exposes two routes as specified in <code class="email">app.js</code>:</p><div class="informalexample"><pre class="programlisting">app.use('/', routes);
app.use('/users', users);</pre></div><p class="calibre14">When a user makes a GET request to <code class="email">/</code>, the index route callback, <code class="email">routes</code>, is invoked. The <code class="email">routes</code> callback is defined in <code class="email">routes/index.js</code>. The callback renders the <code class="email">index.ejs</code> view.</p><p class="calibre14">When a user makes a HTTP GET request to '/users', the users callback function is invoked. The default implementation just writes <code class="email">respond with a resource</code> in the response body.</p></li><li class="listitem" value="6">In our single-page web application, when a user makes an HTTP GET request to the application root URL, the Backbone.js-based frontend is rendered. Replace the content of <code class="email">index.ejs</code> with <code class="email">index.js</code> in the project's GitHub repository, <a class="calibre1" href="https://github.com/OpenShift-Cookbook/chapter9-jobstore-nodejs-express/blob/master/views/index.ejs">https://github.com/OpenShift-Cookbook/chapter9-jobstore-nodejs-express/blob/master/views/index.ejs</a>. Also, copy the <code class="email">css</code> (<a class="calibre1" href="https://github.com/OpenShift-Cookbook/chapter9-jobstore-nodejs-express/tree/master/public/css">https://github.com/OpenShift-Cookbook/chapter9-jobstore-nodejs-express/tree/master/public/css</a>) and <code class="email">js</code> (<a class="calibre1" href="https://github.com/OpenShift-Cookbook/chapter9-jobstore-nodejs-express/tree/master/public/js">https://github.com/OpenShift-Cookbook/chapter9-jobstore-nodejs-express/tree/master/public/js</a>) directory from the application's GitHub repository, <a class="calibre1" href="https://github.com/OpenShift-Cookbook/chapter9-jobstore-nodejs-express">https://github.com/OpenShift-Cookbook/chapter9-jobstore-nodejs-express</a>, and place them inside the public directory.<p class="calibre14">Restart the application, and you will see the index route in action. This time it will render the application user interface.</p></li><li class="listitem" value="7">The <a id="id955" class="calibre1"/>application does not<a id="id956" class="calibre1"/> need the <code class="email">users.js</code> file <a id="id957" class="calibre1"/>in the <code class="email">routes</code> directory, so<a id="id958" class="calibre1"/> delete it. After removing <code class="email">routes/users.js</code>, remove its reference in the <code class="email">app.js</code> file. You need to remove the following two lines from the <code class="email">app.js</code> file:<div class="informalexample"><pre class="programlisting">var users = require('./routes/users');
app.use('/users', users);</pre></div></li><li class="listitem" value="8">Create a new file named <code class="email">api.js</code> inside the <code class="email">routes</code> directory. This file will house the REST backend of our application. On *nix machines, you can create a new file using the <code class="email">touch</code> command. On Windows, you can use file explorer to create the file.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ touch routes/api.js</strong></span>
</pre></div></li><li class="listitem" value="9">The application will use the MongoDB database for storing data. To work with MongoDB, you need to use a third-party library. For this application, you will use the <code class="email">mongojs</code> module. Install the module using the npm command, as shown in the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ npm install mongojs --save</strong></span>
</pre></div></li><li class="listitem" value="10">The next step is configuring the MongoDB database so that our REST API can talk with MongoDB. Place the following code in <code class="email">api.js</code>:<div class="informalexample"><pre class="programlisting">var db_name = process.env.OPENSHIFT_APP_NAME || "jobstore";
var connection_string = '127.0.0.1:27017/' + db_name;
// if OPENSHIFT env variables are present, use the available connection info:
if (process.env.OPENSHIFT_MONGODB_DB_PASSWORD) {
    connection_string = process.env.OPENSHIFT_MONGODB_DB_USERNAME + ":" +
        process.env.OPENSHIFT_MONGODB_DB_PASSWORD + "@" +
        process.env.OPENSHIFT_MONGODB_DB_HOST + ':' +
        process.env.OPENSHIFT_MONGODB_DB_PORT + '/' +
        process.env.OPENSHIFT_APP_NAME;
}
var mongojs = require("mongojs");
var db = mongojs(connection_string, ['jobstore']);
var companies = db.collection("companies");</pre></div></li><li class="listitem" value="11">As mentioned in this recipe introduction, there are two company-related operations—get all companies and store a company in the MongoDB database. These will be exposed as two routes in the <code class="email">app.js</code> file, as shown in the following commands:<div class="informalexample"><pre class="programlisting">var api = require('./routes/api');
app.get('/api/v1/companies', api.companies);
app.post('/api/v1/companies', api.saveCompany);</pre></div><p class="calibre14">When<a id="id959" class="calibre1"/> the HTTP GET <a id="id960" class="calibre1"/>request is <a id="id961" class="calibre1"/>made <a id="id962" class="calibre1"/>to <code class="email">/api/v1/companies</code>, the <code class="email">api.companies</code> callback will be called. The <code class="email">api.companies</code> callback is defined in the <code class="email">api.js </code>route file. This callback will make a <code class="email">find</code> call on the <code class="email">companies</code> collection. It will find all the companies in the MongoDB database and write them to the response object. Have a look at the following commands:</p><div class="informalexample"><pre class="programlisting">exports.companies = function (req, res, next) {
    companies.find().sort({registeredAt: -1}, function (err, companies) {
        if (err) {
            return next(err);
        }
        return res.json(companies);
    });
};</pre></div><p class="calibre14">Similarly, when the HTTP POST request is made to the <code class="email">/api/v1/companies</code> URL, the <code class="email">api.saveCompany</code> callback will be called. The <code class="email">api.saveCompany</code> callback is defined in the <code class="email">api.js</code> route file. The callback will create a <code class="email">company</code> object from the request object and then persist the <code class="email">company</code> object in the MongoDB database:</p><div class="informalexample"><pre class="programlisting">exports.saveCompany = function (req, res, next) {
    var company = {
        "name": req.body.name,
        "description": req.body.description,
        "registeredAt": new Date(),
        "contactEmail": req.body.contactEmail,
        "jobs": []
    };
    companies.save(company, function (err, saved) {
        if (err) {
            return next(err);
        }
        console.log(saved);
        res.json(saved);
    })
};</pre></div></li><li class="listitem" value="12">Next, you will<a id="id963" class="calibre1"/> write REST endpoints to <a id="id964" class="calibre1"/>store and list <a id="id965" class="calibre1"/>the jobs data. There<a id="id966" class="calibre1"/> are two REST endpoints related to jobs—listing all jobs for a company and saving a job for a company. These will be exposed as two routes in <code class="email">app.js</code>. Have a look at the following code:<div class="informalexample"><pre class="programlisting">app.get('/api/v1/companies/:companyId/jobs', api.jobsForCompany);
app.post('/api/v1/companies/:companyId/jobs', api.postJobForCompany);</pre></div><p class="calibre14">When the HTTP GET request is made to <code class="email">/api/v1/companies/:companyId/jobs</code>,  the <code class="email">jobsForCompany</code> callback will be called. This callback will find the company corresponding to <code class="email">companyId</code> and then return the jobs embedded in the array:</p><div class="informalexample"><pre class="programlisting">exports.jobsForCompany = function (req, res, next) {
    var companyId = req.param('companyId');
    companies.findOne({"_id": mongojs.ObjectId(companyId)}, function (err, company) { 
        if (err) {
            return next(err);
        }
        return res.json(company.jobs);
    });

};</pre></div><p class="calibre14">When a <a id="id967" class="calibre1"/>user makes the <a id="id968" class="calibre1"/>HTTP POST request to <code class="email">/api/v1/companies/:companyId/jobs</code>, the <code class="email">postJobForCompany</code> callback function will be <a id="id969" class="calibre1"/>called. This <a id="id970" class="calibre1"/>callback will be defined in the <code class="email">api.js</code> routes file. This route will update the company document with the embedded job document. Finally, it will return the updated company document:</p><div class="informalexample"><pre class="programlisting">exports.postJobForCompany = function (req, res, next) {
    var companyId = req.param('companyId');
    var job = {
        "title": req.body.title,
        "description": req.body.description
    }

    companies.update({"_id": mongojs.ObjectId(companyId)}, {$push: {"jobs": job}}, function (err, result) {
        if (err) {
            return next(err);
        }
        return companies.findOne({"_id": mongojs.ObjectId(companyId)}, function (err, company) {
            if (err) {
                return next(err);
            }

            return res.json(company);
        })
    })
};</pre></div></li><li class="listitem" value="13">To test the<a id="id971" class="calibre1"/> application on your local machine, start the MongoDB database server, and then restart the Node application.</li><li class="listitem" value="14">To make this application run on OpenShift, you have to update the <code class="email">bin/www </code>script:<div class="informalexample"><pre class="programlisting">#!/usr/bin/env node
var debug = require('debug')('jobstore');
var app = require('../app');
var ipaddress = process.env.OPENSHIFT_NODEJS_IP || "127.0.0.1";
var port = process.env.OPENSHIFT_NODEJS_PORT || 3000;
app.set('port', port);
app.set('ipaddress', ipaddress);
var server = app.listen(app.get('port'), app.get('ipaddress'), function() {
  debug('JobStore application running at http://%s:%d ',app.get('ipaddress'), app.get('port'));
});</pre></div><p class="calibre14">This code sets the correct IP address and port values so that the application can work on OpenShift.</p></li><li class="listitem" value="15">Add the <code class="email">node_modules</code> directory to the <code class="email">.gitignore</code> file as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ echo "node_modules/" &gt; .gitignore</strong></span>
</pre></div></li><li class="listitem" value="16">Update <a id="id972" class="calibre1"/>the <code class="email">package.json</code> <a id="id973" class="calibre1"/>main field value. This is<a id="id974" class="calibre1"/> required, because, otherwise, OpenShift will look for the <code class="email">server.js</code> file. As this application does not have a <code class="email">server.js</code> file, the application will not start. This was explained in the <span class="strong"><em class="calibre10">Creating your first Node.js application</em></span> recipe:<div class="informalexample"><pre class="programlisting">"main":"./bin/www",</pre></div></li><li class="listitem" value="17">Add the changes to the Git index, commit the code to the local Git repository, and then finally push the changes to the application gear:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ git add .</strong></span>
<span class="strong"><strong class="calibre7">$ git commit -am "jobstore app"</strong></span>
<span class="strong"><strong class="calibre7">$ git push</strong></span>
</pre></div></li><li class="listitem" value="18">After a successful build, changes will be deployed, and your application will be available at <code class="email">http://jobstore-{domain-name}.rhcloud.com</code>.</li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Creating and deploying Express web applications using Node.js and MongoDB cartridges">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec452" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre6">Let's now understand what <a id="id975" class="calibre1"/>we did in the previous steps. In step 3, you installed the<a id="id976" class="calibre1"/> <span class="strong"><strong class="calibre7">express-generator</strong></span> module. In the previous version of Express, express-generator package was part of the Express module itself. Now, in the latest versions, you will have to install express-generator separately. This recipe was written using 4.2.0. This module is installed globally using the <code class="email">-g</code> option to run the Express executable from any directory.</p><p class="calibre6">Next, in step 4, you generated the project inside the <code class="email">jobstore</code> directory using the <code class="email">express . --ejs --force</code> command. The command instructs Express to create the template in the current directory. The <code class="email">--ejs</code> option tells Express to configure the app with the <code class="email">ejs</code> template engine. Express supports almost all the template engines built for Node, but express-generator only supports <code class="email">hogan</code>, <code class="email">jade</code>, and <code class="email">ejs</code>. The <code class="email">--force</code> option instructs Express to forcefully<a id="id977" class="calibre1"/> create the project template inside <a id="id978" class="calibre1"/>a non-empty directory. If you don't use the <code class="email">--force</code> option, the generator will ask you for confirmation, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">destination is not empty, continue?</strong></span>
</pre></div><p class="calibre6">The <code class="email">express</code> command generates a folder structure suitable for the Express web development as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ ls -p</strong></span>
<span class="strong"><strong class="calibre7">app.js      bin/      package.json   public/      routes/      views/  </strong></span>
</pre></div><p class="calibre6">The <code class="email">package.json</code> file is an<a id="id979" class="calibre1"/> application descriptor file based on CommonJS (<a class="calibre1" href="http://wiki.commonjs.org/wiki/CommonJS">http://wiki.commonjs.org/wiki/CommonJS</a>). It contains application metadata and its dependencies. The <code class="email">npm install</code> command parses the dependencies mentioned in <code class="email">package.json</code> and installs them in the <code class="email">node_modules</code> directory.</p><p class="calibre6">The <code class="email">app.js</code> file configures the Express framework along with Connect middleware components. The application server startup boilerplate is defined inside the <code class="email">bin/www</code> script. This is a Node script that creates an Express web server and binds it to a 3000 port number. To run the application, you can use either the <code class="email">./bin/www</code> or <code class="email">npm start</code> command.</p><p class="calibre6">The Express command creates three other <a id="id980" class="calibre1"/>subdirectories apart from <code class="email">bin</code>—<code class="email">public</code>, <code class="email">routes</code>, and <code class="email">views</code>. The <code class="email">public</code> directory houses all the static resources of the application. The <code class="email">app.js</code> file configures the Express application to use the <code class="email">public</code> directory for static files:</p><div class="informalexample"><pre class="programlisting">app.use(express.static(path.join(__dirname, 'public')));</pre></div><p class="calibre6">In step 6, you copied the <code class="email">css</code> and <code class="email">js</code> directories from the project's GitHub repository.</p><p class="calibre6">The <code class="email">routes</code> directory has two files—<code class="email">index.js</code> and <code class="email">users.js</code>. Both these files are used by <code class="email">app.js</code>. These files define callbacks that will be invoked when the user makes requests to the <code class="email">http://jobstore-{domain-name}.rhcloud.com</code> and <code class="email">http://jobstore-{domain-name}.rhcloud.com/users</code> URLs.</p><p class="calibre6">The <code class="email">views</code> directory holds the template files that will be shown to the user. In step 6, you updated <code class="email">index.ejs</code> with the one from the project's GitHub repository. As mentioned before, the view of the application is built using Backbone.js and will not be covered as it is outside the scope of this book.</p><p class="calibre6">From steps 7 through step 12, you defined the REST backend for the application. The application exposes a REST call backed by the MongoDB database, which is consumed by the Backbone.js frontend. You created a new file named <code class="email">api.js</code> to define all the API callbacks. You installed the <code class="email">mongojs</code> package so that you can work with the MongoDB database. You defined four <a id="id981" class="calibre1"/>methods in <code class="email">api.js</code>—<code class="email">companies</code>, <code class="email">saveCompany</code>, <code class="email">jobsForCompany</code>, and <code class="email">postJobForCompany</code>. All the methods work on the MongoDB database asynchronously and write the database result to the response object.</p><p class="calibre6">In <code class="email">app.js</code>, you defined four routes for the REST endpoints. The callbacks are defined in <code class="email">api.js</code> as follows:</p><div class="informalexample"><pre class="programlisting">app.get('/api/v1/companies', api.companies);
app.post('/api/v1/companies', api.saveCompany)
app.get('/api/v1/companies/:companyId/jobs', api.jobsForCompany);
app.post('/api/v1/companies/:companyId/jobs', api.postJobForCompany);</pre></div><p class="calibre6">After writing the <a id="id982" class="calibre1"/>backend logic, you updated <a id="id983" class="calibre1"/>the <code class="email">bin/www</code> script so that it can bind and listen to the correct IP address and port when running on OpenShift.</p><p class="calibre6">Finally, you<a id="id984" class="calibre1"/> committed the code and pushed the changes to the <a id="id985" class="calibre1"/>application gear. This will download all the dependencies mentioned in the <code class="email">node_modules</code> directory and then restart the application with the updated code.</p></div></div>

<div class="book" title="Creating and deploying Express web applications using Node.js and MongoDB cartridges">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec453" class="calibre1"/>See also</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">The <span class="strong"><em class="calibre10">Creating your first Node.js application</em></span> recipe</li><li class="listitem">The <span class="strong"><em class="calibre10">Enabling hot deployment for Node.js applications</em></span> recipe</li><li class="listitem">The <span class="strong"><em class="calibre10">Working with Web Sockets</em></span> recipe</li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Working with Web Sockets"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec116" class="calibre1"/>Working with Web Sockets</h1></div></div></div><p class="calibre6">HTTP was designed to be <a id="id986" class="calibre1"/>half-duplex, which means it allows transmission of data in just one direction at a time. This makes it unsuitable for building real-time applications that need an open, persistent connection always. To overcome this limitation of HTTP, developers have created some workarounds or hacks. Some of these workarounds are polling, long polling, and streaming.</p><p class="calibre6">Web Sockets provide an asynchronous, bidirectional, full-duplex messaging implementation over a single TCP connection. In this recipe, you will learn how you can use Socket.IO and Express to create a simple echo application. The application simply reverses the message and echoes it back to the user browser.</p></div>

<div class="book" title="Working with Web Sockets">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec454" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre6">To complete this recipe, you will need the rhc command-line client installed on your machine. Please refer to the <span class="strong"><em class="calibre10">Installing the OpenShift rhc command-line client</em></span> recipe in <a class="calibre1" title="Chapter 1. Getting Started with OpenShift" href="part0014_split_000.html#page">Chapter 1</a>, <span class="strong"><em class="calibre10">Getting Started with OpenShift</em></span>, for details. This application will consume one gear, so if you don't have an extra gear available for this recipe, use the <code class="email">rhc delete app &lt;app_name&gt; --confirm</code> command to delete an existing application. To run this application on your local machine, you will need Node installed on your machine. You can get the latest installer of Node.js for your operating system from their official website (<a class="calibre1" href="http://nodejs.org/download/">http://nodejs.org/download/</a>).</p></div></div>

<div class="book" title="Working with Web Sockets">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec455" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre6">Perform the following steps to create an application that uses Web Sockets:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Open a new command-line terminal, and navigate to a convenient location where you want to create the application. Run the following command to create the application:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ rhc create-app reverseecho nodejs-0.10</strong></span>
</pre></div></li><li class="listitem" value="2">Change the directory to <code class="email">reverseecho</code>, and delete the template application source code:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ cd reverseecho</strong></span>
<span class="strong"><strong class="calibre7">$ rm -rf deplist.txt index.html node_modules/ package.json server.js</strong></span>
</pre></div><p class="calibre14">Add the <code class="email">node_modules</code> directory to the <code class="email">.gitignore</code> file by executing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ echo "node_modules/" &gt; .gitignore</strong></span>
</pre></div></li><li class="listitem" value="3">Create a <code class="email">package.json</code> file:<div class="informalexample"><pre class="programlisting">{
  "name": "reverse-echo",
  "version": "0.0.1",
  "private": true,
  "main": "server.js"
}</pre></div></li><li class="listitem" value="4">Install<a id="id987" class="calibre1"/> the <code class="email">express</code> and <code class="email">socket.io</code> modules as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ npm install express –save</strong></span>
<span class="strong"><strong class="calibre7">$ npm install socket.io --save</strong></span>
</pre></div></li><li class="listitem" value="5">Create a new file named <code class="email">server.js</code> in the app root directory and populate it with the following code:<div class="informalexample"><pre class="programlisting">var express = require("express");
var app = express();
var server = require('http').createServer(app);
var ip = process.env.OPENSHIFT_NODEJS_IP || '127.0.0.1';
var port = process.env.OPENSHIFT_NODEJS_PORT || 3000;
server.listen(port,ip);
var io = require('socket.io').listen(server);

app.get('/',function(req,res){
   res.sendfile(__dirname+'/index.html');
});
console.log('App running at http://%s:%d',ip,port);
io.sockets.on('connection', function (socket) {

   // when the client emits 'sendchat', this listens and executes
   socket.on('message', function (data) {
      io.sockets.emit('rev-message', data.split("").reverse().join(""));
   });
});</pre></div><p class="calibre14">In this code, you first created the Express server application instance. Then, you imported the Socket.IO library and started the Socket.IO server, providing it with the already-created Express server so that it can share the same TCP/IP address and port. You defined a couple of event listeners using the <code class="email">io.sockets.on()</code> function. The <code class="email">io.sockets.on()</code> function takes two arguments—the event name and a callback function. The event name can be any string, such as <code class="email">'connection'</code> and <code class="email">'message'</code>. The callback function defines work to perform when an event is received.</p></li><li class="listitem" value="6">Create<a id="id988" class="calibre1"/> <code class="email">index.html</code> in the <code class="email">app</code> root directory, and populate it with the following code. This page has one textbox where the user can enter any text and submit it to the server by pressing a button. The data is transferred to the server using Web Sockets.<div class="informalexample"><pre class="programlisting">&lt;html&gt;
&lt;head&gt;
   &lt;title&gt;ReverseEcho&lt;/title&gt;
application   &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
   &lt;link href="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.1.1/css/bootstrap.css" rel="stylesheet"&gt;
   &lt;style type="text/css"&gt;
    body {
      padding-top:60px;
      padding-bottom: 60px;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="container"&gt;
   &lt;div class="row"&gt;
      &lt;div class="col-md-6"&gt;
         &lt;input type="text" class="form-control" rows="3" id="message" placeholder="Write a message"&gt;
      &lt;input type="button" id="echobutton" value="Reverse Echo" /&gt;
      &lt;/div&gt;
      &lt;div class="col-md-6"&gt;
         &lt;p id="result"&gt;&lt;/p&gt;
      &lt;/div&gt;
   &lt;/div&gt;
&lt;/div&gt;

&lt;script src="/socket.io/socket.io.js"&gt;&lt;/script&gt;
&lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.4/jquery.min.js"&gt;&lt;/script&gt;
&lt;script&gt;
        var wsUrl;
        if(window.location.host == '127.0.0.1:3000'){
          wsUrl = window.location.protocol + "//" + window.location.host;
        }else{
          if (window.location.protocol == 'http:') {
          wsUrl = 'ws://' + window.location.host + ':8000/';
        } else {
          wsUrl = 'wss://' + window.location.host + ':8443/';
          }  
        }
        console.log('WebSockets Url : ' + wsUrl);
        var socket = io.connect(wsUrl);
        socket.on('connect', function(){
          console.log('User connected');
        });
        socket.on('rev-message', function (data) {
                $('#result').text(data);
        });
        $(function(){
                $('#echobutton').click( function() {
                        var message = $('#message').val();
                        $('#message').val('');
                        socket.emit('message', message);
                });
        });

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre14">This <a id="id989" class="calibre1"/>JavaScript code in the <code class="email">index.html</code> file opens a Web Socket connection with the backend Node server deployed on OpenShift. In OpenShift, Web Sockets are not available over standard 80 and 443 ports because of the reasons outlined in the official OpenShift blog, <a class="calibre1" href="https://www.openshift.com/blogs/paas-websockets">https://www.openshift.com/blogs/paas-websockets</a>, so you will have to use <a id="id990" class="calibre1"/>port numbers 8000 and 8443.</p></li><li class="listitem" value="7">Add the code to the Git index, commit the code to the local Git repository, and then finally push the changes to the application gear by executing the following commands:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ git add .</strong></span>
<span class="strong"><strong class="calibre7">$ git commit -am "OpenShift Node Web Socket application"</strong></span>
<span class="strong"><strong class="calibre7">$ git push</strong></span>
</pre></div></li><li class="listitem" value="8">After the <a id="id991" class="calibre1"/>code is deployed, you can see the application running at <code class="email">http://reverseecho-{domain-name}.rhcloud.com</code>. If you type <code class="email">OpenShift</code> and click on the <span class="strong"><strong class="calibre7">Reverse Echo</strong></span> button, you will see <span class="strong"><strong class="calibre7">tfihSnepO</strong></span> as the result. This is shown in the following screenshot:<div class="mediaobject"><img src="../images/00109.jpeg" alt="How to do it…" class="calibre8"/></div><p class="calibre12"> </p></li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Working with Web Sockets">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec456" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre6">In the previous steps, you built an echo server that will reverse the message sent by the user and send it back to the user. To build this application, you installed two modules —Socket.IO and Express as covered in step 3. Socket.IO provides an API abstraction over the Web Sockets and other transports for the Node.js and client-side JavaScript. It will fall back to other alternatives transparently if Web Sockets is not implemented in a web browser while keeping the same API.</p><p class="calibre6">The code listing shown in step 4 does the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">It first imports the Express library using the <code class="email">require()</code> function and then creates the server using the Express application object.</li><li class="listitem">Then, it imports the Socket.IO library and starts the Socket.IO server using the <code class="email">listen()</code> function.</li><li class="listitem">Next, you defined a route for the root URL, which will render <code class="email">index.html</code> (created in the next step).</li><li class="listitem">Lastly, you added event handlers for connection and message events. On the connection event, you will write a message in the server logs. On the message event, you will reverse the message and emit the <code class="email">rev-message</code> event. The client will listen for the <code class="email">rev-message</code> event and will render the user interface.</li></ul></div><p class="calibre6">In the listing shown in step 5, you created an <code class="email">index.html</code> file using Twitter Bootstrap styling. The script tag does the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">On page load, you connected with the Web Socket backend using the backend Web Socket URL. In OpenShift, Web Sockets are not available over standard 80 and 443 ports because of the reasons outlined in this blog, so you will have to use port numbers 8000 and 8443. You constructed the correct URL and then connected with Socket.IO backend.</li><li class="listitem">You added listeners for the <code class="email">connect</code> and <code class="email">rev-message</code> events.</li><li class="listitem">When the <code class="email">rev-message</code> event is received, you write the message in <code class="email">results div</code>.</li><li class="listitem">You added a jQuery event listener, which will emit the message event when the button is pressed. This message will be received by the Socket.IO server backend, and that will emit the <code class="email">rev-message</code> event.</li></ul></div><p class="calibre6">In step 7, you <a id="id992" class="calibre1"/>committed the code and pushed the changes to the application gear. This will download all the dependencies and restart the application with the updated code. Finally, in step 8, you tested the reverse echo functionality in your browser.</p></div></div>

<div class="book" title="Working with Web Sockets">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec457" class="calibre1"/>See also</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">The <span class="strong"><em class="calibre10">Creating and deploying Express web applications using Node.js and MongoDB cartridges</em></span> recipe</li><li class="listitem">The <span class="strong"><em class="calibre10">Creating your first Node.js application</em></span> recipe</li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Using CoffeeScript with OpenShift Node.js applications"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec117" class="calibre1"/>Using CoffeeScript with OpenShift Node.js applications</h1></div></div></div><p class="calibre6">In the last recipe of this chapter, you <a id="id993" class="calibre1"/>will learn how to use <a id="id994" class="calibre1"/>CoffeeScript with OpenShift Node.js applications. You will develop an Express web application in CoffeeScript and deploy it to OpenShift.</p></div>

<div class="book" title="Using CoffeeScript with OpenShift Node.js applications">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec458" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre6">To complete this recipe, you will need the rhc command-line client installed on your machine. Please refer to the <span class="strong"><em class="calibre10">Installing the OpenShift rhc command-line client</em></span> recipe in <a class="calibre1" title="Chapter 1. Getting Started with OpenShift" href="part0014_split_000.html#page">Chapter 1</a>, <span class="strong"><em class="calibre10">Getting Started with OpenShift</em></span>, for details. This application will consume one gear, so if you don't have an extra gear available for this recipe, use the <code class="email">rhc delete app &lt;app_name&gt; --confirm</code> command to delete an existing application. To run this application on your local machine, you will need Node installed on your machine. You can get the latest installer of Node.js for your operating system from their official website (<a class="calibre1" href="http://nodejs.org/download/">http://nodejs.org/download/</a>).</p></div></div>

<div class="book" title="Using CoffeeScript with OpenShift Node.js applications">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec459" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre6">Perform the following steps to create a CoffeeScript Express application:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Open a new command-line terminal, and navigate to a convenient location where you want to create the application. Run the following command to create the application:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ rhc create-app myapp nodejs-0.10</strong></span>
</pre></div></li><li class="listitem" value="2">Change the directory to <code class="email">myapp</code>, and delete the template application source code.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ cd myapp</strong></span>
<span class="strong"><strong class="calibre7">$ rm -rf deplist.txt index.html node_modules/ package.json server.js</strong></span>
</pre></div><p class="calibre14">Add the <code class="email">node_modules</code> directory to the <code class="email">.gitignore</code> file by executing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ echo "node_modules/" &gt; .gitignore</strong></span>
</pre></div></li><li class="listitem" value="3">Create a <code class="email">package.json</code> file to store your application metadata and dependencies as follows:<div class="informalexample"><pre class="programlisting">{
  "name": "myapp",
  "version": "0.0.1"
}</pre></div></li><li class="listitem" value="4">Install <a id="id995" class="calibre1"/>CoffeeScript and Express<a id="id996" class="calibre1"/> modules using npm as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ npm install express coffee-script --save</strong></span>
</pre></div></li><li class="listitem" value="5">Create a new file, <code class="email">app.coffee</code>, and place the following contents in it. This is the <code class="email">Hello World</code> Express web application written in CoffeeScript:<div class="informalexample"><pre class="programlisting">express = require('express')
app = express()
ip = process.env.OPENSHIFT_NODEJS_IP || '127.0.0.1'
port = process.env.OPENSHIFT_NODEJS_PORT || 3000
# App Routes
app.get '/', (request, response) -&gt;
  response.send 'Hello World!!'
 
# Listen
app.listen port,ip
console.log "Express server listening on port http://%s:%d", ip,port</pre></div></li><li class="listitem" value="6">Create the <code class="email">use_npm</code> marker file to tell OpenShift that you want to use the <code class="email">npm start</code> command to run the application:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ touch .openshift/markers/use_npm</strong></span>
</pre></div></li><li class="listitem" value="7">Update the <code class="email">package.json</code> file with the start script:<div class="informalexample"><pre class="programlisting">{
  "name": "myapp",
  "description": "My OpenShift Node.js Application",
  "version": "0.0.1",
  "dependencies": {
    "express": "~4.3.1",
    "coffee-script": "~1.7.1"
  },
  "scripts":{"start":"~/app-root/runtime/repo/node_modules/.bin/coffee app.coffee"}
}</pre></div><p class="calibre14">This start script makes use of the <code class="email">coffee</code> executable in the <code class="email">node_modules .bin</code> directory. The <code class="email">node_modules</code> directory is available inside the <code class="email">$OPENSHIFT_REPO_DIR</code> directory.</p></li><li class="listitem" value="8">Add the code to the Git index, commit the code to the local Git repository, and then finally push the changes to the application gear by executing the following commands:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ git add .</strong></span>
<span class="strong"><strong class="calibre7">$ git commit -am "OpenShift Node CoffeeScript application"</strong></span>
<span class="strong"><strong class="calibre7">$ git push</strong></span>
</pre></div></li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Using CoffeeScript with OpenShift Node.js applications">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec460" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre6">CoffeeScript is <a id="id997" class="calibre1"/>a programming language<a id="id998" class="calibre1"/> that transcompiles to JavaScript. The Python programming language inspires the CoffeeScript syntax. As a result, the code written using CoffeeScript tends to be clean and readable inspires its syntax. Many developers that do not like JavaScript syntax prefer to use CoffeeScript to build their Node applications. From steps 1 through 5, you built a <code class="email">Hello World</code> Express web application in CoffeeScript. To run the CoffeeScript code, you will need <code class="email">coffee</code> executables from the <code class="email">coffee-script</code> package. The <code class="email">coffee</code> executable is inside the <code class="email">node_modules/.bin</code> directory. </p><p class="calibre6">To run CoffeeScript applications on the local machine, you can install the <code class="email">coffee-script</code> module globally using the <code class="email">npm install coffee-script -g</code> command. This will install the <code class="email">coffee</code> executable globally, allowing you to run the <code class="email">coffee</code> command anywhere on your machine. This does not work with OpenShift. If you push the code after step 5, the supervisor will fail to start the application, as it will not be able to find the <code class="email">coffee</code> executable. The <code class="email">use_npm</code> marker can solve this problem. As explained in the <span class="strong"><em class="calibre10">Using the use_npm marker</em></span> recipe, with the <code class="email">use_npm</code> marker, you can specify your own start script. OpenShift will <a id="id999" class="calibre1"/>use the start script <a id="id1000" class="calibre1"/>in <code class="email">package.json</code> to run your application. In step 7, you defined the start script that will use the <code class="email">coffee</code> executable from the <code class="email">$OPENSHIFT_REPO_DIR/node_modules/.bin</code> directory to run the application.</p></div></div>

<div class="book" title="Using CoffeeScript with OpenShift Node.js applications">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec461" class="calibre1"/>See also</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">The <span class="strong"><em class="calibre10">Creating and deploying Express web applications using Node.js and MongoDB cartridges</em></span> recipe</li><li class="listitem">The <span class="strong"><em class="calibre10">Creating your first Node.js application</em></span> recipe</li></ul></div></div></div></body></html>