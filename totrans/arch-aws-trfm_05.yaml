- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Planning and Designing Infrastructure Projects in AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the world of cloud computing, planning and designing infrastructure projects
    are crucial steps toward achieving the desired outcome. As the cloud computing
    environment evolves, it becomes increasingly important to have a proper plan and
    design in place for your infrastructure. With the help of Terraform, an infrastructure-as-code
    tool, you can easily plan and design your infrastructure projects in **Amazon
    Web** **Services** (**AWS**).
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will provide you with the necessary knowledge to get started with
    planning and designing infrastructure projects using Terraform in AWS. We will
    discuss the basics of infrastructure project planning, designing your first Terraform
    template in AWS, understanding AWS Providers and Terraform modules, and implementing
    best practices with Terraform AWS modules. By the end of this chapter, you will
    have a solid foundation for planning and designing your infrastructure projects
    in AWS using Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Terraform infrastructure project planning basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to design your first Terraform template in AWS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding AWS Providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Terraform modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement best practices with Terraform AWS modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terraform infrastructure project planning basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As technology advances, more businesses and leaders are beginning to adopt **infrastructure
    as code** (**IaC**) to manage their IT infrastructure. With the increasing need
    for flexibility and security in software development, IaC offers a high-level
    code solution to automate the provisioning of infrastructure resources. However,
    it’s important to understand both the potential benefits and challenges that come
    with implementing IaC. In this chapter, we will explore the basics of planning
    and designing infrastructure projects in AWS using Terraform, covering important
    topics such as AWS Providers, Terraform modules, and best practices.
  prefs: []
  type: TYPE_NORMAL
- en: The speed benefits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The adoption of cloud computing has brought about IaC, which provides significant
    speed and agility benefits for deploying, modifying, and removing virtual infrastructure
    services. With IaC, teams can interact with infrastructure in a programmatic way,
    allowing for the automation of lifecycle management. In some cases, automation
    solutions can also manage non-programmatic, command-line-interface-based devices
    using IaC management.
  prefs: []
  type: TYPE_NORMAL
- en: The risk management benefits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implementing IaC in an organization can offer numerous benefits. One of the
    primary advantages is the elimination of human error that often occurs during
    manual infrastructure provisioning and configuration. By using IaC, an organization
    can greatly minimize the risks associated with human error and enhance the security
    of its infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Security, reusability, and governance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setting up an IaC pipeline is crucial for organizations seeking to realize the
    full potential of this technology. Proper setup of an IaC pipeline requires considering
    factors such as security, reusability, and governance. It’s essential to implement
    a complete continuous integration and continuous deployment pipeline that includes
    IaC, especially for applications that require frequent updates. This approach
    can significantly improve an organization’s speed to market while reducing costs.
  prefs: []
  type: TYPE_NORMAL
- en: Team skill sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When transitioning to an IaC platform, it’s essential to consider the skill
    sets of the existing staff. IaC requires a different set of development skills
    that may not be present in the current team. Neglecting to take this into account
    can result in demotivation and disengagement among the staff, particularly if
    coding isn’t a skill set that they have or are interested in acquiring. Therefore,
    it’s essential to provide training and support to help employees adapt to this
    new way of working.
  prefs: []
  type: TYPE_NORMAL
- en: The best candidates for automation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Determining which infrastructure should be treated as code is a crucial decision.
    It’s not worthwhile to automate infrastructure that will be deployed only once
    in the organization’s lifetime, but it is worth automating infrastructure that
    will be regularly deployed for new applications or services. It’s important not
    to get bogged down in automating everything; instead, make sure your IaC efforts
    provide a return on investment over traditional approaches.
  prefs: []
  type: TYPE_NORMAL
- en: The types of applications you’ll be running
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Designing the IaC template for an application is critical for its success. The
    configuration should be modularized and driven by the configuration management
    system, and the design process should take into account the application that will
    run on the infrastructure. For instance, if you are planning to deploy a database,
    the IaC design considerations will differ based on whether the application is
    transactional or for reporting purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The cost of automating too many tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the quest to improve efficiency, the general guideline is to automate any
    recurring tasks and reserve manual management for exceptional cases. This approach
    will help manage the expectations of internal stakeholders and departments effectively.
    However, it’s essential to keep a close eye on the **return on investment** (**ROI**)
    for automation, as automating every infrastructure task can lead to cost overruns.
  prefs: []
  type: TYPE_NORMAL
- en: The critical nature of the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As infrastructure is critical to the success of any business, the code used
    to manage it should be treated with the same level of importance. This includes
    having the right processes and backup procedures in place for when issues arise.
    Virtual networks, data centers, and servers require a disciplined approach to
    change management and testing, just like physical infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: The need for software expertise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Collaboration between software engineers and infrastructure engineers is crucial
    for successful IaC implementation. While infrastructure engineers are experts
    in managing and deploying infrastructure, they may lack knowledge of software
    development best practices. By embedding software engineers with the infrastructure
    team, organizations can bridge this gap and leverage the expertise of both teams
    to optimize results. Adopting an inner source model that encourages sharing and
    collaboration can further support this effort.
  prefs: []
  type: TYPE_NORMAL
- en: The impact on agility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start-ups in the rapid growth stage may not be able to prioritize implementing
    IaC, as it can result in a lack of agility. While IaC brings many benefits to
    larger organizations, smaller companies need to balance implementing the necessary
    IaC and keeping their engineers motivated to think outside the box. As a technology
    company, it is important to maintain innovation and original ideas, which can
    be hindered by overreliance on IaC.
  prefs: []
  type: TYPE_NORMAL
- en: Integration with existing infrastructure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before adopting IaC, businesses must assess the potential risks and benefits.
    Implementing IaC may come with adoption, security, and scalability challenges,
    such as integrating new frameworks with existing infrastructure. It requires a
    considerable amount of planning, time, and collaboration with other teams, including
    those responsible for security and compliance.
  prefs: []
  type: TYPE_NORMAL
- en: Goals and available resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Introducing IaC into an organization requires careful planning and consideration
    of the goals for the transition. While IaC can bring significant benefits, such
    as reduced human error and increased security, there are also potential adoption,
    security, and scalability gaps to consider. It’s essential to have a clear plan
    for integrating new frameworks with existing infrastructure and collaborating
    with other teams, including security and compliance.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, it’s crucial to be mindful of the impact on existing tech and personnel
    resources. Pushing inexperienced engineers in a new direction can create an unstable
    organization. To minimize this risk, IaC should be incorporated as part of modernization
    efforts, with a focus on upskilling engineers to handle advanced projects. By
    doing so, organizations can ensure a smoother and more effective transition to
    IaC while maximizing its potential benefits.
  prefs: []
  type: TYPE_NORMAL
- en: The long-term plan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When implementing IaC, it’s important to plan for the long term. This includes
    considering factors such as maintenance, security, and development time. It’s
    also important to have an exit plan in place, which may involve multiple paths
    depending on various scenarios. By having a solid plan in place, you can ensure
    that your investment in IaC will pay off and that you can adapt to any changes
    or challenges that arise.
  prefs: []
  type: TYPE_NORMAL
- en: Quality control and security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implementing IaC in the eDiscovery space requires a thoughtful and deliberate
    approach to avoid introducing unintended vulnerabilities. While traditional infrastructure
    deployment plans account for security holes, an IaC approach offers many benefits.
    However, to fully realize these benefits, it is essential to establish a comprehensive
    program that includes quality control and security measures. This will help ensure
    the stability and security of the infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: How to design your first Terraform template in AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designing your first Terraform template in AWS can be an intimidating task if
    you’re new to IaC. However, understanding the fundamentals and best practices
    can make the process much smoother. In this section, we will explore the key components
    of designing a Terraform template, including defining resources, understanding
    AWS Providers, and utilizing Terraform modules. We will also cover tips for implementing
    best practices with Terraform AWS modules, so you can design and deploy reliable
    and scalable infrastructure in AWS with confidence.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication with AWS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create and manage resources in AWS using Terraform, you first need to establish
    a connection between Terraform and AWS. This connection is authenticated using
    programmatic API keys, which consist of an access key and a secret key. These
    keys are used to access and manage your AWS resources through Terraform. In this
    section, we will explore some sample configurations that illustrate how to use
    API keys to provision your first infrastructure with Terraform in AWS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To start, we should go and create these access and secret keys for Terraform
    from your AWS account.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up programmatic access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Log in to the AWS Management Console, and then in the services, go to IAM,
    and perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the new user and key in the **User** **name** field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Adding user](img/B18198_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Adding user
  prefs: []
  type: TYPE_NORMAL
- en: 'Select **Attach existing policies directly** and **AdmininistratorAccess**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 5.2 – Setting permission\uFEFFs](img/B18198_05_02.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Setting permissions
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next** until you see the following screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Success screen](img/B18198_05_03.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Success screen
  prefs: []
  type: TYPE_NORMAL
- en: Complete the process and get your keys.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After generating your access key ID and secret access key in the AWS console,
    it is important to securely store these credentials. While Terraform allows for
    the access key and secret key to be hardcoded within the configuration file, this
    approach is not recommended due to security risks. Instead, it is advised to save
    these keys as environment variables or as an AWS config profile.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Set as environment variables:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To authenticate with AWS in your terminal or command line, you will need to
    run specific commands with your access and secret key.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up as an AWS config profile:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After this, you will be asked to fill in the following information that you
    have downloaded from the AWS console:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Download and install Terraform CLI
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To get started with Terraform, you can download the single-file binary and run
    it without any additional installation. The installation process is straightforward
    and can be completed by following the instructions provided on the official Terraform
    website.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once Terraform is installed, you can start creating your IaC using the Terraform
    CLI:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[https://developer.hashicorp.com/terraform/tutorials/aws-get-started/install-cli](https://developer.hashicorp.com/terraform/tutorials/aws-get-started/install-cli)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Terraform configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Terraform requires a specific file known as the Terraform configuration file
    as input. This file is written in `*.tf` extension. This example assumes that
    the AWS config profile is being used and references the default profile for authentication:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you are using the environment variables method for authentication, you can
    remove the profile line from the Provider block in your Terraform configuration
    file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A Terraform configuration file consists of several elements, known as blocks,
    including Providers, resources, and more.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here is an example of how the syntax for a Terraform configuration file block
    is formatted:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Terraform offers a wide range of `BLOCK_TYPE` options, with the primary one
    being the resource. The other blocks support building the specified resource.
    These blocks include providers, which represent providers such as AWS, Google,
    and Azure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`providers`: Specifies the name of the Provider, such as AWS, Google, and Azure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resources`: Specifies a specific resource within the Provider, such as `aws_instance`
    for AWS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`variable`: Declares input variables for the Terraform configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output`: Declares output variables that will be stored in the Terraform state
    file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`local`: Assigns a value to an expression, which can be used as a temporary
    variable within a module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`module`: A container for multiple resources that are used together'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data`: Collects data from the remote Provider and saves it as a data source'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create your first AWS infrastructure with Terraform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps to practically apply Terraform and create an EC2 instance:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory for your Terraform project and save the following code as
    a file named `main.tf`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize the directory using the `terraform` `init` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify the proposed changes by running the `terraform` `plan` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are satisfied with the changes that Terraform plans to make, execute
    `terraform apply` to commit and provision the AWS infrastructure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Step 1 – creating a template file for Terraform AWS infrastructure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To create an EC2 instance in AWS using Terraform, we first need to create a
    directory and generate a Terraform configuration file named `main.tf`. It’s important
    to ensure that no other `*.tf` files are present in the directory, as Terraform
    considers all files ending with the `.tf` extension as part of the provisioning
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can copy the following content and save it as `main.tf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To provision an AWS EC2 instance using Terraform, you need to set the required
    arguments for the `aws_instance` resource. While there are many different arguments
    available, for this example, we will only set the two required arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ami`: To launch an EC2 instance with Terraform, you need to specify the `ami`
    parameter is set to the ID of an Ubuntu 20.04 AMI in the `us-east-2` region, which
    is free to use. It’s important to note that AMI IDs are different in every AWS
    region, so if you change the region parameter to something other than `us-east-2`,
    you’ll need to manually look up the corresponding Ubuntu AMI ID for that region
    and copy it into the `ami` parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`instance_type`: The EC2 instance type determines the amount of CPU, memory,
    disk space, and networking capacity available. Each type offers different specifications,
    and the example provided uses `t2.micro`, which offers one virtual CPU and 1 GB
    of memory, and is included in the AWS Free Tier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 2 – initialize Terraform
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After saving the `main.tf` file in the newly created directory, the next step
    is to initialize Terraform. This process is similar to initializing a local repository
    using `git` `init`. The purpose of this step is to set up the Terraform environment
    and download any necessary plugins or modules. To initialize Terraform, open your
    terminal, navigate to the directory where the `main.tf` file is saved, and run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The response should be similar to the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When working with Terraform, the code for providers such as AWS, Azure, and
    GCP are not included in the Terraform binary. Therefore, when starting with new
    Terraform code, it’s essential to run the command `terraform init` to scan the
    code, identify which providers are being used, and download the corresponding
    code for them. By default, this code is downloaded into a `.terraform` folder,
    which serves as Terraform’s scratch directory. Additionally, Terraform records
    information about the downloaded Provider code into a `.terraform.lock.hcl` file.
    It’s important to note that the `init` command can be safely executed multiple
    times and is idempotent. In later chapters, we will explore further uses for the
    `init` command and `.``terraform` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – pre-validate/predict the change—a pilot run
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Running the `terraform plan -out tfplan` command will provide detailed information
    about the changes that will be made to your AWS infrastructure. The `-out` `tfplan`
    flag will save the `plan` output to a file named `tfplan`. This ensures that the
    planned changes will be applied without any modification, and what is seen during
    the planning phase will be committed. It is now time to apply the plan by running
    the `terraform apply` `tfplan` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the previous command should display the changes that Terraform
    plans to make to your AWS infrastructure. It should look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When you execute the `terraform plan` command, Terraform will provide a detailed
    output of what changes it plans to make to your AWS infrastructure. It’s a great
    way to verify the resources that will be created or destroyed and to see whether
    anything unexpected will happen.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that when making modifications to existing resources, Terraform
    may need to destroy and recreate them. In such cases, the output will mention
    that the resource is going to be destroyed. Make sure to review the output carefully
    to avoid unintended results.
  prefs: []
  type: TYPE_NORMAL
- en: The `plan` command is an essential tool for verifying your Terraform code before
    applying it to your infrastructure. The output of the command is similar to the
    output of the `diff` command in Unix, Linux, and Git. The output displays a plus
    sign (`+`) for resources that will be created, a minus sign (`-`) for resources
    that will be deleted, and a tilde sign (`~`) for resources that will be modified
    in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of the preceding output, Terraform is planning on creating a single
    EC2 instance and nothing else, which is exactly what you want. Be sure to monitor
    the last line of the output every time you run the `plan` command to ensure that
    there are no unintended results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Step 4 – apply the plan with terraform apply
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have confirmed our changes with the `terraform plan` command, we
    can move forward and execute the changes using the `terraform apply` command.
    Unlike `terraform plan`, which is a dry run, `terraform apply` makes real changes
    to our AWS infrastructure based on the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be sure to double-check the output before entering `yes` to apply the changes.
    Once you have confirmed the changes, Terraform will begin creating the infrastructure
    resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You’ll observe that the `apply` command displays the same plan output and seeks
    your confirmation on whether you wish to proceed with said plan. Although the
    `plan` command is available separately, it’s primarily useful for quick assessments
    and during code reviews. Most often, you’ll directly execute the `apply` command
    and review the plan output it presents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type `yes` and hit *Enter* to deploy the EC2 instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You have successfully deployed an EC2 instance in your AWS
    account using Terraform. To confirm this, go to the EC2 console and check that
    your instance has been provisioned.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding AWS Providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with Terraform to provision infrastructure in AWS, it’s crucial
    to understand the concept of AWS Providers. In Terraform, a Provider is responsible
    for understanding the API interactions with a particular service and exposing
    the available resources and data sources. AWS is one of the most widely used cloud
    providers, and Terraform provides a rich set of AWS Provider resources to manage
    AWS infrastructure. In this section, we’ll explore what AWS Providers are, how
    to configure and authenticate them, and best practices for working with AWS Providers
    in Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: What are AWS Providers and why are they important in Terraform?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AWS Providers are plugins that allow Terraform to interact with the AWS API
    to manage infrastructure resources in AWS. They enable Terraform to provision,
    modify, and delete AWS resources such as EC2 instances, S3 buckets, and VPCs.
    Providers are critical components of Terraform, allowing it to automate the provisioning
    of infrastructure across multiple cloud platforms and on-premises data centers.
  prefs: []
  type: TYPE_NORMAL
- en: How to configure an AWS Provider in your Terraform code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Configuring an AWS Provider in Terraform is simple and straightforward. You
    just need to specify the AWS Provider and the region you want to work within your
    Terraform code. You can also optionally set your AWS access and secret keys as
    environment variables or use an AWS credentials file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how to configure the AWS Provider in your Terraform code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we’re using the `aws` Provider and setting the region to `us-west-2`.
    This means that any AWS resources we create with Terraform will be created in
    the US west (Oregon) region.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have configured the AWS Provider in your Terraform code, you can start
    creating AWS resources using Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the different versions of the AWS Provider and their compatibility
    with Terraform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The AWS Provider for Terraform is versioned separately from Terraform itself.
    Each release of the AWS Provider includes new features, bug fixes, and compatibility
    updates for new AWS services and features. It’s important to check the compatibility
    of the AWS Provider with your version of Terraform before upgrading.
  prefs: []
  type: TYPE_NORMAL
- en: When using a version of Terraform that is not compatible with the AWS Provider,
    you may experience issues such as errors when running Terraform commands or unexpected
    behavior when deploying resources.
  prefs: []
  type: TYPE_NORMAL
- en: To check the compatibility of the AWS Provider with your version of Terraform,
    you can refer to the AWS Provider release notes or the Terraform documentation.
    In general, it’s recommended to always use the latest version of the AWS Provider
    that is compatible with your version of Terraform to take advantage of the latest
    features and bug fixes.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for working with AWS Providers in Terraform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some best practices for working with AWS Providers in Terraform:'
  prefs: []
  type: TYPE_NORMAL
- en: Keep your AWS Provider version up to date to ensure compatibility with the latest
    features and bug fixes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use separate profiles for each Terraform workspace in order to have different
    AWS credentials for different environments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use AWS IAM roles and policies to restrict access to your resources and use
    the least-privilege principle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use Terraform’s `plan` and `apply` commands to test changes before deploying
    them to production.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use modules to encapsulate and reuse Terraform code, including AWS Provider
    configurations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the principle of least configuration, and avoid configuring unnecessary
    settings in your AWS Provider block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use Terraform Cloud or Terraform Enterprise to securely store and manage your
    AWS credentials, as well as to collaborate with your team on infrastructure changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understanding Terraform modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Terraform modules are reusable, encapsulated packages of Terraform code that
    allow you to efficiently manage and organize your infrastructure. They help you
    to abstract common infrastructure patterns, reduce code duplication, and make
    it easier to maintain, update, and share your infrastructure code. In this section,
    we’ll dive into the details of Terraform modules and learn how to use them effectively
    to manage your infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: What is a Terraform module?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Terraform modules are powerful features that allow you to encapsulate a group
    of resources dedicated to one task into a collection of standard configuration
    files within a dedicated directory. This reduces the amount of code needed for
    similar infrastructure components and makes it easier to manage and reuse configuration
    code. When you run Terraform commands from a module directory, it is considered
    the root module. In fact, every Terraform configuration is part of a module. The
    following is an example of a simple set of Terraform configuration files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Terraform configuration files](img/B18198_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Terraform configuration files
  prefs: []
  type: TYPE_NORMAL
- en: If you are running Terraform commands from within the `minimal-module` directory,
    the contents of that directory are considered the root module. This means that
    the files in this directory define a single module, which could contain one or
    more resources.
  prefs: []
  type: TYPE_NORMAL
- en: Using modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with Terraform, it’s important to understand how to organize your
    code to manage complexity and reuse code across different projects. One way to
    achieve this is by using Terraform modules. A module is essentially a collection
    of configuration files in a dedicated directory that encapsulates groups of resources
    dedicated to one task, reducing the amount of code you must develop for similar
    infrastructure components. These modules can be called from other directories
    through module blocks, allowing you to reuse code across different projects. In
    this context, a module that is called by another configuration is referred to
    as a child module.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 –  Child module](img/B18198_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Child module
  prefs: []
  type: TYPE_NORMAL
- en: Local and remote modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Terraform modules can be loaded from either a local file system or a remote
    source. Remote sources supported by Terraform include the Terraform Registry,
    several version control systems, HTTP URLs, and private module registries in Terraform
    Cloud or Terraform Enterprise.
  prefs: []
  type: TYPE_NORMAL
- en: Module best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using Terraform modules is essential for creating reusable and maintainable
    infrastructure code. They provide a way to encapsulate related resources into
    a single component and can be used to share common patterns and best practices
    across teams and projects. To get the most out of modules, it is recommended to
    follow these best practices:'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to follow a naming convention while naming your Terraform Provider
    `terraform-<PROVIDER>-<NAME>`. This convention must be followed if you plan to
    publish your Provider to the Terraform Cloud or Terraform Enterprise module registries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consider using modules when designing and writing your Terraform configuration,
    even for smaller projects. Even if you are the only person working on the configuration,
    the benefits of using modules can save time and effort in the long run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To organize your code and reduce the burden of maintaining and updating your
    configuration as your infrastructure grows in complexity, it is recommended to
    use local modules. This is beneficial even if you are not using or publishing
    remote modules. Therefore, it is best to organize your configuration with modules
    from the beginning.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leverage the public Terraform Registry to discover useful modules. This will
    help you implement your configuration more efficiently and confidently, as you
    can rely on the pre-built modules to implement common infrastructure scenarios
    instead of building everything from scratch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Collaboration is a key aspect of infrastructure management, and modules enable
    teams to work together effectively to create and maintain infrastructure. To enhance
    collaboration, you can publish and share modules with your team. You can publish
    modules publicly on the Terraform Registry or privately through Terraform Cloud
    or Terraform Enterprise. Module users can then reference the published child modules
    in their root module or deploy no-code ready modules through the Terraform Cloud
    UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What problems do Terraform modules solve?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When working with Terraform, managing large and complex infrastructure can
    be a daunting task. Terraform modules provide a solution to this problem by encapsulating
    groups of resources and configurations into reusable and shareable components.
    In this section, we’ll explore the various problems that Terraform modules solve
    and how they can benefit your infrastructure management workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code repetition**: As your Terraform infrastructure grows larger, copying
    and pasting code becomes inefficient and time-consuming. When you need to create
    multiple instances of the same resource, repeating the code is not scalable. It
    leads to code repetition, which is not only time-consuming but also increases
    the chances of human error. Terraform modules solve this problem by encapsulating
    groups of resources dedicated to one task and reducing the amount of repetitive
    code you need to write.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lack of code clarity**: Copying and pasting code is not only inefficient;
    it also makes the code base difficult to maintain and understand. When working
    with large-scale infrastructure in Terraform, a modular approach can help address
    this issue. Using modules dedicated to specific tasks allows for a more organized
    and readable code base that is easier to maintain and understand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lack of compliance**: Creating a Terraform module in accordance with best
    practices ensures that the same pattern is followed whenever it is reused. Whether
    it’s for encryption, redundancy, or lifecycle policies, practices configured inside
    the module will be enforced, eliminating the need to repeat the process manually.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Human error**: Creating a group of resources from scratch or copy-pasting
    them can lead to errors such as renaming or overwriting something. Terraform modules
    provide a solution to this problem by allowing you to create a single module,
    test it, and reuse it in multiple places. This approach ensures that all elements
    are correct and consistent throughout your infrastructure. By using a single block,
    it becomes easier to check and test your code. Terraform modules also provide
    other benefits, but it’s important not to overuse them. It’s essential to find
    the right balance and maintain it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement best practices with Terraform AWS modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with AWS infrastructure, it’s important to follow best practices
    to ensure a reliable, scalable, and secure environment. Terraform AWS modules
    provide a way to implement these best practices efficiently and consistently across
    different environments. In this section, we will explore some of the best practices
    for using Terraform AWS modules and how to implement them in your infrastructure.
    We’ll cover topics such as module organization, naming conventions, versioning,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform configurations file separation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Storing all Terraform code in a single file such as `main.tf` can make it challenging
    to read and maintain the code. A better approach is to split the code across multiple
    files, each dedicated to a specific purpose or resource. This not only makes the
    code more organized but also easier to troubleshoot and update in the future:'
  prefs: []
  type: TYPE_NORMAL
- en: '`main.tf`: This file calls modules, locals, and data sources to create all
    the necessary resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`variables.tf`: Declarations of variables used in `main.tf` are included in
    this file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outputs.tf`: This file contains outputs from the resources created in `main.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`versions.tf`: This file specifies version requirements for Terraform and providers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`terraform.tfvars`: This file contains variable values and should not be used
    anywhere else'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Follow a standard module structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The standard module structure must be followed for Terraform modules:'
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended to group resources based on their shared purpose in separate
    files such as `vpc.tf`, `instances.tf`, or `s3.tf` rather than creating individual
    files for each resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that every module includes a Markdown-formatted `README.md` file containing
    essential documentation about the module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use opinionated modules to do exactly what you need
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating Terraform modules, it’s recommended to make them opinionated for
    your specific use case, unless you intend to publish them as open source or for
    general-purpose use. You can make use of existing resources, open source modules,
    or even create your own. However, be cautious about creating too many module dependencies,
    as it can become difficult to maintain and update your code.
  prefs: []
  type: TYPE_NORMAL
- en: Leverage official open source modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider using open source modules provided freely by HashiCorp and the platform you
    are using. These modules can be used as primitives by modules you create, or they
    can be used in your deployments as they come if they achieve everything you need.
    You just need to ensure you call specific versions of them so your deployments
    are consistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve seen many people who advocate forking open source modules and tweaking
    them. I’d be cautious when following that approach for three reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Forking an open source repository and changing it means you are now the maintainer
    of that module, giving yourself and other members of your team a higher workload
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Engineers are likely to be familiar with an open source module, but not your
    bespoke version of it, hence new staff enrolment would be quicker if you are using
    standard modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open source modules are generally too broad; your in-house modules should be
    opinionated for your use case to make them simpler to use and maintain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forking is sometimes mandatory; some companies such as banks require you to
    fork modules and keep them in-house, but if you do that, you should consider not
    changing them at all and just tracking the official version and updating where
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: That all being said, there may be situations when importing an official module
    and changing it may suit your needs. In that case, I recommend you strip it bare
    of all the features you don’t need and simplify it as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Also, in that case, consider using open source modules that are designed to
    be forked if you can find them. For example, Google Cloud has the cloud foundation
    fabric modules that are designed just for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Make extensive use of convention over configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your modules will be opinionated to do what you need to do; hence you should
    default as many variables as possible and only require the bare minimum for setup.
    This will help keep your deployment code clean and easy to understand and change.
    Ideally, you should only need five or six variables at most. Default everything
    else if you can.
  prefs: []
  type: TYPE_NORMAL
- en: Make modules flexible with multiple optional inputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should be able to use your modules with minimal inputs, but that doesn’t
    mean that they shouldn’t be flexible for changes. This minimizes the need to have
    to change code, and it gives you options based on different situations. That being
    said, don’t get too bogged down trying to predict every scenario under the sun;
    start by making things as simple as possible based on your use case.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to modules by version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Don’t avoid specifying the version of your modules, as that could break your
    deployments whenever you make changes to them. Consider using semantic versioning to
    update your modules.
  prefs: []
  type: TYPE_NORMAL
- en: Consider bundling modules together if they serve a common purpose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the start of a project, you may consider keeping your modules and deployments
    in the same repository and refer to them by path. As your product matures, you
    may want to move these modules to a separate repository to be able to refer to
    them by version and maintain them separately.
  prefs: []
  type: TYPE_NORMAL
- en: Having one repository per module is useful if your modules need to be maintained
    by different teams or if they are common modules used by multiple projects. However,
    if you have a set of closely related modules, consider keeping them all in one
    repository and using them as submodules.
  prefs: []
  type: TYPE_NORMAL
- en: You can still version them in this way and it is much easier to manage them.
    Remember that you can always separate the modules later in their own repositories,
    but always start with the simplest setup possible.
  prefs: []
  type: TYPE_NORMAL
- en: Consider using variable and naming validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Terraform has a relatively new feature where you can validate names with **Regular
    Expressions** (**regex**). This is very useful to avoid naming errors with your
    platform before you hit **Apply**. You could also enforce the way your resources
    are named by concatenating inputs such as labels and prefixes while validating
    each of them, keeping your platform naming consistent.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 –  Naming validation](img/B18198_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Naming validation
  prefs: []
  type: TYPE_NORMAL
- en: Use locals correctly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I’ve seen locals in situations where variables would be better suited. I find
    locals to be very useful, especially in the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: Using functions on your outputs and/or inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concatenating variables to form names of resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using conditional expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can keep locals in their own file, but I generally recommend keeping them
    in the same file, close to the code they are used for.
  prefs: []
  type: TYPE_NORMAL
- en: Keep the code in your module logically separated
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I generally advocate keeping the structure of the files standard to avoid confusion. However,
    if your module requires over 200 lines of code, not including variables, you should
    consider splitting the `main.tf` into multiple files according to what they do
    and keep all related resources and locals within that file. This makes it easier
    to modify and read than having to search through a long `main.tf` file—even if
    that file is separated with comment lines.
  prefs: []
  type: TYPE_NORMAL
- en: Separate required and optional variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To improve the readability of your code, keep required variables at the top
    and optional variables at the bottom. Separate them with a comment line in your
    `variables.tf` file.
  prefs: []
  type: TYPE_NORMAL
- en: Always have an example folder within your module folder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An example folder has two advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: It gives users an idea of how to use your module in a deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use it to test your module code before creating a new version for it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have successfully learned about Terraform modules and AWS Providers. These
    are essential tools that will help you manage and deploy your infrastructure in
    AWS using Terraform. Now that you understand how to use modules and providers,
    the next step is to make decisions for your projects in AWS Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to make decisions about the architecture,
    security, and scalability of your projects. You’ll also explore how to use best
    practices for cost optimization and how to manage your infrastructure as code.
    With these skills, you’ll be able to design and implement robust, efficient, and
    cost-effective infrastructure for your projects in AWS using Terraform. So, get
    ready to take your Terraform skills to the next level and create the best infrastructure
    for your projects in AWS.
  prefs: []
  type: TYPE_NORMAL
