- en: Introducing Lightweight Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following on from a general introduction to **Google App Engine** (**GAE**),
    we can now turn our attention to fully managed event processing. In this chapter,
    we will start working with Google Compute Engine and discover how to integrate
    serverless operational management tools in our environment. More specifically,
    coverage of event processing including Cloud Functions begins here.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will begin with a quick overview of Cloud Scheduler and Cloud Tasks,
    which are services that provide support to Google Cloud, followed by an introduction
    to Cloud Functions, after which we will develop a small application to utilize
    these services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Operational management tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud Tasks and Cloud Scheduler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to Cloud Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a Cloud Functions application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to complete the exercises in this chapter, you will require a Google
    Cloud project or a Qwiklabs account.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code files for this chapter in the GitHub repository for the
    book in the `ch03` subdirectory at [https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch03](https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch03).
  prefs: []
  type: TYPE_NORMAL
- en: While you are going through code snippets in the book, you will notice that,
    in a few instances, a few lines from the code/output have been removed and replaced
    with ellipses (`...`). The use of ellipses only serves to show relevant code/output.
    The complete code is available on GitHub at the preceding link.
  prefs: []
  type: TYPE_NORMAL
- en: Operational management tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being capable of responding to externally generated events provides a flexible
    mechanism on which to build systems that can be easily scaled and augmented. Consider
    how you might design a solution to create a thumbnail image based on the submission
    of a graphical representation. First, we need some disk storage to hold the image,
    then we need to process the image to generate a thumbnail, and then we need some
    more disk storage to keep the output.
  prefs: []
  type: TYPE_NORMAL
- en: Each stage of this activity requires a state change and response. The state
    change is a notification tied to the service call to indicate the state of the
    resource; for example, an image has been deposited, a picture has changed, or
    processing has completed.
  prefs: []
  type: TYPE_NORMAL
- en: In the example of Cloud Functions (introduced later in this chapter), an event
    triggers a new item deposit in **Google Cloud Storage** (**GCS**). The function
    is alerted by an event trigger and can then perform a series of instructions in
    reaction to this event. At the outset of these instructions, the transformed image
    (now a thumbnail) is made available to the end user.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, having been through the earlier chapters based on GAE, you will
    already have some familiarity with Cloud Tasks. It is always important to consider
    the objective before selecting a service. Taking this step will tell you whether
    the technology is appropriate for your needs.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, this section will not be a detailed exploration, as these are ancillary
    services that enable serverless workloads on Google Cloud. Instead, we will include
    an overview of the critical points to provide the context and likely use cases.
    In this way, working through this section should help intelligent decisions to
    be made regarding the appropriateness of incorporating these services. In many
    instances, there will be grey areas, as well as circumstances in which there is
    no clear choice. Thankfully, these situations will be outliers, and we can, therefore,
    generalize to a large extent on how to address these rate type of circumstances.
    Our discussion begins with Cloud Tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud Tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already reviewed the benefits of using Cloud Tasks with GAE in [Chapter
    1](75f69d9a-2ac4-4f8c-9cbf-aa8928c327cb.xhtml), *Introducing App Engine* and [Chapter
    2](ff73be02-51ed-4f9a-9181-5cd14fc8bd51.xhtml), *Developing with App Engine*.
    Many of these advantages remain when working with HTTP targets, for example, decreased
    application latency by offloading long-lived requests to a worker, or minimizing
    traffic spikes in user-facing tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed tasks on Google Cloud have their service dedicated to managing the
    execution, dispatch, and delivery of jobs. The idea here is that it is preferable
    to be able to offload, isolate, and manage HTTP requests to minimize latency.
    This asynchronous workflow is especially useful when dealing with user-facing
    applications that require responsive interfaces. The message payload request made
    for the task must include POST or PUT as the HTTP method to be processed with
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud Tasks provides several benefits beyond the advantage of asynchronously
    offloading tasks. Also, it allows the developer to configure the various properties
    associated with the transmission of data. This could include sophisticated policies
    such as the application of retries or rate limits established on any data contract
    created.
  prefs: []
  type: TYPE_NORMAL
- en: 'In brief, the following elements are vital characteristics of Cloud Tasks and
    provide a compelling reason to use this service:'
  prefs: []
  type: TYPE_NORMAL
- en: Async task offload
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configurable retry policy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configurable rate limit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deferred scheduling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decouple services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increase resilience against failure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalable and fully managed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP targets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guaranteed delivery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports several popular languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By building a queue of data elements, Cloud Tasks establishes an efficient way
    for workers to process information. Each queue is subject to rate limits, which
    determine how many tasks will be executed per queue. Due to the guaranteed delivery
    mechanism applied, there will be a retry if the response to the message published
    is not adequate for the application. In general, response codes follow HTTP norms,
    with a status code in the 2xx range indicating success.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed task queues make applications more responsive when performing async
    execution. Task queues are capable of organizing and controlling requests by exploiting
    key product features such as scheduling, de-deduplication, retry policy, and version
    redirection.
  prefs: []
  type: TYPE_NORMAL
- en: Decoupled services (for example, Cloud Tasks and Cloud Pub/Sub) allow for better
    structure and application scale, especially when working with microservices. In
    this instance, task handlers will reside in each dedicated service to enable the
    microservices to scale independently. Consequently, this control of the management
    of resource consumption ensures better load dynamics, resulting in smoother service
    access, for example, rate-limiting queues.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, when handling releases and incidents gracefully, requests can be
    paused, retried, and redirected to a new version. If you have worked with Cloud
    Pub/Sub, this decoupling may all sound very familiar. The main difference between
    the two services involves invocation. Cloud Tasks provides the publisher with
    the ability to control execution, that is, the endpoint. Conversely, Cloud Pub/Sub
    enables the subscriber to control message delivery.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about the differences between these two services, read the *Choosing
    between Cloud Tasks and Pub/Sub* documentation reference at [https://cloud.google.com/tasks/docs/comp-pub-sub](https://cloud.google.com/tasks/docs/comp-pub-sub).
  prefs: []
  type: TYPE_NORMAL
- en: Cloud Scheduler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Think of Cloud Scheduler as cron jobs for the cloud. If you are not familiar
    with cron jobs, they represent an easy way to schedule activities on a machine
    based on a schedule. Acting as a single pane of glass, Cloud Scheduler enables
    users to manage all their automation needs from a single place. Creating a Cloud
    Scheduler job only requires a few elements to be up and running.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are in a situation where you wish to automate some cloud infrastructure
    operations, then this is a perfect way to achieve that outcome. As a fully managed
    service, there is a simple interface through which you can set up and configure
    your automation needs as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Establish the frequency with which to run and trigger a task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine how Cloud Scheduler is to be invoked (that is, Pub/Sub, App Engine
    HTTP, or HTTP).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy the service and the task will be invoked automatically when the scheduled
    time occurs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consult the Cloud Scheduler console page to see the results of each invocation
    or access it via Stackdriver Logging.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cloud Scheduler provides a simple and effective way to run regular jobs on schedule.
    If you have ever needed to run things such as backups or download updates, you
    will already know how useful and powerful this application is. Being an enterprise-grade
    product, Cloud Scheduler provides what is essentially a cloud-based crontab. The
    beauty of this product is that it enables users to trigger jobs across existing
    Google Cloud target services. Having these integration targets available provides
    a highly reliable mechanism to ensure that tasks run on a schedule can support
    existing usage patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to this, Cloud Scheduler also provides some key elements that are
    covered in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: Reliable delivery guaranteed that is, delivery of at least one of the job targets
    (this does come with its own complications, where ordering data may be a concern,
    similar to using a messaging solutions such as Cloud Pub/Sub).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A wide range of service support targets such as App Engine, Cloud Pub/Sub, and
    HTTP endpoints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The retry and backoff mechanism determines a suitable retry policy for job requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration with Stackdriver Logging captures information relating to the performance
    and execution of your task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports the Unix cron formation, so your existing knowledge is transferable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So now we know all of that, we can create a quick Cloud Scheduler demonstration
    on how to use it. In the following example, Cloud Scheduler will use Cloud Pub/Sub
    to illustrate how it can interact with a defined endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first task is to create a Pub/Sub topic. A Pub/Sub topic will collate the
    messages ready for distribution based on allocated subscribers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: From the Google Cloud Console menu, select the Pub/Sub option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Pub/Sub screen, select the Create Topic menu option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the Create a topic screen, enter the Topic ID as `cron-topic`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Leave the Encryption settings at the following default option: Google-managed
    key; then select the CREATE TOPIC button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5fe7b49d-9e9c-4062-b630-a10a077d7dea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have a topic defined, we now need to establish a subscription to it.
    For any available messages, we will be able to use either the pull or push mechanism
    to access the data payload associated with the topic:'
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to create a subscription for the topic, so select the Subscriptions
    option from the left-hand menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top of the screen, select the CREATE SUBSCRIPTION option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the Subscription ID as `cron-sub`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the Topic name as `projects/<project-id>/topics/cron-topic`, replacing
    `<project-id>` with the Google Cloud project ID on your system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then select the CREATE button at the bottom of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we need to define the Cloud Scheduler that will use the Pub/Sub created
    earlier as an endpoint. Each time the Cloud Scheduler task invokes, it will send
    a payload to Pub/Sub:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the option for Cloud Scheduler (located under Tools) and choose the CREATE
    JOB option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The result should look similar to the following screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3c8d6c37-3feb-4c6b-b0f1-9f3eff03786d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Complete the fields as per the following table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **Field** | **Content** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | `cron-task` |'
  prefs: []
  type: TYPE_TB
- en: '| Description | `Demonstration of Cloud Scheduler on Google Cloud` |'
  prefs: []
  type: TYPE_TB
- en: '| Frequency | `* * * * *` |'
  prefs: []
  type: TYPE_TB
- en: '| Time zone | United Kingdom (GMT) |'
  prefs: []
  type: TYPE_TB
- en: '| Target | Pub/Sub |'
  prefs: []
  type: TYPE_TB
- en: '| Topic | cron-topic |'
  prefs: []
  type: TYPE_TB
- en: '| Payload | `Yeah Cloud Scheduler Rocks` |'
  prefs: []
  type: TYPE_TB
- en: Once you've finished filling in the preceding fields, select the CREATE button
    to add your Cloud Scheduler task to the list of active jobs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The example code will run every minute, but for the sake of brevity, press
    the RUN NOW button. From the Cloud Scheduler Jobs page, you will see the result
    category logged as successful, and it also indicates the last time the job was
    run. If you now look at the Cloud Pub/Sub queue and click on the cron-topic, under
    the View Messages option, you can pull the payload information added in Cloud
    Scheduler. Alternatively, you can use the Cloud Shell to access Pub/Sub subscriptions
    using the `gcloud` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! As you can see, Cloud Scheduler enables straightforward integration
    with Pub/Sub, App Engine, and HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discussed the means to initiate both tasks and scheduled activities,
    we can begin to consider more extensive system requirements for processing information
    with functions.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Cloud Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Cloud Functions platform provides an effective way to run single-purpose
    code in the cloud. Remember that standalone services remove the need to manage
    a server or its associated runtime. The occurrence of an event notification then
    triggers single-purpose functions. The lightweight Cloud Functions platform then
    provides the basis for event-driven serverless compute.
  prefs: []
  type: TYPE_NORMAL
- en: Building single-purpose functions that are independently called provides a highly
    available architecture for building your services. Compounding these functions
    presents an excellent way to extend cloud services. These single-purpose functions
    deliver lightweight components that, in turn, can be a more natural way to maintain
    your application. The simplicity of deployment and maintenance devoid of server
    provisioning and patch/update cycles can be an effective way to design your solution.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to connect to cloud services and interact with different interfaces
    such as webhooks, APIs, and **Internet of Things** (**IoT**) devices is desirable.
    Google has made the interface to Cloud Functions extremely simple to use; you
    can build single-purpose functions that are limited only by your imagination.
  prefs: []
  type: TYPE_NORMAL
- en: Later in the book, we will discuss how to develop code using the Functions Framework
    to create lightweight functions. The Functions Framework is an open source project
    that enables seamless compatibility across several environments (for example,
    Google Cloud Functions, Cloud Run, and Knative). For now, be aware that, when
    building functions, this approach provides an element of compatibility that enables
    you to switch between technology stacks seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The wide variety of scenarios in which a serverless compute platform deploys
    makes this an attractive offering. Often deployed as the glue between services
    and APIs, Cloud Functions establishes an extensible layer for anyone wishing to
    use Google Cloud in the following areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Real-time file processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event-driven extract, transform, and load pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serverless IoT backends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party integration via APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Typical use cases might include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The IoT**: Serverless engagement with devices to process information via
    an event stream. Cloud Functions provide a simplistic interface that can provide
    a powerful tool with which to gather and disperse batch or real-time information
    using services such as Cloud Pub/Sub.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**APIs**: HTTP triggers can design aggregated logic to respond to application
    calls. This lightweight API is perfect to abstract more complex processing in
    the event chain, such as storage or queue requirements. Building an API of this
    type can be achieved with an event-driven interface and over HTTP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To illustrate how to create a simple Cloud Functions application, in the next
    section, we will walk through the main steps of this process.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a Cloud Functions-based application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To help build our understanding of the services previously discussed, we will
    develop a small application to utilize these services. Our Cloud Function will
    present a simple web page, in which some web-based information displays the output.
    To illustrate the power of each of the functions previously discussed, each of
    the *Requirement* milestones in the following table will alter and improve the
    overall design incrementally.
  prefs: []
  type: TYPE_NORMAL
- en: Our application will be developed with Google Cloud Functions and will display
    some information on the screen. Incidentally, if you need to host something like
    a static website, this can quickly be done by using a GCS bucket. Storage buckets
    are very versatile. For more information on how to implement them, check the documentation
    at [https://cloud.google.com/storage/docs/static-website](https://cloud.google.com/storage/docs/static-website).
  prefs: []
  type: TYPE_NORMAL
- en: 'The application we will develop over the next couple of sections will be an
    RSS reader. Our high-level requirement is to present information from a particular
    site as an HTML web page. Our high-level requirements are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Ref** | **Requirement** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Develop a Cloud Function. | Deploy a single function application. |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Read content from an RSS site. | For the example, we use a BBC RSS feed.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Render data as HTML. | Present the information to be consumed as HTML.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Refresh the data. | Enable data to be refreshed on an automated schedule.
    |'
  prefs: []
  type: TYPE_TB
- en: Now that we have all our requirements in place, we can progress to building
    our first iteration of the application.
  prefs: []
  type: TYPE_NORMAL
- en: App version 1 – introducing Cloud Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we will step through the process for using Cloud Functions
    as the basis for the application. This process consists of the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a function**: Start out with a simple Cloud Function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Adding Functions Framework**: Understand how to add other libraries when
    migrating code to Cloud Shell.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Deploying the resultant code**: Learn how to deploy code from the command
    line.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Starting with Cloud Functions is made more accessible by the fact that it provides
    template code in several languages. The inclusion of this template code is beneficial
    when starting and enables developers to quickly try out the service without having
    to spend any time setting up an environment.
  prefs: []
  type: TYPE_NORMAL
- en: When working through the high-level requirements, retrieving an RSS feed from
    an external site seems like a critical activity. This task also seems like something
    that should have an existing pattern with which to achieve the desired outcome.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first development step, it is always worth doing a quick scan of the internet
    for inspiration. For the identified task, there are quite a few existing packages
    capable of accessing an RSS feed. Coming up with an initial design can help us
    to think through what we want to design:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5d49473-c813-44ba-b012-d1c966db899b.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, we can see that Cloud Functions is used to access
    the backend RSS data source. Also, users can access an HTTP endpoint to retrieve
    RSS information consumed from the backend.
  prefs: []
  type: TYPE_NORMAL
- en: The following example will use the Cloud Functions option in Google Cloud. To
    speed up the development cycle, we will use available components to build our
    application and minimize the amount of code we need to write. To handle the RSS
    feed, we will use a pre-existing package to handle all the processing. The package
    also needs to be capable of accessing elements within the RSS feed. In this example,
    I am going to use Node.js; however, feel free to use an alternative language such
    as Python or Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we will use Cloud Console to write and deploy code to Cloud
    Functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0daa268-496d-459b-96bb-a48552b30d1e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We begin by using the standard boilerplate code provided by Cloud Functions
    to create an application. Using this template will enable the creation of Cloud
    Functions together with different properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d94397ed-82c6-43ff-90d8-53ee61bf5c71.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Having selected the Cloud Functions option from Google Cloud Console and then
    opened a new Cloud Function, select Node as the runtime language to have the application
    code pre-populate with the example boilerplate code, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8430801e-6389-4d71-8ee9-0a546bec2df3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To print some arbitrary text to the console log with Cloud Functions, we can
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `index.js` file presented in the Cloud Functions template. We will
    start our application by amending the blueprint code provided by Google and add
    some code to perform the following task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we introduce the `console.log` statement, which writes
    information to the logging infrastructure. In the case of Google Cloud, this will
    be Stackdriver Logging.
  prefs: []
  type: TYPE_NORMAL
- en: To deploy the preceding code, we need to click the Create button displayed at
    the bottom of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploying this code results in a `helloRSS` message being returned as the HTTP
    response. In addition, the information will also be available under Stackdriver
    as this acts as a centralized repository for all captured logging.
  prefs: []
  type: TYPE_NORMAL
- en: To retrieve information from Stackdriver, use a filter on `resource.type = cloud_function`
    to access specific data relating to program execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 2](ff73be02-51ed-4f9a-9181-5cd14fc8bd51.xhtml), *Developing with App
    Engine*, has a section outlining the process of filtering in Stackdriver. Check
    that out if you need a reminder on how to perform this task.'
  prefs: []
  type: TYPE_NORMAL
- en: We now have a very basic function. To add to this in the next section, we will
    incorporate some external packages to render a view.
  prefs: []
  type: TYPE_NORMAL
- en: App version 2 – migrating to Cloud Shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As our code becomes more complex, we should take the opportunity to move our
    development to somewhere more convenient. By convenient, I am, of course, referring
    to the command line. Now that we have seen how to use Cloud Functions from the
    console, our next step is to use Cloud Shell on Google Cloud:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71f8f36d-9981-4694-8e2b-189bfc0e8029.png)'
  prefs: []
  type: TYPE_IMG
- en: When we use Cloud Shell, it will provide lots of helpful tips. For example,
    in the preceding screenshot, Cloud Shell is indicating that it doesn't know which
    Google Cloud project it should be associated with. To remedy this, use the `gcloud
    config set [PROJECT_ID]` command.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't know the correct `PROJECT_ID` to include, you can find this information
    on the home screen of the Google Cloud Console under the Project Info heading.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you ever get stuck on any of the application code in this book, you can
    also use the code repository version link at the beginning of each chapter. Now
    that we have Cloud Shell open, follow these steps to recreate the application
    from scratch:'
  prefs: []
  type: TYPE_NORMAL
- en: First, make a new directory for your Node code to hold your code. Let's call
    it `ch03`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Cloud Console, two code files, `index.js` and `package.json`, are deployed
    as part of our Cloud Function. The content of each can be observed in the Cloud
    Functions console. Using your favorite editor, we are going to recreate this application.
  prefs: []
  type: TYPE_NORMAL
- en: In later chapters, we will look more closely at other options for local development
    but, for now, we will focus on how to migrate our code to Cloud Shell.
  prefs: []
  type: TYPE_NORMAL
- en: In the new directory, copy the existing function code for `index.js` from the
    Cloud Functions console window and place this into a new `index.js` file located
    within the `ch03` subdirectory in Cloud Shell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do the same for the `package.json` file and you now should have two source files
    (`index.js` and `package.json`) in your `ch03` development directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In addition, we will also need to install any packages required. Let''s add
    the `functions-framework` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you take a sneaky peek at the directory, suddenly we see more than the two
    source files we created. Don't worry about that for now. The critical thing to
    mention is the inclusion of `functions-framework` in the `package.json` configuration
    file. We will cover what this is in more detail in the next chapter on Cloud Functions.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have our code nicely packaged in Cloud Shell, we can do fancy things
    such as saving it to a repository to help with version control. But we will continue
    to test that the files are working as expected, which means deploying our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s stay in the Cloud Shell, using the following command to deploy our code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You will be asked if you want to allow unauthenticated invocations; answer Yes.
    Excellent, congratulations! You have deployed a Cloud Function named `tempest`
    from the command line! At the moment it doesn't do much, but take a bow anyway.
    Next, we are going to expand the application to do something a bit more useful.
  prefs: []
  type: TYPE_NORMAL
- en: App version 3 – adding a view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our application, we want to extend the code to read an RSS feed. To build
    upon the existing code, we should incorporate a few additions to move closer to
    our application requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Display some static content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize an HTTP response to display as HTML page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To achieve this, we will perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduce an NPM peer package to perform the necessary RSS interaction. A peer
    package is a Node dependency declared in the `package.json` file. Performing a
    quick search of NPM packages shows `rss-parser` as the right choice for our requirements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An advantage of using a package is that it will include all the relevant information
    about configuration. Node establishes an automatic update of the `package.json`
    file when an install completes. By adding the RSS component, we are quickly able
    to meet the requirement to read RSS feeds with a minimal amount of code.
  prefs: []
  type: TYPE_NORMAL
- en: A good practice to adopt is to check the available source code/library. We should
    never implicitly trust packages and therefore must remain vigilant when incorporating
    third-party code into our projects. Always heed vulnerabilities and warnings displayed
    that relate to security.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the `rss-parser` page on the NPM website ([https://www.npmjs.com/package/rss-parser](https://www.npmjs.com/package/rss-parser)),
    under Versions, we can see that the most current version (at the time of writing)
    is version 3.7.2\.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the command line, we can install this package by issuing the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now by viewing the `package.json` file, we can see it has been updated to include
    the relevant package and version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now that the `package.json` file has been updated to incorporate `rss-parser`,
    in the JavaScript file, `index.js`, we will declare a new asynchronous function
    to do all the heavy lifting and retrieve the RSS code to output the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are using an asynchronous function as network calls may take a while to process;
    we don't want to incur an unnecessary delay in the UI processing of the request/response
    life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: In this new function, we first want to introduce the `rss-parser` package ([https://www.npmjs.com/package/rss-parser](https://www.npmjs.com/package/rss-parser))
    to consume the RSS data source by declaring a new object. We also add a new background
    asynchronous function to handle the parsing of the relevant RSS feed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We don't pass back this data to the original function, `helloRSS`. Instead,
    we process all network-related activity in the `asyncBBCFeed` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `index.js` as shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now update the `helloRSS` function to look like the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in Cloud Shell, deploy the updated code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the code is deployed, look at the Cloud Functions interface in the Cloud
    Console. Here we can see the application has been incremented to version 2\. Go
    ahead and trigger the function to see the result of the asynchronous call we added.
    Awesome! Some lovely headlines are retrieved from the RSS feed, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/812654c2-4f9f-472b-841f-052946ffa7d9.png)'
  prefs: []
  type: TYPE_IMG
- en: Working with external data sources will be an everyday use case, so it is essential
    to understand how to do this and also to think about crucial aspects of the associated
    design. Iterating to the second version of our application, we want to output
    HTML to our site. Again, this remains an everyday use case and, rather than developing
    additional code, we used an existing Node component to handle the processing for
    us. Introducing an asynchronous task will minimize the associated latency for
    network interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the code, the HTML remains tightly coupled with the system code,
    so that needs addressing. Before embarking on that particular challenge, it's
    time to move our code from the Cloud Console to the command line. In the next
    section, we start to work with Cloud Shell exclusively.
  prefs: []
  type: TYPE_NORMAL
- en: App version 4 – decoupling HTML output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we now know from working with Node, it means we have access to a wealth
    of packages to do cool stuff. For our application, let''s utilize a package named
    `pug` to render our HTML in a more manageable way. Decoupling the given text from
    the RSS data presents us with an opportunity to display the information in a less
    convoluted way and without having to recode significant elements of the Cloud
    Function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Cloud Shell, in line with the previous example, we need to add a new peer
    dependency to the `package.json` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Pug will enable HTML previously embedded within the JavaScript to be segregated
    into a separate file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `index.js` file, we need to add a reference to the `pug` object within
    our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we initiate a programmatic view (that is, how the page will look) when
    rendered against our HTML output using the `index.pug` file. In the `asyncBBCFeed`
    function add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to update the response object to indicate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Successful processing
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The view to be rendered, that is, `index.pug`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interpolation of values, in our case, the `feed.items` returned from the async
    call:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Finally, let's get rid of some of the boilerplate code that is no longer required
    to process the feed items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After updating the changes outlined in the preceding step, our `index.js` should
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To render a view, we now need to create a new file named `index.pug` within
    the `view` directory and add the following to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in Cloud Shell, deploy the updated code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Testing the deployed code should result in the same output as shown in the *App
    version 3 - adding a view* section previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, take note that our application complexity has significantly decreased.
    Also, we haven''t even needed to write much code. Once you have updated the application
    with the preceding code updates, take this opportunity to try another form of
    deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: From the Cloud Shell, compress the contents of the development directory into
    a ZIP file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's make a Cloud Storage bucket in your project (bucket names need to be globally
    unique, so pick one that works for you and replace `[BUCKET_ID]` with your unique
    identifier).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upload the file to your bucket.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Cloud Function interface, choose the `Create` function and select the
    ZIP file from Cloud Storage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the ZIP file from the bucket location and don't forget to change the
    **function to execute** setting—we are using a function named `helloRSS`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, select the Create option and Create a new function option for the code
    taken from the storage bucket.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are anything like me, the joy of deploying code manually will be short-lived.
    In this case, using Cloud Build will be of interest to you.
  prefs: []
  type: TYPE_NORMAL
- en: Working with event processing provides a simple and effective mechanism to set
    up an action to be taken in response to a stimulus. In the initial revision of
    our application, we introduced Cloud Functions. Working with the template code,
    we were able to adapt the system to consume an RSS feed and output the content
    to application logs.
  prefs: []
  type: TYPE_NORMAL
- en: In the example code, I used the BBC RSS feeds site as the source material because
    it has plenty of options and is a suitably stable site on which to base a demo.
    However, feel free to replace this site with one of your choosing as long as it
    adheres to the same standard specification; this should not impact the code presented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great job: working on Google Cloud provides a lot of options. In the next section,
    I will set you an optional challenge to build on all the things you have learned
    so far.'
  prefs: []
  type: TYPE_NORMAL
- en: App version 5 – extending the RSS reader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final revision of the application, I am going to set you a challenge!
    Our application can already retrieve RSS feed data and display it as HTML. However,
    it would be nice to have the ability to show even more information and perhaps
    include another feed or two.
  prefs: []
  type: TYPE_NORMAL
- en: 'By extending the requirements, we now have the following task list:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Ref** | **Requirement** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Develop a Cloud Function. | Deploy a single function application. |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Read content from an RSS site. | For example, the BBC RSS feed. |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Render data as HTML. | Present the information to be consumed as HTML.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Refresh data. | Enable data to be refreshed on an automated schedule.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Read content from an RSS site. | Find another RSS site and add it to
    the application. |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Improve the HTML layout. | Add some images to the output and add some
    more data from an RSS feed. |'
  prefs: []
  type: TYPE_TB
- en: The majority of the code should already be familiar to you but don't worry if
    it is not. The point of the challenge app is to test your understanding and build
    your confidence so you can take on increasingly complex code.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, if you find it challenging to perform this exercise, a solution can
    be found in the book repository in the `ch03/solution` subdirectory.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, do note that building an application within a single function
    can be viewed as an anti-pattern for serverless functions. An alternative approached
    might be to create a reader function for data access, and a presentation function
    for data rendering. This could lead to the state being migrated to other services
    such as Firestore (or even just saved to GCS). Also, the addition of a Cloud Scheduled
    job might be used to refresh the data. The refreshed data might then be stored
    in the backend, such as on Firestore. We could then use a trigger on write for
    an event-driven function to render the updated HTML, possibly even writing the
    data to GCS or some other cache. With this approach serving thousands of frontend
    requests without the slow-down associated with getting the RSS feed, we've decoupled
    our workload into small and easy-to-understand code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, you will have realized that building solutions on Google
    Cloud does not require a vast amount of knowledge to get to a **minimum viable
    product** (**MVP**). Investing time to be able to iterate over numerous revisions
    quickly is worthwhile and can lead to significant improvements in the overall
    design.
  prefs: []
  type: TYPE_NORMAL
- en: Through this chapter, you should now have an appreciation of the nature of the
    services available. You will find it much easier to think about combining different
    products, almost like building blocks. In this regard, it is imperative, at the
    outset, to have a clear view of how the end solution should look. Taking the opportunity
    to build lightweight functions, as opposed to a monolith, can generally simplify
    the overall design; however, be sure that this is what your solution requires.
    As you will now be aware, there are many situations in which serverless event
    processing can be beneficial.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes our initial overview of the three event processing services for
    serverless workloads. The versatility of the functions discussed fulfills a wide
    variety of use cases. When looking to design an application using these services,
    it is worth considering the desired use. Design iteration is a good thing and
    should bring about better efficiencies in your application. As we move on to more
    complex systems, having a working knowledge of the appropriate use cases and associated
    design patterns will make building systems feel more natural. In the next chapter,
    we will be turning our attention specifically to Cloud Functions. There is lots
    more to cover in terms of usage, and we also need to discuss trigger events that
    make them so useful.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Does Cloud Tasks support rate limiting? (True or False)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe deferred scheduling for Cloud Tasks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does Cloud Scheduler support a retry and backoff mechanism? (True or False)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does Cloud Scheduler operate in a similar way to cron? (True or False)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What trigger do we use to deploy an HTTP endpoint?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where does Cloud Functions send its logs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What command enables Cloud Functions to be deployed from the command line?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the entry point for Cloud Functions and why is it important?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Choosing between Cloud Tasks and Pub/Sub**: [https://cloud.google.com/tasks/docs/comp-pub-sub](https://cloud.google.com/tasks/docs/comp-pub-sub)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Static website examples and tips**: [https://cloud.google.com/storage/docs/static-website](https://cloud.google.com/storage/docs/static-website)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The NPM pug package**: [https://www.npmjs.com/package/pug](https://www.npmjs.com/package/pug)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distributed computing**: [https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
