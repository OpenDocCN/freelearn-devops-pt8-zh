- en: Building a PDF Conversion Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we have discussed the relative merits of working with
    serverless computing on Google Cloud. Over the course of this chapter and the
    next, we will look at a case study to explore how a solution might be deployed.
    Working through the examples will illustrate how to use many of the techniques
    we've previously discussed.
  prefs: []
  type: TYPE_NORMAL
- en: In order to do this, we will use an example case study based on Pet Theory,
    a hypothetical veterinary practice that is making the transition to using serverless
    technology on Google Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over the course of this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing a document service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a document service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a Cloud Run service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing service access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the document access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete the exercises in this chapter, you will require a Google Cloud project
    or a Qwiklabs account.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code files of this chapter in the GitHub repository for this
    book, under the `ch11` subdirectory, at [https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch11](https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch11).
  prefs: []
  type: TYPE_NORMAL
- en: While you are going through the code snippets in this book, you will notice
    that, in a few instances, a few lines from the codes/outputs have been removed
    and replaced with ellipses (`...`). The use of ellipses is only to show relevant
    code/output. The complete code is available on GitHub at the link mentioned previously.
  prefs: []
  type: TYPE_NORMAL
- en: Pet Theory case study overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our case study, we will be exploring the Pet Theory veterinary practice.
    In this scenario, the business is looking to transition to serverless technology
    and provide some practical methods to incorporate Google Cloud and its products
    within the business.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full Pet Theory case study incorporates a number of different scenarios
    that demonstrate how to resolve typical real-world issues with serverless technology.
    To view the complete scenario, visit the Qwiklabs site and search for *Serverless
    Workshop: Pet Theory Quest* ([https://www.qwiklabs.com/quests/98](https://www.qwiklabs.com/quests/98))
    to see the associated labs.'
  prefs: []
  type: TYPE_NORMAL
- en: Over the course of this chapter and the next, we will be working through two
    lab examples that illustrate the power and flexibility of serverless technologies.
    In the first example in this chapter, we will look at how Pet Theory deals with
    moving to a unified document process based on the automatic conversion of documents.
    To begin our review, we will outline what the proposed architecture is attempting
    to achieve and the component roles and requirements involved.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a document service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pet Theory has an issue with its existing process for document management. Currently,
    they use multiple document formats within the business and want to rationalize
    this to use a single unified approach. After some consultation, they decided to
    transition to **Portable Document Format** (**PDF**) so that they could continue
    to use rich media when sending information electronically to their clients and
    suppliers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of requirements, the Pet Theory team have decided they need a system
    capable of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Requirement** | **Component** |'
  prefs: []
  type: TYPE_TB
- en: '| Storing document information | Storage |'
  prefs: []
  type: TYPE_TB
- en: '| Handling processing requests | Processing |'
  prefs: []
  type: TYPE_TB
- en: '| Securing service access | Security |'
  prefs: []
  type: TYPE_TB
- en: '| Processing document conversions | Service |'
  prefs: []
  type: TYPE_TB
- en: Now we have the high-level requirements for the application, we should add to
    our understanding by describing each requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Storing document information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the preceding information, we know that storage is a key component in our
    architecture, as the documents will need to be stored somewhere. We also know
    that Google Cloud has a number of products that would suit this type of requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, the obvious choice for storage is to use a disk or shared filesystem
    to persist the data to be processed. However, in this instance, this type of storage
    may not be the best option for the situation presented. The general remit is to
    minimize the maintenance of the infrastructure required, and creating a traditional
    database on managed infrastructure would not meet this requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Thinking about what we have learned regarding Google Cloud Storage, we know
    that short-term object storage can be used for transient information. We also
    know that Cloud Storage provides an event framework that supports interaction
    with serverless computing. On that basis, Cloud Storage seems like a good candidate
    that is capable of meeting our storage requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Handling processing requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Processing requests can be handled in a number of ways. In this example, we
    are going to build a solution that can scale on demand. To that end, we want to
    decouple the storage requirement from the processing component, meaning we need
    to add some middleware capable of efficiently handling the information.
  prefs: []
  type: TYPE_NORMAL
- en: In our application, we have already decided to utilize Cloud Storage and therefore
    we will need a mechanism to asynchronously communicate this service with the backend
    processing to be performed. The application needs to work autonomously as much
    as possible to minimize both user interaction and the potential for errors.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Cloud Pub/Sub to the application enables the application to define a
    consistent and scalable messaging service. The service can consume information
    from Cloud Storage and propagate this information to the component performing
    the backend processing. At this point, you may be thinking that Cloud Tasks would
    be a good alternative for this solution. However, the use case for Cloud Tasks
    states that it is better suited to a scenario where control of execution timing
    (that is, rate-limiting) is required. In our scenario, we do not need that level
    of control over execution. We have a need for general data ingestion and distribution
    for which the Cloud Pub/Sub product is better suited.
  prefs: []
  type: TYPE_NORMAL
- en: When using Cloud Pub/Sub, we will need to provide information relating to a
    topic that provides the information to be transported. In our application, this
    will contain information relating to the file that's uploaded to the Cloud Storage
    bucket. To consume information relating to a topic, we will also create a subscription
    that will receive an event notification based on a new message being added to
    the topic.
  prefs: []
  type: TYPE_NORMAL
- en: Securing service access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As part of our requirements, we also need to implement security permissions
    for service access to ensure that only authorized accounts can invoke the new
    service. Our assumption with this service is that we can use an account to manage
    the necessary permissions. Over the course of the chapters relating to Cloud Functions
    and Cloud Run, we have seen how valuable these service accounts are for non-interactive
    solutions. To achieve this requirement, we can use service accounts that will
    be allocated the necessary permissions associated with the appropriate roles.
  prefs: []
  type: TYPE_NORMAL
- en: Processing document conversations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to select a service capable of performing the document conversion,
    take a moment to recap the relative merits of the serverless options available
    on Google Cloud:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Product** | **Scenario** | **Typical use case** |'
  prefs: []
  type: TYPE_TB
- en: '| App Engine | Serverless HTTP applications | Web applications |'
  prefs: []
  type: TYPE_TB
- en: '| Cloud Functions | Serverless functions and events | Event-driven functions
    |'
  prefs: []
  type: TYPE_TB
- en: '| Cloud Run | Serverless HTTP containers | Fully managed HTTP request-response
    containers |'
  prefs: []
  type: TYPE_TB
- en: 'In addition to the original requirements, the Pet Theory team want to be able
    to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Process information in a scalable manner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leverage existing code/application where practical
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimize application maintenance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize in-house knowledge and skills as much as possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A team member has identified that the LibreOffice application can handle the
    conversion of documents to PDF. Packaging this application as a Docker image will
    allow the team to easily reuse and standardize the integration within their project.
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding paragraphs, it seems that Cloud Run is a good fit for the
    current requirements. As we have learned, Cloud Run supports stateless HTTP and
    custom libraries. Furthermore, the established integration with services such
    as Cloud Pub/Sub means this is perfect for our proposed solution. Once the initial
    build has been tested and verified, the solution can be further enhanced by utilizing
    Google Developer tools such as Cloud Build to achieve continuous integration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Awesome job! We have walked through a high-level analysis of requirements,
    broken it down into components, and now have the essence of a solution. To confirm
    our understanding, the following diagram covers the solution we have designed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b86663ee-371e-4ded-a94e-a1f1dfd66bdf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this diagram, we have defined three distinct stages to be run on Google
    Cloud that represent the components we previously defined in order to manage our
    document processing. Our architecture can be described by the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: A source document uploads to system storage (that is, a Cloud Storage bucket).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A life cycle event is triggered and generates a new payload for the Pub/Sub
    topic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A Pub/Sub subscription polls for new data notifications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A Cloud Run service processes the uploaded content and creates a PDF.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that in the preceding diagram, the main boxes are general abstractions
    to indicate service isolation. For our simple service, this should help clarify
    each stage of processing and the responsible component. In addition, we can also
    see that the majority of processing does not require the creation of code to handle
    storage event notifications and the message queue data objects. Our efforts are
    largely focused on the creation of the service for which we have sensibly opted
    for a preexisting application to handle the PDF conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Based on this discussion, we now have a general understanding of the PDF creation
    process for documents that are submitted to our service. In the next section,
    we will start to look at the practical elements of developing the PDF service
    in order to fulfill the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a document service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we outlined an architecture for our serverless application.
    During this analysis phase, we worked out the high-level components required and
    then theorized on the type of activities required. Creating a document service
    requires the creation of a Cloud Run service to consume information from a Cloud
    Pub/Sub subscription. As we have chosen to minimize the code development process,
    our productivity has been significantly increased. Code for complex notifications
    and message queues has been deferred to existing mechanisms managed by Google
    Cloud. Instead, we will concentrate on building only the specific element needed
    for our requirements, for example, PDF conversion.
  prefs: []
  type: TYPE_NORMAL
- en: In your Google Cloud project, open Cloud Shell and make sure a clone of the
    lab repository for `Chap11` is available.
  prefs: []
  type: TYPE_NORMAL
- en: Storing document information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get the project started, we need to create the storage for the application.
    In the following diagram, we can see that the solution uses two storage buckets.
    The first bucket stores document uploads while the second stores the output, that
    is, the processed PDF file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0a3ed35-cc7d-43a5-b518-aa6f7c3a9d14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Creating storage buckets on Google Cloud is straightforward, and at this point
    should be a familiar activity, whether it''s performed from the console or Cloud
    Shell. For this example, we will use Cloud Shell to complete the task:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a multi-region storage bucket for uploaded files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a multi-region storage bucket for processed files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Google Cloud Storage provides the ability to enable a notification event linked
    to Pub/Sub. The event notification system is extremely powerful and will be used
    to raise a new message for each document that's deposited in the upload bucket.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following architecture diagram, which shows that we automatically
    receive a notification when data is added to the upload bucket. Linking Cloud
    Storage and Cloud Pub/Sub together in this way provides a sensible usage pattern
    that can be used in other projects to indicate the availability of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/535fa8df-7e39-4a46-8162-bb332025837c.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, whenever a file is deposited in the upload bucket, a new Pub/Sub topic
    message will be queued, indicating that new content has been made available.
  prefs: []
  type: TYPE_NORMAL
- en: To set up the notification mechanism on the existing bucket, we use the `gsutil`
    command. The command will need to know what notification is to be triggered and
    also that a new topic is to be created for the upload bucket.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Pub/Sub topic notification called `new-doc` when a file is added to
    the upload bucket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, we use the `OBJECT_FINALIZE` command, which indicates
    a new object being presented to a Google Cloud Storage bucket. Take note that
    the information generated uses the JSON format to pass information to the `new-doc`
    topic.
  prefs: []
  type: TYPE_NORMAL
- en: We will only receive a notification about the file that's been uploaded after
    deploying the PDF service (as there is no active subscription for this new topic).
  prefs: []
  type: TYPE_NORMAL
- en: Great work! We now have the data storage and stream processing services up and
    running. Next, we will see how to build a PDF service using Cloud Run.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a Cloud Run service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a service can be both daunting and challenging. In this section, we
    will walk through an example of how to build a service based on an existing application.
    In this instance, we will be using LibreOffice to create a PDF.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to mention about this example is how an external application can easily
    be integrated to build a simple service. Applications (specifically Linux) encompass
    a lot of versatility, which means they typically offer a great way to extend and
    incorporate these within a solution. For example, Inkscape can be used to convert
    SVG into PNG, while Calibre can convert EPUB into PDF. The bottom line, before
    going down the route of developing an application, is to investigate what is possible
    using already-existing applications.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to the creation of our service, to build our application, we will
    encapsulate LibreOffice in a Docker image. The information for the service is
    provided through a Cloud Pub/Sub subscription that encapsulates the Cloud Storage
    notification event.
  prefs: []
  type: TYPE_NORMAL
- en: Our application will be built using Node.js and will demonstrate how to access
    the message queue information. Although the code base is relatively short, it
    demonstrates how to integrate external applications with Cloud Run. Remember when
    exploring alternative applications that Cloud Run applications are meant to be
    stateless, as well as utilize HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: The document service receives HTTP through the subscription interface to Cloud
    Pub/Sub, which means this provides a straightforward mechanism to exchange data
    between products. Additionally, state information is not required for the request-response
    life cycle associated with the data exchange. Processing the file with LibreOffice
    will, however, use the `/tmp` directory allocated to Cloud Run to temporarily
    hold information on the output file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable Cloud Run to perform document conversions, we are going to consume
    notification messages derived from Cloud Storage, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc539cab-8e33-4ab6-8531-3d0cfcede04b.png)'
  prefs: []
  type: TYPE_IMG
- en: Building the Cloud Run service incorporates a Node.js application to process
    the information, as well as the creation of a Docker container. As in previous
    examples, we start with the `package.json` file and install packages to enable
    access to additional resources (for example, Cloud Storage and Express.js).
  prefs: []
  type: TYPE_NORMAL
- en: Developing the service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need to populate our configuration files with the correct information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Amend the `package.json` file to add a `start` script, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the packages used by the conversion process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `index.js` file to add the required references and additional code.
    Add the following package requirements to the top of the code file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the existing `app.post` function with the code outlined, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `downloadFile` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The next function is where the magic happens in our program. From the following
    code snippet, we can see that LibreOffice is called in a headless state (that
    is, with no graphical interface) to generate a PDF. The resultant file is stored
    in the `/tmp` directory for postprocessing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `convertFile` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `deleteFile` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `uploadFile` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Nice work! We now have an application capable of generating a PDF from an object
    passed to it. The next step is to create a Docker image that will run the application
    when the container is run.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a Dockerfile manifest for the application, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the definition to install the `libreoffice` package to the Dockerfile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'From the command line, build the service, create an image from the manifest,
    and store it in `gcr.io`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the build process has successfully completed, deploy the service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding properties for Cloud Run provide an overview of the key attributes
    associated with a typical deployment. We have increased the memory allocated for
    Cloud Run as the conversion process is memory intensive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new environment variable to hold the `SERVICE_URL` parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We now have an image built and stored in Google Cloud. The image is maintained
    in the Container Registry and the artifact can be deployed with additional properties
    to specify additional memory and the region in which it will be run. Notably,
    when the instance is run, we need to specify an environment variable that names
    the bucket that data will be output to.
  prefs: []
  type: TYPE_NORMAL
- en: As the final step for this build and deployment section, we capture the service
    URL assigned to the deployed Cloud Run instance. Capturing the service URL enables
    the user to access the service via an environment variable. We will use this environment
    variable later on in this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations – there now exists a service on Google Cloud capable of automatically
    creating a PDF based on an uploaded file.
  prefs: []
  type: TYPE_NORMAL
- en: Securing service access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the service enabled successfully, we will turn our attention to securing
    access. To achieve this, we will be creating a new service account with the specific
    task of managing the invocation of the new service.
  prefs: []
  type: TYPE_NORMAL
- en: Thinking back to the original design, the service is actually invoked by Cloud
    Pub/Sub rather than a user. As we have chained together a series of events, we
    can take advantage of this to minimize the external sources that are able to initiate
    our new service. The following steps illustrate how to create a service account
    tasked with the invocation of a new Cloud Run PDF service instance.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a service account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a service account, follow these simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new service account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Give the service account permission to invoke Cloud Run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an environment variable to hold the `PROJECT_ID`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Allow the project to create Cloud Pub/Sub authentication tokens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations – using a service account to manage resources follows best practice
    guidelines laid out by Google Cloud. Following these simple steps ensures that
    the identity and access permissions are limited to only the service account requiring
    access.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a backend service constrained to a service account invocation,
    we can set up the message queue to process requests.
  prefs: []
  type: TYPE_NORMAL
- en: Handling processing requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final development task is to add a subscription to the solution. The subscription
    is used to consume information from the selected topic on Cloud Pub/Sub. A simple
    mechanism such as this allows information to be channeled between different services
    with minimal effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, we bind the push endpoint for Pub/Sub to the `SERVICE_URL`
    and tie the invocation of the function to the service account we created earlier.
    Fortunately, initiating a processing request like this is straightforward on Google
    Cloud:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d89a5e0a-b664-4d6d-8ead-71b14f0788a1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To initiate a subscription on an existing Cloud Pub/Sub topic, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Pub/Sub subscription bound to the `SERVICE_URL`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that a subscription has been declared, the information that''s passed to
    the `new-doc` topic will be automatically pushed to the subscriber by Cloud Pub/Sub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The message object indicates both a subscription and message. A subscription
    key/value pair defines the project and subscription ID to be used in the message
    queue. Additionally, a message object that details the key/value pairs for the
    attributes, data, and message ID allocated to the data to be sent.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, once the message/data has been successfully retrieved,
    the endpoint will use base64 to decode the message passed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both the `PROJECT_ID` and `SUBSCRIPTION_ID` values need to be valid for the
    Google Cloud project being used.
  prefs: []
  type: TYPE_NORMAL
- en: In case you are wondering, the data value displayed in the preceding example
    is a base64-encoded message. To encode a message, use the base64 application;
    for example, `echo "Welcome to Google Cloud Serverless" | base64`.
  prefs: []
  type: TYPE_NORMAL
- en: To decode a message, add `-d` to the application command line; for example,
    `echo "V2VsY29tZSB0byBHb29nbGUgQ2xvdWQgU2VydmVybGVzcwo=" | base64 -d`
  prefs: []
  type: TYPE_NORMAL
- en: The HTTPS request will be passed to the predefined endpoint and acknowledged
    on receipt. If the object passed is not acknowledged as successful, a retry mechanism
    will be employed, indicating the message needs to be resent. The retry process
    will be marshaled by a default acknowledgment deadline, which means the endpoint
    needs to respond before this timeout is in effect.
  prefs: []
  type: TYPE_NORMAL
- en: When working with Cloud Pub/Sub, it is useful to note that Google Cloud serverless
    systems (that is, App Engine, Cloud Functions, and Cloud Run) use the push mechanism.
    As flow control is automatically established, the client only needs to indicate
    success/failure on message processing.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations—the create-a-PDF service has now been designed and developed
    using Google Cloud serverless technologies. That concludes the development phase,
    and we can now progress to testing our new service.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the document service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the service has been successfully configured, we can commence testing
    the service. Before we begin that activity, let''s take a moment to view the service
    architecture that has been built:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b6781b2-fc94-4b6b-8850-1ce5044cb2a7.png)'
  prefs: []
  type: TYPE_IMG
- en: Despite the simplicity of our service, the constituent components remove much
    of the complexity associated with processing information. The use of Cloud Storage
    negates the need to work with a database and provides an effective event notification
    system for content changes that are made to the storage.
  prefs: []
  type: TYPE_NORMAL
- en: Once the data has been uploaded, the event notification generates a new Cloud
    Pub/Sub message containing relevant information on the file uploaded. Again, we
    are not required to do any processing to achieve this result. The Topic/Subscription
    mechanism provides all the message-processing capability required.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the message that a new file has been uploaded reaches our PDF backend
    service. This is the point at which we see the inclusion of the image we built
    earlier. When Cloud Run executes, it receives the payload from Cloud Pub/Sub before
    seamlessly processing the information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why was it worth recounting what we did? Well, it should indicate how little
    we actually need to test in terms of the end-to-end process we''ve defined. Basically,
    we need to confirm the following:'
  prefs: []
  type: TYPE_NORMAL
- en: That the Storage Service uses a managed activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That the Stream Processing Service uses a managed activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That the PDF Service is based on our code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, how and what would we test with the PDF service?
  prefs: []
  type: TYPE_NORMAL
- en: Basic testing of the service can be performed by checking the service is online
    and by adding documents to the specified upload bucket.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the PDF service is active, we will use the cURL program to retrieve
    an authorization token:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, test that the service has been deployed successfully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know the service is online, we can begin to test the service. Remember,
    we have added a Pub/Sub notification event to our upload storage. Once data is
    added, the message queue will be updated and send a request to the service to
    transform the data file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test the conversion process by uploading some public Qwiklabs example files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To confirm the files have been processed, check the processed Cloud Storage
    bucket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d4911469-6b9b-44c6-9698-3034dc9f6a47.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you will note that the original files have now
    been transformed into PDFs. Take a moment to also check the original upload folder
    on Cloud Storage and notice that the upload folder is now empty. What happened
    to all those files that were uploaded? Well, the application includes a hygiene
    element that also helpfully removes the files once they've successfully processed.
    Therefore, the upload folder only contains files that have not been converted.
  prefs: []
  type: TYPE_NORMAL
- en: There was a lot of work involved in this scenario; however, none of the techniques
    presented should be unfamiliar now that you've worked through the various chapters
    in this book. Congratulations on successfully creating the PDF service – learning
    how to build the components services will enable more complex systems to be developed
    over time.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we detailed the process for fulfilling project requirements
    with Google Cloud serverless technologies. As part of this process, we broke down
    the initial customer requirements and matched those to pre-existing Google Cloud
    products. Taking this approach significantly shortened our development cycle and
    minimized the level of testing required.
  prefs: []
  type: TYPE_NORMAL
- en: Working with serverless architectures on Google Cloud presents a number of opportunities
    to build some exciting applications. As we have seen in this chapter, the design
    and development process can be extremely rewarding. In most instances, working
    with the system to minimize both the code developed and the complexity of the
    application is time well spent. Our application example clearly demonstrates how
    using existing packages can significantly increase overall productivity and deliver
    on customer requirements. Hopefully, this chapter has ignited your imagination
    and provided the inspiration needed to build the next great application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce a more advanced example in which multiple
    services are run at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What command is used to access Google Cloud Storage from the command line?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When would Stackdriver Logging be the most useful?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of a Docker manifest file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where does Cloud Build store the images it creates?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `curl` command can test GET and POST requests? (True or False)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why would you use the `gsutil` command with the `-m` parameter?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What type of permission is required to call a service?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Connecting to Cloud Storage Buckets**: [https://cloud.google.com/compute/docs/disks/gcs-buckets](https://cloud.google.com/compute/docs/disks/gcs-buckets)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stackerdriver Logging**: [https://cloud.google.com/logging/docs/view/logs_index](https://cloud.google.com/logging/docs/view/logs_index)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qwiklabs Serverless Workshop**: [qwiklabs.com/quests/98](http://qwiklabs.com/quests/98)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
