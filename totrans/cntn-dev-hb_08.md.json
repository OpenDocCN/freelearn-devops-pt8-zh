["```\nkubectl [command] [TYPE] [NAME] [flags]\n```", "```\napiVersion: v1\nkind: Config\nclusters:\n- cluster:\n    certificate-authority-data: BASE64_CLUSTER_CA or the CA file path\n    server: https://cluster1_URL:6443\n  name: cluster1\ncontexts:\n- context:\n    cluster: cluster1\n    user: user1\n  name: user1@cluster1\ncurrent-context: user1@cluster1\nusers:\n- name: user1\n  user:\n    client-certificate-data: BASE64_USER_CERTIFICATE or the cert file path\n    client-key-data: BASE64_USER_KEY or the key file path\n```", "```\n    $ kubectl get nodes\n    NAME             STATUS   ROLES           AGE   VERSION\n    docker-desktop   Ready    control-plane   45m   v1.25.4\n    ```", "```\n    $ ls -lart ~/.kube/config\n    -rw-r--r-- 1 frjaraur frjaraur 5632 May 27 11:21 /home/frjaraur/.kube/config\n    ```", "```\n$ kubectl version --short\nFlag --short has been deprecated, and will be removed in the future. The --short output will become the default.\nClient Version: v1.27.2\nKustomize Version: v5.0.1\nServer Version: v1.27.2+k3s1\n```", "```\nPS > minikube start --nodes 2 `\n--kubernetes-version=stable `\n--driver=hyperv\n* minikube v1.30.1 on Microsoft Windows 10 Pro 10.0.19045.2965 Build 19045.2965\n* Using the hyperv driver based on user configuration\n* Starting control plane node minikube in cluster minikube\n...\n* Done! kubectl is now configured to use \"minikube\" cluster and \"default\" namespace by default\n```", "```\nPS > kubectl get nodes\nNAME           STATUS   ROLES           AGE   VERSION\nminikube       Ready    control-plane   25m   v1.26.3\nminikube-m02   Ready    <none>          22m   v1.26.3\n```", "```\napiVersion: v1\nkind: Pod\nmetadata:\n    name: examplepod\n  labels:\n    example: singlecontainer\n  spec:\n      containers:\n      - name: examplecontainer\n        image: nginx:alpine\n```", "```\nPS > kubectl explain pod\nKIND:     Pod\nVERSION:  v1\nDESCRIPTION:\n     Pod is a collection of containers that can run on a host. This resource is\n...\n FIELDS:\n   apiVersion   <string>\n     APIVersion defines the versioned schema of this representation of an\n ...\n   spec <Object>\n     ...\n   status       <Object>\n     …\n```", "```\nPS > kubectl explain pod.spec.containers.resources\nKIND:     Pod\n...\nRESOURCE: resources <Object>\n ...\nDESCRIPTION:\n     Compute Resources required by this container. Cannot be updated. More info:\n     https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\n ...\nFIELDS:\n   claims       <[]Object>\n     Claims lists the names of resources, defined in spec.resourceClaims, that\n     are used by this container.\n ...\n    limits       <map[string]string>\n     Limits describes the maximum amount of compute resources allowed. More\n   ...\n   requests     <map[string]string>\n     Requests describes the minimum amount of compute resources required. If\n   ...\n```", "```\n    PS > kubectl run webserver --image=docker.io/nginx:alpine `\n    --port 80\n    pod/webserver created\n    ```", "```\n    PS > kubectl get pods\n    NAME        READY   STATUS              RESTARTS   AGE\n    webserver   0/1     ContainerCreating   0          5s\n    ```", "```\n    PS > kubectl get pods -o wide\n    NAME        READY   STATUS    RESTARTS   AGE     IP           NODE       NOMINATED NODE   READINESS GATES\n    -o wide to modify the command’s output. As you can see, we now have the associated IP address.\n    ```", "```\n    PS > kubectl delete pod webserver\n    pod \"webserver\" deleted\n    PS > kubectl run webserver `\n    --image=docker.io/nginx:alpine --port 80\n    pod/webserver created\n    PS > kubectl get pods -o wide\n    NAME        READY   STATUS    RESTARTS   AGE   IP           NODE       NOMINATED NODE   READINESS GATES\n    webserver   1/1     Running   0          4s    10.244.0.4   minikube   <none>           <none>\n    ```", "```\nPS >   kubectl  expose  pod  webserver  -o yaml  `\n--port 80  --dry-run=client\napiVersion: v1\nkind: Service\nmetadata:\n  creationTimestamp: null\n  labels:\n    run: webserver\n  name: webserver\nspec:\n  ports:\n  - port: 80\n    protocol: TCP\n    targetPort: 80\n  selector:\n    run: webserver\nstatus:\n  loadBalancer: {}\n```", "```\napiVersion: apps/v1\nkind: ReplicaSet\nmetadata:\n  name: replicated-webserver\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      application: webserver\n  template:\n     metadata:\n         application: webserver\n     spec:\n       containers:\n       - name: webserver-container\n         image: docker.io/nginx:alpine\n```", "```\n    $ kubectl auth can-i create pods –namespace dev\n    yes\n    $ kubectl auth can-i create svc -n prod –as dev-user\n    no\n    ```", "```\n    minikube start –nodes 2 –memory 3G –cpus 2 `\n    --kubernetes-version=stable –driver=hyperv `\n    --cni=calico `\n    minikube start:\n    ```", "```\n    PS C:\\Windows\\system32> cd c:\\\n    PS C:\\>  minikube start –nodes 2 –memory 3G `\n    --cpus 2 –kubernetes-version=stable `\n    --driver=hyperv –cni=calico `\n    --addons=ingress,metrics-server,csi-hostpath-driver\n    * minikube v1.30.1 on Microsoft Windows 10 Pro 10.0.19045.2965 Build 19045.2965\n    * Using the hyperv driver based on user configuration\n    * Starting control plane node minikube in cluster minikube\n    * Creating hyperv VM (CPUs=2, Memory=3072MB, Disk=20000MB) …\n    * Preparing Kubernetes v1.26.3 on Docker 20.10.23 ...\n      - Generating certificates and keys ...\n    ...\n      - Using image registry.k8s.io/metrics-server/metrics-server:v0.6.3\n    * Verifying ingress addon...\n    ...\n    * Starting worker node minikube-m02 in cluster minikube\n    ...\n    * Done! kubectl is now configured to u\"e \"minik\"be\" cluster a\"d \"defa\"lt\" namespace by default\n    kubectl get nodes:\n\n    ```", "```\n\n    ```", "```\n    PS C:\\> kubectl get nod– --show-labels\n    NAME           STATUS   ROLES           AGE   VERSION   LABELS\n    minikube       Ready    control-plane   27m   v1.26.3   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=minikube,kubernetes.io/os=linux,minikube.k8s.io/commit=08896fd1dc362c097c925146c4a0d0dac715ace0,minikube.k8s.io/name=minikube,minikube.k8s.io/primary=true,minikube.k8s.io/updated_at=2023_05_31T10_59_55_0700,minikube.k8s.io/version=v1.30.1,node-role.kubernetes.io/control-plane=,node.kubernetes.io/exclude-from-external-load-balancers=,topology.hostpath.csi/node=minikube\n    node-role.kubernetes.io/worker. This label is not required, and that’s why it is not included by default, but it is good to include it to identify nodes in the node cluster review (kubectl get nodes).\n    ```", "```\n    PS C:\\> kubectl label node minikube-m02  `\n    node-role.kubernetes.io/worker=\n    node/minikube-m02 labeled\n    PS C:\\> kubectl get nodes\n    NAME           STATUS   ROLES           AGE   VERSION\n    minikube       Ready    control-plane   33m   v1.26.3\n    kubectl label to add any label to any resource. In the specific case of node-role.kubernetes.io, it is used by Kubernetes to show the ROLES column, but we can use any other label to identify a set of nodes. This will help you in a production cluster to run your applications in nodes that best fit your purposes – for example, by selecting nodes with fast solid-state disks, or those with special hardware devices. You may need to ask your Kubernetes administrators about these nodes’ special characteristics.\n    ```", "```\n    PS C:\\> kubectl create ns chapter8\n    chapter8 namespace by adding --namespace or just --n to kubectl get pods:\n\n    ```", "```\n\n    ```", "```\n    PS C:\\> kubectl run webserver --image=nginx:alpine `\n    -n chapter8\n    pod/webserver created\n    PS C:\\> kubectl get pods -n chapter8\n    NAME        READY   STATUS    RESTARTS   AGE\n    kubectl command talks with the Kubernetes API using the credentials from our local kubeconfig file (this file is located in your home directory in the .kube directory; you can use $env:USERPROFILE\\.kube in Microsoft Windows), and kube-apiserver gets this information from etcd before it is presented in our terminal. The following screenshot shows part of the output we get by using kubectl get pod <PODNAME> -o yaml. The –o yaml modifier shows the output from a current resource in the YAML format. This really helps us to understand how objects are created and managed by Kubernetes:\n    ```", "```\n    PS C:\\> kubectl get pods -n chapter8 -o wide\n    NAME        READY   STATUS    RESTARTS   AGE   IP          NODE           NOMINATED NODE   READINESS GATES\n    webserver   1/1     Running   0          27m   10.244.205.194   minikube-m02   <none>           <none>\n    ```", "```\n    PS C:\\> kubectl get pods -n chapter8 `\n    -o jsonpath='{ .status.hostIP }' webserver\n    172.19.146.184\n    ```", "```\n    PS C:\\> kubectl expose pod webserver -n chapter8 `\n    --target-port 80 --port 8080 --type=NodePort\n    chapter8 namespace:\n\n    ```", "```\n\n    ```", "```\n    PS C:\\> kubectl delete service/webserver pod/webserver -n chapter8\n    service \"webserver\" deleted\n    pod \"webserver\" deleted\n    PS C:\\> kubectl delete ns chapter8\n    namespace \"chapter8\" deleted\n    ```"]