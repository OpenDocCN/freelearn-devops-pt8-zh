- en: Cloud Functions Labs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we picked up some useful skills as we built an application
    to access signed URLs. One of the most common examples is building a website.
    So we will move on to expand our repertoire by creating a static website-based
    example database on Marvel Films. By the end of the chapter, you will understand
    how to enhance the various techniques presented earlier through rich code samples.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we will look at some tips on how to incorporate data and also
    take a first look at security in the context of service accounts. Beyond this,
    we will look at the main components of a static website and how this might potentially
    be enhanced.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a static website
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service account security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to complete the exercises in this chapter, you will require a Google
    Cloud project or a Qwiklabs account.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code files for this chapter in the GitHub repository for this
    book in the `ch06` subdirectory at [https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch06](https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch06).
  prefs: []
  type: TYPE_NORMAL
- en: While you are going through code snippets in the book, you will notice that,
    in a few instances, a few lines from the codes/outputs have been removed and replaced
    with ellipses (`...`). The use of ellipses serves to show only relevant code/output.
    The complete code is available on GitHub at the preceding link.
  prefs: []
  type: TYPE_NORMAL
- en: Building a static website
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following example, we will be building an application in which our now
    familiar function baseline code will consume an external data source (based on
    JSON) and output a view rendered against an HTML template.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen this type of layout used previously in other Node.js applications
    (for example, [Chapter 3](4775f0c6-9325-4890-803a-e8feb14ee1d6.xhtml), *Introducing
    Lightweight Functions* and [Chapter 4](9431bfa5-ef43-4043-9779-d5b6d3fef36c.xhtml),
    *Developing Cloud Functions*), so in this chapter, the focus will be on building
    the code necessary to build our website.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Make a brand new directory in which to host our code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the new directory, initialize the environment by performing `npm init
    --yes` at the command line to initialize our new development environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Complete the resulting `package.json` as per the following table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **Field** | **Response** |'
  prefs: []
  type: TYPE_TB
- en: '| Package name: | `marvel-website` |'
  prefs: []
  type: TYPE_TB
- en: '| Version: | 1.0.0 |'
  prefs: []
  type: TYPE_TB
- en: '| Description: | This is an example website built with Cloud Functions |'
  prefs: []
  type: TYPE_TB
- en: '| Entry Point: | `index.js` |'
  prefs: []
  type: TYPE_TB
- en: '| Test command: | blank |'
  prefs: []
  type: TYPE_TB
- en: '| Git repository: | blank |'
  prefs: []
  type: TYPE_TB
- en: '| Keywords: | blank |'
  prefs: []
  type: TYPE_TB
- en: '| Author: | Enter your name |'
  prefs: []
  type: TYPE_TB
- en: '| License: | ISC |'
  prefs: []
  type: TYPE_TB
- en: As highlighted in [Chapter 4](9431bfa5-ef43-4043-9779-d5b6d3fef36c.xhtml), *Developing
    Cloud Functions* and [Chapter 5](633e9be2-53a4-483b-b6f2-844cd249cbd3.xhtml),
    *Exploring Functions as a Service*), to work locally we can use the `functions-framework`
    package. In addition, we will also need to install the `pug` package for the view
    template used to render HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the command line, install the necessary packages by issuing the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, make a couple of new subdirectories to hold `views` and `data` in relation
    to the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, your directory structure should look similar to the following;
    that is, two files (`package.json` and `package-lock.json`) and three subdirectories
    (`data`, `views`, and `node_modules`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Remember that, to use the Functions Framework within your application, you need
    to alter the `package.json` file to incorporate a `start` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `package.json` file and add a reference to the Functions Framework
    as outlined here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The information highlighted in *line 6* shows the necessary startup command.
    Take note that the target entry point is called `filmAPI`, which means the exported
    function in our application will also need to match this signature.
  prefs: []
  type: TYPE_NORMAL
- en: Excellent! We have now created the basic structure of the application. Now we
    turn our attention to the data source that provides the information to be presented
    in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a data source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Turning our attention to the data directory, our next step is to create a **JavaScript
    Object Notation** (**JSON**) file to store our data. Using JSON is a quick and
    easy way to create an external data source, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file in the `data` subdirectory called `films.json`. This will
    hold our film information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the first film, add the content in the following table to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To explain the schema used, let''s examine the content of the text. The primary
    construct is an array in which we will create a number of placeholders for an
    object representing a film. The film object will expose several fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Field** | **Type** | **Comment** |'
  prefs: []
  type: TYPE_TB
- en: '| `title` | String | Title of the film |'
  prefs: []
  type: TYPE_TB
- en: '| `director` | String | Name of the film director |'
  prefs: []
  type: TYPE_TB
- en: '| `release` | String | Release date of the film |'
  prefs: []
  type: TYPE_TB
- en: '| `description` | String | General overview of the film plot |'
  prefs: []
  type: TYPE_TB
- en: '| `bgImage` | String | URL for the film post |'
  prefs: []
  type: TYPE_TB
- en: 'Looking at the JSON file directly we can see how the data will be represented
    in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: Note the comma at the end of the code block; this indicates we are going to
    add further content to the file. If we are not adding further content, no comma
    is added after the film object (see *The Avengers* object for comparison).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding additional content such as `The Incredible Hulk` can be achieved by
    appending content at the end of the array record:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new record for `Iron Man 2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new record based on `Thor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new record for `Captain America`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add a new record for `The Avengers`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Based on the preceding code, we have created six new records to hold our data
    in an array. The intention is for the data to work as input for the Cloud Function
    we are about to create. In the real world, it is more likely that a database would
    suffice for this type of access. However, in this example, brevity is our friend,
    and so is JSON!
  prefs: []
  type: TYPE_NORMAL
- en: Now we have created a data source, we will need to implement an onscreen representation
    to illustrate the information to be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a frontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Making a frontend in HTML should not present too much of a challenge as there
    are plenty of excellent examples available. In this section, we will take our
    schema and display it onscreen. The template to be used will be created in the
    `views` subdirectory and will feature in a new file named `index.pug` with the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: Header definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Card definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Description definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Body definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From the preceding points, let''s look into the contents of each section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The header definition uses standard HTML to incorporate style content. In the
    example, we create a new header style to alter both the font and alignment of
    text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `card` definition creates a new style that will visually look like an onscreen
    card:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `release` definition creates color and font enhancements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `description` definition creates enhancements with reference to the color,
    font size, and padding for any element associated with this style:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `body` definition provides the main layout considerations for importing
    data via the Cloud Function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Type** | **Comment** |'
  prefs: []
  type: TYPE_TB
- en: '| H1 | Main heading | The page title |'
  prefs: []
  type: TYPE_TB
- en: '| H3 | Subheading | A subheading for the page |'
  prefs: []
  type: TYPE_TB
- en: '| img | Image link | The URL link for the image |'
  prefs: []
  type: TYPE_TB
- en: '| p | Paragraph | Description text |'
  prefs: []
  type: TYPE_TB
- en: When creating a view, we are using information passed from the Cloud Function
    to populate the onscreen view. Specifically, we take the title, release date,
    director, and description from the schema information consumed from the JSON data
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point in our example, we should now have the following directory structure,
    based on the files created in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We have also created a data source based on a JSON file that holds information
    concerning films. The methods to add a new movie, remove a film, and alter information
    relating to a film should be self-evident, and the data file presents a convenient
    way to manage external data content. Also, the view is isolated from the primary
    function; thus, as a bonus, the presentation layer acts independently, making
    alteration easy. Finally, we need to create the service to perform integration
    between the data and view and generate an appropriate HTTP response.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing a Cloud Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Cloud Function that we''ve defined doesn''t have a significant amount of
    code associated with it. There are the following elements in our Cloud Function:'
  prefs: []
  type: TYPE_NORMAL
- en: Variable definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The private function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The public function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To explain the various elements that we've outlined here, let's take a minute
    to explore each component in a bit more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variable definitions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 1**: The function starts with a declaration to include our temporary
    data store in which film information is stored. Again, this is an easy way to
    incorporate data into an application without needing additional infrastructure
    to be put in place.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 2**: Uses `pug` package dependencies and declares them for use within
    the function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The private function works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 6**: Declares the view to be rendered based on the external view defined
    in the `index.pug` file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 11**: Creates the response object based on an HTTP status response code
    of 200 and an array value based on the item selected by the user when viewing
    the initial screen:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The public function works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 31**: A call to the `filmDetail` function passes the request, response,
    and data objects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When running the preceding application (that is, `npm start` from the command
    line), the details of the JSON filmography array will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Note that query string URLs can be used to access information beyond the first
    film. An HTTP query mechanism like this can be useful when passing additional
    parameters to sub-components. In this instance, we use these parameters to select
    alternative pages to be displayed without having to amend the existing function
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To select another film from the array of available films, use the URL query
    setting to access any film persisted in the film database, as demonstrated in
    the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Film** | **URL** |'
  prefs: []
  type: TYPE_TB
- en: '| 1\. Iron Man | `http://localhost:8080` |'
  prefs: []
  type: TYPE_TB
- en: '| 2\. The Incredible Hulk | `http://localhost:8080/?film=1` |'
  prefs: []
  type: TYPE_TB
- en: '| 3\. Iron Man 2 | `http://localhost:8080/?film=2` |'
  prefs: []
  type: TYPE_TB
- en: '| 4\. Thor | `http://localhost:8080/?film=3` |'
  prefs: []
  type: TYPE_TB
- en: '| 5\. Captain America: The First Avenger | `http://localhost:8080/?film=4`
    |'
  prefs: []
  type: TYPE_TB
- en: '| 6\. The Avengers | `http://localhost:8080/?film=5` |'
  prefs: []
  type: TYPE_TB
- en: If you are running this from cloud shell, take note that the URL will be different
    from that shown above. However, you are still able to append query settings, for
    example,`https://mydomain-dot-devshell.appspot.com/?authuser=0&environment_id=default&film=2`
    to display the second film.
  prefs: []
  type: TYPE_NORMAL
- en: You will see different pages when presenting different query objects to the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: This example shows how the GET HTTP verb can be extended through the use of
    querying parameters. It is this type of flexibility that has made HTTP such a
    widely adopted approach and outlines the strength of this protocol. Our working
    example demonstrates how to develop a simple web application using Cloud Functions.
    The example can, of course, extend to other more intricate use cases. I will leave
    it to your imagination to build the next big thing based on the accumulated knowledge
    gathered over the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: We will now turn our attention to the crucial topic of Cloud Functions security.
    In the next section, we will discuss various security techniques that can be applied
    when working with Cloud Functions.
  prefs: []
  type: TYPE_NORMAL
- en: Service account security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, in this chapter, we will introduce the concept of least privilege with
    regard to **Identity Access Management** (**IAM**) and explain how to apply this
    to Cloud Functions. We will look at some approaches that can secure an application
    using Cloud Functions.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we will discuss service accounts; however, let's take
    an initial brief look at how to restrict the caller status of the Cloud Functions
    deployed. Cloud Functions use service accounts rather than a user account to manage
    services. In this respect, the service account takes on the role of the user without
    needing an actual human to be involved in the process.
  prefs: []
  type: TYPE_NORMAL
- en: Concerning the user account, each function deployed will be assigned a service
    account responsible for permissions. The service account is created either manually
    or automatically; in both instances, the role and permissions need to be defined.
    When a function deploys, the `cloudfunctions.invoker` permission is typically
    applied to the service account. This permission provides the service account with
    the ability to call/invoke Cloud Functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides this permission, the caller also needs to have the correct authentication
    for the function. If the default settings persist, then the `allUser/public` interface
    is bound to the service, meaning anyone can call the function. HTTP functions
    are typically deployed with the default `allUsers` policy binding, meaning that
    anyone can invoke the service. In doing this, it enables anyone to invoke our
    function by using the exposed endpoint. Open access presents a potential vulnerability
    for our application and needs a solution to mitigate this risk. If you wish to
    restrict access to the function, limit it to secure account access: for example,
    `allAuthenticated` or specific users denoted through their IAM account.'
  prefs: []
  type: TYPE_NORMAL
- en: Despite a function being available for a shorter amount of time, Cloud Functions
    are still susceptible to security risks such as malicious code or denial of service.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, with regard to denial-of-service attacks, Cloud Functions sits behind
    the Google frontend that is used to mitigate and absorb many attacks on layer
    4 and below, such as SYN floods, IP fragment floods, port exhaustion, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Many different types of vulnerability can be problematic for web-based services.
    The complexity of this subject means we are not able to provide more than a limited
    overview of the mitigations in play. There is seemingly an ever-increasing spectrum
    of potential vulnerabilities, for example, malicious code, denial-of-service attacks,
    or event resource bottlenecks.
  prefs: []
  type: TYPE_NORMAL
- en: The following section details some techniques to mitigate security concerns
    with Cloud Functions.
  prefs: []
  type: TYPE_NORMAL
- en: Economic limits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we are now aware, serverless provides the ability to achieve scalability
    across the Cloud Functions. However, it may be that a service integrated with
    Cloud Functions isn't able to cope at these types of level. It is possible to
    restrict the maximum number of instances available, should such a restriction
    be applicable within your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying restrictions against connectivity can ease the burden and prevent
    a service from experiencing flooding with more requests than can be successfully
    processed. A threshold setting the available number of instances means that the
    function can be limited at the point of deployment, as demonstrated in the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the constrained scenario here, a queuing mechanism is enabled to ensure the
    constraint applied doesn't impede the processing of information to your service.
    Limiting the instance threshold is an excellent start to securing service calls.
    A different variant looks at how to obtain the credentials used to access resources.
  prefs: []
  type: TYPE_NORMAL
- en: Insecure credential storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Credential storage is an increasingly important topic when attempting to secure
    various services. Essential credentials (or keys), such as database username/password/publication
    credentials or secrets stored in code, require a solution that enables this information
    to be accessible only to authenticated components.
  prefs: []
  type: TYPE_NORMAL
- en: Many industry-based solutions will provide the necessary protections, including
    Google Cloud **Key Management Service** (**KMS**), which supports using Google-
    or customer-based keys. Also, general products such as HashiCorp Vault provide
    a similar level of protection for information to be stored securely.
  prefs: []
  type: TYPE_NORMAL
- en: So credentials offer better protection and allow services to be secured. When
    working with multiple integrated services, how do we manage the workflow to the
    level of security desired?
  prefs: []
  type: TYPE_NORMAL
- en: Execution flow manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The execution flow essentially outlining how the function workflow for your
    application. In a scenario where you have multiple functions, there may be an
    information handoff between components in which they exchange information or provide
    access to a backend service such as a database.
  prefs: []
  type: TYPE_NORMAL
- en: In this situation, it would not be appropriate for any of the functions in this
    workflow to be intercepted or accept communications from unauthenticated external
    sources. To do so would diminish the integrity of the workflow. A situation like
    this presents a substantive security risk to the application (for example, tainted
    information).
  prefs: []
  type: TYPE_NORMAL
- en: To prevent this type of vulnerability, we can utilize least-privilege security
    settings to manage service accounts and establish a per-function authorization
    mechanism to validate calls. By default, all functions/apps/containers can share
    the same service identities and have a role assigned, such as project editor.
    However, identity management can also be set on a per-function basis to establish
    the least privilege. For Cloud Functions, append a service account to control
    the function at the point of deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, a service account capable of invoking a Cloud Function
    is labeled **Function A**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67bedd99-4abb-47f3-b779-f0db5a9740f1.png)'
  prefs: []
  type: TYPE_IMG
- en: Service account deployment provides a public interface to our other services.
    We will also create a second service account for **Function B** to manage the
    backend; this service account will not have invoker privileges and will not be
    made public. Finally, **Backend Services** do not expose themselves to the public-facing
    internet. Besides this, they will also be accessible from Function B. An arrangement
    of this type is relatively common, for example, on a bastion host where the host
    is internet-facing and only the host has permission to connect with other machines
    in the estate.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to Google, a service account is a special account that calls the
    Google API without the involvement of a user. These computer accounts are an incredibly
    useful feature and are defined with IAM permissions. We can create a new service
    account that will provide access to the function by using the following `gcloud`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a service account—`Function A`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Bind a role to the service account that will enable the latter to use the `invoker`
    role:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `cloudfunctions.invoker` role is required to initiate Cloud Functions, and
    we bind this permission to our new service account. By doing this, our service
    account can now call Cloud Functions.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created a service account with the necessary permissions, we
    can deploy our function with the new service account by appending the name of
    the account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply the new service account on deployment of the Cloud Function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: To complete our example, we will create a second service account associated
    with our second function. For this service account, we will not apply the `invoker`
    (`cloudfunctions.invoker`) role, thereby restricting who can initiate the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a service account—`Function B`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As we did with the first service account, we need to bind some permissions.
    In this instance, we are using Cloud SQL permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bind a role to the service account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can deploy the function with the recently created service account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply the service account to the function being deployed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have now made simple changes to our application that ensure
    that the function execution flow works to our advantage. **Function A** is our
    entry point function and provides a frontend for our application. **Function B**
    is now only accessible via **Function A**, which secures the execution flow from
    A to B. Also note that now the **Backend Services** is only available via **Function
    B**. With the changes specified in the preceding steps, we now have the following
    layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03d17991-0d41-4824-b24c-5052c989ee0e.png)'
  prefs: []
  type: TYPE_IMG
- en: In the final area to be discussed, we'll look at security controls through policy
    controls.
  prefs: []
  type: TYPE_NORMAL
- en: FunctionShield
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Google Cloud Functions also supports third-party solutions such as FunctionShield.
    With these solutions, strict security controls are employed that ensure the application
    of a policy to the functions deployed. Specifically, these protections apply to
    four distinct areas:'
  prefs: []
  type: TYPE_NORMAL
- en: The security policy allows the disabling of egress internet connectivity. Restriction
    of outbound traffic when not required by the service is a good practice to adopt,
    as most services will typically only require ingress/inbound traffic to be enabled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As previously indicated, Cloud Functions are lightweight functions that are
    stateless. In this respect, local storage requirements, therefore, should be restricted
    where possible. FunctionShield can disable read/writes on the `/tmp` directory,
    typically used for intermediary storage requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread execution for child processes should be minimized and restricted when
    not required by the function to be invoked. Being able to execute child processes
    presents a genuine security risk that is difficult to track and trace once initiated
    without the application of adequate protections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restrict access to the function's source code via the central console. Where
    the source code has some value or associate **intellectual property** (**IP**),
    this can be an extra safeguard that applies to the system source code to be deployed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The FunctionShield solution is a free product that can be deployed to multiple
    cloud providers, making it a flexible solution we can use to ensure the application
    of a standard policy within your serverless estate. No function code amendments
    are necessary to deploy this against your application. A proprietary, behavioral-based
    runtime establishes protection around the serverless environment. The observability
    of the cloud functions remains apparent and is available via the standard mechanism:
    Stackdriver on Google Cloud.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this chapter, we have concluded our foray into Cloud Functions on Google
    Cloud. The last couple of chapters have covered a lot of material on how to develop
    Cloud Functions. In the first example, we continued on our journey with Cloud
    Functions to explore how to construct a website based on an external view and
    data template. In this example, we picked up a couple of tips regarding code organization
    and dependency isolation.
  prefs: []
  type: TYPE_NORMAL
- en: On completion of the example, we have an easy-to-maintain website that utilizes
    Cloud Functions to provide a scalable basis for lightweight site access. We learned
    about the principle of least privilege and how this applies to Cloud Functions.
    We also learned some fundamental methods that are capable of securing our Cloud
    Functions by working with Google Cloud service accounts.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, you should be comfortable building both web applications and
    services integrated with Google APIs. There is more to learn that we unfortunately
    don''t have the time or space to cover in this book. Cloud Build, GKE, databases,
    IoT, and third-party services are all possible avenues for further exploration.
    This concludes our tour of Cloud Functions on Google Cloud. In upcoming chapters,
    we will turn our attention to the latest iteration of serverless on Google Cloud:
    Cloud Run and Cloud GKE.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What permission does a Cloud Function require to be invoked?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does Google KMS provide?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `allUsers` permission effectively mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `allAuthenticated` permission effectively mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What parameter needs to be applied to limit the number of instances available
    to a Cloud Function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What command allows a role to be bound to a service account?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What command is used to create a service account?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a bastion host and why is it useful?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Google service accounts**: [https://cloud.google.com/iam/docs/service-accounts](https://cloud.google.com/iam/docs/service-accounts)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Least privilege for Cloud Functions using Cloud IAM**: [https://cloud.google.com/blog/products/application-development/least-privilege-for-cloud-functions-using-cloud-iam](https://cloud.google.com/blog/products/application-development/least-privilege-for-cloud-functions-using-cloud-iam)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controlling Scaling Behavior**: [https://cloud.google.com/functions/docs/max-instances](https://cloud.google.com/functions/docs/max-instances)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Cloud Key Management Service**: [https://cloud.google.com/kms/](https://cloud.google.com/kms/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
