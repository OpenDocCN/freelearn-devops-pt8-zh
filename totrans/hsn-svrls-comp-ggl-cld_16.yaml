- en: Consuming Third-Party Data via a REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, in [Chapter 11](20f050bc-5118-4170-b2a4-e6c280db6802.xhtml),*Building
    a* *PDF Conversion* *Servic**e*, we learned how to create a PDF service using
    Cloud Run. In this final chapter, we will turn the complexity up a gear in order
    to build a more complex example based on the Pet Theory case study. The requirement
    is to implement a serverless solution on Google Cloud using multiple services.
  prefs: []
  type: TYPE_NORMAL
- en: Through this chapter, your knowledge of serverless workloads and the experience
    required for real-world enterprise products will be challenged. By the end of
    it, a real-world application will be created that demonstrates the key aspects
    of serverless workloads on the Google Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over the course of this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the Pet Theory case study
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a lab report solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing the lab solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Email SMS communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The continuous integration workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing a lab service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete the exercises in this chapter, you will require a Google Cloud project
    or a Qwiklabs account.
  prefs: []
  type: TYPE_NORMAL
- en: You can find all the code files for this chapter in the GitHub repository for
    this book, under the `ch12` subdirectory, at [https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch12](https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch12).
  prefs: []
  type: TYPE_NORMAL
- en: While you are going through the code snippets in this book, you will notice
    that, in a few instances, a few lines from the code/output have been removed and
    replaced with dots (`...`). The use of ellipses is only to show relevant code/output.
    The complete code is available on GitHub at the previously mentioned link.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the Pet Theory case study
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As per the previous chapter, our case study is based on the Pet Theory veterinary
    practice. The full Pet Theory case study incorporates a number of different scenarios
    that demonstrate how you can resolve typical real-world issues with serverless
    technology. To view the complete scenario, visit the Qwiklabs website and reference
    the Pet Theory Quest in order to see the associated labs.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, the Pet Theory management team has expressed their concern
    regarding the level of manual effort that is required to process lab reports.
    Currently, clinical reports sent from third-party labs are received electronically
    and are then manually processed by the internal admin team. The process of managing
    the report is effectively to download the information and add it to a report that
    is then communicated to the pet owner via email or SMS. Since the veterinary practice
    has become more and more successful, the number of reports associated with this
    process has become unmanageable.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve the issue relating to processing lab reports, it has been proposed
    that a proof of concept should be built. The initial revision should demonstrate
    how to automate processing the lab reports that are received and also the distribution
    of report information.
  prefs: []
  type: TYPE_NORMAL
- en: To begin our review, we will outline, at a high level, what the proposed architecture
    should achieve and the associated component roles and requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a lab report solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this scenario, the Pet Theory team is keen to explore how they can use serverless
    technologies to automate the receiving and processing of lab results. Lab reports
    are currently received electronically and then have to be manually sent to clients.
    As per previous examples, the emphasis of the activities to be performed is to
    demonstrate how to replace existing tasks with minimum development effort. In
    addition to this, the components used should be loosely coupled so that further
    enhancements are straightforward to implement and do not require significant rework.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of the requirements stated, the Pet Theory team has decided they need
    a system capable of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Requirement** | **Service** |'
  prefs: []
  type: TYPE_TB
- en: '| Report collation | Reporting |'
  prefs: []
  type: TYPE_TB
- en: '| Message handling | Message |'
  prefs: []
  type: TYPE_TB
- en: '| Email communication | Email |'
  prefs: []
  type: TYPE_TB
- en: '| SMS communication | SMS |'
  prefs: []
  type: TYPE_TB
- en: '| Test data capture | Test |'
  prefs: []
  type: TYPE_TB
- en: Let's add to our understanding by describing each requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Report collation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lab reports are sent directly to the Pet Theory web endpoint using an HTTP(S)
    POST command. The information received utilizes the JSON format and the external
    application has already agreed on the content for the message communicated.
  prefs: []
  type: TYPE_NORMAL
- en: Both Cloud Run and Cloud Functions provide the ability to consume web endpoints.
    Apart from consuming messages, a reporting service also needs to be capable of
    propagating the message to downstream services.
  prefs: []
  type: TYPE_NORMAL
- en: Message handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pet Theory has experienced a similar requirement for the lab, which was discussed
    in [Chapter 11](20f050bc-5118-4170-b2a4-e6c280db6802.xhtml), *Building a PDF Conversion
    Service*. In that example, the sender and receiver used asynchronous messaging
    via Cloud Pub/Sub to achieve their aim.
  prefs: []
  type: TYPE_NORMAL
- en: In this situation, lab reports are to be delivered to email and SMS services
    for further processing.
  prefs: []
  type: TYPE_NORMAL
- en: Email communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The email service represents a new requirement and delivers the ability to communicate
    with clients using an existing email solution. Information is to be passed to
    this component via a Cloud Pub/Sub subscription.
  prefs: []
  type: TYPE_NORMAL
- en: SMS communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to email communication, the SMS component offers an alternative way
    to communicate with clients when receiving test results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a shared understanding of the key components of the architecture,
    the elements necessary for building the solution should be clearer. From an overview
    perspective, our solution architecture can be described with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: A JSON formatted lab report is submitted to the Pet Theory HTTP(S) endpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A report service consumes the JSON message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The lab information in the JSON message is published to a Cloud Pub/Sub topic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A subscription notification is received by the email service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A subscription notification is received by the SMS service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In addition, we can see that the following components are required:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85e5fe08-d707-422a-b10e-e0d7899f5545.png)'
  prefs: []
  type: TYPE_IMG
- en: It is important to note that there are many other ways to resolve the requirements
    outlined here.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, we have defined a number of components to meet our
    initial requirements. Remember that Pet Theory is a small organization, so it
    will not want to incur development costs unnecessarily.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are going to implement multiple services, each of which
    will perform a specific task. As such, later in this exercise, we will look at
    how to test the individual components by enhancing them to write a status update
    within a document.
  prefs: []
  type: TYPE_NORMAL
- en: Based on what we've just covered, we now have a general understanding of the
    lab report solution for processing reports submitted to our service. In the next
    section, we will start to look at the practical elements of developing the solution
    in order to fulfill the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the lab solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Several advanced topics will be covered in this chapter; so, having worked through
    the examples presented in prior chapters is highly recommended. Over the course
    of the previous chapters, knowledge of Google Cloud and its serverless product
    portfolio has been presented in order to guide you on this journey.
  prefs: []
  type: TYPE_NORMAL
- en: Using your Google Cloud account, open the Cloud Shell and make sure that a clone
    of the lab repository for `Chap12` is accessible.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the earlier chapters, some activities will not be covered in detail.
    Instead, this chapter is devoted to bringing together a skeleton solution that
    illustrates how to construct an application to meet requirements. If you get stuck
    or need help, don't forget that you can consult the solution directory.
  prefs: []
  type: TYPE_NORMAL
- en: Linking to Google Docs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to using a centralized service such as Stackdriver, we can also
    introduce alternative tooling. In this section, we will be demonstrating how to
    integrate Google Docs (specifically, Google Sheets).
  prefs: []
  type: TYPE_NORMAL
- en: When you create a spreadsheet on Google Sheets, by default, only the creator
    has permission to read and write to the sheet. To allow the Cloud Run application
    access to the sheet, we need to provide it with access permissions. As you might
    have guessed, for this task, we will use a service account.
  prefs: []
  type: TYPE_NORMAL
- en: 'From Cloud Shell, we need to retrieve the name of the service account for our
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use that information to link to Google Docs:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new spreadsheet in Google Sheets (that is, [https://docs.google.com/spreadsheets](https://docs.google.com/spreadsheets)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the default spreadsheet name of `Untitled spreadsheet`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the spreadsheet to `Lab Results Status`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Share button and enter the service account email address we retrieved
    previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Great! We now have a spreadsheet available that is linked to our service account
    project. To link our new spreadsheet with our services, we need to use the `SHEET-ID`
    variable. The `SHEET-ID` variable is a unique identifier for your document and
    is accessible by accessing the URL of the Google Sheet, as per the following example
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/721cb22d-dee5-4c65-affa-bb120f0b3aad.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding graphic, we can see the `SHEET-ID` has been clearly marked.
    Now, we need to incorporate that identifier into our application code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to access the spreadsheet using Cloud Run:'
  prefs: []
  type: TYPE_NORMAL
- en: Access the URL for the spreadsheet we created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the string that starts after `spreadsheets/d/` and ends before `/edit`,
    as shown in the preceding screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, go back to Cloud Shell and edit the file named `pet theory/lab05/common/sheet.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the `SHEET-ID` variable with the value copied from the URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Excellent! Now, the spreadsheet can be accessed using our Cloud Run application.
  prefs: []
  type: TYPE_NORMAL
- en: Report collation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From our prior discussion on the Lab Service architecture, we know that the
    initial service to be created relates to report collation. If we focus on the
    requirements for this stage of processing, we can see that we need to consume
    a JSON file that''s received from external sources:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd57de1d-2e7d-43be-a64f-8daecb27330b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point in this exercise, let''s take the opportunity to create a Cloud
    Pub/Sub topic, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The Cloud Pub/Sub topic will be used to communicate lab reports between the
    report collation service and backend email/SMS services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `npm` packages dependencies for the lab report:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Amend the `package.json` file to incorporate a `start` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `index.js` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Append the following content to `index.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in `index.js`, add the following function, and then close the file
    for editing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy across the `common` directory that includes the Google API''s code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a moment to look at the `index.js` source code, taking note of the following
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: The `request.body` property represents the lab report to be processed.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The schema associated with the lab report is not required at this point.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The data from the lab report is added to a Cloud Pub/Sub topic named `new-lab-report`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the topic has been published, the service returns an HTTP status code of
    204 (that is, successful but no data to return).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If an error occurs, an HTTP status code of 500 (a server error) is returned.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides the Node.js source code for the report service, we also require a Dockerfile
    to be created in the same directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Dockerfile, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The content of this manifest should, at this stage, be familiar and require
    no further explanation. We will deploy the manifest later in this exercise when
    we discuss component deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! The code definition for a report service capable of consuming
    external lab reports is available and ready to be deployed. A Cloud Pub/Sub has
    been provisioned and made ready to accept information that's received from external
    third parties.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will take a closer look at the email and SMS services and review the
    instructions associated with their implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Email/SMS communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the sake of brevity in our proof of concept, the email and SMS services
    will utilize a similar code base to demonstrate how background services can be
    designed within Google Cloud. While these components are meant to provide isolated
    services, in our example, we will use common code to demonstrate their functionality.
    In a real-world situation, the communication component presents an opportunity
    for a common code base to be replicated/extended for different solutions (for
    example, email, bots, SMSes, pagers, and more).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Cloud Pub/Sub topic we previously created pushes the data to be consumed
    by the communication components. In this instance, the lab report data object
    represents a JSON file that is used to communicate lab results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c858700d-3281-42ef-8f3c-a04ac7d66f68.png)'
  prefs: []
  type: TYPE_IMG
- en: It is worth pointing out that we have not actually referenced the data passed
    in the lab report, nor do we know the content schema being used. Instead, we treat
    it as a black box and, therefore, don't have any data validation to be performed
    on the content. Taking this step reduces the level of testing to be performed
    later on in the development cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of Cloud Run message processing, this means the following processes
    are observed when using Cloud Pub/Sub:'
  prefs: []
  type: TYPE_NORMAL
- en: Cloud Pub/Sub maintains its responsibility for pushing messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The subscriber is responsible for consuming the messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A service is aligned with the subscriber to accept the message payload.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once again, we are using techniques that should now be familiar, as these same
    design patterns are common when using Cloud Pub/Sub to interact between resources.
  prefs: []
  type: TYPE_NORMAL
- en: Email
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the `email-service` directory, we need to perform a couple of activities.
    If you are unsure of the exact command, refer to the *Designing a lab report solution*
    section earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Amend the `package.json` file to include a node start `index.js` statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add package dependencies for `express`, `body-parser`, and `googleapis`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an `index.js` file and populate it with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `index.js` file and populate it with this additional code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy across the `common` directory that includes the Google API''s code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Once more, take a moment to observe the `index.js` source code, taking note
    of the following key elements:'
  prefs: []
  type: TYPE_NORMAL
- en: The `request.body` property translates the Cloud Pub/Sub message using `decodeBase64`.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Data processing uses a `console.log` statement.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The service returns an HTTP status code of `204` (that is, successful but no
    data to return).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If an error occurs, an HTTP status code of `500` (that is, an unsuccessful server
    error occurred) is returned.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We also need a Dockerfile manifest that will be used later to build the image
    for the Node.js application.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Dockerfile for a `Node.js` application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Great! Let's move on.
  prefs: []
  type: TYPE_NORMAL
- en: SMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the SMS service directory, we need to perform the same steps. If you are
    unsure of the exact command, reference to the Developing the *Lab solution* section
    earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Amend the `package.json` file to include a node start `index.js` statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add package dependencies for `express`, `body-parser`, and `googleapis`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an `index.js` file and populate it with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `index.js` file and populate it with this additional code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy across the `common` directory that includes the Google API''s code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Add a Dockerfile manifest that will be used later to build the image for the
    Node.js application.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Dockerfile for a `Node.js` application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations! The email and SMS services are now available and ready to be
    deployed. Now that we have looked at the general code base, we can move on to
    thinking about how to efficiently build the multiple components needed for this
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: The continuous integration workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While building components, using a manual approach may seem like a good technique
    due to its implementation simplicity. In this chapter, we will automate this process.
    The reason for this is that there are multiple code bases that need to be built
    and deployed, which, if done manually, can result in unnecessary errors in the
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of a manual build, we turn our focus to a development tool to take care
    of this repetitive build and deploy process. In our project, we intend to use
    Cloud Build to manage the build workflow on Google Cloud. To use Cloud Build,
    it is worth understanding the actual process to be automated, since the configuration
    required will often be an approximation of the manual steps to be followed.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working in this project, our developer workflow can be defined using the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: A developer commits their code using `git`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Code commits are notified to Source Repositories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cloud Build triggers when a matching pattern is found.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the build process fails, the developer is required to rectify the code (go
    to *step 1*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the build process succeeds, the image is added to the Container Registry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A **Quality Assurance** (**QA**) team member can then access the new image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, there are multiple steps involved in this process, and an error
    could potentially occur during any one of these stages. Introducing automation
    in this process can help to remediate any errors through consistency and also
    make the overall maintenance of the project more straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: The defined steps provide a common approach to ensure building software can
    be achieved in an iterative manner. Using a development tool such as Cloud Build
    ensures that the build process remains both consistent and flexible and that the
    process is managed through an external build file. The build file can easily be
    shared between team members and means updates and build profiles can be managed
    under version control.
  prefs: []
  type: TYPE_NORMAL
- en: Developers are part of a continual feedback workflow based on their code commits,
    meaning they control code submissions and can also react directly to any issues.
    The initiation of the build process, based on a code commit, will feedback on
    the success or failure of the relevant component submitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following diagram to see how this process could work in
    practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee3ee395-38ea-496b-acb9-2c4c3219aa38.png)'
  prefs: []
  type: TYPE_IMG
- en: Once the code component has been successfully built, it will be stored in the
    Container Registry. From here, the QA team members have access to the latest verified
    image and are able to test each of the images independently, without needing to
    refer to the development team. In this way, alternative versions such as dev,
    staging, and prod could be deployed and tested as different stage gates.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Lab Service CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand how this process will be used in our example, we can create a
    configuration for Pet Theory based on a basic Cloud Build script.
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to the *Further reading* section at the end of this chapter for
    more information regarding account permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, go back to the `lab-service` directory. This is where we will
    create a basic Cloud Build configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create and edit a new `cloudbuild.yaml` file for `lab-service`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Next, we are going to set up Google Source Repositories for our project. We
    need to create a temporary repository in order to host our code and demonstrate
    some additional features of Google Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Cloud Source Repositories configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Clone the newly created repository, noting you will need to supply your project
    identity as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy across the subdirectories (that is, `email-service`, `sms-service`, `lab-service`,
    and `common`) to the new Google Source repository directory. Your new `pet-theory-test`
    directory should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the status of the `git` directory to ensure you have the common `email-service`,
    `lab-service`, and `sms-service` subdirectories as untracked files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the amended files to `git`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Set up the email credentials using your email address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Set up the name credentials using your username:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a commit message to the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Commit the code for the repository directly to the master branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Check the Cloud Source Repositories in the console to ensure the code is now
    available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations! Knowing how to use Cloud Source Repositories can save time
    when hosting code in Google Cloud. In general, being able to use a Git-based solution
    provides some assurance over the safety of code.
  prefs: []
  type: TYPE_NORMAL
- en: Triggering Cloud Build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, now that we have our code in Cloud Source Repositories, how do we get it
    to automatically build using the Google Cloud developer tools? To automatically
    build code on commit, we can use our old friend Cloud Build. For this example,
    we will use our `lab-service` directory to demonstrate the build process:'
  prefs: []
  type: TYPE_NORMAL
- en: For this example, make sure that you are in the `pet-theory-test`/`lab-service`
    directory. The initial steps in Cloud Build requires the selection of a repository.
  prefs: []
  type: TYPE_NORMAL
- en: From the Cloud Console, access Cloud Build (located under the Developer Tools
    options).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Triggers menu option and the Create Trigger option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set up the trigger using the following information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **Field** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | `trigger-lab-service` |'
  prefs: []
  type: TYPE_TB
- en: '| Description | `Push to the lab branch` |'
  prefs: []
  type: TYPE_TB
- en: '| Trigger type | `Branch` |'
  prefs: []
  type: TYPE_TB
- en: '| Branch (regex) | `^([lL]ab)/\w+` |'
  prefs: []
  type: TYPE_TB
- en: '| Cloudbuild configuration | `lab-service/cloudbuild.yaml` |'
  prefs: []
  type: TYPE_TB
- en: '| Substitution variables | `N/A` |'
  prefs: []
  type: TYPE_TB
- en: Select the Create Trigger button at the bottom of the screen to enable the trigger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The regex branch in the Cloud Build trigger table is a common way of filtering
    which content should be built. In many instances, developers will want to only
    build a specific branch, and using regex helps to isolate particular branches.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the trigger has been successfully set up, commit a code change to the
    `lab-service` trigger. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a comment to the `cloudbuild.yaml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the updated file to `git`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a commit message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Push the change to Cloud Source Repositories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the final command, we use a special regex command to indicate that the change
    refers to the `lab-service` trigger. When we set up the trigger, we used a regular
    expression to only look at branches that were labelled with `lab`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6b20ae0-b5f8-4f50-b66e-bf7c031f3df0.png)'
  prefs: []
  type: TYPE_IMG
- en: Once the code has been committed, checking the Cloud Build History will indicate
    a new build job has commenced. After each Git commit to a branch, our components
    will automatically trigger a build process. Now that we know that the build configuration
    works correctly, let's roll out the same changes to the email and SMS directories.
    We will ensure each build is maintained on a separate branch to minimize the potential
    for code merging.
  prefs: []
  type: TYPE_NORMAL
- en: Triggering email and SMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As per the work we did with the `lab-service` trigger, we need to set up a
    Cloud Build trigger. However, this time, we can just duplicate the existing `lab-service`
    trigger:'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we used a single repository for services. However, in the real
    world, this approach would not be optimal. Instead, I would suggest that a repository
    for each service is used for better code isolation.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/454ea543-1966-489f-9515-32fba1319e4d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To set up the trigger perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the Cloud Console, access Cloud Build (located under the Developer Tools
    options).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the three-dot menu item to open the pop-up menu and select Duplicate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the three-dot menu (of the newly created trigger) item to open the pop-up
    menu and select Edit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set up the trigger with the following information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **Field** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | `trigger-email-service` |'
  prefs: []
  type: TYPE_TB
- en: '| Description | `Push to the email branch` |'
  prefs: []
  type: TYPE_TB
- en: '| Trigger type | `Branch` |'
  prefs: []
  type: TYPE_TB
- en: '| Branch (regex) | `^([eE]mail)/\w+` |'
  prefs: []
  type: TYPE_TB
- en: '| Cloudbuild configuration | `email-service`/`cloudbuild.yaml` |'
  prefs: []
  type: TYPE_TB
- en: '| Substitution variables | N/A |'
  prefs: []
  type: TYPE_TB
- en: Select the Save button at the bottom of the screen to enable the trigger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, do exactly the same again; however, this time, create an SMS trigger using
    the following details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **Field** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | `trigger-sms-service` |'
  prefs: []
  type: TYPE_TB
- en: '| Description | `Push to the sms branch` |'
  prefs: []
  type: TYPE_TB
- en: '| Trigger type | `Branch` |'
  prefs: []
  type: TYPE_TB
- en: '| Branch (regex) | `^([sS]ms)/\w+` |'
  prefs: []
  type: TYPE_TB
- en: '| Cloudbuild configuration | `sms-service`/`cloudbuild.yaml` |'
  prefs: []
  type: TYPE_TB
- en: '| Substitution variables | N/A |'
  prefs: []
  type: TYPE_TB
- en: Select the Save button at the bottom of the screen to enable the trigger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Having created three triggers, the Cloud Build screen should look similar to
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ffe261c-3c94-4a30-beb9-4fdcada44282.png)'
  prefs: []
  type: TYPE_IMG
- en: Each of these triggers operates in isolation using a different branch to signify
    work that's been performed on a specific service. Thanks to our regex filter,
    each branch will be checked and a new build job will be created when code is committed
    to the repository. To make this work, we need to add the `cloudbuild.yaml` file
    to the email and SMS directories to initiate the build process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create some configurations using `cloudbuild.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `email-service` directory, create a new `cloudbuild.yaml` file containing
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If you do not remember how to perform any of these actions in Git, you can review
    the earlier examples on how to use Google Source Repositories. The commands are
    similar; we are just working on a different branch.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new branch in `git` called `email/fix-1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `git` to add the updated `cloudbuild.yaml` file to the `email/fix-1` branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a commit message: `Initial revision - email/fix-1`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the `email/fix-1` branch code to the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `sms-service` directory, create a new `cloudbuild.yaml` file containing
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Create a new branch in `git` called `sms/fix-1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `git` to add the updated `cloudbuild.yaml` file to the `sms/fix-1` branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a commit message: `Initial revision - sms/fix-1`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the `sms/fix-1` branch code to the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pushing the final piece of code automatically initiates Cloud Build and the
    associated three-stage script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations! Using Cloud Build for build process automation increases developer
    productivity. Now that we have integrated a component-based build capability,
    we can move on and look at how to test the multiple components for this solution.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a lab service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Technically, if you need to log information, the correct answer is typically
    Stackdriver as it is already integrated into Google Cloud. However, there are
    instances where you may need an alternative solution – such as in this scenario,
    in which a quick and easy method of checking the services is required.
  prefs: []
  type: TYPE_NORMAL
- en: In this test section, rather than utilizing *Logging* to a centralized system
    such as Stackdriver, we will be posting our data to a Google Sheet. An approach
    such as this can be a very handy technique to know, so it is worth incorporating
    it into our solution to demonstrate how this is achieved.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a high level, the following process is applicable to the test service:'
  prefs: []
  type: TYPE_NORMAL
- en: Write information to sheets
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Application Audit
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Vulnerability Fix
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Take a look at the following diagram in order to understand the components
    involved in this solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f612b6a-d9f0-4058-b840-f5606adc2196.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding diagram, we add a new service component to the existing code
    to log information into a Google spreadsheet. Being able to demonstrate the resilience
    of the solution is a handy feature in order to build into our proof of concept.
    The spreadsheet will be completed by the service; so, if it is working successfully,
    the output will be indicated in the spreadsheet. If the service is unavailable
    for some reason, then an alternative status message is written for the service
    that is unable to complete the task:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0edb504-84bb-436b-adde-80864376f08e.png)'
  prefs: []
  type: TYPE_IMG
- en: The spreadsheet is dynamically linked to each of the services and writes a message
    to a spreadsheet cell when invoked by a service. The new component will provide
    a straightforward method to test each service in isolation and show whether a
    service component is operating to specification. As we now have a description
    of the service and properties, we can begin developing the code base to deliver
    against requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the credentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll begin by accessing the Compute Engine service account:'
  prefs: []
  type: TYPE_NORMAL
- en: 'List the service accounts associated with the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Copy the Compute Engine service account email address listed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a new Google Sheets document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the sheet to `Lab Results Status`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Share button and add the Compute Engine service account email with
    full edit rights.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to set up the email Cloud Pub/Sub subscription.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the email Cloud Pub/Sub subscription
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To set up the email Cloud Pub/Sub subscription, follow these simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a service account with invoking privileges:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Give the service account permissions to invoke the email service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the Google Cloud project number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a role binding of `serviceAccountTokenCreator` using the `PROJECT_NUMBER`
    environment variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the `EMAIL_URL` endpoint for the email service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the Cloud Pub/Sub subscription:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Great work! We have now set up email subscriptions for Cloud Pub/Sub. Next,
    we need to repeat the process for SMS subscriptions.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the SMS Cloud Pub/Sub subscription
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To set up the SMS Cloud Pub/Sub subscription, complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a role binding of `run.invoker`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the `SMS_URL` endpoint for the `sms-service`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the Cloud Pub/Sub subscription:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Fantastic! We have now set up both subscriptions for Cloud Pub/Sub. Next, we
    need to test our services.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, it''s time to test the service. To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the `LAB_URL` endpoint for the `lab-service`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Post some data to the lab report service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, you can see the result of posting information
    to the lab service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c01b7d4-4f0b-4859-99cf-81e0109f30ef.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! The application is now responding to external stimuli.
  prefs: []
  type: TYPE_NORMAL
- en: To test our service for resilience, we need to add an error that will mean the
    service will not be able to process information. For this example, we will use
    the email service to introduce an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change to the `ch12/email-service` subdirectory and edit the `index.js` source
    code – add the erroneous `oops` line entry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Entering the invalid code will ensure the service will not be able to complete
    successfully when invoked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit the updated `email-service` code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code will be automatically built, pushed to the registry, and deployed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, when the application is run, the email service will be unable to complete
    as the erroneous line entry, `oops`, stops the service from working correctly.
    Consequentially, no entries will be written in the spreadsheet. To validate this,
    check the Stackdriver logs to see that an error is shown relating to the defect
    entered.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, correct the source file to remove the code defect to resume normal
    service and have the information successfully logged to the spreadsheet.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! We have now successfully concluded testing the various components.
    We will now provide an overview of this chapter's contents.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the course of this final chapter, we built an application to consume external
    information based on JSON. To our credit, we used a scalable and resilient mechanism
    to handle messaging so that retries occur seamlessly. We also learned how to incorporate
    Google Sheets to output information. A new technique like this has many applications
    and will prove useful time and time again. To complete our application, we also
    looked at developer productivity so that we can use tools such as Cloud Build
    when building multiple components.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, you have learned how to integrate with Google APIs,
    initiate Cloud Pub/Sub, and consume JSON information from external services. Learning
    how to aggregate services is part and parcel of working with serverless on Google
    Cloud. For example, achieving scalable application messaging is simple when using
    Cloud Pub/Sub. Each of the patterns that's been used over the previous chapters
    can easily be enhanced for your own projects. Hopefully, you will be able to create
    the next big thing or encourage your colleagues to build even more awesome products
    on Google Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What products can be used for asynchronous messaging on Google Cloud?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you name some notifications supported by Google Cloud Storage?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are there beta commands for the GCloud SDK?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is regex and why is it useful for creating triggers for branch names?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cloud Source Repositories are project-based. (True or False)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If I wanted to invoke rate limiting on messages, I would use Cloud Tasks over
    Cloud Pub/Sub. (True or False)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where would I be able to see HTTP latency associated with a Cloud Run application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Deploying builds**: [https://cloud.google.com/cloud-build/docs/deploying-builds/deploy-cloud-run](https://cloud.google.com/cloud-build/docs/deploying-builds/deploy-cloud-run)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Docs**: [https://www.google.co.uk/docs/about/](https://www.google.co.uk/docs/about/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stackdriver**: [https://cloud.google.com/stackdriver/](https://cloud.google.com/stackdriver/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cloud Run API**: [https://cloud.google.com/run/docs/reference/rest/](https://cloud.google.com/run/docs/reference/rest/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Troubleshooting Cloud Run – fully managed**: [https://cloud.google.com/run/docs/troubleshooting](https://cloud.google.com/run/docs/troubleshooting)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stackoverflow [google-cloud-run]**: [https://stackoverflow.com/questions/tagged/google-cloud-run](https://stackoverflow.com/questions/tagged/google-cloud-run)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
