- en: Hiera 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hiera 5 is now a fully fledged member of the Puppet ecosystem. We've all been
    using Hiera for several years already, to provide a so-called *separation of concerns* between
    Puppet code and configuration data. Essentially, Hiera lets us separate the *how* (Puppet
    modules and manifests) from the *what* (configuration data). This allows us to
    keep all site-specific and business-specific data out of our manifests, making
    our Puppet modules vastly more portable. I can recall some time ago in the Puppet
    community, when Kelsey Hightower first gave us a presentation about separating
    manifests from data. Well, Hiera 5 finally comes of age in this version, and now
    allows us complete mastery over this aspect of our infrastructure design.
  prefs: []
  type: TYPE_NORMAL
- en: Hiera provides a key/value lookup facility for configuration data, allowing
    external lookups of values, and then exposing that data to Puppet DSL and hence,
    the Puppet compiler. Hiera data is kept in a pluggable database comprised of usually
    nothing more than simple text-based files. What we should aim to achieve is the
    design of a data hierarchy that essentially cascades through our server categories.
    Hiera then searches through all the tiers in this hierarchy, merging all the results
    into either a single value, array, or hash.
  prefs: []
  type: TYPE_NORMAL
- en: Although Hiera typically has a pluggable design, the sources for Hiera data
    are written in easy-to-read YAML. This means that it's often not necessary for
    Puppet developers to always be involved with site configuration, so some server
    configuration can now be done by other, less technical professionals in your organization.
  prefs: []
  type: TYPE_NORMAL
- en: Separation of concerns between code and data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hiera separates Puppet DSL from business data, allowing us to use some of the
    same generic Puppet DSL repeatedly. In fact, as much as 80% of the Puppet DSL
    most organizations use is entirely generic; only the business data varies. Hiera
    allows us to make this full separation of concerns between functionality and business
    data, instead handily passing in the business data to our modules as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Hiera works by first setting business values at the widest catchment (that is,
    site-wide, or *common* in Puppet parlance), and then moving up the hierarchy,
    overriding this global value at the appropriate level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data specific to infrastructure lends itself incredibly well to a hierarchical
    model. Infrastructure always tends to consist of sets of configurable attributes:
    IP addresses, ports, hostnames, and API endpoints. There is a ton of settings
    that we configure within our infrastructures, and most of them are best represented
    hierarchically.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A lot of infrastructure data starts out with a default, let''s say, the DNS
    resolver your data center uses. You first set this as a key-value pair in the
    `common.yaml` data file. After Puppet is first installed, the hierarchy hash inside
    `hiera.conf` provides initially just this common (default) level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Introducing a frame for the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s a typical scenario for Hiera: you find yourself having to override
    the DNS setting for your development environment because that environment can''t
    connect to the production resolver on your network. You then deploy your production
    in a second data center, and you need that location to be different. Hiera allows
    us to model settings such as *the production DNS resolver is* `10.20.1.3`*, and
    the development DNS server is* `10.199.30.2`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To accommodate this type of scenario, we can introduce what''s best described
    as an environment *frame* within the Hiera hierarchy, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The percent-braces `%{variable}` syntax denotes a Hiera interpolation token.
    Wherever you use these interpolation tokens, Hiera will evaluate the variable's
    value and inserts it appropriately into the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: See the Puppet documentation for specifics on the Hiera 5 configuration syntax: [https://puppet.com/docs/puppet/5.3/hiera_config_yaml_5.html#config-file-syntax-hierayaml-v5](https://puppet.com/docs/puppet/5.3/hiera_config_yaml_5.html#config-file-syntax-hierayaml-v5).
  prefs: []
  type: TYPE_NORMAL
- en: If we are using the data `datadir` and using the YAML backend by default, we
    can completely omit the defaults hash, as these are the default settings.
  prefs: []
  type: TYPE_NORMAL
- en: A more complete hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are just handling simple hierarchies, so instead of programming a complex
    conditional statement in Puppet DSL to determine how a DNS resolver gets resolved,
    we can build a hierarchy that best represents our infrastructure, such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5706e98-0264-484d-8955-ceb7b39382dd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This example hierarchy would be represented with the following `hiera.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `facts`, `trusted`, and `server_facts` hashes are the most useful hashes
    to interpolate in `hiera.yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: Note, if you need to reference the node's `fqdn`, use `trusted.certname`. In
    order to reference the environment of a node, the `server_facts.environment` fact
    is available.
  prefs: []
  type: TYPE_NORMAL
- en: See the Puppet documentation for more specifics on interpolation in Hiera: [https://puppet.com/docs/puppet/5.3/hiera_merging.html#interpolation](https://puppet.com/docs/puppet/5.3/hiera_merging.html#interpolation).
  prefs: []
  type: TYPE_NORMAL
- en: Hiera 5 summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s step through some of the key differences between Hiera 3 and Hiera 5
    now, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Global, environment, and module layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypted YAML backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lookup function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging Hiera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global, environment, and module layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The earlier incarnations of Hiera (version 3 or earlier) used a single, entirely
    global `hiera.yaml`. Since its hierarchy is entirely global, it''s not actually
    possible to change it without changing all environments simultaneously. Environments
    are usually used to control code changes, so this really makes a single `hiera.yaml`
    file quite inappropriate. Hiera 5 uses three layers of configuration and data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Global layer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Hiera 3, this was the only layer
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Useful for very temporary overrides, for example, when your operations team
    must bypass regular change processes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The legacy Hiera 3 backends are still supported—so it can be used while migrating
    to Hiera 5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This layer should generally now be avoided. All regular data should now be specified
    in the environment layer
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Environment layer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The environment layer is now where most of the Hiera data definition happens
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Available across all modules in the environment
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Overrides the module layer
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Module layer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we discussed in [Chapter 1](e7bbbeb3-e406-46ea-aad3-20f4af34d014.xhtml),
    *Authoring Modules*, the module layer can now configure default values and merge
    behavior for a module's class parameters. It is a handy alternative to using the
    `params.pp` pattern.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To get the identical behavior, as we are used to with the `params.pp` pattern,
    the `default_hierarchy` setting is advisable, as those bindings aren't in merges.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Data set in the environment layer overrides the default data configured by the
    author of the module.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypted YAML backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Puppet 4.9.3, a `hiera-eyaml` backend was added to the Hiera functionality,
    allowing you to store encrypted data values. So, you can now hide away all your
    secret values, such as passwords, certificates, and so on, rather than using plain
    text in your Hiera data files. Let's go through the steps you can take to get
    this facility up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Installing hiera-eyaml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To set up `eyaml` with Puppet Server, install the `hiera-eyaml` gem with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll also need to install the Ruby gem a second time with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Creating the encryption keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the `eyaml createkeys` command to create the public and private encryption
    keys, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This command will create the public and private keys with their default names
    in the default  `./keys`directory.
  prefs: []
  type: TYPE_NORMAL
- en: Securely storing away the encryption keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now copy the two keys into the `/etc/puppetlabs/puppet/eyaml` directory
    and set up the appropriate permissions, giving the Puppet user ownership, and
    excluding all other users from being able to access the two keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Changing hiera.yaml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Make the following settings in `hiera.yaml` to enable the `hiera-eyaml` backend,
    and provide access to the keys and data files:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the `lookup_key` property to the value `eyaml_lookup_key` in order to use
    the new `eyaml` backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the locations of the encryption keys to the `options` hash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Change all the file paths to `eyaml` rather than YAML file extensions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With this configuration, you can store both encrypted and plaintext keys and
    values into your `eyaml` data files.
  prefs: []
  type: TYPE_NORMAL
- en: Lookup function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s worth mentioning the fact that we should now be using the new `lookup()`
    function in our Puppet DSL to retrieve Hiera values. The `lookup()` function replaces
    the now deprecated set of Hiera functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hiera( )`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hiera_hash( )`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hiera_array( )`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hiera_include( )`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These each have an equivalent way of achieving the same result, so some fairly
    simple find-and-replace work on your Puppet DSL code base will soon have you moving
    away from the deprecated roadmap.
  prefs: []
  type: TYPE_NORMAL
- en: The lookup function syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `lookup` function syntax has three specific styles of usage, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: With mandatory `<name>` and set of three optional arguments: `<value type>`,
    `<merge behavior>` and `<default value>` in that given order and separated by
    commas. For example, `lookup( <name>, [<value type>], [<merge behavior>], [<default
    value>] )`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With optional `<name>`, and mandatory `<options hash>` arguments. For example, `lookup(
    [<name>], <options hash> )`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With mandatory `<name>` and `<lambda expression>` arguments. For example, `lookup(
    <name>, <lambda expression> )`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lookup function arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arguments to the `lookup` function shown in `[ ]` are not mandatory which is
    covered in the preceding section.
  prefs: []
  type: TYPE_NORMAL
- en: '`<name>`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Must be of the data type `string` or `array`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The key name in the Hiera hierarchy to retrieve.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An array of keys may also be provided. If the resulting Hiera lookup doesn't
    provide a result for the first key, it will iteratively try retrievals for the
    subsequently given keys, finally resorting to the default if none of the array
    keys succeed in returning a value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<value type>:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Must be a valid data type
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Hiera lookup (and hence the compilation of the catalog) will fail if the
    datatype of the returned value does not match the data type given here
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Defaults to `Data` (that is, any normal value will not fail the Hiera lookup)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<merge behavior>`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Must be either a `string` or a `hash` (please see the following *Deep merge
    lookup settings explained* section).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Explains whether and how to merge multiple values encountered at different hierarchy
    levels. This overrides the merge behavior that's been specified in the Hiera data
    sources.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Defaults to no value, meaning that, if present, Hiera will first use the merge
    behavior defined in the data sources; otherwise it will simply use the first lookup
    strategy (please see the following *Lookup strategies* section).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<default value>`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If provided, the Hiera lookup will return the value provided here when it cannot
    find a value in the Hiera hierarchy
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The values found by the Hiera lookup are never merged with the given default(s)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `default type` and `value type` must match
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`no value` is the default; meaning that whenever the Hiera lookup cannot retrieve
    a normal value, the Hiera lookup (and hence the compilation) will fail'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As explained in the *The lookup function syntax* section, there''s also an
    alternative way of providing the lookup function arguments, using an `<options
    hash>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<options hash>`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Must be of type `hash`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If using this alternative `<options hash>` style of syntax, you can't combine
    it with any of the preceding regular arguments except `<name>`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Permissible keys for the options hash are as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: Identical to the first `<name>` argument described previously. You
    can pass this either as an argument or in the options `hash`, but not both.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value_type`: Identical to the second `<value type>` argument described previously.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`merge`: This is the same as the third `<merge behavior>` argument described
    previously.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default_value`: This is the same as the fourth `<default_value>` argument
    described previously.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default_values_hash`: This is a hash of lookup keys and their respective default
    values. If a normal value cannot be retrieved from a Hiera lookup, this hash will
    be checked for the key before Hiera gives up. This can be combined with either
    `default_value` or a lambda expression, which will be substituted if the value
    is unable to be retrieved from the Hiera hierarchy. An empty hash is the default.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`override`: This value is a hash of Hiera lookup keys and their respective
    override settings. Hiera checks in the overrides hash for the key; if it is found,
    it returns that value finally, ignoring any merge behavior. An empty hash is the
    default.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, as explained in the *Lookup function syntax* section, there is
    a third alternative to providing the arguments to the `lookup()` function using
    a single lambda expression. If the Hiera lookup is unable to retrieve a value,
    the requested key is passed into the lambda expression, the result of which becomes
    the `default_value`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, `<lambda_expression>` is returning a custom string to provide feedback
    to the user and to handle Hiera being unable to retrieve the required key gracefully
    , which in previous versions of Hiera would fail silently, causing all sorts of
    mischief.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also add our fact values and so on to help the user find the right
    place to insert their key-value pair (please refer to the *A more complete hierarchy* section
    at the beginning of this chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Lookup function examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s just quickly run through the main use cases for the `lookup( )` function,
    also showing the equivalent usages of the old `hiera( )` function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following usage is a completely regular lookup:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following usage is a regular lookup, while providing a default:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following usage is an array lookup:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a deep-merge lookup:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a classification lookup:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Lookup strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The merge strategy is no longer set globally as it was in previous versions
    of Hiera, and this is a big improvement. The valid merge strategies are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`first`: A retrieval of the first match is made; this is equivalent to the
    traditional `hiera()` default behavior'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unique`: This is an array merge, equivalent to the old `hiera_array()` function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hash`: This is equivalent to the old `hiera_hash()` function without deep
    merging enabled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deep`: This is equivalent to the old `hiera_hash()` function with `deeper` merging
    enabled (`deep` is no longer supported)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check the official Hiera 3.3 documentation to understand the concept of deep
    and deeper merges fully: [https://puppet.com/docs/hiera/3.3/lookup_types.html#example](https://puppet.com/docs/hiera/3.3/lookup_types.html#example).
    Note, `deeper` merges in Hiera 3 are equivalent to a `deep` merge in Hiera 4+.'
  prefs: []
  type: TYPE_NORMAL
- en: '`deep` merges are no longer supported.'
  prefs: []
  type: TYPE_NORMAL
- en: Deep merge lookup settings explained
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now look together at these commonly misunderstood merge settings, to make
    sure we have our Hiera know-how at the mastery level.
  prefs: []
  type: TYPE_NORMAL
- en: knockout_prefix setting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is an example of a deep merge, using the `knockout_prefix` setting to
    specify a prefix to indicate a value should be removed from the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are indicating that `mynode.myorg.net.yaml` is not using Paessler
    for monitoring, but rather Nagios. The use of this lookup returns the correct
    value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: sort_merge_arrays setting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We could also sort the merged arrays with the `sort_merge_arrays` setting,
    and remove the data that matches `knockout_prefix`. An array member or entire
    keys can be removed from the resulting hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: merge_hash_arrays setting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If a certain array member contains a hash and you desire these to be merged
    together, this is possible by using the `merge_hash_arrays` setting.
  prefs: []
  type: TYPE_NORMAL
- en: unpack_arrays setting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, there''s the `unpack_arrays` setting. Let us change the data for our
    node again to look as follows, while leaving the common data the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `unpack_arrays` setting takes each string, splits it according to the `,`
    delimiter, creating an array of, in our example, `[“–-paessler”, “nagios”]`, and
    then merging it; in our example knocking out the `paessler` value, since it was
    indicated with the `knockout_prefix` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Debugging Hiera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hiera's data lookups are all done with reference to the details of the node
    being configured, and it's that node's scope which informs Hiera the datasets
    it should select, how to order the data, and how to interpolate certain values.
  prefs: []
  type: TYPE_NORMAL
- en: See the Hiera documentation for more specifics on debugging and the lookup function: [https://puppet.com/docs/puppet/5.3/hiera_quick.html#testing-hiera-data-on-the-command-line](https://puppet.com/docs/puppet/5.3/hiera_quick.html#testing-hiera-data-on-the-command-line) and [https://puppet.com/docs/puppet/5.3/man/lookup.html](https://puppet.com/docs/puppet/5.3/man/lookup.html).
  prefs: []
  type: TYPE_NORMAL
- en: Old debugging techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Previously, we have run `hiera` from the command line with the `–debug` argument,
    and provided the setting, for example, `mysetting`, we would like to look up,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command runs `hiera` in the debug verbosity necessary, but we
    also need to collect the node''s facts and other relevant information (particularly
    the environment and `fqdn`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Another earlier debugging method was to use the `hiera` lookup function inside `puppet
    apply` using the `-e` (execute) argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent debugging technique
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `hiera` command has now been completely replaced with the `puppet lookup`
    command, so we can run the following and use the `--node` argument to provide
    the node to which the lookup pertains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The key difference here is that the `puppet lookup` function will now query
    `puppetdb` to gather all the appropriate facts for the given `node` argument.
  prefs: []
  type: TYPE_NORMAL
- en: We can also now use the `--explain` argument to give a complete description
    of how Hiera fetches the data in its hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond Hiera using Jerakia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you would like to transcend single-customer and small-scale hierarchical
    data classifications and open up the possibilities of modeling larger, more complex
    and diverse environments, you should consider the use of Jerakia ([http://jerakia.io](http://jerakia.io)),
    using Jerakia as a Hiera backend, or configuring Puppet to accept Jerakia as a
    data-binding terminus.
  prefs: []
  type: TYPE_NORMAL
- en: Jerakia advanced use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some questions around advanced use cases for Jerakia:'
  prefs: []
  type: TYPE_NORMAL
- en: How can I use a different Hiera backend for just one module?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can I allow a team the use of a separate hierarchy, exclusively for their
    own application?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can I allow access to a smaller subset of data to a certain user or team?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can I use `eyaml` encryption without being forced to use YAML?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can I implement a dynamic hierarchy rather than hard coding it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can I group together application-specific data into separate YAML files?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jerakia allows us to implement some of these corner cases.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Jerakia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Jerakia is installed from a RubyGem. Simply run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Configuring Jerakia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Set up the `jerakia.yaml` configuration file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the simplest configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If you intend to use encryption, you should also provide the keys in the `private_key`
    and `public_key` settings as indicated.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your default Jerakia policy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All requests for data from Jerakia are processed according to the so-called
    **policy**. The filenames for policies should be the same as the actual name of
    the policy, and are loaded from the directory indicated by the `policydir` setting
    in your `jerakia.yaml` configuration file. If a certain policy name is not indicated
    by the lookup request, then the name `default` is used. Let''s create the default
    policy, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: A Jerakia `policy` is a container of the so-called `lookup`, which is performed
    in the indicated order. A lookup consists of a `datasource` that should be used
    for the data lookup, along with any plugin functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'There follows a simple example, using the `file` data source to provide data
    from simple YAML files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s change the default policy to accommodate settings for another configuration
    team, based in, let''s say, `denmark`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Using Vault as an encryption backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The version 2 release of Jerakia now supports integration with Vault via the
    transit secret backend.
  prefs: []
  type: TYPE_NORMAL
- en: Vault is an open source platform for encrypting, securing, storing, and tightly
    controlling access to passwords, tokens, certificates, and other secret settings
    for your infrastructure. Vault also handles those tricky aspects of secret management,
    such as leasing, rolling, revocation, and auditing.
  prefs: []
  type: TYPE_NORMAL
- en: So, Vault provides something like an *encryption as a service* backend for Jerakia.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Vault
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: See the Vault documentation to install and configure Vault: [https://www.vaultproject.io/docs/install/index.html](https://www.vaultproject.io/docs/install/index.html)
  prefs: []
  type: TYPE_NORMAL
- en: Unsealing Vault
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Follow the procedures in the Vault documentation to unseal Vault: [https://www.vaultproject.io/docs/concepts/seal.html](https://www.vaultproject.io/docs/concepts/seal.html)
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the transit backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enable the transit backend by mounting it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Creating an encryption key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a key Jerakia will use for encrypting and decrypting. By default,
    the key is simply called `jerakia`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Creating a policy for encrypting and decrypting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we need to create a policy which restricts Jerakia to using only the encryption
    and decryption endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to create this policy, we''ll create a new file, `jerakia_policy.hcl`,
    and then import it into Vault using the `policy-write` Vault command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Checking the encryption is working correctly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now try to encrypt a value on the command line using the Jerakia transit
    key and the policy that we''ve just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'See the Vault documentation for more specifics on the `read` and `write` commands:
    [https://www.vaultproject.io/docs/commands/read-write.html](https://www.vaultproject.io/docs/commands/read-write.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Allowing Jerakia to authenticate with our Vault
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AppRole authentication is the recommended method of authenticating with Vault.
  prefs: []
  type: TYPE_NORMAL
- en: When using this authentication method, Jerakia is configured with a role ID
    (`role_id`) and a secret ID (`secret_id`*)*, and Jerakia uses these values to
    acquire a limited-lifetime token from Vault to interact with the API of the transit
    backend.
  prefs: []
  type: TYPE_NORMAL
- en: Upon token expiry, Jerakia will request a new token using `role_id` and `secret_id`
    again.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll create an AppRole for Jerakia, giving it a TTL of 15 minutes.
    This has to be associated with the access policy we created earlier using the
    policies argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can check the Jerakia AppRole and ascertain the `role_id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to create a `secret_id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have `role_id` and `secret_id`, we can proceed to integrate Jerakia
    with Vault.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Jerakia for encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `jerakia.yaml` configuration file, we configure the encryption option
    with a provider of Vault and the specific configuration that our provider requires:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We should now be able to `encrypt` and `decrypt` using Jerakia:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Encryption-enabling our Jerakia lookups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We enable encryption by using the `output_filter` method to our lookup in our
    policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This instructs Jerakia to pass everything to the encryption filter and to match
    all the retrieved values against the signature of the encryption provider. If
    a match is made, the encryption provider will be used to decrypt the value before
    it is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have taken a close look at the main differences between
    Hiera 5 and its earlier incarnations. We have also described how you can now quickly
    set up the encrypted YAML backend, so you no longer have to save your secret Hiera
    values in plain text.
  prefs: []
  type: TYPE_NORMAL
- en: We've also looked at Jerakia, which you can use to cover more advanced use cases,
    such as providing different hierarchies to different teams, and integrating Vault
    to provide something like an *encryption as a service* backend for Jerakia.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, let's continue our master class by examining the management
    of Puppet code.
  prefs: []
  type: TYPE_NORMAL
