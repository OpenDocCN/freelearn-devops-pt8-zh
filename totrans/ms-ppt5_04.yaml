- en: Hiera 5
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hiera 5
- en: Hiera 5 is now a fully fledged member of the Puppet ecosystem. We've all been
    using Hiera for several years already, to provide a so-called *separation of concerns* between
    Puppet code and configuration data. Essentially, Hiera lets us separate the *how* (Puppet
    modules and manifests) from the *what* (configuration data). This allows us to
    keep all site-specific and business-specific data out of our manifests, making
    our Puppet modules vastly more portable. I can recall some time ago in the Puppet
    community, when Kelsey Hightower first gave us a presentation about separating
    manifests from data. Well, Hiera 5 finally comes of age in this version, and now
    allows us complete mastery over this aspect of our infrastructure design.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Hiera 5 现在已成为 Puppet 生态系统的一个完全成熟的成员。我们已经使用 Hiera 好几年了，用于实现 Puppet 代码和配置数据之间的所谓*关注点分离*。本质上，Hiera
    使我们能够将*如何做*（Puppet 模块和清单）与*做什么*（配置数据）分离。这使我们能够将所有特定站点和业务的数据与我们的清单分开，从而使我们的 Puppet
    模块更加可移植。我记得很久以前，Kelsey Hightower 在 Puppet 社区中首次给我们做了一个关于将清单与数据分离的演讲。好吧，Hiera 5
    在这个版本中终于成熟了，现在可以让我们完全掌握这一基础设施设计方面的工作。
- en: Hiera provides a key/value lookup facility for configuration data, allowing
    external lookups of values, and then exposing that data to Puppet DSL and hence,
    the Puppet compiler. Hiera data is kept in a pluggable database comprised of usually
    nothing more than simple text-based files. What we should aim to achieve is the
    design of a data hierarchy that essentially cascades through our server categories.
    Hiera then searches through all the tiers in this hierarchy, merging all the results
    into either a single value, array, or hash.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Hiera 提供了一个用于配置数据的键/值查找功能，允许外部查找值，然后将这些数据暴露给 Puppet DSL，从而传递给 Puppet 编译器。Hiera
    数据保存在一个可插拔的数据库中，通常只包含简单的文本文件。我们应该努力实现的是设计一个数据层次结构，基本上通过我们的服务器类别级联。Hiera 然后会在这个层次结构中的所有层级中搜索，将所有结果合并成一个单一值、数组或哈希。
- en: Although Hiera typically has a pluggable design, the sources for Hiera data
    are written in easy-to-read YAML. This means that it's often not necessary for
    Puppet developers to always be involved with site configuration, so some server
    configuration can now be done by other, less technical professionals in your organization.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Hiera 通常具有可插拔设计，但 Hiera 数据的来源是用易读的 YAML 编写的。这意味着 Puppet 开发人员通常不需要始终参与站点配置，因此一些服务器配置现在可以由你组织中的其他、技术要求较低的专业人员来完成。
- en: Separation of concerns between code and data
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码和数据的关注点分离
- en: Hiera separates Puppet DSL from business data, allowing us to use some of the
    same generic Puppet DSL repeatedly. In fact, as much as 80% of the Puppet DSL
    most organizations use is entirely generic; only the business data varies. Hiera
    allows us to make this full separation of concerns between functionality and business
    data, instead handily passing in the business data to our modules as parameters.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Hiera 将 Puppet DSL 与业务数据分开，使我们能够反复使用一些相同的通用 Puppet DSL。事实上，大多数组织使用的 Puppet DSL
    中，约 80% 是完全通用的；只有业务数据有所不同。Hiera 使我们能够实现功能和业务数据之间的完全关注点分离，而是将业务数据方便地作为参数传递给我们的模块。
- en: Hiera works by first setting business values at the widest catchment (that is,
    site-wide, or *common* in Puppet parlance), and then moving up the hierarchy,
    overriding this global value at the appropriate level.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Hiera 的工作原理是首先在最广泛的范围内设置业务值（即在整个站点范围内，或在 Puppet 术语中称为*common*），然后向上移动层次结构，在适当的级别覆盖这个全局值。
- en: 'Data specific to infrastructure lends itself incredibly well to a hierarchical
    model. Infrastructure always tends to consist of sets of configurable attributes:
    IP addresses, ports, hostnames, and API endpoints. There is a ton of settings
    that we configure within our infrastructures, and most of them are best represented
    hierarchically.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 专门针对基础设施的数据非常适合使用层次模型。基础设施通常由一组可配置的属性组成：IP 地址、端口、主机名和 API 端点。我们在基础设施中配置了大量设置，其中大多数最好通过层次结构表示。
- en: 'A lot of infrastructure data starts out with a default, let''s say, the DNS
    resolver your data center uses. You first set this as a key-value pair in the
    `common.yaml` data file. After Puppet is first installed, the hierarchy hash inside
    `hiera.conf` provides initially just this common (default) level:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 很多基础设施数据都有一个默认值，例如，数据中心使用的 DNS 解析器。你首先将其作为键值对设置在 `common.yaml` 数据文件中。在 Puppet
    初次安装后，`hiera.conf` 中的层次结构哈希最初仅提供这个常见（默认）级别：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Introducing a frame for the environment
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入环境框架
- en: 'Here''s a typical scenario for Hiera: you find yourself having to override
    the DNS setting for your development environment because that environment can''t
    connect to the production resolver on your network. You then deploy your production
    in a second data center, and you need that location to be different. Hiera allows
    us to model settings such as *the production DNS resolver is* `10.20.1.3`*, and
    the development DNS server is* `10.199.30.2`.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Hiera 的一个典型场景：你可能需要覆盖开发环境的 DNS 设置，因为该环境无法连接到网络中的生产解析器。然后你在第二数据中心部署生产环境，并且需要该位置有所不同。Hiera
    允许我们建模像是 *生产 DNS 解析器是* `10.20.1.3`*，而开发 DNS 服务器是* `10.199.30.2` 的设置。
- en: 'To accommodate this type of scenario, we can introduce what''s best described
    as an environment *frame* within the Hiera hierarchy, as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应这种场景，我们可以在 Hiera 层次结构中引入最好的环境 *框架*，如下所示：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The percent-braces `%{variable}` syntax denotes a Hiera interpolation token.
    Wherever you use these interpolation tokens, Hiera will evaluate the variable's
    value and inserts it appropriately into the hierarchy.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 百分号括号 `%{variable}` 语法表示 Hiera 插值标记。无论你在哪里使用这些插值标记，Hiera 都会评估变量的值，并将其适当地插入到层次结构中。
- en: See the Puppet documentation for specifics on the Hiera 5 configuration syntax: [https://puppet.com/docs/puppet/5.3/hiera_config_yaml_5.html#config-file-syntax-hierayaml-v5](https://puppet.com/docs/puppet/5.3/hiera_config_yaml_5.html#config-file-syntax-hierayaml-v5).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看 Puppet 文档，了解 Hiera 5 配置语法的具体细节：[https://puppet.com/docs/puppet/5.3/hiera_config_yaml_5.html#config-file-syntax-hierayaml-v5](https://puppet.com/docs/puppet/5.3/hiera_config_yaml_5.html#config-file-syntax-hierayaml-v5)。
- en: If we are using the data `datadir` and using the YAML backend by default, we
    can completely omit the defaults hash, as these are the default settings.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用数据 `datadir` 并且默认使用 YAML 后端，我们可以完全省略 defaults 哈希，因为这些是默认设置。
- en: A more complete hierarchy
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个更完整的层次结构
- en: 'We are just handling simple hierarchies, so instead of programming a complex
    conditional statement in Puppet DSL to determine how a DNS resolver gets resolved,
    we can build a hierarchy that best represents our infrastructure, such as the
    following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只处理简单的层次结构，因此我们可以构建一个最能代表我们基础设施的层次结构，例如以下内容，而不是在 Puppet DSL 中编写复杂的条件语句来确定如何解析
    DNS 解析器：
- en: '![](img/a5706e98-0264-484d-8955-ceb7b39382dd.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5706e98-0264-484d-8955-ceb7b39382dd.png)'
- en: 'This example hierarchy would be represented with the following `hiera.yaml`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例层次结构将通过以下 `hiera.yaml` 表示：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `facts`, `trusted`, and `server_facts` hashes are the most useful hashes
    to interpolate in `hiera.yaml`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`facts`、`trusted` 和 `server_facts` 哈希是最有用的可在 `hiera.yaml` 中插值的哈希。'
- en: Note, if you need to reference the node's `fqdn`, use `trusted.certname`. In
    order to reference the environment of a node, the `server_facts.environment` fact
    is available.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你需要引用节点的 `fqdn`，请使用 `trusted.certname`。为了引用节点的环境，`server_facts.environment`
    事实是可用的。
- en: See the Puppet documentation for more specifics on interpolation in Hiera: [https://puppet.com/docs/puppet/5.3/hiera_merging.html#interpolation](https://puppet.com/docs/puppet/5.3/hiera_merging.html#interpolation).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看 Puppet 文档，了解关于 Hiera 插值的更多细节：[https://puppet.com/docs/puppet/5.3/hiera_merging.html#interpolation](https://puppet.com/docs/puppet/5.3/hiera_merging.html#interpolation)。
- en: Hiera 5 summary
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hiera 5 概要
- en: 'Let''s step through some of the key differences between Hiera 3 and Hiera 5
    now, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在一步步来看一下 Hiera 3 和 Hiera 5 之间的一些关键区别，具体如下：
- en: Global, environment, and module layers
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局、环境和模块层
- en: Encrypted YAML backend
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密的 YAML 后端
- en: Lookup function
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找函数
- en: Debugging Hiera
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试 Hiera
- en: Global, environment, and module layers
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局、环境和模块层
- en: 'The earlier incarnations of Hiera (version 3 or earlier) used a single, entirely
    global `hiera.yaml`. Since its hierarchy is entirely global, it''s not actually
    possible to change it without changing all environments simultaneously. Environments
    are usually used to control code changes, so this really makes a single `hiera.yaml`
    file quite inappropriate. Hiera 5 uses three layers of configuration and data:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Hiera 的早期版本（版本 3 或更早）使用单一的、完全全局的 `hiera.yaml`。由于其层次结构完全是全局的，实际上不可能在不同时改变所有环境的情况下更改它。环境通常用于控制代码更改，因此这使得单一的
    `hiera.yaml` 文件非常不适合。Hiera 5 使用三层配置和数据：
- en: 'Global layer:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局层：
- en: In Hiera 3, this was the only layer
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Hiera 3 中，这是唯一的层次
- en: Useful for very temporary overrides, for example, when your operations team
    must bypass regular change processes
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于非常临时的覆盖非常有用，例如，当你的运维团队必须绕过常规的变更流程时
- en: The legacy Hiera 3 backends are still supported—so it can be used while migrating
    to Hiera 5
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仍然支持遗留的 Hiera 3 后端——因此在迁移到 Hiera 5 的过程中可以继续使用。
- en: This layer should generally now be avoided. All regular data should now be specified
    in the environment layer
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在应该避免使用这个层。所有常规数据应该在环境层中指定。
- en: 'Environment layer:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境层：
- en: The environment layer is now where most of the Hiera data definition happens
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境层现在是大多数 Hiera 数据定义发生的地方。
- en: Available across all modules in the environment
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在环境中的所有模块可用
- en: Overrides the module layer
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖模块层
- en: 'Module layer:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块层：
- en: As we discussed in [Chapter 1](e7bbbeb3-e406-46ea-aad3-20f4af34d014.xhtml),
    *Authoring Modules*, the module layer can now configure default values and merge
    behavior for a module's class parameters. It is a handy alternative to using the
    `params.pp` pattern.
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](e7bbbeb3-e406-46ea-aad3-20f4af34d014.xhtml)《模块编写》中讨论的那样，模块层现在可以为模块的类参数配置默认值和合并行为。这是一个非常方便的替代方案，代替使用`params.pp`模式。
- en: To get the identical behavior, as we are used to with the `params.pp` pattern,
    the `default_hierarchy` setting is advisable, as those bindings aren't in merges.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了实现我们习惯的`params.pp`模式的相同行为，建议使用`default_hierarchy`设置，因为这些绑定在合并中并不包含。
- en: Data set in the environment layer overrides the default data configured by the
    author of the module.
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在环境层中的数据集会覆盖模块作者配置的默认数据。
- en: Encrypted YAML backend
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密的 YAML 后端
- en: In Puppet 4.9.3, a `hiera-eyaml` backend was added to the Hiera functionality,
    allowing you to store encrypted data values. So, you can now hide away all your
    secret values, such as passwords, certificates, and so on, rather than using plain
    text in your Hiera data files. Let's go through the steps you can take to get
    this facility up and running.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puppet 4.9.3 中，添加了`hiera-eyaml`后端到 Hiera 功能中，这样你就可以存储加密的数据值。这样，你现在可以隐藏所有的秘密值，如密码、证书等，而不是在
    Hiera 数据文件中使用纯文本。接下来，让我们一步步介绍如何启用这一功能。
- en: Installing hiera-eyaml
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 hiera-eyaml
- en: 'To set up `eyaml` with Puppet Server, install the `hiera-eyaml` gem with the
    following command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Puppet Server 设置`eyaml`，可以通过以下命令安装`hiera-eyaml` gem：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You''ll also need to install the Ruby gem a second time with the following
    command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要第二次使用以下命令安装 Ruby gem：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Creating the encryption keys
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建加密密钥
- en: 'Use the `eyaml createkeys` command to create the public and private encryption
    keys, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`eyaml createkeys`命令创建公钥和私钥，如下所示：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This command will create the public and private keys with their default names
    in the default  `./keys`directory.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在默认的`./keys`目录中创建公钥和私钥，并使用默认名称。
- en: Securely storing away the encryption keys
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全地存储加密密钥
- en: 'Let''s now copy the two keys into the `/etc/puppetlabs/puppet/eyaml` directory
    and set up the appropriate permissions, giving the Puppet user ownership, and
    excluding all other users from being able to access the two keys:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将两个密钥复制到`/etc/puppetlabs/puppet/eyaml`目录，并设置适当的权限，赋予 Puppet 用户所有权，并排除所有其他用户无法访问这两个密钥：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Changing hiera.yaml
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改 hiera.yaml
- en: 'Make the following settings in `hiera.yaml` to enable the `hiera-eyaml` backend,
    and provide access to the keys and data files:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在`hiera.yaml`中进行以下设置，以启用`hiera-eyaml`后端，并提供对密钥和数据文件的访问：
- en: Set the `lookup_key` property to the value `eyaml_lookup_key` in order to use
    the new `eyaml` backend
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置`lookup_key`属性为`eyaml_lookup_key`，以便使用新的`eyaml`后端。
- en: Add the locations of the encryption keys to the `options` hash
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将加密密钥的位置添加到`options`哈希中
- en: 'Change all the file paths to `eyaml` rather than YAML file extensions:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有的文件路径更改为`eyaml`，而不是 YAML 文件扩展名：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With this configuration, you can store both encrypted and plaintext keys and
    values into your `eyaml` data files.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此配置，你可以将加密和纯文本的密钥和值存储到`eyaml`数据文件中。
- en: Lookup function
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找函数
- en: 'It''s worth mentioning the fact that we should now be using the new `lookup()`
    function in our Puppet DSL to retrieve Hiera values. The `lookup()` function replaces
    the now deprecated set of Hiera functions:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，我们现在应该在 Puppet DSL 中使用新的`lookup()`函数来获取 Hiera 值。`lookup()`函数替代了现在已废弃的一组
    Hiera 函数：
- en: '`hiera( )`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hiera( )`'
- en: '`hiera_hash( )`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hiera_hash( )`'
- en: '`hiera_array( )`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hiera_array( )`'
- en: '`hiera_include( )`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hiera_include( )`'
- en: These each have an equivalent way of achieving the same result, so some fairly
    simple find-and-replace work on your Puppet DSL code base will soon have you moving
    away from the deprecated roadmap.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些每一个都有一种等效的方式来实现相同的结果，因此对 Puppet DSL 代码库做一些简单的查找和替换工作，很快你就能摆脱已废弃的路线。
- en: The lookup function syntax
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找函数语法
- en: 'The `lookup` function syntax has three specific styles of usage, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`lookup` 函数语法有三种特定的使用方式，如下所示：  '
- en: With mandatory `<name>` and set of three optional arguments: `<value type>`,
    `<merge behavior>` and `<default value>` in that given order and separated by
    commas. For example, `lookup( <name>, [<value type>], [<merge behavior>], [<default
    value>] )`.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '必须包含强制性的 `<name>` 和三种可选参数：`<value type>`、`<merge behavior>` 和 `<default value>`，按照给定顺序并以逗号分隔。例如，`lookup(
    <name>, [<value type>], [<merge behavior>], [<default value>] )`。  '
- en: With optional `<name>`, and mandatory `<options hash>` arguments. For example, `lookup(
    [<name>], <options hash> )`.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '必须包含可选的 `<name>` 和强制性的 `<options hash>` 参数。例如，`lookup( [<name>], <options hash>
    )`。  '
- en: With mandatory `<name>` and `<lambda expression>` arguments. For example, `lookup(
    <name>, <lambda expression> )`.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '必须包含 `<name>` 和 `<lambda expression>` 参数。例如，`lookup( <name>, <lambda expression>
    )`。  '
- en: Lookup function arguments
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '查找函数参数  '
- en: Arguments to the `lookup` function shown in `[ ]` are not mandatory which is
    covered in the preceding section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '显示在 `[ ]` 中的 `lookup` 函数参数不是强制性的，如前一部分所述。  '
- en: '`<name>`:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<name>`：  '
- en: Must be of the data type `string` or `array`.
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '必须是 `string` 或 `array` 类型。  '
- en: The key name in the Hiera hierarchy to retrieve.
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在 Hiera 层级中要检索的键名。  '
- en: An array of keys may also be provided. If the resulting Hiera lookup doesn't
    provide a result for the first key, it will iteratively try retrievals for the
    subsequently given keys, finally resorting to the default if none of the array
    keys succeed in returning a value.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '也可以提供一个包含多个键的数组。如果最终的 Hiera 查找无法为第一个键返回结果，它将依次尝试后续给定键的查找，最后如果数组中的键都没有返回值，则回退到默认值。  '
- en: '`<value type>:`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<value type>`：  '
- en: Must be a valid data type
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '必须是有效的数据类型  '
- en: The Hiera lookup (and hence the compilation of the catalog) will fail if the
    datatype of the returned value does not match the data type given here
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果返回值的数据类型与此处给定的数据类型不匹配，Hiera 查找（因此目录编译）将会失败。  '
- en: Defaults to `Data` (that is, any normal value will not fail the Hiera lookup)
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '默认为 `Data`（即任何正常值不会使 Hiera 查找失败）  '
- en: '`<merge behavior>`:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<merge behavior>`：  '
- en: Must be either a `string` or a `hash` (please see the following *Deep merge
    lookup settings explained* section).
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '必须是 `string` 或 `hash` 类型（请参阅以下 *深度合并查找设置说明* 部分）。  '
- en: Explains whether and how to merge multiple values encountered at different hierarchy
    levels. This overrides the merge behavior that's been specified in the Hiera data
    sources.
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '解释是否以及如何合并在不同层级遇到的多个值。这将覆盖在 Hiera 数据源中指定的合并行为。  '
- en: Defaults to no value, meaning that, if present, Hiera will first use the merge
    behavior defined in the data sources; otherwise it will simply use the first lookup
    strategy (please see the following *Lookup strategies* section).
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '默认为无值，意味着如果存在，Hiera 将首先使用在数据源中定义的合并行为；否则，它将简单地使用第一个查找策略（请参阅以下 *查找策略* 部分）。  '
- en: '`<default value>`:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<default value>`：  '
- en: If provided, the Hiera lookup will return the value provided here when it cannot
    find a value in the Hiera hierarchy
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果提供，当 Hiera 查找无法在 Hiera 层级找到值时，查找将返回此处提供的值。  '
- en: The values found by the Hiera lookup are never merged with the given default(s)
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Hiera 查找找到的值从不与给定的默认值合并。  '
- en: The `default type` and `value type` must match
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default type` 和 `value type` 必须匹配  '
- en: '`no value` is the default; meaning that whenever the Hiera lookup cannot retrieve
    a normal value, the Hiera lookup (and hence the compilation) will fail'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`no value` 是默认值；意味着每当 Hiera 查找无法检索到正常值时，Hiera 查找（因此编译）将会失败。  '
- en: 'As explained in the *The lookup function syntax* section, there''s also an
    alternative way of providing the lookup function arguments, using an `<options
    hash>`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '如 *查找函数语法* 部分所述，也可以使用 `<options hash>` 提供查找函数参数：  '
- en: '`<options hash>`:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<options hash>`：  '
- en: Must be of type `hash`
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '必须是 `hash` 类型  '
- en: If using this alternative `<options hash>` style of syntax, you can't combine
    it with any of the preceding regular arguments except `<name>`
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果使用这种替代的 `<options hash>` 语法样式，则不能与任何前面的常规参数结合使用，除了 `<name>`。  '
- en: 'Permissible keys for the options hash are as follows:'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '可用的选项哈希键如下：  '
- en: '`name`: Identical to the first `<name>` argument described previously. You
    can pass this either as an argument or in the options `hash`, but not both.'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：与前面描述的第一个 `<name>` 参数相同。你可以将其作为参数传递或放在选项 `hash` 中，但不能同时使用两者。'
- en: '`value_type`: Identical to the second `<value type>` argument described previously.'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value_type`：与前面描述的第二个 `<value type>` 参数相同。  '
- en: '`merge`: This is the same as the third `<merge behavior>` argument described
    previously.'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`merge`：这与之前描述的第三个 `<merge behavior>` 参数相同。'
- en: '`default_value`: This is the same as the fourth `<default_value>` argument
    described previously.'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default_value`：这与之前描述的第四个 `<default_value>` 参数相同。'
- en: '`default_values_hash`: This is a hash of lookup keys and their respective default
    values. If a normal value cannot be retrieved from a Hiera lookup, this hash will
    be checked for the key before Hiera gives up. This can be combined with either
    `default_value` or a lambda expression, which will be substituted if the value
    is unable to be retrieved from the Hiera hierarchy. An empty hash is the default.'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default_values_hash`：这是一个查找键及其相应默认值的哈希表。如果无法从 Hiera 查找中检索到正常值，则在 Hiera 放弃之前会检查该哈希表中的键。可以将其与
    `default_value` 或 lambda 表达式结合使用，如果无法从 Hiera 层次结构中检索到值，将替换为该值。空哈希表是默认值。'
- en: '`override`: This value is a hash of Hiera lookup keys and their respective
    override settings. Hiera checks in the overrides hash for the key; if it is found,
    it returns that value finally, ignoring any merge behavior. An empty hash is the
    default.'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`override`：该值是一个包含 Hiera 查找键及其相应重写设置的哈希表。Hiera 在重写哈希表中查找该键；如果找到，它最终返回该值，忽略任何合并行为。空哈希表是默认值。'
- en: 'Additionally, as explained in the *Lookup function syntax* section, there is
    a third alternative to providing the arguments to the `lookup()` function using
    a single lambda expression. If the Hiera lookup is unable to retrieve a value,
    the requested key is passed into the lambda expression, the result of which becomes
    the `default_value`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如在 *查找函数语法* 部分所解释的，提供 `lookup()` 函数参数的第三种方式是使用单个 lambda 表达式。如果 Hiera 查找无法检索到值，请将请求的键传递给
    lambda 表达式，lambda 表达式的结果将成为 `default_value`：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, `<lambda_expression>` is returning a custom string to provide feedback
    to the user and to handle Hiera being unable to retrieve the required key gracefully
    , which in previous versions of Hiera would fail silently, causing all sorts of
    mischief.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<lambda_expression>` 返回一个自定义字符串，向用户提供反馈，并优雅地处理 Hiera 无法检索所需键的情况，而在 Hiera
    的早期版本中，如果检索失败，它会静默失败，导致各种问题。
- en: 'We could also add our fact values and so on to help the user find the right
    place to insert their key-value pair (please refer to the *A more complete hierarchy* section
    at the beginning of this chapter):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以添加我们的事实值等，帮助用户找到合适的位置来插入他们的键值对（请参考本章开头的 *更完整的层次结构* 部分）：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Lookup function examples
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找函数示例
- en: 'Let''s just quickly run through the main use cases for the `lookup( )` function,
    also showing the equivalent usages of the old `hiera( )` function:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览一下 `lookup()` 函数的主要用例，同时展示旧的 `hiera()` 函数的等效用法：
- en: 'The following usage is a completely regular lookup:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下用法是一个完全常规的查找：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following usage is a regular lookup, while providing a default:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下用法是常规查找，同时提供默认值：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following usage is an array lookup:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下用法是数组查找：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following is a deep-merge lookup:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是一个深度合并查找：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following is a classification lookup:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是一个分类查找：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Lookup strategies
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找策略
- en: 'The merge strategy is no longer set globally as it was in previous versions
    of Hiera, and this is a big improvement. The valid merge strategies are as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 合并策略不再像早期版本的 Hiera 那样在全局范围内设置，这是一个很大的改进。有效的合并策略如下：
- en: '`first`: A retrieval of the first match is made; this is equivalent to the
    traditional `hiera()` default behavior'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first`：检索第一个匹配项；这等同于传统的 `hiera()` 默认行为。'
- en: '`unique`: This is an array merge, equivalent to the old `hiera_array()` function'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unique`：这是一个数组合并，相当于旧的 `hiera_array()` 函数。'
- en: '`hash`: This is equivalent to the old `hiera_hash()` function without deep
    merging enabled'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hash`：这相当于没有启用深度合并的旧 `hiera_hash()` 函数。'
- en: '`deep`: This is equivalent to the old `hiera_hash()` function with `deeper` merging
    enabled (`deep` is no longer supported)'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deep`：这等同于启用了 `deeper` 合并的旧 `hiera_hash()` 函数（`deep` 不再被支持）'
- en: 'Check the official Hiera 3.3 documentation to understand the concept of deep
    and deeper merges fully: [https://puppet.com/docs/hiera/3.3/lookup_types.html#example](https://puppet.com/docs/hiera/3.3/lookup_types.html#example).
    Note, `deeper` merges in Hiera 3 are equivalent to a `deep` merge in Hiera 4+.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅官方的 Hiera 3.3 文档，深入理解深度合并和更深合并的概念：[https://puppet.com/docs/hiera/3.3/lookup_types.html#example](https://puppet.com/docs/hiera/3.3/lookup_types.html#example)。请注意，Hiera
    3 中的 `deeper` 合并相当于 Hiera 4+ 中的 `deep` 合并。
- en: '`deep` merges are no longer supported.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`deep` 合并不再被支持。'
- en: Deep merge lookup settings explained
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度合并查找设置说明
- en: Let's now look together at these commonly misunderstood merge settings, to make
    sure we have our Hiera know-how at the mastery level.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们一起看看这些常常被误解的合并设置，以确保我们掌握Hiera的使用技巧。
- en: knockout_prefix setting
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: knockout_prefix设置
- en: 'Here is an example of a deep merge, using the `knockout_prefix` setting to
    specify a prefix to indicate a value should be removed from the result:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个深度合并的示例，使用`knockout_prefix`设置指定一个前缀，用于指示某个值应该从结果中移除：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we are indicating that `mynode.myorg.net.yaml` is not using Paessler
    for monitoring, but rather Nagios. The use of this lookup returns the correct
    value, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们表示`mynode.myorg.net.yaml`并没有使用Paessler进行监控，而是使用了Nagios。这个查找会返回正确的值，如下所示：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: sort_merge_arrays setting
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sort_merge_arrays设置
- en: 'We could also sort the merged arrays with the `sort_merge_arrays` setting,
    and remove the data that matches `knockout_prefix`. An array member or entire
    keys can be removed from the resulting hash:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过`sort_merge_arrays`设置对合并后的数组进行排序，并移除匹配`knockout_prefix`的数据。可以从结果哈希中移除数组成员或整个键：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: merge_hash_arrays setting
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: merge_hash_arrays设置
- en: If a certain array member contains a hash and you desire these to be merged
    together, this is possible by using the `merge_hash_arrays` setting.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个数组成员包含一个哈希，并且你希望将这些内容合并在一起，可以通过使用`merge_hash_arrays`设置来实现。
- en: unpack_arrays setting
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: unpack_arrays设置
- en: 'Finally, there''s the `unpack_arrays` setting. Let us change the data for our
    node again to look as follows, while leaving the common data the same:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有`unpack_arrays`设置。让我们再次修改节点的数据，保持公共数据不变，修改后的数据如下：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `unpack_arrays` setting takes each string, splits it according to the `,`
    delimiter, creating an array of, in our example, `[“–-paessler”, “nagios”]`, and
    then merging it; in our example knocking out the `paessler` value, since it was
    indicated with the `knockout_prefix` as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`unpack_arrays`设置会将每个字符串根据`,`分隔符拆分，创建一个数组，例如`[“–-paessler”, “nagios”]`，然后将其合并；在我们的示例中，`paessler`值会被移除，因为它是通过`knockout_prefix`设置标记的，如下所示：'
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Debugging Hiera
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试Hiera
- en: Hiera's data lookups are all done with reference to the details of the node
    being configured, and it's that node's scope which informs Hiera the datasets
    it should select, how to order the data, and how to interpolate certain values.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Hiera的数据查找都是基于被配置节点的详细信息进行的，正是这个节点的作用域告知Hiera应选择哪些数据集，如何排序数据，以及如何插值某些值。
- en: See the Hiera documentation for more specifics on debugging and the lookup function: [https://puppet.com/docs/puppet/5.3/hiera_quick.html#testing-hiera-data-on-the-command-line](https://puppet.com/docs/puppet/5.3/hiera_quick.html#testing-hiera-data-on-the-command-line) and [https://puppet.com/docs/puppet/5.3/man/lookup.html](https://puppet.com/docs/puppet/5.3/man/lookup.html).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Hiera文档，获取更多关于调试和查找功能的详细信息：[https://puppet.com/docs/puppet/5.3/hiera_quick.html#testing-hiera-data-on-the-command-line](https://puppet.com/docs/puppet/5.3/hiera_quick.html#testing-hiera-data-on-the-command-line)
    和 [https://puppet.com/docs/puppet/5.3/man/lookup.html](https://puppet.com/docs/puppet/5.3/man/lookup.html)。
- en: Old debugging techniques
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旧的调试技巧
- en: 'Previously, we have run `hiera` from the command line with the `–debug` argument,
    and provided the setting, for example, `mysetting`, we would like to look up,
    as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们曾通过命令行运行`hiera`并使用`–debug`参数，提供了设置（例如，`mysetting`）来查找，如下所示：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding command runs `hiera` in the debug verbosity necessary, but we
    also need to collect the node''s facts and other relevant information (particularly
    the environment and `fqdn`):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令以所需的调试详细级别运行`hiera`，但我们还需要收集节点的事实信息以及其他相关数据（特别是环境和`fqdn`）：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Another earlier debugging method was to use the `hiera` lookup function inside `puppet
    apply` using the `-e` (execute) argument:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种早期的调试方法是使用`hiera`查找功能，通过`puppet apply`使用`-e`（执行）参数：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Equivalent debugging technique
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等效的调试技巧
- en: 'The `hiera` command has now been completely replaced with the `puppet lookup`
    command, so we can run the following and use the `--node` argument to provide
    the node to which the lookup pertains:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`hiera`命令现已完全被`puppet lookup`命令取代，因此我们可以运行以下命令，并使用`--node`参数来提供查找所涉及的节点：'
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The key difference here is that the `puppet lookup` function will now query
    `puppetdb` to gather all the appropriate facts for the given `node` argument.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要区别是，`puppet lookup`功能现在会查询`puppetdb`，以收集与给定`node`参数相关的所有事实数据。
- en: We can also now use the `--explain` argument to give a complete description
    of how Hiera fetches the data in its hierarchy.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在还可以使用 `--explain` 参数来详细描述 Hiera 如何在其层级中获取数据。
- en: Beyond Hiera using Jerakia
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越 Hiera 使用 Jerakia
- en: If you would like to transcend single-customer and small-scale hierarchical
    data classifications and open up the possibilities of modeling larger, more complex
    and diverse environments, you should consider the use of Jerakia ([http://jerakia.io](http://jerakia.io)),
    using Jerakia as a Hiera backend, or configuring Puppet to accept Jerakia as a
    data-binding terminus.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想超越单一客户和小规模的层级数据分类，并开辟更大、更复杂、多样化环境建模的可能性，你应该考虑使用 Jerakia（[http://jerakia.io](http://jerakia.io)），将
    Jerakia 用作 Hiera 后端，或者配置 Puppet 接受 Jerakia 作为数据绑定终端。
- en: Jerakia advanced use cases
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jerakia 高级用例
- en: 'Here are some questions around advanced use cases for Jerakia:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于 Jerakia 高级用例的一些问题：
- en: How can I use a different Hiera backend for just one module?
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我该如何仅为某个模块使用不同的 Hiera 后端？
- en: How can I allow a team the use of a separate hierarchy, exclusively for their
    own application?
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我该如何允许某个团队使用独立的层级，仅用于他们自己的应用程序？
- en: How can I allow access to a smaller subset of data to a certain user or team?
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我该如何允许某个用户或团队访问更小范围的数据？
- en: How can I use `eyaml` encryption without being forced to use YAML?
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我该如何在不强制使用 YAML 的情况下使用 `eyaml` 加密？
- en: How can I implement a dynamic hierarchy rather than hard coding it?
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我该如何实现一个动态层级，而不是硬编码它？
- en: How can I group together application-specific data into separate YAML files?
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我该如何将应用程序特定的数据分组到单独的 YAML 文件中？
- en: Jerakia allows us to implement some of these corner cases.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Jerakia 使我们能够实现一些特殊的情况。
- en: Installing Jerakia
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Jerakia
- en: 'Jerakia is installed from a RubyGem. Simply run the following command:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Jerakia 是通过 RubyGem 安装的。只需运行以下命令：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Configuring Jerakia
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Jerakia
- en: 'Set up the `jerakia.yaml` configuration file as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式设置 `jerakia.yaml` 配置文件：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is the simplest configuration:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的配置：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you intend to use encryption, you should also provide the keys in the `private_key`
    and `public_key` settings as indicated.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算使用加密，你还应该在 `private_key` 和 `public_key` 设置中提供密钥，如所示。
- en: Creating your default Jerakia policy
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的默认 Jerakia 策略
- en: 'All requests for data from Jerakia are processed according to the so-called
    **policy**. The filenames for policies should be the same as the actual name of
    the policy, and are loaded from the directory indicated by the `policydir` setting
    in your `jerakia.yaml` configuration file. If a certain policy name is not indicated
    by the lookup request, then the name `default` is used. Let''s create the default
    policy, as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 所有来自 Jerakia 的数据请求都是按照所谓的 **policy** 处理的。策略的文件名应与策略的实际名称相同，并从 `jerakia.yaml`
    配置文件中 `policydir` 设置所指定的目录加载。如果查找请求中未指定某个策略名称，则使用 `default` 作为默认名称。我们来创建默认策略，如下所示：
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: A Jerakia `policy` is a container of the so-called `lookup`, which is performed
    in the indicated order. A lookup consists of a `datasource` that should be used
    for the data lookup, along with any plugin functions.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Jerakia 的 `policy` 是一个容器，包含所谓的 `lookup`，按指定的顺序执行。一个查找包括一个应当用于数据查找的 `datasource`，以及任何插件功能。
- en: 'There follows a simple example, using the `file` data source to provide data
    from simple YAML files:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的示例，使用 `file` 数据源从简单的 YAML 文件提供数据：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s change the default policy to accommodate settings for another configuration
    team, based in, let''s say, `denmark`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改默认策略，以适应另一个配置团队的设置，假设该团队位于 `denmark`：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using Vault as an encryption backend
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Vault 作为加密后端
- en: The version 2 release of Jerakia now supports integration with Vault via the
    transit secret backend.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Jerakia 的 2.0 版本现在支持通过 transit secret 后端与 Vault 集成。
- en: Vault is an open source platform for encrypting, securing, storing, and tightly
    controlling access to passwords, tokens, certificates, and other secret settings
    for your infrastructure. Vault also handles those tricky aspects of secret management,
    such as leasing, rolling, revocation, and auditing.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Vault 是一个开源平台，用于加密、保护、存储并严格控制密码、令牌、证书以及基础设施的其他秘密设置的访问权限。Vault 还处理秘密管理中的一些复杂问题，例如租赁、轮换、撤销和审计。
- en: So, Vault provides something like an *encryption as a service* backend for Jerakia.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Vault 提供了类似 *加密即服务* 的后端供 Jerakia 使用。
- en: Installing and configuring Vault
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置 Vault
- en: See the Vault documentation to install and configure Vault: [https://www.vaultproject.io/docs/install/index.html](https://www.vaultproject.io/docs/install/index.html)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 Vault 文档以安装和配置 Vault：[https://www.vaultproject.io/docs/install/index.html](https://www.vaultproject.io/docs/install/index.html)
- en: Unsealing Vault
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解封 Vault
- en: Follow the procedures in the Vault documentation to unseal Vault: [https://www.vaultproject.io/docs/concepts/seal.html](https://www.vaultproject.io/docs/concepts/seal.html)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 按照 Vault 文档中的步骤解封 Vault：[https://www.vaultproject.io/docs/concepts/seal.html](https://www.vaultproject.io/docs/concepts/seal.html)
- en: Enabling the transit backend
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用传输后端
- en: 'Enable the transit backend by mounting it as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通过如下方式挂载来启用传输后端：
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Creating an encryption key
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建加密密钥
- en: 'Let''s create a key Jerakia will use for encrypting and decrypting. By default,
    the key is simply called `jerakia`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个 Jerakia 用于加密和解密的密钥。默认情况下，密钥被称为 `jerakia`：
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Creating a policy for encrypting and decrypting
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建加密和解密策略
- en: Now we need to create a policy which restricts Jerakia to using only the encryption
    and decryption endpoints.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建一个策略，限制 Jerakia 仅能使用加密和解密端点。
- en: 'In order to create this policy, we''ll create a new file, `jerakia_policy.hcl`,
    and then import it into Vault using the `policy-write` Vault command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建这个策略，我们将创建一个新的文件 `jerakia_policy.hcl`，然后使用 `policy-write` Vault 命令将其导入 Vault：
- en: '[PRE32]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Checking the encryption is working correctly
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查加密是否正常工作
- en: 'We can now try to encrypt a value on the command line using the Jerakia transit
    key and the policy that we''ve just created:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以尝试使用 Jerakia 传输密钥和刚刚创建的策略在命令行中加密一个值：
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'See the Vault documentation for more specifics on the `read` and `write` commands:
    [https://www.vaultproject.io/docs/commands/read-write.html](https://www.vaultproject.io/docs/commands/read-write.html).'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 Vault 文档，了解 `read` 和 `write` 命令的更多细节：[https://www.vaultproject.io/docs/commands/read-write.html](https://www.vaultproject.io/docs/commands/read-write.html)。
- en: Allowing Jerakia to authenticate with our Vault
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 允许 Jerakia 使用我们的 Vault 进行身份验证
- en: AppRole authentication is the recommended method of authenticating with Vault.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: AppRole 身份验证是与 Vault 认证的推荐方法。
- en: When using this authentication method, Jerakia is configured with a role ID
    (`role_id`) and a secret ID (`secret_id`*)*, and Jerakia uses these values to
    acquire a limited-lifetime token from Vault to interact with the API of the transit
    backend.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种身份验证方法时，Jerakia 配置了角色 ID（`role_id`）和密钥 ID（`secret_id`），并使用这些值从 Vault 获取一个有限生命周期的令牌，以便与传输后端的
    API 进行交互。
- en: Upon token expiry, Jerakia will request a new token using `role_id` and `secret_id`
    again.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当令牌过期时，Jerakia 将再次使用 `role_id` 和 `secret_id` 请求新的令牌。
- en: 'First, we''ll create an AppRole for Jerakia, giving it a TTL of 15 minutes.
    This has to be associated with the access policy we created earlier using the
    policies argument:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将为 Jerakia 创建一个 AppRole，并为其设置 15 分钟的 TTL。这个角色必须与我们之前创建的访问策略相关联，使用 `policies`
    参数：
- en: '[PRE34]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we can check the Jerakia AppRole and ascertain the `role_id`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以检查 Jerakia 的 AppRole 并确认 `role_id`：
- en: '[PRE35]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We also need to create a `secret_id`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要创建一个 `secret_id`：
- en: '[PRE36]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now that we have `role_id` and `secret_id`, we can proceed to integrate Jerakia
    with Vault.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们拥有了 `role_id` 和 `secret_id`，可以继续将 Jerakia 与 Vault 集成。
- en: Configuring Jerakia for encryption
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Jerakia 进行加密
- en: 'In the `jerakia.yaml` configuration file, we configure the encryption option
    with a provider of Vault and the specific configuration that our provider requires:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `jerakia.yaml` 配置文件中，我们使用 Vault 作为加密提供者，并配置该提供者所需的特定配置：
- en: '[PRE37]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We should now be able to `encrypt` and `decrypt` using Jerakia:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该能够使用 Jerakia 进行 `加密` 和 `解密`：
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Encryption-enabling our Jerakia lookups
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用 Jerakia 查找加密
- en: 'We enable encryption by using the `output_filter` method to our lookup in our
    policy:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在策略中使用 `output_filter` 方法来启用加密：
- en: '[PRE39]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This instructs Jerakia to pass everything to the encryption filter and to match
    all the retrieved values against the signature of the encryption provider. If
    a match is made, the encryption provider will be used to decrypt the value before
    it is returned.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这指示 Jerakia 将所有内容传递给加密过滤器，并将所有检索到的值与加密提供者的签名进行匹配。如果匹配成功，加密提供者将在返回值之前用于解密。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have taken a close look at the main differences between
    Hiera 5 and its earlier incarnations. We have also described how you can now quickly
    set up the encrypted YAML backend, so you no longer have to save your secret Hiera
    values in plain text.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细探讨了 Hiera 5 与其早期版本之间的主要区别。我们还描述了如何快速设置加密的 YAML 后端，这样您就不再需要以明文方式保存您的秘密
    Hiera 值。
- en: We've also looked at Jerakia, which you can use to cover more advanced use cases,
    such as providing different hierarchies to different teams, and integrating Vault
    to provide something like an *encryption as a service* backend for Jerakia.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看了 Jerakia，您可以使用它来处理更高级的用例，比如为不同的团队提供不同的层级结构，并集成 Vault，为 Jerakia 提供类似 *加密即服务*
    的后端。
- en: In the next chapter, let's continue our master class by examining the management
    of Puppet code.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，让我们继续通过研究 Puppet 代码的管理来进行我们的高级课程。
