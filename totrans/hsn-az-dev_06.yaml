- en: Mobile Notifications with Notification Hub
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用通知中心进行移动通知
- en: Push notifications are one of the main features of many mobile apps. They facilitate
    informing a user about a wait for action, or maybe about a temporary discount
    that is available only for minutes within an application. While each mobile OS
    vendor has its own service for such notifications, it's always nice to configure
    such a feature in one place, so we don't have to worry about changes in the underlying
    API or the parameters required. Azure Notification Hub simplifies things greatly
    by providing a single service that acts as a single endpoint for our mobile applications,
    easing both development and testing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 推送通知是许多移动应用的主要功能之一。它们帮助用户了解等待操作的通知，或者关于仅在应用内存在几分钟的临时折扣。虽然每个移动操作系统供应商都有自己的通知服务，但将此类功能集中配置在一个地方总是很好的，这样我们就不必担心底层API或所需参数的变化。Azure
    通知中心通过提供一个单一的服务，作为我们移动应用的单一端点，极大简化了开发和测试过程。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Notification Hub and its benefits
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知中心及其好处
- en: Notification architecture and the best patterns for sending a notification to
    mobile apps
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知架构以及发送通知到移动应用的最佳模式
- en: Registering a device within Notification Hub and maintaining registrations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在通知中心注册设备并保持注册信息
- en: Sending notifications to multiple vendors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向多个供应商发送通知
- en: Sending a rich content notification through Notification Hub
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过通知中心发送富媒体内容的通知
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To perform exercises from this chapter, you will need the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行本章的练习，你需要以下资源：
- en: An active Azure subscription
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的 Azure 订阅
- en: Visual Studio 2017 with Tools for Universal Windows apps installed
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了通用 Windows 应用工具的 Visual Studio 2017
- en: A Windows Store account
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Windows Store 账户
- en: Reasons to use Notification Hub
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用通知中心的理由
- en: If you have ever had a chance to develop an application that was integrated
    with any notifications system, you probably know the challenges that are faced
    when creating such a product. In this chapter, I will try to introduce you to
    some basic concepts such as PNS, push notifications, and device registrations.
    This will ensure that we can easily start developing applications leveraging Notification
    Hub features and focus on learning details and hidden functionalities.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经有机会开发一个与任何通知系统集成的应用程序，你可能会了解在创建这样的产品时所面临的挑战。在本章中，我将尝试向你介绍一些基本概念，如PNS、推送通知和设备注册。这样，我们就能轻松开始开发利用通知中心功能的应用程序，专注于学习细节和隐藏功能。
- en: Exercises from this chapter are written for **Universal Windows Platform** (**UWP**)
    applications—however, the concepts presented are true also for other platforms
    such as Android or iOS.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的练习是为**通用 Windows 平台**（**UWP**）应用程序编写的——不过，所介绍的概念也适用于其他平台，如 Android 或 iOS。
- en: Challenges for application design
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用设计的挑战
- en: 'Let''s assume you have the following architecture:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有如下架构：
- en: '![](img/f349f142-6d65-4104-93a8-775296a547f4.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f349f142-6d65-4104-93a8-775296a547f4.png)'
- en: 'Here, we have a backend that sends some messages to three different platforms:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个后端系统，将消息发送到三个不同的平台：
- en: iOS
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iOS
- en: Android
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android
- en: Windows
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows
- en: 'Now, if these messages are push notifications, our backend will have to communicate
    with three different services:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果这些消息是推送通知，我们的后端将需要与三个不同的服务进行通信：
- en: '**Apple Push Notification Service** (**APNS**)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**苹果推送通知服务**（**APNS**）'
- en: '**Firebase Cloud Messaging** (**FCM**)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Firebase 云消息推送**（**FCM**）'
- en: '**Windows Notification Service** (**WNS**)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows 通知服务**（**WNS**）'
- en: 'Each of these services is called a **Platform Notification Service** (**PNS**).
    Their responsibility is to accept a request to send a notification and send it
    to the appropriate device. They also handle registration of the devices that want
    to accept notifications (for instance, by tokens in APNS). The downside of such
    a solution is that none of these services has a common interface—we cannot introduce
    a simple wrapper in our backend to handle each request in the same fashion. The
    solution for that kind of trouble would be altering our architecture a little
    bit, so it contains a service that aggregates the logic for each PNS and is able
    to communicate with them:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务被称为**平台通知服务**（**PNS**）。它们的责任是接受发送通知的请求并将其发送到相应的设备。它们还处理希望接收通知的设备的注册（例如，APNS中的令牌）。这种解决方案的缺点是，这些服务没有共同的接口——我们无法在后台引入一个简单的封装器以相同的方式处理每个请求。解决这种问题的方法是稍微调整我们的架构，使其包含一个能够汇总每个PNS逻辑并与其通信的服务：
- en: '![](img/af3659a3-656d-4b51-a9c0-925aa30c3fda.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af3659a3-656d-4b51-a9c0-925aa30c3fda.png)'
- en: Notification Hub is such a service; it's an abstraction over different PNSes
    and is able to handle different device registration. We can consider two more
    problems—scaling and routing. It is important to know that, according do the PNSes
    guide, the device token must be refreshed with each app launch. Now, if it is
    your backend responsibility, you may end up with a solution that tries to handle
    refresh requests instead of focusing on your business logic.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通知中心就是这样一个服务；它是不同平台通知服务（PNS）的抽象层，能够处理不同的设备注册。我们还可以考虑另外两个问题——扩展性和路由。需要知道的是，根据PNS的指南，设备令牌必须在每次应用启动时刷新。现在，如果这是你的后台责任，你可能最终会得到一个试图处理刷新请求的解决方案，而不是专注于业务逻辑。
- en: Additionally, if you want to send a notification to a particular device, you
    have to store its identifier somewhere so you are able to route a message to it.
    All of these responsibilities can be moved to a notification service, so this
    whole overhead can be taken from the backend.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你想向特定设备发送通知，你必须将其标识符存储在某个地方，以便能够将消息路由到该设备。所有这些责任都可以转移到通知服务上，这样所有的额外负担都可以从后台移除。
- en: Push notification architecture
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推送通知架构
- en: Creating a whole system that relies on push notification is not a trivial task.
    Besides ensuring that you are not focusing on handling each PNS logic individually
    and providing reliable device registration and routing systems, you have to introduce
    a pipeline for passing messages from one part of your system to the end device.
    In this section, we will focus on incorporating Notification Hub into a few reference
    architectures, which will help you understand its role and the connections between
    different cloud services.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个完全依赖推送通知的系统并不是一件简单的事。除了确保你不单独处理每个PNS的逻辑，并提供可靠的设备注册和路由系统外，你还必须引入一个消息传递管道，将消息从系统的一个部分传递到最终设备。在本节中，我们将重点介绍如何将通知中心集成到几个参考架构中，这将帮助你理解它的作用以及不同云服务之间的连接。
- en: Direct connection
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直接连接
- en: 'The simplest architecture we could think of would be a direct connection between
    a backend and notification service:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能想到的最简单架构是后台与通知服务之间的直接连接：
- en: '![](img/bb7fc67a-53af-44ca-a7bd-d7cfa2c2dabb.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb7fc67a-53af-44ca-a7bd-d7cfa2c2dabb.png)'
- en: 'In such a scenario, each send notification request is handled by Notification
    Service, which communicate with different PNSes. Each PNS individually handles
    a request and sends a notification to a registered device. Device registration
    is handled by Notification Service—each device has to register in it to be able
    to receive a notification. Note that, even in that simple scenario, Notification
    Service (in our case—Notification Hub) takes responsibility for two important
    things:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，每个发送通知请求都由通知服务处理，该服务与不同的PNS进行通信。每个PNS单独处理请求，并将通知发送到已注册的设备。设备注册由通知服务处理——每个设备必须在通知服务中注册，才能接收通知。请注意，即使在这种简单的场景中，通知服务（在我们的案例中是通知中心）也负责两件重要的事情：
- en: Providing a common interface for different PNSes
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为不同的PNS提供统一接口
- en: Handling device registration and routing
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理设备注册和路由
- en: Devices never communicate directly with the PNS itself—they only receive push
    notifications as a result of sending a request to Notification Service.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 设备永远不会直接与PNS本身通信——它们仅通过向通知服务发送请求来接收推送通知。
- en: Queued communication
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排队通信
- en: 'Sometimes exposing Notification Service to the backend is not the way to go—it
    could become unresponsive, have some performance issues, or just be overloaded.
    In such a situation, it is always good to have something that can cache messages
    and store them until all issues are resolved. Let''s modify the previous architecture
    with one more service:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，将 Notification Service 暴露给后端并不是最佳选择——它可能变得无响应，出现性能问题，或者只是过载。在这种情况下，拥有一个可以缓存消息并在所有问题解决之前存储它们的服务总是好的。让我们通过添加一个服务来修改之前的架构：
- en: '![](img/fa1627e3-e404-4b0c-9d77-5f82bb24d8c4.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa1627e3-e404-4b0c-9d77-5f82bb24d8c4.png)'
- en: By introducing a Queue with readers, you can absolve the backend from handling
    communication with Notification Service and move the responsibility for delivering
    a message to them. Now Backend does not have to know how to handle undelivered
    messages and will not be aware of a storage for storing them. This solution can
    be also scaled much more easily than the previous one, as you do not have to worry
    about losing a message—a queue should be able to cache them as long as needed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入带有读取器的队列，你可以将后端从处理与 Notification Service 的通信中解脱出来，并将消息传递的责任转移给它们。现在，后端不需要知道如何处理未发送的消息，也不会知道存储它们的存储位置。这个解决方案比之前的方案更容易扩展，因为你不必担心丢失消息——队列应该能够根据需要缓存它们。
- en: Make sure that your caching mechanism makes sense in the business domain you
    are working with. Caching a notification request for a day, for example, and sending
    a notification after that time may not make any sense in scenarios such as geolocalization,
    a specific time, or a short-lived discount.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的缓存机制在你所处理的业务领域中是合理的。例如，缓存一个通知请求一天，并在那时之后发送通知，在诸如地理定位、特定时间或短期折扣等场景中可能没有意义。
- en: Triggered communication
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发的通信
- en: 'Sometimes, you might like to send a notification based on some specific set
    of parameters or raising an event. Let''s assume you would like to send it whenever
    a photo is uploaded to storage:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能希望根据一些特定的参数或事件触发来发送通知。假设你希望每次上传照片到存储时发送通知：
- en: '![](img/dc74a003-82c7-4ade-a13b-09a1592e3a02.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc74a003-82c7-4ade-a13b-09a1592e3a02.png)'
- en: In this asynchronous scenario, you have an Event Listener, which listens to
    an event publication and performs an action based on the passed metadata. It sends
    a request to a Notification Service, which communicates with PNS to send a notification
    with the appropriate content (probable information regarding an upload status).
    Once more, we see the advantages of having a service acting as a proxy to PNSes—the
    whole communication can be made asynchronous and each component has its own responsibility.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个异步场景中，你有一个事件监听器，它监听事件发布，并根据传递的元数据执行相应的操作。它向 Notification Service 发送请求，后者与
    PNS 通信，发送包含适当内容（可能是关于上传状态的信息）的通知。再次，我们看到了拥有作为 PNS 代理服务的优势——整个通信可以是异步的，每个组件都有自己的职责。
- en: Registering devices in Notification Hub
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Notification Hub 中注册设备
- en: To be able to actually send a notification, you have to register a device in
    the PNS. Without using a service such as Notification Hub, you would have to know
    the individual logic of each PNS and storage device data somewhere. Such a challenge
    would be problematic in most cases, as usually you do not want to handle external
    dependencies by yourself; rather, your aim is to simplify the overall system logic.
    In this section, you will learn how device registration is handled in Notification
    Hub and how to monitor it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够实际发送通知，你必须在 PNS 中注册一个设备。如果不使用类似 Notification Hub 这样的服务，你将不得不了解每个 PNS 的个别逻辑，并将设备数据存储在某个地方。这样的挑战在大多数情况下是有问题的，因为通常你不希望自己处理外部依赖关系；而是你的目标是简化整体系统逻辑。在本节中，你将学习如何在
    Notification Hub 中处理设备注册以及如何监控它。
- en: Notification Hub device registration
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Notification Hub 设备注册
- en: 'When you register a device in Notification Hub, you are actually associating
    it with a template of a notification and tag. To create such a link, you need
    a PNS handle, which can be understood as an identifier of a specific vendor (such
    as a token or GCM registration ID). In fact, there are two ways to register a
    device:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Notification Hub 中注册设备时，实际上是将设备与通知模板和标签关联起来。为了创建这样的链接，你需要一个 PNS 句柄，可以理解为一个特定厂商的标识符（例如令牌或
    GCM 注册 ID）。事实上，注册设备有两种方式：
- en: '**Use registration**: Where you pass an identifier, tag, and template'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用注册**：你需要传递标识符、标签和模板'
- en: '**Use installation**: An enhanced registration with an additional set of push-related
    properties'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用安装**：增强的注册，包含一组额外的与推送相关的属性'
- en: Please note that, currently, if you want to use installation, there is no possibility
    to use a .NET SDK—you are limited to using the REST API of a service.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，目前，如果您想使用安装功能，是无法使用 .NET SDK 的—您只能使用服务的 REST API。
- en: 'We have to also describe what tags and templates are to fully understand the
    process:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要描述标签和模板，以便充分理解这一过程：
- en: '**Tag**: This is a way to route a notification to a particular set of (or all)
    registered devices. It allows you to segment users, so you can easily decide who
    is an addressee of a message; you can use, for example, `version_Beta` to send
    a notification to a limited group of devices using a preview version of your application.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标签**：这是一种将通知路由到特定设备组（或所有设备）的方法。它允许您对用户进行分段，从而轻松决定谁是消息的接收者；例如，您可以使用 `version_Beta`
    将通知发送到使用您应用程序预览版本的有限设备组。'
- en: '**Template**: This is a particular schema of data designed to be sent to a
    client application. It differs depending on the PNS used and varies from JSON
    data to XML documents. By using Notification Hub, you can create a platform-agnostic
    template, which can be reused between different platforms.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板**：这是一种特定的数据模式，设计用于发送到客户端应用程序。它根据使用的推送通知服务（PNS）有所不同，从 JSON 数据到 XML 文档不等。通过使用通知中心，您可以创建一个平台无关的模板，这个模板可以在不同平台之间重复使用。'
- en: Now we will try registering a device using both methods and understand the differences
    between them.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将尝试使用两种方法注册设备，并了解它们之间的区别。
- en: Creating a Notification Hub
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建通知中心
- en: 'Before we start sending notifications, we have to have a notification service
    provisioned and working. To create a Notification Hub instance, go to the portal
    and click on the + Create a resource button. Search for Notification Hub and click
    Create. Here, you can see a completed configuration:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始发送通知之前，我们必须先有一个已配置并正常运行的通知服务。要创建一个通知中心实例，进入门户并点击 + 创建资源按钮。搜索“通知中心”并点击“创建”。在这里，您可以看到一个已完成的配置：
- en: '![](img/1b1e2ca5-d221-44cc-923e-b2e5da518a39.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b1e2ca5-d221-44cc-923e-b2e5da518a39.png)'
- en: 'As you can see, there is nothing unexpected on that screen—the only things
    that need clarification are Pricing tier and Namespace:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，屏幕上没有什么意外情况—需要澄清的唯一事项是定价层级和命名空间：
- en: 'Namespace: You can have multiple Notification Hubs inside the same namespace.
    A namespace is a logical container for your hubs and holds the limit of available
    pushes for them.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间：您可以在同一个命名空间中拥有多个通知中心。命名空间是您通知中心的逻辑容器，并持有可用推送次数的限制。
- en: 'Pricing tier: Depending on the selected tier (Free, Basic, or Standard) you
    will have different features available and a different number of available pushes
    for your hubs. Additionally, it defines the price of extra pushes and the number
    of active devices. What is more, the Standard tier comes with handy enterprise
    features such as multi-tenancy or scheduled push.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定价层级：根据选择的层级（免费、基础或标准），您将拥有不同的功能和不同数量的可用推送次数。此外，它还定义了额外推送次数的价格和激活设备的数量。更重要的是，标准层级提供了便利的企业功能，如多租户或定时推送。
- en: 'For the purpose of this exercise, the Free tier will be more than enough. Once
    you are satisfied with your configuration, click on the Create button and wait
    a second for service creation. When it is created, you can go to its page where
    you will see an Overview blade:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本次练习，免费层级就足够了。一旦您对配置满意，点击创建按钮，并等待片刻，直到服务创建完成。当创建完成后，您可以进入其页面，看到概览页面：
- en: '![](img/0babb183-5361-404f-b38a-ac63a7739e15.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0babb183-5361-404f-b38a-ac63a7739e15.png)'
- en: There, you can click on the hub you created to see its features. We will cover
    them later in this chapter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里，您可以点击您创建的中心，查看其功能。我们将在本章稍后介绍这些功能。
- en: Registering in an application
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在应用程序中注册
- en: In this section, we will try to perform a registration using a UWP application
    in Visual Studio. To get started, open the `HandsOnAzureApp` project from the
    source code for this chapter—you should see a blank UWP application with boilerplate
    code in it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将尝试使用 Visual Studio 中的 UWP 应用程序进行注册。首先，从本章的源代码中打开 `HandsOnAzureApp`
    项目—您应该能看到一个带有基本代码的空白 UWP 应用程序。
- en: We will use a UWP application here because it is the easiest way to get started
    and work with Notification Hub. However, if you are a mobile developer, you can
    use any kind of project you want.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将使用一个 UWP 应用程序，因为它是开始使用和操作通知中心的最简单方式。然而，如果你是移动开发者，你可以使用任何你想要的项目类型。
- en: 'To get started with registration, you will have to install a package to work
    with Notification Hub—use the NuGet package manager and search for the `WindowsAzure.Messaging.Managed`
    package, which holds all of the components required for this particular exercise.
    In the `App.xaml.cs` file, you will have to add the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始注册，你需要安装一个包来与通知中心进行交互——使用 NuGet 包管理器，搜索`WindowsAzure.Messaging.Managed`包，该包包含了本练习所需的所有组件。在`App.xaml.cs`文件中，你需要添加以下代码：
- en: '[PRE0]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'What we are doing here can be described as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的事情可以描述如下：
- en: We are creating a notification channel to be used for a registration
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在创建一个通知通道，用于注册
- en: We are defining a hub, which we will use to handle notifications and registrations
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在定义一个中心，供我们处理通知和注册
- en: We are registering a device and displaying a dialog if an operation was successful
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在注册一个设备，并在操作成功时显示一个对话框
- en: You may wonder how to obtain the connection string used for the communication;
    to get it, go to Azure Portal, select your Notification Hub namespace and click
    on the Access Policies blade—there you will see a policy named `RootManageSharedAccessKey`,
    from which you can copy a connection string.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道如何获取用于通信的连接字符串；要获取它，请前往 Azure 门户，选择你的通知中心命名空间，然后点击访问策略（Access Policies）选项卡——在那里你会看到一个名为`RootManageSharedAccessKey`的策略，你可以从中复制连接字符串。
- en: I am using a root policy only for the purpose of this exercise. In a production
    environment, it is always good to create an individual policy for each application
    and select only those permissions that are required for it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我仅为本练习使用根策略。在生产环境中，最好为每个应用程序创建一个独立的策略，并仅选择所需的权限。
- en: 'When you enter your hub name and paste a connection string, call the `RegisterADevice()`method
    in `OnLaunched()`. Now, you can try to start an application. If everything is
    successful, you should see a screen similar to mine:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当你输入你的中心名称并粘贴连接字符串后，调用`RegisterADevice()`方法，放在`OnLaunched()`中。现在，你可以尝试启动应用程序。如果一切顺利，你应该会看到一个类似于我屏幕的界面：
- en: '![](img/309000d1-c39b-4f6b-929b-7e5927c5010e.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/309000d1-c39b-4f6b-929b-7e5927c5010e.png)'
- en: Congratulations—you have just registered your very first device in Notification
    Hub!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你——你刚刚在通知中心注册了你的第一个设备！
- en: Checking available registrations
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查可用的注册
- en: 'Once you register a device, you need to make sure it is really available in
    Notification Hub. The easiest way to do so is to check device registrations in
    a service itself using Server Explorer, which can be accessed either by clicking
    on it in the View menu (View | Server Explorer) or by using the *Ctrl* + *W* + *L *key
    combination:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦注册了设备，你需要确保它确实在通知中心中可用。最简单的方式是使用服务器资源管理器（Server Explorer）检查设备注册情况，可以通过在视图（View）菜单中点击它（视图
    | 服务器资源管理器）或使用*Ctrl* + *W* + *L*快捷键组合来访问：
- en: '![](img/17ad80e0-6a21-45b5-99ad-0b2c2d1ee18c.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17ad80e0-6a21-45b5-99ad-0b2c2d1ee18c.png)'
- en: Now, when you double-click on an Notification Hub instance you would like to
    check, you will see a new screen that contains two tabs—Test Send (which we will
    cover later) and Device Registrations.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你双击你想要检查的通知中心实例时，你会看到一个新屏幕，包含两个标签——测试发送（Test Send，稍后我们会讲解）和设备注册（Device Registrations）。
- en: 'By clicking on the latter, you will able to verify all available registrations:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击后者，你可以验证所有可用的注册：
- en: '![](img/136d5430-51ef-4687-b9a9-465b981ab6ee.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/136d5430-51ef-4687-b9a9-465b981ab6ee.png)'
- en: Using installations
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用安装
- en: 'Installations is a newer feature, which allows you to handle each device registration
    using a bit different syntax and tools. It has a few important advantages over registrations:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 安装是一个较新的功能，它允许你使用稍有不同的语法和工具处理每个设备注册。它相较于注册有几个重要的优势：
- en: While it is possible to duplicate registrations (by registering the same device
    twice), installations are idempotent. That means that sending the same installation
    multiple times will not result in the creation of more than one registration record.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然可以重复注册（通过两次注册相同的设备），但安装是幂等的。这意味着多次发送相同的安装不会导致创建多个注册记录。
- en: By using `HTTP PATCH`, you are able to update a specific parameter in an installation.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`HTTP PATCH`，你可以更新安装中的特定参数。
- en: It is easier to perform individual pushes, since each installation is automatically
    tagged using an installation identifier. In registrations, you would have to create
    such a tag by yourself and maintain it somehow to get the same functionality.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行单个推送操作更为简单，因为每个安装包会自动标记安装标识符。在注册时，您需要自己创建这样的标签，并以某种方式维护它，以便获得相同的功能。
- en: 'As I said in a previous part of this book, it is not currently possible to
    use installations with the .NET SDK on the client side—to check this functionality,
    we will have to use the Notification Hub RESTful API or use SDK for the backend.
    Here, you can find an example request for calling an API method:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本书的前面部分所说，目前不能在客户端使用 .NET SDK 来使用安装包——要检查此功能，我们必须使用通知中心 RESTful API 或使用后台
    SDK。这里，您可以找到调用 API 方法的示例请求：
- en: '[PRE1]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To generate an authorization token you will need to generate an SAS token. You
    can find a guide on how to generate it here  [https://msdn.microsoft.com/library/azure/dn495627.aspx](https://msdn.microsoft.com/library/azure/dn495627.aspx).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成授权令牌，您需要生成一个 SAS 令牌。您可以在这里找到如何生成它的指南 [https://msdn.microsoft.com/library/azure/dn495627.aspx](https://msdn.microsoft.com/library/azure/dn495627.aspx)。
- en: Sending a notification
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送通知
- en: The main functionality of Notification Hub is to send a notification to a set
    of registered devices. You will see that, using its SDK and portal, you can easily
    start using that feature without knowing the internal logic of different PNSes.
    After this section, you should be able to use Notification Hub without problems
    and incorporate it into your applications.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通知中心的主要功能是将通知发送到一组已注册的设备。您会看到，使用它的 SDK 和门户，您可以轻松开始使用此功能，而无需了解不同推送通知服务（PNS）的内部逻辑。通过这一部分，您应该能够顺利使用通知中心并将其集成到您的应用程序中。
- en: Sending a test notification
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送测试通知
- en: While developing your application, you always need a way to test it. When using
    Notification Hub, you have two options when it comes to sending a test notification—either
    use the portal or its SDK. Both possibilities allow for similar results; however,
    using the SDK is a bit more flexible as it is easier to find all of the devices
    to which you would like to send a notification or add any kind of logic.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序时，您总是需要一种测试它的方法。使用通知中心时，您有两种发送测试通知的选择——要么使用门户，要么使用其 SDK。这两种方式都能达到类似的效果；然而，使用
    SDK 更加灵活，因为它能更轻松地找到您希望发送通知的所有设备，或者添加任何逻辑。
- en: Test notification in Azure Portal
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Azure 门户中的测试通知
- en: 'When you go to the hub you created, you will see that, at the top of the page,
    there is a Test Send button:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当您进入已创建的中心时，您会看到在页面顶部有一个 Test Send 按钮：
- en: '![](img/b107f2e6-af2a-4c5a-b2c4-7f631498a28f.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b107f2e6-af2a-4c5a-b2c4-7f631498a28f.png)'
- en: 'When you click on it, you will see a screen for the Test Send functionality.
    There are a few fields available and they all depend on the platform selected.
    In the following, you can find a sample request for the Windows platform:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击它时，您会看到一个用于测试发送功能的屏幕。这里有一些字段，所有这些字段都依赖于所选的平台。以下是 Windows 平台的示例请求：
- en: '![](img/b236fe41-ffc6-46af-bea1-81580fc38334.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b236fe41-ffc6-46af-bea1-81580fc38334.png)'
- en: Now, if you click the Send button, Notification Hub will select ten different
    registered devices, which will receive a notification. If you want, you can change
    both the type and the payload sent. What is more, you can send a message to a
    specific set of devices by specifying the Send to Tag Expression option.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您点击“发送”按钮，通知中心将选择十个不同的已注册设备，这些设备将接收到通知。如果您愿意，您可以更改发送的类型和负载。更重要的是，您还可以通过指定“发送到标签表达式”选项，将消息发送给特定的设备集合。
- en: Test notification in the SDK
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SDK 中的测试通知
- en: 'It is also possible to send a test notification using the Notification Hub
    SDK. To use it, you will need to install the following package: `Microsoft.Azure.NotificationHubs`.
    Consider the following example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用通知中心 SDK 发送测试通知。要使用它，您需要安装以下包：`Microsoft.Azure.NotificationHubs`。请参考以下示例：
- en: '[PRE2]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The last parameter enables sending a test notification. That means that, each
    time you send a notification using the SDK, it will be sent to a maximum of ten
    registered devices. Additionally, you will get the outcome of each operation (whether
    it succeeded or failed).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个参数允许发送测试通知。这意味着，每次您使用 SDK 发送通知时，它将发送到最多十个已注册的设备。此外，您还会看到每个操作的结果（是否成功或失败）。
- en: Remember that, when test mode is enabled, each request to Notification Hub is
    throttled. That means that you will not be able to overload your communication
    channel as send operations will be queued and executed in a controlled manner.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当启用测试模式时，每个对通知中心的请求都会被限流。这意味着您无法过度加载通信通道，因为发送操作将被排队并以受控方式执行。
- en: 'You can check whether test send is enabled by checking a property on the `NotificationHubClient`
    object:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过检查 `NotificationHubClient` 对象上的一个属性来检查是否启用了测试发送：
- en: '[PRE3]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using the SDK to send a notification
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SDK 发送通知
- en: 'The Notification Hub SDK brings many different methods for sending notifications,
    depending on the configuration and expected output. Here you can find all the
    methods available in the SDK:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通知中心 SDK 提供了许多不同的方法来发送通知，具体取决于配置和期望的输出。在这里，您可以找到 SDK 中所有可用的方法：
- en: '[PRE4]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, we have two different categories:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有两种不同的类别：
- en: '**Native notifications**: Methods for sending a notification to a specific
    platform only'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原生通知**：仅用于向特定平台发送通知的方法'
- en: '**Generic notifications**: A set of methods for sending a notification to a
    specific tag'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用通知**：一组用于向特定标签发送通知的方法'
- en: 'I strongly encourage you to experiment and test different possibilities as
    each method is a bit different. Here you can find the result of calling `SendAppleNativeNotificationAsync()`
    and serializing the output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议您尝试和测试不同的可能性，因为每种方法略有不同。这里您可以看到调用 `SendAppleNativeNotificationAsync()`
    并序列化输出的结果：
- en: '[PRE5]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The result will be as follows in my case:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，结果将如下所示：
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we get the complete result of sending a notification to a set
    of registered devices. You can leverage that output to work with your application
    and, for instance, display the appropriate status or report.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们得到了向一组注册设备发送通知的完整结果。您可以利用该输出与您的应用程序进行交互，例如显示适当的状态或报告。
- en: Rich content notifications
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 富内容通知
- en: In the last section of this chapter, we will talk a bit about another type of
    notification, which is called **rich content notification**. Sometimes you would
    like to send something more than plain text. In Notification Hub, it is possible
    to send, for example, an image to enhance the look and feel of an application.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将讨论另一种类型的通知，称为 **富内容通知**。有时您可能希望发送的不仅仅是纯文本。在通知中心中，您可以发送例如图像来增强应用程序的外观和感觉。
- en: Please note that receiving rich content notifications requires making changes
    on the client side. We will not cover that in this chapter but, at the end of
    it, you will find a link where such an operation is described in detail.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，接收富内容通知需要在客户端进行更改。我们将在本章中不涉及该内容，但在章节结束时，您将找到一个链接，其中详细描述了如何进行此类操作。
- en: Creating and sending a rich content notification
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建并发送富内容通知
- en: 'To create and send a rich content notification, you will need two things:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并发送富内容通知，您需要两个东西：
- en: A model of a notification
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知模型
- en: The notification payload and content
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知负载和内容
- en: 'The idea is to send it in a way that will enable a client application to fetch
    rich content and handle it on its side. In fact, the simplest way to do so would
    be to have an API that provides two operations:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个思路是以一种方式发送通知，使客户端应用程序能够获取富内容并在客户端处理。事实上，最简单的方法是拥有一个 API 提供两个操作：
- en: Send a notification
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送通知
- en: Fetch notification data
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取通知数据
- en: 'In the following, you can find example code for both actions:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的内容中，您可以找到两个操作的示例代码：
- en: '[PRE7]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, the only thing we have to do is to keep the correct schema for
    sending a notification to a particular PNS. In the previous example, I used APNS
    but, of course, it is possible for other vendors (as long as their software supports
    receiving images or audio through push notifications). You can find the example
    in the source code for this chapter.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们需要做的唯一事情就是保持正确的架构，以便向特定的 PNS 发送通知。在之前的示例中，我使用了 APNS，但当然也可以使用其他供应商（只要他们的软件支持通过推送通知接收图像或音频）。您可以在本章的源代码中找到示例。
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned what Notification Hub is and how you can use
    it to incorporate push notifications into your applications. We covered some reference
    architectures and possible scenarios, which should help you understand what the
    purpose of this service is and how it solves problems when sending notifications
    to multiple PNSes and devices.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经了解了什么是通知中心，以及如何使用它将推送通知集成到应用程序中。我们介绍了一些参考架构和可能的场景，这应该有助于你理解该服务的目的，并且当向多个
    PNS 和设备发送通知时，它是如何解决问题的。
- en: This chapter ends the first part of this book. In the next one, we will focus
    on serverless components and architectures.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束了本书的第一部分。在接下来的章节中，我们将重点介绍无服务器组件和架构。
- en: Questions
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is PNS?
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 PNS？
- en: Do multiple platforms (iOS, Android, and Windows) have different PNSes?
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不同平台（iOS、Android 和 Windows）是否有不同的 PNS？
- en: What is the difference between registration and installation?
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册和安装之间有什么区别？
- en: Can you register the same number of devices in the Free and Basic tiers?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在免费和基础套餐中，你能否注册相同数量的设备？
- en: What is the easiest way to check registered devices in Notification Hub?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查通知中心中已注册的设备的最简单方法是什么？
- en: How can you send a test notification?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何发送测试通知？
- en: What are rich content notifications?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是富媒体内容通知？
- en: Further reading
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'Azure Notification Hub documentation: [https://docs.microsoft.com/en-us/azure/notification-hubs/](https://docs.microsoft.com/en-us/azure/notification-hubs/)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Azure 通知中心文档: [https://docs.microsoft.com/zh-cn/azure/notification-hubs/](https://docs.microsoft.com/en-us/azure/notification-hubs/)'
- en: 'IOS push notifications: [https://docs.microsoft.com/en-us/azure/notification-hubs/notification-hubs-aspnet-backend-ios-apple-push-notification-service-apns-rich](https://docs.microsoft.com/en-us/azure/notification-hubs/notification-hubs-aspnet-backend-ios-apple-push-notification-service-apns-rich)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'IOS 推送通知: [https://docs.microsoft.com/zh-cn/azure/notification-hubs/notification-hubs-aspnet-backend-ios-apple-push-notification-service-apns-rich](https://docs.microsoft.com/en-us/azure/notification-hubs/notification-hubs-aspnet-backend-ios-apple-push-notification-service-apns-rich)'
- en: 'Registrations in Azure Notification Hub: [https://docs.microsoft.com/en-us/azure/notification-hubs/notification-hubs-push-notification-registration-management](https://docs.microsoft.com/en-us/azure/notification-hubs/notification-hubs-push-notification-registration-management)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Azure 通知中心中的注册管理: [https://docs.microsoft.com/zh-cn/azure/notification-hubs/notification-hubs-push-notification-registration-management](https://docs.microsoft.com/en-us/azure/notification-hubs/notification-hubs-push-notification-registration-management)'
