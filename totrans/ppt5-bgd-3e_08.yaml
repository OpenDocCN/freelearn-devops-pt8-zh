- en: Chapter 8. Classes, roles, and profiles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 类、角色和配置文件
- en: '|   | *Our life is frittered away by detail. Simplify, simplify!* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *我们的生活被琐事浪费了。简化，简化！* |   |'
- en: '|   | --*Henry David Thoreau* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*亨利·戴维·梭罗* |'
- en: In this chapter you will explore the details of Puppet classes, the distinction
    between defining a class and including the class, how to supply parameters to
    classes, and how to declare classes with parameters and specify appropriate data
    types for them. You'll learn how to create defined resource types, and how they
    differ from classes. You'll also see how to organize your Puppet code using the
    concepts of nodes, roles, and profiles.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将探索Puppet类的细节，定义类和包含类的区别，如何为类提供参数，如何声明带参数的类并为其指定合适的数据类型。你将学习如何创建定义的资源类型，以及它们与类的不同。你还将了解如何使用节点、角色和配置文件的概念来组织你的Puppet代码。
- en: '![Classes, roles, and profiles](img/8880_08_01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![类、角色和配置文件](img/8880_08_01.jpg)'
- en: Classes
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: We've come across the **class** concept a few times so far in this book, without
    really explaining it. Let's explore a little further now and see how to use this
    key Puppet language building block.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们已经多次提到**类**的概念，但并没有真正解释它。现在让我们进一步探索，并看看如何使用这个关键的Puppet语言构建块。
- en: The class keyword
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类关键字
- en: 'You may have noticed that in the code for our example NTP module in [Chapter
    7,](ch07.html "Chapter 7. Mastering modules") *Mastering modules* (in the *Writing
    the module code* section), we used the `class` keyword:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，在我们示例NTP模块的代码中（见[第7章，](ch07.html "第7章。掌握模块") *掌握模块*部分中的*编写模块代码*部分），我们使用了`class`关键字：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you're wondering what the `class` keyword does, the surprising answer is
    nothing at all. Nothing, that is, except inform Puppet that the resources it contains
    should be grouped together and given a name (`pbg_ntp`), and that these resources
    should not be applied yet.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想`class`关键字的作用，出乎意料的答案是：什么也不做。也就是说，除了通知Puppet将其中的资源分组在一起并赋予一个名称（`pbg_ntp`），并且这些资源不应该被应用。
- en: 'You can then use this name elsewhere to tell Puppet to apply all the resources
    in the class together. We declared our example module by using the `include` keyword:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以在其他地方使用这个名称，告诉Puppet一起应用该类中的所有资源。我们通过使用`include`关键字来声明我们的示例模块：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following example shows a class **definition**, which makes the class available
    to Puppet, but does not (yet) apply any of its contained resources:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了一个**类定义**，它使得类对Puppet可用，但并不会（还没有）应用其中的任何资源：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following example shows a **declaration** of the `CLASS_NAME` class. A
    declaration tells Puppet to apply all the resources in that class (and the class
    must have already been defined):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了`CLASS_NAME`类的**声明**。声明告诉Puppet应用该类中的所有资源（并且该类必须已经定义）：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You may recall from [Chapter 7,](ch07.html "Chapter 7. Mastering modules") *Mastering
    modules*, that we used Hiera's automatic parameter lookup mechanism to supply
    parameters to classes. We'll find out more about this shortly, but first, how
    do we write a class that accepts parameters?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得在[第7章，](ch07.html "第7章。掌握模块") *掌握模块*中，我们使用了Hiera的自动参数查找机制来为类提供参数。我们很快会进一步了解这个，但首先，我们如何编写一个接受参数的类呢？
- en: Declaring parameters to classes
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向类声明参数
- en: 'If all a class does is group together related resources, that''s still useful,
    but a class becomes much more powerful if we can use **parameters**. Parameters
    are just like resource attributes: they let you pass data to the class to change
    how it''s applied.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类仅仅是将相关资源分组在一起，那也是有用的，但如果我们能使用**参数**，类将变得更强大。参数就像资源属性：它们让你传递数据给类，以改变类的应用方式。
- en: 'The following example shows how to define a class that takes parameters. It''s
    a simplified version of the `pbg_ntp` class we developed for our NTP module (`class_params.pp`):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何定义一个接受参数的类。这是我们为NTP模块开发的`pbg_ntp`类的简化版本（`class_params.pp`）：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The important part to look at is in parentheses after the start of the class
    definition. This specifies the parameters that the class accepts:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 需要关注的重要部分是类定义开始后的括号中的内容。这部分指定了类接受的参数：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`String` tells Puppet that we expect this value to be a String, and it will
    raise an error if we try to pass it anything else, such as an Integer. `$version`
    is the name of the parameter. Finally, the `''installed''` part specifies a **default
    value** for the parameter. If someone declares this class without supplying the
    `pbg_ntp_params::version` parameter, Puppet will fill it in automatically using
    this default value.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`String` 告诉 Puppet 我们期望这个值是一个字符串，如果我们尝试传递其他类型的值，例如整数，它会抛出错误。`$version` 是参数的名称。最后，`''installed''`
    部分指定了该参数的**默认值**。如果有人声明了这个类而没有提供 `pbg_ntp_params::version` 参数，Puppet 会自动使用这个默认值进行填充。'
- en: If you don't supply a default value for a parameter, that makes the parameter
    **mandatory**, so Puppet will not let you declare the class without supplying
    a value for that parameter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有为某个参数提供默认值，那么该参数就是**必需的**，因此 Puppet 不允许你声明这个类而不为该参数提供值。
- en: 'When you declare this class, you do it in exactly the same way that we did
    previously with the Puppet Forge modules, using the `include` keyword and the
    name of the class:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当你声明这个类时，你可以像之前使用 Puppet Forge 模块时那样，使用 `include` 关键字和类名：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There are no mandatory parameters for this class, so you need not supply any,
    but if you do, add a value like the following to your Hiera data, and Puppet will
    look it up automatically when the class is included:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类没有必需的参数，因此你不必提供任何参数，但如果你提供了参数，可以像下面这样在 Hiera 数据中添加一个值，Puppet 在类被包含时会自动查找它：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Classes can take more than one parameter, of course, and the following (contrived)
    example shows how to declare multiple parameters of various types (`class_params2.pp`):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，类可以接受多个参数，以下（虚构的）示例展示了如何声明多个不同类型的参数（`class_params2.pp`）：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To pass parameters to this class, add Hiera data like the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要向这个类传递参数，可以添加如下的 Hiera 数据：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s look closely at the parameter list:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看参数列表：
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first parameter is of `Boolean` type and named `$start_at_boot`. There's
    no default value, so this parameter is mandatory. Mandatory parameters must be
    declared first, before any optional parameters (that is, parameters with a default
    value).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是 `Boolean` 类型，名为 `$start_at_boot`。没有默认值，因此这个参数是必需的。必需参数必须先声明，在任何可选参数（即有默认值的参数）之前。
- en: The `$version` parameter we saw in the previous example, but now it's a `String[1]`
    instead of a `String`. What's the difference? A `String[1]` is a String with at
    least one character. This means that you can't pass the empty string to such a
    parameter, for example. It's a good idea to specify a minimum length for String
    parameters, if appropriate, to catch the case where an empty string is accidentally
    passed to the class.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的例子中看到的 `$version` 参数，但现在它是一个 `String[1]` 类型，而不是一个 `String` 类型。这有什么区别？`String[1]`
    是一个至少包含一个字符的字符串。这意味着，你不能将空字符串传递给这样的参数。例如，如果合适的话，为字符串参数指定最小长度是个好主意，以防不小心传递空字符串到类中。
- en: The final parameter, `$service_state` is of a new type, `Enum`, which we haven't
    come across before. With an **Enum parameter**, we can specify exactly the list
    of allowed values it can take.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的参数 `$service_state` 是一种新类型，`Enum`，我们之前没有遇到过。对于**Enum 参数**，我们可以精确地指定它可以接受的值的列表。
- en: 'If your class expects a String parameter which can only take one of a handful
    of values, you can list them all in an `Enum` parameter declaration, and Puppet
    will not allow any value to be passed to that parameter unless it is in that list.
    In our example, if you try to declare the `pbg_ntp_params2` class and pass the
    value `bogus` to the `$service_state` parameter, you''ll get this error:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的类期望一个字符串类型的参数，并且该参数只能接受一些有限的值，你可以在 `Enum` 参数声明中列出所有允许的值，Puppet 不会允许传递任何不在该列表中的值。例如，在我们的示例中，如果你尝试声明
    `pbg_ntp_params2` 类，并将值 `bogus` 传递给 `$service_state` 参数，你会收到这个错误：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Just like any other parameter, an `Enum` parameter can take a default value,
    as it does in our example.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他参数一样，`Enum` 类型的参数也可以具有默认值，就像我们在示例中所做的那样。
- en: Automatic parameter lookup from Hiera data
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Hiera 数据中自动查找参数
- en: 'We''ve seen in this chapter, and the previous one that we can use Hiera data
    to pass parameters to classes. If we include a class named `ntp`, which accepts
    a parameter `version`, and a key exists in Hiera named `ntp::version`, its value
    will be passed to the `ntp` class as the value of `version`. For example, if the
    Hiera data looks like the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章和上一章中看到过，我们可以使用 Hiera 数据将参数传递给类。如果我们包含一个名为 `ntp` 的类，它接受一个名为 `version` 的参数，并且
    Hiera 中存在名为 `ntp::version` 的键，则其值将作为 `version` 的值传递给 `ntp` 类。例如，如果 Hiera 数据如下所示：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Puppet will automatically find this value and pass it to the `ntp` class when
    it's declared.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 将自动找到该值，并在声明 `ntp` 类时将其传递给 `ntp` 类。
- en: 'In general, Puppet determines parameter values in the following order of priority,
    highest first:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Puppet 按照以下优先顺序确定参数值，优先级从高到低：
- en: Literal parameters specified in a class declaration (you may see older code
    which does this)
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类声明中指定的文字参数（你可能会看到旧代码使用这种方式）
- en: Automatic parameter lookup from Hiera (the key must be named `CLASS_NAME::PARAMETER_NAME`)
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自 Hiera 的自动参数查找（键名必须为 `CLASS_NAME::PARAMETER_NAME`）
- en: Default values specified in a class definition
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类定义中指定的默认值
- en: Parameter data types
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数数据类型
- en: You should always specify types for your class parameters, as it makes it easier
    to catch errors where the wrong parameters or values are being supplied to the
    class. If you're using a String parameter, for example, if possible, make it an
    Enum parameter with an exact list of the values your class accepts. If you can't
    restrict it to a set of allowed values, specify a minimum length with `String[x]`.
    (If you need to specify a maximum length too, the syntax is `String[min, max]`.)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该始终为类参数指定类型，因为这有助于更容易捕捉到错误，比如错误的参数或值被传递到类中。例如，如果你使用的是 String 参数，尽可能将其设为 Enum
    参数，并列出类接受的确切值。如果不能限制为一组允许的值，可以指定最小长度，如 `String[x]`。（如果还需要指定最大长度，语法为 `String[min,
    max]`。）
- en: Available data types
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可用数据类型
- en: 'So far in this chapter, we''ve encountered the data types String, Enum, and
    Boolean. Here are the others:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们遇到了数据类型 String、Enum 和 Boolean。以下是其他类型：
- en: Integer (whole numbers)
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Integer（整数）
- en: Float (floating-point numbers, which have optional decimal fractions)
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Float（浮动小数，具有可选的小数部分）
- en: Numeric (matches either integers or floats)
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Numeric（匹配整数或浮动小数）
- en: Array
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Array
- en: Hash
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hash
- en: Regexp
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Regexp
- en: Undef (matches a variable or parameter which hasn't been assigned a value)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Undef（匹配尚未赋值的变量或参数）
- en: Type (data type of literal values which represent Puppet data types, such as
    String, Integer, and Array)
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Type（表示 Puppet 数据类型的字面值的数据类型，如 String、Integer 和 Array）
- en: 'There are also *abstract* data types, which are more general:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些 *抽象* 数据类型，它们更加通用：
- en: Optional (matches a value which may be undefined, or not supplied)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Optional（匹配一个可能未定义或未提供的值）
- en: Pattern (matches Strings which conform to a specified regular expression)
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pattern（匹配符合指定正则表达式的字符串）
- en: Scalar (matches Numeric, String, Boolean, or Regexp values, but not Array, Hash,
    or Undef)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scalar（匹配 Numeric、String、Boolean 或 Regexp 值，但不匹配 Array、Hash 或 Undef）
- en: Data (matches Scalar values, but also Array, Hash, and Undef)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Data（匹配 Scalar 值，但也匹配 Array、Hash 和 Undef）
- en: Collection (matches Array or Hash)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Collection（匹配 Array 或 Hash）
- en: Variant (matches one of a specified list of data types)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Variant（匹配指定数据类型列表中的一种）
- en: Any (matches any data type)
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Any（匹配任何数据类型）
- en: In general, you should use as specific a data type as possible. For example,
    if you know that a parameter will always be an integer number, use `Integer`.
    If it needs to accept floating-point values as well, use `Numeric`. If it could
    be a String as well as a Number, use `Scalar`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你应该尽可能使用更具体的数据类型。例如，如果你知道某个参数将始终是一个整数，使用 `Integer`。如果它也需要接受浮动小数值，使用 `Numeric`。如果它可以是字符串或数字，使用
    `Scalar`。
- en: Content type parameters
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内容类型参数
- en: Types which represent a collection of values, such as `Array` and `Hash` (or
    their parent type, `Collection`) can also take a parameter indicating the type
    of values they contain. For example, `Array[Integer]` matches an array of Integer
    values.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 代表一组值的类型，例如 `Array` 和 `Hash`（或它们的父类型 `Collection`）也可以接受一个参数，指示它们包含的值的类型。例如，`Array[Integer]`
    匹配一个整数值的数组。
- en: 'If you declare a content type parameter to a collection, then all the values
    in that collection must match the declared type. If you don''t specify a content
    type, the default is `Data`, which matches (almost) any type of value. The content
    type parameter can itself take parameters: `Array[Integer[1]]` declares an array
    of positive Integers.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你声明一个内容类型参数给一个集合，那么该集合中的所有值必须与声明的类型匹配。如果没有指定内容类型，默认值为 `Data`，它匹配（几乎）任何类型的值。内容类型参数本身也可以接受参数：`Array[Integer[1]]`
    声明了一个正整数数组。
- en: Hash takes two content type parameters, the first indicating the data type of
    its keys, the second the data type of its values. `Hash[String, Integer]` declares
    a hash whose keys are Strings, each of which is associated with an Integer value
    (this would match, for example, the hash `{'eggs' => 61}`).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Hash 需要两个内容类型参数，第一个表示键的数据类型，第二个表示值的数据类型。`Hash[String, Integer]` 声明一个哈希，其键是字符串，每个键关联一个整数值（例如，这将匹配哈希
    `{'eggs' => 61}`）。
- en: Range parameters
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范围参数
- en: Most types can also accept parameters in square brackets, which make the type
    declaration more specific. For example, we've already seen that `String` can take
    a pair of parameters indicating the minimum and maximum length of the string.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数类型也可以接受方括号中的参数，这些参数使类型声明更加具体。例如，我们已经看到 `String` 可以接受一对参数，表示字符串的最小和最大长度。
- en: 'Most types can take **range** **parameters**: `Integer[0]` matches any Integer
    greater than or equal to zero, while `Float[1.0, 2.0]` matches any Float between
    1.0 and 2.0 inclusive.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数类型可以接受**范围****参数**：`Integer[0]` 匹配任何大于或等于零的整数，而 `Float[1.0, 2.0]` 匹配 1.0
    到 2.0 之间（包括 1.0 和 2.0）的任何浮点数。
- en: If either range parameter is the special value `default`, the default minimum
    or maximum value for the type will be used. For example, `Integer[default, 100]`
    matches any Integer less than or equal to 100.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任一范围参数为特殊值 `default`，则将使用该类型的默认最小值或最大值。例如，`Integer[default, 100]` 匹配任何小于或等于
    100 的整数。
- en: 'For arrays and hashes, the range parameters specify the minimum and maximum
    number of elements or keys: `Array[Any, 16]` specifies an array of no less than
    16 elements of `Any` type. `Hash[Any, Any, 5, 5]` specifies a hash containing
    exactly five key-value pairs.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数组和哈希，范围参数指定元素或键的最小和最大数量：`Array[Any, 16]` 指定一个包含不少于 16 个 `Any` 类型元素的数组。`Hash[Any,
    Any, 5, 5]` 指定一个哈希，其中包含恰好五个键值对。
- en: 'You can specify both range and content type parameters at once: `Array[String,
    1, 10]` matches an array of between one and ten strings. `Hash[String, Hash, 1]`
    specifies a hash with String keys and Hash values, containing at least one key-value
    pair with String keys and values of type Hash.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以同时指定范围和内容类型参数：`Array[String, 1, 10]` 匹配一个包含 1 到 10 个字符串的数组。`Hash[String,
    Hash, 1]` 指定一个哈希，其键是字符串，值是哈希，且至少包含一对键值对，键是字符串，值的类型是哈希。
- en: Flexible data types
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 灵活的数据类型
- en: If you don't know exactly what type the values may be, you can use one of Puppet's
    more flexible **abstract types**, such as `Variant`, which specifies a list of
    allowed types. For example, `Variant[String, Integer]` allows its value to be
    either a String or an Integer.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定值的类型，可以使用 Puppet 更灵活的**抽象类型**，如 `Variant`，它指定一个允许类型的列表。例如，`Variant[String,
    Integer]` 允许其值为字符串或整数。
- en: Similarly, `Array[Variant[Enum['true', 'false'], Boolean]]` declares an array
    of values which can be either the String values `'true'` or `'false'` or the Boolean
    values `true` and `false`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`Array[Variant[Enum['true', 'false'], Boolean]]` 声明一个数组，其中的值可以是字符串值 `'true'`
    或 `'false'`，也可以是布尔值 `true` 和 `false`。
- en: The `Optional` type is very useful when a value may be undefined. For example,
    `Optional[String]` specifies a String parameter which may or may not be passed
    to the class. Normally, if a parameter is declared without a default value, Puppet
    will give an error when it is not supplied. If it is declared `Optional`, however,
    it may be omitted, or set to `Undef` (meaning that the identifier is defined,
    but has no value).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional` 类型在值可能未定义时非常有用。例如，`Optional[String]` 指定了一个可以传递也可以不传递的字符串参数。通常，如果一个参数没有声明默认值，Puppet
    会在没有提供值时抛出错误。然而，如果声明为 `Optional`，则可以省略，或设置为 `Undef`（意味着该标识符已定义，但没有值）。'
- en: The `Pattern` type allows you to specify a regular expression. All Strings matching
    that regular expression will be allowed values for the parameter. For example,
    `Pattern[/a/]` will match any String which contains the lowercase letter a. In
    fact, you can specify as many regular expressions as you like. `Pattern[/a/, /[0-9]/]`
    matches any String which contains the letter `a`, or any string which contains
    a digit.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pattern` 类型允许你指定一个正则表达式。所有符合该正则表达式的字符串都将被视为该参数的有效值。例如，`Pattern[/a/]` 会匹配任何包含小写字母
    `a` 的字符串。实际上，你可以指定任意多个正则表达式。`Pattern[/a/, /[0-9]/]` 会匹配任何包含字母 `a` 的字符串，或任何包含数字的字符串。'
- en: Defined resource types
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义的资源类型
- en: 'Whereas a class lets you group together related resources, a **defined resource
    type** lets you create new kinds of resources and declare as many instances of
    them as you like. A defined resource type definition looks a lot like a class
    (`defined_resource_type.pp`):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与类让你将相关资源组合在一起不同，**定义的资源类型**让你创建新的资源类型，并声明任意多个实例。定义资源类型的定义看起来非常像一个类（`defined_resource_type.pp`）：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can see that instead of the `class` keyword, we use the `define` keyword.
    This tells Puppet that we are creating a defined resource type instead of a class.
    The type is called `user_with_key`, and once it''s defined, we can declare as
    many instances of it as we want, just like any other Puppet resource:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们使用的是 `define` 关键字，而不是 `class` 关键字。这告诉 Puppet 我们正在创建一个定义的资源类型，而不是类。这个类型叫做
    `user_with_key`，一旦定义，我们就可以像其他 Puppet 资源一样声明它的多个实例：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When we do this, Puppet applies all the resources inside `user_with_key`: a
    user, a `.ssh` directory for that user, and an `ssh_authorized_key` for the user,
    containing the specified key.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，Puppet 会应用 `user_with_key` 中的所有资源：一个用户、该用户的 `.ssh` 目录，以及该用户的 `ssh_authorized_key`，其中包含指定的密钥。
- en: Tip
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Wait, we seem to be referring to a parameter called `$title` in the example
    code. Where does that come from? `$title` is a special parameter which is always
    available in classes and defined resource types, and its value is the title of
    this particular declaration of the class or type. In the example, that's `john`,
    because we gave the declaration of `user_with_key` the title `john`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，我们似乎在示例代码中引用了一个名为 `$title` 的参数。这个参数来自哪里？`$title` 是一个特殊的参数，它在类和定义的资源类型中始终可用，它的值是该类或类型声明的标题。在这个示例中，它是
    `john`，因为我们给 `user_with_key` 的声明指定了标题 `john`。
- en: So what's the difference between defined resource types and classes? They look
    pretty much the same. They seem to act the same. Why would you use one rather
    than the other? The most important difference is that you can only have **one
    declaration** of a given class on a given node, whereas you can have as many different
    instances of a defined resource type as you like. The only restriction is that,
    like all Puppet resources, the title of each instance of the defined resource
    type must be unique.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，定义的资源类型和类有什么区别呢？它们看起来几乎一样。它们似乎也有相似的作用。为什么你会选择使用其中一个而不是另一个呢？最重要的区别在于，你在一个节点上只能有一个给定类的**声明**，而你可以拥有任意多个不同实例的定义资源类型。唯一的限制是，像所有
    Puppet 资源一样，每个定义资源类型实例的标题必须是唯一的。
- en: Recall our example `ntp` class, which installs and runs the NTP daemon. Usually,
    you would only want one NTP service per node. There's very little point in running
    two. So we declare the class once, which is all we need.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们的 `ntp` 类，它安装并运行 NTP 守护进程。通常，你每个节点只希望有一个 NTP 服务。运行两个几乎没有意义。所以我们只声明一次该类，这就是我们需要的。
- en: Contrast this with the `user_with_key` defined resource type. It's quite likely
    that you'll want more than one `user_with_key` on a given node, perhaps several.
    In this case, a defined resource type is the right choice.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 将此与定义的 `user_with_key` 资源类型进行对比。很可能你希望在某个节点上拥有多个 `user_with_key`，可能有好几个。在这种情况下，定义的资源类型是正确的选择。
- en: Defined resource types are ideal in modules when you want to make a resource
    available to users of the module. For example, in the `puppetlabs/apache` module,
    the `apache::vhost` resource is a defined resource type, provided by the `apache`
    class. You can think of a defined resource type as being a wrapper for a collection
    of multiple resources.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 定义的资源类型在模块中非常理想，特别是当你想让模块的用户使用某个资源时。例如，在 `puppetlabs/apache` 模块中，`apache::vhost`
    资源是由 `apache` 类提供的定义资源类型。你可以将定义的资源类型看作是多个资源的包装器。
- en: Tip
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Remember this rule of thumb when deciding whether to create a class or a defined
    resource type: if it''s reasonable to have more than one instance on a given node,
    it should be a defined resource type, but if there will only ever be one instance,
    it should be a class.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定是创建类还是定义资源类型时，请记住这个经验法则：如果在给定节点上有多个实例是合理的，那么它应该是一个定义的资源类型；如果只有一个实例，它应该是一个类。
- en: Type aliases
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型别名
- en: 'It''s straightforward to define new **type aliases**, using the `type` keyword
    (`type_alias.pp`):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`type`关键字定义新的**类型别名**非常简单（`type_alias.pp`）：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Creating a type alias can be very useful when you want to ensure, for example,
    that parameter values match a complex pattern, which would be tiresome to duplicate.
    You can define the pattern in one place and declare multiple parameters of that
    type (`type_alias_pattern.pp`):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 创建类型别名非常有用，例如，当你想确保参数值匹配一个复杂的模式时，手动复制会很麻烦。你可以在一个地方定义这个模式，并声明多个该类型的参数（`type_alias_pattern.pp`）：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When creating a type alias in a module, it should be in a file named after the
    type in the `types` subdirectory of the module. For example, a type named `IPAddress`
    should be defined in the file `types/ipaddress.pp`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块中创建类型别名时，它应该位于模块的`types`子目录下，文件名与类型名称相同。例如，一个名为`IPAddress`的类型应该在`types/ipaddress.pp`文件中定义。
- en: Managing classes with Hiera
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Hiera管理类
- en: 'In [Chapter 3](ch03.html "Chapter 3. Managing your Puppet code with Git"),
    *Managing your Puppet code with Git*, we saw how to set up your Puppet repo on
    multiple nodes and auto-apply the manifest using a cron job and the `run-puppet`
    script. The `run-puppet` script runs the following commands:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章：使用Git管理Puppet代码")，*使用Git管理Puppet代码*中，我们看到了如何在多个节点上设置Puppet仓库，并使用cron作业和`run-puppet`脚本自动应用清单。`run-puppet`脚本运行以下命令：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can see that everything in the `manifests/` directory will be applied on
    every node. Clearly, Puppet is much more useful when we can apply different manifests
    on each node; some nodes will be web servers, others database servers, and so
    on. In fact, we would like to include some classes on all nodes, for general administration,
    such as managing user accounts, and other classes only on specific nodes. So how
    do we do that?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，`manifests/`目录中的所有内容将在每个节点上应用。显然，当我们能够在每个节点上应用不同的清单时，Puppet的作用就更大了；一些节点将是Web服务器，另一些将是数据库服务器，等等。实际上，我们希望在所有节点上包括一些类，用于通用管理，例如管理用户帐户，其他类则仅在特定节点上使用。那么我们该怎么做呢？
- en: Using include with lookup()
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`include`与`lookup()`一起
- en: 'Previously, when including classes in our manifest, we''ve used the `include`
    keyword with a literal class name, as in the following example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，在我们的清单中包含类时，我们使用了带有字面类名的`include`关键字，如下例所示：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'However, `include` can also be used as a function, which takes an array of
    class names to include:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`include`也可以作为一个函数使用，它接受一个包含类名的数组：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We already know that we can use Hiera to return different values for a query
    based on the node name (or anything else defined in the hierarchy), so let''s
    define a suitable array in Hiera data, as in the following example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道，可以使用Hiera根据节点名称（或层次结构中定义的任何其他内容）返回不同的查询值，因此我们可以在Hiera数据中定义一个合适的数组，如下例所示：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we can simply use `lookup()` to get this Hiera value, and pass the result
    to the `include()` function:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以简单地使用`lookup()`来获取这个Hiera值，并将结果传递给`include()`函数：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In effect, this is your entire Puppet manifest. Every node will apply this manifest,
    and thus include the classes assigned to it by the Hiera data. Since the top-level
    manifest file is traditionally named `site.pp`, you can put this `include` line
    in `manifests/site.pp`, and the `papply` or `run-puppet` scripts will apply it
    because they apply everything in the `manifests/` directory.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这就是你整个Puppet清单的内容。每个节点都会应用这个清单，从而包括Hiera数据中为其分配的类。由于顶级清单文件通常命名为`site.pp`，因此你可以将这行`include`放入`manifests/site.pp`中，`papply`或`run-puppet`脚本将应用它，因为它们会应用`manifests/`目录中的所有内容。
- en: Common and per-node classes
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公共类和每节点类
- en: 'We can specify a set of classes in `common.yaml` which will be applied to all
    nodes: things such as user accounts, SSH and `sudoers` config, time zone, NTP
    setup, and so on. The complete example repo outlined in [Chapter 12,](ch12.html
    "Chapter 12. Putting it all together") *Putting it all together* has a typical
    set of such classes defined in `common.yaml`.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`common.yaml`中指定一组类，这些类将应用于所有节点：例如用户帐户、SSH和`sudoers`配置、时区、NTP设置等。在[第12章](ch12.html
    "第12章：将一切整合")中，*将一切整合*的完整示例仓库定义了一组典型的类，并且这些类都在`common.yaml`中。
- en: 'However, some classes will only be needed on particular nodes. Add these to
    the per-node Hiera data file. For example, our `pbg` environment on the Vagrant
    box contains the following in `hiera.yaml`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，某些类只在特定节点上需要。将这些类添加到每节点的Hiera数据文件中。例如，我们在Vagrant盒子上的`pbg`环境在`hiera.yaml`中包含以下内容：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So per-node data for a node named `node1` will live in the `nodes/node1.yaml`
    file under the `data/` directory.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，名为`node1`的节点的每节点数据将保存在`data/`目录下的`nodes/node1.yaml`文件中。
- en: 'Let''s see a complete example. Suppose your `common.yaml` file contains the
    following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个完整的示例。假设你的`common.yaml`文件包含如下内容：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And suppose your per-node file (`nodes/node1.yaml`) also contains:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的每节点文件（`nodes/node1.yaml`）也包含以下内容：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, what happens when you apply the following manifest in `manifests/site.pp`
    on `node1`?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你在`node1`上应用以下清单（`manifests/site.pp`）时会发生什么？
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Which classes will be applied? You may recall from [Chapter 6,](ch06.html "Chapter 6. Managing
    data with Hiera") *Managing data with Hiera* that the `unique` merge strategy
    finds all values for the given key throughout the hierarchy, merges them together,
    and returns them as a flattened array, with duplicates removed. So the result
    of this `lookup()` call will be the following array:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些类将会被应用？你可能还记得[第6章](ch06.html "第6章：使用Hiera管理数据")，*使用Hiera管理数据*中提到的，`unique`合并策略会查找整个层次结构中给定键的所有值，将它们合并在一起，并作为一个扁平化的数组返回，重复项被移除。因此，这个`lookup()`调用的结果将是以下数组：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is the complete list of classes that Puppet will apply to the node. Of
    course, you can add classes at any other level of the hierarchy, if you need to,
    but you will probably find the common and per-node levels to be the most useful
    for including classes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Puppet将应用于节点的完整类列表。当然，如果需要，你可以在层次结构的其他任何级别添加类，但你可能会发现常规层级和每个节点的层级最适合用于包含类。
- en: Naturally, even though some nodes may include the same classes as others, they
    may need different configuration values for the classes. You can use Hiera in
    the same way to supply different parameters for the included classes, as described
    in the *Automatic parameter lookup from Hiera data* section earlier in this chapter.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 自然，尽管一些节点可能包含与其他节点相同的类，它们可能需要为这些类提供不同的配置值。你可以像之前在本章的*从Hiera数据自动查找参数*部分中描述的那样，使用Hiera为包含的类提供不同的参数。
- en: Roles and profiles
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色和配置文件
- en: 'Now that we know how to include different sets of classes on a given node,
    depending on the job the node is supposed to do, let''s think more about how to
    name those classes in the most helpful way. For example, consider the following
    list of included classes for a certain node:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何根据节点要执行的任务，在给定节点上包含不同的类集，让我们更深入地思考如何以最有帮助的方式命名这些类。例如，考虑下面某个节点的包含类列表：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The class names give some clues as to what this node might be doing. It looks
    like it's probably an app server running a Java app named `my_app` served by Tomcat
    behind Apache, and backed by a PostgreSQL database. That's a good start, but we
    can do even better than this, and we'll see how in the next section.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 类名为我们提供了一些关于这个节点可能在做什么的线索。看起来它可能是一个运行Java应用程序`my_app`的应用服务器，通过Tomcat在Apache后端提供服务，并由PostgreSQL数据库支持。这是一个很好的开始，但我们可以做得更好，我们将在下一节看到如何做。
- en: Roles
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色
- en: 'To make it obvious that the node is an app server, why don''t we create a class
    called `role::app_server`, which exists only to encapsulate the node''s included
    classes? That class definition might look like this (`role_app_server.pp`):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确节点是一个应用服务器，为什么不创建一个名为`role::app_server`的类，该类仅用于封装节点包含的类呢？该类的定义可能如下所示（`role_app_server.pp`）：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We call this idea a **role class**. A role class could simply be a module in
    its own right, or to make it clear that this is a role class, we could organize
    it into a special `role` module. If you keep all your role classes in a single
    module, then they will all be named `role::something`, depending on the role they
    implement.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个概念称为**角色类**。角色类可以仅仅是一个独立的模块，或者为了明确表示这是一个角色类，我们可以将其组织成一个特殊的`role`模块。如果你将所有的角色类放在一个模块中，那么它们的名称将都以`role::something`命名，具体取决于它们实现的角色。
- en: Tip
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It's important to note that role classes are not special to Puppet in any way.
    They're just ordinary classes; we call them role classes only to remind ourselves
    that they are for expressing the roles assigned to a particular node.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，角色类在Puppet中并不特别。它们只是普通的类；我们之所以称它们为角色类，仅仅是为了提醒自己它们是用来表达分配给特定节点的角色。
- en: 'The value of `classes` in Hiera is now reduced to just the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Hiera 中 `classes` 的值现在简化为以下内容：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Looking at the Hiera data, it's now very easy to see what the node's job is—what
    its *role* is—and all app servers now just need to include `role::app_server`.
    When or if the list of classes required for app servers changes, you don't need
    to find and update the Hiera `classes` value for every app server; you just need
    to edit the `role::app_server` class.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 看着 Hiera 数据，现在很容易看出节点的工作是什么——它的*角色*是什么——所有应用服务器现在只需要包括 `role::app_server`。当应用服务器所需的类列表发生变化时，你不需要找到并更新每个应用服务器的
    Hiera `classes` 值；只需要编辑 `role::app_server` 类。
- en: Profiles
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置文件
- en: We can tidy up our manifest quite a bit by adopting the rule of thumb that,
    apart from common configuration in `common.yaml`, **nodes should only include
    role classes**. This makes the Hiera data more self-documenting, and our role
    classes are all neatly organized in the `role` module, each of them encapsulating
    all the functionality required for that role. It's a big improvement. But can
    we do even better?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用一个经验法则，我们可以整理清单：除了在 `common.yaml` 中的公共配置外，**节点应该只包含角色类**。这使得 Hiera 数据更具自我文档性，而且我们的角色类都整齐地组织在
    `role` 模块中，每个角色类都封装了该角色所需的所有功能。这是一个很大的改进。但我们能做得更好吗？
- en: 'Let''s look at a role class such as `role::app_server`. It contains lots of
    lines including modules, like the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看像 `role::app_server` 这样的角色类。它包含很多行，包括模块，像这样：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If all you need to do is include a module and have the parameters automatically
    looked up from Hiera data, then there's no problem. This is the kind of simple,
    encouraging, unrealistic example you'll see in product documentation or on a conference
    slide.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要包括一个模块，并且让参数自动从 Hiera 数据中查找，那么就没有问题。这种简单、鼓励性的、不切实际的示例通常会出现在产品文档或会议幻灯片上。
- en: Real-life Puppet code is often more complicated, however, with logic and conditionals
    and special cases, and extra resources that need to be added, and so forth. We
    don't want to duplicate all this code when we use Tomcat as part of another role
    (for example, serving another Tomcat-based app). How can we neatly encapsulate
    it at the right level of abstraction and avoid duplication?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，真实的 Puppet 代码通常更复杂，包含逻辑、条件语句、特殊情况以及需要添加的额外资源等。我们不想在将 Tomcat 用作另一个角色的一部分时重复所有这些代码（例如，提供另一个基于
    Tomcat 的应用）。我们如何在合适的抽象层次封装它并避免重复？
- en: We could, of course, create a custom module for each app, which hides away all
    that messy support code. However, it's a big overhead to create a new module just
    for a few lines of code, so it seems like there should be a niche for a small
    layer of code which bridges the gap between roles and modules.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以为每个应用创建一个自定义模块，将所有这些杂乱的支持代码隐藏起来。然而，为了几行代码创建一个新模块是一个很大的开销，因此似乎应该有一个小层代码填补角色与模块之间的空隙。
- en: 'We call this a **profile class**. A profile encapsulates some specific piece
    of software or functionality which is required for a role. In our example, the
    `app_server` role requires several pieces of software: PostgreSQL, Tomcat, Apache,
    and so on. Each of these can now have its own profile.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称之为 **配置文件类**。配置文件封装了角色所需的一些特定软件或功能。在我们的例子中，`app_server` 角色需要几种软件：PostgreSQL、Tomcat、Apache
    等。现在，每个软件都可以有它自己的配置文件。
- en: 'Let''s rewrite the `app_server` role to include profiles, instead of modules
    (`role_app_server_profiles.pp`):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写 `app_server` 角色以包括配置文件，而不是模块（`role_app_server_profiles.pp`）：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: What would be in these profile classes? The `profile::tomcat` class, for example,
    would set up the specific configuration of Tomcat required, along with any app-specific
    or site-specific resources required, such as firewall rules, `logrotate` config,
    file and directory permissions, and so on. The profile wraps the module, configures
    it, and provides everything the module does not, in order to support this particular
    application or site.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这些配置文件类中会有什么内容？例如，`profile::tomcat` 类将设置 Tomcat 所需的特定配置，同时还包括任何特定应用或站点所需的资源，如防火墙规则、`logrotate`
    配置、文件和目录权限等。配置文件封装了模块，配置它，并提供模块未涵盖的部分，以支持该特定应用或站点。
- en: 'The `profile::tomcat` class might look something like the following example,
    adapted from a real production manifest (`profile_tomcat.pp`):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`profile::tomcat` 类可能看起来像以下示例，改编自一个真实的生产清单（`profile_tomcat.pp`）：'
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The exact contents of this class don't really matter here, but the point you
    should take away is that this kind of site-specific 'glue' code, wrapping third-party
    modules and connecting them with particular applications, should live in a profile
    class.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这类配置文件的具体内容在这里并不重要，但你应该记住的是，这种特定站点的“胶水”代码，用来包装第三方模块并将它们与特定应用程序连接，应该放在配置文件类中。
- en: In general, a profile class should include everything needed to make that particular
    software component or service work, including other profiles if necessary. For
    example, every profile which requires a specific configuration of Java should
    include that Java profile. You can include a profile from multiple other profiles
    without any conflicts.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个配置文件类应该包含使该特定软件组件或服务正常工作的所有内容，包括必要时的其他配置文件。例如，每个需要特定Java配置的配置文件应该包含该Java配置文件。你可以从多个其他配置文件中包含配置文件，而不会发生冲突。
- en: Using profile classes in this way both makes your role classes neater, tidier,
    and easier to maintain, but it also allows you to reuse the profiles for different
    roles. The `app_server` role includes these profiles, and other roles can include
    them as well. This way, our code is organized to reduce duplication and encourage
    re-use. The second rule of thumb is, **roles should only include profiles**.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用配置文件类，既可以让你的角色类更加整洁、有序且易于维护，还可以让你重用这些配置文件来适应不同的角色。`app_server`角色包含了这些配置文件，其他角色也可以包含它们。这样，我们的代码组织得更加有序，减少了重复，并鼓励重用。第二条经验法则是，**角色应该仅包含配置文件**。
- en: 'If you''re still confused about the exact distinction between roles and profiles,
    don''t worry: you''re in good company. Let''s try and define them as succinctly
    as possible:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然对角色和配置文件之间的确切区别感到困惑，不用担心：你并不孤单。让我们尽可能简洁地定义它们：
- en: '**Roles** identify a particular function for a node, such as being an app server
    or a database server. A role exists to document what a node is for. Roles should
    only include profiles, but they can include any number of profiles.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角色**标识节点的特定功能，例如作为应用服务器或数据库服务器。角色存在的目的是记录节点的用途。角色应该仅包含配置文件，但可以包含任意数量的配置文件。'
- en: '**Profiles** identify a particular piece of software or functionality which
    contributes to a role; for example, the `tomcat` profile is required for the `app_server`
    role. Profiles generally install and configure a specific software component or
    service, its associated business logic, and any other Puppet resources needed.
    Profiles are the ''glue layer'' which sits between roles and modules.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置文件**标识为角色提供特定软件或功能的部分；例如，`tomcat`配置文件是`app_server`角色所需要的。配置文件通常安装和配置特定的软件组件或服务、其相关的业务逻辑以及任何其他所需的Puppet资源。配置文件是“胶水层”，位于角色和模块之间。'
- en: It's possible that your manifest may be so simple that you can organize it using
    only roles or only profiles. That's fine, but when things start getting more complex
    and you find yourself duplicating code, consider refactoring it to use the roles-and-profiles
    pattern in the way we've seen here.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你的清单可能非常简单，以至于你只需要使用角色或仅使用配置文件来组织它。这没有问题，但当事情变得更加复杂，并且你发现自己在重复代码时，可以考虑按照我们在这里看到的方式重构代码，采用角色和配置文件模式。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've looked at a range of different ways of organizing your
    Puppet code. We've covered classes in detail, explaining how to define them using
    the `class` keyword to define a new class, using the `include` keyword to declare
    the class, and using Hiera's automatic parameter lookup mechanism to supply parameters
    for included classes.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了多种组织Puppet代码的方式。我们详细介绍了类的定义，说明了如何使用`class`关键字定义一个新类，如何使用`include`关键字声明类，以及如何使用Hiera的自动参数查找机制为包含的类提供参数。
- en: Declaring parameters involves specifying the allowable data types for parameters,
    and we've had a brief overview of Puppet's data types, including scalars, collections,
    content types and range parameters, abstract types, flexible types, and introduced
    creating your own type aliases. We've also introduced the defined resource type,
    and explained the difference between defined resource types and classes, and when
    you would use one or the other.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 声明参数涉及指定参数的允许数据类型，我们简要概述了Puppet的数据类型，包括标量、集合、内容类型和范围参数、抽象类型、灵活类型，并介绍了如何创建你自己的类型别名。我们还介绍了定义资源类型，解释了定义资源类型与类之间的区别，以及何时使用其中的一个或另一个。
- en: We've also looked at how to use the `classes` array in Hiera to include common
    classes on all nodes, and other classes only on particular nodes. We've introduced
    the idea of the role class, which encapsulates everything needed for a node to
    fulfil a particular role, such as an app server.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了如何在 Hiera 中使用 `classes` 数组将公共类包含在所有节点上，而将其他类仅包含在特定节点上。我们介绍了角色类的概念，角色类封装了节点完成特定角色所需的所有内容，比如应用服务器。
- en: Finally, we've seen how to use profile classes to configure and support a particular
    software package or service, and how to compose several profile classes into a
    single role class. Between them, roles and profiles bridge the gap between the
    Hiera `classes` array, at the top level, and modules and configuration data (at
    the lowest level). We can summarize the rules by saying that *nodes should only
    include roles, and roles should only include profiles*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到如何使用配置文件类来配置和支持特定的软件包或服务，并且如何将多个配置文件类组合成一个角色类。角色和配置文件类之间架起了 Hiera `classes`
    数组（位于顶层）与模块和配置数据（位于最底层）之间的桥梁。我们可以通过总结规则来说，*节点应只包含角色，角色应只包含配置文件*。
- en: In the next chapter we'll look at using Puppet to create files using templates,
    iteration, and Hiera data.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将探讨如何使用 Puppet 利用模板、迭代和 Hiera 数据创建文件。
