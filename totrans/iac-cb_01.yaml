- en: Chapter 1. Vagrant Development Environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding an Ubuntu Xenial (16.04 LTS) Vagrant box
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a disposable Ubuntu Xenial (16.04) in seconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling VirtualBox Guest Additions in Vagrant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a disposable CentOS 7.x with VMware in seconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the VMware VM capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling multiprovider Vagrant environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing a Vagrant VM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Docker with Vagrant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Docker in Vagrant for a Ghost blog behind NGINX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Vagrant remotely with AWS EC2 and Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating dynamic multiple host networking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating a networked three-tier architecture app with Vagrant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing your work on the LAN while working with Laravel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing access to your Vagrant environment with the world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating Chef upgrades using Vagrant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Ansible with Vagrant to create a Docker host
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Docker containers on CoreOS with Vagrant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vagrant is a free and open source tool by Hashicorp aimed at building a repeatable
    development environment inside a virtual machine, using simple Ruby code. You
    can then distribute this simple file with other people, team members, and external
    contributors, so that they immediately have a working running environment as long
    as they have virtualization on their laptop. It also means that you can use a
    Mac laptop, and with a simple command, launch a fully configured Linux environment
    for you to use locally. Everyone can work using the same environment, regardless
    of their own local machine. Vagrant is also very useful to simulate full production
    environments, with multiple machines and specific operating system versions. Vagrant
    is compatible with most hypervisors, such as VMware, VirtualBox, or Parallels,
    and can be largely extended using plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Vagrant uses *boxes* to run. These boxes are just packaged virtual machines
    images that are available, for example, from [https://atlas.hashicorp.com/boxes/search](https://atlas.hashicorp.com/boxes/search),
    or you can alternatively build your own using various tools.
  prefs: []
  type: TYPE_NORMAL
- en: Vagrant can be greatly extended using plugins. There're plugins for almost anything
    you can think about, and most of them are community supported. From specific guest
    operating systems to remote IaaS providers, features around sharing, caching or
    snapshotting, networking, testing or specifics to Chef/Puppet, a lot can be done
    through plugins in Vagrant.
  prefs: []
  type: TYPE_NORMAL
- en: 'A list of all available plugins, including all Vagrant providers is available
    on the Vagrant wiki here: [https://github.com/mitchellh/vagrant/wiki/Available-Vagrant-Plugins](https://github.com/mitchellh/vagrant/wiki/Available-Vagrant-Plugins).'
  prefs: []
  type: TYPE_NORMAL
- en: 'More information about all integrated providers can be found on Vagrant''s
    website: [https://www.vagrantup.com/docs/providers/](https://www.vagrantup.com/docs/providers/).'
  prefs: []
  type: TYPE_NORMAL
- en: You can download a Vagrant installer for your platform from [https://www.vagrantup.com/downloads.html](https://www.vagrantup.com/downloads.html).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Vagrant version in use for this book is Vagrant 1.8.4
  prefs: []
  type: TYPE_NORMAL
- en: Adding an Ubuntu Xenial (16.04 LTS) Vagrant box
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vagrant boxes are referred to by their names, usually following the *username/boxname*
    naming scheme. A 64-bits *Precise* box released by *Ubuntu* will be named *ubuntu/precise64*
    while the *centos/7* box will always be the latest CentOS 7 official box.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Vagrant installation using the free and open source Virtualbox hypervisor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open a terminal and type the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vagrant knows where to look for the latest version for the requested box on
    the Atlas service and automatically downloads it over the Internet. All boxes
    are stored by default in `~/.vagrant.d/boxes`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you're interested in creating your own base Vagrant boxes, refer to Packer
    ([https://www.packer.io/](https://www.packer.io/)) and the Chef Bento project
    ([http://chef.github.io/bento/](http://chef.github.io/bento/)).
  prefs: []
  type: TYPE_NORMAL
- en: Using a disposable Ubuntu Xenial (16.04) in seconds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to access and use an Ubuntu Xenial system (16.04 LTS) as quickly as
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, Vagrant uses a file named `Vagrantfile` to describe the Vagrant
    infrastructure. This file is in fact pure Ruby that Vagrant reads to manage your
    environment. Everything related to Vagrant is done inside a block such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Vagrant installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working VirtualBox installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a folder for the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using your favorite editor, create this very minimal Vagrantfile to launch
    an ubuntu/`xenial64` box:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now you can execute Vagrant, by explicitly using the Virtualbox hypervisor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within seconds, you''ll have a running Ubuntu 16.04 Vagrant box on your host
    and you can do whatever you want with it. For example, start by logging into it
    via **Secure Shell** (**SSH**) by issuing the following `vagrant` command and
    use the system normally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you''re done with your Vagrant VM, you can simply destroy it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, we can just stop the Vagrant VM with the goal of restarting
    it later in its current state using vagrant halt:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**$ vagrant halt**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you started Vagrant, it read the Vagrantfile, asking for a specific box
    to run (Ubuntu Xenial). If you previously added it, it will launch it right away
    through the default hypervisor (in this case, VirtualBox), or if it's a new box,
    download it for you automatically. It created the required virtual network interfaces,
    then the Ubuntu VM got a private IP address. Vagrant took care of configuring
    **SSH** by exposing an available port and inserting a default key, so you can
    log into it via SSH without problems.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling VirtualBox Guest Additions in Vagrant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The VirtualBox Guest Additions are a set of drivers and applications to be deployed
    on a virtual machine to have better performance and enable features such as folder
    sharing. While it's possible to include the **Guest Additions** directly in the
    box, not all the boxes you'll find have it, and even when they do, they can be
    outdated very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to automatically deploy the VirtualBox Guest Additions on demand,
    through a plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The downside to using this plugin is that the Vagrant box may now take longer
    to boot, as it may need to download and install the right guest additions for
    the box.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Vagrant installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working VirtualBox installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Vagrantfile from the previous recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to enable VirtualBox Guest Additions in Vagrant:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `vagrant-vbguest` plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Confirm that the plugin is installed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start Vagrant and see that the VirtualBox Guest Additions are installed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, maybe you don''t want to do this every time you start you Vagrant box,
    because it takes time and bandwidth or because the minor difference between your
    host VirtualBox version and the one already installed in the Vagrant box isn''t
    a problem for you. In this case, you can simply tell Vagrant to disable the auto-update
    feature right from the Vagrantfile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An even better way to keep your code compatible with people without this plugin
    is to use this plugin configuration only if the plugin is found by Vagrant itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The full Vagrantfile now looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vagrant plugins are automatically installed from the vendor's website, and made
    available globally on your system for all other Vagrant environments you'll run.
    Once the virtual machine is ready, the plugin will detect the operating system,
    decide if the Guest Additions need to be installed or not, and if they do, install
    the necessary tools to do that (compilers, kernel headers, and libraries), and
    finally download and install the corresponding Guest Additions.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using Vagrant plugins also extends what you can do with the Vagrant CLI. In
    the case of the VirtualBox Guest Addition plugin, you can do a lot of things such
    as status checks, manage the installation, and much more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The plugin can later be called through Vagrant directly; here it''s triggering
    the Guest Additions installation in the virtual machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using a disposable CentOS 7.x with VMware in seconds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vagrant supports both VMware Workstation and VMware Fusion through official
    plugins available on the Vagrant store ([https://www.vagrantup.com/vmware](https://www.vagrantup.com/vmware)).
    Follow the indications from the official website to install the plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Vagrant boxes depend on the hypervisor—a VirtualBox image won't run on VMware.
    You need to use dedicated images for each supervisor you choose to use. For example,
    Ubuntu official releases only provide VirtualBox images. If you try to create
    a Vagrant box with a provider while using an image built for another provider,
    you'll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Vagrant installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working VMware Workstation (PC) or Fusion (Mac) installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working Vagrant VMware plugin installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Chef Bento project provides various multiprovider images we can use. For
    example, let''s use a CentOS 7.2 with Vagrant (bento/centos-7.2) with this simplest
    Vagrantfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Start your CentOS 7.2 virtual environment and specify the hypervisor you want
    to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You're now running a CentOS 7.2 Vagrant box using VMware!
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vagrant is powered by plugins extending its usage and capabilities. In this
    case, the Vagrant plugin for VMware delegates all the virtualization features
    to the VMware installation, removing the need for VirtualBox.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If VMware is your primary hypervisor, you''ll soon be tired to always specify
    the provider in the command line. By setting the `VAGRANT_DEFAULT_PROVIDER` environment
    variable to the corresponding plugin, you will never have to specify the provider
    again, VMware will be the default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Chef Bento Project at [http://chef.github.io/bento/](http://chef.github.io/bento/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A community VMware vSphere plugin at [https://github.com/nsidc/vagrant-vsphere](https://github.com/nsidc/vagrant-vsphere)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A community VMware vCloud Director plugin at [https://github.com/frapposelli/vagrant-vcloud](https://github.com/frapposelli/vagrant-vcloud)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A community VMware vCenter plugin at [https://github.com/frapposelli/vagrant-vcenter](https://github.com/frapposelli/vagrant-vcenter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A community VMware vCloud Air plugin at [https://github.com/frapposelli/vagrant-vcloudair](https://github.com/frapposelli/vagrant-vcloudair)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the VMware VM capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The hardware specifications of the Vagrant box vary from image to image as
    they''re specified at the creation time. However, it''s not fixed forever: it''s
    just the default behavior. You can set the requirements right in the Vagrantfile,
    so you can keep a daily small Vagrant box and on-demand.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Vagrant installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working VMware Workstation (PC) or Fusion (Mac) installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working Vagrant VMware plugin installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Vagrantfile from the previous recipe using a bento/centos72 box
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The VMware provider can be configured inside the following configuration blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If the configuration is the same, you''ll end up with a lot of duplicated code.
    Take advantage of the Ruby nature of the Vagrantfile and use a simple loop to
    iterate through both values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Our default Bento CentOS 7.2 image has only 512 MB of RAM and one CPU. Let''s
    double that for better performance using the `vmx["numvcpus"]` and `vmx["memsize"]`
    keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Start or restart your Vagrant machine to apply the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Your box is now using two CPUs and 1 GB of RAM.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Virtual machine configuration is the last thing done by Vagrant before starting
    up. Here, it just tells VMware to allocate two CPUs and 1 GB of RAM to the virtual
    machine it's launching the way you would have done manually from inside the software.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vagrant's authors may merge both plugins into one at some point in the future.
    The current 4.x version of the plugins is still split.
  prefs: []
  type: TYPE_NORMAL
- en: The VMX format is not very well documented by VMware. The possible keys and
    values can be found on most VMware Inc. documentation about VMX configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling multiprovider Vagrant environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might be running VMware on your laptop, but your coworker might not. Alternatively,
    you want people to have the choice, or you simply want both environments to work!
    We'll see how to build a single Vagrantfile to support them all.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Vagrant installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working VirtualBox installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working VMware Workstation (PC) or Fusion (Mac) installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working Vagrant VMware plugin installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Vagrantfile from the previous recipe using a bento/centos72 box
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some Vagrant boxes are available for multiple hypervisors, such as the CentOS
    7 Bento box we previously used. This way, we can simply choose which one to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with our previous Vagrantfile including customizations for VMware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'How would we add the same configuration on VirtualBox as we have on VMware?
    Here''s how to customize VirtualBox similarly in the Vagrantfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Add this to your current Vagrantfile, reload and you'll get the requested resources
    from your hypervisor, be it VMware or VirtualBox.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s nice, but we''re still repeating ourselves with the values, leading to
    possible errors, omissions, or mistakes in the future. Let''s take advantage once
    again of the Ruby nature of our Vagrantfile and declare some meaningful variables
    at the top of our file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now replace the four values by their variable names and you''re done: you''re
    centrally managing characteristics of the Vagrant environment you''re using and
    distributing, whatever hypervisor you''re using.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simple fact that the Vagrantfile is a pure Ruby file helps creating powerful
    and dynamic configuration, by simply setting variables that we use later for all
    the providers.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing a Vagrant VM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vagrant supports many configuration options through the Vagrantfile. Here are
    the most useful ones for daily use.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Vagrant installation (with a hypervisor)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Vagrantfile from the previous recipe using a bento/centos72 box
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are some possible customizations for your Vagrant Virtual Machine.
  prefs: []
  type: TYPE_NORMAL
- en: Set the hostname
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to specify the VM name right from Vagrant, just add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This will also add an entry with the hostname to the `/etc/host` file.
  prefs: []
  type: TYPE_NORMAL
- en: Disable new box version check at startup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You may be using a slow internet connection, or you know you do want to use
    your current installed box, or maybe you''re in a hurry and just want to get the
    job done; you can just remove the option to check for a new version of the box
    at startup by adding the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Use a specific box version
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you know you want to use a specific version of the box (maybe for debugging
    purposes or compliance) and not the latest, you can simply declare it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Display an informational message to the user
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A useful feature is to display some basic but relevant information to the user
    launching the Vagrant box, such as usage or connection information. Don''t forget
    to escape the special characters. As it''s Ruby, you can access all available
    variables, so the message can be even more dynamic and useful to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Specify a minimum Vagrant version
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Vagrant is updated quite often, and new features are added regularly. A good
    practice, if you use a feature that is known to work only after a specific version,
    is to declare it in the Vagrantfile, so people with an older version know they
    have to update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Using Docker with Vagrant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Development environments can often be mixed, using both virtual machines and
    Docker containers. While virtual machines include everything needed to run a full
    operating system like memory, CPU, a kernel and all required libraries, a container
    is much more lightweight and can share all this with its host, while keeping a
    good isolation through special kernel features named cgroups. Docker containers
    helps developers use, share and ship a *bundle* including everything needed to
    run their application. Here, we'll show how to use Vagrant to start containers.
    Since Docker usage is a little different between Linux hosts and other platforms,
    the reference used here is the native Docker platform—Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Vagrant installation (no hypervisor needed)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working Docker installation and basic Docker knowledge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll see how to use, access, and manipulate an NGINX container in Vagrant using
    Docker as a provider.
  prefs: []
  type: TYPE_NORMAL
- en: Using NGINX Docker container through Vagrant
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s start with the simplest Vagrantfile possible, using the `nginx:stable`
    container with the Docker Vagrant provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Simply start it up with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s remove the need to specify the provider on the command line by setting
    a simple Ruby environment access code at the top of the Vagrantfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now you can distribute your Vagrantfile and not worry about people forgetting
    to explicitly specify the Docker provider.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing Docker ports in Vagrant
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Okay, the previous example wasn''t terribly useful as we didn''t expose any
    ports. Let''s tell Vagrant to expose the Docker container HTTP (TCP/80) port to
    our host''s HTTP (TCP/80) port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the Vagrant and verify you can access your NGINX container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Sharing folders with Docker through Vagrant
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What about sharing a local folder so you can code on your laptop and see the
    result processed by the Vagrant environment? The default NGINX configuration reads
    files from `/usr/share/nginx/html`. Let's put our own `index.html` in there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a simple `src/index.html` file, containing some text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the Docker volume configuration to our Docker provider block in Vagrant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`#{Dir.pwd}` is the Ruby for finding the current directory, so you don''t hardcode
    paths, making it highly distributable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Restart the Vagrant environment and see the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On SELinux-enabled systems you may need to do some configuration that''s beyond
    the scope of this book. We encourage you to secure your Docker systems using SELinux,
    but to disable SELinux just type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can choose not to use your local or default Docker installation, but instead
    use a dedicated VM, maybe to reflect production or a specific OS (such as CoreOS).
    In this case, you can specify a dedicated Vagrantfile as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Using Docker in Vagrant for a Ghost blog behind NGINX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vagrant in Docker can be used more usefully to simulate traditional setups such
    as an application behind a load balancer or a reverse proxy. We've already set
    up NGINX, so what about using it as a front reverse proxy with a blog engine such
    as Ghost behind it? We'll end up by showing how to do something similar with docker-compose.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Vagrant installation (no hypervisor needed)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working Docker installation and basic Docker knowledge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous example allows only one container to be launched simultaneously,
    which is sad considering the power of Docker. Let''s define multiple containers
    and start by creating a `front` container (our previous NGINX):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now how about creating an application container, maybe a blog engine such as
    Ghost? Ghost publishes a ready-to-use container on the Docker Hub, so let''s use
    that (version 0.9.0 at the time of writing) and expose on TCP/8080 the application
    container listening on TCP/2368:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Check if you can access the blog on `http://localhost:8080` and NGINX on `http://localhost`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s use NGINX for what it''s for—serving the application. Configuring
    NGINX as a reverse proxy is beyond the scope of this book, so just use the following
    simple configuration for the `nginx.conf` file at the root of your working folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the configuration of the `front` container in Vagrant to use this configuration,
    remove the old `index.html` as we''re not using it anymore, and link this container
    to the `app` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Linking the `app` container makes it available to the `front` container, so
    now there''s no need to expose the Ghost blog container directly, let''s make
    it simpler and more secure behind the reverse proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re close! But this setup will eventually fail for a simple reason: our
    systems are too fast, and Vagrant parallelizes the startup of virtual machines
    by default, and also does this for containers. Containers start so fast that the
    `app` container may not be ready for NGINX when it''s started. To ensure sequential
    startup, use the `VAGRANT_NO_PARALLEL` environment variable at the top of the
    Vagrantfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now you can browse to `http://localhost/admin` and start using your Ghost blog
    in a container, behind a NGINX reverse proxy container, with the whole thing managed
    by Vagrant!
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can access the containers logs directly using Vagrant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: A Docker Compose equivalent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Docker Compose is a tool to orchestrate multiple containers and manage Docker
    features from a single YAML file. So if you''re more familiar with Docker Compose,
    or if you''d like to do something similar with this tool, here''s what the code
    would look like in the `docker-compose.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that with Vagrant, you can mix virtual machines and Docker containers,
    while you can't with docker-compose.
  prefs: []
  type: TYPE_NORMAL
- en: Using Vagrant remotely with AWS EC2 and Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another powerful usage of Vagrant can be with remote IaaS resources such as
    Amazon EC2\. Amazon Web Services Elastic Compute Cloud (EC2) and similar Infrastructure-as-a-Service
    providers like Google Cloud, Azure or Digital Ocean, to name a few, are selling
    virtual machines with varying compute power and network bandwidth for a fee. You
    don''t always have all the necessary CPU and memory you need on your laptop, or
    you need to have some specific computing power for a task, or you just want to
    replicate part of an existing production environment: here''s how you can leverage
    the power of Vagrant using Amazon EC2.'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we'll deploy a Ghost blog with an NGINX reverse proxy, all on Docker,
    using an Ubuntu Xenial 16.04 on AWS EC2! This is to simulate a real deployment
    of an application, so you can see if it is working in real conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Vagrant installation (no hypervisor needed)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Amazon EC2 account (or create one for free at [https://aws.amazon.com/](https://aws.amazon.com/)
    if you don't have one already), with valid Access Keys, a keypair named *iac-lab*,
    a security group named *iac-lab* allowing at least HTTP ports, and SSH access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Begin by installing the plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'A requirement of this plugin is the presence of a dummy Vagrant box that does
    nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember how we configured the Docker provider in the previous recipes? This
    is no different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Then, defining an application VM will consist of specifying which provider it's
    using (AWS in our case), the **Amazon Machine Image** (**AMI**) (Ubuntu 16.04
    LTS in our case), and a provisioning script that we creatively named `script.sh`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find other AMI IDs at [http://cloud-images.ubuntu.com/locator/ec2/](http://cloud-images.ubuntu.com/locator/ec2/):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: So what is the AWS-related information we need to fill in so Vagrant can launch
    servers on AWS?
  prefs: []
  type: TYPE_NORMAL
- en: 'We need the AWS Access Keys, preferably from environment variables so you don''t
    hardcode them in your Vagrantfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Indicate the region and availability zone where you want the instance to start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Include the instance type; here, we''ve chosen the one included in the AWS
    free tier plan so it won''t cost you a dime with a new account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Indicate in which security group this instance will live (it''s up to you to
    adapt the requirements to your needs):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Specify the AWS keypair name, and override the default SSH username and keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Under some circumstances, you can experience a bug with NFS while using Vagrant
    and AWS EC2, so I choose to disable this feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it''s a good practice to tag the instances, so you can later find
    out where they come from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a simple shell script that will install Docker and `docker-compose`, then
    execute the docker-compose file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Include both NGINX configuration and `docker-compose.yml` files from the previous
    recipe and you''re good to go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Open your browser at `http://a.b.c.d/` (using the EC2 instance public IP) and
    you'll see your Ghost blog behind an NGINX reverse proxy, using Docker containers,
    using Vagrant on Amazon EC2.
  prefs: []
  type: TYPE_NORMAL
- en: A common usage for such a setup is for the developer to test the application
    in close to real production conditions, maybe to show a new feature to a remote
    product owner, replicate a bug seen only in this setup, or at some point in the
    CI. Once Docker containers have been built, smoke test them on EC2 before going
    any further.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating dynamic multiple host networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vagrant is also very useful when used to simulate multiple hosts in a network.
    This way you can have full systems able to talk to each other in the same private
    network and easily test connectivity between systems.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Vagrant installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working VirtualBox installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s how we would create one CentOS 7.2 machine with 512 MB of RAM and one
    CPU, in a private network with a fixed IP 192.168.50.11, and a simple shell output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'To add a new machine to this network, we could simply duplicate the `srv-1`
    machine definition, as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: That's not very DRY, so let's take advantage of the Ruby nature of the Vagrantfile
    to create a loop that will dynamically and simply create as many virtual machines
    as we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, declare a variable with the amount of virtual machines we want (`2`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Then iterate through that value, so it can generate values for an IP and for
    a hostname:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This will create two virtual machines (`srv-1` at `192.168.50.11` and `srv-2`
    at `192.168.50.12`) on the same internal network, so they can talk to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can simply change the value of `vm_num` and you'll easily spawn new
    virtual machines in seconds.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can optionally go even further, using the following cloning and networking
    features.
  prefs: []
  type: TYPE_NORMAL
- en: Speed up deployments with linked clones
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Linked clones is a feature that enables new VMs to be created based on an initial
    existing disk image, without the need to duplicate everything. Each VM stores
    only its delta state, allowing very fast virtual machines boot times.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we''re launching many machines, you can optionally enable linked clones
    to speed things up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Using named NAT networks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: VirtualBox has the option to let you define your own networks for further reference
    or reuse. Configure them under **Preferences** | **Network** | **NAT Networks**.
    Luckily, Vagrant can work with those named NAT networks too. To test the feature,
    you can create in VirtualBox a network (like iac-lab) and assign it the network
    `192.168.50.0/24`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just change the network configuration from the preceding Vagrantfile to launch
    the VMs in this specific network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Simulating a networked three-tier architecture app with Vagrant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vagrant is a great tool to help simulate systems in isolated networks, allowing
    us to easily mock architectures found in production. The idea behind the multiple
    tiers is to separate the logic and execution of the various elements of the application,
    and not centralize everything in one place. A common pattern is to get a first
    layer that gets the common user requests, a second layer that does the application
    job, and a third layer that stores and retrieves data, usually from a database.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this simulation, we''ll have the traditional three tiers, each running CentOS
    7 virtual machines on their own isolated network:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Front**: NGINX reverse proxy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**App**: a Node.js app running on two nodes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database**: Redis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Virtual Machine Name | front_lan IP | app_lan IP | db_lan IP |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| front-1 | 10.10.0.11/24 | 10.20.0.101/24 | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| app-1 | N/A | 10.20.0.11/24 | 10.30.0.101/24 |'
  prefs: []
  type: TYPE_TB
- en: '| app-2 | N/A | 10.20.0.12/24 | 10/30.0.102/24 |'
  prefs: []
  type: TYPE_TB
- en: '| db-1 | N/A | N/A | 10.30.0.11/24 |'
  prefs: []
  type: TYPE_TB
- en: You will access the reverse proxy (NGINX), which alone can contact the application
    server (Node.js), which is the only one to be able to connect to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Vagrant installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working VirtualBox installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Follow these steps for simulating a networked three-tier architecture app with
    Vagrant.
  prefs: []
  type: TYPE_NORMAL
- en: Tier 3 – the database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The database lives in a db_lan private network with the IP 10.30.0.11/24.
  prefs: []
  type: TYPE_NORMAL
- en: 'This application will use a simple Redis installation. Installing and configuring
    Redis is beyond the scope of this book, so we''ll keep it as simple as possible
    (install it, configure it to listen on the LAN port instead of 127.0.0.1, and
    start it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Tier 2: the application servers'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This tier is where our application lives, backed by an application (web) server.
    The application can connect to the database tier, and will be available to the
    end user through tier 1 proxy servers. This is usually where all the logic is
    done (by the application).
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js application
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This will be simulated with the simplest Node.js code I could produce to demonstrate
    the usage, displaying the server hostname (the filename is `app.js`).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, it creates a connection to the Redis server on the `db_lan` network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Then if it goes well, it creates an HTTP server listening on `:8080`, displaying
    the server''s hostname:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the app, the simplest of the `systemd` service file (`systemd` unit files
    are out of the scope of this book):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s iterate through the deployment of a number of application servers (in
    this case: two) to serve the app. Once again, deploying Node.js applications is
    out of the scope of this book, so I kept it as simple as possible—simple directories
    and permissions creation and systemd unit deployment. In production, this would
    probably be done through a configuration management tool such as Chef or Ansible
    and maybe coupled with a proper deployment tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Tier 1: the NGINX reverse proxy'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Tier 1 is represented here by an NGINX reverse proxy configuration on CentOS
    7, as simple as it could be for this demo. Configuring an NGINX reverse proxy
    with a pool of servers is out of the scope of this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create the reverse proxy VM that will serve `http://localhost:8080`
    through the pool of application servers. This VM listens on 10.10.0.11/24 on its
    own LAN (`front_lan`), and on `10.20.0.101`/`24` on the application servers''
    LAN (`app_lan`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Start this up (`vagrant up`) and navigate to `http://localhost:8080`, where
    the app displays the application server hostname so you can confirm that the load
    balancing across networks is working (while application servers can talk to the
    Redis backend).
  prefs: []
  type: TYPE_NORMAL
- en: Showing your work on the LAN while working with Laravel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You're working on your application using Laravel, the free and open source PHP
    framework (https://laravel.com/), and you'd like to showcase your work to your
    colleagues. Using a Vagrant development environment can help keep your work machine
    clean and allow you to use your usual tools and editors while using an infrastructure
    close to production.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we'll deploy a CentOS 7 server, with NGINX, PHP-FPM, and MariaDB,
    all the PHP dependencies, and install Composer. You can build from this example
    and others in this book to create an environment that mimics production (three-tier,
    multiple machines, and other characteristics).
  prefs: []
  type: TYPE_NORMAL
- en: This environment will be available for access to all your coworkers on your
    network, and the code will be accessible to you locally.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Vagrant installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working VirtualBox or VMware installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with the simplest Vagrant environment we know:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: A sample NGINX configuration for Laravel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Configuring NGINX for Laravel is out of the scope for this book, but for reference,
    here''s a simple NGINX configuration that will work well for us, listening on
    HTTP, serving files located on `/srv/app/public`, and using PHP-FPM (the file
    name is `nginx.conf`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Simple shell provisioning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll create a provisioning script that we''ll name as `provision.sh`, which
    contains all the steps we need to have a fully working Laravel environment. The
    details are out of the scope of this book, but here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We want **Extra Packages for Enterprise Linux** (**EPEL**):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We want PHP-FPM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We want PHP-FPM to run as the Vagrant user so we have the rights:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install a bunch of PHP dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install Composer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install and ship a good enough NGINX configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install MariaDB Server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start all the services:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Enable provisioning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To enable provisioning using our script, add the following code in the VM definition
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Shared folder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To share the `src` folder between your host and the Vagrant VM under `/srv/app`,
    you can add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Public LAN Networking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last thing we need to do now is to add a network interface to our Vagrant
    virtual machine, that will be on the real LAN, so our coworkers will access it
    easily through the network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Adapt the name of your network adapter to use (this was on a Mac, as you can
    guess) to your needs. Another solution is not to specify any adapter name, so
    you will be presented a list of possible adapters to bridge:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the Vagrant environment (`vagrant up`), and when it''s available, you
    can execute commands such as finding out the network information: `vagrant ssh
    -c "ip addr"`. Your mileage will vary, but in this network, the public IP of this
    Vagrant box is `192.168.1.106`, so our work is available.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can start coding in the `./src/` folder. This is not a Laravel book,
    but a way to create a new project in a clean directory is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to remove all files from the folder beforehand. Navigate to `http://local-ip/`
    and you'll see the default Laravel welcome screen.
  prefs: []
  type: TYPE_NORMAL
- en: To verify the file sharing sync is working correctly, edit the `./resources/views/welcome.blade.php`
    file and reload your browser to see the change reflected.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you include the Vagrantfile directly with your project's code, coworkers
    or contributors will only have to run `vagrant up` to see it running.
  prefs: []
  type: TYPE_NORMAL
- en: Other Vagrantfile sharing options include Windows Sharing (smb), rsync (useful
    with remote virtual machines such as on AWS EC2), and even NFS.
  prefs: []
  type: TYPE_NORMAL
- en: 'A noticeable bug in the sharing feature using VirtualBox leads to corrupted
    or non-updating files. The workaround is to deactivate in the web server configuration
    `sendfile`, using NGINX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Using Apache, it is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Sharing access to your Vagrant environment with the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You're working on your project with your local Vagrant environment, and you'd
    like to show the status of the job to your customer who's located in another city.
    Maybe you have an issue configuring something and you'd like some remote help
    from your coworker on the other side of the planet. Alternatively, maybe you'd
    like to access your work Vagrant box from home, hotel, or coworking space? There's
    a neat Vagrant sharing feature we'll use here, working with a Ghost blog on CentOS
    7.2.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Vagrant installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working VirtualBox installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A free HashiCorp Atlas account ([https://atlas.hashicorp.com/account/new](https://atlas.hashicorp.com/account/new))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with this simple Vagrantfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'We know we''ll have to install some packages, so let''s add a provisioning
    script to be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll want to hack locally on our Ghost blog, such as adding themes and more,
    so let''s sync our `src/` folder to the remote `/srv/blog` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'We want a local private network so we can access the virtual machine, with
    the `2368` TCP port (Ghost default) redirected to our host `8080` HTTP port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Provisioning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To configure our new box, we''ll first need to enable EPEL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then install the requirements, `node`, `npm`, and `unzip`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Download the latest Ghost version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Uncompress it in the `/srv/blog` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install the Ghost dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Put all those commands in the `provisioning.sh` script and we''re good to go:
    `vagrant up`.'
  prefs: []
  type: TYPE_NORMAL
- en: Starting Ghost engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you would do normally, log in to your Vagrant box to launch the node server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the host IP from `127.0.0.1` to `0.0.0.0` in the generated `config.js`
    file so the server listens on all interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the node server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'You now have a direct access to the blog through your box LAN IP (adapt the
    IP to your case): `http://172.28.128.3:2368/`.'
  prefs: []
  type: TYPE_NORMAL
- en: Sharing access
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now you can access your application locally through your Vagrant box, let''s
    give access to it to others through the Internet using `vagrant share`:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The default is to share through HTTP, so your work is available through a web
    browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'This URL is the one you can give to anyone to access publicly your work: Vagrant
    servers being used as proxy.'
  prefs: []
  type: TYPE_NORMAL
- en: SSH
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another possible sharing option is by SSH (deactivated by default). The program
    will ask you for a password you''ll need to connect to the box remotely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, at home or at the coworking space, you can simply connect to your work
    Vagrant box (if needed, the default Vagrant password is vagrant):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: You or your coworker are now remotely logged into your own Vagrant box over
    the Internet!
  prefs: []
  type: TYPE_NORMAL
- en: Simulating Chef upgrades using Vagrant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wouldn't it be awesome to simulate production changes quickly? Chances are you're
    using Chef in production. We'll see how to use both Chef cookbooks with Vagrant,
    as well as how to simulate Chef version upgrades between environments. This kind
    of setup is the beginning of a good combination of infrastructure as code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Vagrant installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working VirtualBox installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with a minimal virtual machine named `prod` that simply boots
    a CentOS 7.2, like we have in our production environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Vagrant Omnibus Chef plugin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, if we want to use Chef code, if we want to use Chef code (Ruby files organized
    in directories that form a unit called a ''cookbook'' that configure and maintain
    a specific area of a system), we first need to install Chef on the Vagrant box.
    There''re many ways to do this, from provisioning shell scripts to using boxes
    with Chef already installed. A clean, reliable, and repeatable way is to use a
    Vagrant plugin to do just that—vagrant-omnibus. Omnibus is a packaged Chef. Install
    it like any other Vagrant plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, just add the following configuration in your VM definition of the Vagrantfile
    and you''ll always have the latest Chef version installed on this box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'However, our goal is to mimic production, maybe we''re still using the latest
    in v11.x series of Chef instead of the latest 12.x, so instead let''s specify
    exactly which version we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''re using a new plugin, our Vagrantfile won''t work out of the
    box for everybody. Users will have to install this vagrant-omnibus plugin. If
    you care about consistency and repeatability, an option is to add the following
    Ruby check at the beginning of your Vagrantfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet will simply iterate over each plugin name to verify that Vagrant
    returns them as *installed*. If not, stop there and return a helpful exit message
    on how to install the required plugins.
  prefs: []
  type: TYPE_NORMAL
- en: A sample Chef recipe
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This part of the book isn''t about writing Chef recipes (read more about it
    later in the book!), so we''ll keep that part simple. Our objective is to install
    the Apache 2 web server on CentOS 7 (`httpd` package), and start it. Here''s what
    our sample recipe looks like (`cookbooks/apache2/recipes/default.rb`); it does
    exactly what it says in plain English:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Vagrant and Chef integration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s how, in our VM definition block, we''ll tell Vagrant to work with Chef
    Solo (a way of running Chef in standalone mode, without the need of a Chef server)
    to provision our box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: As simple as that. Vagrant this up (`vagrant up`), and you'll end up with a
    fully provisioned VM, using the old 11.18.12 version, and a running Apache 2 web
    server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our manual tests can include checking that the chef-solo version is the one
    we requested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'They can also check if we have `httpd` installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we can check if `httpd` is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Various other options than chef-solo exist, such as chef-client and chef-zero.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Chef version update
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So we simulated our production environment locally, with the same CentOS version,
    the apache2 cookbook used in production, and the old Chef version 11\. Our next
    task is to test if everything is still running smoothly after an upgrade to the
    new version 12\. Let''s create a second "staging" VM, very similar to our production
    setup, except we want to install the current latest Chef version (12.13.37 at
    the time of writing, feel free to use `:latest` instead):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Launch this new machine (`vagrant up staging`) and we''ll see if our setup
    still works with the new major Chef version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: So we can safely assume, as far as our testing goes, that the newest Chef version
    still works correctly with our production Chef code.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are more ways of controlling a Vagrant environment, and use even better
    Chef tooling inside it.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling default Vagrant VMs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You may not always want to boot both production and staging vagrant virtual
    machines, especially when you just want to work on the default production setup.
    To specify a default VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'To not start automatically a VM when issuing the `vagrant up` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Berkshelf and Vagrant
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Chances are, if your production environment is using Chef, you're also using
    Berkshelf for dependency management and not 100% local cookbooks (if you aren't,
    you should!).
  prefs: []
  type: TYPE_NORMAL
- en: Vagrant work pretty well with a Berkshelf enabled Chef environment, using the
    `vagrant-berkshelf` plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Your workstation will need the Chef Development Kit (Chef DK: [https://downloads.chef.io/chef-dk/](https://downloads.chef.io/chef-dk/))
    for this to work correctly.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing with Test Kitchen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This setup is in fact so close to what's used to make infrastructure code testing
    that you'll see a lot of similarities in the dedicated section of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Using Ansible with Vagrant to create a Docker host
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible ([https://www.ansible.com/](https://www.ansible.com/)) is a very simple
    and powerful open source automation tool. While using and creating Ansible *playbooks*
    is off-topic for this book, we'll use a very simple *playbook* to install and
    configure Docker on a CentOS 7 box. Starting from here, you'll be able to iterate
    through more complex Ansible playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Vagrant installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working hypervisor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working Ansible installation on your machine (an easy way is to `$ pip install
    ansible` or to pick your usual package manager like APT or YUM/DNF)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because writing complex Ansible playbooks is out of the scope of this book,
    we'll use a very simple one, so you can learn more about Ansible later and still
    reuse this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: A simple Ansible Docker playbook for Vagrant
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our playbook file (`playbook.yml`) is a plain YAML file, and we''ll do the
    following in this order:'
  prefs: []
  type: TYPE_NORMAL
- en: Install EPEL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Docker Unix group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the default Vagrant user to the new Docker group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Docker from CentOS repositories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable and start Docker Engine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s how the `playbook.yml` file looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Apply Ansible from Vagrant
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To use our Ansible playbook, let''s start with a simple Vagrantfile starting
    a CentOS 7 box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Simply add Ansible provisioning like this to the VM definition so it will load
    and apply your `playbook.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now run `vagrant up` and use CentOS 7 Docker Engine version right away:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What if for some reason you don''t or can''t have Ansible installed on your
    host machine? Alternatively, maybe you need a specific Ansible version on your
    Vagrant box to mimic production and you don''t want to mess with your local Ansible
    installation. There''s an interesting variant Ansible provider you can use: it
    will either use Ansible directly from the guest VM, and if it''s not installed,
    it will install it from official repositories or PIP. You can use this very simple
    default configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Log in to the box via SSH and check that Ansible is locally installed with
    the latest version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'If your use case is different, you can use more precise deployment options,
    to be able to fix an Ansible version number using PIP (here, version 1.9.6 instead
    of the latest 2.x series):'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It will take noticeably longer to start, as it needs to install many packages
    on the guest system.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the Vagrant guest, you can now check for the PIP and Ansible versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also check if our playbook has been installed correctly with the old
    1.x Ansible version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Also check if Docker is installed, and verify now it''s working as the Vagrant
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Using Docker containers on CoreOS with Vagrant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vagrant can help in simulating environments, and Docker containers are not forgotten
    with Vagrant. We'll use one of the best platforms to run containers, the free
    and open source lightweight operating system CoreOS. Based on Linux, targeting
    easy container and clustered deployments, it also provides official Vagrant boxes.
    We'll deploy the official WordPress container with MariaDB on another container
    using the Vagrant Docker provisioner (and not the Vagrant Docker provider).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Vagrant installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working hypervisor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CoreOS doesn''t host its official images at the default location on Atlas,
    it hosts it itself. So, we have to specify the full URL to the Vagrant box in
    our Vagrantfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'As CoreOS is a minimal OS, it doesn''t support any of the VirtualBox guest
    addition tools, so we''ll disable them, and don''t try anything if we (most likely)
    have the `vagrant-vbguest` plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a new VM definition, using the CoreOS Vagrant box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to run the `mariadb` and `wordpress` official containers from the
    Docker Hub. Using Docker directly, we would have run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s translate this into our Vagrantfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Vagrant this up (`$ vagrant up`), and you''ll access a ready-to-use WordPress
    installation running on CoreOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The CoreOS team proposes a full Vagrant environment to try and manipulate a
    CoreOS cluster [https://github.com/coreos/coreos-vagrant](https://github.com/coreos/coreos-vagrant).
    You'll then be able to try all CoreOS features and configuration options for all
    release channels (alpha, beta, or stable).
  prefs: []
  type: TYPE_NORMAL
- en: Other operating systems such as Ubuntu or CentOS are fully supported to provision
    Docker containers, even if Docker isn't installed at first on the base image.
    Vagrant will install Docker for you, so it will work transparently and run the
    containers as soon as it's installed.
  prefs: []
  type: TYPE_NORMAL
