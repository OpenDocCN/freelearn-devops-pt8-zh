- en: Chapter 2. Puppet Infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"Computers in the future may have as few as 1,000 vacuum tubes and weigh
    only 1.5 tons."* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Popular Mechanics, 1949* |'
  prefs: []
  type: TYPE_TB
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Puppet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing your manifests with Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a decentralized Puppet architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a papply script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running Puppet from cron
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bootstrapping Puppet with bash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a centralized Puppet infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating certificates with multiple DNS names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running Puppet from passenger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring PuppetDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Hiera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting-node specific data with Hiera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing secret data with hiera-gpg
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using MessagePack serialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic syntax checking with Git hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pushing code around with Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing environments with Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover how to deploy Puppet in a centralized and decentralized
    manner. With each approach, we'll see a combination of best practices, my personal
    experience, and community solutions.
  prefs: []
  type: TYPE_NORMAL
- en: We'll configure and use both PuppetDB and Hiera. PuppetDB is used with exported
    resources, which we will cover in [Chapter 5](ch05.html "Chapter 5. Users and
    Virtual Resources"), *Users and Virtual Resources*. Hiera is used to separate
    variable data from Puppet code.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I'll introduce Git and see how to use Git to organize our code and
    our infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Because Linux distributions, such as Ubuntu, Red Hat, and CentOS, differ in
    the specific details of package names, configuration file paths, and many other
    things, I have decided that for reasons of space and clarity the best approach
    for this book is to pick one distribution (*Debian 7* named as *Wheezy*) and stick
    to that. However, Puppet runs on most popular operating systems, so you should
    have very little trouble adapting the recipes to your own favorite OS and distribution.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, Puppet 3.7.2 is the latest stable version available,
    this is the version of Puppet used in the book. The syntax of Puppet commands
    changes often, so be aware that while older versions of Puppet are still perfectly
    usable, they may not support all of the features and syntax described in this
    book. As we saw in [Chapter 1](ch01.html "Chapter 1. Puppet Language and Style"),
    *Puppet Language and Style*, the future parser showcases features of the language
    scheduled to become default in Version 4 of Puppet.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Puppet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Puppet Language and Style"), *Puppet Language
    and Style*, we installed Puppet as a rubygem using the gem install. When deploying
    to several nodes, this may not be the best approach. Using the package manager
    of your chosen distribution is the best way to keep your Puppet versions similar
    on all of the nodes in your deployment. Puppet labs maintain repositories for
    APT-based and YUM-based distributions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your Linux distribution uses APT for package management, go to [http://apt.puppetlabs.com/](http://apt.puppetlabs.com/)
    and download the appropriate Puppet labs release package for your distribution.
    For our wheezy cookbook node, we will use [http://apt.puppetlabs.com/puppetlabs-release-wheezy.deb](http://apt.puppetlabs.com/puppetlabs-release-wheezy.deb).
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a Linux distribution that uses YUM for package management,
    go to [http://yum.puppetlabs.com/](http://yum.puppetlabs.com/) and download the
    appropriate Puppet labs release package for your distribution.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have found the appropriate Puppet labs release package for your distribution,
    the steps to install Puppet are the same for either APT or YUM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Puppet labs release package
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Install Puppet package
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you have installed Puppet, verify the version of Puppet as shown in the
    following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have a method to install Puppet on our nodes, we need to turn our
    attention to keeping our Puppet manifests organized. In the next section, we will
    see how to use Git to keep our code organized and consistent.
  prefs: []
  type: TYPE_NORMAL
- en: Managing your manifests with Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s a great idea to put your Puppet manifests in a version control system
    such as Git or Subversion (Git is the de facto standard for Puppet). This gives
    you several advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: You can undo changes and revert to any previous version of your manifest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can experiment with new features using a branch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If several people need to make changes to the manifests, they can make them
    independently, in their own working copies, and then merge their changes later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the `git log` feature to see what was changed, and when (and by
    whom)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we'll import your existing manifest files into Git. If you
    have created a Puppet directory in a previous section use that, otherwise, use
    your existing manifest directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we''ll create a new Git repository on a server accessible
    from all our nodes. There are several steps we need to take to have our code held
    in a Git repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Install Git on a central server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a user to run Git and own the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a repository to hold the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create **SSH** keys to allow key-based access to the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Git on a node and download the latest version from our Git repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install Git on your Git server (`git.example.com` in our example). The
    easiest way to do this is using Puppet. Create the following manifest, call it
    `git.pp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Apply this manifest using `puppet apply git.pp`, this will install Git.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, create a Git user that the nodes will use to log in and retrieve the
    latest code. Again, we''ll do this with puppet. We''ll also create a directory
    to hold our repository (`/home/git/repos`) as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After applying that manifest, log in as the Git user and create an empty Git
    repository using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set a password for the Git user, we''ll need to log in remotely after the next
    step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now back on your local machine, create an `ssh` key for our nodes to use to
    update the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now copy the newly created public key to the `authorized_keys` file. This will
    allow us to connect to the Git server using this new key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now try logging into the machine, with: "ssh ''git@git.example.com''" and check
    to make sure that only the key(s) you wanted were added.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, configure `ssh` to use your key when accessing the Git server and add
    the following to your `~/.ssh/config` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Clone the repo onto your machine into a directory named Puppet (substitute
    your server name if you didn''t use `git.example.com`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We've created a Git repository; before we commit any changes to the repository,
    it's a good idea to set your name and e-mail in Git. Your name and e-mail will
    be appended to each commit you make.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When you are working in a large team, knowing who made a change is very important;
    for this, use the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can verify your Git settings using the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have Git configured properly, change directory to your repository
    directory and create a new site manifest as shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This site manifest will install our base class on every node; we will create
    the base class using the Puppet module as we did in [Chapter 1](ch01.html "Chapter 1. Puppet
    Language and Style"), *Puppet Language and Style*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As a last step, we create a symbolic link between the `thomas-base` directory
    and `base`. Now to make sure our module does something useful, add the following
    to the body of the `base` class defined in `thomas-base/manifests/init.pp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add the new base module and site manifest to Git using `git add` and `git
    commit` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point your changes to the Git repository have been committed locally;
    you now need to push those changes back to `git.example.com` so that other nodes
    can retrieve the updated files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Git tracks changes to files, and stores a complete history of all changes. The
    history of the repo is made up of commits. A commit represents the state of the
    repo at a particular point in time, which you create with the `git commit` command
    and annotate with a message.
  prefs: []
  type: TYPE_NORMAL
- en: You've now added your Puppet manifest files to the repo and created your first
    commit. This updates the history of the repo, but only in your local working copy.
    To synchronize the changes with the `git.example.com` copy, the `git push` command
    pushes all changes made since the last sync.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have a central Git repository for your Puppet manifests, you can
    check out multiple copies of it in different places and work on them before committing
    your changes. For example, if you're working in a team, each member can have their
    own local copy of the repo and synchronize changes with the others via the central
    server. You may also choose to use GitHub as your central Git repository server.
    GitHub offers free Git repository hosting for public repositories, and you can
    pay for GitHub's premium service if you don't want your Puppet code to be publicly
    available.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will use our Git repository for both centralized and
    decentralized Puppet configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a decentralized Puppet architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Puppet is a configuration management tool. You can use Puppet to configure and
    prevent configuration drift in a large number of client computers. If all your
    client computers are easily reached via a central location, you may choose to
    have a central Puppet server control all the client computers. In the centralized
    model, the Puppet server is known as the Puppet master. We will cover how to configure
    a central Puppet master in a few sections.
  prefs: []
  type: TYPE_NORMAL
- en: If your client computers are widely distributed or you cannot guarantee communication
    between the client computers and a central location, then a decentralized architecture
    may be a good fit for your deployment. In the next few sections, we will see how
    to configure a decentralized Puppet architecture.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, we can run the `puppet apply` command directly on a manifest
    file to have Puppet apply it. The problem with this arrangement is that we need
    to have the manifests transferred to the client computers.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the Git repository we created in the previous section to transfer
    our manifests to each new node we create.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new test node, call this new node whatever you wish, I'll use `testnode`
    for mine. Install Puppet on the machine as we have previously done.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a `bootstrap.pp` manifest that will perform the following configuration
    steps on our new node:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Git:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install the `ssh` key to access `git.example.com` in the Puppet user''s home
    directory (`/var/lib/puppet/.ssh/id_rsa`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Download the `ssh` host key from `git.example.com` (`/var/lib/puppet/.ssh/known_hosts`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a directory to contain the Git repository (`/etc/puppet/cookbook`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Clone the Puppet repository onto the new machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now when we run Puppet apply on the new machine, the `ssh` key will be installed
    for the Puppet user. The Puppet user will then clone the Git repository into `/etc/puppet/cookbook`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have to disable the `tty` requirement of `sudo`. Comment out the line
    `Defaults requiretty` at `/etc/sudoers` if you have this line.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Alternatively, you can set `user => Puppet` within the `'create cookbook' exec`
    type. Beware that using the user attribute will cause any error messages from
    the command to be lost.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that your Puppet code is available on the new node, you can apply it using
    `puppet apply`, specifying that `/etc/puppet/cookbook/modules` will contain the
    modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, our `bootstrap.pp` manifest ensures that Git is installed. The manifest
    then goes on to ensure that the `ssh` key for the Git user on `git.example.com`
    is installed into the Puppet user's home directory (`/var/lib/puppet` by default).
    The manifest then ensures that the host key for `git.example.com` is trusted by
    the Puppet user. With `ssh` configured, the bootstrap ensures that `/etc/puppet/cookbook`
    exists and is a directory.
  prefs: []
  type: TYPE_NORMAL
- en: We then use an `exec` to have Git clone the repository into `/etc/puppet/cookbook`.
    With all the code in place, we then call `puppet apply` a final time to deploy
    the code from the repository. In a production setting, you would distribute the
    `bootstrap.pp` manifest to all your nodes, possibly via an internal web server,
    using a method similar to curl [http://puppet/bootstrap.pp >bootstrap.pp && puppet
    apply bootstrap.pp](http://puppet/bootstrap.pp >bootstrap.pp && puppet apply bootstrap.pp)
  prefs: []
  type: TYPE_NORMAL
- en: Writing a papply script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'd like to make it as quick and easy as possible to apply Puppet on a machine;
    for this we'll write a little script that wraps the `puppet apply` command with
    the parameters it needs. We'll deploy the script where it's needed with Puppet
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your Puppet repo, create the directories needed for a Puppet module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `modules/puppet/files/papply.sh` file with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `modules/puppet/manifests/init.pp` file with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify your `manifests/site.pp` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the Puppet module to the Git repository and commit the change as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now remember to push the changes to the Git repository on `git.example.com`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Pull the latest version of the Git repository to your new node (`testnode`
    for me) as shown in the following command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Apply the manifest manually once to install the `papply` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, test the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, whenever you need to run Puppet, you can simply run `papply`. In future,
    when we apply Puppet changes, I'll ask you to run `papply` instead of the full
    `puppet apply` command.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you''ve seen, to run Puppet on a machine and apply a specified manifest
    file, we use the `puppet apply` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'When you''re using modules (such as the Puppet module we just created), you
    also need to tell Puppet where to search for modules, using the `modulepath` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to run Puppet with the root privileges it needs, we have to put `sudo`
    before everything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, any additional arguments passed to `papply` will be passed through
    to Puppet itself, by adding the `$*` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s a lot of typing, so putting this in a script makes sense. We''ve added
    a Puppet file resource that will deploy the script to `/usr/local/bin` and make
    it executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we include the Puppet module in our default node declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You can do the same for any other nodes managed by Puppet.
  prefs: []
  type: TYPE_NORMAL
- en: Running Puppet from cron
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can do a lot with the setup you already have: work on your Puppet manifests
    as a team, communicate changes via a central Git repository, and manually apply
    them on a machine using the `papply` script.'
  prefs: []
  type: TYPE_NORMAL
- en: However, you still have to log into each machine to update the Git repo and
    rerun Puppet. It would be helpful to have each machine update itself and apply
    any changes automatically. Then all you need to do is to push a change to the
    repo, and it will go out to all your machines within a certain time.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to do this is with a **cron** job that pulls updates from the
    repo at regular intervals and then runs Puppet if anything has changed.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You'll need the Git repo we set up in the *Managing your manifests with Git*
    and *Creating a decentralized Puppet architecture* recipes, and the `papply` script
    from the *Writing a papply script* recipe. You'll need to apply the `bootstrap.pp`
    manifest we created to install `ssh` keys to download the latest repository.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the `bootstrap.pp` script to any node you wish to enroll. The `bootstrap.pp`
    manifest includes the private key used to access the Git repository, it should
    be protected in a production environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `modules/puppet/files/pull-updates.sh` file with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `modules/puppet/manifests/init.pp` file and add the following snippet
    after the `papply` file definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Commit the changes as before and push to the Git server as shown in the following
    command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Issue a Git pull on the test node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run Puppet on the test node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check that the `pull-updates` script works properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify the `cron` job was created successfully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we created the `bootstrap.pp` manifest, we made sure that the Puppet user
    can checkout the Git repository using an `ssh` key. This enables the Puppet user
    to run the Git pull in the cookbook directory unattended. We''ve also added the
    `pull-updates` script, which does this and runs Puppet if any changes are pulled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We deploy this script to the node with Puppet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ve created a `cron` job that runs `pull-updates` at regular intervals
    (every 10 minutes, but feel free to change this if you need to):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Congratulations, you now have a fully-automated Puppet infrastructure! Once
    you have applied the `bootstrap.pp` manifest, run Puppet on the repository; the
    machine will be set up to pull any new changes and apply them automatically.
  prefs: []
  type: TYPE_NORMAL
- en: So, for example, if you wanted to add a new user account to all your machines,
    all you have to do is add the account in your working copy of the manifest, and
    commit and push the changes to the central Git repository. Within 10 minutes,
    it will automatically be applied to every machine that's running Puppet.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping Puppet with bash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previous versions of this book used Rakefiles to bootstrap Puppet. The problem
    with using Rake to configure a node is that you are running the commands from
    your laptop; you assume you already have `ssh` access to the machine. Most bootstrap
    processes work by issuing an easy to remember command from a node once it has
    been provisioned. In this section, we'll show how to use bash to bootstrap Puppet
    with a web server and a bootstrap script.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install httpd on a centrally accessible server and create a password protected
    area to store the bootstrap script. In my example, I''ll use the Git server I
    set up previously, `git.example.com`. Start by creating a directory in the root
    of your web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following location definition to your apache configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Reload your web server to ensure the location configuration is operating. Verify
    with curl that you cannot download from the bootstrap directory without authentication:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the password file you referenced in the apache configuration (`/var/www/puppet.passwd`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify that the username and password permit access to the bootstrap directory
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have a safe location to store the bootstrap script, create a bootstrap
    script for each OS you support in the bootstrap directory. In this example, I'll
    show you how to do this for a Red Hat Enterprise Linux 6-based distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although the bootstrap location requires a password, there is no encryption
    since we haven't configured SSL on our server. Without encryption, the location
    is not very safe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a script named `el6.sh` in the bootstrap directory with the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The apache configuration only permits access to the bootstrap directory with
    a username and password combination. We supply these with the `--user` argument
    to curl, thereby getting access to the file. We use a pipe (`|`) to redirect the
    output of curl into bash. This causes bash to execute the script. We write our
    bash script like we would any other bash script. The bash script downloads our
    `bootstrap.pp` manifest and applies it. Finally, we apply the Puppet manifest
    from the Git repository and the machine is configured as a member of our decentralized
    infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To support another operating system, we only need to create a new bash script.
    All Linux distributions will support bash scripting, Mac OS X does as well. Since
    we placed much of our logic into the `bootstrap.pp` manifest, the bootstrap script
    is quite minimal and easy to port to new operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a centralized Puppet infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A configuration management tool such as Puppet is best used when you have many
    machines to manage. If all the machines can reach a central location, using a
    centralized Puppet infrastructure might be a good solution. Unfortunately, Puppet
    doesn't scale well with a large number of nodes. If your deployment has less than
    800 servers, a single Puppet master should be able to handle the load, assuming
    your catalogs are not complex (take less than 10 seconds to compile each catalog).
    If you have a larger number of nodes, I suggest a load balancing configuration
    described in *Mastering Puppet*, *Thomas Uphill*, *Packt Publishing*.
  prefs: []
  type: TYPE_NORMAL
- en: A Puppet master is a Puppet server that acts as an X509 certificate authority
    for Puppet and distributes catalogs (compiled manifests) to client nodes. Puppet
    ships with a built-in web server called **WEBrick,** which can handle a very small
    number of nodes. In this section, we will see how to use that built-in server
    to control a very small (less than 10) number of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Puppet master process is started by running `puppet master`; most Linux
    distributions have start and stop scripts for the Puppet master in a separate
    package. To get started, we'll create a new debian server named `puppet.example.com`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install Puppet on the new server and then use Puppet to install the Puppet
    master package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now start the Puppet master service and ensure it will start at boot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Puppet master package includes the start and stop scripts for the Puppet
    master service. We use Puppet to install the package and start the service. Once
    the service is started, we can point another node at the Puppet master (you might
    need to disable the host-based firewall on your machine).
  prefs: []
  type: TYPE_NORMAL
- en: 'From another node, run `puppet agent` to start a `puppet agent`, which will
    contact the server and request a new certificate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now on the Puppet server, sign the new key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Return to the cookbook node and run Puppet again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we ran `puppet agent`, Puppet looked for a host named `puppet.example.com`
    (since our test node is in the `example.com` domain); if it couldn't find that
    host, it would then look for a host named Puppet. We can specify the server to
    contact with the `--server` option to `puppet agent`. When we installed the Puppet
    master package and started the Puppet master service, Puppet created default SSL
    certificates based on our hostname. In the next section, we'll see how to create
    an SSL certificate that has multiple DNS names for our Puppet server.
  prefs: []
  type: TYPE_NORMAL
- en: Creating certificates with multiple DNS names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Puppet will create an SSL certificate for your Puppet master that
    contains the fully qualified domain name of the server only. Depending on how
    your network is configured, it can be useful for the server to be known by other
    names. In this recipe, we'll make a new certificate for our Puppet master that
    has multiple DNS names.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Install the Puppet master package if you haven't already done so. You will then
    need to start the Puppet master service at least once to create a **certificate
    authority** (**CA**).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Stop the running Puppet master process with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Delete (`clean`) the current server certificate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new Puppet certificate using Puppet certificate generate with the
    `--dns-alt-names` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Sign the new certificate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Restart the Puppet master process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When your puppet agents connect to the Puppet server, they look for a host called
    `Puppet`, they then look for a host called `Puppet.[your domain]`. If your clients
    are in different domains, then you need your Puppet master to reply to all the
    names correctly. By removing the existing certificate and generating a new one,
    you can have your Puppet master reply to multiple DNS names.
  prefs: []
  type: TYPE_NORMAL
- en: Running Puppet from passenger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The WEBrick server we configured in the previous section is not capable of handling
    a large number of nodes. To deal with a large number of nodes, a scalable web
    server is required. Puppet is a ruby process, so we need a way to run a ruby process
    within a web server. **Passenger** is the solution to this problem. It allows
    us to run the Puppet master process within a web server (apache by default). Many
    distributions ship with a puppetmaster-passenger package that configures this
    for you. In this section, we'll use the package to configure Puppet to run within
    passenger.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install the puppetmaster-passenger package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using `puppet resource` to install packages ensures the same command will work
    on multiple distributions (provided the package names are the same).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure the Puppet master site is enabled in your apache configuration. Depending
    on your distribution this may be at `/etc/httpd/conf.d` or `/etc/apache2/sites-enabled`.
    The configuration file should be created for you and contain the following information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These lines are tuning settings for passenger. The file then instructs apache
    to listen on port 8140, the Puppet master port. Next a `VirtualHost` definition
    is created that loads the Puppet CA certificates and the Puppet master''s certificate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have more or less lines of SSL configuration here depending on your
    version of the puppetmaster-passenger package.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, a few important headers are set so that the passenger process has access
    to the SSL information sent by the client node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, the location of the passenger configuration file `config.ru` is given
    with the `DocumentRoot` location as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `config.ru` file should exist at `/usr/share/puppet/rack/puppetmasterd/`
    and should have the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the passenger apache configuration file in place and the `config.ru` file
    correctly configured, start the apache server and verify that apache is listening
    on the Puppet master port (if you configured the standalone Puppet master previously,
    you must stop that process now using `service puppetmaster stop`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The passenger configuration file uses the existing Puppet master certificates
    to listen on port 8140 and handles all the SSL communication between the server
    and the client. Once the certificate information has been dealt with, the connection
    is handed off to a ruby process started from passenger using the command line
    arguments from the `config.ru` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the `$0` variable is set to `master` and the arguments variable
    is set to `--rack --confdir /etc/puppet --vardir /var/lib/puppet`; this is equivalent
    to running the following from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can add additional configuration parameters to the `config.ru` file to
    further alter how Puppet runs when it''s running through passenger. For instance,
    to enable debugging on the passenger Puppet master, add the following line to
    `config.ru` before the run `Puppet::Util::CommandLine.new.execute` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Setting up the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Environments in Puppet are directories holding different versions of your Puppet
    manifests. Environments prior to Version 3.6 of Puppet were not a default configuration
    for Puppet. In newer versions of Puppet, environments are configured by default.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a node connects to a Puppet master, it informs the Puppet master of
    its environment. By default, all nodes report to the `production` environment.
    This causes the Puppet master to look in the production environment for manifests.
    You may specify an alternate environment with the `--environment` setting when
    running puppet agent or by setting environment `= newenvironment` in `/etc/puppet/puppet.conf`
    in the [agent] section.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Set the `environmentpath` function of your installation by adding a line to
    the `[main]` section of `/etc/puppet/puppet.conf` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `production` directory at `/etc/puppet/environments` that contains
    both a `modules` and `manifests` directory. Then create a `site.pp` which creates
    a file in `/tmp` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run puppet agent on the master to connect to it and verify that the production
    code was delivered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure another environment `devel`. Create a new manifest in the `devel`
    environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Apply the new environment by running the `--environment devel` puppet agent
    using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may need to restart apache2 to enable your new environment, this depends
    on your version of Puppet and the `environment_timeout` parameter of `puppet.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each environment can have its own `modulepath` if you create an `environment.conf`
    file within the environment directory. More information on environments can be
    found on the Puppet labs website at [https://docs.puppetlabs.com/puppet/latest/reference/environments.html](https://docs.puppetlabs.com/puppet/latest/reference/environments.html).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring PuppetDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PuppetDB is a database for Puppet that is used to store information about nodes
    connected to a Puppet master. PuppetDB is also a storage area for exported resources.
    Exported resources are resources that are defined on nodes but applied to other
    nodes. The simplest way to install PuppetDB is to use the PuppetDB module from
    Puppet labs. From this point on, we'll assume you are using the `puppet.example.com`
    machine and have a passenger-based configuration of Puppet.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install the PuppetDB module in the production environment you created in the
    previous recipe. If you didn''t create directory environments, don''t worry, using
    `puppet module install` will install the module to the correct location for your
    installation with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that our Puppet master has the PuppetDB module installed, we need to apply
    the PuppetDB module to our Puppet master, we can do this in the site manifest.
    Add the following to your (production) `site.pp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `puppet agent` to apply the `puppetdb` class and the `puppetdb::master::config`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The PuppetDB module is a great example of how a complex configuration task can
    be puppetized. Simply by adding the `puppetdb` class to our Puppet master node,
    Puppet installed and configured `postgresql` and `puppetdb`.
  prefs: []
  type: TYPE_NORMAL
- en: When we called the `puppetdb::master::config` class, we set the `puppet_service_name`
    variable to `apache2`, this is because we are running Puppet through passenger.
    Without this line our agent would try to start the puppetmaster process instead
    of `apache2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The agent then set up the configuration files for PuppetDB and configured Puppet
    to use PuppetDB. If you look at `/etc/puppet/puppet.conf`, you''ll see the following
    two new lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that PuppetDB is configured and we''ve had a successful agent run, PuppetDB
    will have data we can query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Configuring Hiera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Hiera** is an information repository for Puppet. Using Hiera you can have
    a hierarchical categorization of data about your nodes that is maintained outside
    of your manifests. This is very useful for sharing code and dealing with exceptions
    that will creep into any Puppet deployment.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Hiera should have already been installed as a dependency on your Puppet master.
    If it has not already, install it using Puppet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Hiera is configured from a yaml file, `/etc/puppet/hiera.yaml`. Create the
    file and add the following as a minimal configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `common.yaml` file referenced in the hierarchy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit the `site.pp` file and add a notify resource based on the Hiera value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Apply the manifest to a test node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Hiera uses a hierarchy to search through a set of yaml files to find the appropriate
    values. We defined this hierarchy in `hiera.yaml` with the single entry for `common.yaml`.
    We used the `hiera` function in `site.pp` to lookup the value for message and
    store that value in the variable `$message`. The values used for the definition
    of the hierarchy can be any facter facts defined about the system. A common hierarchy
    is shown as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Hiera can be used for automatic parameter lookup with parameterized classes.
    For example, if you have a class named `cookbook::example` with a parameter named
    `publisher`, you can include the following in a Hiera yaml file to automatically
    set this parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Another often used fact is `environment` you may reference the `environment`
    of the client node using `%{environment}` as shown in the following hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A good rule of thumb is to limit the hierarchy to 8 levels or less. Keep in
    mind that each time a parameter is searched with Hiera, all the levels are searched
    until a match is found.
  prefs: []
  type: TYPE_NORMAL
- en: The default Hiera function returns the first match to the search key, you can
    also use `hiera_array` and `hiera_hash` to search and return all values stored
    in Hiera.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hiera can also be searched from the command line as shown in the following
    command line (note that currently the command line Hiera utility uses `/etc/hiera.yaml`
    as its configuration file whereas the Puppet master uses `/etc/puppet/hiera.yaml`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information, consult the Puppet labs website at [https://docs.puppetlabs.com/hiera/1/](https://docs.puppetlabs.com/hiera/1/).
  prefs: []
  type: TYPE_NORMAL
- en: Setting node-specific data with Hiera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our hierarchy defined in `hiera.yaml`, we created an entry based on the hostname
    fact; in this section, we'll create yaml files in the `hosts` subdirectory of
    Hiera data with information specific to a particular host.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Install and configure Hiera as in the last section and use the hierarchy defined
    in the previous recipe that includes a `hosts/%{hostname}` entry.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file at `/etc/puppet/hieradata/hosts` that is the hostname of your
    test node. For example if your host is named `cookbook-test`, then the file would
    be named `cookbook-test.yaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Insert a specific message in this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run Puppet on two different test nodes to note the difference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hiera searches the hierarchy for files that match the values returned by facter.
    In this case, the `cookbook-test.yaml` file is found by substituting the hostname
    of the node into the search path `/etc/puppet/hieradata/hosts/%{hostname}.yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Hiera, it is possible to greatly reduce the complexity of your Puppet
    code. We will use `yaml` files for separate values, where previously you had large
    `case` statements or nested `if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Storing secret data with hiera-gpg
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're using Hiera to store your configuration data, there's a gem available
    called **hiera-gpg** that adds an encryption backend to Hiera to allow you to
    protect values stored in Hiera.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To set up hiera-gpg, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `ruby-dev` package; it will be required to build the `hiera-gpg`
    gem as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install the `hiera-gpg` gem using the gem provider:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify your `hiera.yaml` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we''ll create a piece of encrypted data and retrieve it using
    `hiera-gpg` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `secret.yaml` file at `/etc/puppet/secret` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you don't already have a GnuPG encryption key, follow the steps in the *Using
    GnuPG to encrypt secrets* recipe in [Chapter 4](ch04.html "Chapter 4. Working
    with Files and Packages"), *Working with Files and Packages*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Encrypt the `secret.yaml` file to this key using the following command (replace
    the `puppet@puppet.example.com` with the e-mail address you specified when creating
    the key). This will create the `secret.gpg` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove the plaintext `secret.yaml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify your default node in the `site.pp` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now run Puppet on a node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you install `hiera-gpg`, it adds to Hiera, the ability to decrypt `.gpg`
    files. So you can put any secret data into a `.yaml` file that you then encrypt
    to the appropriate key with GnuPG. Only machines that have the right secret key
    will be able to access this data.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you might encrypt the MySQL root password using `hiera-gpg` and
    install the corresponding key only on your database servers. Although other machines
    may also have a copy of the `secret.gpg` file, it's not readable to them unless
    they have the decryption key.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might also like to know about `hiera-eyaml`, another secret-data backend
    for Hiera that supports encryption of individual values within a Hiera data file.
    This could be handy if you need to mix encrypted and unencrypted facts within
    a single file. Find out more about hiera-eyaml at [https://github.com/TomPoulton/hiera-eyaml](https://github.com/TomPoulton/hiera-eyaml).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using GnuPG to encrypt secrets* recipe in [Chapter 4](ch04.html "Chapter 4. Working
    with Files and Packages"), *Working with Files and Packages*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using MessagePack serialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running Puppet in a centralized architecture creates a lot of traffic between
    nodes. The bulk of this traffic is JSON and yaml data. An experimental feature
    of the latest releases of Puppet allow for the serialization of this data using
    **MessagePack** (**msgpack**).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install the msgpack gem onto your Puppet master and your nodes. Use Puppet
    to do the work for you with Puppet resource. You may need to install the `ruby-dev`
    or `ruby-devel` package on your nodes/server at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Set the `preferred_serialization_format` to `msgpack` in the `[agent]` section
    of your nodes `puppet.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The master will be sent this option when the node begins communicating with
    the master. Any classes that support serialization with `msgpack` will be transmitted
    with `msgpack.Serialization` of the data between nodes and the master will in
    theory increase the speed at which nodes communicate by optimizing the data that
    is travelling between them. This feature is still experimental.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic syntax checking with Git hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It would be nice if we knew there was a syntax error in the manifest before
    we even committed it. You can have Puppet check the manifest using the `puppet
    parser validate` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: This is especially useful because a mistake anywhere in the manifest will stop
    Puppet from running on any node, even on nodes that don't use that particular
    part of the manifest. So checking in a bad manifest can cause Puppet to stop applying
    updates to production for some time, until the problem is discovered, and this
    could potentially have serious consequences. The best way to avoid this is to
    automate the syntax check, by using a precommit hook in your version control repo.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your Puppet repo, create a new `hooks` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the file `hooks/check_syntax.sh` with the following contents (based
    on a script by Puppet Labs):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set execute permission for the `hook` script with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now either symlink or copy the script to the precommit hook in your hooks directory.
    If your Git repo is checked out in `~/puppet`, then create the symlink at `~/puppet/hooks/pre-commit`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `check_syntax.sh` script will prevent you from committing any files with
    syntax errors when it is used as the pre-commit hook for Git:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: If you add the `hooks` directory to your Git repo, anyone who has a checkout
    can copy the script into their local `hooks` directory to get this syntax checking
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing code around with Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already seen in the decentralized model, Git can be used to transfer
    files between machines using a combination of `ssh` and `ssh` keys. It can also
    be useful to have a Git hook do the same on each successful commit to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: There exists a hook called post-commit that can be run after a successful commit
    to the repository. In this recipe, we'll create a hook that updates the code on
    our Puppet master with code from our Git repository on the Git server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `ssh` key that can access your Puppet user on your Puppet master
    and install this key into the Git user''s account on `git.example.com`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the Puppet account to allow the Git user to log in as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Git user can log in to the Puppet master as the Puppet user, modify
    the Git user''s `ssh` configuration to use the newly created `ssh` key by default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the Puppet master as a remote location for the Puppet repository on the
    Git server with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On the Puppet master, move the `production` directory out of the way and check
    out your Puppet repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we have a local bare repository on the Puppet server that we can push to,
    to remotely clone this into the `production` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now perform a Git push from the Git server to the Puppet master:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a post-commit file in the `hooks` directory of the repository on the
    Git server with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Commit a change to the repository from your laptop and verify that the change
    is propagated to the Puppet master as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a bare repository on the Puppet master that we then use as a remote
    for the repository on `git.example.com` (remote repositories must be bare). We
    then clone that bare repository into the `production` directory. We add the bare
    repository on `puppet.example.com` as a remote to the bare repository on `git.example.com`.
    We then create a post-receive hook in the repository on `git.example.com`.
  prefs: []
  type: TYPE_NORMAL
- en: The hook issues a Git push to the Puppet master bare repository. We then update
    the `production` directory from the updated bare repository on the Puppet master.
    In the next section, we'll modify the hook to use branches.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Environments with Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Branches are a way of keeping several different tracks of development within
    a single source repository. Puppet environments are a lot like Git branches. You
    can have the same code with slight variations between branches, just as you can
    have different modules for different environments. In this section, we'll show
    how to use Git branches to define environments on the Puppet master.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, we created a `production` directory that was based
    on the master branch; we''ll remove that directory now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Modify the `post-receive` hook to accept a branch variable. The hook will use
    this variable to create a directory on the Puppet master as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify your `README` file again and push to the repository on `git.example.com`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The hook now reads in the `refname` and parses out the branch that is being
    updated. We use that branch variable to clone the repository into a new directory
    and check out the branch.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now when we want to create a new environment, we can create a new branch in
    the Git repository. The branch will create a directory on the Puppet master. Each
    branch of the Git repository represents an environment on the Puppet master:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the production branch as shown in the following command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the production branch and push to the Git server as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now whenever we create a new branch, a corresponding directory is created in
    our environment's directory. A one-to-one mapping is established between environments
    and branches.
  prefs: []
  type: TYPE_NORMAL
