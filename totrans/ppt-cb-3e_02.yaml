- en: Chapter 2. Puppet Infrastructure
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章：Puppet 基础设施
- en: '|   | *"Computers in the future may have as few as 1,000 vacuum tubes and weigh
    only 1.5 tons."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *“未来的计算机可能只有1,000个真空管，重量仅为1.5吨。”* |   |'
- en: '|   | --*Popular Mechanics, 1949* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*《Popular Mechanics》，1949年* |'
- en: 'In this chapter, we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论：
- en: Installing Puppet
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Puppet
- en: Managing your manifests with Git
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Git 管理你的清单
- en: Creating a decentralized Puppet architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建分散式 Puppet 架构
- en: Writing a papply script
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 papply 脚本
- en: Running Puppet from cron
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 cron 运行 Puppet
- en: Bootstrapping Puppet with bash
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 bash 引导 Puppet
- en: Creating a centralized Puppet infrastructure
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建集中式 Puppet 基础设施
- en: Creating certificates with multiple DNS names
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有多个 DNS 名称的证书
- en: Running Puppet from passenger
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 passenger 运行 Puppet
- en: Setting up the environment
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置环境
- en: Configuring PuppetDB
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 PuppetDB
- en: Configuring Hiera
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 Hiera
- en: Setting-node specific data with Hiera
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Hiera 设置节点特定数据
- en: Storing secret data with hiera-gpg
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 hiera-gpg 存储机密数据
- en: Using MessagePack serialization
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MessagePack 序列化
- en: Automatic syntax checking with Git hooks
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Git 钩子进行自动语法检查
- en: Pushing code around with Git
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Git 推送代码
- en: Managing environments with Git
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Git 管理环境
- en: Introduction
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we will cover how to deploy Puppet in a centralized and decentralized
    manner. With each approach, we'll see a combination of best practices, my personal
    experience, and community solutions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍如何以集中式和分散式方式部署 Puppet。在每种方法中，我们将看到最佳实践、我的个人经验和社区解决方案的结合。
- en: We'll configure and use both PuppetDB and Hiera. PuppetDB is used with exported
    resources, which we will cover in [Chapter 5](ch05.html "Chapter 5. Users and
    Virtual Resources"), *Users and Virtual Resources*. Hiera is used to separate
    variable data from Puppet code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将配置并使用 PuppetDB 和 Hiera。PuppetDB 与导出的资源一起使用，我们将在[第5章](ch05.html "第5章：用户与虚拟资源")，*用户与虚拟资源*中进行详细讲解。Hiera
    用于将变量数据与 Puppet 代码分离。
- en: Finally, I'll introduce Git and see how to use Git to organize our code and
    our infrastructure.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我将介绍 Git，并展示如何使用 Git 来组织我们的代码和基础设施。
- en: Because Linux distributions, such as Ubuntu, Red Hat, and CentOS, differ in
    the specific details of package names, configuration file paths, and many other
    things, I have decided that for reasons of space and clarity the best approach
    for this book is to pick one distribution (*Debian 7* named as *Wheezy*) and stick
    to that. However, Puppet runs on most popular operating systems, so you should
    have very little trouble adapting the recipes to your own favorite OS and distribution.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Linux 发行版（如 Ubuntu、Red Hat 和 CentOS）在软件包名称、配置文件路径以及许多其他细节上有所不同，我决定出于篇幅和清晰度考虑，本书选择一个发行版（*Debian
    7*，代号 *Wheezy*）并坚持使用它。然而，Puppet 可以在大多数流行的操作系统上运行，因此你应该能够轻松地将这些示例适配到你自己喜爱的操作系统和发行版上。
- en: At the time of writing, Puppet 3.7.2 is the latest stable version available,
    this is the version of Puppet used in the book. The syntax of Puppet commands
    changes often, so be aware that while older versions of Puppet are still perfectly
    usable, they may not support all of the features and syntax described in this
    book. As we saw in [Chapter 1](ch01.html "Chapter 1. Puppet Language and Style"),
    *Puppet Language and Style*, the future parser showcases features of the language
    scheduled to become default in Version 4 of Puppet.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书写作时，Puppet 3.7.2 是最新的稳定版本，本书中使用的就是这一版本的 Puppet。Puppet 命令的语法变化较为频繁，因此请注意，虽然较旧版本的
    Puppet 仍然可以正常使用，但它们可能不支持本书中描述的所有功能和语法。正如我们在[第1章](ch01.html "第1章：Puppet 语言与风格")，*Puppet
    语言与风格*中所见，未来的解析器展示了计划在 Puppet 4 版本中成为默认功能的语言特性。
- en: Installing Puppet
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Puppet
- en: In [Chapter 1](ch01.html "Chapter 1. Puppet Language and Style"), *Puppet Language
    and Style*, we installed Puppet as a rubygem using the gem install. When deploying
    to several nodes, this may not be the best approach. Using the package manager
    of your chosen distribution is the best way to keep your Puppet versions similar
    on all of the nodes in your deployment. Puppet labs maintain repositories for
    APT-based and YUM-based distributions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章：Puppet 语言与风格")，*Puppet 语言与风格*中，我们通过 gem 安装安装了 Puppet 作为
    rubygem。在部署到多个节点时，这可能不是最佳方法。使用你所选择的发行版的包管理器，是保持所有节点上 Puppet 版本一致的最佳方法。Puppet Labs
    为基于 APT 和 YUM 的发行版维护了软件仓库。
- en: Getting ready
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: If your Linux distribution uses APT for package management, go to [http://apt.puppetlabs.com/](http://apt.puppetlabs.com/)
    and download the appropriate Puppet labs release package for your distribution.
    For our wheezy cookbook node, we will use [http://apt.puppetlabs.com/puppetlabs-release-wheezy.deb](http://apt.puppetlabs.com/puppetlabs-release-wheezy.deb).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 Linux 发行版使用 APT 作为包管理，访问 [http://apt.puppetlabs.com/](http://apt.puppetlabs.com/)
    下载适合你发行版的 Puppet Labs 发布包。对于我们的 wheezy cookbook 节点，我们将使用 [http://apt.puppetlabs.com/puppetlabs-release-wheezy.deb](http://apt.puppetlabs.com/puppetlabs-release-wheezy.deb)。
- en: If you are using a Linux distribution that uses YUM for package management,
    go to [http://yum.puppetlabs.com/](http://yum.puppetlabs.com/) and download the
    appropriate Puppet labs release package for your distribution.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是一个使用 YUM 作为包管理的 Linux 发行版，访问 [http://yum.puppetlabs.com/](http://yum.puppetlabs.com/)
    下载适合你发行版的 Puppet Labs 发布包。
- en: How to do it...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Once you have found the appropriate Puppet labs release package for your distribution,
    the steps to install Puppet are the same for either APT or YUM:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦找到适合你发行版的 Puppet Labs 发布包，安装 Puppet 的步骤对于 APT 和 YUM 都是相同的：
- en: Install Puppet labs release package
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Puppet Labs 发布包
- en: Install Puppet package
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Puppet 包
- en: 'Once you have installed Puppet, verify the version of Puppet as shown in the
    following example:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦安装了 Puppet，请按照下面的示例验证 Puppet 的版本：
- en: '[PRE0]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now that we have a method to install Puppet on our nodes, we need to turn our
    attention to keeping our Puppet manifests organized. In the next section, we will
    see how to use Git to keep our code organized and consistent.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了在节点上安装 Puppet 的方法，接下来需要关注的是如何保持 Puppet 清单的有序管理。在接下来的章节中，我们将展示如何使用 Git
    来保持代码的组织性和一致性。
- en: Managing your manifests with Git
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Git 管理你的清单
- en: 'It''s a great idea to put your Puppet manifests in a version control system
    such as Git or Subversion (Git is the de facto standard for Puppet). This gives
    you several advantages:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Puppet 清单放入版本控制系统（如 Git 或 Subversion）是一个非常好的主意（Git 是 Puppet 的事实标准）。这样做有几个优势：
- en: You can undo changes and revert to any previous version of your manifest
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以撤销更改，并恢复到任何先前的清单版本
- en: You can experiment with new features using a branch
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用分支来尝试新特性
- en: If several people need to make changes to the manifests, they can make them
    independently, in their own working copies, and then merge their changes later
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果多人需要修改清单，他们可以在各自的工作副本中独立进行更改，然后再合并更改。
- en: You can use the `git log` feature to see what was changed, and when (and by
    whom)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `git log` 功能查看更改的内容，以及更改发生的时间（和更改者）
- en: Getting ready
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this section, we'll import your existing manifest files into Git. If you
    have created a Puppet directory in a previous section use that, otherwise, use
    your existing manifest directory.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们将把你现有的清单文件导入到 Git 中。如果你在之前的部分中创建了 Puppet 目录，请使用该目录，否则使用你现有的清单目录。
- en: 'In this example, we''ll create a new Git repository on a server accessible
    from all our nodes. There are several steps we need to take to have our code held
    in a Git repository:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将在一个所有节点都能访问的服务器上创建一个新的 Git 仓库。为了将代码托管在 Git 仓库中，我们需要执行几个步骤：
- en: Install Git on a central server.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在中央服务器上安装 Git。
- en: Create a user to run Git and own the repository.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用户来运行 Git 并拥有仓库。
- en: Create a repository to hold the code.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个仓库来存放代码。
- en: Create **SSH** keys to allow key-based access to the repository.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 **SSH** 密钥以允许基于密钥的访问仓库。
- en: Install Git on a node and download the latest version from our Git repository.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在节点上安装 Git 并从我们的 Git 仓库下载最新版本。
- en: How to do it...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'First, install Git on your Git server (`git.example.com` in our example). The
    easiest way to do this is using Puppet. Create the following manifest, call it
    `git.pp`:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在你的 Git 服务器（在我们的示例中是 `git.example.com`）上安装 Git。最简单的方式是使用 Puppet。创建以下清单，命名为
    `git.pp`：
- en: '[PRE1]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Apply this manifest using `puppet apply git.pp`, this will install Git.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `puppet apply git.pp` 应用此清单，这将安装 Git。
- en: 'Next, create a Git user that the nodes will use to log in and retrieve the
    latest code. Again, we''ll do this with puppet. We''ll also create a directory
    to hold our repository (`/home/git/repos`) as shown in the following code snippet:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个 Git 用户，供节点登录并获取最新代码。我们仍然使用 Puppet 来完成这个操作。我们还将创建一个目录来存放我们的仓库（`/home/git/repos`），如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After applying that manifest, log in as the Git user and create an empty Git
    repository using the following command:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用该清单后，作为 Git 用户登录，并使用以下命令创建一个空的 Git 仓库：
- en: '[PRE3]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Set a password for the Git user, we''ll need to log in remotely after the next
    step:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 Git 用户设置密码，我们将在下一步后远程登录：
- en: '[PRE4]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now back on your local machine, create an `ssh` key for our nodes to use to
    update the repository:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在回到本地机器，创建一个`ssh`密钥供我们的节点用来更新仓库：
- en: '[PRE5]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now copy the newly created public key to the `authorized_keys` file. This will
    allow us to connect to the Git server using this new key:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将新创建的公钥复制到`authorized_keys`文件中。这将允许我们使用这个新密钥连接到 Git 服务器：
- en: '[PRE6]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now try logging into the machine, with: "ssh ''git@git.example.com''" and check
    to make sure that only the key(s) you wanted were added.'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在尝试使用以下命令登录到机器："ssh 'git@git.example.com'"，并检查确保只有你希望添加的密钥被加入。
- en: 'Next, configure `ssh` to use your key when accessing the Git server and add
    the following to your `~/.ssh/config` file:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，配置`ssh`在访问 Git 服务器时使用你的密钥，并将以下内容添加到你的`~/.ssh/config`文件中：
- en: '[PRE7]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Clone the repo onto your machine into a directory named Puppet (substitute
    your server name if you didn''t use `git.example.com`):'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将仓库克隆到你的机器上，放入一个名为 Puppet 的目录中（如果你没有使用`git.example.com`，请替换为你的服务器名称）：
- en: '[PRE8]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We've created a Git repository; before we commit any changes to the repository,
    it's a good idea to set your name and e-mail in Git. Your name and e-mail will
    be appended to each commit you make.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经创建了一个 Git 仓库；在我们向仓库提交任何更改之前，最好在 Git 中设置你的名字和电子邮件。你的名字和电子邮件将附加到你做的每个提交上。
- en: 'When you are working in a large team, knowing who made a change is very important;
    for this, use the following code snippet:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你在一个大型团队中工作时，知道是谁做了哪些更改非常重要；为此，请使用以下代码片段：
- en: '[PRE9]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can verify your Git settings using the following snippet:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用以下代码片段验证你的 Git 设置：
- en: '[PRE10]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now that we have Git configured properly, change directory to your repository
    directory and create a new site manifest as shown in the following snippet:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经正确配置了 Git，切换到你的仓库目录，并按照以下代码片段创建一个新的站点清单：
- en: '[PRE11]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This site manifest will install our base class on every node; we will create
    the base class using the Puppet module as we did in [Chapter 1](ch01.html "Chapter 1. Puppet
    Language and Style"), *Puppet Language and Style*:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个站点清单将在每个节点上安装我们的基础类；我们将像在[第1章](ch01.html "第1章。Puppet语言与风格")中一样使用 Puppet 模块创建基础类，*Puppet
    语言与风格*：
- en: '[PRE12]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As a last step, we create a symbolic link between the `thomas-base` directory
    and `base`. Now to make sure our module does something useful, add the following
    to the body of the `base` class defined in `thomas-base/manifests/init.pp`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步，我们在`thomas-base`目录和`base`之间创建一个符号链接。现在，为了确保我们的模块能够执行有用的操作，请在`thomas-base/manifests/init.pp`中定义的`base`类的主体中添加以下内容：
- en: '[PRE13]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now add the new base module and site manifest to Git using `git add` and `git
    commit` as follows:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在使用`git add`和`git commit`将新的基础模块和站点清单添加到 Git，如下所示：
- en: '[PRE14]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'At this point your changes to the Git repository have been committed locally;
    you now need to push those changes back to `git.example.com` so that other nodes
    can retrieve the updated files:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，你对 Git 仓库的更改已经在本地提交；你现在需要将这些更改推送到`git.example.com`，以便其他节点可以获取更新的文件：
- en: '[PRE15]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Git tracks changes to files, and stores a complete history of all changes. The
    history of the repo is made up of commits. A commit represents the state of the
    repo at a particular point in time, which you create with the `git commit` command
    and annotate with a message.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Git 跟踪文件更改，并存储所有更改的完整历史记录。仓库的历史由提交（commits）构成。一个提交代表某个特定时间点仓库的状态，你可以通过`git commit`命令创建并附加一条信息来标注提交。
- en: You've now added your Puppet manifest files to the repo and created your first
    commit. This updates the history of the repo, but only in your local working copy.
    To synchronize the changes with the `git.example.com` copy, the `git push` command
    pushes all changes made since the last sync.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经将 Puppet 清单文件添加到仓库并创建了第一个提交。这更新了仓库的历史记录，但仅在你本地的工作副本中。要将更改与`git.example.com`副本同步，`git
    push`命令会推送自上次同步以来所做的所有更改。
- en: There's more...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: Now that you have a central Git repository for your Puppet manifests, you can
    check out multiple copies of it in different places and work on them before committing
    your changes. For example, if you're working in a team, each member can have their
    own local copy of the repo and synchronize changes with the others via the central
    server. You may also choose to use GitHub as your central Git repository server.
    GitHub offers free Git repository hosting for public repositories, and you can
    pay for GitHub's premium service if you don't want your Puppet code to be publicly
    available.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经有了一个中央的 Git 仓库来存储 Puppet 清单，你就可以在不同的位置检出多个副本，并在提交更改之前进行工作。例如，如果你在一个团队中工作，每个成员可以有自己本地的仓库副本，并通过中央服务器与其他成员同步更改。你也可以选择使用
    GitHub 作为你的中央 Git 仓库服务器。GitHub 为公开仓库提供免费的 Git 仓库托管，如果你不希望 Puppet 代码公开，可以支付 GitHub
    的高级服务费用。
- en: In the next section, we will use our Git repository for both centralized and
    decentralized Puppet configurations.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将使用我们的 Git 仓库来配置集中式和去中心化的 Puppet 配置。
- en: Creating a decentralized Puppet architecture
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个去中心化的 Puppet 架构
- en: Puppet is a configuration management tool. You can use Puppet to configure and
    prevent configuration drift in a large number of client computers. If all your
    client computers are easily reached via a central location, you may choose to
    have a central Puppet server control all the client computers. In the centralized
    model, the Puppet server is known as the Puppet master. We will cover how to configure
    a central Puppet master in a few sections.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 是一个配置管理工具。你可以使用 Puppet 配置并防止大量客户端计算机出现配置漂移。如果你的所有客户端计算机都可以通过一个中心位置轻松访问，你可以选择让中央
    Puppet 服务器控制所有客户端计算机。在集中式模型中，Puppet 服务器被称为 Puppet 主控。我们将在接下来的几节中介绍如何配置一个中央 Puppet
    主控。
- en: If your client computers are widely distributed or you cannot guarantee communication
    between the client computers and a central location, then a decentralized architecture
    may be a good fit for your deployment. In the next few sections, we will see how
    to configure a decentralized Puppet architecture.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客户端计算机分布广泛，或者无法保证客户端计算机与中心位置之间的通信，那么去中心化架构可能适合你的部署。在接下来的几节中，我们将看到如何配置一个去中心化的
    Puppet 架构。
- en: As we have seen, we can run the `puppet apply` command directly on a manifest
    file to have Puppet apply it. The problem with this arrangement is that we need
    to have the manifests transferred to the client computers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，我们可以直接在清单文件上运行 `puppet apply` 命令来让 Puppet 应用它。这个方法的问题是我们需要将清单传输到客户端计算机上。
- en: We can use the Git repository we created in the previous section to transfer
    our manifests to each new node we create.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用上一节中创建的 Git 仓库，将我们的清单传输到我们创建的每个新节点。
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new test node, call this new node whatever you wish, I'll use `testnode`
    for mine. Install Puppet on the machine as we have previously done.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的测试节点，给这个新节点命名，你可以随意命名，我这里用 `testnode`。按照之前的方法在机器上安装 Puppet。
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a `bootstrap.pp` manifest that will perform the following configuration
    steps on our new node:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `bootstrap.pp` 清单，该清单将在我们的新节点上执行以下配置步骤：
- en: 'Install Git:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Git：
- en: '[PRE16]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Install the `ssh` key to access `git.example.com` in the Puppet user''s home
    directory (`/var/lib/puppet/.ssh/id_rsa`):'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Puppet 用户的主目录（`/var/lib/puppet/.ssh/id_rsa`）中安装 `ssh` 密钥，以访问 `git.example.com`：
- en: '[PRE17]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Download the `ssh` host key from `git.example.com` (`/var/lib/puppet/.ssh/known_hosts`):'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `git.example.com` 下载 `ssh` 主机密钥（`/var/lib/puppet/.ssh/known_hosts`）：
- en: '[PRE18]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a directory to contain the Git repository (`/etc/puppet/cookbook`):'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个目录来存放 Git 仓库（`/etc/puppet/cookbook`）：
- en: '[PRE19]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Clone the Puppet repository onto the new machine:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Puppet 仓库克隆到新机器上：
- en: '[PRE20]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now when we run Puppet apply on the new machine, the `ssh` key will be installed
    for the Puppet user. The Puppet user will then clone the Git repository into `/etc/puppet/cookbook`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当我们在新机器上运行 Puppet apply 时，`ssh` 密钥将为 Puppet 用户安装。然后，Puppet 用户会将 Git 仓库克隆到
    `/etc/puppet/cookbook`：
- en: '[PRE21]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may have to disable the `tty` requirement of `sudo`. Comment out the line
    `Defaults requiretty` at `/etc/sudoers` if you have this line.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能需要禁用 `sudo` 的 `tty` 要求。如果 `/etc/sudoers` 文件中有 `Defaults requiretty` 这一行，请将其注释掉。
- en: Alternatively, you can set `user => Puppet` within the `'create cookbook' exec`
    type. Beware that using the user attribute will cause any error messages from
    the command to be lost.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，你可以在 `'create cookbook' exec` 类型中设置 `user => Puppet`。请注意，使用 user 属性会导致命令的任何错误信息丢失。
- en: 'Now that your Puppet code is available on the new node, you can apply it using
    `puppet apply`, specifying that `/etc/puppet/cookbook/modules` will contain the
    modules:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你的 Puppet 代码已经可以在新节点上使用，你可以通过 `puppet apply` 来应用它，并指定 `/etc/puppet/cookbook/modules`
    包含这些模块：
- en: '[PRE22]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, our `bootstrap.pp` manifest ensures that Git is installed. The manifest
    then goes on to ensure that the `ssh` key for the Git user on `git.example.com`
    is installed into the Puppet user's home directory (`/var/lib/puppet` by default).
    The manifest then ensures that the host key for `git.example.com` is trusted by
    the Puppet user. With `ssh` configured, the bootstrap ensures that `/etc/puppet/cookbook`
    exists and is a directory.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的 `bootstrap.pp` 清单确保 Git 已安装。该清单接着确保 Git 用户在 `git.example.com` 上的 `ssh`
    密钥已安装到 Puppet 用户的主目录（默认是 `/var/lib/puppet`）。接下来，清单确保 `git.example.com` 的主机密钥被
    Puppet 用户信任。配置好 `ssh` 后，启动脚本确保 `/etc/puppet/cookbook` 存在并且是一个目录。
- en: We then use an `exec` to have Git clone the repository into `/etc/puppet/cookbook`.
    With all the code in place, we then call `puppet apply` a final time to deploy
    the code from the repository. In a production setting, you would distribute the
    `bootstrap.pp` manifest to all your nodes, possibly via an internal web server,
    using a method similar to curl [http://puppet/bootstrap.pp >bootstrap.pp && puppet
    apply bootstrap.pp](http://puppet/bootstrap.pp >bootstrap.pp && puppet apply bootstrap.pp)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用 `exec` 命令让 Git 克隆仓库到 `/etc/puppet/cookbook`。所有代码就绪后，我们再次调用 `puppet apply`
    来部署仓库中的代码。在生产环境中，你可以将 `bootstrap.pp` 清单分发到所有节点，可能通过内部 web 服务器，使用类似 curl [http://puppet/bootstrap.pp
    >bootstrap.pp && puppet apply bootstrap.pp](http://puppet/bootstrap.pp >bootstrap.pp
    && puppet apply bootstrap.pp) 的方式。
- en: Writing a papply script
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个 papply 脚本
- en: We'd like to make it as quick and easy as possible to apply Puppet on a machine;
    for this we'll write a little script that wraps the `puppet apply` command with
    the parameters it needs. We'll deploy the script where it's needed with Puppet
    itself.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望尽可能快速和简单地在机器上应用 Puppet；为此，我们将编写一个小脚本，将 `puppet apply` 命令与它所需的参数封装在一起。我们将使用
    Puppet 本身在需要的地方部署这个脚本。
- en: How to do it...
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'In your Puppet repo, create the directories needed for a Puppet module:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 Puppet 仓库中，创建 Puppet 模块所需的目录：
- en: '[PRE23]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create the `modules/puppet/files/papply.sh` file with the following contents:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `modules/puppet/files/papply.sh` 文件，内容如下：
- en: '[PRE24]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create the `modules/puppet/manifests/init.pp` file with the following contents:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `modules/puppet/manifests/init.pp` 文件，内容如下：
- en: '[PRE25]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Modify your `manifests/site.pp` file as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式修改你的 `manifests/site.pp` 文件：
- en: '[PRE26]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add the Puppet module to the Git repository and commit the change as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Puppet 模块添加到 Git 仓库并提交更改，如下所示：
- en: '[PRE27]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now remember to push the changes to the Git repository on `git.example.com`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在记得将更改推送到 `git.example.com` 上的 Git 仓库：
- en: '[PRE28]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Pull the latest version of the Git repository to your new node (`testnode`
    for me) as shown in the following command line:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示，拉取 Git 仓库的最新版本到你的新节点（对我来说是 `testnode`）：
- en: '[PRE29]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Apply the manifest manually once to install the `papply` script:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 手动应用清单一次以安装 `papply` 脚本：
- en: '[PRE30]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, test the script:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，测试脚本：
- en: '[PRE31]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, whenever you need to run Puppet, you can simply run `papply`. In future,
    when we apply Puppet changes, I'll ask you to run `papply` instead of the full
    `puppet apply` command.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当你需要运行 Puppet 时，只需运行 `papply`。将来，当我们应用 Puppet 更改时，我会让你运行 `papply` 而不是完整的
    `puppet apply` 命令。
- en: How it works...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As you''ve seen, to run Puppet on a machine and apply a specified manifest
    file, we use the `puppet apply` command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，为了在机器上运行 Puppet 并应用指定的清单文件，我们使用 `puppet apply` 命令：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When you''re using modules (such as the Puppet module we just created), you
    also need to tell Puppet where to search for modules, using the `modulepath` argument:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用模块时（例如我们刚才创建的 Puppet 模块），你还需要告诉 Puppet 在哪里查找模块，使用 `modulepath` 参数：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In order to run Puppet with the root privileges it needs, we have to put `sudo`
    before everything:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以所需的根权限运行 Puppet，我们必须在所有命令前加上 `sudo`：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, any additional arguments passed to `papply` will be passed through
    to Puppet itself, by adding the `$*` parameter:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，传递给 `papply` 的任何附加参数将通过 `$*` 参数传递给 Puppet 本身：
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'That''s a lot of typing, so putting this in a script makes sense. We''ve added
    a Puppet file resource that will deploy the script to `/usr/local/bin` and make
    it executable:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要大量的输入，因此将其放入脚本中是合理的。我们添加了一个 Puppet 文件资源，将脚本部署到 `/usr/local/bin` 并使其可执行：
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, we include the Puppet module in our default node declaration:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在默认节点声明中包含了 Puppet 模块：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can do the same for any other nodes managed by Puppet.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对任何其他由 Puppet 管理的节点做同样的操作。
- en: Running Puppet from cron
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 cron 运行 Puppet
- en: 'You can do a lot with the setup you already have: work on your Puppet manifests
    as a team, communicate changes via a central Git repository, and manually apply
    them on a machine using the `papply` script.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以利用现有的设置做很多事情：作为团队共同处理 Puppet 清单，通过中央 Git 仓库通信更改，并使用 `papply` 脚本手动在机器上应用它们。
- en: However, you still have to log into each machine to update the Git repo and
    rerun Puppet. It would be helpful to have each machine update itself and apply
    any changes automatically. Then all you need to do is to push a change to the
    repo, and it will go out to all your machines within a certain time.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你仍然需要登录到每台机器上以更新 Git 仓库并重新运行 Puppet。拥有每台机器自动更新并应用更改的功能会很有帮助。然后你只需推送更改到仓库，它会在一定时间内自动传送到所有机器。
- en: The simplest way to do this is with a **cron** job that pulls updates from the
    repo at regular intervals and then runs Puppet if anything has changed.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是使用 **cron** 任务定期从仓库拉取更新，并在有任何更改时运行 Puppet。
- en: Getting ready
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You'll need the Git repo we set up in the *Managing your manifests with Git*
    and *Creating a decentralized Puppet architecture* recipes, and the `papply` script
    from the *Writing a papply script* recipe. You'll need to apply the `bootstrap.pp`
    manifest we created to install `ssh` keys to download the latest repository.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要我们在*使用 Git 管理清单*和*创建去中心化的 Puppet 架构*食谱中设置的 Git 仓库，以及来自*编写 papply 脚本*食谱的
    `papply` 脚本。你需要应用我们创建的 `bootstrap.pp` 清单，以安装 `ssh` 密钥并下载最新的仓库。
- en: How to do it...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: Copy the `bootstrap.pp` script to any node you wish to enroll. The `bootstrap.pp`
    manifest includes the private key used to access the Git repository, it should
    be protected in a production environment.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `bootstrap.pp` 脚本复制到任何你希望注册的节点。`bootstrap.pp` 清单包括用于访问 Git 仓库的私钥，生产环境中应该保护该密钥。
- en: 'Create the `modules/puppet/files/pull-updates.sh` file with the following contents:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `modules/puppet/files/pull-updates.sh` 文件，内容如下：
- en: '[PRE38]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Modify the `modules/puppet/manifests/init.pp` file and add the following snippet
    after the `papply` file definition:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `modules/puppet/manifests/init.pp` 文件，在 `papply` 文件定义后添加以下代码片段：
- en: '[PRE39]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Commit the changes as before and push to the Git server as shown in the following
    command line:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如之前所示，提交更改并推送到 Git 服务器，命令行如下：
- en: '[PRE40]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Issue a Git pull on the test node:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试节点上发出 Git pull 命令：
- en: '[PRE41]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Run Puppet on the test node:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试节点上运行 Puppet：
- en: '[PRE42]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Check that the `pull-updates` script works properly:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 `pull-updates` 脚本是否正常工作：
- en: '[PRE43]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Verify the `cron` job was created successfully:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证 `cron` 任务是否成功创建：
- en: '[PRE44]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How it works...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When we created the `bootstrap.pp` manifest, we made sure that the Puppet user
    can checkout the Git repository using an `ssh` key. This enables the Puppet user
    to run the Git pull in the cookbook directory unattended. We''ve also added the
    `pull-updates` script, which does this and runs Puppet if any changes are pulled:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建 `bootstrap.pp` 清单时，我们确保 Puppet 用户可以使用 `ssh` 密钥签出 Git 仓库。这使得 Puppet 用户可以在食谱目录中无人值守地运行
    Git pull。我们还添加了 `pull-updates` 脚本，它会执行此操作，并在拉取到任何更改时运行 Puppet：
- en: '[PRE45]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We deploy this script to the node with Puppet:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 Puppet 将此脚本部署到节点上：
- en: '[PRE46]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, we''ve created a `cron` job that runs `pull-updates` at regular intervals
    (every 10 minutes, but feel free to change this if you need to):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了一个 `cron` 任务，它定期（每10分钟，但如果需要可以更改）运行 `pull-updates`：
- en: '[PRE47]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: There's more...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Congratulations, you now have a fully-automated Puppet infrastructure! Once
    you have applied the `bootstrap.pp` manifest, run Puppet on the repository; the
    machine will be set up to pull any new changes and apply them automatically.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，你现在拥有一个完全自动化的 Puppet 基础架构！一旦你应用了 `bootstrap.pp` 清单，运行 Puppet 在仓库中；机器将设置为拉取任何新的更改并自动应用它们。
- en: So, for example, if you wanted to add a new user account to all your machines,
    all you have to do is add the account in your working copy of the manifest, and
    commit and push the changes to the central Git repository. Within 10 minutes,
    it will automatically be applied to every machine that's running Puppet.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，如果你想为所有机器添加一个新的用户账户，你需要做的就是在工作副本的清单中添加该账户，然后提交并推送到中央 Git 仓库。在10分钟内，它会自动应用到所有运行
    Puppet 的机器上。
- en: Bootstrapping Puppet with bash
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 bash 启动 Puppet
- en: Previous versions of this book used Rakefiles to bootstrap Puppet. The problem
    with using Rake to configure a node is that you are running the commands from
    your laptop; you assume you already have `ssh` access to the machine. Most bootstrap
    processes work by issuing an easy to remember command from a node once it has
    been provisioned. In this section, we'll show how to use bash to bootstrap Puppet
    with a web server and a bootstrap script.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的早期版本使用 Rakefiles 来启动 Puppet。使用 Rake 配置节点的问题在于，您是从笔记本电脑上运行命令；您假设已经有 `ssh`
    访问该机器的权限。大多数启动过程通过在节点已被配置后执行一个容易记住的命令来完成。在本节中，我们将展示如何使用 bash 和 web 服务器以及启动脚本来启动
    Puppet。
- en: Getting ready
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Install httpd on a centrally accessible server and create a password protected
    area to store the bootstrap script. In my example, I''ll use the Git server I
    set up previously, `git.example.com`. Start by creating a directory in the root
    of your web server:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个中心可访问的服务器上安装 httpd，并创建一个受密码保护的区域来存储启动脚本。在我的示例中，我将使用之前设置的 Git 服务器 `git.example.com`。首先在
    web 服务器的根目录下创建一个目录：
- en: '[PRE48]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now perform the following steps:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在执行以下步骤：
- en: 'Add the following location definition to your apache configuration:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下位置定义添加到您的 apache 配置中：
- en: '[PRE49]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Reload your web server to ensure the location configuration is operating. Verify
    with curl that you cannot download from the bootstrap directory without authentication:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新加载您的 web 服务器以确保位置配置生效。使用 curl 验证您无法在没有身份验证的情况下从 bootstrap 目录下载：
- en: '[PRE50]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create the password file you referenced in the apache configuration (`/var/www/puppet.passwd`):'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建您在 apache 配置中引用的密码文件（`/var/www/puppet.passwd`）：
- en: '[PRE51]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Verify that the username and password permit access to the bootstrap directory
    as follows:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证用户名和密码是否允许访问 bootstrap 目录，如下所示：
- en: '[PRE52]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How to do it...
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Now that you have a safe location to store the bootstrap script, create a bootstrap
    script for each OS you support in the bootstrap directory. In this example, I'll
    show you how to do this for a Red Hat Enterprise Linux 6-based distribution.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您有了一个安全的位置来存储启动脚本，在 bootstrap 目录中为您支持的每个操作系统创建一个启动脚本。在这个例子中，我将展示如何为基于 Red
    Hat Enterprise Linux 6 的发行版创建启动脚本。
- en: Tip
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Although the bootstrap location requires a password, there is no encryption
    since we haven't configured SSL on our server. Without encryption, the location
    is not very safe.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 bootstrap 位置需要密码保护，但由于我们没有在服务器上配置 SSL，因此没有加密。没有加密的话，这个位置并不太安全。
- en: 'Create a script named `el6.sh` in the bootstrap directory with the following
    contents:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在 bootstrap 目录中创建一个名为`el6.sh`的脚本，内容如下：
- en: '[PRE53]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How it works...
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The apache configuration only permits access to the bootstrap directory with
    a username and password combination. We supply these with the `--user` argument
    to curl, thereby getting access to the file. We use a pipe (`|`) to redirect the
    output of curl into bash. This causes bash to execute the script. We write our
    bash script like we would any other bash script. The bash script downloads our
    `bootstrap.pp` manifest and applies it. Finally, we apply the Puppet manifest
    from the Git repository and the machine is configured as a member of our decentralized
    infrastructure.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Apache 配置仅允许使用用户名和密码组合访问 bootstrap 目录。我们通过将`--user`参数传递给 curl 来提供这些信息，从而获得对文件的访问权限。我们使用管道符号（`|`）将
    curl 的输出重定向到 bash，这样 bash 就会执行该脚本。我们像编写任何其他 bash 脚本一样编写我们的 bash 脚本。该脚本下载我们的`bootstrap.pp`清单并应用它。最后，我们从
    Git 仓库应用 Puppet 清单，并将机器配置为我们去中心化基础设施的一部分。
- en: There's more...
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: To support another operating system, we only need to create a new bash script.
    All Linux distributions will support bash scripting, Mac OS X does as well. Since
    we placed much of our logic into the `bootstrap.pp` manifest, the bootstrap script
    is quite minimal and easy to port to new operating systems.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要支持另一个操作系统，我们只需要创建一个新的 bash 脚本。所有的 Linux 发行版都支持 bash 脚本，Mac OS X 也支持。由于我们将大部分逻辑放入了`bootstrap.pp`清单中，因此启动脚本非常简洁，且易于移植到新的操作系统。
- en: Creating a centralized Puppet infrastructure
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个集中式 Puppet 基础设施
- en: A configuration management tool such as Puppet is best used when you have many
    machines to manage. If all the machines can reach a central location, using a
    centralized Puppet infrastructure might be a good solution. Unfortunately, Puppet
    doesn't scale well with a large number of nodes. If your deployment has less than
    800 servers, a single Puppet master should be able to handle the load, assuming
    your catalogs are not complex (take less than 10 seconds to compile each catalog).
    If you have a larger number of nodes, I suggest a load balancing configuration
    described in *Mastering Puppet*, *Thomas Uphill*, *Packt Publishing*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Puppet 这样的配置管理工具在管理大量机器时最为有效。如果所有机器都能连接到一个中心位置，使用集中式的 Puppet 基础设施可能是一个好方案。不幸的是，Puppet
    在节点数量较多时扩展性较差。如果你的部署有不到 800 台服务器，假设你的目录不复杂（每个目录编译时间少于 10 秒），单一的 Puppet 主服务应该能够处理这个负载。如果你的节点数量更大，我建议参考
    *Mastering Puppet* 中描述的负载均衡配置，*Thomas Uphill* 著，*Packt Publishing* 出版。
- en: A Puppet master is a Puppet server that acts as an X509 certificate authority
    for Puppet and distributes catalogs (compiled manifests) to client nodes. Puppet
    ships with a built-in web server called **WEBrick,** which can handle a very small
    number of nodes. In this section, we will see how to use that built-in server
    to control a very small (less than 10) number of nodes.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 主服务是一个 Puppet 服务器，充当 Puppet 的 X509 证书颁发机构，并将编译后的清单（catalogs）分发给客户端节点。Puppet
    配带了一个内置的 Web 服务器 **WEBrick**，可以处理非常少量的节点。在本节中，我们将看到如何使用该内置服务器来控制少量（少于 10）节点。
- en: Getting ready
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The Puppet master process is started by running `puppet master`; most Linux
    distributions have start and stop scripts for the Puppet master in a separate
    package. To get started, we'll create a new debian server named `puppet.example.com`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 主服务进程通过运行 `puppet master` 启动；大多数 Linux 发行版将 Puppet 主服务的启动和停止脚本放在一个单独的包中。为了开始，我们将创建一台名为
    `puppet.example.com` 的新的 Debian 服务器。
- en: How to do it...
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Install Puppet on the new server and then use Puppet to install the Puppet
    master package:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新服务器上安装 Puppet，然后使用 Puppet 来安装 Puppet 主服务包：
- en: '[PRE54]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now start the Puppet master service and ensure it will start at boot:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在启动 Puppet 主服务，并确保它在启动时自动启动：
- en: '[PRE55]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: How it works...
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Puppet master package includes the start and stop scripts for the Puppet
    master service. We use Puppet to install the package and start the service. Once
    the service is started, we can point another node at the Puppet master (you might
    need to disable the host-based firewall on your machine).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 主服务包包括启动和停止 Puppet 主服务的脚本。我们使用 Puppet 来安装这个包并启动服务。一旦服务启动，我们可以将另一个节点指向
    Puppet 主服务（你可能需要禁用机器上的基于主机的防火墙）。
- en: 'From another node, run `puppet agent` to start a `puppet agent`, which will
    contact the server and request a new certificate:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从另一个节点运行 `puppet agent` 启动一个 `puppet agent`，它将联系服务器并请求新的证书：
- en: '[PRE56]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now on the Puppet server, sign the new key:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在 Puppet 服务器上，签署新的密钥：
- en: '[PRE57]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Return to the cookbook node and run Puppet again:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到烹饪书节点，并再次运行 Puppet：
- en: '[PRE58]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: There's more...
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When we ran `puppet agent`, Puppet looked for a host named `puppet.example.com`
    (since our test node is in the `example.com` domain); if it couldn't find that
    host, it would then look for a host named Puppet. We can specify the server to
    contact with the `--server` option to `puppet agent`. When we installed the Puppet
    master package and started the Puppet master service, Puppet created default SSL
    certificates based on our hostname. In the next section, we'll see how to create
    an SSL certificate that has multiple DNS names for our Puppet server.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 `puppet agent` 时，Puppet 会查找名为 `puppet.example.com` 的主机（因为我们的测试节点位于 `example.com`
    域中）；如果找不到该主机，它会继续查找名为 Puppet 的主机。我们可以通过在 `puppet agent` 中使用 `--server` 选项来指定要联系的服务器。当我们安装
    Puppet 主服务包并启动 Puppet 主服务时，Puppet 会根据我们的主机名创建默认的 SSL 证书。在接下来的部分中，我们将看到如何为我们的 Puppet
    服务器创建一个包含多个 DNS 名称的 SSL 证书。
- en: Creating certificates with multiple DNS names
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建包含多个 DNS 名称的证书
- en: By default, Puppet will create an SSL certificate for your Puppet master that
    contains the fully qualified domain name of the server only. Depending on how
    your network is configured, it can be useful for the server to be known by other
    names. In this recipe, we'll make a new certificate for our Puppet master that
    has multiple DNS names.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Puppet 会为你的 Puppet 主服务器创建一个只包含服务器完全限定域名的 SSL 证书。根据你的网络配置，服务器被其他名称识别可能很有用。在本食谱中，我们将为
    Puppet 主服务器创建一个包含多个 DNS 名称的新证书。
- en: Getting ready
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Install the Puppet master package if you haven't already done so. You will then
    need to start the Puppet master service at least once to create a **certificate
    authority** (**CA**).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有安装Puppet主包，请安装它。然后，你需要至少启动一次Puppet主服务以创建**证书颁发机构**（**CA**）。
- en: How to do it...
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The steps are as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤如下：
- en: 'Stop the running Puppet master process with the following command:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令停止正在运行的Puppet主进程：
- en: '[PRE59]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Delete (`clean`) the current server certificate:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除（`clean`）当前的服务器证书：
- en: '[PRE60]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Create a new Puppet certificate using Puppet certificate generate with the
    `--dns-alt-names` option:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`--dns-alt-names`选项通过Puppet证书生成命令创建新的Puppet证书：
- en: '[PRE61]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Sign the new certificate:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 签署新证书：
- en: '[PRE62]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Restart the Puppet master process:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重启Puppet主进程：
- en: '[PRE63]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: How it works...
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When your puppet agents connect to the Puppet server, they look for a host called
    `Puppet`, they then look for a host called `Puppet.[your domain]`. If your clients
    are in different domains, then you need your Puppet master to reply to all the
    names correctly. By removing the existing certificate and generating a new one,
    you can have your Puppet master reply to multiple DNS names.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的Puppet代理连接到Puppet服务器时，它们会查找名为`Puppet`的主机，然后查找名为`Puppet.[你的域名]`的主机。如果你的客户端位于不同的域中，你需要让Puppet主服务器对所有正确的名称做出回应。通过删除现有证书并生成新证书，你可以让Puppet主服务器对多个DNS名称做出响应。
- en: Running Puppet from passenger
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Passenger运行Puppet
- en: The WEBrick server we configured in the previous section is not capable of handling
    a large number of nodes. To deal with a large number of nodes, a scalable web
    server is required. Puppet is a ruby process, so we need a way to run a ruby process
    within a web server. **Passenger** is the solution to this problem. It allows
    us to run the Puppet master process within a web server (apache by default). Many
    distributions ship with a puppetmaster-passenger package that configures this
    for you. In this section, we'll use the package to configure Puppet to run within
    passenger.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一部分配置的WEBrick服务器无法处理大量节点。为了处理大量节点，需要一个可扩展的Web服务器。Puppet是一个Ruby进程，因此我们需要一种在Web服务器中运行Ruby进程的方法。**Passenger**是解决此问题的方案。它允许我们在Web服务器中运行Puppet主进程（默认使用Apache）。许多发行版都提供了一个puppetmaster-passenger软件包，可以为你配置这个功能。在本节中，我们将使用这个软件包来配置Puppet在Passenger中运行。
- en: Getting ready
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Install the puppetmaster-passenger package:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 安装puppetmaster-passenger软件包：
- en: '[PRE64]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using `puppet resource` to install packages ensures the same command will work
    on multiple distributions (provided the package names are the same).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`puppet resource`安装软件包可确保相同的命令在多个发行版上有效（前提是软件包名称相同）。
- en: How to do it...
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The steps are as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤如下：
- en: 'Ensure the Puppet master site is enabled in your apache configuration. Depending
    on your distribution this may be at `/etc/httpd/conf.d` or `/etc/apache2/sites-enabled`.
    The configuration file should be created for you and contain the following information:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保Puppet主站点在你的Apache配置中已启用。根据你的发行版，它可能位于`/etc/httpd/conf.d`或`/etc/apache2/sites-enabled`。配置文件应该已经为你创建，并包含以下信息：
- en: '[PRE65]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'These lines are tuning settings for passenger. The file then instructs apache
    to listen on port 8140, the Puppet master port. Next a `VirtualHost` definition
    is created that loads the Puppet CA certificates and the Puppet master''s certificate:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些行是Passenger的调优设置。然后，文件指示Apache在端口8140上监听，这是Puppet主端口。接着，创建一个`VirtualHost`定义，加载Puppet
    CA证书和Puppet主证书：
- en: '[PRE66]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Tip
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You may have more or less lines of SSL configuration here depending on your
    version of the puppetmaster-passenger package.
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据你所使用的puppetmaster-passenger软件包的版本，这里可能会有更多或更少的SSL配置行。
- en: 'Next, a few important headers are set so that the passenger process has access
    to the SSL information sent by the client node:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，设置几个重要的头信息，以便Passenger进程可以访问客户端节点发送的SSL信息：
- en: '[PRE67]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Finally, the location of the passenger configuration file `config.ru` is given
    with the `DocumentRoot` location as follows:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，给出了Passenger配置文件`config.ru`的位置，以及`DocumentRoot`位置，具体如下：
- en: '[PRE68]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `config.ru` file should exist at `/usr/share/puppet/rack/puppetmasterd/`
    and should have the following content:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`config.ru`文件应位于`/usr/share/puppet/rack/puppetmasterd/`，并应包含以下内容：'
- en: '[PRE69]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'With the passenger apache configuration file in place and the `config.ru` file
    correctly configured, start the apache server and verify that apache is listening
    on the Puppet master port (if you configured the standalone Puppet master previously,
    you must stop that process now using `service puppetmaster stop`):'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置好 passenger apache 配置文件，并正确配置 `config.ru` 文件后，启动 apache 服务器，并验证 apache 是否在
    Puppet master 端口上监听（如果你之前配置了独立的 Puppet master，必须现在停止该进程，使用命令 `service puppetmaster
    stop`）：
- en: '[PRE70]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: How it works...
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The passenger configuration file uses the existing Puppet master certificates
    to listen on port 8140 and handles all the SSL communication between the server
    and the client. Once the certificate information has been dealt with, the connection
    is handed off to a ruby process started from passenger using the command line
    arguments from the `config.ru` file.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: passenger 配置文件使用现有的 Puppet master 证书监听 8140 端口，并处理服务器与客户端之间的所有 SSL 通信。一旦证书信息处理完毕，连接就会被交给一个由
    passenger 启动的 ruby 进程，该进程使用来自 `config.ru` 文件的命令行参数。
- en: 'In this case, the `$0` variable is set to `master` and the arguments variable
    is set to `--rack --confdir /etc/puppet --vardir /var/lib/puppet`; this is equivalent
    to running the following from the command line:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`$0`变量被设置为`master`，而参数变量被设置为`--rack --confdir /etc/puppet --vardir /var/lib/puppet`；这相当于从命令行运行以下内容：
- en: '[PRE71]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: There's more...
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can add additional configuration parameters to the `config.ru` file to
    further alter how Puppet runs when it''s running through passenger. For instance,
    to enable debugging on the passenger Puppet master, add the following line to
    `config.ru` before the run `Puppet::Util::CommandLine.new.execute` line:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向 `config.ru` 文件添加额外的配置参数，以进一步改变 Puppet 在通过 passenger 运行时的行为。例如，要在 passenger
    Puppet master 上启用调试，请在 `config.ru` 文件中的 `Puppet::Util::CommandLine.new.execute`
    之前添加以下行：
- en: '[PRE72]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Setting up the environment
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置环境
- en: Environments in Puppet are directories holding different versions of your Puppet
    manifests. Environments prior to Version 3.6 of Puppet were not a default configuration
    for Puppet. In newer versions of Puppet, environments are configured by default.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 中的环境是包含不同版本 Puppet 清单的目录。在 Puppet 3.6 版本之前，环境并不是 Puppet 的默认配置。在较新版本的
    Puppet 中，环境是默认配置的。
- en: Whenever a node connects to a Puppet master, it informs the Puppet master of
    its environment. By default, all nodes report to the `production` environment.
    This causes the Puppet master to look in the production environment for manifests.
    You may specify an alternate environment with the `--environment` setting when
    running puppet agent or by setting environment `= newenvironment` in `/etc/puppet/puppet.conf`
    in the [agent] section.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一个节点连接到 Puppet master 时，它会通知 Puppet master 它的环境。默认情况下，所有节点都报告到 `production`
    环境。这会导致 Puppet master 在生产环境中查找清单。你可以在运行 puppet agent 时通过 `--environment` 设置指定一个备用环境，或者在
    `/etc/puppet/puppet.conf` 的 [agent] 部分中设置 `environment = newenvironment`。
- en: Getting ready
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Set the `environmentpath` function of your installation by adding a line to
    the `[main]` section of `/etc/puppet/puppet.conf` as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `/etc/puppet/puppet.conf` 的 `[main]` 部分添加以下行，设置你的安装的 `environmentpath` 功能：
- en: '[PRE73]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: How to do it...
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The steps are as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤如下：
- en: 'Create a `production` directory at `/etc/puppet/environments` that contains
    both a `modules` and `manifests` directory. Then create a `site.pp` which creates
    a file in `/tmp` as follows:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/etc/puppet/environments` 下创建一个 `production` 目录，包含 `modules` 和 `manifests`
    目录。然后创建一个 `site.pp` 文件，该文件在 `/tmp` 中创建一个文件，如下所示：
- en: '[PRE74]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Run puppet agent on the master to connect to it and verify that the production
    code was delivered:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主节点上运行 puppet agent 以连接到主节点，并验证生产代码是否已交付：
- en: '[PRE75]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Configure another environment `devel`. Create a new manifest in the `devel`
    environment:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置另一个环境 `devel`。在 `devel` 环境中创建一个新的清单：
- en: '[PRE76]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Apply the new environment by running the `--environment devel` puppet agent
    using the following command:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令，使用 `--environment devel` 选项来应用新环境：
- en: '[PRE77]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Tip
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You may need to restart apache2 to enable your new environment, this depends
    on your version of Puppet and the `environment_timeout` parameter of `puppet.conf`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要重新启动 apache2 才能启用新环境，这取决于你的 Puppet 版本和 `puppet.conf` 中的 `environment_timeout`
    参数。
- en: There's more...
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Each environment can have its own `modulepath` if you create an `environment.conf`
    file within the environment directory. More information on environments can be
    found on the Puppet labs website at [https://docs.puppetlabs.com/puppet/latest/reference/environments.html](https://docs.puppetlabs.com/puppet/latest/reference/environments.html).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 每个环境可以有自己的 `modulepath`，只要在环境目录中创建一个 `environment.conf` 文件。关于环境的更多信息可以在 Puppet
    Labs 网站上找到，链接是 [https://docs.puppetlabs.com/puppet/latest/reference/environments.html](https://docs.puppetlabs.com/puppet/latest/reference/environments.html)。
- en: Configuring PuppetDB
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 PuppetDB
- en: PuppetDB is a database for Puppet that is used to store information about nodes
    connected to a Puppet master. PuppetDB is also a storage area for exported resources.
    Exported resources are resources that are defined on nodes but applied to other
    nodes. The simplest way to install PuppetDB is to use the PuppetDB module from
    Puppet labs. From this point on, we'll assume you are using the `puppet.example.com`
    machine and have a passenger-based configuration of Puppet.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: PuppetDB 是一个用于存储与 Puppet 主服务器连接的节点信息的数据库。PuppetDB 还是导出资源的存储区域。导出资源是指在节点上定义但应用于其他节点的资源。安装
    PuppetDB 的最简单方法是使用 Puppet Labs 提供的 PuppetDB 模块。从这一点开始，我们假设你正在使用 `puppet.example.com`
    机器，并且拥有基于 Passenger 的 Puppet 配置。
- en: Getting ready
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Install the PuppetDB module in the production environment you created in the
    previous recipe. If you didn''t create directory environments, don''t worry, using
    `puppet module install` will install the module to the correct location for your
    installation with the following command:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前步骤中创建的生产环境中安装 PuppetDB 模块。如果你没有创建目录环境，也不用担心，使用 `puppet module install` 将会把模块安装到你的安装目录的正确位置，执行以下命令：
- en: '[PRE78]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: How to do it...
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Now that our Puppet master has the PuppetDB module installed, we need to apply
    the PuppetDB module to our Puppet master, we can do this in the site manifest.
    Add the following to your (production) `site.pp`:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的 Puppet 主服务器已经安装了 PuppetDB 模块，我们需要将 PuppetDB 模块应用到 Puppet 主服务器。我们可以在站点清单中完成此操作。在你的（生产）`site.pp`
    文件中添加以下内容：
- en: '[PRE79]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Run `puppet agent` to apply the `puppetdb` class and the `puppetdb::master::config`
    class:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `puppet agent` 来应用 `puppetdb` 类和 `puppetdb::master::config` 类：
- en: '[PRE80]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: How it works...
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The PuppetDB module is a great example of how a complex configuration task can
    be puppetized. Simply by adding the `puppetdb` class to our Puppet master node,
    Puppet installed and configured `postgresql` and `puppetdb`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: PuppetDB 模块是一个很好的例子，展示了如何将复杂的配置任务自动化。通过将 `puppetdb` 类添加到 Puppet 主节点，Puppet 安装并配置了
    `postgresql` 和 `puppetdb`。
- en: When we called the `puppetdb::master::config` class, we set the `puppet_service_name`
    variable to `apache2`, this is because we are running Puppet through passenger.
    Without this line our agent would try to start the puppetmaster process instead
    of `apache2`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `puppetdb::master::config` 类时，我们将 `puppet_service_name` 变量设置为 `apache2`，这是因为我们通过
    Passenger 运行 Puppet。如果没有这一行，我们的代理会尝试启动 puppetmaster 进程，而不是 `apache2`。
- en: 'The agent then set up the configuration files for PuppetDB and configured Puppet
    to use PuppetDB. If you look at `/etc/puppet/puppet.conf`, you''ll see the following
    two new lines:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 代理接着为 PuppetDB 设置了配置文件，并配置了 Puppet 使用 PuppetDB。如果你查看`/etc/puppet/puppet.conf`，你会看到以下两行新的配置：
- en: '[PRE81]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: There's more...
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'Now that PuppetDB is configured and we''ve had a successful agent run, PuppetDB
    will have data we can query:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 PuppetDB 已经配置完毕，并且我们成功运行了代理，PuppetDB 将会有我们可以查询的数据：
- en: '[PRE82]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Configuring Hiera
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Hiera
- en: '**Hiera** is an information repository for Puppet. Using Hiera you can have
    a hierarchical categorization of data about your nodes that is maintained outside
    of your manifests. This is very useful for sharing code and dealing with exceptions
    that will creep into any Puppet deployment.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**Hiera** 是 Puppet 的信息仓库。使用 Hiera，你可以对关于节点的数据进行分层分类，这些数据保存在清单之外。这对于共享代码和处理任何
    Puppet 部署中不可避免的例外情况非常有用。'
- en: Getting ready
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Hiera should have already been installed as a dependency on your Puppet master.
    If it has not already, install it using Puppet:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Hiera 应该已经作为 Puppet 主服务器的依赖项安装。如果还没有安装，可以通过 Puppet 来安装它：
- en: '[PRE83]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: How to do it...
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Hiera is configured from a yaml file, `/etc/puppet/hiera.yaml`. Create the
    file and add the following as a minimal configuration:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Hiera 是通过一个 yaml 文件 `/etc/puppet/hiera.yaml` 进行配置的。创建该文件，并添加以下内容作为最小配置：
- en: '[PRE84]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Create the `common.yaml` file referenced in the hierarchy:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建在层次结构中引用的 `common.yaml` 文件：
- en: '[PRE85]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Edit the `site.pp` file and add a notify resource based on the Hiera value:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `site.pp` 文件并基于 Hiera 值添加一个通知资源：
- en: '[PRE86]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Apply the manifest to a test node:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将清单应用于测试节点：
- en: '[PRE87]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: How it works...
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Hiera uses a hierarchy to search through a set of yaml files to find the appropriate
    values. We defined this hierarchy in `hiera.yaml` with the single entry for `common.yaml`.
    We used the `hiera` function in `site.pp` to lookup the value for message and
    store that value in the variable `$message`. The values used for the definition
    of the hierarchy can be any facter facts defined about the system. A common hierarchy
    is shown as:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: Hiera 使用层次结构搜索一组 yaml 文件，以找到合适的值。我们在 `hiera.yaml` 中定义了这个层次结构，并且只包含了 `common.yaml`
    的条目。我们在 `site.pp` 中使用了 `hiera` 函数来查找消息的值并将其存储在变量 `$message` 中。用于定义层次结构的值可以是系统上定义的任何
    facter 数据。常见的层次结构示例如下：
- en: '[PRE88]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: There's more...
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Hiera can be used for automatic parameter lookup with parameterized classes.
    For example, if you have a class named `cookbook::example` with a parameter named
    `publisher`, you can include the following in a Hiera yaml file to automatically
    set this parameter:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: Hiera 可以用于带有参数化类的自动参数查找。例如，如果你有一个名为 `cookbook::example` 的类，其中有一个名为 `publisher`
    的参数，你可以在 Hiera 的 yaml 文件中加入以下内容来自动设置这个参数：
- en: '[PRE89]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Another often used fact is `environment` you may reference the `environment`
    of the client node using `%{environment}` as shown in the following hierarchy:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常用的 fact 是 `environment`，你可以通过 `%{environment}` 引用客户端节点的 `environment`，如下所示的层次结构：
- en: '[PRE90]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Tip
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A good rule of thumb is to limit the hierarchy to 8 levels or less. Keep in
    mind that each time a parameter is searched with Hiera, all the levels are searched
    until a match is found.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的经验法则是将层次结构限制为 8 层或更少。请记住，每次使用 Hiera 搜索参数时，所有层次都会被搜索，直到找到匹配项。
- en: The default Hiera function returns the first match to the search key, you can
    also use `hiera_array` and `hiera_hash` to search and return all values stored
    in Hiera.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 Hiera 函数返回与搜索键匹配的第一个结果，你还可以使用 `hiera_array` 和 `hiera_hash` 来搜索并返回 Hiera
    中存储的所有值。
- en: 'Hiera can also be searched from the command line as shown in the following
    command line (note that currently the command line Hiera utility uses `/etc/hiera.yaml`
    as its configuration file whereas the Puppet master uses `/etc/puppet/hiera.yaml`):'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: Hiera 也可以从命令行进行搜索，如以下命令所示（请注意，目前命令行的 Hiera 工具使用 `/etc/hiera.yaml` 作为其配置文件，而
    Puppet 主控使用 `/etc/puppet/hiera.yaml`）：
- en: '[PRE91]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Note
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information, consult the Puppet labs website at [https://docs.puppetlabs.com/hiera/1/](https://docs.puppetlabs.com/hiera/1/).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请参阅 Puppet labs 网站 [https://docs.puppetlabs.com/hiera/1/](https://docs.puppetlabs.com/hiera/1/)。
- en: Setting node-specific data with Hiera
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Hiera 设置特定节点数据
- en: In our hierarchy defined in `hiera.yaml`, we created an entry based on the hostname
    fact; in this section, we'll create yaml files in the `hosts` subdirectory of
    Hiera data with information specific to a particular host.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们在 `hiera.yaml` 中定义的层次结构中，我们基于主机名 fact 创建了一个条目；在本节中，我们将在 Hiera 数据的 `hosts`
    子目录中创建 yaml 文件，其中包含特定主机的信息。
- en: Getting ready
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Install and configure Hiera as in the last section and use the hierarchy defined
    in the previous recipe that includes a `hosts/%{hostname}` entry.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 按照上一节的步骤安装并配置 Hiera，并使用前面配方中定义的层次结构，该层次结构包括一个 `hosts/%{hostname}` 条目。
- en: How to do it...
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following are the steps:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是步骤：
- en: Create a file at `/etc/puppet/hieradata/hosts` that is the hostname of your
    test node. For example if your host is named `cookbook-test`, then the file would
    be named `cookbook-test.yaml`.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/etc/puppet/hieradata/hosts` 创建一个文件，该文件的名称与测试节点的主机名相同。例如，如果主机名为 `cookbook-test`，则文件应命名为
    `cookbook-test.yaml`。
- en: 'Insert a specific message in this file:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件中插入特定消息：
- en: '[PRE92]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Run Puppet on two different test nodes to note the difference:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个不同的测试节点上运行 Puppet，以注意其中的差异：
- en: '[PRE93]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: How it works...
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Hiera searches the hierarchy for files that match the values returned by facter.
    In this case, the `cookbook-test.yaml` file is found by substituting the hostname
    of the node into the search path `/etc/puppet/hieradata/hosts/%{hostname}.yaml`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: Hiera 会在层次结构中搜索与 facter 返回的值匹配的文件。在此情况下，通过将节点的主机名替换到搜索路径`/etc/puppet/hieradata/hosts/%{hostname}.yaml`中，找到了
    `cookbook-test.yaml` 文件。
- en: Using Hiera, it is possible to greatly reduce the complexity of your Puppet
    code. We will use `yaml` files for separate values, where previously you had large
    `case` statements or nested `if` statements.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Hiera，可以大大减少 Puppet 代码的复杂性。我们将使用 `yaml` 文件来存储分开的值，而不再需要像以前那样写大型的 `case` 语句或嵌套的
    `if` 语句。
- en: Storing secret data with hiera-gpg
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 hiera-gpg 存储机密数据
- en: If you're using Hiera to store your configuration data, there's a gem available
    called **hiera-gpg** that adds an encryption backend to Hiera to allow you to
    protect values stored in Hiera.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Hiera存储配置数据，可以使用名为**hiera-gpg**的gem，它为Hiera添加了一个加密后端，允许您保护存储在Hiera中的值。
- en: Getting ready
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To set up hiera-gpg, follow these steps:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 设置hiera-gpg，请按照以下步骤操作：
- en: 'Install the `ruby-dev` package; it will be required to build the `hiera-gpg`
    gem as follows:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`ruby-dev`软件包；它将用于构建`hiera-gpg` gem，如下所示：
- en: '[PRE94]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Install the `hiera-gpg` gem using the gem provider:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用gem提供程序安装`hiera-gpg` gem：
- en: '[PRE95]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Modify your `hiera.yaml` file as follows:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式修改`hiera.yaml`文件：
- en: '[PRE96]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: How to do it...
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this example, we''ll create a piece of encrypted data and retrieve it using
    `hiera-gpg` as follows:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将创建一段加密数据，并使用`hiera-gpg`按如下方式检索它：
- en: 'Create the `secret.yaml` file at `/etc/puppet/secret` with the following contents:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/etc/puppet/secret`处创建`secret.yaml`文件，内容如下：
- en: '[PRE97]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: If you don't already have a GnuPG encryption key, follow the steps in the *Using
    GnuPG to encrypt secrets* recipe in [Chapter 4](ch04.html "Chapter 4. Working
    with Files and Packages"), *Working with Files and Packages*.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有GnuPG加密密钥，请按照[第4章](ch04.html "第4章：与文件和软件包一起工作")中*使用GnuPG加密机密*的步骤进行操作，*与文件和软件包一起工作*。
- en: 'Encrypt the `secret.yaml` file to this key using the following command (replace
    the `puppet@puppet.example.com` with the e-mail address you specified when creating
    the key). This will create the `secret.gpg` file:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令将`secret.yaml`文件加密为此密钥（将`puppet@puppet.example.com`替换为您在创建密钥时指定的电子邮件地址）。这将生成`secret.gpg`文件：
- en: '[PRE98]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Remove the plaintext `secret.yaml` file:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除明文的`secret.yaml`文件：
- en: '[PRE99]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Modify your default node in the `site.pp` file as follows:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式修改`site.pp`文件中的默认节点：
- en: '[PRE100]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Now run Puppet on a node:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在节点上运行Puppet：
- en: '[PRE101]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: How it works...
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you install `hiera-gpg`, it adds to Hiera, the ability to decrypt `.gpg`
    files. So you can put any secret data into a `.yaml` file that you then encrypt
    to the appropriate key with GnuPG. Only machines that have the right secret key
    will be able to access this data.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`hiera-gpg`时，它为Hiera添加了解密`.gpg`文件的功能。因此，您可以将任何机密数据放入`.yaml`文件中，然后使用GnuPG将其加密到相应的密钥。只有拥有正确密钥的机器才能访问这些数据。
- en: For example, you might encrypt the MySQL root password using `hiera-gpg` and
    install the corresponding key only on your database servers. Although other machines
    may also have a copy of the `secret.gpg` file, it's not readable to them unless
    they have the decryption key.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以使用`hiera-gpg`加密MySQL root密码，并仅在数据库服务器上安装相应的密钥。尽管其他机器可能也有`secret.gpg`文件的副本，但除非它们拥有解密密钥，否则无法读取此文件。
- en: There's more...
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: You might also like to know about `hiera-eyaml`, another secret-data backend
    for Hiera that supports encryption of individual values within a Hiera data file.
    This could be handy if you need to mix encrypted and unencrypted facts within
    a single file. Find out more about hiera-eyaml at [https://github.com/TomPoulton/hiera-eyaml](https://github.com/TomPoulton/hiera-eyaml).
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还想了解`hiera-eyaml`，这是另一个Hiera的秘密数据后端，它支持加密Hiera数据文件中的单个值。如果您需要在单个文件中混合加密和未加密的事实数据，这将非常有用。了解更多关于hiera-eyaml的信息，请访问[https://github.com/TomPoulton/hiera-eyaml](https://github.com/TomPoulton/hiera-eyaml)。
- en: See also
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Using GnuPG to encrypt secrets* recipe in [Chapter 4](ch04.html "Chapter 4. Working
    with Files and Packages"), *Working with Files and Packages*.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第4章](ch04.html "第4章：与文件和软件包一起工作")中*使用GnuPG加密机密*的步骤，*与文件和软件包一起工作*。'
- en: Using MessagePack serialization
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MessagePack序列化
- en: Running Puppet in a centralized architecture creates a lot of traffic between
    nodes. The bulk of this traffic is JSON and yaml data. An experimental feature
    of the latest releases of Puppet allow for the serialization of this data using
    **MessagePack** (**msgpack**).
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在集中式架构中运行Puppet会在节点之间产生大量流量。大部分流量是JSON和yaml数据。Puppet最新版本的实验性功能允许使用**MessagePack**（**msgpack**）对这些数据进行序列化。
- en: Getting ready
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Install the msgpack gem onto your Puppet master and your nodes. Use Puppet
    to do the work for you with Puppet resource. You may need to install the `ruby-dev`
    or `ruby-devel` package on your nodes/server at this point:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 将msgpack gem安装到您的Puppet主节点和节点上。使用Puppet资源让Puppet为您完成这项工作。此时，您可能需要在节点/服务器上安装`ruby-dev`或`ruby-devel`软件包：
- en: '[PRE102]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: How to do it...
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Set the `preferred_serialization_format` to `msgpack` in the `[agent]` section
    of your nodes `puppet.conf` file:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在节点`puppet.conf`文件的`[agent]`部分，将`preferred_serialization_format`设置为`msgpack`：
- en: '[PRE103]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: How it works...
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The master will be sent this option when the node begins communicating with
    the master. Any classes that support serialization with `msgpack` will be transmitted
    with `msgpack.Serialization` of the data between nodes and the master will in
    theory increase the speed at which nodes communicate by optimizing the data that
    is travelling between them. This feature is still experimental.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 当节点开始与主机通信时，主机会收到此选项。任何支持与 `msgpack` 进行序列化的类将通过节点与主机之间的 `msgpack.Serialization`
    数据传输。理论上，这会通过优化传输的数据，提高节点之间的通信速度。此功能仍在实验阶段。
- en: Automatic syntax checking with Git hooks
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Git 钩子进行自动语法检查
- en: 'It would be nice if we knew there was a syntax error in the manifest before
    we even committed it. You can have Puppet check the manifest using the `puppet
    parser validate` command:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够在提交之前就知道清单中是否有语法错误，那该多好。你可以使用 `puppet parser validate` 命令让 Puppet 检查清单的语法：
- en: '[PRE104]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: This is especially useful because a mistake anywhere in the manifest will stop
    Puppet from running on any node, even on nodes that don't use that particular
    part of the manifest. So checking in a bad manifest can cause Puppet to stop applying
    updates to production for some time, until the problem is discovered, and this
    could potentially have serious consequences. The best way to avoid this is to
    automate the syntax check, by using a precommit hook in your version control repo.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 这尤其有用，因为清单中的任何错误都会导致 Puppet 在任何节点上停止运行，即使是那些没有使用该部分清单的节点也是如此。因此，提交一个有问题的清单可能会导致
    Puppet 停止向生产环境应用更新，直到问题被发现，而这可能会带来严重后果。避免这种情况的最佳方法是通过在版本控制仓库中使用预提交钩子（precommit
    hook）来自动化语法检查。
- en: How to do it...
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these steps:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'In your Puppet repo, create a new `hooks` directory:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Puppet 仓库中创建一个新的 `hooks` 目录：
- en: '[PRE105]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Create the file `hooks/check_syntax.sh` with the following contents (based
    on a script by Puppet Labs):'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文件`hooks/check_syntax.sh`，内容如下（基于 Puppet Labs 的脚本）：
- en: '[PRE106]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Set execute permission for the `hook` script with the following command:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令为`hook`脚本设置执行权限：
- en: '[PRE107]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Now either symlink or copy the script to the precommit hook in your hooks directory.
    If your Git repo is checked out in `~/puppet`, then create the symlink at `~/puppet/hooks/pre-commit`
    as follows:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将脚本通过符号链接或复制到 hooks 目录中的预提交钩子（precommit hook）中。如果你的 Git 仓库在 `~/puppet` 目录下，则按以下方式在
    `~/puppet/hooks/pre-commit` 创建符号链接：
- en: '[PRE108]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: How it works...
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The `check_syntax.sh` script will prevent you from committing any files with
    syntax errors when it is used as the pre-commit hook for Git:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `check_syntax.sh` 脚本作为 Git 的预提交钩子使用时，它将防止你提交任何包含语法错误的文件：
- en: '[PRE109]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: If you add the `hooks` directory to your Git repo, anyone who has a checkout
    can copy the script into their local `hooks` directory to get this syntax checking
    behavior.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将 `hooks` 目录添加到 Git 仓库中，任何有仓库检出的用户都可以将脚本复制到本地的 `hooks` 目录，以获得此语法检查功能。
- en: Pushing code around with Git
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Git 推送代码
- en: As we have already seen in the decentralized model, Git can be used to transfer
    files between machines using a combination of `ssh` and `ssh` keys. It can also
    be useful to have a Git hook do the same on each successful commit to the repository.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在去中心化模型中看到的，Git 可以通过结合使用 `ssh` 和 `ssh` 密钥在机器之间传输文件。让 Git 钩子在每次成功提交到仓库时执行相同的操作也是有用的。
- en: There exists a hook called post-commit that can be run after a successful commit
    to the repository. In this recipe, we'll create a hook that updates the code on
    our Puppet master with code from our Git repository on the Git server.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个叫做 post-commit 的钩子，可以在成功提交到仓库后运行。在本配方中，我们将创建一个钩子，用于将代码从 Git 服务器上的 Git 仓库更新到
    Puppet 主机上的代码。
- en: Getting ready
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Follow these steps to get started:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤开始：
- en: 'Create an `ssh` key that can access your Puppet user on your Puppet master
    and install this key into the Git user''s account on `git.example.com`:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `ssh` 密钥，使其能够访问 Puppet 主机上的 Puppet 用户，并将该密钥安装到 `git.example.com` 上 Git
    用户的帐户中：
- en: '[PRE110]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Modify the Puppet account to allow the Git user to log in as follows:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 Puppet 帐号以允许 Git 用户按以下方式登录：
- en: '[PRE111]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: How to do it...
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Perform the following steps:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Now that the Git user can log in to the Puppet master as the Puppet user, modify
    the Git user''s `ssh` configuration to use the newly created `ssh` key by default:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在 Git 用户可以作为 Puppet 用户登录到 Puppet 主机，修改 Git 用户的 `ssh` 配置，使其默认使用新创建的 `ssh` 密钥：
- en: '[PRE112]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Add the Puppet master as a remote location for the Puppet repository on the
    Git server with the following command:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令将 Puppet 主机添加为 Git 服务器上的 Puppet 仓库的远程位置：
- en: '[PRE113]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'On the Puppet master, move the `production` directory out of the way and check
    out your Puppet repository:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Puppet 主服务器上，将 `production` 目录移开，并检出你的 Puppet 仓库：
- en: '[PRE114]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Now we have a local bare repository on the Puppet server that we can push to,
    to remotely clone this into the `production` directory:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们在 Puppet 服务器上有一个本地裸仓库，可以将其推送，并将其远程克隆到 `production` 目录：
- en: '[PRE115]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Now perform a Git push from the Git server to the Puppet master:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在从 Git 服务器执行 Git 推送到 Puppet 主服务器：
- en: '[PRE116]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Create a post-commit file in the `hooks` directory of the repository on the
    Git server with the following contents:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Git 服务器上的仓库的 `hooks` 目录中创建一个 post-commit 文件，内容如下：
- en: '[PRE117]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Commit a change to the repository from your laptop and verify that the change
    is propagated to the Puppet master as follows:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的笔记本提交一个更改到仓库，并验证该更改是否传播到 Puppet 主服务器，步骤如下：
- en: '[PRE118]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: How it works...
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We created a bare repository on the Puppet master that we then use as a remote
    for the repository on `git.example.com` (remote repositories must be bare). We
    then clone that bare repository into the `production` directory. We add the bare
    repository on `puppet.example.com` as a remote to the bare repository on `git.example.com`.
    We then create a post-receive hook in the repository on `git.example.com`.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Puppet 主服务器上创建了一个裸仓库，然后将其作为 `git.example.com` 上仓库的远程。然后我们将该裸仓库克隆到 `production`
    目录中。我们将 `puppet.example.com` 上的裸仓库添加为 `git.example.com` 上裸仓库的远程。接着，我们在 `git.example.com`
    上的仓库中创建一个 post-receive 钩子。
- en: The hook issues a Git push to the Puppet master bare repository. We then update
    the `production` directory from the updated bare repository on the Puppet master.
    In the next section, we'll modify the hook to use branches.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子对 Puppet 主服务器上的裸仓库执行 Git 推送。然后，我们从 Puppet 主服务器上的更新的裸仓库更新 `production` 目录。在下一节中，我们将修改钩子以使用分支。
- en: Managing Environments with Git
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Git 管理环境
- en: Branches are a way of keeping several different tracks of development within
    a single source repository. Puppet environments are a lot like Git branches. You
    can have the same code with slight variations between branches, just as you can
    have different modules for different environments. In this section, we'll show
    how to use Git branches to define environments on the Puppet master.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 分支是一种在单个源代码仓库中保持多个开发轨迹的方法。Puppet 环境与 Git 分支非常相似。你可以在不同的分支之间拥有相同的代码，并且稍有不同，就像你可以为不同的环境创建不同的模块一样。在本节中，我们将展示如何使用
    Git 分支在 Puppet 主服务器上定义环境。
- en: Getting ready
  id: totrans-455
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In the previous section, we created a `production` directory that was based
    on the master branch; we''ll remove that directory now:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们创建了一个基于主分支的 `production` 目录；现在我们将删除该目录：
- en: '[PRE119]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: How to do it...
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Modify the `post-receive` hook to accept a branch variable. The hook will use
    this variable to create a directory on the Puppet master as follows:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 `post-receive` 钩子以接受分支变量。该钩子将使用此变量在 Puppet 主服务器上创建一个目录，步骤如下：
- en: '[PRE120]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Modify your `README` file again and push to the repository on `git.example.com`:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 再次修改你的 `README` 文件，并推送到 `git.example.com` 上的仓库：
- en: '[PRE121]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: How it works...
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The hook now reads in the `refname` and parses out the branch that is being
    updated. We use that branch variable to clone the repository into a new directory
    and check out the branch.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 这个钩子现在读取 `refname` 并解析出正在更新的分支。我们使用这个分支变量将仓库克隆到一个新的目录，并检出该分支。
- en: There's more...
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Now when we want to create a new environment, we can create a new branch in
    the Git repository. The branch will create a directory on the Puppet master. Each
    branch of the Git repository represents an environment on the Puppet master:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们想创建一个新环境时，可以在 Git 仓库中创建一个新分支。这个分支将在 Puppet 主服务器上创建一个目录。Git 仓库的每个分支都代表
    Puppet 主服务器上的一个环境：
- en: 'Create the production branch as shown in the following command line:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下命令行创建 `production` 分支：
- en: '[PRE122]'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Update the production branch and push to the Git server as follows:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `production` 分支并推送到 Git 服务器，步骤如下：
- en: '[PRE123]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Now whenever we create a new branch, a corresponding directory is created in
    our environment's directory. A one-to-one mapping is established between environments
    and branches.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当我们创建一个新分支时，环境目录中将创建一个对应的目录。环境和分支之间建立了一对一的映射关系。
