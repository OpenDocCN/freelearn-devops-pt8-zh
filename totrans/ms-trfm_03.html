<html><head></head><body>
<div id="_idContainer035">
<h1 class="chapter-number" id="_idParaDest-71"><a id="_idTextAnchor185"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-72"><a id="_idTextAnchor186"/><span class="koboSpan" id="kobo.2.1">Harnessing HashiCorp Utility Providers</span></h1>
<p><span class="koboSpan" id="kobo.3.1">As we discussed in the first chapter, when we learned about Terraform’s architecture, Terraform was designed to be extensible. </span><span class="koboSpan" id="kobo.3.2">In the previous chapter, we spent a lot of time looking at the </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">HashiCorp Configuration Language</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">HCL</span></strong><span class="koboSpan" id="kobo.7.1">), which provides many tools that we can use to help us define our </span><strong class="bold"><span class="koboSpan" id="kobo.8.1">infrastructure as code</span></strong><span class="koboSpan" id="kobo.9.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.10.1">IaC</span></strong><span class="koboSpan" id="kobo.11.1">). </span><span class="koboSpan" id="kobo.11.2">However, these language devices are not always sufficient. </span><span class="koboSpan" id="kobo.11.3">That is why HashiCorp has built a set of utility providers that provide a kind of base class library, or a set of reusable features that are helpful to specific scenarios, no matter what cloud platforms you are using to build your </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">IaC solutions.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">This chapter covers the </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.15.1">Working </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">with reality</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Adaptation </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">and integration</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.19.1">Filesystem</span></span></li>
<li><span class="koboSpan" id="kobo.20.1">Operating system </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">and networking</span></span></li>
</ul>
<h1 id="_idParaDest-73"><a id="_idTextAnchor187"/><span class="koboSpan" id="kobo.22.1">Working with reality</span></h1>
<p><span class="koboSpan" id="kobo.23.1">When building our architecture with IaC, the product is not the code but living and breathing environments. </span><span class="koboSpan" id="kobo.23.2">While the code lives in the abstract realms of our minds, these environments operate within the real world, and just like how our best-laid plans get smashed by reality—so do </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">our environments.</span></span></p>
<p><span class="koboSpan" id="kobo.25.1">Therefore, we need some tools to prepare our environments to meet and come to grips with reality. </span><span class="koboSpan" id="kobo.25.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.26.1">random</span></strong><span class="koboSpan" id="kobo.27.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.28.1">time</span></strong><span class="koboSpan" id="kobo.29.1"> providers allow us to avoid conflicts between our resources and our environments—whether it’s the name of something or when something expires. </span><span class="koboSpan" id="kobo.29.2">These are all critical elements of our solution design that can make or break our architecture when it encounters the </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">real world.</span></span></p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor188"/><span class="koboSpan" id="kobo.31.1">Randomizing</span></h2>
<p><span class="koboSpan" id="kobo.32.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">random</span></strong><span class="koboSpan" id="kobo.34.1"> provider offers several</span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.35.1"> ways to add randomness to your Terraform solution. </span><span class="koboSpan" id="kobo.35.2">Each </span><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">random</span></strong><span class="koboSpan" id="kobo.37.1"> resource type may generate different types of random values and have other attributes to control the output. </span><span class="koboSpan" id="kobo.37.2">Still, all of them—with only a couple of exceptions—generate the random value through a single output called </span><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">result</span></strong><span class="koboSpan" id="kobo.39.1">. </span><span class="koboSpan" id="kobo.39.2">They also all have at least one attribute called </span><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">keepers</span></strong><span class="koboSpan" id="kobo.41.1">, which triggers Terraform to recreate the resource. </span><span class="koboSpan" id="kobo.41.2">This attribute can be helpful to set when you have transient resources that get replaced often, and you need to ensure there are no name conflicts when destroying and recreating </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">the resource.</span></span><a id="_idTextAnchor189"/></p>
<h3><span class="koboSpan" id="kobo.43.1">Random strings</span></h3>
<p><span class="koboSpan" id="kobo.44.1">Generating </span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.45.1">random strings can be a great way to guarantee uniqueness across deployments, especially in situations where you are dynamically generating short-lived environments. </span><span class="koboSpan" id="kobo.45.2">Depending on the case, there are two ways to generate strings—one for non-sensitive data, such as resource names, and another for sensitive data, such as access keys </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">and passwords.</span></span></p>
<p><span class="koboSpan" id="kobo.47.1">Generating non-sensitive dynamic names can be done using </span><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">random_string</span></strong><span class="koboSpan" id="kobo.49.1">. </span><span class="koboSpan" id="kobo.49.2">At the same time, </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">random_password</span></strong><span class="koboSpan" id="kobo.51.1"> can create sensitive values you should protect from leakage by marking them as sensitive if you output them and by securing your state, since Terraform will store the resulting value </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">in state:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.53.1">
    resource "random_string" "name_suffix" {
      length           = 6
      special          = true
      override_special = "/@£$"
    }</span></pre> <p><span class="koboSpan" id="kobo.54.1">The preceding code generates a random string that can generate unique resource names within projects. </span><span class="koboSpan" id="kobo.54.2">Using short random strings to embed within the names of your resources is a great strategy when working with resources with minimal name length constraints, as it can be challenging to create a coherent naming convention across all your resources when one or two of the resources require abnormally small name lengths. </span><span class="koboSpan" id="kobo.54.3">This situation is common when resources need to have globally unique names, such as S3 buckets or Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">Storage accounts:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.56.1">
    locals {
      resource_name = "foobar${random_string.name_suffix.result}"
    }</span></pre> <p><span class="koboSpan" id="kobo.57.1">When you </span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.58.1">couple a random name suffix with part of your naming convention, you can still have a relatively rational </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">resource name:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.60.1">
    resource "random_password" "database" {
      length           = 16
      special          = true
      override_special = "!#$%&amp;*()-_=+[]{}&lt;&gt;:?"
</span><span class="koboSpan" id="kobo.60.2">    }</span></pre> <h4><span class="koboSpan" id="kobo.61.1">Unique identifiers</span></h4>
<p><span class="koboSpan" id="kobo.62.1">You</span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.63.1"> can also generate a </span><strong class="bold"><span class="koboSpan" id="kobo.64.1">Universally Unique Identifier</span></strong><span class="koboSpan" id="kobo.65.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.66.1">UUID</span></strong><span class="koboSpan" id="kobo.67.1">), also</span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.68.1"> known as a </span><strong class="bold"><span class="koboSpan" id="kobo.69.1">Globally Unique Identifier</span></strong><span class="koboSpan" id="kobo.70.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.71.1">GUID</span></strong><span class="koboSpan" id="kobo.72.1">), using </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">random_uuid</span></strong><span class="koboSpan" id="kobo.74.1">. </span><span class="koboSpan" id="kobo.74.2">This can be helpful when your resource supports</span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.75.1"> very long names, as these non-case-sensitive, alphanumeric values take the following format: </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">00000000-0000-0000-0000-000000000000</span></strong><span class="koboSpan" id="kobo.77.1">. </span><span class="koboSpan" id="kobo.77.2">You might need this to generate a unique correlation identifier to link resources within your deployments using a </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">common</span><a id="_idTextAnchor190"/><span class="koboSpan" id="kobo.79.1"> tag.</span></span></p>
<h4><span class="koboSpan" id="kobo.80.1">Just for fun</span></h4>
<p><span class="koboSpan" id="kobo.81.1">There is also a fun little resource</span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.82.1"> called </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">random_pet</span></strong><span class="koboSpan" id="kobo.84.1">, with a nod to the age-old jest of </span><em class="italic"><span class="koboSpan" id="kobo.85.1">pets versus cattle</span></em><span class="koboSpan" id="kobo.86.1">, where you can generate pet names. </span><span class="koboSpan" id="kobo.86.2">This resource is probably not useful for production but can be helpful in development or lab environments where you can be more creative with resource names. </span><span class="koboSpan" id="kobo.86.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">random_pet</span></strong><span class="koboSpan" id="kobo.88.1"> resource’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">id</span></strong><span class="koboSpan" id="kobo.90.1"> output will generate names with an adjective-noun format. </span><span class="koboSpan" id="kobo.90.2">Here are some sample values I came up with using the sample included in this chapter of </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">the book:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">notable-coyote</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">quiet-parakeet</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">pure-woodcock</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">healthy-monkey</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">mint-foal</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">pet-serval</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">ideal-lab</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">special-urchin</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.100.1">You can see that almost all of them don’t make much sense, but some can </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">be </span><a id="_idTextAnchor191"/><span class="koboSpan" id="kobo.102.1">funny.</span></span></p>
<h3><span class="koboSpan" id="kobo.103.1">Random numbers</span></h3>
<p><span class="koboSpan" id="kobo.104.1">Generating</span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.105.1"> random numbers can also help generate random names or generate a random index from an array. </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">random_integer</span></strong><span class="koboSpan" id="kobo.107.1"> offers a simple solution that allows you to pick a number between specified </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">min</span></strong><span class="koboSpan" id="kobo.109.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">max</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.111.1"> values.</span></span></p>
<p><span class="koboSpan" id="kobo.112.1">Consider the following array of AWS </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">availability zones:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.114.1">
    locals {
      azs = [
        "us-west-1a",
        "us-west-1c",
        "us-west-1d",
        "us-west-1e"
      ]
    }</span></pre> <p><span class="koboSpan" id="kobo.115.1">If we wanted to pick a random availability zone from this </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">list</span></strong><span class="koboSpan" id="kobo.117.1">, we could use </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">random_integer</span></strong><span class="koboSpan" id="kobo.119.1"> to generate a random index </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">from it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.121.1">
    resource "random_integer" "az" {
      min = 0
      max = length(local.azs) – 1
    }</span></pre> <p><span class="koboSpan" id="kobo.122.1">The </span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.123.1">preceding code would allow us to generate a random integer between </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">0</span></strong><span class="koboSpan" id="kobo.125.1"> and the length of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">list</span></strong><span class="koboSpan" id="kobo.127.1"> minus </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">1</span></strong><span class="koboSpan" id="kobo.129.1">, which would be </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">4 - 1 = 3</span></strong><span class="koboSpan" id="kobo.131.1">. </span><span class="koboSpan" id="kobo.131.2">Therefore, we would randomly generate either </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">0</span></strong><span class="koboSpan" id="kobo.133.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">1</span></strong><span class="koboSpan" id="kobo.135.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">2</span></strong><span class="koboSpan" id="kobo.137.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.141.1">We can access the random availability zone using the </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.143.1">
    locals {
      selected_az = local.azs[random_integer.az.result]
    }</span></pre> <p><span class="koboSpan" id="kobo.144.1">Finally, we could use the availability zone name to configure our </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">AWS resources:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.146.1">
    resource "aws_elb" "foo" {
      availability_zones = [local.selected_az]
      # ... </span><span class="koboSpan" id="kobo.146.2">and other aws_elb arguments .</span><a id="_idTextAnchor192"/><span class="koboSpan" id="kobo.147.1">..
</span><span class="koboSpan" id="kobo.147.2">    }</span></pre> <h4><span class="koboSpan" id="kobo.148.1">Beyond simple integers</span></h4>
<p><span class="koboSpan" id="kobo.149.1">When simple</span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.150.1"> integers aren’t enough, you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">random_id</span></strong><span class="koboSpan" id="kobo.152.1"> to generate more sophisticated outputs. </span><span class="koboSpan" id="kobo.152.2">The only input is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">byte_length</span></strong><span class="koboSpan" id="kobo.154.1"> to control how large the random number generated can be. </span><span class="koboSpan" id="kobo.154.2">This resource differs from other </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">random</span></strong><span class="koboSpan" id="kobo.156.1"> providers’ resources as it does not have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">result</span></strong><span class="koboSpan" id="kobo.158.1"> output, but has several others that present the random number in various formats, including decimal, hexadecimal, </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">and Base64:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.160.1">
    resource "random_id" "foo" {
      byte_length = 8
    }</span></pre> <p><span class="koboSpan" id="kobo.161.1">The preceding code generates a random number with a length of 8 bytes. </span><span class="koboSpan" id="kobo.161.2">Examples of the output values of the different </span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.162.1">formats are listed </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">as follows:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.164.1">ID</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">IpVgeF7uUY0</span></strong></span></li>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.167.1">Decimal</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">2492004038924456333</span></strong></span></li>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.170.1">Hex</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">229560785eee518d</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.173.1">Base64 </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.174.1">standard</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">IpVgeF7uUY0=</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.177.1">Base64 URL</span></strong><span class="koboSpan" id="kobo.178.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">= </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">IpVgeF7uUY0</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.181.1">Again, depending on your naming conventions, this can be useful for creating names or tags that uniquely identify </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">your </span><a id="_idTextAnchor193"/><span class="koboSpan" id="kobo.183.1">resources.</span></span></p>
<h3><span class="koboSpan" id="kobo.184.1">Shuffle</span></h3>
<p><span class="koboSpan" id="kobo.185.1">Using the</span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.186.1"> previous example, when selecting availability zones from a list, we would have to generate various </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">random_integer</span></strong><span class="koboSpan" id="kobo.188.1"> resources if we wanted to select multiple items from that list at random. </span><span class="koboSpan" id="kobo.188.2">Attempting to do so with </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">random_integer</span></strong><span class="koboSpan" id="kobo.190.1"> is already pretty cumbersome, but it becomes more challenging if we have requirements to ensure that the second instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">random_integer</span></strong><span class="koboSpan" id="kobo.192.1"> isn’t the same as the </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">first one.</span></span></p>
<p><span class="koboSpan" id="kobo.194.1">Luckily, an alternative approach to using </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">random_integer</span></strong><span class="koboSpan" id="kobo.196.1"> to select the index of an array is to use a built-in resource for the specific task of choosing a random subset of items from a </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">list</span></strong><span class="koboSpan" id="kobo.198.1">. </span><span class="koboSpan" id="kobo.198.2">You can achieve this approach using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">random_shuffle</span></strong><span class="koboSpan" id="kobo.200.1"> resource, passing in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">list</span></strong><span class="koboSpan" id="kobo.202.1"> and the number of items you want using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">result_count</span></strong><span class="koboSpan" id="kobo.204.1"> attribute. </span><span class="koboSpan" id="kobo.204.2">The output </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">result</span></strong><span class="koboSpan" id="kobo.206.1"> will be a </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">list</span></strong><span class="koboSpan" id="kobo.208.1"> of strings that you can use. </span><span class="koboSpan" id="kobo.208.2">This approach dramatically simplifies our solution if we want our AWS </span><strong class="bold"><span class="koboSpan" id="kobo.209.1">Elastic Load Balancer</span></strong><span class="koboSpan" id="kobo.210.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.211.1">ELB</span></strong><span class="koboSpan" id="kobo.212.1">) to</span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.213.1"> span multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">availability zones.</span></span></p>
<p><span class="koboSpan" id="kobo.215.1">Consider the following array of AWS </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">availability zones:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.217.1">
    locals {
      azs = [
        "us-west-1a",
        "us-west-1c",
        "us-west-1d",
        "us-west-1e"
      ]
    }</span></pre> <p><span class="koboSpan" id="kobo.218.1">We would </span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.219.1">use </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">random_shuffle</span></strong><span class="koboSpan" id="kobo.221.1"> to generate two availability zones for </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">our ELB:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.223.1">
    resource "random_shuffle" "azs" {
      input        = local.azs
      result_count = 2
    }</span></pre> <p><span class="koboSpan" id="kobo.224.1">Finally, we set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">availability_zones</span></strong><span class="koboSpan" id="kobo.226.1"> attribute using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">result</span></strong><span class="koboSpan" id="kobo.228.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">random_shuffle</span></strong><span class="koboSpan" id="kobo.230.1"> because its output is the correct type </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">list(string)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.234.1">
    resource "aws_elb" "foo" {
      availability_zones = random_shuffle.azs.result
      # ... </span><span class="koboSpan" id="kobo.234.2">and other aws_elb arguments ...
</span><span class="koboSpan" id="kobo.234.3">    }</span></pre> <p><span class="koboSpan" id="kobo.235.1">This resource is useful, but you need to watch out when using it as it can cause your solution to become non-deterministic—meaning that Terraform won’t be able to figure out how to create a plan until the </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">random_shuffle</span></strong><span class="koboSpan" id="kobo.237.1"> resource has been created. </span><span class="koboSpan" id="kobo.237.2">This could require you to use targeted </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">terraform apply</span></strong><span class="koboSpan" id="kobo.239.1"> operations to avoid </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">first-time-ap</span><a id="_idTextAnchor194"/><span class="koboSpan" id="kobo.241.1">ply failures.</span></span></p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor195"/><span class="koboSpan" id="kobo.242.1">Working with time</span></h2>
<p><span class="koboSpan" id="kobo.243.1">In Terraform, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">time</span></strong><span class="koboSpan" id="kobo.245.1"> provider </span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.246.1">offers several capabilities that make it easier to handle various scenarios where resource life cycle management is dictated </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">by time.</span></span></p>
<p><span class="koboSpan" id="kobo.248.1">While most cloud providers offer much better solutions for resource scheduling, there are still cases where time plays a crucial role in the provisioning of resources. </span><span class="koboSpan" id="kobo.248.2">This situation often involves certificates, where you need to set a fixed or rolling window for the certificate to expire. </span><span class="koboSpan" id="kobo.248.3">In this situation, you can use either a specific date/time in the future or one that is relative to the </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">curr</span><a id="_idTextAnchor196"/><span class="koboSpan" id="kobo.250.1">ent date/time.</span></span></p>
<h3><span class="koboSpan" id="kobo.251.1">Current date/time</span></h3>
<p><span class="koboSpan" id="kobo.252.1">Sometimes, you</span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.253.1"> want to capture the current date and time, which you may like to use for the effective date of a secret’s value. </span><span class="koboSpan" id="kobo.253.2">There are two methods to obtaining the current date in Terraform—a function and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">time_static</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.255.1"> resource:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.256.1">
    locals {
      option1 = timestamp()
    }</span></pre> <p><span class="koboSpan" id="kobo.257.1">The preceding code demonstrates using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">timestamp()</span></strong><span class="koboSpan" id="kobo.259.1"> function. </span><span class="koboSpan" id="kobo.259.2">The following code shows how to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">time_static</span></strong><span class="koboSpan" id="kobo.261.1"> resource from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">time</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.263.1"> provider:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.264.1">
    resource "time_static" "current_time" {}</span></pre> <p><span class="koboSpan" id="kobo.265.1">Both approaches will generate the current date/time on the first time you run </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">apply</span></strong><span class="koboSpan" id="kobo.267.1">. </span><span class="koboSpan" id="kobo.267.2">The difference is that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">timestamp()</span></strong><span class="koboSpan" id="kobo.269.1"> function will always generate a current date/time stamp on every subsequent </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">apply</span></strong><span class="koboSpan" id="kobo.271.1">. </span><span class="koboSpan" id="kobo.271.2">This makes it more ideal for scenarios such as tagging a resource with its last modified date, which could be useful to determine the last time the resource was touched by Terraform. </span><span class="koboSpan" id="kobo.271.3">Another common scenario is triggering resource updates that you want to happen every time, but try to avoid this because this creates perpetual churn in </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">your solution.</span></span></p>
<p><span class="koboSpan" id="kobo.273.1">At the same time, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">time_static</span></strong><span class="koboSpan" id="kobo.275.1"> resource will maintain, in State, the original date/time stamp at the first Terraform </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">apply</span></strong><span class="koboSpan" id="kobo.277.1">. </span><span class="koboSpan" id="kobo.277.2">This can be useful for life cycle management of the resources to determine when the deployment was originally created or for setting policies for backups, scaling, or decommissionin</span><a id="_idTextAnchor197"/><span class="koboSpan" id="kobo.278.1">g based </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">on age.</span></span></p>
<h3><span class="koboSpan" id="kobo.280.1">Fixed date/time</span></h3>
<p><span class="koboSpan" id="kobo.281.1">A string representation</span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.282.1"> of the date/time can be used to create a specific time in the future using an </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">absolute date/time:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.284.1">
    locals {
      future_date = "2024-05-04T00:00:00Z"
    }</span></pre> <p><span class="koboSpan" id="kobo.285.1">The preceding code will set the expiration date to May 4, 2024. </span><span class="koboSpan" id="kobo.285.2">The format of the string representation of date/time </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">YYYY-MM-DDTHH:MM:SSZ</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.289.1">Another option is using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">time_static</span></strong><span class="koboSpan" id="kobo.291.1"> resource and setting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">rfc3339</span></strong><span class="koboSpan" id="kobo.293.1"> attribute, which is rarely used due to its limited value over simply setting </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">a local:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.295.1">
    resource "time_static" "may_the_fourth" {
      rfc3339 = "2024-05-04T</span><a id="_idTextAnchor198"/><span class="koboSpan" id="kobo.296.1">00:00:00Z"
    }</span></pre> <h3><span class="koboSpan" id="kobo.297.1">Time offset</span></h3>
<p><span class="koboSpan" id="kobo.298.1">A specific</span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.299.1"> time in the future using a period relative to the current date can be created </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">time_offset</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.303.1">
    resource "time_offset" "certificate_expiration" {
      offset_years = 1
    }</span></pre> <p><span class="koboSpan" id="kobo.304.1">The preceding code will set the expiration date to exactly one year in the future. </span><span class="koboSpan" id="kobo.304.2">There are different attributes to adjust the offset date/time stamp by years, months, days, hours, minutes, and seconds. </span><span class="koboSpan" id="kobo.304.3">You can set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">base_rfc3339</span></strong><span class="koboSpan" id="kobo.306.1"> attribute to change the date/time to which the offset is relative. </span><span class="koboSpan" id="kobo.306.2">This can be a great way to dynamically set certain expiration dates. </span><span class="koboSpan" id="kobo.306.3">However, you need to ensure that you routinely run Terraform to keep the target da</span><a id="_idTextAnchor199"/><span class="koboSpan" id="kobo.307.1">te in </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">the future.</span></span></p>
<h4><span class="koboSpan" id="kobo.309.1">Rotation</span></h4>
<p><span class="koboSpan" id="kobo.310.1">You</span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.311.1"> may need to recreate resources on a regular cadence in several situations. </span><span class="koboSpan" id="kobo.311.2">This secret could need to be updated every 90 days or XXX days. </span><span class="koboSpan" id="kobo.311.3">In these situations, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">time_rotating</span></strong><span class="koboSpan" id="kobo.313.1"> resource provides an advantage over its static siblings, both </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">time_static</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.315.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">time_offset</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.318.1">Time offset seems like the solution for rotation as it is relative to the current date, but just like </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">time_static</span></strong><span class="koboSpan" id="kobo.320.1">, it is just another way of calculating a static date/time stamp that Terraform will store in State. </span><span class="koboSpan" id="kobo.320.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">time_rotating</span></strong><span class="koboSpan" id="kobo.322.1"> resource’s superpower is that when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">rotation_days</span></strong><span class="koboSpan" id="kobo.324.1"> period expires relative to the original date, you will see that the resource triggers </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">a </span></span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">replacement</span></span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.328.1">
    resource "time_rotating" "certificate" {
      rotation_days = 90
    }</span></pre> <p><span class="koboSpan" id="kobo.329.1">This also requires you to regularly run Terraform to keep the values in the future. </span><span class="koboSpan" id="kobo.329.2">If you utilize resources like this, make sure you coordinate with your change management procedures, as they can sneak up on you when you execute a </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">terraform plan</span></strong><span class="koboSpan" id="kobo.331.1"> only to discover you’ve pass</span><a id="_idTextAnchor200"/><span class="koboSpan" id="kobo.332.1">ed the </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">magic date.</span></span></p>
<p><span class="koboSpan" id="kobo.334.1">In this section, we learned how to randomize the names of our resources using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">random</span></strong><span class="koboSpan" id="kobo.336.1"> provider, and even generate secrets that we can use to fully automate an environment with resources that need you to set passwords before Terraform can provision them. </span><span class="koboSpan" id="kobo.336.2">We also learned how we could use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">time</span></strong><span class="koboSpan" id="kobo.338.1"> provider, when to use it versus the </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">timestamp()</span></strong><span class="koboSpan" id="kobo.340.1"> function we looked at in </span><a href="B21183_02.xhtml#_idTextAnchor096"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.341.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.342.1">, and other advanced scenarios of creating time periods and windows </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">of rotation.</span></span></p>
<p><span class="koboSpan" id="kobo.344.1">Next, we’ll look at some utility providers that help us overcome some limitations of Terraform whenever we encounter a situation in which Terraform doesn’t already have a built-in solution or an existing provider that tackles </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">the problem.</span></span></p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor201"/><span class="koboSpan" id="kobo.346.1">Adaptation and integration</span></h1>
<p><span class="koboSpan" id="kobo.347.1">As we’ve discussed, Terraform and its providers are open source projects, so there may be limits to what it can do or what is available. </span><span class="koboSpan" id="kobo.347.2">As a result, we often need to find ways of overcoming these limitations—even temporarily. </span><span class="koboSpan" id="kobo.347.3">In this section, we’ll look at several providers that help Terraform reach outside and take advantage of external programs and systems that can enhance Terraform and help it overcome situations lacking a </span><a id="_idTextAnchor202"/><span class="No-Break"><span class="koboSpan" id="kobo.348.1">built-in solution.</span></span></p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor203"/><span class="koboSpan" id="kobo.349.1">Accessing external resources</span></h2>
<p><span class="koboSpan" id="kobo.350.1">Like many</span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.351.1"> utility providers, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">external</span></strong><span class="koboSpan" id="kobo.353.1"> provider is tiny. </span><span class="koboSpan" id="kobo.353.2">It only has one data source of the same name as the provider: </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">external</span></strong><span class="koboSpan" id="kobo.355.1">. </span><span class="koboSpan" id="kobo.355.2">As the name implies, this data source allows you to integrate with third-party components. </span><span class="koboSpan" id="kobo.355.3">It enables you to execute a local program, pass its input, and process the output. </span><span class="koboSpan" id="kobo.355.4">This capability can be advantageous when you want to obtain dynamic configuration from an external source, perform complex transformations on inputs you receive from other providers, and integrate with third-party tools that you want to integrate </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">with Terraform.</span></span></p>
<p><span class="koboSpan" id="kobo.357.1">This provider is very particular about the runtime requirements of the program that you specified. </span><span class="koboSpan" id="kobo.357.2">First, the program must run successfully by exiting with an exit code of zero. </span><span class="koboSpan" id="kobo.357.3">If the program returns a non-zero code, the provider will sound the alarm and scramble an error message to Terraform. </span><span class="koboSpan" id="kobo.357.4">Second, the provider expects both the input and the output to be in </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">JSON format.</span></span></p>
<p><span class="koboSpan" id="kobo.359.1">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">external</span></strong><span class="koboSpan" id="kobo.361.1"> provider </span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.362.1">works perfectly when your third-party program fulfills all these requirements. </span><span class="koboSpan" id="kobo.362.2">It is a happy coincidence indeed! </span><span class="koboSpan" id="kobo.362.3">If you are integrating with such a program, that’s great. </span><span class="koboSpan" id="kobo.362.4">However, this provider is the right choice when you author custom scripts or programs that explicitly meet these </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">contractual obligations.</span></span></p>
<p><span class="koboSpan" id="kobo.364.1">To be as cross-platform as possible, the ideal programming language to write these custom scripts would be Python or Go. </span><span class="koboSpan" id="kobo.364.2">With these programming languages, you can create a lightweight script, designed and built, that is fit for the purpose of talking to the external system of your choice and providing Terraform-friendly outputs and </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">error handling:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.366.1">
    data "external" "example" {
      program = ["python", "${path.module}/example-data-source.py"]
      query = {
        # arbitrary map from strings to strings, passed
        # to the external program as the data query.
</span><span class="koboSpan" id="kobo.366.2">        id = "abc123"
      }
    }</span></pre> <p><span class="koboSpan" id="kobo.367.1">In the preceding</span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.368.1"> code, we are executing the Python program on the local machine–this</span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.369.1"> could be our laptop or the build agent of our </span><strong class="bold"><span class="koboSpan" id="kobo.370.1">continuous integration/continuous deli</span><a id="_idTextAnchor204"/><span class="koboSpan" id="kobo.371.1">very</span></strong><span class="koboSpan" id="kobo.372.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.373.1">CI/CD</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">) pipeline.</span></span></p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor205"/><span class="koboSpan" id="kobo.375.1">When you want to make something from nothing</span></h2>
<p><span class="koboSpan" id="kobo.376.1">Terraform and its providers are open source projects. </span><span class="koboSpan" id="kobo.376.2">That means that we are at the mercy of friendly internet strangers who are keeping pace with the changes made to the platforms and technologies that we hope to automate. </span><span class="koboSpan" id="kobo.376.3">While Terraform has fantastic coverage across a wide set of public cloud platforms and technologies, sometimes, it needs a little help. </span><span class="koboSpan" id="kobo.376.4">There might be a small feature that lacks support that you can’t configure natively through the resources available in the provider. </span><span class="koboSpan" id="kobo.376.5">Sometimes, those small tweaks play a critical role in configuration, and we need to draw dependencies on them from other resources that can be provisioned natively through the Terraform provider. </span><span class="koboSpan" id="kobo.376.6">That’s where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">null_res</span><a id="_idTextAnchor206"/><span class="koboSpan" id="kobo.378.1">ource</span></strong><span class="koboSpan" id="kobo.379.1"> comes </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">into play.</span></span></p>
<h3><span class="koboSpan" id="kobo.381.1">Null resource</span></h3>
<p><span class="koboSpan" id="kobo.382.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">null_resource</span></strong><span class="koboSpan" id="kobo.384.1"> allows </span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.385.1">us to leverage meta-arguments such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">provisioner</span></strong><span class="koboSpan" id="kobo.387.1"> to perform local and remote script executions. </span><span class="koboSpan" id="kobo.387.2">This allows you to execute critical command-line scripts that must be completed before Terraform can continue its plan. </span><span class="koboSpan" id="kobo.387.3">As a result, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">null_resource</span></strong><span class="koboSpan" id="kobo.389.1"> has no attributes such as other Terraform resources. </span><span class="koboSpan" id="kobo.389.2">Its only attribute is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">list(string)</span></strong><span class="koboSpan" id="kobo.391.1"> called </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">triggers</span></strong><span class="koboSpan" id="kobo.393.1">. </span><span class="koboSpan" id="kobo.393.2">When any strings within this array change, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">null_resource</span></strong><span class="koboSpan" id="kobo.395.1"> is replaced. </span><span class="koboSpan" id="kobo.395.2">This is an important life cycle control that you need to consider when configuring the </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">provisi</span><a id="_idTextAnchor207"/><span class="koboSpan" id="kobo.397.1">oner</span></strong><span class="koboSpan" id="kobo.398.1"> blocks </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">you attach.</span></span></p>
<h3><span class="koboSpan" id="kobo.400.1">Time sleep</span></h3>
<p><span class="koboSpan" id="kobo.401.1">There is another technique of doing nothing. </span><span class="koboSpan" id="kobo.401.2">There can be situations where the action you try to trigger is non-deterministic, meaning you won’t know exactly when it finishes. </span><span class="koboSpan" id="kobo.401.3">This could be out of context or a true technical limitation of the resource or shim you use. </span><span class="koboSpan" id="kobo.401.4">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">time</span></strong><span class="koboSpan" id="kobo.403.1"> provider offers a resource</span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.404.1"> called </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">time_sleep</span></strong><span class="koboSpan" id="kobo.406.1">, which lets you create a sleep timer. </span><span class="koboSpan" id="kobo.406.2">You must declare </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">depends_on</span></strong><span class="koboSpan" id="kobo.408.1"> meta-arguments to ensure that the sleep timer is invoked between the </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">required resources:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.410.1">
    # This resource will destroy (potentially immediately) after null_resource.next
    resource "null_resource" "previous" {}
    resource "time_sleep" "wait_30_seconds" {
      depends_on = [null_resource.previous]
      create_duration = "30s"
    }
    # This resource will create (at least) 30 seconds after null_resource.previous
    resource "null_resource" "next" {
      depends_on = [time_sleep.wait_30_seconds]
    }</span></pre> <p><span class="koboSpan" id="kobo.411.1">Delayed </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">destroy</span></strong><span class="koboSpan" id="kobo.413.1"> can be done using a different attribute </span><a id="_idTextAnchor208"/><span class="No-Break"><span class="koboSpan" id="kobo.414.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">destroy_duration</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">.</span></span></p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor209"/><span class="koboSpan" id="kobo.417.1">Making HTTP requests</span></h2>
<p><span class="koboSpan" id="kobo.418.1">Sometimes, you</span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.419.1"> can access data from external sources without using a local script or command-line utility, by directly accessing a REST API endpoint. </span><span class="koboSpan" id="kobo.419.2">This approach is advantageous when you want to fetch configuration information staged at a static HTTP endpoint, access information about resources managed outside of Terraform, integrate with a cloud provider or external services directly through a REST API, and integrate health checks into your </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">Terraform process.</span></span></p>
<p><span class="koboSpan" id="kobo.421.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">http</span></strong><span class="koboSpan" id="kobo.423.1"> provider </span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.424.1">provides a single data source called </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">http</span></strong><span class="koboSpan" id="kobo.426.1">, allowing you to make an HTTP </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">GET</span></strong><span class="koboSpan" id="kobo.428.1"> operation. </span><span class="koboSpan" id="kobo.428.2">The only required input is </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">url</span></strong><span class="koboSpan" id="kobo.430.1">, but you can provide several attributes you would expect to set on an HTTP request, such as HTTP request headers and </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">body content:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.432.1">
    data "http" "foo" {
      url = "https://foo"
    }</span></pre> <p><span class="koboSpan" id="kobo.433.1">After Terraform </span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.434.1">makes the HTTP request, you can access the HTTP response status code, headers, and </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">body content.</span></span></p>
<p><span class="koboSpan" id="kobo.436.1">In this section, we learned how to integrate with all sorts of external components—local programs or scripts, a remote server, and nothing </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">at all.</span></span></p>
<p><span class="koboSpan" id="kobo.438.1">Next, we’ll look at some utility providers that help us work with creating and accessing files. </span><span class="koboSpan" id="kobo.438.2">We’ve already encountered some functions that enable some of these scenarios, but some additional scenarios are only possible when we use </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">utility providers.</span></span></p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor210"/><span class="koboSpan" id="kobo.440.1">Filesystem</span></h1>
<p><span class="koboSpan" id="kobo.441.1">When building IaC solutions using Terraform, there are many situations where we need to either use existing files or create new ones. </span><span class="koboSpan" id="kobo.441.2">In this section, we’ll look at the utility providers that enable more advanced scenarios that move beyond the </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">file</span></strong><span class="koboSpan" id="kobo.443.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">templatefile</span></strong><span class="koboSpan" id="kobo.445.1"> functions and when we should use the providers </span><a id="_idTextAnchor211"/><span class="koboSpan" id="kobo.446.1">versus using </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">the functions.</span></span></p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor212"/><span class="koboSpan" id="kobo.448.1">Reading and writing local files</span></h2>
<p><span class="koboSpan" id="kobo.449.1">There are</span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.450.1"> many situations when reading or writing files can be very useful to simplify how Terraform integrates with other tools by creating configuration files, scripts, or any other artifact required for your infrastructure deployment. </span><span class="koboSpan" id="kobo.450.2">To produce the desired output, you can define the content using templated files, input variables, or other expressions within your </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">HCL code.</span></span></p>
<p><span class="koboSpan" id="kobo.452.1">Terraform has a utility provider called </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">local</span></strong><span class="koboSpan" id="kobo.454.1"> that provides this functionality. </span><span class="koboSpan" id="kobo.454.2">This provider has two resources and two data sources named </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">local_file</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.456.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">local_sensitive_file</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.459.1">Why not just use the function? </span><span class="koboSpan" id="kobo.459.2">Functions do not participate in the dependency graph, so when you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">file</span></strong><span class="koboSpan" id="kobo.461.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">template_file</span></strong><span class="koboSpan" id="kobo.463.1"> functions, you cannot use them with files generated dynamically during a Terraform operation. </span><span class="koboSpan" id="kobo.463.2">Therefore, if you plan on generating and using a file within Terraform, you should always use the</span><a id="_idTextAnchor213"/> <strong class="source-inline"><span class="koboSpan" id="kobo.464.1">local</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.465.1">provider’s resources.</span></span></p>
<h3><span class="koboSpan" id="kobo.466.1">Writing files</span></h3>
<p><span class="koboSpan" id="kobo.467.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">local_file</span></strong><span class="koboSpan" id="kobo.469.1"> resource (and the corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">local_sensitive_file</span></strong><span class="koboSpan" id="kobo.471.1"> resource) allows you to </span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.472.1">create a new file at a target location specified in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">filename</span></strong><span class="koboSpan" id="kobo.474.1"> attribute. </span><span class="koboSpan" id="kobo.474.2">There are several options for sourcing the content, either by using dynamically generated content inside Terraform or an </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">existing file:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">content</span></strong><span class="koboSpan" id="kobo.477.1">: This attribute allows you to pass any string as long as it is UTF-8-encoded, using simple strings from resource outputs, local variables, or functions to generate </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">a string.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">content_base64</span></strong><span class="koboSpan" id="kobo.480.1">: This attribute allows you to pass binary data as a </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">Base64-encoded string.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">source</span></strong><span class="koboSpan" id="kobo.483.1">: This attribute allows you to pass a path to an existing file from which you want to read the contents. </span><span class="koboSpan" id="kobo.483.2">When using this attribute, you copy the original file to a </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">new location.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.485.1">In the following code, we are setting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">content</span></strong><span class="koboSpan" id="kobo.487.1"> attribute to a simple constant string and using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">${path.module}</span></strong><span class="koboSpan" id="kobo.489.1"> special token to specify the current module’s working directory as the output location for a file with the name </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">foo.bar</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.493.1">
    resource "local\_file" "foo" {
      content  = "foo!"
</span><span class="koboSpan" id="kobo.493.2">      filename = "${path.module}/foo.bar"
    }</span></pre> <p><span class="koboSpan" id="kobo.494.1">Be careful when destroying, especially if you dynamically generate the file’s contents inside Terraform using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">jsonencode</span></strong><span class="koboSpan" id="kobo.496.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">yamlencode</span></strong><span class="koboSpan" id="kobo.498.1">, or any other method—you may run into issues because of the way Terraform handles dependencies on this </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">resource type.</span></span></p>
<p><span class="koboSpan" id="kobo.500.1">Also, be aware</span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.501.1"> when writing sensitive data to files, as it can pose a security risk. </span><span class="koboSpan" id="kobo.501.2">Likewise, filesystem access or I/O failures can create opportunities for additional points of failure when </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">executing Terraform.</span></span></p>
<p><span class="koboSpan" id="kobo.503.1">Given these common pitfalls, generating file contents using Terraform can still be extremely effective. </span><span class="koboSpan" id="kobo.503.2">One such scenario is generating YAML inventories for Ansible, which can be an excellent way of integrating Terraform and Ansible as part of a broader maintenance process for long-lived environments that need configuration management changes </span><a id="_idTextAnchor214"/><span class="koboSpan" id="kobo.504.1">at the operating </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">system level.</span></span></p>
<h3><span class="koboSpan" id="kobo.506.1">Reading files</span></h3>
<p><span class="koboSpan" id="kobo.507.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">local_file</span></strong><span class="koboSpan" id="kobo.509.1"> data source (and the corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">local_sensitive_file</span></strong><span class="koboSpan" id="kobo.511.1"> data source) allows </span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.512.1">you to read the contents of an existing file and output its contents in a variety of formats that you can use as inputs to other resources and modules within your code base. </span><span class="koboSpan" id="kobo.512.2">This capability is similar to what the </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">file</span></strong><span class="koboSpan" id="kobo.514.1"> function can do but provides a </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">few advantages.</span></span></p>
<p><span class="koboSpan" id="kobo.516.1">First, it can create a standalone block referenced multiple times from multiple resources without repeating the filename’s path in the equivalent function call. </span><span class="koboSpan" id="kobo.516.2">Creating a central reference to the local file can make your code more maintainable by making the dependencies on the file more apparent to both Terraform </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">and humans.</span></span></p>
<p><span class="koboSpan" id="kobo.518.1">Second, by leveraging the data source, you immediately have several ways to output the data, including Base64-string, SHA, and MD5 options. </span><span class="koboSpan" id="kobo.518.2">By leveraging these output options, you can avoid additional nested function calls to perform the same </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">encoding operations.</span></span></p>
<p><span class="koboSpan" id="kobo.520.1">In the following code, we access an existing file within the module’s current directory with a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">foo.bar</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.522.1"> filename:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.523.1">
    data "local_file" "foo" {
      filename = "${path.module}/foo.bar"
    }</span></pre> <p><span class="koboSpan" id="kobo.524.1">We can then access the file’s raw content by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">content</span></strong><span class="koboSpan" id="kobo.526.1"> output of the data source or any of the other enco</span><a id="_idTextAnchor215"/><span class="koboSpan" id="kobo.527.1">ding options </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">mentioned earlier.</span></span></p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor216"/><span class="koboSpan" id="kobo.529.1">Templating files and directories</span></h2>
<p><span class="koboSpan" id="kobo.530.1">In the </span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.531.1">previous chapter, we covered templating files and surveyed HCL’s built-in functions, including the function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">template_file</span></strong><span class="koboSpan" id="kobo.533.1">. </span><span class="koboSpan" id="kobo.533.2">You should use</span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.534.1"> this function when working with a single file, but the </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">template</span></strong><span class="koboSpan" id="kobo.536.1"> provider offers a resource that you can use to apply templating across all the files within a </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">given directory.</span></span></p>
<p><span class="koboSpan" id="kobo.538.1">The resource takes input files from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">source_dir</span></strong><span class="koboSpan" id="kobo.540.1"> attribute and, for each file, substitutes the specified input variables for the corresponding placeholders, writing each output file to the established </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">destination_dir</span></strong><span class="koboSpan" id="kobo.542.1">. </span><span class="koboSpan" id="kobo.542.2">Using this resource is a great way to update configurations that span a multitude of files. </span><span class="koboSpan" id="kobo.542.3">Still, you must stage all files with a consistent set of placeholders for the templating engine to replace in the same fashion as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">t</span><a id="_idTextAnchor217"/><span class="koboSpan" id="kobo.544.1">emplate_file()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.545.1">function operates.</span></span></p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor218"/><span class="koboSpan" id="kobo.546.1">Generating file archives</span></h2>
<p><span class="koboSpan" id="kobo.547.1">Sometimes, it’s necessary </span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.548.1">to package outputs from Terraform into compressed archives that you can use for several different purposes, such as efficiently transferring configuration to the next stage in the application deployment pipeline, bundling configuration for easy distribution to other external repositories, and generating documentation or other artifacts to track deployment history, environmental changes, or snapshots of configuration as they change </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">over time.</span></span></p>
<p><span class="koboSpan" id="kobo.550.1">You should avoid this approach when working with secrets or sensitive data, as more appropriate solutions exist for those scenarios. </span><span class="koboSpan" id="kobo.550.2">Metadata related to the infrastructure generated by Terraform and needed by another tool in another format is the ideal scenario for </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">this approach.</span></span></p>
<p><span class="koboSpan" id="kobo.552.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">archive_file</span></strong><span class="koboSpan" id="kobo.554.1"> resource generates a ZIP file at the specified </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">output_path </span></strong><span class="koboSpan" id="kobo.556.1">and includes one or more files, using either existing fil</span><a id="_idTextAnchor219"/><span class="koboSpan" id="kobo.557.1">es or dynamically </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">generated files.</span></span></p>
<h3><span class="koboSpan" id="kobo.559.1">Including existing files</span></h3>
<p><span class="koboSpan" id="kobo.560.1">When you</span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.561.1"> want to reference either existing files that are stored in your Terraform module directory or files generated by Terraform using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">local</span></strong><span class="koboSpan" id="kobo.563.1"> provider, you should use </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">source_file</span></strong><span class="koboSpan" id="kobo.565.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">source_dir</span></strong><span class="koboSpan" id="kobo.567.1"> to include a single file or an </span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.568.1">entire directory of files within the </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">archive, respectively:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.570.1">
    data "archive_file" "init" {
      type        = "zip"
      source_file = "${path.module}/foo.txt"
      output_path = </span><a id="_idTextAnchor220"/><span class="koboSpan" id="kobo.571.1">"${path.module}/files/out.zip"
    }</span></pre> <h3><span class="koboSpan" id="kobo.572.1">Including dynamically created files</span></h3>
<p><span class="koboSpan" id="kobo.573.1">When</span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.574.1"> you want to output content that’s dynamically generated by Terraform using object construction in local variables or other means, you need to use one or more </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">source</span></strong><span class="koboSpan" id="kobo.576.1"> blocks and specify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">content</span></strong><span class="koboSpan" id="kobo.578.1"> and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">filename</span></strong><span class="koboSpan" id="kobo.580.1"> of the file to include it within </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">the archive:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.582.1">
    data "archive_file" "dotfiles" {
      type        = "zip"
      output_path = "${path.module}/files/out.zip"
      source {
        content  = "foobar"
        filename = "foo.txt"
      }
    }</span></pre> <p><span class="koboSpan" id="kobo.583.1">Optionally, if you only want one dynamically generated file in the archive, you can use the top-level </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">source_content</span></strong><span class="koboSpan" id="kobo.585.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">source_filename</span></strong><span class="koboSpan" id="kobo.587.1"> to have a </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">single file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.589.1">
    data "archive_file" "dotfiles" {
      type        = "zip"
      output_path = "${path.module}/files/out.zip"
      source_content          = "foobar"
      source_content_filename = "foo.txt"
    }</span></pre> <p><span class="koboSpan" id="kobo.590.1">The</span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.591.1"> preceding examples produce the same output, but the latter is slightly more concise for the single-file archive scenario. </span><span class="koboSpan" id="kobo.591.2">At the same time, the former allows you to add as many files to the archive as you like in the future using additional </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">source</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.593.1"> blocks.</span></span></p>
<p><span class="koboSpan" id="kobo.594.1">It’s important to note that each method for including files within the archive is mutually exclusive, so you must choose one—and </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">only one—approach.</span></span></p>
<p><span class="koboSpan" id="kobo.596.1">In this section, we learned how to leverage the </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">local</span></strong><span class="koboSpan" id="kobo.598.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">archive</span></strong><span class="koboSpan" id="kobo.600.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">template</span></strong><span class="koboSpan" id="kobo.602.1"> providers to handle more robust filesystem access scenarios where leveraging the existing functions may not </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">be ideal.</span></span></p>
<p><span class="koboSpan" id="kobo.604.1">Finally, we’ll look at some utility providers that help us work with setting up operating system configuration, security, and network </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">access control.</span></span></p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor221"/><span class="koboSpan" id="kobo.606.1">Operating system and networking</span></h1>
<p><span class="koboSpan" id="kobo.607.1">HashiCorp created Terraform’s utility providers to solve common problems that span cloud platforms. </span><span class="koboSpan" id="kobo.607.2">As a result, some utility providers solve problems relating to common architectural scenarios you will encounter whe</span><a id="_idTextAnchor222"/><span class="koboSpan" id="kobo.608.1">n setting up or connecting </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">to servers.</span></span></p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor223"/><span class="koboSpan" id="kobo.610.1">Generating certificates and SSH keys</span></h2>
<p><span class="koboSpan" id="kobo.611.1">In Terraform, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">tls</span></strong><span class="koboSpan" id="kobo.613.1"> provider</span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.614.1"> offers general capabilities related to </span><strong class="bold"><span class="koboSpan" id="kobo.615.1">Transport Layer Security</span></strong><span class="koboSpan" id="kobo.616.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.617.1">TLS</span></strong><span class="koboSpan" id="kobo.618.1">) and </span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.619.1">cryptography. </span><span class="koboSpan" id="kobo.619.2">You should use this provider with a certificate authority to generate signed certificates for production workloads. </span><span class="koboSpan" id="kobo.619.3">Still, several features are very helpful in development and lab </span><a id="_idTextAnchor224"/><span class="koboSpan" id="kobo.620.1">environments to </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">streamline productivity.</span></span></p>
<h3><span class="koboSpan" id="kobo.622.1">SSH keys</span></h3>
<p><span class="koboSpan" id="kobo.623.1">When working with virtual</span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.624.1"> machines, an everyday use case is the need to generate </span><strong class="bold"><span class="koboSpan" id="kobo.625.1">Secure Socket Shell</span></strong><span class="koboSpan" id="kobo.626.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.627.1">SSH</span></strong><span class="koboSpan" id="kobo.628.1">) keys that you can use to access your Linux-based virtual machines. </span><span class="koboSpan" id="kobo.628.2">Of course, you can create and pre-stage a key on the public cloud of your choice using standard command-line tools such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">ssh-keygen</span></strong><span class="koboSpan" id="kobo.630.1">, but Terraform has a provider with resources for this very task, which makes it extremely easy and convenient to encapsulate the same SSH key generation with the infrastructure that is going to use it. </span><span class="koboSpan" id="kobo.630.2">It’s a perfect tool for short-lived lab environments to kick the tires on, but when using this approach, you’ll need to lock down your </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">Terraform state:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.632.1">
    resource "tls_private_key" "ssh_key" {
      algorithm = "RSA"
      rsa_bits  = 4096
    }</span></pre> <p><span class="koboSpan" id="kobo.633.1">Now that Terraform has generated your resource, you can drop it into the secrets manager of </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">your choice:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.635.1">
    resource "azurerm_key_vault_secret" "ssh_private_key" {
      name         = "ssh-key"
      value        = tls_private_key.ssh_key.private_key_openssh
      key_vault_id = azurerm_key_vault.main.id
    }</span></pre> <p><span class="koboSpan" id="kobo.636.1">In the preceding example, we drop the </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">private_key_openssh</span></strong><span class="koboSpan" id="kobo.638.1"> value into an Azure Key Vault secret, allowing us to use the SSH key from the Azure portal to connect to the machine directly or use </span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">Azure Bastion.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">RSA</span></strong><span class="koboSpan" id="kobo.641.1"> is the most popular algorithm used for SSH keys. </span><span class="koboSpan" id="kobo.641.2">It is tried and true, but you should use a key size of at least 4,096 bits. </span><span class="koboSpan" id="kobo.641.3">Newer algorithms such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">ECDSA</span></strong><span class="koboSpan" id="kobo.643.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">ED25519</span></strong><span class="koboSpan" id="kobo.645.1"> are also supported, but you should ensure your clients support these algorithms before wider adoption within </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">your organization.</span></span></p>
<p><span class="koboSpan" id="kobo.647.1">When you generate the SSH key, you don’t need to save it to the filesystem. </span><span class="koboSpan" id="kobo.647.2">You should save it to a </span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.648.1">certificate management service such as </span><strong class="bold"><span class="koboSpan" id="kobo.649.1">AWS Certificate Manager</span></strong><span class="koboSpan" id="kobo.650.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.651.1">ACM</span></strong><span class="koboSpan" id="kobo.652.1">), Azure Key Vault, or Google Cloud’s </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">Certificate Manager.</span></span></p>
<p><span class="koboSpan" id="kobo.654.1">Due to the</span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.655.1"> way Terraform planning works, for Terraform to know whether or not the SSH key resource exists and whether your certificate manager has the resource, it needs to maintain critical attributes in the state file. </span><span class="koboSpan" id="kobo.655.2">Many of those key attributes are highly sensitive information, including the public and private keys. </span><span class="koboSpan" id="kobo.655.3">Therefore, securing your Terraform state’s backend will be crucial to prevent unauthorized access. </span><span class="koboSpan" id="kobo.655.4">It’s not an impossible or difficult task in its own right, but until you’ve got a secure backend strategy in place, this approach is prob</span><a id="_idTextAnchor225"/><span class="koboSpan" id="kobo.656.1">ably good to skip for </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">production workloads.</span></span></p>
<h3><span class="koboSpan" id="kobo.658.1">Certificates</span></h3>
<p><span class="koboSpan" id="kobo.659.1">When</span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.660.1"> generating a certificate, you typically need to generate a </span><strong class="bold"><span class="koboSpan" id="kobo.661.1">certificate signing request</span></strong><span class="koboSpan" id="kobo.662.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.663.1">CSR</span></strong><span class="koboSpan" id="kobo.664.1">) to a </span><strong class="bold"><span class="koboSpan" id="kobo.665.1">certificate authority</span></strong><span class="koboSpan" id="kobo.666.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.667.1">CA</span></strong><span class="koboSpan" id="kobo.668.1">), which would include a</span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.669.1"> private key (usually in the form of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">PEM</span></strong><span class="koboSpan" id="kobo.671.1"> file) and </span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.672.1">details about the certificate subject, including human-friendly information such as the organization name, physical address, and network address information such as domain names or </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">IP addresses.</span></span></p>
<p><span class="koboSpan" id="kobo.674.1">Terraform has a resource, </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">tls_cert_request</span></strong><span class="koboSpan" id="kobo.676.1">, that</span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.677.1"> can generate the CSR. </span><span class="koboSpan" id="kobo.677.2">Like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">tls_private_key</span></strong><span class="koboSpan" id="kobo.679.1"> resource</span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.680.1"> that generates an SSH key, this resource performs a task a human operator would perform by using a graphical or command-line interface to generate the CSR. </span><span class="koboSpan" id="kobo.680.2">The output of this resource would then need to be passed to a CA to generate a </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">signed certificate.</span></span></p>
<p><span class="koboSpan" id="kobo.682.1">You can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">foo</span></strong><span class="koboSpan" id="kobo.684.1"> resource to generate the certificate locally. </span><span class="koboSpan" id="kobo.684.2">The CSR provider will attempt to process it on the local machine </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">running Terraform.</span></span></p>
<p><span class="koboSpan" id="kobo.686.1">First, you need a private key, which you can create using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">tls_private_key</span></strong><span class="koboSpan" id="kobo.688.1"> resource we used to generate an </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">SSH key:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.690.1">
    resource "tls_private_key" "foo" {
      algorithm = "RSA"
    }</span></pre> <p><span class="koboSpan" id="kobo.691.1">Then, we need to generate the CSR using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">tls_cert_request</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.693.1"> resource:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.694.1">
    resource "tls_cert_request" "foo" {
      private_key_pem = tls_private_key.foo.private_key_pem
      subject {
        common_name  = "foo.com"
        organization = "Foobar, Inc"
      }
    }</span></pre> <p><span class="koboSpan" id="kobo.695.1">Finally, we can </span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.696.1">generate a certificate using the private key and </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">the CSR:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.698.1">
    resource "tls_locally_signed_cert" "vault" {
      cert_request_pem = tls_cert_request.foo.cert_request_pem
      ca_key_algorithm   = tls_private_key.foo.algorithm
      ca_private_key_pem = tls_private_key.foo.private_key_pem
      ca_cert_pem        = tls_self_signed_cert.foo.cert_pem
      validity_period_hours = 17520
      allowed_uses = [
        "s</span><a id="_idTextAnchor226"/><span class="koboSpan" id="kobo.699.1">erver_auth",
        "client_auth",
      ]
    }</span></pre> <h2 id="_idParaDest-86"><a id="_idTextAnchor227"/><span class="koboSpan" id="kobo.700.1">Generating CloudInit configuration</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.701.1">Cloud Init</span></strong><span class="koboSpan" id="kobo.702.1"> is an </span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.703.1">open source, multi-platform tool for providing startup configuration to cloud-hosted virtual machines. </span><span class="koboSpan" id="kobo.703.2">It configures the new instance using metadata from</span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.704.1"> the cloud and user data. </span><span class="koboSpan" id="kobo.704.2">For example, you can set the hostname, set up users and groups, mount and form</span><a id="_idTextAnchor228"/><span class="koboSpan" id="kobo.705.1">at disks, install packages, and run </span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">custom scripts.</span></span></p>
<h3><span class="koboSpan" id="kobo.707.1">Basic usage</span></h3>
<p><span class="koboSpan" id="kobo.708.1">Sometimes, you </span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.709.1">can use data sources to generate content rather than talk to an external system. </span><span class="koboSpan" id="kobo.709.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">cloudinit_config</span></strong><span class="koboSpan" id="kobo.711.1"> is a perfect example of this. </span><span class="koboSpan" id="kobo.711.2">It is designed with a schema to help simplify generating the sometimes-verbose Cloud-Init configuration file passed as input to newly created </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">virtual machines.</span></span></p>
<p><span class="koboSpan" id="kobo.713.1">Cloud-Init supports several different part types. </span><span class="koboSpan" id="kobo.713.2">Each type infers a different schema and format for passing in content, sometimes using JSON, YAML, bash scripts, or raw text. </span><span class="koboSpan" id="kobo.713.3">The full scope of what Cloud-Init can do is out of the scope of this book, but I’d encourage you to look into the online documentation for further details. </span><span class="koboSpan" id="kobo.713.4">I’ll cover a few everyday use cases to show how you can use your existing Cloud-Init knowledge and apply it while using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">cloudinit</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.715.1">Terraform provider:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.716.1">
    data "cloudinit_config" "foo" {
      gzip          = false
      base64_encode = false
    }</span></pre> <p><span class="koboSpan" id="kobo.717.1">To attach the output as user data to a new </span><strong class="bold"><span class="koboSpan" id="kobo.718.1">Elastic Compute Cloud</span></strong><span class="koboSpan" id="kobo.719.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.720.1">EC2</span></strong><span class="koboSpan" id="kobo.721.1">) instance on AWS, we</span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.722.1"> would use the </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.724.1">
    resource "aws_instance" "web" {
      # other ec2 attributes
      user</span><a id="_idTextAnchor229"/><span class="koboSpan" id="kobo.725.1">_data = data.cloudinit_config.foo.rendered
    }</span></pre> <h3><span class="koboSpan" id="kobo.726.1">Loading external content</span></h3>
<p><span class="koboSpan" id="kobo.727.1">When</span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.728.1"> you have a large amount of external content you want to download to the instance, you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">x-include-url</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.730.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">x-include-once-url</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.733.1">
    data "cloudinit_config" "foo" {
      gzip          = false
      base64_encode = false
      part {
        content_type = "text/x-include-url"
      </span><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.734.1">  content      = "http://foo.com/bar.sh"
      }
    }</span></pre> <h3><span class="koboSpan" id="kobo.735.1">Using custom scripts</span></h3>
<p><span class="koboSpan" id="kobo.736.1">When you</span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.737.1"> want to execute custom scripts stored within the Terraform module directory, you can use several different part types to run the scripts under </span><span class="No-Break"><span class="koboSpan" id="kobo.738.1">other conditions:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">x-shellscript</span></strong><span class="koboSpan" id="kobo.740.1">: This script will run whenever the instance is booted. </span><span class="koboSpan" id="kobo.740.2">That is, it will execute every time your instance starts up, whether it is the first boot after creation or a </span><span class="No-Break"><span class="koboSpan" id="kobo.741.1">subsequent reboot.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">x-shellscript-per-boot</span></strong><span class="koboSpan" id="kobo.743.1">: This is the same as </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">x-shellscript</span></strong><span class="koboSpan" id="kobo.745.1">. </span><span class="koboSpan" id="kobo.745.2">It will also run on every boot of </span><span class="No-Break"><span class="koboSpan" id="kobo.746.1">the instance.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">x-shellscript-per-instance</span></strong><span class="koboSpan" id="kobo.748.1">: This script will run only once per instance. </span><span class="koboSpan" id="kobo.748.2">That is, the script will run on the first boot after the instance is created but will not run on subsequent reboots. </span><span class="koboSpan" id="kobo.748.3">This part is helpful for initialization tasks that only need to be done once for each instance, such as setting up software or users that persist </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">across reboots.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">x-shellscript-per-once</span></strong><span class="koboSpan" id="kobo.751.1">: This script will run only once across all instances. </span><span class="koboSpan" id="kobo.751.2">If you create multiple instances with the same script, this script will only run on the first instance that boots. </span><span class="koboSpan" id="kobo.751.3">This part is helpful for tasks that only need to be done once in a set of instances, such as setting up a database or a leader node in </span><span class="No-Break"><span class="koboSpan" id="kobo.752.1">a cluster.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.753.1">Consider the </span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.754.1">following script, which is stored in a bash script file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">foo.sh</span></strong><span class="koboSpan" id="kobo.756.1"> in the Terraform module’s </span><span class="No-Break"><span class="koboSpan" id="kobo.757.1">root folder:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.758.1">
    #!/bin/bash
    sudo apt-get update -y
    sudo apt-get install nginx -y
    echo '&lt;h1&gt;Hello from Terraform Cloud-Init!&lt;/h1&gt;' | sudo tee /var/www/html/index.html</span></pre> <p><span class="koboSpan" id="kobo.759.1">We can embed this in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">cloudinit_config</span></strong><span class="koboSpan" id="kobo.761.1"> data source to generate the user data we pass to a newly created </span><span class="No-Break"><span class="koboSpan" id="kobo.762.1">virtual machine:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.763.1">
    data "cloudinit_config" "foo" {
      gzip          = false
      base64_encode = false
      part {
        content_type = "text/x-shellscript"
        co</span><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.764.1">ntent      = file("${path.module}/foo.sh")
      }
    }</span></pre> <h3><span class="koboSpan" id="kobo.765.1">Cloud config files</span></h3>
<p><span class="koboSpan" id="kobo.766.1">Cloud-Init supports a custom schema for performing various everyday tasks. </span><span class="koboSpan" id="kobo.766.2">Several different </span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.767.1">part types are supported, enabling you to include cloud config data in multiple formats in your </span><a id="_idIndexMarker308"/><span class="No-Break"><span class="koboSpan" id="kobo.768.1">Cloud-Init packages:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">cloud-config</span></strong><span class="koboSpan" id="kobo.770.1">: This is the most commonly used content type for standard cloud-init YAML configuration files. </span><span class="koboSpan" id="kobo.770.2">You can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">cloud-config</span></strong><span class="koboSpan" id="kobo.772.1"> content type for general-purpose instance configuration tasks, such as setting up users and groups, managing packages, running commands, and </span><span class="No-Break"><span class="koboSpan" id="kobo.773.1">writing files.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">cloud-config-archive</span></strong><span class="koboSpan" id="kobo.775.1">: This content type provides multiple cloud-config parts in a single file. </span><span class="koboSpan" id="kobo.775.2">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">cloud-config-archive</span></strong><span class="koboSpan" id="kobo.777.1"> file is a YAML file that contains a list of cloud-config parts, where each part is a map containing a filename, a content type, and the content itself. </span><span class="koboSpan" id="kobo.777.2">You should use this when applying multiple cloud-config files in a specific order. </span><span class="koboSpan" id="kobo.777.3">Their order in the list influences when they </span><span class="No-Break"><span class="koboSpan" id="kobo.778.1">are applied.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">cloud-config-jsonp</span></strong><span class="koboSpan" id="kobo.780.1">: This content type allows you to write </span><strong class="bold"><span class="koboSpan" id="kobo.781.1">JSON with Padding</span></strong><span class="koboSpan" id="kobo.782.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.783.1">JSONP</span></strong><span class="koboSpan" id="kobo.784.1">) responses. </span><span class="koboSpan" id="kobo.784.2">JSONP is</span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.785.1"> commonly used to bypass web browser cross-domain policies. </span><span class="koboSpan" id="kobo.785.2">You might use this content type if you’re writing a web app that needs to interact with a server on a different domain and uses JSONP to circumvent the </span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">same-origin policy.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.787.1">The full capabilities of cloud config are beyond the scope of this book, but I encourage you to explore them in more detail through online documentation. </span><span class="koboSpan" id="kobo.787.2">The following configuration demonstrates how we can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">cloud init</span></strong><span class="koboSpan" id="kobo.789.1"> to generate a user, a group, assign the user to the group, and set up permissions and settings for </span><span class="No-Break"><span class="koboSpan" id="kobo.790.1">the machine:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.791.1">
    #cloud-config
    groups:
      - bar
    users:
      - name: foo
        groups: sudo, bar
        shell: /bin/bash
        sudo: ['ALL=(ALL) NOPASSWD:ALL']
        ssh_authorized_keys:
          - ssh-rsa your-public-key</span></pre> <p><span class="koboSpan" id="kobo.792.1">We can embed this in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">cloudinit_config</span></strong><span class="koboSpan" id="kobo.794.1"> data source to generate the user data we pass to a newly created </span><span class="No-Break"><span class="koboSpan" id="kobo.795.1">virtual machine:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.796.1">
    data "cloudinit_config" "foo" {
      gzip          = false
      base64_encode = false
      part {
        content_type = "text/cloud-config"
        con</span><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.797.1">tent      = file("${path.module}/users.yaml")
      }
    }</span></pre> <h2 id="_idParaDest-87"><a id="_idTextAnchor233"/><span class="koboSpan" id="kobo.798.1">Configuring DNS records</span></h2>
<p><span class="koboSpan" id="kobo.799.1">Managing </span><strong class="bold"><span class="koboSpan" id="kobo.800.1">Domain Name System</span></strong><span class="koboSpan" id="kobo.801.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.802.1">DNS</span></strong><span class="koboSpan" id="kobo.803.1">) using</span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.804.1"> automation is critical to specific release </span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.805.1">strategies such as blue-green deployment. </span><span class="koboSpan" id="kobo.805.2">Terraform provides an extensible framework that can easily handle such </span><span class="No-Break"><span class="koboSpan" id="kobo.806.1">essential configurations.</span></span></p>
<p><span class="koboSpan" id="kobo.807.1">While most cloud providers offer their own DNS services, from Amazon’s Route 53 to Azure’s Private DNS zones, there is usually a first-party solution for managing DNS on the cloud of your choice. </span><span class="koboSpan" id="kobo.807.2">Several third-party providers for public DNS registrars have DNS service offerings such as Cloudflare, Akamai, GoDaddy, </span><span class="No-Break"><span class="koboSpan" id="kobo.808.1">and DynDNS.</span></span></p>
<p><span class="koboSpan" id="kobo.809.1">However, because Terraform offers such an extensible foundation, managing DNS is not limited to public cloud platforms through their respective providers. </span><span class="koboSpan" id="kobo.809.2">You can also manage your on-premises DNS servers or any custom DNS infrastructure built using infrastructure as a service in your chosen public or </span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">private clouds.</span></span></p>
<p><span class="koboSpan" id="kobo.811.1">You can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">DNS</span></strong><span class="koboSpan" id="kobo.813.1"> provider with any DNS server that supports either the secret</span><a id="_idTextAnchor234"/><span class="koboSpan" id="kobo.814.1"> key (</span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">RFC 2845</span></strong><span class="koboSpan" id="kobo.816.1">) or GSS-TSIG (</span><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">RFC 3645</span></strong><span class="koboSpan" id="kobo.818.1">) </span><span class="No-Break"><span class="koboSpan" id="kobo.819.1">authentication method.</span></span></p>
<h1 id="_idParaDest-88"><a id="_idTextAnchor235"/><span class="koboSpan" id="kobo.820.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.821.1">In this chapter, we looked in depth at the utility providers that HashiCorp has built to help us augment our IaC solutions. </span><span class="koboSpan" id="kobo.821.2">We learned how to integrate with external systems, work with assets stored on the filesystem, and randomize and fill in whitespace within Terraform. </span><span class="koboSpan" id="kobo.821.3">These Terraform providers are incredibly versatile, and as you explore them more, you will find them more and </span><span class="No-Break"><span class="koboSpan" id="kobo.822.1">more valuable.</span></span></p>
<p><span class="koboSpan" id="kobo.823.1">As you would when using other providers, always reference the provider in your </span><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">required_providers</span></strong><span class="koboSpan" id="kobo.825.1"> block with an explicit version number. </span><span class="koboSpan" id="kobo.825.2">Do not implicitly take the latest. </span><span class="koboSpan" id="kobo.825.3">Other than that, resources from these providers can be embedded in any Terraform module. </span><span class="koboSpan" id="kobo.825.4">Take special care when designing reusable modules to ensure you have minimal provider requirements on upstream client modules, as this can add additional complexity to users who hope to reuse your module when it requires a dozen different providers to </span><span class="No-Break"><span class="koboSpan" id="kobo.826.1">be declared!</span></span></p>
<p><span class="koboSpan" id="kobo.827.1">In the next chapter, we will establish some architectural concepts we can apply to our IaC, no matter the cloud platform we target. </span><span class="koboSpan" id="kobo.827.2">After all, our IaC is only as good as the architecture that it defines. </span><span class="koboSpan" id="kobo.827.3">Therefore, we must have a sound understanding of the typical elements of cloud service anatomy and the mechanics of different computational paradigms such as virtual machines and containers. </span><span class="koboSpan" id="kobo.827.4">So, next, we’ll look at virtual machine architecture through a </span><span class="No-Break"><span class="koboSpan" id="kobo.828.1">multi-cloud lens.</span></span></p>
</div>


<div class="Content" id="_idContainer036">
<h1 id="_idParaDest-89" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor236"/><span class="koboSpan" id="kobo.1.1">Part 2: Concepts of Cloud Architecture and Automation</span></h1>
<p><span class="koboSpan" id="kobo.2.1">Without a solid foundation in cloud architecture and software development processes, the journey into Infrastructure as Code would be a futile one. </span><span class="koboSpan" id="kobo.2.2">Luckily, many of these concepts transcend cloud platforms, and once you understand the key concepts, you’ll be ready to apply that knowledge within the cloud of your choice—be it AWS, Azure, </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">or GCP.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B21183_04.xhtml#_idTextAnchor239"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 4</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Foundations of Cloud Architecture – Virtual Machines and Infrastructure-as-a-Service</span></em></li>
<li><a href="B21183_05.xhtml#_idTextAnchor278"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Beyond VMs – Core Concepts of Containers and Kubernetes</span></em></li>
<li><a href="B21183_06.xhtml#_idTextAnchor330"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 6</span></em></a><span class="koboSpan" id="kobo.13.1">, </span><a id="_idTextAnchor237"/><a id="_idTextAnchor238"/><em class="italic"><span class="koboSpan" id="kobo.14.1">Connecting It All Together – GitFlow, GitOps, and </span></em><em class="italic"><span class="koboSpan" id="kobo.15.1">CI/CD</span></em></li>
</ul>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer037">
</div>
</div>
</body></html>