<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Managing Resources and Files"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Managing Resources and Files</h1></div></div></div><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><span class="emphasis"><em>"The art of simplicity is a puzzle of complexity".</em></span></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<span class="attribution">Douglas Horton</span></td></tr></table></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Distributing cron jobs efficiently</li><li class="listitem" style="list-style-type: disc">Scheduling when resources are applied</li><li class="listitem" style="list-style-type: disc">Using host resources</li><li class="listitem" style="list-style-type: disc">Using exported host resources</li><li class="listitem" style="list-style-type: disc">Using multiple file sources</li><li class="listitem" style="list-style-type: disc">Distributing and merging directory trees</li><li class="listitem" style="list-style-type: disc">Cleaning up old files</li><li class="listitem" style="list-style-type: disc">Auditing resources</li><li class="listitem" style="list-style-type: disc">Temporarily disabling resources</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec75"/>Introduction</h1></div></div></div><p>In the previous chapter, we introduced virtual and exported resources. Virtual and exported resources are ways to manage the way in which resources are applied to a node. In this chapter, we will deal with when and how to apply resources. In some cases, you may only wish to apply a resource off hours, while in others, you may wish to only audit the resource but change nothing. In other cases, you may wish to apply completely different resources based on which node is using the code. As we will see, Puppet has the flexibility to deal with all these scenarios.</p></div></div>
<div class="section" title="Distributing cron jobs efficiently"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec76"/>Distributing cron jobs efficiently</h1></div></div></div><p>When you have many<a id="id410" class="indexterm"/> servers executing the same cron job, it's usually a good idea not to run them all at the same time. If all the jobs access a common server (for example, when running backups), it may put too much load on that server, and even if they don't, all the servers will be busy at the same time, which may affect their capacity to provide other services.</p><p>As usual, Puppet can help; this time, using the <code class="literal">inline_template</code> function<a id="id411" class="indexterm"/> to calculate a unique time for each job.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec211"/>How to do it...</h2></div></div></div><p>Here's how to have Puppet schedule the same job at a different time for each machine:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Modify your <code class="literal">site.pp</code> file as follows:<div class="informalexample"><pre class="programlisting">node 'cookbook' {
  cron { 'run-backup':
    ensure  =&gt; present,
    command =&gt; '/usr/local/bin/backup',
    hour    =&gt; inline_template('&lt;%= @hostname.sum % 24 %&gt;'),
    minute  =&gt; '00',
  }
}</pre></div></li><li class="listitem">Run Puppet:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[root@cookbook ~]# puppet agent -t</strong></span>
<span class="strong"><strong>Info: Caching catalog for cookbook.example.com</strong></span>
<span class="strong"><strong>Info: Applying configuration version '1413730771'</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[cookbook]/Cron[run-backup]/ensure: created</strong></span>
<span class="strong"><strong>Notice: Finished catalog run in 0.11 seconds</strong></span>
</pre></div></li><li class="listitem">Run <code class="literal">crontab</code> to see how the job has been configured:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[root@cookbook ~]# crontab -l</strong></span>
<span class="strong"><strong># HEADER: This file was autogenerated at Sun Oct 19 10:59:32 -0400 2014 by puppet.</strong></span>
<span class="strong"><strong># HEADER: While it can still be managed manually, it is definitely not recommended.</strong></span>
<span class="strong"><strong># HEADER: Note particularly that the comments starting with 'Puppet Name' should</strong></span>
<span class="strong"><strong># HEADER: not be deleted, as doing so could cause duplicate cron jobs.</strong></span>
<span class="strong"><strong># Puppet Name: run-backup</strong></span>
<span class="strong"><strong>0 15 * * * /usr/local/bin/backup</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec212"/>How it works...</h2></div></div></div><p>We want to <a id="id412" class="indexterm"/>distribute the hour of the cron job runs across all our nodes. We choose something that is unique across all the machines and convert it to a number. This way, the value will be distributed across the nodes and will not change per node.</p><p>We can do the conversion using Ruby's <code class="literal">sum</code> method, which computes a numerical value from a string that is unique to the machine (in this case, the machine's hostname). The <code class="literal">sum</code> function will generate a large integer (in the case of the string <code class="literal">cookbook</code>, the sum is 855), and we want values for <code class="literal">hour</code> between 0 and 23, so we use Ruby's <code class="literal">%</code> (modulo) operator to restrict the result to this range. We should get a reasonably good (though not statistically uniform) distribution of values, depending on your hostnames. Another option here is to use the <code class="literal">fqdn_rand()</code> function, which works<a id="id413" class="indexterm"/> in much the same way as our example.</p><p>If all your machines have the same name (it does happen), don't expect this trick to work! In this case, you can use some other string that is unique to the machine, such as <code class="literal">ipaddress</code> or <code class="literal">fqdn</code>.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec213"/>There's more...</h2></div></div></div><p>If you have several cron jobs per machine and you want to run them a certain number of hours apart, add this number to the <code class="literal">hostname.sum</code> resource before taking the modulus. Let's say we want to run the <code class="literal">dump_database</code> job at some arbitrary time and the <code class="literal">run_backup</code> job an hour later, this can be done using the following code snippet:</p><div class="informalexample"><pre class="programlisting">cron { 'dump-database':
  ensure  =&gt; present,
  command =&gt; '/usr/local/bin/dump_database',
  hour    =&gt; inline_template('&lt;%= @hostname.sum % 24 %&gt;'),
  minute  =&gt; '00',
}

cron { 'run-backup':
  ensure  =&gt; present,
  command =&gt; '/usr/local/bin/backup',
  hour    =&gt; inline_template('&lt;%= ( @hostname.sum + 1) % 24 %&gt;'),
  minute  =&gt; '00',
}</pre></div><p>The two jobs will end up with different <code class="literal">hour</code> values for each machine Puppet runs on, but <code class="literal">run_backup</code> will always be one hour after <code class="literal">dump_database</code>.</p><p>Most cron implementations have directories for hourly, daily, weekly, and monthly tasks. The directories <code class="literal">/etc/cron.hourly</code>, <code class="literal">/etc/cron.daily</code>, <code class="literal">/etc/cron.weekly</code>, and <code class="literal">/etc/cron.monthly</code> exist on both our Debian and Enterprise Linux machines. These directories hold executables, which will be run on the referenced schedule (hourly, daily, weekly, or monthly). I find it better to describe all the jobs in these folders and push the jobs as <code class="literal">file</code> resources. An <a id="id414" class="indexterm"/>admin on the box searching for your script will be able to find it with <code class="literal">grep</code> in these directories. To use the same trick here, we would push a cron task into <code class="literal">/etc/cron.hourly</code> and then verify that the hour is the correct hour for the task to run. To create the cron jobs using the cron directories, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, create a <code class="literal">cron</code> class in <code class="literal">modules/cron/init.pp</code>:<div class="informalexample"><pre class="programlisting">class cron {
  file { '/etc/cron.hourly/run-backup':
    content =&gt; template('cron/run-backup'),
    mode    =&gt; 0755,
  }
}</pre></div></li><li class="listitem">Include the <code class="literal">cron</code> class in your cookbook node in <code class="literal">site.pp</code>:<div class="informalexample"><pre class="programlisting">node cookbook {
  include cron
}</pre></div></li><li class="listitem">Create a template to hold the cron task:<div class="informalexample"><pre class="programlisting">#!/bin/bash

runhour=&lt;%= @hostname.sum%24 %&gt;
hour=$(date +%H)
if [ "$runhour" -ne "$hour" ]; then
  exit 0
fi

echo run-backup</pre></div></li><li class="listitem">Then, run Puppet:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[root@cookbook ~]# puppet agent -t</strong></span>
<span class="strong"><strong>Info: Caching catalog for cookbook.example.com</strong></span>
<span class="strong"><strong>Info: Applying configuration version '1413732254'</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Cron/File[/etc/cron.hourly/run-backup]/ensure: defined content as '{md5}5e50a7b586ce774df23301ee72904dda'</strong></span>
<span class="strong"><strong>Notice: Finished catalog run in 0.11 seconds</strong></span>
</pre></div></li><li class="listitem">Verify that the script has the same value we calculated before, <code class="literal">15</code>:<div class="informalexample"><pre class="programlisting">#!/bin/bash

runhour=15
hour=$(date +%H)
if [ "$runhour" -ne "$hour" ]; then
  exit 0
fi

echo run-backup</pre></div></li></ol></div><p>Now, this job will run every hour but only when the hour, returned by <code class="literal">$(date +%H)</code>, is equal to <code class="literal">15</code> will the rest of the script run. Creating your cron jobs as file resources in a large organization makes it easier for your fellow administrators to find them. When you have a very large number of machines, it can be advantageous to add another random wait at the beginning of your job. You would need to modify the line before <code class="literal">echo run-backup</code> and add the following:</p><div class="informalexample"><pre class="programlisting">MAXWAIT=600
sleep $((RANDOM%MAXWAIT))</pre></div><p>This will sleep a<a id="id415" class="indexterm"/> maximum of <code class="literal">600</code> seconds but will sleep a different amount each time it runs (assuming your random number generator is working). This sort of random wait is useful when you have thousands of machines, all running the same task and you need to stagger the runs as much as possible.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec214"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Running Puppet from cron</em></span> recipe in <a class="link" href="ch02.html" title="Chapter 2. Puppet Infrastructure">Chapter 2</a>, <span class="emphasis"><em>Puppet Infrastructure</em></span></li></ul></div></div></div>
<div class="section" title="Scheduling when resources are applied"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec77"/>Scheduling when resources are applied</h1></div></div></div><p>So far, we looked at what Puppet can do, and the order that it does things in, but not when it does them. One way to control <a id="id416" class="indexterm"/>this is to use the <code class="literal">schedule</code> metaparameter. When you need to limit the number of times a resource is applied within a specified period, <code class="literal">schedule</code> can help. For example:</p><div class="informalexample"><pre class="programlisting">exec { "/usr/bin/apt-get update":
    schedule =&gt; daily,
}</pre></div><p>The most important thing to understand about <code class="literal">schedule</code> is that it can only stop a resource being applied. It doesn't guarantee that the resource will be applied with a certain frequency. For example, the <code class="literal">exec</code> resource shown in the preceding code snippet has <code class="literal">schedule =&gt; daily</code>, but this just represents an upper limit on the number of times the <code class="literal">exec</code> resource can run per day. It won't be applied more than once a day. If you don't run Puppet at all, the resource won't be applied at all. Using the hourly schedule, for instance, is meaningless on a machine configured to run the agent every 4 hours (via the <code class="literal">runinterval</code> configuration setting).</p><p>That being said, <code class="literal">schedule</code> is best used to restrict resources from running when they shouldn't, or don't need to; for example, you might want to make sure that <code class="literal">apt-get update</code> isn't run more than once an hour. There are some built-in schedules available for you to use:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">hourly</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">daily</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">weekly</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">monthly</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">never</code></li></ul></div><p>However, you can modify these and create your own custom schedules, using the <code class="literal">schedule</code> resource. We'll see how to do this in the following example. Let's say we want to make sure that an <code class="literal">exec</code> resource representing a maintenance job won't run during office hours, when it might interfere with production.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec215"/>How to do it...</h2></div></div></div><p>In this example, we'll create a <a id="id417" class="indexterm"/>custom <code class="literal">schedule</code> resource and assign this to the resource:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Modify your <code class="literal">site.pp</code> file as follows:<div class="informalexample"><pre class="programlisting">schedule { 'outside-office-hours':
  period =&gt; daily,
  range  =&gt; ['17:00-23:59','00:00-09:00'],
  repeat =&gt; 1,
}
node 'cookbook' {
  notify { 'Doing some maintenance':
    schedule =&gt; 'outside-office-hours',
  }
}</pre></div></li><li class="listitem">Run Puppet. What you'll see will depend on the time of the day. If it's currently outside the office hours period you defined, Puppet will apply the resource as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[root@cookbook ~]# date</strong></span>
<span class="strong"><strong>Fri Jan  2 23:59:01 PST 2015</strong></span>
<span class="strong"><strong>[root@cookbook ~]# puppet agent -t</strong></span>
<span class="strong"><strong>Info: Caching catalog for cookbook.example.com</strong></span>
<span class="strong"><strong>Info: Applying configuration version '1413734477'</strong></span>
<span class="strong"><strong>Notice: Doing some maintenance</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[cookbook]/Notify[Doing some maintenance]/message: defined 'message' as 'Doing some maintenance'</strong></span>
<span class="strong"><strong>Notice: Finished catalog run in 0.07 seconds</strong></span>
</pre></div></li><li class="listitem">If the time is within the office hours period, Puppet will do nothing:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[root@cookbook ~]# date</strong></span>
<span class="strong"><strong>Fri Jan  2 09:59:01 PST 2015</strong></span>
<span class="strong"><strong>[root@cookbook ~]# puppet agent -t</strong></span>
<span class="strong"><strong>Info: Caching catalog for cookbook.example.com</strong></span>
<span class="strong"><strong>Info: Applying configuration version '1413734289'</strong></span>
<span class="strong"><strong>Notice: Finished catalog run in 0.09 seconds</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec216"/>How it works...</h2></div></div></div><p>A schedule consists of three<a id="id418" class="indexterm"/> bits of information:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">period</code> (<code class="literal">hourly</code>, <code class="literal">daily</code>, <code class="literal">weekly</code>, or <code class="literal">monthly</code>)</li><li class="listitem" style="list-style-type: disc">The <code class="literal">range</code> (defaults to the whole period, but can be a smaller part of it)</li><li class="listitem" style="list-style-type: disc">The <code class="literal">repeat</code> count (how often the resource is allowed to be applied within the range; the default is 1 or once per period)</li></ul></div><p>Our custom schedule named <code class="literal">outside-office-hours</code> supplies these three parameters:</p><div class="informalexample"><pre class="programlisting">schedule { 'outside-office-hours':
  period =&gt; daily,
  range  =&gt; ['17:00-23:59','00:00-09:00'],
  repeat =&gt; 1,
}</pre></div><p>The <code class="literal">period</code> is <code class="literal">daily</code>, and <code class="literal">range</code> is defined as an array of two time intervals:</p><div class="informalexample"><pre class="programlisting">17:00-23:59
00:00-09:00</pre></div><p>The schedule named <code class="literal">outside-office-hours</code> is now available for us to use with any resource, just as though it were built into Puppet such as the <code class="literal">daily</code> or <code class="literal">hourly</code> schedules. In our example, we assign this schedule to the <code class="literal">exec</code> resource using the <code class="literal">schedule</code> metaparameter:</p><div class="informalexample"><pre class="programlisting">notify { 'Doing some maintenance':
  schedule =&gt; 'outside-office-hours',
}</pre></div><p>Without this <code class="literal">schedule</code> parameter, the resource would be applied every time Puppet runs. With it, Puppet will check the following parameters to decide whether or not to apply the resource:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Whether the time is in the permitted range</li><li class="listitem" style="list-style-type: disc">Whether the resource has already been run the maximum permitted number of times in this period</li></ul></div><p>For example, let's consider what happens if Puppet runs at 4 p.m., 5 p.m., and 6 p.m. on a given day:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>4 p.m.</strong></span>: It's outside <a id="id419" class="indexterm"/>the permitted time range, so Puppet will do nothing</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>5 p.m.</strong></span>: It's inside the permitted time range, and the resource hasn't been run yet in this period, so Puppet will apply the resource</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>6 p.m.</strong></span>: It's inside the permitted time range, but the resource has already been run the maximum number of times in this period, so Puppet will do nothing</li></ul></div><p>And so on until the next day.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec217"/>There's more...</h2></div></div></div><p>The <code class="literal">repeat</code> parameter<a id="id420" class="indexterm"/> governs how many times the resource will be applied given the other constraints of the schedule. For example, to apply a resource no more than six times an hour, use a schedule as follows:</p><div class="informalexample"><pre class="programlisting">period =&gt; hourly,
repeat =&gt; 6,</pre></div><p>Remember that this won't guarantee that the job is run six times an hour. It just sets an upper limit; no matter how often Puppet runs or anything else happens, the job won't be run if it has already run six times this hour. If Puppet only runs once a day, the job will just be run once. So <code class="literal">schedule</code> is best used to make sure things don't happen at certain times (or don't exceed a given frequency).</p></div></div>
<div class="section" title="Using host resources"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec78"/>Using host resources</h1></div></div></div><p>It's not always <a id="id421" class="indexterm"/>practical or convenient to use DNS to map your machine names to IP addresses, especially in cloud infrastructures, where those addresses may change all the time. However, if you use entries in the <code class="literal">/etc/hosts</code> file instead, you then have the problem of how to distribute these entries to all machines and keep them up to date.</p><p>Here's a better way to do it; Puppet's host resource type controls a single <code class="literal">/etc/hosts</code> entry, and you can use this to map a hostname to an IP address easily across your whole network. For example, if all your machines need to know the address of the main database server, you can manage it with a <code class="literal">host</code> resource.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec218"/>How to do it...</h2></div></div></div><p>Follow these steps to create an example <code class="literal">host</code> resource:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Modify your <code class="literal">site.pp</code> file as follows:<div class="informalexample"><pre class="programlisting">node 'cookbook' {
  host { 'packtpub.com':
    ensure =&gt; present,
    ip     =&gt; '83.166.169.231',
  }
}</pre></div></li><li class="listitem">Run Puppet:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[root@cookbook ~]# puppet agent -t</strong></span>
<span class="strong"><strong>Info: Caching catalog for cookbook.example.com</strong></span>
<span class="strong"><strong>Info: Applying configuration version '1413781153'</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[cookbook]/Host[packtpub.com]/ensure: created</strong></span>
<span class="strong"><strong>Info: Computing checksum on file /etc/hosts</strong></span>
<span class="strong"><strong>Notice: Finished catalog run in 0.12 seconds</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec219"/>How it works...</h2></div></div></div><p>Puppet will check <a id="id422" class="indexterm"/>the <code class="literal">target</code> file (usually <code class="literal">/etc/hosts</code>) to see whether the host entry already exists, and if not, add it. If an entry for that hostname already exists with a different address, Puppet will change the address to match the manifest.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec220"/>There's more...</h2></div></div></div><p>Organizing your host resources into classes can be helpful. For example, you could put the host resources for all your DB servers into one class called <code class="literal">admin::dbhosts</code>, which is included by all web servers.</p><p>Where machines may need to be defined in multiple classes (for example, a database server might also be a repository server), virtual resources can solve this problem. For example, you could define all your hosts as virtual in a single class:</p><div class="informalexample"><pre class="programlisting">class admin::allhosts {
  @host { 'db1.packtpub.com':
    tag =&gt; 'database'
    ...
  }
}</pre></div><p>You could then<a id="id423" class="indexterm"/> realize the hosts you need in the various classes:</p><div class="informalexample"><pre class="programlisting">class admin::dbhosts {
  Host &lt;| tag=='database' |&gt;
}

class admin::webhosts {
  Host &lt;| tag=='web' |&gt;
}</pre></div></div></div>
<div class="section" title="Using exported host resources"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec79"/>Using exported host resources</h1></div></div></div><p>In the previous example, we <a id="id424" class="indexterm"/>used the spaceship syntax to collect virtual host resources for hosts of type database or type web. You can use the same trick with exported resources. The advantage to using exported resources is that as you add more database servers, the collector syntax will automatically pull in the newly created exported host entries for those servers. This makes your <code class="literal">/etc/hosts</code> entries more dynamic.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec221"/>Getting ready</h2></div></div></div><p>We will be using exported resources. If you haven't already done so, set up puppetdb and enable storeconfigs to use puppetdb as outlined in <a class="link" href="ch02.html" title="Chapter 2. Puppet Infrastructure">Chapter 2</a>, <span class="emphasis"><em>Puppet Infrastructure</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec222"/>How to do it...</h2></div></div></div><p>In this example, we will configure database servers and clients to communicate with each other. We'll make use of exported resources to do the configuration.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new database module, <code class="literal">db</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>t@mylaptop ~/puppet/modules $ mkdir -p db/manifests</strong></span>
</pre></div></li><li class="listitem">Create a new class for your database servers, <code class="literal">db::server</code>:<div class="informalexample"><pre class="programlisting">class db::server {
  @@host {"$::fqdn":
    host_aliases =&gt; $::hostname,
    ip           =&gt; $::ipaddress,
    tag          =&gt; 'db::server',
  }
  # rest of db class
}</pre></div></li><li class="listitem">Create a new class for your database clients:<div class="informalexample"><pre class="programlisting">class db::client {
  Host &lt;&lt;| tag == 'db::server' |&gt;&gt;
}</pre></div></li><li class="listitem">Apply the database server module to some nodes, in <code class="literal">site.pp</code>, for example:<div class="informalexample"><pre class="programlisting">node 'dbserver1.example.com' {
  class {'db::server': }
}
node 'dbserver2.example.com' {
  class {'db::server': }
}</pre></div></li><li class="listitem">Run Puppet on the nodes <a id="id425" class="indexterm"/>with the database server module to create the exported resources.</li><li class="listitem">Apply the database client module to cookbook:<div class="informalexample"><pre class="programlisting">node 'cookbook' {
  class {'db::client': }
}</pre></div></li><li class="listitem">Run Puppet:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[root@cookbook ~]# puppet agent -t</strong></span>
<span class="strong"><strong>Info: Caching catalog for cookbook.example.com</strong></span>
<span class="strong"><strong>Info: Applying configuration version '1413782501'</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Db::Client/Host[dbserver2.example.com]/ensure: created</strong></span>
<span class="strong"><strong>Info: Computing checksum on file /etc/hosts</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Db::Client/Host[dbserver1.example.com]/ensure: created</strong></span>
<span class="strong"><strong>Notice: Finished catalog run in 0.10 seconds</strong></span>
</pre></div></li><li class="listitem">Verify the host entries in <code class="literal">/etc/hosts</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[root@cookbook ~]# cat /etc/hosts</strong></span>
<span class="strong"><strong># HEADER: This file was autogenerated at Mon Oct 20 01:21:42 -0400 2014</strong></span>
<span class="strong"><strong># HEADER: by puppet.  While it can still be managed manually, it</strong></span>
<span class="strong"><strong># HEADER: is definitely not recommended.</strong></span>
<span class="strong"><strong>127.0.0.1	localhost  localhost.localdomain localhost4 localhost4.localdomain4 </strong></span>
<span class="strong"><strong>::1  localhost  localhost.localdomain localhost6 localhost6.localdomain6</strong></span>
<span class="strong"><strong>83.166.169.231  packtpub.com</strong></span>
<span class="strong"><strong>192.168.122.150  dbserver2.example.com  dbserver2</strong></span>
<span class="strong"><strong>192.168.122.151  dbserver1.example.com  dbserver1</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec223"/>How it works...</h2></div></div></div><p>In the <code class="literal">db::server</code> class, we <a id="id426" class="indexterm"/>create an exported host resource:</p><div class="informalexample"><pre class="programlisting">@@host {"$::fqdn":
  host_aliases =&gt; $::hostname,
  ip           =&gt; $::ipaddress,
  tag          =&gt; 'db::server',
}</pre></div><p>This resource uses the fully qualified domain name (<code class="literal">$::fqdn</code>) of the node on which it is applied. We also use the short hostname (<code class="literal">$::hostname</code>) as an alias of the node. Aliases are printed after <code class="literal">fqdn</code> in <code class="literal">/etc/hosts</code>. We use the node's <code class="literal">$::ipaddress</code> fact as the IP address for the host entry. Finally, we add a tag to the resource so that we can collect based on that tag later.</p><p>The important thing to remember here is that if the ip address should change for the host, the exported resource will be updated, and nodes that collect the exported resource will update their host records accordingly.</p><p>We created a collector in <code class="literal">db::client</code>, which only collects exported host resources that have been tagged with <code class="literal">'db::server'</code>:</p><div class="informalexample"><pre class="programlisting">Host &lt;&lt;| tag == 'db::server' |&gt;&gt;</pre></div><p>We applied the <code class="literal">db::server</code> class for a couple of nodes, dbserver1 and dbserver2, which we then collected on cookbook by applying the <code class="literal">db::client</code> class. The host entries were placed in <code class="literal">/etc/hosts</code> (the default file). We can see that the host entry contains both the fqdn and the short hostname for dbserver1 and dbserver2.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec224"/>There's more...</h2></div></div></div><p>Using exported resources in this manner is very useful. Another similar system would be to create an NFS server class, which creates exported resources for the mount points that it exports (via NFS). You can then use tags to have clients collect the appropriate mount points from the server. In the previous example, we made use of a tag to aid in our collection of exported resources. It is worth noting that there are several tags automatically added to resources when they are created, one of which is the scope where the resource was created.</p></div></div>
<div class="section" title="Using multiple file sources"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec80"/>Using multiple file sources</h1></div></div></div><p>A neat feature of Puppet's <code class="literal">file</code> resource is that you can specify multiple values for the <code class="literal">source</code> parameter. Puppet will search them in order. If the first source isn't found, it moves on to the next, and so on. You can use this to specify a default substitute if the particular file isn't <a id="id427" class="indexterm"/>present, or even a series of increasingly generic substitutes.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec225"/>How to do it...</h2></div></div></div><p>This example demonstrates using multiple file sources:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new greeting module as follows:<div class="informalexample"><pre class="programlisting">class greeting {
  file { '/tmp/greeting':
    source =&gt; [ 'puppet:///modules/greeting/hello.txt',
                'puppet:///modules/greeting/universal.txt'],
  }
}</pre></div></li><li class="listitem">Create the file <code class="literal">modules/greeting/files/hello.txt</code> with the following contents:<div class="informalexample"><pre class="programlisting">Hello, world.</pre></div></li><li class="listitem">Create the file <code class="literal">modules/greeting/files/universal.txt</code> with the following contents:<div class="informalexample"><pre class="programlisting">Bah-weep-Graaaaagnah wheep ni ni bong</pre></div></li><li class="listitem">Add the class to a node:<div class="informalexample"><pre class="programlisting">node cookbook {
  class {'greeting': }
}</pre></div></li><li class="listitem">Run Puppet:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[root@cookbook ~]# puppet agent -t</strong></span>
<span class="strong"><strong>Info: Caching catalog for cookbook.example.com</strong></span>
<span class="strong"><strong>Info: Applying configuration version '1413784347'</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Greeting/File[/tmp/greeting]/ensure: defined content as '{md5}54098b367d2e87b078671fad4afb9dbb'</strong></span>
<span class="strong"><strong>Notice: Finished catalog run in 0.43 seconds</strong></span>
</pre></div></li><li class="listitem">Check the contents of the <code class="literal">/tmp/greeting</code> file:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[root@cookbook ~]# cat /tmp/greeting </strong></span>
<span class="strong"><strong>Hello, world.</strong></span>
</pre></div></li><li class="listitem">Now remove the <code class="literal">hello.txt</code> file from your Puppet repository and rerun the agent:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[root@cookbook ~]# puppet agent -t</strong></span>
<span class="strong"><strong>Info: Caching catalog for cookbook.example.com</strong></span>
<span class="strong"><strong>Info: Applying configuration version '1413784939'</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Greeting/File[/tmp/greeting]/content: </strong></span>
<span class="strong"><strong>--- /tmp/greeting	2014-10-20 01:52:28.117999991 -0400</strong></span>
<span class="strong"><strong>+++ /tmp/puppet-file20141020-4960-1o9g344-0	2014-10-20 02:02:20.695999979 -0400</strong></span>
<span class="strong"><strong>@@ -1 +1 @@</strong></span>
<span class="strong"><strong>-Hello, world.</strong></span>
<span class="strong"><strong>+Bah-weep-Graaaaagnah wheep ni ni bong</strong></span>

<span class="strong"><strong>Info: Computing checksum on file /tmp/greeting</strong></span>
<span class="strong"><strong>Info: /Stage[main]/Greeting/File[/tmp/greeting]: Filebucketed /tmp/greeting to puppet with sum 54098b367d2e87b078671fad4afb9dbb</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Greeting/File[/tmp/greeting]/content: content changed '{md5}54098b367d2e87b078671fad4afb9dbb' to '{md5}933c7f04d501b45456e830de299b5521'</strong></span>
<span class="strong"><strong>Notice: Finished catalog run in 0.77 seconds</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec226"/>How it works...</h2></div></div></div><p>On the first Puppet run, puppet searches for <a id="id428" class="indexterm"/>the available file sources in the order given:</p><div class="informalexample"><pre class="programlisting">source =&gt; [
  'puppet:///modules/greeting/hello.txt',
  'puppet:///modules/greeting/universal.txt'
],</pre></div><p>The file <code class="literal">hello.txt</code> is first in the list, and is present, so Puppet uses that as the source for <code class="literal">/tmp/greeting</code>:</p><div class="informalexample"><pre class="programlisting">Hello, world.</pre></div><p>On the second Puppet run, <code class="literal">hello.txt</code> is missing, so Puppet goes on to look for the next file, <code class="literal">universal.txt</code>. This is present, so it becomes the source for <code class="literal">/tmp/greeting</code>:</p><div class="informalexample"><pre class="programlisting">Bah-weep-Graaaaagnah wheep ni ni bong</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec227"/>There's more...</h2></div></div></div><p>You can use this trick anywhere you<a id="id429" class="indexterm"/> have a <code class="literal">file</code> resource. A common example is a service that is deployed on all nodes, such as rsyslog. The <code class="literal">rsyslog</code> configuration is the same on every host except for the rsyslog server. Create an <code class="literal">rsyslog</code> class with a file resource for the <code class="literal">rsyslog</code> configuration file:</p><div class="informalexample"><pre class="programlisting">class rsyslog {
  file { '/etc/rsyslog.conf':
    source =&gt; [
      "puppet:///modules/rsyslog/rsyslog.conf.${::hostname}",
      'puppet:///modules/rsyslog/rsyslog.conf' ],
  }</pre></div><p>Then, you put the default configuration in <code class="literal">rsyslog.conf</code>. For your rsyslog server, <code class="literal">logger</code>, create an <code class="literal">rsyslog.conf.logger</code> file. On the machine logger, <code class="literal">rsyslog.conf.logger</code> will be used before <code class="literal">rsyslog.conf</code> because it is listed first in the array of sources.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec228"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Passing parameters to classes</em></span> recipe in <a class="link" href="ch03.html" title="Chapter 3. Writing Better Manifests">Chapter 3</a>, <span class="emphasis"><em>Writing Better Manifests</em></span></li></ul></div></div></div>
<div class="section" title="Distributing and merging directory trees"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec81"/>Distributing and merging directory trees</h1></div></div></div><p>As we saw in the previous chapter, the<a id="id430" class="indexterm"/> file resource has a <code class="literal">recurse</code> parameter, which allows Puppet <a id="id431" class="indexterm"/>to transfer entire directory trees. We used this parameter to copy an admin user's dotfiles into their home directory. In this section, we'll show how to use <code class="literal">recurse</code> and another parameter <code class="literal">sourceselect</code> to extend our previous example.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec229"/>How to do it...</h2></div></div></div><p>Modify our admin user example as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Remove the <code class="literal">$dotfiles</code> parameter, remove the condition based on <code class="literal">$dotfiles</code>. Add a second source to the home directory <code class="literal">file</code> resource:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>define admin_user ($key, $keytype) { </strong></span>
<span class="strong"><strong>  $username = $name</strong></span>
<span class="strong"><strong>  user { $username:</strong></span>
<span class="strong"><strong>    ensure     =&gt; present,</strong></span>
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>  file { "/home/${username}/.ssh":</strong></span>
<span class="strong"><strong>    ensure  =&gt; directory,</strong></span>
<span class="strong"><strong>    mode    =&gt; '0700',</strong></span>
<span class="strong"><strong>    owner   =&gt; $username,</strong></span>
<span class="strong"><strong>    group   =&gt; $username,</strong></span>
<span class="strong"><strong>    require =&gt; File["/home/${username}"],</strong></span>
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>  ssh_authorized_key { "${username}_key":</strong></span>
<span class="strong"><strong>    key     =&gt; $key,</strong></span>
<span class="strong"><strong>    type    =&gt; "$keytype",</strong></span>
<span class="strong"><strong>    user    =&gt; $username,</strong></span>
<span class="strong"><strong>    require =&gt; File["/home/${username}/.ssh"],</strong></span>
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>  # copy in all the files in the subdirectory</strong></span>
<span class="strong"><strong>  file { "/home/${username}":</strong></span>
<span class="strong"><strong>    recurse =&gt; true,</strong></span>
<span class="strong"><strong>    mode    =&gt; '0700',</strong></span>
<span class="strong"><strong>    owner   =&gt; $username,</strong></span>
<span class="strong"><strong>    group   =&gt; $username,</strong></span>
<span class="strong"><strong>    source  =&gt; [</strong></span>
<span class="strong"><strong>      "puppet:///modules/admin_user/${username}",</strong></span>
<span class="strong"><strong>      'puppet:///modules/admin_user/base' ],</strong></span>
<span class="strong"><strong>    sourceselect =&gt; 'all',</strong></span>
<span class="strong"><strong>    require      =&gt; User["$username"],</strong></span>
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div></li><li class="listitem">Create a<a id="id432" class="indexterm"/> base directory and<a id="id433" class="indexterm"/> copy all the system default files from <code class="literal">/etc/skel</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>t@mylaptop ~/puppet/modules/admin_user/files $ cp -a /etc/skel base</strong></span>
</pre></div></li><li class="listitem">Create a new <code class="literal">admin_user</code> resource, one that will not have a directory defined:<div class="informalexample"><pre class="programlisting">node 'cookbook' {
  admin_user {'steven':
    key     =&gt; 'AAAAB3N...',
    keytype =&gt; 'dsa',
  }
}</pre></div></li><li class="listitem">Run Puppet:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[root@cookbook ~]# puppet agent -t</strong></span>
<span class="strong"><strong>Info: Caching catalog for cookbook.example.com</strong></span>
<span class="strong"><strong>Info: Applying configuration version '1413787159'</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[cookbook]/Admin_user[steven]/User[steven]/ensure: created</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[cookbook]/Admin_user[steven]/File[/home/steven]/ensure: created</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[cookbook]/Admin_user[steven]/File[/home/steven/.bash_logout]/ensure: defined content as '{md5}6a5bc1cc5f80a48b540bc09d082b5855'</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[cookbook]/Admin_user[steven]/File[/home/steven/.emacs]/ensure: defined content as '{md5}de7ee35f4058681a834a99b5d1b048b3'</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[cookbook]/Admin_user[steven]/File[/home/steven/.bashrc]/ensure: defined content as '{md5}2f8222b4f275c4f18e69c34f66d2631b'</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[cookbook]/Admin_user[steven]/File[/home/steven/.bash_profile]/ensure: defined content as '{md5}f939eb71a81a9da364410b799e817202'</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[cookbook]/Admin_user[steven]/File[/home/steven/.ssh]/ensure: created</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[cookbook]/Admin_user[steven]/Ssh_authorized_key[steven_key]/ensure: created</strong></span>
<span class="strong"><strong>Notice: Finished catalog run in 1.11 seconds</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec230"/>How it works...</h2></div></div></div><p>If a <code class="literal">file</code> resource <a id="id434" class="indexterm"/>has the <code class="literal">recurse</code> parameter set on it, and it is a directory, Puppet will deploy not only the<a id="id435" class="indexterm"/> directory itself, but all its contents (including subdirectories and their contents). As we saw in the previous example, when a file has more than one source, the first source file found is used to satisfy the request. This applies to directories as well.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec231"/>There's more...</h2></div></div></div><p>By specifying the <a id="id436" class="indexterm"/>parameter <code class="literal">sourceselect</code> as 'all', the contents of all the source<a id="id437" class="indexterm"/> directories will be combined. For example, add <code class="literal">thomas admin_user</code> back into your node definition in <code class="literal">site.pp</code> for cookbook:</p><div class="informalexample"><pre class="programlisting">admin_user {'thomas':
    key     =&gt; 'ABBA...',
    keytype =&gt; 'rsa',
  }</pre></div><p>Now run Puppet again on cookbook:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[root@cookbook thomas]# puppet agent -t</strong></span>
<span class="strong"><strong>Info: Caching catalog for cookbook.example.com</strong></span>
<span class="strong"><strong>Info: Applying configuration version '1413787770'</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[cookbook]/Admin_user[thomas]/File[/home/thomas/.bash_profile]/content: content changed '{md5}3e8337f44f84b298a8a99869ae8ca76a' to '{md5}f939eb71a81a9da364410b799e817202'</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[cookbook]/Admin_user[thomas]/File[/home/thomas/.bash_profile]/group: group changed 'root' to 'thomas'</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[cookbook]/Admin_user[thomas]/File[/home/thomas/.bash_profile]/mode: mode changed '0644' to '0700'</strong></span>
<span class="strong"><strong>Notice: /File[/home/thomas/.bash_profile]/seluser: seluser changed 'system_u' to 'unconfined_u'</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[cookbook]/Admin_user[thomas]/File[/home/thomas/.bash_logout]/ensure: defined content as '{md5}6a5bc1cc5f80a48b540bc09d082b5855'</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[cookbook]/Admin_user[thomas]/File[/home/thomas/.bashrc]/content: content changed '{md5}db2a20b2b9cdf36cca1ca4672622ddd2' to '{md5}033c3484e4b276e0641becc3aa268a3a'</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[cookbook]/Admin_user[thomas]/File[/home/thomas/.bashrc]/group: group changed 'root' to 'thomas'</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[cookbook]/Admin_user[thomas]/File[/home/thomas/.bashrc]/mode: mode changed '0644' to '0700'</strong></span>
<span class="strong"><strong>Notice: /File[/home/thomas/.bashrc]/seluser: seluser changed 'system_u' to 'unconfined_u'</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[cookbook]/Admin_user[thomas]/File[/home/thomas/.emacs]/ensure: defined content as '{md5}de7ee35f4058681a834a99b5d1b048b3'</strong></span>
<span class="strong"><strong>Notice: Finished catalog run in 0.86 seconds</strong></span>
</pre></div><p>Because we previously applied the <code class="literal">thomas admin_user</code> to cookbook, the user existed. The two files defined in the <code class="literal">thomas</code> directory on the Puppet server were already in the home directory, so only the additional files, <code class="literal">.bash_logout</code>, <code class="literal">.bash_profile</code>, and <code class="literal">.emacs</code> were created. Using these two parameters together, you can have default files that can be overridden easily.</p><p>Sometimes you want to <a id="id438" class="indexterm"/>deploy files to an existing directory but remove any files which aren't managed by Puppet. A good example would be if you are using <code class="literal">mcollective</code> in <a id="id439" class="indexterm"/>your environment. The directory holding client credentials should only have certificates that come from Puppet.</p><p>The <code class="literal">purge</code> parameter will do this for you. Define the directory as a resource in Puppet:</p><div class="informalexample"><pre class="programlisting">file { '/etc/mcollective/ssl/clients':
  purge   =&gt; true,
  recurse =&gt; true,
}</pre></div><p>The combination of <code class="literal">recurse</code> and <code class="literal">purge</code> will remove all files and subdirectories in <code class="literal">/etc/mcollective/ssl/clients</code> that are not deployed by Puppet. You can then deploy your own files to that location by placing them in the appropriate directory on the Puppet server.</p><p>If there are subdirectories that contain files you don't want to purge, just define the subdirectory as a Puppet resource, and it will be left alone:</p><div class="informalexample"><pre class="programlisting">file { '/etc/mcollective/ssl/clients':
  purge =&gt; true,
  recurse =&gt; true,
}
file { '/etc/mcollective/ssl/clients/local':
  ensure =&gt; directory,
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>Be aware that, at least in current implementations of Puppet, recursive file copies can be quite slow and place a heavy memory load on the server. If the data doesn't change very often, it might be better to deploy and unpack a <code class="literal">tar</code> file instead. This can be done with a file resource for the <code class="literal">tar</code> file and an exec, which requires the file resource and unpacks the archive. Recursive directories are less of a problem when filled with small files. Puppet is not a very efficient file server, so creating large tar files and distributing them with Puppet is not a good idea either. If you need to copy large files around, using the Operating Systems packager is a better solution.</p></div></div></div></div>
<div class="section" title="Cleaning up old files"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec82"/>Cleaning up old files</h1></div></div></div><p>Puppet's <code class="literal">tidy</code> resource will help <a id="id440" class="indexterm"/>you clean up old or out-of-date files, reducing <a id="id441" class="indexterm"/>disk usage. For example, if you have Puppet reporting enabled as described in the section on generating reports, you might want to regularly delete old report files.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec232"/>How to do it...</h2></div></div></div><p>Let's get started.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Modify your <code class="literal">site.pp</code> file as follows:<div class="informalexample"><pre class="programlisting">node 'cookbook' {
  tidy { '/var/lib/puppet/reports':
    age     =&gt; '1w',
    recurse =&gt; true,
  }
}</pre></div></li><li class="listitem">Run Puppet:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[root@cookbook clients]# puppet agent -t</strong></span>
<span class="strong"><strong>Info: Caching catalog for cookbook.example.com</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[cookbook]/File[/var/lib/puppet/reports/cookbook.example.com/201409090637.yaml]/ensure: removed</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[cookbook]/File[/var/lib/puppet/reports/cookbook.example.com/201409100556.yaml]/ensure: removed</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[cookbook]/File[/var/lib/puppet/reports/cookbook.example.com/201409090631.yaml]/ensure: removed</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[cookbook]/File[/var/lib/puppet/reports/cookbook.example.com/201408210557.yaml]/ensure: removed</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[cookbook]/File[/var/lib/puppet/reports/cookbook.example.com/201409080557.yaml]/ensure: removed</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[cookbook]/File[/var/lib/puppet/reports/cookbook.example.com/201409100558.yaml]/ensure: removed</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[cookbook]/File[/var/lib/puppet/reports/cookbook.example.com/201408210546.yaml]/ensure: removed</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[cookbook]/File[/var/lib/puppet/reports/cookbook.example.com/201408210539.yaml]/ensure: removed</strong></span>
<span class="strong"><strong>Notice: Finished catalog run in 0.80 seconds</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec233"/>How it works...</h2></div></div></div><p>Puppet searches the <a id="id442" class="indexterm"/>specified path for any files matching the <code class="literal">age</code> <a id="id443" class="indexterm"/>parameter; in this case, <code class="literal">2w</code> (two weeks). It also searches subdirectories (<code class="literal">recurse =&gt; true</code>).</p><p>Any files matching your criteria will be deleted.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec234"/>There's more...</h2></div></div></div><p>You can specify file ages in seconds, minutes, hours, days, or weeks by using a single character to specify the time unit, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">60s</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">180m</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">24h</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">30d</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">4w</code></li></ul></div><p>You can specify that files greater than a given size should be removed, as follows:</p><div class="informalexample"><pre class="programlisting">size =&gt; '100m',</pre></div><p>This removes files of 100 megabytes and over. For kilobytes, use <code class="literal">k</code>, and for bytes, use <code class="literal">b</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>Note that if you specify both age and size parameters, they are treated as independent criteria. For example, if you specify the following, Puppet will remove all files that are either at least one day old, or at least 512 KB in size:</p><p>age  =&gt; "1d",</p><p>size =&gt; "512k",</p></div></div></div></div>
<div class="section" title="Auditing resources"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec83"/>Auditing resources</h1></div></div></div><p>Dry run mode, using <a id="id444" class="indexterm"/>the <code class="literal">--noop</code> switch, is a simple way to audit any changes to a machine under Puppet's control. However, Puppet also has a dedicated audit feature, which can report changes to resources or specific attributes.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec235"/>How to do it...</h2></div></div></div><p>Here's an example <a id="id445" class="indexterm"/>showing Puppet's auditing capabilities:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Modify your <code class="literal">site.pp</code> file as follows:<div class="informalexample"><pre class="programlisting">node 'cookbook' {
  file { '/etc/passwd':
    audit =&gt; [ owner, mode ],
  }
}</pre></div></li><li class="listitem">Run Puppet:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[root@cookbook clients]# puppet agent -t</strong></span>
<span class="strong"><strong>Info: Caching catalog for cookbook.example.com</strong></span>
<span class="strong"><strong>Info: Applying configuration version '1413789080'</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[cookbook]/File[/etc/passwd]/owner: audit change: newly-recorded value 0</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[cookbook]/File[/etc/passwd]/mode: audit change: newly-recorded value 644</strong></span>
<span class="strong"><strong>Notice: Finished catalog run in 0.55 seconds</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec236"/>How it works...</h2></div></div></div><p>The <code class="literal">audit</code> metaparameter tells Puppet that you want to record and monitor certain things about the resource. The value can be a list of the parameters that you want to audit.</p><p>In this case, when Puppet runs, it will now record the owner and mode of the <code class="literal">/etc/passwd</code> file. In future runs, Puppet will spot whether either of these has changed. For example, if you run:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[root@cookbook ~]# chmod 666 /etc/passwd</strong></span>
</pre></div><p>Puppet will pick up this change and log it on the next run:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[cookbook]/File[/etc/passwd]/mode: audit change: previously recorded value 0644 has been changed to 0666</strong></span>
</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec237"/>There's more...</h2></div></div></div><p>This feature is very useful to audit large networks for any changes to machines, either malicious or accidental. It's also very handy to keep an eye on things that aren't managed by Puppet, for example, application code on production servers. You can read more about Puppet's auditing capability<a id="id446" class="indexterm"/> here:</p><p>
<a class="ulink" href="http://puppetlabs.com/blog/all-about-auditing-with-puppet/">http://puppetlabs.com/blog/all-about-auditing-with-puppet/</a>
</p><p>If you just want to audit everything about a resource, use <code class="literal">all</code>:</p><div class="informalexample"><pre class="programlisting">file { '/etc/passwd':
  audit =&gt; all,
}</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec238"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Noop - the don't change anything option</em></span> recipe in <a class="link" href="ch10.html" title="Chapter 10. Monitoring, Reporting, and Troubleshooting">Chapter 10</a>, <span class="emphasis"><em>Monitoring, Reporting, and Troubleshooting</em></span></li></ul></div></div></div>
<div class="section" title="Temporarily disabling resources"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec84"/>Temporarily disabling resources</h1></div></div></div><p>Sometimes you want <a id="id447" class="indexterm"/>to disable a resource for the time being so that it doesn't interfere with other work. For example, you might want to tweak a configuration file on the server until you have the exact settings you want, before checking it into Puppet. You don't want Puppet to overwrite it with an old version in the meantime, so you can set the <code class="literal">noop</code> metaparameter on the resource:</p><div class="informalexample"><pre class="programlisting">noop =&gt; true,</pre></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec239"/>How to do it...</h2></div></div></div><p>This example shows you how to use the <code class="literal">noop</code> metaparameter:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Modify your <code class="literal">site.pp</code> file as follows:<div class="informalexample"><pre class="programlisting">node 'cookbook' {
  file { '/etc/resolv.conf':
    content =&gt; "nameserver 127.0.0.1\n",
    noop    =&gt; true,
  }
}</pre></div></li><li class="listitem">Run Puppet:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[root@cookbook ~]# puppet agent -t</strong></span>
<span class="strong"><strong>Info: Caching catalog for cookbook.example.com</strong></span>
<span class="strong"><strong>Info: Applying configuration version '1413789438'</strong></span>
<span class="strong"><strong>Notice: /Stage[main]/Main/Node[cookbook]/File[/etc/resolv.conf]/content: </strong></span>
<span class="strong"><strong>--- /etc/resolv.conf  2014-10-20 00:27:43.095999975 -0400</strong></span>
<span class="strong"><strong>+++ /tmp/puppet-file20141020-8439-1lhuy1y-0	2014-10-20 03:17:18.969999979 -0400</strong></span>
<span class="strong"><strong>@@ -1,3 +1 @@  </strong></span>
<span class="strong"><strong>-; generated by /sbin/dhclient-script</strong></span>
<span class="strong"><strong>-search example.com</strong></span>
<span class="strong"><strong>-nameserver 192.168.122.1</strong></span>
<span class="strong"><strong>+nameserver 127.0.0.1</strong></span>

<span class="strong"><strong>Notice: /Stage[main]/Main/Node[cookbook]/File[/etc/resolv.conf]/content: current_value {md5}4c0d192511df253826d302bc830a371b, should be {md5}949343428bded6a653a85910f6bdb48e (noop)</strong></span>
<span class="strong"><strong>Notice: Node[cookbook]: Would have triggered 'refresh' from 1 events</strong></span>
<span class="strong"><strong>Notice: Class[Main]: Would have triggered 'refresh' from 1 events</strong></span>
<span class="strong"><strong>Notice: Stage[main]: Would have triggered 'refresh' from 1 events</strong></span>
<span class="strong"><strong>Notice: Finished catalog run in 0.50 seconds</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec240"/>How it works...</h2></div></div></div><p>The <code class="literal">noop</code> metaparameter is set to <code class="literal">true</code>, so for this particular resource, it's as if you had to run Puppet with the <code class="literal">--noop</code> flag. Puppet noted that the resource would have been applied, but otherwise did nothing.</p><p>The nice thing with running the agent in test mode (<code class="literal">-t</code>) is that Puppet output a diff of what it would have done if the <code class="literal">noop</code> was not present (you can tell puppet to show the diff's without using <code class="literal">-t</code> with <code class="literal">--show_diff</code>; <code class="literal">-t</code> implies many different settings):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>--- /etc/resolv.conf  2014-10-20 00:27:43.095999975 -0400</strong></span>
<span class="strong"><strong>+++ /tmp/puppet-file20141020-8439-1lhuy1y-0	2014-10-20 03:17:18.969999979 -0400</strong></span>
<span class="strong"><strong>@@ -1,3 +1 @@</strong></span>
<span class="strong"><strong>-; generated by /sbin/dhclient-script</strong></span>
<span class="strong"><strong>-search example.com</strong></span>
<span class="strong"><strong>-nameserver 192.168.122.1</strong></span>
<span class="strong"><strong>+nameserver 127.0.0.1</strong></span>
</pre></div><p>This can be very useful when debugging a template; you can work on your changes and then see what they would look like on the node without actually applying them. Using the diff, you can see whether your updated template produces the correct output.</p></div></div></body></html>