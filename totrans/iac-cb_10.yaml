- en: Chapter 10. Maintaining Docker Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章：维护 Docker 容器
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下内容：
- en: Testing Docker containers with BATS
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 BATS 测试 Docker 容器
- en: Test-Driven Development (TDD) with Docker and ServerSpec
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 和 ServerSpec 进行测试驱动开发（TDD）
- en: The workflow for creating automated Docker builds from Git
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Git 创建自动化 Docker 构建的工作流程
- en: The workflow for connecting the Continuous Integration (CI) system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接持续集成（CI）系统的工作流程
- en: Scanning for vulnerabilities with Quay.io and Docker Cloud
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Quay.io 和 Docker Cloud 扫描漏洞
- en: Sending Docker logs to AWS CloudWatch Logs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Docker 日志发送到 AWS CloudWatch Logs
- en: Monitoring and getting information out of Docker
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控和获取 Docker 信息
- en: Debugging containers using sysdig
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 sysdig 调试容器
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we'll explore some advanced and highly interesting areas that
    probably most developers today are already used to. Infrastructure code is still
    code, so it should be no different than software code; the same principle should
    apply. This means that the Docker code should be testable, the builds automatic,
    and the CI systems connected to our Git servers so they could continuously apply
    the tests. In addition to this, security checks should be part of the mandatory
    release process and the logs easy to access, even if the application is scaled
    on multiple machines. Also note that containers shouldn't be black boxes, and
    highly performant debugging tools should be available for us to do our work. The
    good news is that these topics will be covered in this chapter, because all of
    this can be done easily.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索一些高级且非常有趣的领域，这些领域可能是今天大多数开发人员已经习惯的。基础设施代码仍然是代码，因此它应该与软件代码没有什么不同；同样的原则应该适用。这意味着
    Docker 代码应该是可测试的，构建过程是自动的，CI 系统应连接到我们的 Git 服务器，以便它们可以持续执行这些测试。此外，安全检查应该成为强制发布流程的一部分，日志应易于访问，即使应用程序在多台机器上进行了扩展。还要注意，容器不应是黑箱，我们应该拥有高性能的调试工具来帮助我们完成工作。好消息是，这些话题将在本章中覆盖，因为所有这些都可以轻松实现。
- en: Testing Docker containers with BATS
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 BATS 测试 Docker 容器
- en: '**BATS** (**Bash Automated Testing System**) allows you to have quick and easy
    tests in a very natural language, without the need of a lot of dependencies. BATS
    can also grow in complexity as per your requirement. In this section, we''ll use
    Docker with Docker Compose to handle the build and a Makefile to tie the dependencies
    between the build process and the BATS testing process; this will make it easier
    to later integrate this process into a CI system.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**BATS**（**Bash 自动化测试系统**）让你可以用非常自然的语言进行快速简便的测试，无需大量依赖项。根据需求，BATS 也可以随着复杂性增加。在这一部分，我们将使用
    Docker 和 Docker Compose 来处理构建，并使用 Makefile 将构建过程和 BATS 测试过程之间的依赖关系绑定在一起；这样更容易将该过程稍后集成到
    CI 系统中。'
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行此操作，你将需要：
- en: A working Docker installation
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的 Docker 安装
- en: A BATS installation (it's available for all major Linux distributions and Mac
    OS)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BATS 安装（它适用于所有主要的 Linux 发行版和 Mac OS）
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: BATS Version 0.4.0 is used in this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用的是 BATS 版本 0.4.0。
- en: How to do it…
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Let''s start with this simple Dockerfile that will install Apache and run it
    after clearing the cache:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这个简单的 Dockerfile 开始，它将安装 Apache 并在清理缓存后运行它：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For convenience, let''s create a `docker-compose.yml` file so the image can
    be built and run easily:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，让我们创建一个 `docker-compose.yml` 文件，这样就可以轻松构建和运行镜像：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This way, running `docker-compose up` will also build the image if absent.
    Alternatively, to just build the image, use this code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，运行 `docker-compose up` 时，如果镜像不存在，它也会进行构建。或者，如果只想构建镜像，可以使用以下命令：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Creating BATS tests
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 BATS 测试
- en: 'We''ll now test two of the main actions this image is supposed to do:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将测试该镜像应该执行的两项主要操作：
- en: Install Apache 2.4.10
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Apache 2.4.10
- en: Clean the APT cache
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理 APT 缓存
- en: 'Start by creating a `test` folder at the root of our repository that will host
    the BATS tests:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们仓库的根目录创建一个 `test` 文件夹，用于存放 BATS 测试：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Our first test is to verify that the installed version of Apache is `2.4.10`,
    as required. How would we do it manually? We''d probably just execute the following
    and check the output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个测试是验证安装的 Apache 版本是否为 `2.4.10`，这是要求的版本。我们怎么手动验证呢？我们可能会执行以下命令并检查输出：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This translates in Docker with our image in the following command (`-v` being
    the command (`CMD`) for the `apache2ctl` `ENTRYPOINT` instruction):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 Docker 中与我们的镜像对应的命令如下（`-v` 是 `apache2ctl` `ENTRYPOINT` 指令的命令（`CMD`））：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Basically, now we just have to run `grep` for the correct version:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，现在我们只需运行 `grep` 来查找正确的版本：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If `grep` is successful, it returns `0`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `grep` 成功，它会返回 `0`：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A simple BATS test for a command return code looks like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的 BATS 测试命令返回码如下：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We now have everything we need to write our first BATS test in `test/httpd.bats`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有编写第一个 BATS 测试所需的一切，文件路径为 `test/httpd.bats`：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To execute our test, let''s launch BATS with the folder containing the tests
    as arguments:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行我们的测试，让我们将包含测试的文件夹作为参数传给 BATS：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Good! We're now assured that the correct Apache version is installed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！我们现在已经确认正确的 Apache 版本已经安装。
- en: 'Let''s ensure the APT cache is cleaned after we build the image so we don''t
    waste precious space. Deleting the APT lists means the `/var/lib/apt/lists` folder
    will become empty, so if you count the files in this folder after this, it should
    return `0`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保在构建镜像后清理 APT 缓存，以免浪费宝贵的空间。删除 APT 列表意味着 `/var/lib/apt/lists` 文件夹将变为空，因此，如果你在此之后统计该文件夹中的文件数量，应该返回
    `0`：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'However, we cannot just send this command to the container like we did for
    the Apache version; the entry point is `apache2ctl`, and it needs to be overridden
    by `sh` on the `docker run` command line. Here''s the `apt.bats` test file, executing
    the shell command instead of `apache2ctl`, expecting a successful execution and
    an output of `0`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不能像处理 Apache 版本那样直接将命令发送到容器中；其入口点是 `apache2ctl`，需要在 `docker run` 命令行中通过
    `sh` 进行重写。以下是 `apt.bats` 测试文件，执行的是 shell 命令而不是 `apache2ctl`，期望成功执行并返回输出 `0`：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Execute the BATS tests:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 BATS 测试：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using Makefile to glue it all together
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Makefile 将所有内容连接起来
- en: 'Now this whole process might be a bit tedious in CI, with some additional steps
    needed before the testing is done (the image needs to be built and made available
    before it is tested, for example). Let''s create a `Makefile` that will take care
    of the prerequisites for us:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个过程在 CI 中可能有点繁琐，需要在测试之前做一些额外的步骤（比如镜像需要先构建并可用，然后才能进行测试）。让我们创建一个 `Makefile`
    来处理这些前置工作：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now when you execute the `make test` command, it will launch the `bats` suite,
    which itself depends on building the image by `docker-compose`—a much simpler
    command to integrate in the CI system of your choice:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你执行 `make test` 命令时，它将启动 `bats` 测试套件，而该套件依赖于通过 `docker-compose` 构建镜像——这是一个更简单的命令，可以更好地集成到你选择的
    CI 系统中：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: See also
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: Information on BATS at [https://github.com/sstephenson/bats](https://github.com/sstephenson/bats)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BATS 的相关信息见 [https://github.com/sstephenson/bats](https://github.com/sstephenson/bats)
- en: Test-Driven Development (TDD) with Docker and ServerSpec
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 和 ServerSpec 进行测试驱动开发（TDD）
- en: Docker containers might have a simpler language, but in the end, general concepts
    remain common and still apply. Testing is good for quality, and writing tests
    first ensures that we write code that would make a test pass, instead of writing
    tests after the code is written, which would somehow lead to missed errors. To
    help us with this, we'll use ServerSpec, based on RSpec, to initiate a TDD workflow
    along with writing and testing a Docker container. Working like this usually ensures
    a very high quality of work overall and very sustainable containers.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 容器可能使用更简化的语言，但最终，通用概念依然是相同的，仍然适用。测试有助于保证质量，而先编写测试可以确保我们编写能够通过测试的代码，而不是在编写完代码后再编写测试，这样可能会错过一些错误。为了帮助我们实现这一点，我们将使用基于
    RSpec 的 ServerSpec 来启动 TDD 工作流，同时编写和测试 Docker 容器。以这种方式工作通常能确保非常高的工作质量和非常可持续的容器。
- en: Getting ready
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To step through this recipe, you will need:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了按照这个步骤操作，你将需要：
- en: A working Docker installation
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的 Docker 安装
- en: A working Ruby environment (including Bundler)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可用的 Ruby 环境（包括 Bundler）
- en: How to do it…
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: Our goal is to create an NGINX container following TDD principles. Before we
    start to code, let's begin by setting up our environment.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是按照 TDD 原则创建一个 NGINX 容器。在开始编码之前，让我们先设置好我们的环境。
- en: Creating a ServerSpec environment using Bundler
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Bundler 创建一个 ServerSpec 环境
- en: 'ServerSpec comes as a gem (a Ruby package), and as we''ll use Docker APIs,
    we''ll need the `docker-api` gem as well. For ease of deployment, let''s create
    `Gemfile` containing our dependencies inside a `test` group:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ServerSpec 作为一个 gem（Ruby 包）提供，并且由于我们将使用 Docker APIs，我们还需要 `docker-api` gem。为了便于部署，让我们创建一个包含依赖的
    `Gemfile`，并将其放在 `test` 组中：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Install these dependencies using Bundler:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Bundler 安装这些依赖：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we''ll be able to execute `rspec` in our local context using Bundler:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将能够在本地环境中使用 Bundler 执行 `rspec`：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Initializing the tests
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化测试
- en: 'Let''s start by creating our first Docker Rspec test that will just, for now,
    initialize the libraries we need and build the Docker image before anything else.
    It looks like this in `spec/Dockerfile_spec.rb`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建第一个 Docker Rspec 测试开始，暂时只是初始化所需的库，并在其他任何操作之前构建 Docker 镜像。它在 `spec/Dockerfile_spec.rb`
    中看起来是这样的：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: TDD – using the Debian Jessie base's Docker image
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TDD – 使用 Debian Jessie 基础的 Docker 镜像
- en: 'We now want to use a Debian stable for our project, which happens to be Debian
    8 at the moment. To know the current version of a Debian system, just look at
    the `/etc/debian_version` file (on Red-Hat-based systems, it''s under `/etc/redhat_release`):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在希望为我们的项目使用 Debian 稳定版，目前是 Debian 8。要查看当前 Debian 系统的版本，只需查看 `/etc/debian_version`
    文件（在基于 Red-Hat 的系统中，它位于 `/etc/redhat_release`）：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Good! Let''s create a definition in ServerSpec, checking for the Debian version
    through this command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！让我们在 ServerSpec 中创建一个定义，通过这个命令检查 Debian 版本：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, the `debian_version` content can be easily queried, for example, by this
    check:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`debian_version` 内容可以轻松查询，例如，使用以下检查：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If this system is running Debian 8, then the test will pass. If the `Dockerfile`
    is empty, the test will fail:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该系统正在运行 Debian 8，那么测试将通过。如果 `Dockerfile` 为空，则测试将失败：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Good! Our test has failed. Let''s write the `FROM` instruction in Dockerfile
    that will make it pass; this is because the current Debian stable is version 8:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！我们的测试失败了。让我们在 Dockerfile 中写下 `FROM` 指令，使其通过；这是因为当前的 Debian 稳定版是版本 8：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Save the file and launch the test again:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并再次启动测试：
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Good job! Our test has passed, meaning this really is Debian 8.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 做得好！我们的测试通过了，意味着这确实是 Debian 8。
- en: TDD – installing the NGINX package
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TDD – 安装 NGINX 包
- en: 'Our next objective is to install the `nginx` package. Let''s write the Rspec
    test in `Dockerfile_spec.rb` that will check for this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个目标是安装 `nginx` 包。让我们在 `Dockerfile_spec.rb` 中编写 Rspec 测试，检查这个问题。
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Launch the test to be sure it fails:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 启动测试以确保它失败：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It''s now time to add the instructions to the `Dockerfile` on how to install
    NGINX:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候在 `Dockerfile` 中添加安装 NGINX 的指令了：
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Relaunch the tests (it will take some time as it needs to build the image):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动测试（这需要一些时间，因为它需要构建镜像）：
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We're now sure the `nginx` package is installed.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以确定 `nginx` 包已经安装。
- en: TDD – running NGINX
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TDD – 运行 NGINX
- en: 'Now that we have our image built with NGINX, execute it. Using ServerSpec,
    we can start a container using the `id` attribute of the image we built earlier.
    In the `Dockerfile_spec.rb` file, create and start the container using the image:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了带有 NGINX 的镜像，接下来执行它。使用 ServerSpec，我们可以通过之前构建的镜像的 `id` 属性启动容器。在 `Dockerfile_spec.rb`
    文件中，创建并启动容器：
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Using standard ServerSpec checks, verify that an NGINX process is running:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准的 ServerSpec 检查，验证是否有 NGINX 进程在运行：
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can''t stop here without cleaning up the container. We need to stop it when
    we''re done with the tests and delete it:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能仅停留在这里，还需要清理容器。我们需要在测试完成后停止它并删除它：
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we can run the test that will execute the container and fail upon checking
    for an `nginx` process (we didn''t write anything that would launch `nginx`):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行测试，它将执行容器并在检查 `nginx` 进程时失败（因为我们没有写任何启动 `nginx` 的代码）：
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now let''s execute `/usr/bin/nginx` for our container in the foreground, specifically
    in the `Dockerfile`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在容器中执行 `/usr/bin/nginx`，并将其放在前台运行，特别是在 `Dockerfile` 中：
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Rerun the tests to check whether the `nginx` process is now running as expected:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行测试，检查 `nginx` 进程是否如预期般运行：
- en: '[PRE35]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To add simplicity when integrating these tests in CI systems, let''s create
    a simple `Makefile`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 CI 系统中集成这些测试时简化操作，让我们创建一个简单的 `Makefile`：
- en: '[PRE36]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now a simple `make test` command will launch the ServerSpec tests.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，简单的 `make test` 命令将启动 ServerSpec 测试。
- en: Good job! We've built our first simple Docker container following TDD principles.
    We can now build more complex and secure containers using this technique.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 做得好！我们已经按照 TDD 原则构建了第一个简单的 Docker 容器。现在我们可以使用这种技术构建更复杂、更安全的容器。
- en: See also
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: RSpec at [http://rspec.info/](http://rspec.info/)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RSpec 网址：[http://rspec.info/](http://rspec.info/)
- en: Docker-api at [https://github.com/swipely/docker-api](https://github.com/swipely/docker-api)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker-api 网址：[https://github.com/swipely/docker-api](https://github.com/swipely/docker-api)
- en: ServerSpec at [http://serverspec.org/](http://serverspec.org/)
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ServerSpec 网址：[http://serverspec.org/](http://serverspec.org/)
- en: The workflow for creating automated Docker builds from Git
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Git 创建自动化 Docker 构建的工作流程
- en: 'Building local containers is a nice thing to do, but what about its wide distribution?
    We can use the Docker Hub service to store and distribute our containers (or its
    alternative Quay.io); however, uploading each and every container and version
    manually will soon be a problem. Consider you need to rebuild dozens of containers
    in an emergency, because of the existence of another OpenSSL security bug; nobody
    would want to be the one to upload them one by one, especially with the bad uplink
    at work. And as we''re working with our Docker code using branches and tags, it
    will be awesome to see the same behavior reflected automatically on the remote
    Docker registry. This includes two of the Docker Hub (or Quay.io) features: automatically
    build Docker images upon changes and serve them to the world. We''ll do exactly
    this in this section: create an automated build and distribution pipeline from
    our code to GitHub to the Docker Hub.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 构建本地容器是一个不错的选择，但它的广泛分发怎么办呢？我们可以使用 Docker Hub 服务来存储和分发我们的容器（或者其替代品 Quay.io）；然而，手动上传每一个容器及其版本很快就会成为问题。假设你需要紧急重建几十个容器，因为另一个
    OpenSSL 安全漏洞的存在；没人愿意一个一个地上传它们，特别是在工作时网络连接不佳。而且，当我们使用分支和标签进行 Docker 代码工作时，看到相同的行为自动反映在远程
    Docker 仓库中会非常棒。这包括 Docker Hub（或 Quay.io）的两个功能：在代码发生变化时自动构建 Docker 镜像并将它们服务给全世界。在本节中，我们将完全按照此流程操作：从我们的代码到
    GitHub，再到 Docker Hub，创建一个自动构建和分发流水线。
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To step through this recipe, you will need:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此教程，你需要：
- en: A free GitHub account
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个免费的 GitHub 账户
- en: A free Docker Hub account
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个免费的 Docker Hub 账户
- en: A Docker project
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Docker 项目
- en: How to do it…
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Our objective is to get a fully working Docker build pipeline. To achieve this,
    we''ll use two free, popular services: GitHub and the Docker Hub. Let''s start
    with the code from the previous section that helped us build an NGINX container;
    we can alternatively use any other repository on GitHub containing at least a
    buildable `Dockerfile`. The code needs to actually be on GitHub not just versioned
    using Git locally. The repository should look like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是获得一个完全工作的 Docker 构建流水线。为了实现这一目标，我们将使用两个免费的流行服务：GitHub 和 Docker Hub。让我们从上一节中帮助我们构建
    NGINX 容器的代码开始；我们也可以使用任何包含至少一个可构建的 `Dockerfile` 的 GitHub 仓库。代码需要实际托管在 GitHub 上，而不仅仅是在本地使用
    Git 版本控制。仓库应该如下所示：
- en: '![How to do it…](img/B05671_10_01.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/B05671_10_01.jpg)'
- en: This repository is ready to communicate with other build services.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个仓库已经准备好与其他构建服务进行通信。
- en: Creating an automated build on the Docker Hub
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Docker Hub 上创建自动构建
- en: The Docker Hub is one of the commercial services from the company that created
    Docker. It's both a public Docker registry service (with private or public containers,
    depending on your subscription) and a Docker image build service that can automatically
    create new images when changes occur in the code. Go to [https://hub.docker.com](https://hub.docker.com)
    and log in or create an account if you don't have any.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub 是由创建 Docker 的公司提供的商业服务之一。它既是一个公共 Docker 镜像仓库服务（根据你的订阅，容器可以是私有的或公共的），也是一个
    Docker 镜像构建服务，当代码发生变化时，它可以自动创建新的镜像。访问[https://hub.docker.com](https://hub.docker.com)，登录或者如果你没有账户，创建一个新账户。
- en: 'Click on **Create Automated Build** in the **Create** menu:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在**创建**菜单中点击**创建自动构建**：
- en: '![Creating an automated build on the Docker Hub](img/B05671_10_02.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![在 Docker Hub 上创建自动构建](img/B05671_10_02.jpg)'
- en: 'Choose the provider where the infrastructure code is hosted; in our case, it''s
    **GitHub**:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 选择托管基础设施代码的提供者；在我们的例子中，是**GitHub**：
- en: '![Creating an automated build on the Docker Hub](img/B05671_10_03.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![在 Docker Hub 上创建自动构建](img/B05671_10_03.jpg)'
- en: 'When the synchronization is done, choose the GitHub repository:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 同步完成后，选择 GitHub 仓库：
- en: '![Creating an automated build on the Docker Hub](img/B05671_10_04.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![在 Docker Hub 上创建自动构建](img/B05671_10_04.jpg)'
- en: 'Finally, decide on a name for the image (it doesn''t have to be the name of
    the GitHub repository) and the namespace. The namespace could either be your username
    or an organization if you have one. Write a short description and choose the visibility
    of the image: private stuff should remain private, while public can stay public.
    Let''s be careful about what we ship:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，决定镜像的名称（它不必是 GitHub 仓库的名称）和命名空间。命名空间可以是你的用户名，也可以是你的组织名称（如果有的话）。写一个简短的描述，并选择镜像的可见性：私人内容应保持私密，公共内容可以公开。我们在发布内容时要小心：
- en: '![Creating an automated build on the Docker Hub](img/B05671_10_05.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![在 Docker Hub 上创建自动构建](img/B05671_10_05.jpg)'
- en: 'Navigate to **Build Settings** of our Docker Hub''s project to trigger an initial
    build:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 进入我们 Docker Hub 项目的**构建设置**以触发初始构建：
- en: '![Creating an automated build on the Docker Hub](img/B05671_10_06.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![在 Docker Hub 创建自动构建](img/B05671_10_06.jpg)'
- en: Clicking on the **Trigger** button will create a build. This is done by having
    `master` as the **Branch** type of our repository; tag the build with the `latest`
    tag. If, for some reason, the `Dockerfile` of our project wasn't at the root,
    we could specify it here. This build also allows us to manage different `Dockerfile`
    for different purposes, such as building the development and production containers
    differently, among other options.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**触发**按钮会创建一个构建。这是通过将我们的仓库的**分支**类型设为 `master` 来完成的，并使用 `latest` 标签标记该构建。如果出于某种原因，我们的项目的
    `Dockerfile` 不在根目录，我们可以在这里指定它。这个构建还允许我们管理不同的 `Dockerfile`，用于不同的目的，比如分别构建开发和生产容器等选项。
- en: 'Once the build is complete (should happen in minutes), navigating to the **Tags**
    tab will show the available tags (**latest** is the only one we have now) and
    the size of the image:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建完成（应该会在几分钟内完成），进入**标签**标签页会显示可用的标签（**latest**是我们现在唯一拥有的）和镜像的大小：
- en: '![Creating an automated build on the Docker Hub](img/B05671_10_07.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![在 Docker Hub 创建自动构建](img/B05671_10_07.jpg)'
- en: The **Dockerfile** tab shows the content of the `Dockerfile` from which the
    image has been built, while the **Build Details** tab will list all the builds
    and their details, including the build output. This is very useful for debugging
    when things go wrong.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**Dockerfile**标签显示了构建镜像所使用的 `Dockerfile` 内容，而**构建详情**标签将列出所有构建及其详情，包括构建输出。这对于调试出现问题时非常有用。'
- en: Configuring a GitHub to a Docker Hub-automated build pipeline
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 GitHub 配置为 Docker Hub 自动构建管道
- en: 'Now let''s make a modification to the `Dockerfile`, for example, adding a label
    for the image''s name and version:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们修改 `Dockerfile`，例如，为镜像的名称和版本添加标签：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Commit and push this change to GitHub:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 提交并推送此更改到 GitHub：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'What''s happening on the Docker Hub? It automatically starts building a new
    image as soon as it becomes aware of the change on GitHub:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub 上发生了什么？它会在检测到 GitHub 上的变化后自动开始构建新镜像：
- en: '![Configuring a GitHub to a Docker Hub-automated build pipeline](img/B05671_10_08.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![将 GitHub 配置为 Docker Hub 自动构建管道](img/B05671_10_08.jpg)'
- en: 'A few seconds later, our newest build is available for everyone to use:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，我们最新的构建可以供大家使用：
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Building Docker images using Git tags
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Git 标签构建 Docker 镜像
- en: 'As we''re happy with this release, we''d like it to be available as a `1.0`
    tag on the Docker Hub. To do this, we''ll need to complete two actions:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们对这个版本满意，我们希望它作为 `1.0` 标签发布在 Docker Hub 上。为了做到这一点，我们需要完成两个操作：
- en: Configure the Docker Hub to build and tag according to Git tags and not just
    branches
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 Docker Hub 根据 Git 标签而非仅仅根据分支来构建和标记
- en: Tag and push our release on Git
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Git 上标记并推送我们的发布版本
- en: 'For the Docker Hub to build images with the same tags than the ones we set
    on Git, let''s add a new type called **Tag** in the **Build Settings** tab. This
    will now make the Docker Hub follow the tags we set on Git. It will also build
    any other tag you may create in the future:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 Docker Hub 构建与我们在 Git 上设置的相同标签的镜像，让我们在**构建设置**标签中添加一个新类型，叫做**标签**。这样，Docker
    Hub 将会遵循我们在 Git 上设置的标签，它还会构建你将来可能创建的任何其他标签：
- en: '![Building Docker images using Git tags](img/B05671_10_09.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Git 标签构建 Docker 镜像](img/B05671_10_09.jpg)'
- en: 'Let''s tag our code as `1.0` on Git so we can refer to it later:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Git 上将代码标记为 `1.0`，以便稍后引用：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This just triggered a new build on the Docker Hub, using the tag **1.0**, as
    we asked to match:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这刚刚在 Docker Hub 上触发了一个新的构建，使用了我们要求的匹配标签**1.0**：
- en: '![Building Docker images using Git tags](img/B05671_10_10.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Git 标签构建 Docker 镜像](img/B05671_10_10.jpg)'
- en: 'Everyone can now refer to this stable build and use it without fearing a breaking
    change from the master branch; this branch will always be built with the latest
    tag:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每个人都可以引用这个稳定版本，并且使用它时无需担心来自主分支的破坏性变更；这个分支将始终使用最新标签进行构建：
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Even better, from now on, our future Docker projects that need both this container
    and the stability can simply start with the following line on the `Dockerfile`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，从现在开始，我们未来需要同时拥有此容器和稳定性的 Docker 项目，只需在 `Dockerfile` 中加入以下一行即可：
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We now have a nice initial workflow for building master and tagged, stable releases
    of our containers.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个不错的初始工作流，用于构建主分支和已标记的稳定版容器。
- en: The workflow for connecting the Continuous Integration (CI) system
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接持续集成（CI）系统的工作流
- en: As people working with code and writing tests for it, there's no reason not
    to see those tests executed in CI. The same way every program has language requirements,
    ours need to be able to build Docker containers and execute some Ruby code. Being
    able to fully execute a whole pile of tests automatically, upon any code check-in,
    is a major quality improvement step. No one can test each and every possibility
    and regression and special cases from months or maybe years ago. It's true in
    software code, and it's the same in infrastructure code as well. Let's find an
    elegant and automated way to execute our infrastructure code tests in CI systematically
    so this could be another dot connected to the bigger map.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 作为编写代码和测试代码的人，完全没有理由不在 CI 中执行这些测试。就像每个程序都有语言要求一样，我们的程序也需要能够构建 Docker 容器并执行一些
    Ruby 代码。能够在任何代码提交时自动执行一整堆测试，是质量提升的一个重要步骤。没有人能测试每一个可能性、回归和几个月或几年以前的特殊情况。这在软件代码中是如此，在基础设施代码中也是一样。让我们找到一种优雅的自动化方法，系统性地在
    CI 中执行我们的基础设施代码测试，这将是与更大蓝图连接的又一个点。
- en: Getting ready
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To step through this recipe, you will need:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行这个教程，你需要：
- en: A working Docker installation
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的 Docker 安装
- en: A free Travis CI account
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个免费的 Travis CI 账户
- en: How to do it…
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: How to do it…
- en: 'We''d like our RSpec integration tests to be executed automatically each time
    we commit a change on Git. This is the perfect job for a CI system, such as Jenkins,
    the Circle CI, or the Travis CI. Our only requirement is that the CI platform
    should build and execute Docker containers and run RSpec tests. Docker support
    is good with Travis, and it works out of the box. Jenkins would work equally well
    behind the firewall when properly configured, like most other CI systems. Here''s
    how to configure our CI platform to automatically execute tests on a new commit:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望每次提交 Git 更改时，能够自动执行 RSpec 集成测试。这正是 CI 系统的完美工作，如 Jenkins、Circle CI 或 Travis
    CI。我们唯一的要求是 CI 平台能够构建并执行 Docker 容器并运行 RSpec 测试。Travis 对 Docker 的支持很好，开箱即用。而 Jenkins
    也能在正确配置后，在防火墙后正常工作，就像大多数其他 CI 系统一样。下面是如何配置 CI 平台，在新提交时自动执行测试：
- en: Create a free account for the Travis CI or use your own ([https://travis-ci.org/](https://travis-ci.org/)).
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个免费的 Travis CI 账户或使用你自己的账户 ([https://travis-ci.org/](https://travis-ci.org/))。
- en: Click on the **+** button to add a new GitHub repository:![How to do it…](img/B05671_10_14.jpg)
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **+** 按钮以添加一个新的 GitHub 仓库：![How to do it…](img/B05671_10_14.jpg)
- en: Enable the watching of the repository by Travis:![How to do it…](img/B05671_10_11.jpg)
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用 Travis 对仓库的监控：![How to do it…](img/B05671_10_11.jpg)
- en: 'Now add a configuration file for Travis named `.travis.yml` at the root of
    the repository. This file can contain a lot of information to do many things,
    but for now, it should simply tell Travis that we need a Ruby environment in a
    recent Linux distribution running Docker. Also, it should simply execute `make
    test` for `Makefile`. In our case, this command will execute the RSpec tests:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在仓库根目录添加一个名为 `.travis.yml` 的配置文件。这个文件可以包含很多信息来做很多事情，但现在它应该简单地告诉 Travis，我们需要在一个最近的
    Linux 发行版中运行 Docker 的 Ruby 环境。同时，它应该执行 `Makefile` 中的 `make test`。在我们的案例中，这个命令将执行
    RSpec 测试：
- en: '[PRE43]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Commit and push this file and it will trigger our first test on Travis:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交并推送这个文件，它将触发我们在 Travis 上的第一次测试：
- en: '[PRE44]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Navigating back to the Travis CI, we can see the tests begin:![How to do it…](img/B05671_10_12.jpg)
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 Travis CI，我们可以看到测试开始了：![How to do it…](img/B05671_10_12.jpg)
- en: A few seconds later, the tests pass successfully, assuring us the build is consistent
    with our expectations. Travis even gives easy access to the output of the commands:![How
    to do it…](img/B05671_10_13.jpg)
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几秒钟后，测试成功通过，确保构建与我们的预期一致。Travis 甚至可以轻松访问命令的输出：![How to do it…](img/B05671_10_13.jpg)
- en: We just initiated new steps for integrating automated tests in our workflow.
    This is getting increasingly important as every project or team grows, and it's
    getting riskier to ship untested containers into production.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚为将自动化测试集成到工作流中启动了新步骤。随着每个项目或团队的发展，这变得越来越重要，向生产环境中发布未经测试的容器变得更加危险。
- en: Note
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'It''s also highly recommended that you include any other test that can be done
    in this CI system, such as the Docker linters check from earlier in this book.
    Quality can only go higher: the more the checks, the better. Building quicker
    tests for a faster feedback loop will then be a new subject.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议你包括任何可以在这个 CI 系统中执行的其他测试，比如本书早些时候提到的 Docker linters 检查。质量只能越来越高：检查越多，效果越好。为更快的反馈循环构建更快速的测试将成为下一个主题。
- en: As with every CI system, the final step after the tests are completed is to
    package, ship, and deploy the containers. As exciting as this step is, it's also
    unfortunately far beyond the scope of this book.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 和每个CI系统一样，测试完成后的最后一步是打包、发布和部署容器。尽管这一步令人兴奋，但遗憾的是，已经超出了本书的范围。
- en: Scanning for vulnerabilities with Quay.io and Docker Cloud
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Quay.io和Docker Cloud扫描漏洞
- en: One major issue when working with containers is their deprecation and maintenance
    costs. Too often, containers are built one day, shipped to production because
    they work, and forgotten there until the next rebuild (which may not happen anytime
    soon). Libraries are still libraries, and security fixes are pushed every day
    into distributions package repositories. Sysadmins are used to patch the systems;
    however, now it's a total anti-pattern to update a running container. Containers
    need to be rebuilt, exactly like developers are used to rebuilding applications
    with updated libraries to get rid of bugged code. The exception is that we are
    lucky enough to have tools that monitor each and every layer of our Docker images
    and tell us how and when they are vulnerable, allowing us to simply rebuild and
    redeploy them.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器时的一个主要问题是它们的弃用和维护成本。容器通常是在某一天构建的，因其正常工作而被推送到生产环境，并且被遗忘直到下一次重建（这可能不会很快发生）。库依然是库，安全修复每天都会推送到发行版的包仓库。系统管理员习惯了修补系统；然而，现在更新运行中的容器完全是反模式。容器需要重新构建，正如开发者习惯于通过更新库来重新构建应用程序以消除有问题的代码。例外的是，我们足够幸运，有工具监控我们每个Docker镜像的每一层，并告诉我们如何以及何时它们会变得脆弱，让我们能够简单地重新构建并重新部署它们。
- en: Getting ready
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个教程，你需要：
- en: A working Docker installation
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的Docker安装
- en: A free account at Quay.io and/or a paid account at the Docker Hub
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个免费的Quay.io账户和/或Docker Hub的付费账户
- en: How to do it…
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Using the free Quay.io account (by the CoreOS team), push an image to their
    Docker Registry service after logging in using `docker login`. Here''s how to
    do this using an earlier image from this chapter:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用免费的Quay.io账户（由CoreOS团队提供），在通过`docker login`登录后，将镜像推送到他们的Docker Registry服务。下面是使用本章早些时候的镜像操作的步骤：
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Quay.io has a very nice security feature: as Docker stores passwords in plain
    text on the local workstation, it''s possible to generate an encrypted password
    from the **settings** tab of your Quay.io account not only for Docker use, but
    also for Kubernetes, rkt, or Mesos. It''s a much better option to use this encrypted
    password to log in to the service.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Quay.io有一个非常好的安全功能：由于Docker将密码以明文存储在本地工作站上，因此你可以在Quay.io账户的**设置**标签页中生成一个加密密码，这个密码不仅可以用于Docker，也可以用于Kubernetes、rkt或Mesos。这种加密密码是登录服务的一个更好的选择。
- en: 'After a while, in the **Repository Tags** tab of our image, we''ll get a **SECURITY
    SCAN** summary:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 稍等片刻，在我们镜像的**Repository Tags**标签页中，我们将看到一个**安全扫描**的总结：
- en: '![How to do it…](img/B05671_10_20.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作……](img/B05671_10_20.jpg)'
- en: 'In this example, we have issues to investigate further:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们有一些问题需要进一步调查：
- en: '![How to do it…](img/B05671_10_21.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作……](img/B05671_10_21.jpg)'
- en: Many vulnerabilities are displayed, but don't be frightened. In fact, none are
    fixable in our case (click on **Only show fixable** to see what you can do). The
    reasons are multiple, such as no fix is available currently, the vulnerability
    doesn't concern the platform we're running on, and so on.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 显示了许多漏洞，但不要害怕。实际上，在我们的案例中，没有漏洞是可以修复的（点击**仅显示可修复**查看可以采取的措施）。原因有很多，比如当前没有可用的修复程序，漏洞与我们运行的平台无关，等等。
- en: 'Here''s a screenshot of a really vulnerable container and the Quay.io scanner
    giving helpful advice on the available fixes:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常脆弱的容器的截图，Quay.io扫描仪提供了关于可用修复的有用建议：
- en: '![How to do it…](img/B05671_10_22.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作……](img/B05671_10_22.jpg)'
- en: '**Quay.io Security Scanner** will also send reminders by e-mail with a summary
    of the vulnerabilities found on all the containers it hosts on our account. So
    we don''t have to worry too much about missing out on important security issues.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**Quay.io安全扫描仪**还会通过电子邮件发送提醒，提供在我们账户下托管的所有容器的漏洞总结。这样我们就不必太担心错过重要的安全问题。'
- en: Using Docker Security Scanning
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Docker安全扫描
- en: 'There''s a similar feature on the Docker Hub that uses a paid account, though
    still in preview at the time of this writing. By default, Docker Security Scanning
    is not activated, so we have to navigate to the billing tab of the account''s
    interface and tick it to enable it:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub 上有一个类似的功能，使用的是付费账户，尽管在撰写本文时仍处于预览阶段。默认情况下，Docker 安全扫描未激活，因此我们需要进入账户界面的账单标签页，并勾选该选项以启用它：
- en: '![Using Docker Security Scanning](img/B05671_10_18.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Docker 安全扫描](img/B05671_10_18.jpg)'
- en: 'From now on, when a new Docker image is created or pushed, the system will
    scan it quickly and report issues, tag by tag. To access the report summary, just
    click on the **Tag** tab:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，每当创建或推送一个新的 Docker 镜像时，系统将迅速扫描并逐个标签报告问题。要访问报告摘要，只需点击 **标签** 标签：
- en: '![Using Docker Security Scanning](img/B05671_10_19.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Docker 安全扫描](img/B05671_10_19.jpg)'
- en: 'To see details (and the corresponding vulnerabilities), click on the tag number:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看详细信息（以及相应的漏洞），点击标签编号：
- en: '![Using Docker Security Scanning](img/B05671_10_17.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Docker 安全扫描](img/B05671_10_17.jpg)'
- en: This layer has clear issues! But don't follow this blindly and double-check
    the said vulnerabilities. All the critical issues in this example only concern
    Apple platforms and we're running Linux containers.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层有明显的问题！但不要盲目跟从，要仔细检查所说的漏洞。这个例子中的所有关键问题只涉及 Apple 平台，而我们正在运行 Linux 容器。
- en: How it works…
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Under the hood, the Quay Security Scanner is based on Clair. Clair is an open
    source static analysis vulnerability scanner by CoreOS that we can run ourselves
    or build tools upon. It currently handles Debian, Ubuntu, Alpine, Oracle, and
    Red Hat security data sources. It gives access to a simple API. Our custom tool
    can send each Docker image layer we're interested in and get the corresponding
    vulnerabilities or fixes.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，Quay 安全扫描器是基于 Clair 的。Clair 是一个由 CoreOS 开发的开源静态分析漏洞扫描器，我们可以自己运行或基于它构建工具。它目前处理
    Debian、Ubuntu、Alpine、Oracle 和 Red Hat 的安全数据源，并提供简单的 API 接口。我们的自定义工具可以发送我们感兴趣的每个
    Docker 镜像层，并获取相应的漏洞或修复信息。
- en: See also
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: CoreOS Clair at [https://github.com/coreos/clair/](https://github.com/coreos/clair/)
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CoreOS Clair 在 [https://github.com/coreos/clair/](https://github.com/coreos/clair/)
- en: Sending Docker logs to AWS CloudWatch logs
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Docker 日志发送到 AWS CloudWatch 日志
- en: When we run dozens or hundreds of containers in production, hopefully on a clustered
    container platform, it soon becomes difficult and tedious to read, search, and
    process logs—just like it was before when containers with services ran on dozens
    or hundreds of physical or virtual servers. The problem is that traditional solutions
    don't work out of the box to handle Docker logs. Luckily, AWS has a nice and easy
    log-aggregating service, named AWS CloudWatch. Docker has a logging driver just
    for it. We'll send our Tomcat logs to it right away!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在生产环境中运行数十或数百个容器时，尤其是在集群化的容器平台上，阅读、搜索和处理日志变得越来越困难和繁琐——就像以前容器与服务在数十或数百台物理或虚拟服务器上运行时的情况一样。问题在于，传统解决方案并不直接适用于处理
    Docker 日志。幸运的是，AWS 提供了一个简单易用的日志聚合服务——AWS CloudWatch。Docker 为此提供了一个专用的日志驱动程序。我们将立刻把
    Tomcat 日志发送到它！
- en: Getting ready
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To step through this recipe, you will need:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行这个操作步骤，你将需要：
- en: A working Docker installation
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的 Docker 安装
- en: An AWS account
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 AWS 账户
- en: How to do it…
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: To use AWS CloudWatch Logs, we need at least one **log group**. Use this book's
    chapter on Terraform code to create a CloudWatch Logs group and a dedicated IAM
    user, or manually create both.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 AWS CloudWatch 日志，我们需要至少一个 **日志组**。可以使用本书中关于 Terraform 代码的章节来创建一个 CloudWatch
    日志组和一个专用的 IAM 用户，或者手动创建二者。
- en: Note
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As always, with AWS, it's highly recommended that you use a dedicated IAM user
    for each AWS key pair we'll use. In our case, we can associate the prebuilt IAM
    policy, named CloudWatchLogsFullAccess, with a new dedicated user in order to
    be up and running quickly in a secured way.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，使用 AWS 时，强烈建议为我们将使用的每对 AWS 密钥使用专用的 IAM 用户。在我们的案例中，我们可以将名为 CloudWatchLogsFullAccess
    的预构建 IAM 策略与一个新的专用用户关联，以便快速并安全地启动。
- en: 'The Docker daemon needs to run with the AWS credentials in the memory—it''s
    not information we pass to containers, as it''s handled by the Docker daemon''s
    log driver. To give the Docker daemon access to the keys we created, let''s create
    an added `systemd` configuration file for the Docker service in `/etc/systemd/system/docker.service.d/aws.conf`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 守护进程需要在内存中运行 AWS 凭证——这些信息不会传递给容器，因为它由 Docker 守护进程的日志驱动程序处理。为了让 Docker
    守护进程访问我们创建的密钥，让我们为 Docker 服务在 `/etc/systemd/system/docker.service.d/aws.conf`
    中创建一个额外的 `systemd` 配置文件：
- en: '[PRE46]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Don''t forget to reload the `systemd` daemon and restart Docker to apply the
    changes:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了重新加载 `systemd` 守护进程并重启 Docker 以应用更改：
- en: '[PRE47]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We're now ready to talk to the AWS APIs through the Docker daemon.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过 Docker 守护进程与 AWS API 进行交互。
- en: Using the Docker run
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Docker run
- en: 'Here''s a simple way to execute the Tomcat 9 container that uses the `awslogs`
    driver. Utilize the CloudWatch log group named `docker_logs` on the `us-east-1`
    data center and automatically create a new stream named `www`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的方式来执行 Tomcat 9 容器，使用 `awslogs` 驱动程序。利用位于 `us-east-1` 数据中心的名为 `docker_logs`
    的 CloudWatch 日志组，并自动创建一个名为 `www` 的新日志流：
- en: '[PRE48]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Navigating over the AWS Console, the new log stream will appear under **Search
    Log Group**:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AWS 控制台中导航，新的日志流将在 **Search Log Group** 下显示：
- en: '![Using the Docker run](img/B05671_10_23.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Docker run](img/B05671_10_23.jpg)'
- en: 'Clicking on the log stream name will give us access to all the output logs
    from our Tomcat container:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 点击日志流名称将使我们能够访问来自 Tomcat 容器的所有输出日志：
- en: '![Using the Docker run](img/B05671_10_24.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Docker run](img/B05671_10_24.jpg)'
- en: We now have access to unlimited log storage and search features, and the amount
    of effort we put was very limited!
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以访问无限的日志存储和搜索功能，而且我们付出的努力非常有限！
- en: Using docker-compose
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 docker-compose
- en: 'It''s also possible to configure the logging driver using Docker Compose. Here''s
    how it works with creating a log stream named `tomcat` under the same log group
    in `docker-compose.yml`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用 Docker Compose 配置日志驱动程序。以下是如何在 `docker-compose.yml` 中创建一个名为 `tomcat` 的日志流，位于同一个日志组下：
- en: '[PRE49]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Launch the compose as usual:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样启动 Compose：
- en: '[PRE50]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `tomcat` CloudWatch log stream is now automatically created and the logs
    flow into it.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`tomcat` CloudWatch 日志流现在自动创建，日志流入其中。'
- en: Using systemd
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 systemd
- en: 'Another useful way to launch containers is through the use of systemd. Here''s
    how to create a dynamically named log stream using the systemd unit name (in this
    case, `tomcat.service`). This is useful on platforms that use multiple instances
    of the same container to let them all send their logs separately. Here''s a working
    Tomcat systemd service that is running Docker and sending the logs to a dynamically
    allocated stream name in `/etc/systemd/system/tomcat.service`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 启动容器的另一种有用方法是通过使用 systemd。以下是如何使用 systemd 单元名称（在此示例中为 `tomcat.service`）创建动态命名的日志流。这在使用多个相同容器实例的平台上非常有用，可以让它们分别发送日志。以下是一个正在运行
    Docker 并将日志发送到动态分配的日志流名称的工作 Tomcat systemd 服务，在 `/etc/systemd/system/tomcat.service`
    中：
- en: '[PRE51]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Reload systemd and start the `tomcat` unit:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载 systemd 并启动 `tomcat` 单元：
- en: '[PRE52]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now a third log stream is created with the service name, with the systemd unit
    logs streaming into it:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建了第三个日志流，带有服务名称，并且 systemd 单元的日志正在流入其中。
- en: '![Using systemd](img/B05671_10_25.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![使用 systemd](img/B05671_10_25.jpg)'
- en: Enjoy a centralized and powerful way of storing and accessing logs before you
    eventually process them!
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 享受一种集中且强大的存储和访问日志的方式，直到最终处理它们！
- en: There's more...
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The Docker daemon can stream logs not only to AWS, but also to the more common
    syslog. This enables a lot of options (such as having traditional `rsyslog` setups
    and online services compatible with the traditional format). Similarly, it not
    only sends the logs to `journald`, but also supports the Graylog or Logstash GELF
    log format. The Fluentd unified logging layer is also supported, while on the
    platform front, we find support for Splunk and Google Cloud together with AWS
    CloudWatch logs.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 守护进程不仅可以将日志流传送到 AWS，还可以传送到更常见的 syslog。这提供了许多选项（例如，可以与传统的 `rsyslog` 设置和兼容传统格式的在线服务一起使用）。类似地，它不仅将日志发送到
    `journald`，还支持 Graylog 或 Logstash GELF 日志格式。还支持 Fluentd 统一日志层，同时在平台方面，支持 Splunk
    和 Google Cloud 以及 AWS CloudWatch 日志。
- en: Monitoring and getting information out of Docker
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控并获取 Docker 中的信息
- en: 'It''s often important to get some quick and useful information out of our Docker
    system when weird problems arise or strange issues start to cripple our performance.
    What''s going on in the system? Is there a container taking up all of the memory?
    Maybe one minor container just crashed and is eating up all of the CPU. All of
    this information shouldn''t be hard to get, but they are precious for building
    quality containers. We''ll see two tools quite fit for the job: the first one
    is simply the one shipped with Docker itself, and the second one is a totally
    different tool by Google named cAdvisor—a web user interface with a lot of useful
    and easy-to-get information.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现奇怪的问题或系统性能严重下降时，通常需要快速获取一些有用的信息。系统发生了什么问题？是否有某个容器占用了所有内存？也许某个小容器崩溃了并占用了所有的
    CPU。所有这些信息都不难获取，但对于构建高质量的容器来说，它们非常宝贵。我们将看到两个非常适合这项工作的工具：第一个工具是 Docker 本身自带的工具，第二个工具是谷歌推出的一个完全不同的工具——cAdvisor，它是一个提供丰富且易于获取信息的
    Web 用户界面。
- en: Getting ready
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To step through this recipe, you will need:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照这个步骤执行，你需要：
- en: A working Docker installation
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的 Docker 安装
- en: How to do it...
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: There's a few ways to get information out of Docker. We'll explore the first
    one through the main Docker program.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从 Docker 中获取信息。我们将通过 Docker 主程序探索第一种方法。
- en: Using docker stats
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 docker stats
- en: 'To get live metrics about the running containers (CPU, memory, and network),
    we can use the simple `docker stats` command:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取正在运行的容器的实时度量信息（CPU、内存和网络），我们可以使用简单的 `docker stats` 命令：
- en: '[PRE53]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'It''s, however, not overwhelmingly helpful as it''s using containers'' IDs
    and not names, and when running many containers, it can start becoming useless
    because it would be unreadable. So we can use a trick: ask the stats (`docker
    stats`) of all the running containers (`docker ps`) whose names we extracted using
    a Go template formatter `(--format`):'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法并不是非常有帮助，因为它使用的是容器的 ID 而非名称，当运行许多容器时，这种方法可能会变得不可读，因此几乎没有用处。所以我们可以使用一个技巧：请求所有正在运行的容器的统计数据（`docker
    stats`）（`docker ps`）并通过 Go 模板格式化提取容器名称 `(--format)`：
- en: '[PRE54]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Using Google's cAdvisor tool
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用谷歌的 cAdvisor 工具
- en: 'Google created a nice web tool to see what''s going on in machines that run
    containers: **cAdvisor**. It collects, organizes, and displays metrics about resource
    usage, container by container, on a given host. Though not interactive, it''s
    still powerful enough, given how easy it is to install and use. To install and
    use it, simply run the cAdvisor Docker image with volume access to all of the
    required system information, such as the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌创建了一个很棒的 Web 工具，用于查看运行容器的机器的状态：**cAdvisor**。它收集、组织并显示有关资源使用的度量数据，按容器逐个列出，适用于给定的主机。尽管它不是交互式的，但由于安装和使用非常简单，它仍然足够强大。要安装和使用它，只需运行
    cAdvisor 的 Docker 镜像，并使其能够访问所需的系统信息，像这样：
- en: '[PRE55]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Or, if using `docker-compose`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果使用 `docker-compose`：
- en: '[PRE56]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Navigating to the host''s `8080` port (or whatever port you choose to publish)
    with a web browser will present a web interface where we can navigate and see
    graphical information about container usage on the host:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Web 浏览器访问主机的 `8080` 端口（或你选择的任何端口）将显示一个 Web 界面，在该界面上我们可以浏览并查看主机上容器使用情况的图形信息：
- en: '![Using Google''s cAdvisor tool](img/B05671_10_27.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![使用谷歌的 cAdvisor 工具](img/B05671_10_27.jpg)'
- en: 'Or, we may have more general gauges giving live indication of resource usage:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可能有一些更通用的指标，用于实时指示资源使用情况：
- en: '![Using Google''s cAdvisor tool](img/B05671_10_26.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![使用谷歌的 cAdvisor 工具](img/B05671_10_26.jpg)'
- en: 'A very useful process table with top-like data from the underlying host is
    also available with a container-aware context. All of these pieces of data are
    browsable and they help you gain more in-depth information about a specific container
    and its content and usage:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过具有容器感知上下文的主机进程表获取类似 top 的有用数据。所有这些数据都可以浏览，它们帮助你更深入地了解特定容器及其内容和使用情况：
- en: '![Using Google''s cAdvisor tool](img/B05671_10_36.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![使用谷歌的 cAdvisor 工具](img/B05671_10_36.jpg)'
- en: cAdvisor can also be plugged in to many backend storage systems, such as Prometheus,
    ElasticSearch, InfluxDB, Redis, statsD, and so on.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: cAdvisor 还可以插入许多后端存储系统，如 Prometheus、ElasticSearch、InfluxDB、Redis、statsD 等。
- en: Note
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you plan to let cAdvisor run permanently, it is a good idea to restrict access
    using simple HTTP authentication. This is supported out of the box by cAdvisor
    using `--http_auth_file /cadvisor.htpasswd --http_auth_realm my_message`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算让 cAdvisor 永久运行，最好通过简单的 HTTP 身份验证来限制访问。这是 cAdvisor 默认支持的功能，使用 `--http_auth_file
    /cadvisor.htpasswd --http_auth_realm my_message`。
- en: See also
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: cAdvisor GitHub at [https://github.com/google/cadvisor](https://github.com/google/cadvisor)
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cAdvisor GitHub 地址 [https://github.com/google/cadvisor](https://github.com/google/cadvisor)
- en: cAdvisor storage backends at [https://github.com/google/cadvisor/blob/master/docs/storage/README.md](https://github.com/google/cadvisor/blob/master/docs/storage/README.md)
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cAdvisor 存储后端在 [https://github.com/google/cadvisor/blob/master/docs/storage/README.md](https://github.com/google/cadvisor/blob/master/docs/storage/README.md)
- en: Debugging containers using sysdig
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 sysdig 调试容器
- en: Sysdig is an awesome tool that can be used for many purposes, including monitoring,
    logging, process debugging, network analyzing, and exploring a system in depth.
    Plus, it includes fantastic Linux container support. It's also scriptable and
    can be fed with recorded real traffic packet captures for offline analysis. It's
    an incredible tool that each and every person working with containers should at
    least know the basics of, and as infrastructure developers used to working with
    code, we know how important debugging tools are. This is no different with sysdig,
    and we'll now discover some of its fantastic features related to containers.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Sysdig是一个非常棒的工具，可以用于许多目的，包括监控、日志记录、进程调试、网络分析以及深入探索系统。它还提供了出色的Linux容器支持。它是可编程的，并且可以使用已录制的真实流量数据包捕获进行离线分析。它是一个不可思议的工具，每一个与容器打交道的人都应该至少了解它的基本功能，作为习惯使用代码的基础设施开发人员，我们知道调试工具有多么重要。Sysdig也不例外，现在我们将探索一些与容器相关的精彩功能。
- en: Getting ready
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备开始
- en: 'To step through this recipe, you will need:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要按此步骤操作，您需要：
- en: A working Docker installation
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可用的 Docker 安装
- en: Sysdig installed and running on the host
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sysdig 已安装并在主机上运行
- en: How to do it...
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Installing sysdig is easy on most platforms, including CoreOS ([http://www.sysdig.org/install/](http://www.sysdig.org/install/)).
    However, if you''re in a hurry, here''s a one liner that will do the job of installing
    Sysdig on your Linux host. We''d probably choose a better way to deploy it programmatically
    though, such as Ansible or Chef, through a Docker container or not:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数平台上安装 sysdig 很容易，包括 CoreOS ([http://www.sysdig.org/install/](http://www.sysdig.org/install/))。不过，如果您赶时间，下面是一个一行命令，可以完成在
    Linux 主机上安装 Sysdig 的工作。当然，我们可能会选择更好的方式通过编程部署它，比如使用 Ansible 或 Chef，是否通过 Docker
    容器部署也无所谓：
- en: '[PRE57]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here''s how to get an htop-like view of all the running containers on the system:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何获得系统上所有正在运行的容器的类似htop的视图：
- en: '[PRE58]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '![How to do it...](img/B05671_10_28.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![如何实现...](img/B05671_10_28.jpg)'
- en: 'Navigating to the **F2/Views** menu helps you enter many different options
    to see what''s running, from processes to syslog to open files and even the Kubernetes,
    Marathon, or Mesos integration. Want to see which container is draining all of
    the IO? You''re at the right place:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 **F2/Views** 菜单可以帮助您进入多个不同的选项，查看正在运行的内容，从进程到syslog，再到打开的文件，甚至包括 Kubernetes、Marathon
    或 Mesos 的集成。想查看哪个容器消耗了所有的 IO？您来对地方了：
- en: '![How to do it...](img/B05671_10_32.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![如何实现...](img/B05671_10_32.jpg)'
- en: 'Here''s an example of a Tomcat container with a view of all the local and remote
    connections, IPs, ports, protocols, bandwidth, IOs, and the corresponding commands—terribly
    useful to find suspicious behavior:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个Tomcat容器的示例，展示了所有本地和远程连接、IP、端口、协议、带宽、IO以及相应的命令——对于查找可疑行为非常有用：
- en: '![How to do it...](img/B05671_10_30.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![如何实现...](img/B05671_10_30.jpg)'
- en: 'Another useful tool is `F5`/`Echo`, grabbing what''s transiting on this container:
    (un)encrypted content, logs, output, and more. This is also very useful to maybe
    catch something wrong with a container acting weird:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的工具是 `F5`/`Echo`，它可以抓取这个容器上正在传输的内容：（解）密内容、日志、输出等。这对于捕捉容器出现异常的情况也非常有用：
- en: '![How to do it...](img/B05671_10_31.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![如何实现...](img/B05671_10_31.jpg)'
- en: 'Another very powerful tool from sysdig is `F6`/`Dig`. This basically offers
    nothing less than a full-fledged `strace` for a container; imagine the debugging
    power it has:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Sysdig 中的另一个非常强大的工具是 `F6`/`Dig`。它基本上提供了一个完整的容器 `strace`；可以想象它强大的调试功能：
- en: '![How to do it...](img/B05671_10_33.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![如何实现...](img/B05671_10_33.jpg)'
- en: 'The `F8`/`Actions` feature is a full Docker command integration tool available
    right from inside sysdig. Select a container and we''ll be able to enter it, read
    logs, see its image history, kill it, and more:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`F8`/`Actions` 功能是一个完整的 Docker 命令集成工具，可以直接在 sysdig 中使用。选择一个容器后，我们可以进入容器，查看日志，查看其镜像历史，杀死容器等：'
- en: '![How to do it...](img/B05671_10_34.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![如何实现...](img/B05671_10_34.jpg)'
- en: 'Those commands are also always available right from the main interface: want
    to gain a shell on this selected container? Just type `b`.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令也可以从主界面直接访问：想要获得这个选定容器的 shell 吗？只需输入 `b`。
- en: These are just a few of the many powerful things we can do with Sysdig using
    Docker containers.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是我们使用 Docker 容器与 Sysdig 结合后能够完成的众多强大功能中的一小部分。
- en: See also
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: More general sysdig usage examples at [http://www.sysdig.org/wiki/sysdig-examples/](http://www.sysdig.org/wiki/sysdig-examples/)
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多的 sysdig 使用示例请参考 [http://www.sysdig.org/wiki/sysdig-examples/](http://www.sysdig.org/wiki/sysdig-examples/)
