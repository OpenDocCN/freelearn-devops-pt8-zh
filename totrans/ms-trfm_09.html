<html><head></head><body>
<div id="_idContainer116">
<h1 class="chapter-number" id="_idParaDest-179"><a id="_idTextAnchor446"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-180"><a id="_idTextAnchor447"/><span class="koboSpan" id="kobo.2.1">Go Serverless with AWS – Building Solutions with AWS Lambda</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we will turn the page to the final installment of our three-part series on </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">Amazon Web Services</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">AWS</span></strong><span class="koboSpan" id="kobo.7.1">). </span><span class="koboSpan" id="kobo.7.2">Having previously built solutions on AWS using </span><strong class="bold"><span class="koboSpan" id="kobo.8.1">Virtual Machines</span></strong><span class="koboSpan" id="kobo.9.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.10.1">VMs</span></strong><span class="koboSpan" id="kobo.11.1">) in </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.13.1"> and then in containers in </span><a href="B21183_08.xhtml#_idTextAnchor402"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.14.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.15.1">, our journey now leads us to an exploration of what building a truly serverless solution looks like </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">on AWS.</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">While the</span><a id="_idIndexMarker710"/><span class="koboSpan" id="kobo.18.1"> foundational concepts and practices from the preceding chapters will help us, some aspects of the solution are completely absent here. </span><span class="koboSpan" id="kobo.18.2">Namely, we don’t need to worry about any operating system configuration, whether it be in Packer </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">or Docker.</span></span></p>
<p><span class="koboSpan" id="kobo.20.1">Our attention now turns to adapting our application code to </span><strong class="bold"><span class="koboSpan" id="kobo.21.1">Lambda</span></strong><span class="koboSpan" id="kobo.22.1">’s application model. </span><span class="koboSpan" id="kobo.22.2">While this necessitates changes to our application code to align with Lambda’s approach, it also presents opportunities to enhance scalability and efficiency without the burden of managing servers. </span><span class="koboSpan" id="kobo.22.3">This shift in focus promises a more streamlined and efficient process. </span><span class="koboSpan" id="kobo.22.4">We’ll spend a bit more time adjusting our application code to conform than provisioning new services </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">using Terraform.</span></span><a id="_idTextAnchor448"/></p>
<p><span class="koboSpan" id="kobo.24.1">This chapter covers the </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.26.1">Laying </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">the foundation</span></span></li>
<li><span class="koboSpan" id="kobo.28.1">Designing </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">the solution</span></span></li>
<li><span class="koboSpan" id="kobo.30.1">Building </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">the solution</span></span></li>
<li><span class="koboSpan" id="kobo.32.1">Automating </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">the deployment</span></span></li>
</ul>
<h1 id="_idParaDest-181"><a id="_idTextAnchor449"/><span class="koboSpan" id="kobo.34.1">Laying the foundation</span></h1>
<p><span class="koboSpan" id="kobo.35.1">Our story </span><a id="_idIndexMarker711"/><span class="koboSpan" id="kobo.36.1">continues through the lens of Söze Enterprises, founded by the enigmatic Turkish billionaire Keyser Söze. </span><span class="koboSpan" id="kobo.36.2">Our team has been hard at work building the next-generation autonomous vehicle orchestration platform. </span><span class="koboSpan" id="kobo.36.3">Our initial strategy involved minimizing change to allow the team to focus on driving features into our product. </span><span class="koboSpan" id="kobo.36.4">However, our elusive CEO had other ideas and pushed us to adopt container technology to make our product more flexible and scalable going forward. </span><span class="koboSpan" id="kobo.36.5">Working with Keyser, there is never a dull moment, but managing such radical change so quickly can </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">be frustrating.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">Meanwhile, in Davos, Switzerland, with the World Economic Forum in full swing, Keyser has a chance encounter at the espresso bar with Werner Vogels, with whom he immediately hits it off. </span><span class="koboSpan" id="kobo.38.2">When Werner gets a glimpse of Keyser’s immense vision for the autonomous vehicle platform, he casually suggests that maybe Keyser shouldn’t concern himself with infrastructure at all and that leveraging AWS’s serverless offerings could free him from the shackles of infrastructure management to allow him to focus on his </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">grand vision.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">Thanks to Werner’s insights and Keyser’s whimsical decision-making, our team veers deeper into AWS, explicitly transitioning from Amazon </span><strong class="bold"><span class="koboSpan" id="kobo.41.1">Elastic Kubernetes Service</span></strong><span class="koboSpan" id="kobo.42.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.43.1">EKS</span></strong><span class="koboSpan" id="kobo.44.1">) to AWS</span><a id="_idIndexMarker712"/><span class="koboSpan" id="kobo.45.1"> Lambda for serverless computing. </span><span class="koboSpan" id="kobo.45.2">This might require a complete re-think of our application architecture, but it could free us from the significant operational overhead of managing </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">low-level infrastructur</span><a id="_idTextAnchor450"/><span class="koboSpan" id="kobo.47.1">e.</span></span></p>
<h1 id="_idParaDest-182"><a id="_idTextAnchor451"/><span class="koboSpan" id="kobo.48.1">Designing the solution</span></h1>
<p><span class="koboSpan" id="kobo.49.1">In this section, we </span><a id="_idIndexMarker713"/><span class="koboSpan" id="kobo.50.1">will look at the overall design of our solution, given the shift from VM- and container-based architectures toward serverless architectures. </span><span class="koboSpan" id="kobo.50.2">Serverless has the quintessential objective of eliminating heavy infrastructure from the stack at its core. </span><span class="koboSpan" id="kobo.50.3">Therefore, we will look for ways to shed any AWS services requiring significant fixed costs, such as EC2 instances or EKS clusters, and replace them with serverless options. </span><span class="koboSpan" id="kobo.50.4">This change in our operational context and technology landscape will require us to rethink our solution’s design, implementation, and </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">deployment strategy:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer104">
<span class="koboSpan" id="kobo.52.1"><img alt="Figure 9.1 – Logical architecture for the autonomous vehicle platform" src="image/B21183_09_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.53.1">Figure 9.1 – Logical architecture for the autonomous vehicle platform</span></p>
<p><span class="koboSpan" id="kobo.54.1">Our</span><a id="_idIndexMarker714"/><span class="koboSpan" id="kobo.55.1"> application’s architecture doesn’t change significantly, but we will be using different Azure services to host it. </span><span class="koboSpan" id="kobo.55.2">In this case, we’ll be using Azure Storage to host the application’s frontend and Azure Functions to host the </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">application’s backend:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer105">
<span class="koboSpan" id="kobo.57.1"><img alt="Figure 9.2 – Source control structure of our repository" src="image/B21183_09_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.58.1">Figure 9.2 – Source control structure of our repository</span></p>
<p><span class="koboSpan" id="kobo.59.1">In this solution, we’ll have four parts of our code base. </span><span class="koboSpan" id="kobo.59.2">The first two are the Terraform code that provisions the environment and the GitHub Actions code that executes the deployment process. </span><span class="koboSpan" id="kobo.59.3">Then we have the two code bases for our application’s frontend </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">and backen</span><a id="_idTextAnchor452"/><span class="koboSpan" id="kobo.61.1">d.</span></span></p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor453"/><span class="koboSpan" id="kobo.62.1">Cloud architecture</span></h2>
<p><span class="koboSpan" id="kobo.63.1">In </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.64.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.65.1">, our</span><a id="_idIndexMarker715"/><span class="koboSpan" id="kobo.66.1"> cloud-hosting solution was a set of dedicated EC2 instances. </span><span class="koboSpan" id="kobo.66.2">In </span><a href="B21183_08.xhtml#_idTextAnchor402"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.67.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.68.1">, it was a set of shared EC2 instances </span><a id="_idIndexMarker716"/><span class="koboSpan" id="kobo.69.1">managed by our Kubernetes cluster’s node pool. </span><span class="koboSpan" id="kobo.69.2">Using VMs, whether standalone VMs or ones that are part of a Kubernetes node pool, has the most </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">sunk cost.</span></span></p>
<p><span class="koboSpan" id="kobo.71.1">In </span><a href="B21183_08.xhtml#_idTextAnchor402"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.72.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.73.1">, our entire solution was executed on containers that allowed the front- and backends to coexist as a set of containers on the same VMs. </span><span class="koboSpan" id="kobo.73.2">This saved some money, but we still needed servers to host the workload. </span><span class="koboSpan" id="kobo.73.3">In this chapter, we will have a new objective: to take advantage of the power of the cloud by leveraging cloud-native services that abstract the underlying infrastructure from us and allow us to truly only pay for what we use. </span><span class="koboSpan" id="kobo.73.4">AWS’s serverless offerings will be crucial to us in </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">this endea</span><a id="_idTextAnchor454"/><span class="koboSpan" id="kobo.75.1">vor.</span></span></p>
<h3><span class="koboSpan" id="kobo.76.1">Frontend</span></h3>
<p><span class="koboSpan" id="kobo.77.1">In </span><a id="_idIndexMarker717"/><span class="koboSpan" id="kobo.78.1">previous chapters, we hosted our frontend on public-facing servers that returned the HTML and JavaScript that composed our web application. </span><span class="koboSpan" id="kobo.78.2">However, we still require a cloud-hosted solution to host the files and respond to requests in </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">both solutions.</span></span></p>
<p><span class="koboSpan" id="kobo.80.1">However, due to the nature of the web application running within the end user’s browser, we don’t need to use cloud-hosted VMs to host what are essentially flat files. </span><span class="koboSpan" id="kobo.80.2">We can use simple cloud storage to host the frontend as a static website and rely on the cloud platform to shoulder the burden of returning the </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">web content.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">On AWS, we</span><a id="_idIndexMarker718"/><span class="koboSpan" id="kobo.83.1"> can use </span><strong class="bold"><span class="koboSpan" id="kobo.84.1">Simple Storage Service</span></strong><span class="koboSpan" id="kobo.85.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.86.1">S3</span></strong><span class="koboSpan" id="kobo.87.1">). </span><span class="koboSpan" id="kobo.87.2">This service allows us to host static web content that is internet-accessible. </span><span class="koboSpan" id="kobo.87.3">S3 handles all the load balancing, SSL termination, and scaling up to meet huge spikes </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">in demand:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer106">
<span class="koboSpan" id="kobo.89.1"><img alt="Figure 9.3 – S3 handles web page requests, Lambda handles REST API requests" src="image/B21183_09_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.90.1">Figure 9.3 – S3 handles web page requests, Lambda handles REST API requests</span></p>
<p><span class="koboSpan" id="kobo.91.1">In order</span><a id="_idIndexMarker719"/><span class="koboSpan" id="kobo.92.1"> to do this, we’ll need an S3 bucket. </span><span class="koboSpan" id="kobo.92.2">We will need to enable public internet access to its contents. </span><span class="koboSpan" id="kobo.92.3">This will require a combination of S3 and IAM configuration. </span><span class="koboSpan" id="kobo.92.4">All S3 buckets have an internet-accessible public domain. </span><span class="koboSpan" id="kobo.92.5">When we activate the static websites feature of S3, internet traffic gets routed to content hosted in </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">our bucket.</span></span></p>
<p><span class="koboSpan" id="kobo.94.1">This will give us a huge advantage because S3 has no sunk costs. </span><span class="koboSpan" id="kobo.94.2">Creating an S3 bucket costs you absolutely zero dollars per month. </span><span class="koboSpan" id="kobo.94.3">Like other serverless offerings, it uses a set of micro-transactions to measure your activity and charge you for precisely what you use. </span><span class="koboSpan" id="kobo.94.4">In S3, this can be a bit complicated, as several measurements </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">incur costs:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-1">
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.96.1">Metric</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.97.1">Unit</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.98.1">Scale</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.99.1">Price</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.100.1">Storage</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.101.1">GB</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.102.1">1,000</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.103.1">$</span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">0.023</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.105.1">Read transactions</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.106.1">Transactions</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.107.1">10,000</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.108.1">$</span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">0.0004</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.110.1">Write transactions</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.111.1">Transactions</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.112.1">10,000</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.113.1">$</span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">0.005</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.115.1">Other operations</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.116.1">Transactions</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.117.1">10,000</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.118.1">$</span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">0.01</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.120.1">Table 9.1 – AWS S3’s micro-transactional pricing</span></p>
<p><span class="koboSpan" id="kobo.121.1">The preceding table shows all the costs you will run into when using AWS to host your static websites. </span><span class="koboSpan" id="kobo.121.2">The prices listed are accurate for AWS’s US West (Oregon) region at the time of </span><a id="_idIndexMarker720"/><span class="koboSpan" id="kobo.122.1">writing. </span><span class="koboSpan" id="kobo.122.2">Prices may have changed by the time you read this, so it’s best to check the latest prices for the most accurate </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">cost estimation.</span></span></p>
<p><span class="koboSpan" id="kobo.124.1">I included these prices to make a point. </span><span class="koboSpan" id="kobo.124.2">We can host a static website on a three-node Kubernetes cluster for approximately $300 a month, or on AWS S3 for less than $0.01 a month. </span><span class="koboSpan" id="kobo.124.3">Which approach would </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">you choose?</span></span><a id="_idTextAnchor455"/></p>
<h3><span class="koboSpan" id="kobo.126.1">Backend</span></h3>
<p><span class="koboSpan" id="kobo.127.1">Like our</span><a id="_idIndexMarker721"/><span class="koboSpan" id="kobo.128.1"> frontend, in previous chapters, our backend was also hosted on VMs in two different ways: dedicated VMs and shared VMs within the node pool on our </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">Kubernetes cluster.</span></span></p>
<p><span class="koboSpan" id="kobo.130.1">Unlike the frontend, our backend doesn’t have the option of running entirely client-side inside the end user’s web browser. </span><span class="koboSpan" id="kobo.130.2">In the backend, we have custom code that needs to run on a server. </span><span class="koboSpan" id="kobo.130.3">Therefore, we need to find a solution to host these components without all the overhead of a fleet </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">of VMs.</span></span></p>
<p><span class="koboSpan" id="kobo.132.1">We can use Lambda Functions on AWS to accomplish this. </span><span class="koboSpan" id="kobo.132.2">AWS Lambda is a managed service that allows you to deploy your code without paying the sunk costs for any of the underlying VMs. </span><span class="koboSpan" id="kobo.132.3">Like S3, it has its micro-transactional pricing model that charges you for precisely what </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">you use:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table002">
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.134.1">Metric</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.135.1">Unit</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.136.1">Scale</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.137.1">Price ($)</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.138.1">Execution time</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.139.1">GB/s</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.140.1">1</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.141.1">$</span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">0.0000166667</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.143.1">Total executions</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.144.1">Transactions</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.145.1">1,000,000</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.146.1">$</span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">0.020</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.148.1">Table 9.2 – AWS Lambda’s micro-transactional pricing</span></p>
<p><span class="koboSpan" id="kobo.149.1">The preceding table shows the costs associated with deploying your code to Lambda Functions. </span><span class="koboSpan" id="kobo.149.2">The first thing you’ll probably notice is that, like S3, these prices are extremely low and measure a very small amount of activity on </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">the platform.</span></span></p>
<p><span class="koboSpan" id="kobo.151.1">For example, the execution time metric has a unit of GB/s, which is the amount of memory that your Lambda Function uses per second in GB. </span><span class="koboSpan" id="kobo.151.2">Given that it measures at a per-second interval, you don’t have to run your Lambda Functions very long to rack up quite a few of these. </span><span class="koboSpan" id="kobo.151.3">The execution time cost can be adjusted based on how much memory you allocate. </span><span class="koboSpan" id="kobo.151.4">You can choose to allocate any amount of memory between 128 MB and </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">10 GB.</span></span></p>
<p><span class="koboSpan" id="kobo.153.1">While </span><a id="_idIndexMarker722"/><span class="koboSpan" id="kobo.154.1">straightforward, the total executions metric is subject to AWS Lambda’s built-in constraints, including execution time limits. </span><span class="koboSpan" id="kobo.154.2">For example, each of these executions is limited to 15 minutes. </span><span class="koboSpan" id="kobo.154.3">Suppose you are trying to respond to requests from a web application. </span><span class="koboSpan" id="kobo.154.4">In that case, you probably won’t want to design your Lambda Function to take 15 minutes anyway, as this would be a poor experience for the end users of the web browser. </span><span class="koboSpan" id="kobo.154.5">In this scenario, you would want your Lambda Function to return in no more than a few seconds. </span><span class="koboSpan" id="kobo.154.6">However, Lambda Functions can be employed for many different tasks besides responding to HTTP requests from a browser. </span><span class="koboSpan" id="kobo.154.7">In these situations, you must carefully design your Lambda solution to stay within this execution time limitation. </span><span class="koboSpan" id="kobo.154.8">This may require you to think about how to split up the work so that it can be processed more parallelly by hundreds, if not thousands, of instances of your </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">Lambda Function:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer107">
<span class="koboSpan" id="kobo.156.1"><img alt="Figure 9.4 – The backend’s architecture using Lambda" src="image/B21183_09_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.157.1">Figure 9.4 – The backend’s architecture using Lambda</span></p>
<p><span class="koboSpan" id="kobo.158.1">Previously, our </span><a id="_idIndexMarker723"/><span class="koboSpan" id="kobo.159.1">ASP.NET REST API was set up using a traditional ASP.NET project that used controllers to implement the REST API endpoints. </span><span class="koboSpan" id="kobo.159.2">However, when transitioning to Lambda Functions, we would expect the code base to be structured much differently. </span><span class="koboSpan" id="kobo.159.3">To host our REST API as Lambda Functions, we need to conform to the framework that Lambda dictates. </span><span class="koboSpan" id="kobo.159.4">As a result, the ASP.NET controller classes must be refactored to conform to this standard. </span><span class="koboSpan" id="kobo.159.5">In the next section, we’ll delve into the code that makes </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">this possible.</span></span><a id="_idTextAnchor456"/></p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor457"/><span class="koboSpan" id="kobo.161.1">Deployment architecture</span></h2>
<p><span class="koboSpan" id="kobo.162.1">Now that we have</span><a id="_idIndexMarker724"/><span class="koboSpan" id="kobo.163.1"> a good idea of what our cloud architecture for our solution on AWS will look like, we need to devise a plan for provisioning our environments and deploying </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">our code.</span></span></p>
<p><span class="koboSpan" id="kobo.165.1">In </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.166.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.167.1">, when we deployed our application to VMs, we baked our compiled application code into a VM image using Packer. </span><span class="koboSpan" id="kobo.167.2">Similarly, in </span><a href="B21183_08.xhtml#_idTextAnchor402"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.168.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.169.1">, when we deployed our application to containers on our Kubernetes cluster, we baked our application code into container images using Docker. </span><span class="koboSpan" id="kobo.169.2">With serverless, this completely changes because AWS’s serverless offerings completely abstract away the operating system. </span><span class="koboSpan" id="kobo.169.3">This means that all we are responsible for is producing a compatible </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">deployment package</span><a id="_idTextAnchor458"/><span class="koboSpan" id="kobo.171.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.172.1">Creating the deployment package</span></h3>
<p><span class="koboSpan" id="kobo.173.1">As we discussed </span><a id="_idIndexMarker725"/><span class="koboSpan" id="kobo.174.1">in the previous section, our application has two components: the frontend and the backend. </span><span class="koboSpan" id="kobo.174.2">Each has a different deployment target. </span><span class="koboSpan" id="kobo.174.3">For the frontend, we are going to be deploying as a static website to AWS S3, while the backend is going to be deployed as an AWS Lambda Function. </span><span class="koboSpan" id="kobo.174.4">Since both are .NET projects, we will be using both .NET and AWS platform-specific tools in order to create deployment packages and deploy them to their target AWS services. </span><span class="koboSpan" id="kobo.174.5">The following diagram shows the process we will go through in order to provision our environment, package our application code, and deploy it to the target environment out </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">in AWS:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer108">
<span class="koboSpan" id="kobo.176.1"><img alt="Figure 9.5 – The resource deployment pipeline to build our .NET application code for deployment to AWS" src="image/B21183_09_5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.177.1">Figure 9.5 – The resource deployment pipeline to build our .NET application code for deployment to AWS</span></p>
<p><span class="koboSpan" id="kobo.178.1">For the frontend, this means enabling the feature to deploy our ASP.NET Blazor web application as a web assembly. </span><span class="koboSpan" id="kobo.178.2">This will allow the frontend to be hosted as a static website</span><a id="_idIndexMarker726"/><span class="koboSpan" id="kobo.179.1"> running completely client-side without server-side rendering. </span><span class="koboSpan" id="kobo.179.2">This is only possible because of the way we have designed our front-end web application, which uses HTML, CSS, and JavaScript to interact with server-side REST APIs. </span><span class="koboSpan" id="kobo.179.3">It’s important to note that ASP.NET Blazor supports both hosting options. </span><span class="koboSpan" id="kobo.179.4">Still, we chose to go down the client-side-only path and eliminate any dependency on server-side page rendering. </span><span class="koboSpan" id="kobo.179.5">As a result, when we use the .NET CLI to publish our ASP.NET Blazor project, it will emit a folder containing static web content. </span><span class="koboSpan" id="kobo.179.6">Then, using the AWS CLI, we can upload the contents of this folder to our S3 bucket to complete </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">the deployment.</span></span></p>
<p><span class="koboSpan" id="kobo.181.1">Using the .NET CLI, we will publish our project for the backend, which emits all the files necessary for the AWS Lambda service to recognize and execute our </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">Lambda Function.</span></span></p>
<p><span class="koboSpan" id="kobo.183.1">Once this is done, we must zip this folder into a ZIP archive. </span><span class="koboSpan" id="kobo.183.2">Finally, we can use the AWS CLI to deploy this ZIP archive to our </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">Lambda Functio</span><a id="_idTextAnchor459"/><span class="koboSpan" id="kobo.185.1">n.</span></span></p>
<p><span class="koboSpan" id="kobo.186.1">Now that we have a solid plan for how we will implement both the cloud architecture using AWS and the deployment architecture using GitHub Actions, let’s start building! </span><span class="koboSpan" id="kobo.186.2">In the next section, we’ll break down the HashiCorp Configuration Language code we use to implement the Terraform and modify the application code to conform to AWS </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">Lambda’s framework.</span></span></p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor460"/><span class="koboSpan" id="kobo.188.1">Building the solution</span></h1>
<p><span class="koboSpan" id="kobo.189.1">Now that</span><a id="_idIndexMarker727"/><span class="koboSpan" id="kobo.190.1"> we have a solid design for our solution, we can begin building it. </span><span class="koboSpan" id="kobo.190.2">As discussed in the previous section, since we’ll be using AWS serverless offerings such as AWS S3 and Lambda Functions to host our application, we will need to make some changes to our application code. </span><span class="koboSpan" id="kobo.190.3">We never had to do this in </span><em class="italic"><span class="koboSpan" id="kobo.191.1">Chapters 7</span></em><span class="koboSpan" id="kobo.192.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.193.1">8</span></em><span class="koboSpan" id="kobo.194.1">, as we were able to deploy our application to the cloud by packaging it in either a VM image (using Packer) or a container image (using Docker). </span><span class="koboSpan" id="kobo.194.2">Therefore, we need to write some Terraform code and update our application code in C# to build </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">our soluti</span><a id="_idTextAnchor461"/><span class="koboSpan" id="kobo.196.1">on.</span></span></p>
<h2 id="_idParaDest-186"><a id="_idTextAnchor462"/><span class="koboSpan" id="kobo.197.1">Terraform</span></h2>
<p><span class="koboSpan" id="kobo.198.1">As we </span><a id="_idIndexMarker728"/><span class="koboSpan" id="kobo.199.1">discussed in our design, our solution consists of two application components: the frontend and the backend. </span><span class="koboSpan" id="kobo.199.2">Each has its own code base of application code that needs to be deployed. </span><span class="koboSpan" id="kobo.199.3">In previous chapters, we also had the operating </span><a id="_idIndexMarker729"/><span class="koboSpan" id="kobo.200.1">system configuration. </span><span class="koboSpan" id="kobo.200.2">Now that we are using serverless offerings, this is no longer our responsibility, as the platform will take care of it </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">for us.</span></span></p>
<p><span class="koboSpan" id="kobo.202.1">Much of the Terraform setup is very similar to what we have done in previous chapters, so we will only focus on new resources needed for our solution. </span><span class="koboSpan" id="kobo.202.2">If you want to work with the complete solution, you can check the full source code for this book, which is available </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">on GitHub.</span></span></p>
<h3><span class="koboSpan" id="kobo.204.1">Frontend</span></h3>
<p><span class="koboSpan" id="kobo.205.1">First, we </span><a id="_idIndexMarker730"/><span class="koboSpan" id="kobo.206.1">need to provision an AWS S3 bucket to which we can deploy our frontend. </span><span class="koboSpan" id="kobo.206.2">The S3 bucket is one of the most common Terraform resources to be provisioned, as many other AWS services use S3 buckets for </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">different purposes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.208.1">
resource "aws_s3_bucket" "frontend" {
  bucket        = "${var.application_name}-${var.environment_name}-frontend"
  tags = {
    Name        = "${var.application_name}-${var.environment_name}-frontend"
    application = var.application_name
    environment = var.environment_name
  }
}</span></pre> <p><span class="koboSpan" id="kobo.209.1">However, we need to configure our S3 bucket a bit differently by using a couple of additional resources. </span><span class="koboSpan" id="kobo.209.2">First, we need to configure public access using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">aws_s3_bucket_public_access_block</span></strong><span class="koboSpan" id="kobo.211.1"> resource. </span><span class="koboSpan" id="kobo.211.2">Then we need to configure our static website using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">aws_s3_bucket_website_configuration</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.213.1"> resource:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.214.1">
resource "aws_s3_bucket_public_access_block" "frontend" {
  bucket = aws_s3_bucket.frontend.id
  block_public_acls       = false
  block_public_policy     = false
  ignore_public_acls      = false
  restrict_public_buckets = false
}</span></pre> <p><span class="koboSpan" id="kobo.215.1">The</span><a id="_idIndexMarker731"/><span class="koboSpan" id="kobo.216.1"> configuration is pretty simple, but it is critical for enabling our S3 bucket to be accessible over the internet. </span><span class="koboSpan" id="kobo.216.2">By altering our configuration here, we could also opt to host static websites that are not accessible over the internet. </span><span class="koboSpan" id="kobo.216.3">This might be ideal for intranet websites that we only want accessible when on a </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">private network:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.218.1">
resource "aws_s3_bucket_website_configuration" "frontend" {
  bucket = aws_s3_bucket.frontend.id
  index_document {
    suffix = "index.html"
  }
  error_document {
    key = "error.html"
  }
}</span></pre> <p><span class="koboSpan" id="kobo.219.1">This configures the S3 bucket to specify the default web page when it redirects web traffic to the content stored within our bucket. </span><span class="koboSpan" id="kobo.219.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">index.html</span></strong><span class="koboSpan" id="kobo.221.1"> page aligns with what our ASP.NET Blazor web application uses </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">by default.</span></span></p>
<p><span class="koboSpan" id="kobo.223.1">Lastly, we </span><a id="_idIndexMarker732"/><span class="koboSpan" id="kobo.224.1">need to configure </span><strong class="bold"><span class="koboSpan" id="kobo.225.1">Identity and Access Management</span></strong><span class="koboSpan" id="kobo.226.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.227.1">IAM</span></strong><span class="koboSpan" id="kobo.228.1">) to allow access to our S3 bucket. </span><span class="koboSpan" id="kobo.228.2">A common </span><a id="_idIndexMarker733"/><span class="koboSpan" id="kobo.229.1">technique within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">aws</span></strong><span class="koboSpan" id="kobo.231.1"> provider is to use a Data Source resource to generate IAM policy documents that can then be attached to other </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">provisioned resources:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.233.1">
data "aws_iam_policy_document" "frontend" {
  statement {
    actions   = ["s3:GetObject"]
    resources = ["${aws_s3_bucket.frontend.arn}/*"]
    principals {
      type        = "*"
      identifiers = ["*"]
    }
  }
}</span></pre> <p><span class="koboSpan" id="kobo.234.1">The preceding data source emits the correct policy document, which we can use when configuring the S3 bucket’s policy using an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">aws_s3_bucket_policy</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.236.1"> resource:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.237.1">
resource "aws_s3_bucket_policy" "frontend" {
  bucket = aws_s3_bucket.frontend.id
  policy = data.aws_iam_policy_document.frontend.json
  depends_on = [aws_s3_bucket_public_access_block.frontend]
}</span></pre> <h3><span class="koboSpan" id="kobo.238.1">Backend</span></h3>
<p><span class="koboSpan" id="kobo.239.1">Lambda</span><a id="_idIndexMarker734"/><span class="koboSpan" id="kobo.240.1"> Functions are deployed to an </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">aws_lambda_function</span></strong><span class="koboSpan" id="kobo.242.1"> resource, but the most important thing to set up first is the IAM role you will use for your Lambda Function. </span><span class="koboSpan" id="kobo.242.2">This will be how we allow our Lambda Function access to other resources on AWS, such as secrets and logging. </span><span class="koboSpan" id="kobo.242.3">It is also how we allow it to communicate with databases and other services our application code needs to </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">communicate with:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.244.1">
data "aws_iam_policy_document" "lambda" {
  statement {
    effect = "Allow"
    principals {
      type        = "Service"
      identifiers = ["lambda.amazonaws.com"]
    }
    actions = ["sts:AssumeRole"]
  }
}</span></pre> <p><span class="koboSpan" id="kobo.245.1">We will start with an IAM policy document for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">sts:AssumeRole</span></strong><span class="koboSpan" id="kobo.247.1"> permissions and scope it to Lambda Functions. </span><span class="koboSpan" id="kobo.247.2">Then we define the IAM role and use this as </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">assume_role_policy</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.251.1">
resource "aws_iam_role" "lambda" {
  name               = "${var.application_name}-${var.environment_name}-lambda"
  assume_role_policy = data.aws_iam_policy_document.lambda.json
}</span></pre> <p><span class="koboSpan" id="kobo.252.1">We can grant more permissions later by defining additional policies and attaching them to this IAM role; more</span><a id="_idIndexMarker735"/><span class="koboSpan" id="kobo.253.1"> on that later. </span><span class="koboSpan" id="kobo.253.2">Now, it’s time to provision our </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">Lambda Function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.255.1">
resource "aws_lambda_function" "main" {
  function_name = "${var.application_name}-${var.environment_name}"
  role          = aws_iam_role.lambda.arn
  runtime       = "dotnet6"
  filename      = "deployment.zip"
  handler       = "FleetAPI::FleetAPI.Function::FunctionHandler"
  tags = {
    Name        = "${var.application_name}-${var.environment_name}-lambda"
    application = var.application_name
    environment = var.environment_name
  }
}</span></pre> <p><span class="koboSpan" id="kobo.256.1">As in the previous two chapters, we must consistently tag our AWS resources with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">application</span></strong><span class="koboSpan" id="kobo.258.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">environment</span></strong><span class="koboSpan" id="kobo.260.1"> tags. </span><span class="koboSpan" id="kobo.260.2">These tags organize our deployment into an AWS resource group for easier </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">centralized management.</span></span></p>
<p><span class="koboSpan" id="kobo.262.1">A key attribute here is </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">runtime</span></strong><span class="koboSpan" id="kobo.264.1">, which in our case is .NET 6. </span><span class="koboSpan" id="kobo.264.2">Depending on your technology stack, this will, of course, vary. </span><span class="koboSpan" id="kobo.264.3">However, perhaps the most important attribute is </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">handler</span></strong><span class="koboSpan" id="kobo.266.1">. </span><span class="koboSpan" id="kobo.266.2">This is also the trickiest one to set, as it needs to be carefully aligned with our application code. </span><span class="koboSpan" id="kobo.266.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">handler</span></strong><span class="koboSpan" id="kobo.268.1"> is a path to a component in our application code. </span><span class="koboSpan" id="kobo.268.2">In .NET, this path is made up of three parts: the namespace, the fully qualified class name, and the </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">method name.</span></span></p>
<p><span class="koboSpan" id="kobo.270.1">We can also use an optional nested block to set additional environment variables to help configure the </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">Lambda Function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.272.1">
environment {
  variables = {
    SECRET_SAUCE = random_string.secret_sauce.result
  }
}</span></pre> <p><span class="koboSpan" id="kobo.273.1">This can</span><a id="_idIndexMarker736"/><span class="koboSpan" id="kobo.274.1"> be a useful way to pass in configuration to Lambda, which is output by other </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">Terrafor</span><a id="_idTextAnchor463"/><span class="koboSpan" id="kobo.276.1">m resources.</span></span></p>
<h3><span class="koboSpan" id="kobo.277.1">Logging</span></h3>
<p><span class="koboSpan" id="kobo.278.1">As we’ve seen, AWS</span><a id="_idIndexMarker737"/><span class="koboSpan" id="kobo.279.1"> uses IAM policies to grant access to other foundational services on the platform. </span><span class="koboSpan" id="kobo.279.2">This is necessary for even things such </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">as logging:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.281.1">
resource "aws_iam_policy" "lambda_logging" {
  name        = "${var.application_name}-${var.environment_name}-lambda-logging-policy"
  description = "Allow Lambda to log to CloudWatch"
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = [
          "logs:CreateLogGroup",
          "logs:CreateLogStream",
          "logs:PutLogEvents"
        ]
        Effect   = "Allow"
        Resource = "arn:aws:logs:*:*:*"
      }
    ]
  })
}</span></pre> <p><span class="koboSpan" id="kobo.282.1">In the </span><a id="_idIndexMarker738"/><span class="koboSpan" id="kobo.283.1">preceding code, we are creating a policy that allows our Lambda Function to write </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">to CloudWatch.</span></span></p>
<p><span class="koboSpan" id="kobo.285.1">Finally, we must attach this policy to the IAM role that we created for our </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">Lambda Function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.287.1">
resource "aws_iam_role_policy_attachment" "lambda_logging" {
  role       = aws_iam_role.lambda.name
  policy_arn = aws_iam_policy.lambda_logging.arn
}</span></pre> <p><span class="koboSpan" id="kobo.288.1">This is what it </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">looks like:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer109">
<span class="koboSpan" id="kobo.290.1"><img alt="Figure 9.6 – IAM policy to grant access to CloudWatch logging" src="image/B21183_09_6.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.291.1">Figure 9.6 – IAM policy to grant access to CloudWatch logging</span></p>
<p><span class="koboSpan" id="kobo.292.1">This </span><a id="_idIndexMarker739"/><span class="koboSpan" id="kobo.293.1">will allow us to use CloudWatch to see what’s happening inside our application code every time our Lambda Function is executed, which is critical for troubleshooting </span><a id="_idTextAnchor464"/><span class="No-Break"><span class="koboSpan" id="kobo.294.1">and debugging.</span></span></p>
<h3><span class="koboSpan" id="kobo.295.1">Secrets management</span></h3>
<p><span class="koboSpan" id="kobo.296.1">We saw</span><a id="_idIndexMarker740"/><span class="koboSpan" id="kobo.297.1"> that we could set environment variables on our Lambda Function. </span><span class="koboSpan" id="kobo.297.2">Still, if we want better control over our secrets, we may want to use AWS Secrets Manager to manage them and then configure our Lambda Function to access them </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">from there.</span></span></p>
<p><span class="koboSpan" id="kobo.299.1">For example, we’ll set up a password using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">random_password</span></strong><span class="koboSpan" id="kobo.301.1"> resource from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">random</span></strong><span class="koboSpan" id="kobo.303.1"> utility provider that we reviewed in </span><a href="B21183_03.xhtml#_idTextAnchor185"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.304.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.305.1">. </span><span class="koboSpan" id="kobo.305.2">Sometimes AWS services generate secrets on your behalf and sometimes they allow you to specify your own. </span><span class="koboSpan" id="kobo.305.3">In that situation, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">random_password</span></strong><span class="koboSpan" id="kobo.307.1"> resource can be </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">very useful:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.309.1">
resource "random_password" "secret_sauce" {
  length  = 8
  lower   = false
  special = false
}</span></pre> <p><span class="koboSpan" id="kobo.310.1">The preceding code declares a password that we will use as our secret. </span><span class="koboSpan" id="kobo.310.2">Then we need to create a Secrets Manager </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">secret</span></strong><span class="koboSpan" id="kobo.312.1"> to hold </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">this secret:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.314.1">
resource "aws_secretsmanager_secret" "secret_sauce" {
  name = "secret-sauce"
  tags = {
    application = var.application_name
    environment = var.environment_name
  }
}</span></pre> <p><span class="koboSpan" id="kobo.315.1">The </span><a id="_idIndexMarker741"/><span class="koboSpan" id="kobo.316.1">preceding code generates the secret, but you must store secret values in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">aws_secretsmanager_secret_version</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.318.1"> sub-resource:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.319.1">
resource "aws_secretsmanager_secret_version" "secret_sauce" {
  secret_id     = aws_secretsmanager_secret.secret_sauce.id
  secret_string = random_string.secret_sauce.result
}</span></pre> <p><span class="koboSpan" id="kobo.320.1">There are additional features that can be enabled to handle automatic rotation and custom encryption that you could </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">also consider.</span></span></p>
<p><span class="koboSpan" id="kobo.322.1">Now that our secret has been created and stored in Secrets Manager, we must create an IAM policy to grant our Lambda </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">Function access:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.324.1">
resource "aws_iam_policy" "lambda_secrets" {
  name        = "${var.application_name}-${var.environment_name}-secrets-policy"
  description = "Policy to allow Lambda function to access secrets."
</span><span class="koboSpan" id="kobo.324.2">  policy = jsonencode({
    Version = "2012-10-17",
    Statement = [
      {
        Action = ["secretsmanager:GetSecretValue"],
        Effect = "Allow",
        Resource = [
          aws_secretsmanager_secret.secret_sauce.arn
        ]
      }
    ]
  })
}</span></pre> <p><span class="koboSpan" id="kobo.325.1">We</span><a id="_idIndexMarker742"/><span class="koboSpan" id="kobo.326.1"> will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">aws_iam_role_policy_attachment</span></strong><span class="koboSpan" id="kobo.328.1"> to attach the policy to the Lambda Function’s IAM role just as we did for the permissions to log to CloudWatch. </span><span class="koboSpan" id="kobo.328.2">If you need to use additional secrets, you can continue to add them to the resource array where </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">secret_sauce</span></strong><span class="koboSpan" id="kobo.330.1"> has </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">been added.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer110">
<span class="koboSpan" id="kobo.332.1"><img alt="Figure 9.7 – Resource IAM policy to grant access to Secrets Manager secrets" src="image/B21183_09_7.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.333.1">Figure 9.7 – Resource IAM policy to grant access to Secrets Manager secrets</span></p>
<p><span class="koboSpan" id="kobo.334.1">As you </span><a id="_idIndexMarker743"/><span class="koboSpan" id="kobo.335.1">can see, the Lambda Function has a much simpler deployment. </span><span class="koboSpan" id="kobo.335.2">We don’t need a virtual network or any other surrounding resources we provisioned in previous chapters to get off the ground. </span><span class="koboSpan" id="kobo.335.3">For most applications, the built-in security of Lambda Functions and Secrets Manager is sufficient. </span><span class="koboSpan" id="kobo.335.4">If we wanted to enable private networking because our application has to follow some regulatory compliance, we could do that. </span><span class="koboSpan" id="kobo.335.5">However, it</span><a id="_idTextAnchor465"/><span class="koboSpan" id="kobo.336.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">not required.</span></span></p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor466"/><span class="koboSpan" id="kobo.338.1">Application code</span></h2>
<p><span class="koboSpan" id="kobo.339.1">AWS Lambda</span><a id="_idIndexMarker744"/><span class="koboSpan" id="kobo.340.1"> is inherently event-based. </span><span class="koboSpan" id="kobo.340.2">Each</span><a id="_idIndexMarker745"/><span class="koboSpan" id="kobo.341.1"> Lambda Function is triggered by a different type of event. </span><span class="koboSpan" id="kobo.341.2">The AWS Lambda service provides many different event types to trigger your Lambda Function from a wide variety of other AWS services. </span><span class="koboSpan" id="kobo.341.3">This makes it easy to design Lambda Functions that can respond to all sorts of activities within your AWS environment. </span><span class="koboSpan" id="kobo.341.4">For </span><a id="_idIndexMarker746"/><span class="koboSpan" id="kobo.342.1">the purposes of this book, we’ll focus on the Application Load Balancer only. </span><span class="koboSpan" id="kobo.342.2">If you are interested in this topic, I’d recommend that you check out all the other options that AWS Lambda has—they are </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">quite extensive.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer111">
<span class="koboSpan" id="kobo.344.1"><img alt="Figure 9.8 – Resource ASP.NET MVC Controller class anatomy" src="image/B21183_09_8.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.345.1">Figure 9.8 – Resource ASP.NET MVC Controller class anatomy</span></p>
<p><span class="koboSpan" id="kobo.346.1">In a traditional ASP.NET REST API solution, you have Controller classes embodying a specific route and methods that implement different operations at that route. </span><span class="koboSpan" id="kobo.346.2">The Controller class must be decorated with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">ApiController</span></strong><span class="koboSpan" id="kobo.348.1"> attribute that informs the ASP.NET runtime that this class should be used to process incoming web requests at the route specified in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">Route</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.350.1"> attribute.</span></span></p>
<p><span class="koboSpan" id="kobo.351.1">Each method is decorated with an attribute that denotes which HTTP verb the method should respond to. </span><span class="koboSpan" id="kobo.351.2">In the preceding example, we used </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">HttpGet</span></strong><span class="koboSpan" id="kobo.353.1">, but there are corresponding attributes for each supported HTTP verb. </span><span class="koboSpan" id="kobo.353.2">The method can take strongly typed parameters that can be part of the route, query string, or request body. </span><span class="koboSpan" id="kobo.353.3">The method returns an </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">IActionResult</span></strong><span class="koboSpan" id="kobo.355.1"> by default, which allows us to return different data structures depending on the outcome of </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">the request.</span></span></p>
<p><span class="koboSpan" id="kobo.357.1">To implement a REST API using Lambda Functions, we need to implement a class using the SDK Lambda function. </span><span class="koboSpan" id="kobo.357.2">This requires us to slightly adjust how we implement both our class and our method. </span><span class="koboSpan" id="kobo.357.3">We will employ different class and method attributes to achieve a similar outcome: defining an endpoint that responds to web requests at a </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">specific route.</span></span></p>
<p><span class="koboSpan" id="kobo.359.1">The</span><a id="_idIndexMarker747"/><span class="koboSpan" id="kobo.360.1"> Lambda Function class is not decorated with any attributes. </span><span class="koboSpan" id="kobo.360.2">A method should take in a request object and an </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">ILambdaContext</span></strong><span class="koboSpan" id="kobo.362.1"> object. </span><span class="koboSpan" id="kobo.362.2">This method should also return a corresponding response object. </span><span class="koboSpan" id="kobo.362.3">Depending on the type of event you are designing your Lambda Function to respond to, you will need to use different classes for the request and response objects. </span><span class="koboSpan" id="kobo.362.4">AWS has published some libraries to encapsulate common structures of these various types to make them easier </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">to build:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer112">
<span class="koboSpan" id="kobo.364.1"><img alt="Figure 9.9 – Resource AWS Lambda Function class anatomy" src="image/B21183_09_9.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.365.1">Figure 9.9 – Resource AWS Lambda Function class anatomy</span></p>
<p><span class="koboSpan" id="kobo.366.1">In this book, we are using the Application Load Balancer; therefore, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">Amazon.Lambda.ApplicationLoadBalancerEvents</span></strong><span class="koboSpan" id="kobo.368.1"> library to provide a standard implementation of our request and response objects. </span><span class="koboSpan" id="kobo.368.2">As you can see, we are taking in an </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">ApplicationLoadBalancerRequest</span></strong><span class="koboSpan" id="kobo.370.1"> and returning </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">an </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">ApplicationLoadBalancerResponse</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.374.1">If we want to implement a more complex Lambda Function that supports different functionalities or operations, we can implement our routing logic around the </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">ApplicationLoadBalancerRequest</span></strong><span class="koboSpan" id="kobo.376.1"> object’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">Path</span></strong><span class="koboSpan" id="kobo.378.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">HttpMethod</span></strong><span class="koboSpan" id="kobo.380.1"> properties. </span><span class="koboSpan" id="kobo.380.2">These correspond to the ASP.NET framework’s route and HTTP verb attributes that decorate each controller class and </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">its methods.</span></span></p>
<p><span class="koboSpan" id="kobo.382.1">As we </span><a id="_idIndexMarker748"/><span class="koboSpan" id="kobo.383.1">can see, the cloud architecture radically simplifies. </span><span class="koboSpan" id="kobo.383.2">However, one trade-off is that our backend code needs to be adapted to the AWS Lambda framework. </span><span class="koboSpan" id="kobo.383.3">This will require development and testing efforts to transform our code base into this new hosting model. </span><span class="koboSpan" id="kobo.383.4">This starkly contrasts with what we explored in previous chapters, where we hosted on VMs or containerized and hosted on a Kubernetes cluster. </span><span class="koboSpan" id="kobo.383.5">While conforming to the AWS Lambda application model does take work, its benefits are twofold. </span><span class="koboSpan" id="kobo.383.6">First, it allows us to take advantage of a close-to-zero sunk cost. </span><span class="koboSpan" id="kobo.383.7">Second, it allows us to fully abstract the underlying infrastructure from us and let the AWS platform take care of scalability and high availability. </span><span class="koboSpan" id="kobo.383.8">This allows us to focus more on the functionality of our solutions than on the plumbing required to keep the </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">lights on.</span></span></p>
<p><span class="koboSpan" id="kobo.385.1">Now that we have implemented Terraform to provision our solution and made changes to our application code to conform it to the AWS Lambda framework, in the next section, we’ll dive into YAML and Bash. </span><span class="koboSpan" id="kobo.385.2">We will also implement GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">Actions workflows.</span></span></p>
<h1 id="_idParaDest-188"><a id="_idTextAnchor467"/><span class="koboSpan" id="kobo.387.1">Automating the deployment</span></h1>
<p><span class="koboSpan" id="kobo.388.1">As discussed</span><a id="_idIndexMarker749"/><span class="koboSpan" id="kobo.389.1"> in the previous section, serverless offerings such as AWS Lambda and S3 abstract the operating system configuration away. </span><span class="koboSpan" id="kobo.389.2">Therefore, when we deploy, we simply need an application package that is compatible with </span><a id="_idIndexMarker750"/><span class="koboSpan" id="kobo.390.1">the target platform. </span><span class="koboSpan" id="kobo.390.2">In this section, we’ll create an automation pipeline using GitHub Actions to provision our application to its new serverless home </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">in AWS.</span></span></p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor468"/><span class="koboSpan" id="kobo.392.1">Terraform</span></h2>
<p><span class="koboSpan" id="kobo.393.1">The first </span><a id="_idIndexMarker751"/><span class="koboSpan" id="kobo.394.1">thing that we need to do is to provision our environment to AWS. </span><span class="koboSpan" id="kobo.394.2">This is going to be extremely similar to the way we did this in the previous chapters. </span><span class="koboSpan" id="kobo.394.3">In </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.395.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.396.1">, we needed to ensure that our VM images were built and available before we executed Terraform because the Terraform code base referenced the VM images when it provisioned the VMs. </span><span class="koboSpan" id="kobo.396.2">With our VM architecture, application deployment happens before Terraform provisions </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">the environment:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer113">
<span class="koboSpan" id="kobo.398.1"><img alt="Figure 9.10 – Packer-produced VM images are a prerequisite for Terraform" src="image/B21183_09_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.399.1">Figure 9.10 – Packer-produced VM images are a prerequisite for Terraform</span></p>
<p><span class="koboSpan" id="kobo.400.1">In </span><a href="B21183_08.xhtml#_idTextAnchor402"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.401.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.402.1">, we provisioned</span><a id="_idIndexMarker752"/><span class="koboSpan" id="kobo.403.1"> our Kubernetes cluster using AWS EKS without such a prerequisite. </span><span class="koboSpan" id="kobo.403.2">In fact, the application deployment occurred after the Kubernetes cluster was online. </span><span class="koboSpan" id="kobo.403.3">This means that with container-based architecture, application deployment happens after Terraform provisions </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">the environment:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer114">
<span class="koboSpan" id="kobo.405.1"><img alt="Figure 9.11 – Docker-produced container images are provisioned to Kubernetes after Terraform executes" src="image/B21183_09_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.406.1">Figure 9.11 – Docker-produced container images are provisioned to Kubernetes after Terraform executes</span></p>
<p><span class="koboSpan" id="kobo.407.1">When using AWS’s serverless offerings, the deployment process mirrors what we saw when deploying our application as containers to Kubernetes. </span><span class="koboSpan" id="kobo.407.2">Just like with this approach, we need to build a deployment artifact for AWS’s serverless offerings. </span><span class="koboSpan" id="kobo.407.3">For the frontend, that</span><a id="_idIndexMarker753"/><span class="koboSpan" id="kobo.408.1"> means simply generating the static web content. </span><span class="koboSpan" id="kobo.408.2">For the backend, that means generating a Lambda Functions ZIP archive. </span><span class="koboSpan" id="kobo.408.3">These artifacts share a similar purpose to the Docker images in that they are a target service-compatible way of packaging our application </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">for deployment:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer115">
<span class="koboSpan" id="kobo.410.1"><img alt="Figure 9.12 – The .NET CLI produces deployment artifacts that are provisioned to AWS after Terraform executes" src="image/B21183_09_12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.411.1">Figure 9.12 – The .NET CLI produces deployment artifacts that are provisioned to AWS after Terraform executes</span></p>
<p><span class="koboSpan" id="kobo.412.1">As you can see, the </span><a id="_idIndexMarker754"/><span class="koboSpan" id="kobo.413.1">serverless deployment looks very similar to the approach used with the container-based architecture. </span><span class="koboSpan" id="kobo.413.2">That’s because AWS is fulfilling the role that Kubernetes played when using a serverless approach. </span><span class="koboSpan" id="kobo.413.3">AWS just has custom tools to facilitate the deploym</span><a id="_idTextAnchor469"/><span class="koboSpan" id="kobo.414.1">ent of </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">the application.</span></span></p>
<h2 id="_idParaDest-190"><a id="_idTextAnchor470"/><span class="koboSpan" id="kobo.416.1">Deployment</span></h2>
<p><span class="koboSpan" id="kobo.417.1">Now that Terraform </span><a id="_idIndexMarker755"/><span class="koboSpan" id="kobo.418.1">has provisioned the AWS infrastructure that we need for our serverless solution, we need to take the final step of deploying both the deployment artifacts to the appropriate locations </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">in AWS.</span></span></p>
<p><span class="koboSpan" id="kobo.420.1">We will use .NET and AWS custom tools to produce and deploy the artifacts to these </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">target locations.</span></span></p>
<h3><span class="koboSpan" id="kobo.422.1">Frontend</span></h3>
<p><span class="koboSpan" id="kobo.423.1">As we saw in </span><a id="_idIndexMarker756"/><span class="koboSpan" id="kobo.424.1">other chapters, our .NET application code needs to follow a continuous integration process, whereby the code is built and tested using automated unit testing and other built-in quality controls. </span><span class="koboSpan" id="kobo.424.2">Nothing changes there except that we need to add some special handling to the deployment artifact that these processes produce in order to make sure it is available to our GitHub Action’s job that deploys the workload to the </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">appropriate location.</span></span></p>
<p><span class="koboSpan" id="kobo.426.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">dotnet publish</span></strong><span class="koboSpan" id="kobo.428.1"> command outputs the deployment artifact of the .NET application code. </span><span class="koboSpan" id="kobo.428.2">This </span><a id="_idIndexMarker757"/><span class="koboSpan" id="kobo.429.1">output for the ASP.NET Blazor web application is a folder container: a collection of loose files with HTML, JavaScript, and CSS in it. </span><span class="koboSpan" id="kobo.429.2">In order to pass all of these files efficiently from one GitHub Actions job to another, we need to zip them up into a </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">single file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.431.1">
    - name: Generate the Deployment Package
      run: |
        zip -r ../deployment.zip ./
      working-directory: ${{ env.DOTNET_WORKING_DIRECTORY }}/publish</span></pre> <p><span class="koboSpan" id="kobo.432.1">Now that the static web content has been zipped into a ZIP archive, we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">upload-artifact</span></strong><span class="koboSpan" id="kobo.434.1"> GitHub action to save this file to GitHub Actions. </span><span class="koboSpan" id="kobo.434.2">This will make the file available for future jobs that are executed within </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">the pipeline:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.436.1">
    - name: Upload Deployment Package
      uses: actions/upload-artifact@v2
      with:
        name: dotnet-deployment
        path: ${{ env.DOTNET_WORKING_DIRECTORY }}/deployment.zip</span></pre> <p><span class="koboSpan" id="kobo.437.1">Future jobs can simply download the artifact using a corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">download-artifact</span></strong><span class="koboSpan" id="kobo.439.1"> GitHub action and the same name that was used to </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">upload it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.441.1">
    - uses: actions/download-artifact@v3
      with:
        name: dotnet-deployment</span></pre> <p><span class="koboSpan" id="kobo.442.1">Since the ASP.NET Blazor web application will be hosted as static web content on our AWS S3 bucket, we need to ensure that we unzip it before uploading the contents. </span><span class="koboSpan" id="kobo.442.2">If we were to upload</span><a id="_idIndexMarker758"/><span class="koboSpan" id="kobo.443.1"> the ZIP archive to S3, the web application wouldn’t work correctly because all the web content would be trapped inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">archive file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.445.1">
    - name: Unzip Deployment Package
      run: |
        mkdir -p ${{ env.DOTNET_WORKING_DIRECTORY }}/upload-staging
        unzip ./deployment.zip -d ${{ env.DOTNET_WORKING_DIRECTORY }}/upload-staging</span></pre> <p><span class="koboSpan" id="kobo.446.1">Now that the static web content has been unzipped to the staging directory, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">aws s3 sync</span></strong><span class="koboSpan" id="kobo.448.1"> command to deploy all of the files in the folder to the </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">S3 bucket:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.450.1">
      - id: deploy
        name: Upload to S3 Bucket
        env:
          AWS_ACCESS_KEY_ID: ${{ vars.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ vars.BACKEND_REGION }}
        working-directory: ${{ env.DOTNET_WORKING_DIRECTORY }}/upload-staging
        run: |
          aws s3 sync . </span><span class="koboSpan" id="kobo.450.2">s3://${{ needs.terraform.outputs.frontend_bucket_name }}</span></pre> <h3><span class="koboSpan" id="kobo.451.1">Backend</span></h3>
<p><span class="koboSpan" id="kobo.452.1">To </span><a id="_idIndexMarker759"/><span class="koboSpan" id="kobo.453.1">deploy the Lambda Function, the exact same process is followed to pass the artifact from the GitHub Actions job that builds the deployment artifact to the job that actually </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">deploys it.</span></span></p>
<p><span class="koboSpan" id="kobo.455.1">The only difference is that we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">aws lambda update-function-code</span></strong><span class="koboSpan" id="kobo.457.1"> command to provision a ZIP archive to the </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">Lambda Function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.459.1">
      - name: Deploy
        env:
          AWS_ACCESS_KEY_ID: ${{ vars.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ vars.BACKEND_REGION }}
          FUNCTION_NAME: ${{needs.terraform.outputs.lambda_function_name}}
        run: |
          aws lambda update-function-code --function-name $FUNCTION_NAME --zip-file fileb://deployment.zip</span></pre> <p><span class="koboSpan" id="kobo.460.1">Unlike </span><a id="_idIndexMarker760"/><span class="koboSpan" id="kobo.461.1">how we provisioned the frontend, we don’t need to unzip the deployment package for the Lambda Function. </span><span class="koboSpan" id="kobo.461.2">AWS Lambda expects our application code to be bundled into a </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">ZIP archive.</span></span></p>
<p><span class="koboSpan" id="kobo.463.1">That’s it! </span><span class="koboSpan" id="kobo.463.2">Now our application has been fully de</span><a id="_idTextAnchor471"/><span class="koboSpan" id="kobo.464.1">ployed to AWS S3 </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">and Lambda!</span></span></p>
<h1 id="_idParaDest-191"><a id="_idTextAnchor472"/><span class="koboSpan" id="kobo.466.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.467.1">In this chapter, we embarked on an ambitious journey, transitioning from a .NET solution that was previously architected on VMs and Kubernetes using Amazon EKS to a fully serverless architecture utilizing AWS Lambda Functions. </span><span class="koboSpan" id="kobo.467.2">This transformative step involved converting our traditional .NET REST API into a suite of Lambda Functions and hosting the frontend as a static website on Amazon S3, marking a significant evolution in our cloud-native development journey for our fictional company’s autonomous vehicle fleet </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">operations platform.</span></span></p>
<p><span class="koboSpan" id="kobo.469.1">As we conclude this chapter, we have built three distinct solutions on AWS, spanning VMs, Kubernetes, and now serverless architectures. </span><span class="koboSpan" id="kobo.469.2">We’ve also demonstrated our ability to navigate and leverage AWS’s diverse capabilities to meet our </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">evolving needs.</span></span></p>
<p><span class="koboSpan" id="kobo.471.1">Looking ahead, we are poised to embark on a new chapter of our cloud journey with Microsoft Azure. </span><span class="koboSpan" id="kobo.471.2">Under the guidance of our elusive and visionary CEO, Keyser Söze, who has now forged a partnership with Microsoft, we stand at the threshold of exploring similar architectures in the Azure ecosystem. </span><span class="koboSpan" id="kobo.471.3">With our sights now set on Azure, I invite you to continue our journey as we enter this alternate universe, ready to tackle new challenges and uncover new possibilities on a completely different </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">cloud platform.</span></span></p>
</div>


<div class="Content" id="_idContainer117">
<h1 id="_idParaDest-192" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor473"/><span class="koboSpan" id="kobo.1.1">Part 4: Building Solutions on Azure</span></h1>
<p><span class="koboSpan" id="kobo.2.1">Armed with the conceptual knowledge of Terraform and architectural concepts that transcend the implementation details of the major public cloud platforms, we’ll explore building solutions on Microsoft Azure with three cloud computing paradigms: virtual machines, containers with Kubernetes, and serverless with </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">Azure Functions.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B21183_10.xhtml#_idTextAnchor474"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 10</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Getting Started on Azure – Building Solutions with Azure Virtual Machines</span></em></li>
<li><a href="B21183_11.xhtml#_idTextAnchor509"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 11</span></em></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Containerize on Azure – Building Solutions with Azure Kubernetes Service</span></em></li>
<li><a href="B21183_12.xhtml#_idTextAnchor543"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 12</span></em></a><span class="koboSpan" id="kobo.13.1">, </span><em class="italic"><span class="koboSpan" id="kobo.14.1">Go Serverless on Azure – Building Solutions with Azure Functions</span></em></li>
</ul>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer118">
</div>
</div>
</body></html>