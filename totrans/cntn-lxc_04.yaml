- en: Chapter 4. LXC Code Integration with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will introduce you to the Python bindings provided by both the
    LXC and libvirt APIs. We'll explore which container functionalities are possible
    and which are not, using the upstream `lxc-dev` and `python-libvirt` packages
    on Ubuntu and the `lxc-devel` and `libvirt-python` packages on CentOS.
  prefs: []
  type: TYPE_NORMAL
- en: To gain the most out of this chapter, some knowledge of Python is required.
    If you are a developer, this chapter is probably the most important one for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics in this order:'
  prefs: []
  type: TYPE_NORMAL
- en: Building and managing containers using the `lxc` Python bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and orchestrating containers using the libvirt Python bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using LXC as a backend for development and testing with Vagrant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a simple frontend RESTful API to LXC, using the Bottle micro framework
    and the `lxc` libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LXC Python bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LXC comes with stable C API and Python bindings for both Python 2.x and 3.x
    versions. Let's explore some of the functionalities that are available to us using
    Python 2.7.6, by writing a code that will cover most of the features provided
    by the userspace tools we saw in earlier chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the LXC Python bindings and preparing the development environment
    on Ubuntu and CentOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start by installing all the necessary packages that will allow us to write
    a functioning Python code. This includes the LXC API libraries and a Python development
    environment with `ipython` and `virtualenv`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prepare an Ubuntu host, run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding commands will ensure we are running the latest Ubuntu packages,
    along with tools such as `pip`, to install and manage Python packages, and the
    `ipython` tool for interactive programming in Python. On CentOS, install the following
    packages to provide the same functionality:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, let''s create a Linux bridge for the containers to connect to
    later on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For the examples in this chapter, we are going to use a separate Python virtual
    environment to keep the dependency requirements for our project separate. We can
    do this by utilizing the `virtualenv` package.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s install it first with `pip`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s create a working directory for our project and activate the virtual
    environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the virtual environment activated, let''s install the Python LXC API bindings
    package and list what is present in our development environment using `pip`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this, we have all the required packages, libraries, and tools for creating
    and using LXC containers with Python. Let's have some fun writing Python code!
  prefs: []
  type: TYPE_NORMAL
- en: Building our first container with Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start the `ipython` tool and import the LXC library we installed earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to create the `container` object using the `Container` class
    and by specifying a name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a `container` object, we can use the `create` method to build
    our first container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `container.create()` method definition along with the explanation for each
    parameter is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Definition**: `container.create(self, template=None, flags=0, args=())`,
    creates a new `rootfs` for the container. The Following is a description of the
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`template`: This parameter must be a valid template name in order to be passed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flags`: This is optional. It is an integer representing the optional create
    flags to be passed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`args`: This is optional. It is a tuple of arguments to pass to the template.
    It can also be provided as a dictionary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creating an Ubuntu container is as easy as running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: An output of `True` indicates that the operation was successful in defining
    the container.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering container information with Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we've built our first LXC container, let's examine a few of its properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s check the container''s name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Also check its state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s list all containers currently present on the host OS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `containers()` method returns a tuple containing the container
    names. In this case, just the single container we've just built.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, when we build LXC containers with the userspace tools such as `lxc-create`,
    the root filesystem and the configuration file are located in `/var/lib/lxc/containername/`.
    Let''s see where the root filesystem for the container we built is, by calling
    the `get_config_path()` and `get_config_item()` methods on the `container` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: From the output of the `get_config_path()` method, we can observe that the default
    LXC config location is the same as the one if the `lxc-create` command was used
    to build the container.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code example, we also passed the `lxc.rootfs` configuration
    option to the `get_config_item()` method to obtain the root filesystem location,
    which is also in line with the default, if using the command line tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can pass various configuration parameters to the `get_config_item()` method
    to obtain the container''s current settings. Let''s query for the `memory.limit_in_bytes`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To list all available methods and variables on the `container` object we created,
    in `ipython`, type `container` and press the ***Tab*** key once. To get more information
    about a method, function, or variable, type its name followed by question mark,
    for example, `container.get_ips?`.
  prefs: []
  type: TYPE_NORMAL
- en: You can experiment further by opening the container's configuration file as
    shown from the preceding output and pass it as a parameter to the `get_config_item()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain the IP configuration of our container, we can call the `get_ips()`
    method with no arguments, as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Since the container is not running and no memory limits have been applied, the
    output is an empty string and an empty tuple, respectively. Working with a stopped
    container is not very interesting; let's explore what we can do in Python with
    a running container.
  prefs: []
  type: TYPE_NORMAL
- en: Starting containers, applying changes, and listing configuration options with
    Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s check if the container is running by printing the value of the running
    Boolean on the `container` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To start the container, we can use the `start()` method. The docstring for
    that method reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the container and return `True` on success. When set, `useinit` will
    make LXC use `lxc-init` to start the container. The container can be started in
    the foreground with `daemonize=False`. All `fds` may also be closed by passing
    `close_fds=True`. Looks easy enough. Let''s start our container by daemonizing
    it and not using the `lxc-init` manager, but the Python interpreter instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as earlier, an output of `True` indicates that the operation was executed
    successfully. Let''s use the `wait()` method to wait for the container to reach
    the `RUNNING` state, or to timeout in 5 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output indicates that the container is now running. Let''s double-check
    by printing the values of the running and state variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In a separate terminal, let''s use the LXC userspace tools to examine the container
    we built with the Python library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The output of the `lxc-ls` command confirms what the `container.state` variable
    returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s obtain the PID of the container in our Python shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The PID in this case is `4688`; we can confirm if it matches what''s currently
    running on the host system by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: No real surprises here. Notice how the main process that started the container's
    `init` system is `python` and not `lxc-init`, because that is what we passed as
    an argument to the `start()` method earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our container is running, we can get some more information from it.
    Let''s start by obtaining its IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The result is a tuple, containing the IP addresses of all interfaces for the
    container, in this case just one IP.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can programmatically attach to the container and run commands just like
    we saw in the [Chapter 3](ch03.html "Chapter 3. Command-Line Operations Using
    Native and Libvirt Tools"), *Command-line Operations Using Native and Libvirt
    Tools*, with the `lxc-attach` command, by invoking the `attach_wait()` method,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `attach_wait()` method takes a function as its argument, in the preceding
    example, the built-in `lxc.attach_run_command`, but it can be any other function
    in Python that you wrote. We also specified a list consisting of the command we
    want to execute and its arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also specify the namespace context the command should run in. For example,
    to list all files in the container''s mount namespace designated by the `CLONE_NEWNS`
    flag, we can pass the `namespaces` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run commands by specifying multiple `namespaces` flags. In the next
    example, we list all processes in the container by explicitly specifying the mount
    and process namespaces with the `CLONE_NEWNS` and `CLONE_NEWPID` flags, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `set_config_item()` and `get_config_item()` methods, we can apply
    configuration changes and query them on a running container. To demonstrate this,
    let''s specify a memory limit for the container and then obtain the newly set
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding changes will not persist when a container restarts; to make the
    changes permanent, we can write them in the configuration file using the `append_config_item()`
    and `save_config()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify this, the `lxc.cgroup.memory.limit_in_bytes` parameter was saved
    in the configuration file; let''s examine it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last line in the configuration file is the one we appended with the two
    Python calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the `set_config_item()` method, the Python bindings also provide
    the `set_cgroup_item()` and `get_cgroup_item()` methods for specifically manipulating
    the cgroup parameters. Let''s set and get the same `memory.limit_in_bytes` option
    using those two calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Changing container state with Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 3](ch03.html "Chapter 3. Command-Line Operations Using Native and
    Libvirt Tools"), *Command-Line Operations Using Native and Libvirt Tools*, we
    saw how to freeze and unfreeze LXC containers to preserve their state using the
    `lxc-freeze` and `lxc-unfreeze` commands. We can do the same with the `freeze()`
    and `unfreeze()` methods. To freeze the container, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the status as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can examine the cgroup file as well, to confirm the change took place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To unfreeze the container and check the new state, call the `unfreeze()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Stopping containers with Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Python bindings provide a convenient way of stopping containers with the
    `stop()` method. Let''s stop our container and check its state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, list all the containers on the host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Cloning containers with Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the container in a `STOPPED` state, let''s run the `clone()` method and
    create a copy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing the available containers with the `list_containers()` method on the
    `lxc` object, we get a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To confirm on the host OS, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'To find where the root filesystem for the cloned container is, we can call
    the `get_config_item()` method on the new `container` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Two directories now exist in the default container path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s start the cloned container and ensure it''s running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Destroying containers with Python and cleaning up the virtual environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can remove or destroy containers in Python, just like with the command
    line tools, we need to stop them first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoke the `destroy()` method on the `container` object to delete the root
    filesystem and free all resources used by it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'List the containers through the `list_containers()` method to now return an
    empty tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, let''s deactivate the Python virtual environment we created earlier
    – note that the files will still be present on the disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Libvirt Python bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. Command-Line Operations Using Native and
    Libvirt Tools"), *Command-Line Operations Using Native and Libvirt Tools*, we
    explored an alternative way of working with LXC through the use of the libvirt
    userspace tools. Libvirt provides Python bindings that we can use to write applications,
    with the main benefit of uniformity with other virtualization technologies. It's
    quite convenient to write Python applications for KVM, XEN, and LXC using just
    one common library.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to explore some of the Python methods provided
    by the libvirt library to create and control LXC containers.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the libvirt Python development packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start by installing the required packages and starting the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Ubuntu, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'On CentOS, the library and the service are named differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Since libvirt does not provide templates to work with, we need to create our
    own root filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Activate the Python virtual environment and start the interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Building LXC containers with libvirt Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s time to import the library and call the `open()` method to create a connection
    to the LXC driver. The argument that we pass to the `open()` method should look
    familiar – we used it in [Chapter 3](ch03.html "Chapter 3. Command-Line Operations
    Using Native and Libvirt Tools"), *Command-Line Operations Using Native and Libvirt
    Tools*, when exporting the `LIBVIRT_DEFAULT_URI` environment variable, telling
    libvirt that LXC is going to be the default virtualization driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'After specifying the default virtualization driver and URI, we can use the
    next two methods to return the name and path of the driver we set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To get a list of the available methods and variables on the `lxc_conn` object
    we created earlier, type `lxc_conn`. and press the ***Tab*** key. To get more
    information about a method, function, or variable, type its name followed by a
    question mark, for example, `lxc_conn.getURI?`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `getInfo()` method to extract hardware information about the
    host node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is a list with the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Member** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `list[0]` | String indicating the CPU model |'
  prefs: []
  type: TYPE_TB
- en: '| `list[1]` | Memory size in megabytes |'
  prefs: []
  type: TYPE_TB
- en: '| `list[2]` | The number of active CPUs |'
  prefs: []
  type: TYPE_TB
- en: '| `list[3]` | Expected CPU frequency in MHz |'
  prefs: []
  type: TYPE_TB
- en: '| `list[4]` | The number of NUMA nodes, `1` for uniform memory access |'
  prefs: []
  type: TYPE_TB
- en: '| `list[5]` | Number of CPU sockets per node |'
  prefs: []
  type: TYPE_TB
- en: '| `list[6]` | Number of cores per socket |'
  prefs: []
  type: TYPE_TB
- en: '| `list[7]` | Number of threads per core |'
  prefs: []
  type: TYPE_TB
- en: 'To build a container, we need to define it first in a XML file. Let''s use
    the following example and assign it to the `domain_xml` string variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding XML configuration assigned to a variable, we can use the
    `defineXML()` method to define the container. This method takes the XML definition
    as an argument and defines the container, but does not start it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s verify the container was successfully defined on the host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `listDefinedDomains()` method to list all the defined but not
    the running domains, which returns a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Starting containers and running basic operations with libvirt Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start the previously defined container, we need to call the `create()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify the container is running on the host, after calling the `create()`
    method, we''ll execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'There are quite a few methods for obtaining information about the container.
    We can fetch the XML definition by calling the `XMLDesc()` method on the `container`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s verify that the container is running by calling the `isAlive()` function
    that returns a Boolean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We can obtain the container ID that should match the ID we received back by
    running the preceding `virsh` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: No surprise here, the ID is the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next code snippet iterates over a list of defined containers and returns
    a list of domain objects from which we print their name, by calling the `listAllDomains()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The API provides two methods to lookup a container, by name and by ID, and
    assigns it to an object variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This is useful when we want to work with containers that already exist. The
    `container` object can now be used as usual, by calling its methods.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting container information with libvirt Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s collect information about the memory of the container. The `maxMemory()`
    method returns the maximum memory configured on the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Collecting memory statistics is done with the `memoryStats()` method, which
    returns a dictionary object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'When we defined our container earlier in the XML file, we specified the OS
    type of the domain to be `exe`, meaning the container will execute the specified
    binary. To obtain that on a running container, call the `OSType()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to get more information on the container, we can call the `info()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is a list with the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Member** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `list[0]` | String indicating the state of the container |'
  prefs: []
  type: TYPE_TB
- en: '| `list[1]` | Max container memory |'
  prefs: []
  type: TYPE_TB
- en: '| `list[2]` | Current memory utilization |'
  prefs: []
  type: TYPE_TB
- en: '| `list[3]` | Number of CPUs |'
  prefs: []
  type: TYPE_TB
- en: '| `list[4]` | CPU time |'
  prefs: []
  type: TYPE_TB
- en: With the container running, let's look at how we can stop it and clean up the
    environment next.
  prefs: []
  type: TYPE_NORMAL
- en: Stopping and deleting LXC containers with libvirt Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can destroy the container, let's verify its state and name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'To stop it, call the `destroy()` method on the `container` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s verify the container is not running on the host before we can delete
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'To delete the container, we invoke the `undefine()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's important to note that not all methods, functions, and variables are available
    to the libvirt LXC driver, even though they can be listed in the ipython interpreter
    after importing the libvirt library. This is due to the libvirt support for multiple
    hypervisors such as KVM and XEN. Keep this in mind when exploring the rest of
    the API calls.
  prefs: []
  type: TYPE_NORMAL
- en: Vagrant and LXC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vagrant is a great open source project that provides a way for building isolated
    development environments, utilizing various virtualization technologies such as
    KVM and LXC, through the use of plugins.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to briefly touch on how to set up a Vagrant development
    environment using LXC for isolation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by downloading and installing Vagrant on Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Installing the package is trivial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'On CentOS, the steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command for downloading and installing Vagrant:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a new bridge if it does not already exist, for LXC to attach to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It''s time to install the LXC plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If all went well, list the installed Vagrant plugins:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the LXC plugin installed, create a new project directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, initialize a new Vagrant environment by specifying the type of box, or
    virtual machine image we are going to use. In the following example, we are going
    to use the Ubuntu Precise LXC image from the `fgremh` repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As the output indicates, a new `Vagrantfile` was created in the project directory:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For a list of Vagrant boxes you can visit: [https://atlas.hashicorp.com/boxes/search](https://atlas.hashicorp.com/boxes/search).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s take a look at `Vagrantfile`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The configuration is very minimal, specifying the image that the Vagrant machine
    will use. Let''s start the container, by explicitly specifying the provider:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To verify that we have a running LXC container, execute the following on the
    command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s check the status of the Vagrant machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To connect to the LXC container, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Configuring Vagrant LXC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Vagrantfile` is very well documented, but here''s a brief example on how
    to customize the Vagrant machine by specifying the amount of memory available
    to the LXC container:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Stop the running Vagrant machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit `Vagrantfile` and set the `cgroup.memory.limit_in_bytes` cgroup limit.
    The new config should looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file and start back the Vagrant machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify that the cgroup limit was applied:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let''s clean up by deleting all remnants of the Vagrant machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Putting it all together – building a simple RESTful API to LXC with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all the knowledge we have in hand by experimenting with the LXC bindings
    for Python earlier, we can write a simple RESTful API that will build, manage,
    and destroy LXC containers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To keep the code as simple as possible, we are going to skip all error and exception
    handling and any input validation from the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the simplest Python web frameworks for building APIs is Bottle. Let''s
    install it first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure you have both the `bottle` and `lxc-python2` libraries installed
    before continuing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s open the new `lxc_api.py` file and write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The `run` class provides the `run()` call, which starts a built-in server. In
    our example, the server will be listening on localhost, port `8080`. The `get()`
    decorator links the code from the function below it to an URL path. In the preceding
    code, the `/list` path is bound to the `list()` function. Of course, you are already
    familiar with the `list_containers()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this simple API frontend, save the file and execute the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you get the `socket.error: [Errno 98] Address already in use` error, there''s
    another process that is bound to port `8080`. To fix this, simply change the port
    your Python application is listening on in the `run()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a separate terminal window, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: It's just that simple; we created an API call to list LXC containers!
  prefs: []
  type: TYPE_NORMAL
- en: API calls to build and configure LXC containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s expand the functionality a bit by adding the ability to build containers.
    Edit the file and add the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: We are going to use the `@post` decorator in this case and the provided `headers.get()`
    method from the `request` class to get the custom headers that will contain the
    container and template names.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a complete API reference of the Bottle framework refer to [http://bottlepy.org/docs/dev/api.html](http://bottlepy.org/docs/dev/api.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the updated file and restart the program. Let''s test the new call in
    the second terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'We used the `--header` flags to pass the container and template names with
    `curl` as headers, using the `POST` verb. If you check the terminal where the
    application is running you can see the logs of the container being built, along
    with the HTTP route and the error code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use the `/list` route we defined earlier to list all containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! We can now build and list containers. Let''s create a new route that
    will start LXC. Add the following function to the `lxc_api.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using the `POST` decorator again and a dynamic route. The dynamic route
    consists of a name, in our example called `<name>`, which will hold whatever string
    value we pass to the route with the `curl` command. The method that is bound to
    the `container_start(name)` route also accepts a variable with the same name.
    Save the changes, restart the application, and execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: We passed `api_container` in the URL, and the route we defined was able to match
    it and pass it as a variable to the `container_start` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our simple API does not yet provide a route to get the status of a container,
    so let''s ensure it''s really running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add a `state` call to our API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'This time we are using the `@get` decorator and calling the `state()` method
    on the `container` object. Let''s test the new route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a running container, let''s add the functionality to list
    its IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'There is nothing new to note here, so let''s see what we get back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'We saw how to freeze and unfreeze containers earlier in this chapter; let''s
    now add that functionality to our API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The `POST` verb makes more sense here, since we are making changes to the state
    of the container. Let''s freeze the container and check its state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s unfreeze it with the new API call we made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, as a conclusion, let''s write two new functions to stop and delete the
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: All the methods we've used so far, we've tested earlier in this chapter; feel
    free to refer back to their description as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up using the API calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s time to clean up, by calling the `stop` API route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'The console with the running application should show something similar to this
    after making all the preceding API calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s destroy the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: We can easily add all the LXC Python methods we experimented with earlier, by
    following the same pattern – just remember to catch all exceptions and validate
    the input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the entire program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bindings for Python provided by the LXC and libvirt APIs are a great way
    to programmatically create and manage LXC containers.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explored both sets of Python bindings, by writing simple
    code snippets that implement most of the functions provided by the userspace tools.
    In fact, the best way to learn about those APIs is to look at the source code
    of the command-line tools, although they are implemented in C.
  prefs: []
  type: TYPE_NORMAL
- en: We had a brief introduction in how to provision LXC with Vagrant for testing
    your code in isolation. We ended the chapter with a working implementation of
    a simple RESTful API that uses some of the methods we explored earlier to provision,
    manage, and destroy LXC. In [Chapter 5](ch05.html "Chapter 5. Networking in LXC
    with the Linux Bridge and Open vSwitch"), *Networking in LXC with the Linux Bridge
    and Open vSwitch*, we'll explore the networking aspects of LXC, using the Linux
    bridge, Open vSwitch in NAT, and direct routing modes, and look into examples
    of how to interconnect containers and the host OS.
  prefs: []
  type: TYPE_NORMAL
