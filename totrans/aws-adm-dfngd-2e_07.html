<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Transforming Application Development Using the AWS Code Suite</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we explored a few interesting and really useful enhancements made to the AWS <strong>Identity and Access Management Service</strong> (<strong>IAM</strong>) along with a quick deep dive into AWS Organizations as well.</p>
<p>In this chapter, we will be learning and exploring three extremely useful and powerful services provided by AWS that are specially catered toward enhancing a developer's experience with continuous code deployments: AWS CodeCommit, AWS CodeDeploy, and AWS CodePipeline!</p>
<p>Keeping this in mind, let's have a quick look at the various topics that we will be covering in this chapter:</p>
<ul>
<li>Introducing AWS CodeCommit, AWS CodeDeploy, and AWS CodePipeline along with each service's concepts and internal workings</li>
<li>Creating your first CodeCommit repository and uploading an application to it</li>
<li>Running basic Git commands against your new code repository</li>
<li>Configuring the CodeDeploy agent on an EC2 instance</li>
<li>Leveraging the AppSpec file for configuring application life cycle deployment</li>
<li>Creating your own continuous delivery system using CodePipeline</li>
</ul>
<p>So without any further ado, let's get started right away!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding the AWS Code Suite</h1>
                </header>
            
            <article>
                
<p>Besides providing a plethora of infrastructure-related services, AWS also provides a few services that are designed to help developers quickly design, develop, build, and deploy their applications on the AWS cloud platform. In this section, we will have a quick look at these services and how you can leverage them together to build your very own continuous integration and delivery pipelines:</p>
<ul>
<li><strong>AWS CodeCommit</strong>: An important starting point for any CI/ CD pipeline is a simple yet functional source control repository. Traditionally, this would be set up on one or more physical servers in the form a Git or SVN repository that developers would use to push their code and updates to; however, maintaining such code repositories and scaling them was always going to be a challenge. That's where AWS CodeCommit comes into play! AWS CodeCommit is a managed source control service that enables developers to securely store their code on the AWS cloud. It offers many of the features that you would require and use while working with different source control repositories, such as branching, commits, rollbacks, and much more.</li>
<li><strong>AWS CodeBuild</strong>: AWS CodeBuild is a code build service that developers can leverage to automate their source code compilations, tests, executions, and code packaging for deployments. Similar to its other counterpart services in the Code Suite, CodeBuild too is managed completely by AWS, thus eliminating any unnecessary administrative overheads, such as patching or scaling the code build software. CodeBuild is highly extensible and it also easily integrates with your existing CI/CD workflows as well.</li>
<li><strong>AWS CodeDeploy</strong>: With your application code stored securely and compiled, the final step requires the code to be deployed across your fleet of EC2 instances. This can be easily achieved with the help of our next Code Suite service, called AWS CodeDeploy. Using CodeDeploy, a developer can automate code deployments to any environment that runs off of either EC2 instances as well as servers that are running in an on-premise datacenter. CodeDeploy essentially eliminates deployment complexities by allowing you to automate the delivery of your code across thousands of instances without having to undergo any major downtimes.</li>
<li><strong>AWS CodePipeline</strong>: AWS CodePipeline is a full fledge CI/CD service provided by AWS that developers can leverage to build end-to-end CI/CD pipelines either by using the AWS Code Suite of services or even with other popular third-party tools, such as GitHub, Jenkins, and so on. Using CodePipeline, you can also create and define custom software release models using which your application gets updated with the latest set of updates, tested, and packaged as well for the next iterative set of deployments.</li>
</ul>
<p>Here is a brief representation of how these services map together collaboratively to create a comprehensive CI/CD pipeline:</p>
<div class="CDPAlignCenter CDPAlign"><img height="474" width="1352" src="Images/6e3d7b23-e812-4d55-ba50-ad84c36c0288.png"/></div>
<p>For the purpose of this chapter, however, we will be working with only three AWS Code Suite services, namely AWS <strong>CodeCommit</strong>, AWS <strong>CodeDeploy</strong>, and AWS <strong>CodePipeline</strong>. The chapter will showcase how these three services can be leveraged together to build your very own CI/CD pipelines for our sample WordPress application. Here is a high-level depiction of our overall use case:</p>
<div class="CDPAlignCenter CDPAlign"><img height="649" width="1062" src="Images/ea5db7c2-66dd-46e7-b588-94de46987c18.png"/></div>
<p>With the basic understanding of the Code Suite services out of the way, let's learn a bit more about AWS CodeCommit and how you can leverage it as your very own source code repository!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting Started with AWS CodeCommit</h1>
                </header>
            
            <article>
                
<p>As discussed earlier, AWS CodeCommit is a secure and highly scalable source control service which allows you to create multiple private Git repositories without having to bother about any of the underlying management overheads. You can use it to store anything, from code, to application binaries, to even code packages, all using the standard Git-like functionality. This makes CodeCommit extremely easy to work with even if you have not used it before. Here is the gist of some of the most commonly used Git commands and how you can leverage them with CodeCommit:</p>
<ul>
<li><span><kbd>git clone</kbd>: Used to clone and connect the AWS CodeCommit repository over to your local development server.</span></li>
<li><kbd>git add</kbd>: <span>Once the repository is cloned locally, you can use it to add, edit, or delete files as you see fit. Once done, use the <kbd>git add</kbd> command to stage the modifications in your local Git repository.</span></li>
<li><kbd>git commit</kbd><span>: Used to commit the modifications made to the files to the local Git repository.</span></li>
<li><kbd>git push</kbd><span>: Used to push the committed files and changes over to the AWS CodeCommit repository.</span></li>
<li><kbd>git <span>pull</span></kbd><span>: Used to ensure that the files you are working on are synced and are of the latest version from the AWS CodeCommit repository.</span></li>
</ul>
<p>In this section, we will be looking at a few simple steps to enable you to create your very own source code repository using the AWS Management Console. However, before we move on to that, it is important to understand some of the different connections that you can use to connect to your CodeCommit repository. This can vary based on your development environments as well as security requirements:</p>
<ul>
<li><strong>Using the HTTPS connections</strong>: Configuring Git credentials using HTTPS connections is by far the simplest and most widely used method for connecting to your Git repository. With this set up, you simply generate a static username and password using AWS IAM. Once the credentials are created, you can then use them with Git and any third-party tool, such as an IDE, for authentication.</li>
<li><strong>Using the SSH connections</strong>: In this case, a user will be required to create public and private key files on your local development server that Git and AWS CodeCommit can use for SSH authentication. The public key generated in this process gets associated with your IAM user, whereas the private key remains on the local development server. The generation of the keys varies from operating system to operating system and can be a tedious process at times to manage.</li>
</ul>
<p>For this section, however, we will be leveraging the SSH connections method itself for connecting to our AWS CodeCommit repository:</p>
<ol>
<li>To get started, first log in to your AWS Management Console and filter the IAM service using the <span class="packt_screen">Filter</span> option provided. Alternatively, you can also select URL <a href="https://console.aws.amazon.com/iam/">https://console.aws.amazon.com/iam/</a> to view the IAM dashboard.</li>
<li>Here, we will start off by creating a dedicated user that will have full management rights to our CodeCommit repository. Select the <span class="packt_screen">Users</span> option from the IAM dashboard's navigation pane to bring up the list of currently created IAM users.</li>
<li>Next, select the <span class="packt_screen">Add user</span> option. This will bring up the <span class="packt_screen">Add user</span> page where you can provide a suitable <span class="packt_screen">User name</span> as well as opt for the user's <span class="packt_screen">Access type</span>. In this case, the CodeCommit user will only require <span class="packt_screen">Programmatic access</span>. Click <span class="packt_screen">Next</span> to proceed.</li>
<li>Moving on, in the <span class="packt_screen">Permissions</span> page, we are required to filter and attach the <kbd>AWSCodeCommitFullAccess</kbd> policy to our newly created user. To do so, select the <span class="packt_screen">Attach existing policies directly</span> option and select the <kbd>AWSCodeCommitFullAccess</kbd> policy, as shown in the following screenshot. Alternatively, you can also provide a customized access policy here based on your requirements:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="201" width="628" src="Images/7fe3b055-8f07-4ffc-9425-639d123653f6.png"/></div>
<ol start="5">
<li>Complete the user creation process by reviewing the changes and making a note of the user's new access and secret keys as well.</li>
</ol>
<p>At this point, with your CodeCommit IAM user created, we now move on to the next part of this section where we create and configure a set of public and private keys for the IAM user, using a simple Linux-based development server. Follow URL <a href="http://docs.aws.amazon.com/codecommit/latest/userguide/setting-up-ssh-windows.html">http://docs.aws.amazon.com/codecommit/latest/userguide/setting-up-ssh-windows.html</a> if you are using a Windows operating system as your development server:</p>
<ol>
<li>Log in to your development server and run the following command to generate the new set of keys:</li>
</ol>
<pre style="padding-left: 60px"><strong># ssh-keygen</strong> </pre>
<ol start="2">
<li>When prompted, save the keys in the following directory structure:</li>
</ol>
<pre style="padding-left: 60px">/home/&lt;USER_NAME&gt;/.ssh/&lt;KEY_NAME&gt; </pre>
<p>Make a note of the public and private keys' locations, as depicted in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/495a035a-aed2-4591-ad52-5155b48b7e98.png" width="1007" height="197"/></div>
<ol start="3">
<li>Next, display and copy the public key's contents, using the following command. Note the public key will be saved in the file with a <kbd>.pub</kbd> extension:</li>
</ol>
<pre style="padding-left: 60px"><strong># cat /home/&lt;USER_NAME&gt;/.ssh/&lt;KEY_NAME&gt;</strong> </pre>
<ol start="4">
<li>Log in to your IAM dashboard once again and select the newly created user from the <span class="packt_screen">Users</span> page. Select the user's <span class="packt_screen">Security Credentials</span> tab. Here, under the <span class="packt_screen">SSH keys for AWS CodeCommit</span> section, click on <span class="packt_screen">Upload SSH public key</span> to paste the entire copied text from the earlier step.</li>
</ol>
<ol start="5">
<li>Once completed, you should now see a unique key auto-generated under the <span class="packt_screen">SSH key ID</span> column, as shown in the following screenshot. Copy this SSH key ID as we will be requiring it in the next steps:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="166" width="699" src="Images/baf12b4f-1415-4f5b-ae4c-211bae5c221f.png"/></div>
<ol start="6">
<li>With the public key uploaded to IAM and the new SSH key ID generated, the final step is to create a simple <kbd>config</kbd> file in your local development server with the following contents pasted into it:</li>
</ol>
<pre style="padding-left: 60px"><strong># vi ~/.ssh/config<br/>##### SUBSTITUTE THE &lt;VALUES&gt; WITH YOUR ACTUAL ONES #####</strong><br/>    <strong>Host git-codecommit.*.amazonaws.com</strong>
    <strong>  User &lt;SSH_KEY_ID&gt;</strong>
    <strong>  IdentityFile ~/.ssh/&lt;PRIVATE_KEY_FILENAME&gt;</strong>
  </pre>
<ol start="7">
<li>Save the file once done. Remember to modify the permissions of your <kbd>config</kbd> file before moving on to the verification step:</li>
</ol>
<pre style="padding-left: 60px"><strong># chmod 600 config</strong></pre>
<ol start="8">
<li>To verify the connectivity, simply use the following command to SSH to the AWS CodeCommit endpoint. Since this will be a first connect, you will be prompted to verify the connection for authenticity. Type in <kbd>yes</kbd> when prompted:</li>
</ol>
<pre style="padding-left: 60px"><strong># ssh git-codecommit.us-east-1.amazonaws.com</strong></pre>
<div class="packt_infobox"><span>The endpoint you use will be specific to the AWS region that you operate out of. You can view the list of region-specific CodeCommit URLs along with the availability of the CodeCommit service at <a href="http://docs.aws.amazon.com/codecommit/latest/userguide/regions.html">http://docs.aws.amazon.com/codecommit/latest/userguide/regions.html</a>.<a href="http://docs.aws.amazon.com/codecommit/latest/userguide/regions.html"/></span></div>
<p>With this step, we have successfully validated and connected our development server with the AWS CodeCommit service! But where is our CodeCommit repository?</p>
<ol>
<li>To create the repository, log in to the AWS CodeCommit service using URL <a href="https://console.aws.amazon.com/codecommit">https://console.aws.amazon.com/codecommit</a>. Remember to change the <span class="packt_screen">Region</span> based on what you selected during the key verification state.</li>
<li>Since this is our first time working with CodeCommit, select the <span class="packt_screen">Get Started</span> option to begin with. This will display the <span class="packt_screen">Create repository</span> page, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="259" width="659" src="Images/bcb3f74e-2d2b-4fce-abb0-176341c6a6f9.png"/></div>
<ol start="3">
<li>Provide a suitable <span class="packt_screen">Repository name</span> and an optional <span class="packt_screen">Description</span>. Click on <span class="packt_screen">Create repository</span> once done.</li>
<li>You can additionally configure notifications for specific <span class="packt_screen">Event types</span>, such as pull requests and commits made to your repo in the <span class="packt_screen">Configure email notifications</span> page. Simply select an existing <span class="packt_screen">SNS topic</span> or opt to <span class="packt_screen">Create a new topic</span> based on your requirements. Once done, click on <span class="packt_screen">Save</span> to complete the repository creation process.</li>
</ol>
<p>With the repository created, you can now use the development server and connect to it using a simple <kbd>git clone</kbd> command. You can obtain your repository's connection URL anytime by simply selecting the <span class="packt_screen">Connect</span> option present on the <span class="packt_screen">Code</span> page:</p>
<pre><strong># git clone https://git-codecommit.us-east-1.amazonaws.com/v1/repos/&lt;YOUR_CODECOMMIT_REPO&gt;</strong> </pre>
<p>Here's a snapshot of the first <kbd>git clone</kbd> command output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/e3a3932d-ee79-422d-90c0-e441dafb63b9.png" width="871" height="211"/></div>
<p>Since the repository is empty, the cloning process simply creates a folder with your repository's name on your development server. You can now use this folder as a code source control by simply adding your program files, binaries, and other application-specific data to it.</p>
<p>In the next section, we will be using this repository as our WordPress application source control and explore a few simple commands and features that are provided as a part of AWS CodeCommit.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with branches, commits, and triggers</h1>
                </header>
            
            <article>
                
<p>With your CodeCommit repo created, it's now time to go ahead and use this repository as our source control repository. To do so, we will first push a standard WordPress application from our local development server to the AWS CodeCommit repository using simple Git commands and later run a few more Git commands as well as AWS actions to branch and commit our code.</p>
<div class="packt_infobox">You can obtain a WordPress application ZIP file by downloading it from here:<br/>
<a href="https://github.com/WordPress/WordPress">https://github.com/WordPress/WordPress</a></div>
<p>To begin with, first we will need to copy the WordPress application contents over to our local repository that was cloned earlier:</p>
<ol>
<li>Once the WordPress application is downloaded to your local development server, simply unzip and copy its contents over to the local repository. Your local repository should now show a folder structure similar to the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="447" width="553" src="Images/15239bc3-a5e8-4b6e-b3bb-4bc2e291f633.png"/></div>
<ol start="2">
<li>With the code in place, simply use the following Git commands to commit and push the code over to your AWS CodeCommit repository. First up, stage the files using the <kbd>git add</kbd> command:</li>
</ol>
<pre style="padding-left: 60px"><strong># git add *</strong></pre>
<ol start="3">
<li>Next, commit the changes using the <kbd>git commit</kbd> command:</li>
</ol>
<pre style="padding-left: 60px"><strong># git commit -m "First Commit!!"</strong></pre>
<ol start="4">
<li>And, finally, push the commit over to the AWS CodeCommit repository. Here, the keyword <kbd>origin</kbd> is the default remote name used by Git for your AWS CodeCommit repository, whereas <kbd>master</kbd> is the default branch name:</li>
</ol>
<pre style="padding-left: 60px"><strong># git push -u origin master</strong></pre>
<ol start="5">
<li>You should see the code get uploaded to your AWS CodeCommit repository, as shown in the following image. You can cross-verify this by refreshing and checking the <span class="packt_screen">Code</span> page on your AWS CodeCommit dashboard as well:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="236" width="840" src="Images/fac448f3-bb8b-45ef-961e-5261da4ba809.png"/></div>
<p>Similarly, you and your fellow developers can edit and commit the code back to the AWS CodeCommit repository. You can also create multiple branches of your repository so that developers can work independently on the code without affecting the <kbd>master</kbd> branch. Once the features are all thoroughly tested and verified, the individual developer branches can be merged into a more stable <kbd>master</kbd> branch of the software.</p>
<p>Creating a branch in CodeCommit is an extremely easy process! You can use the CodeCommit dashboard, the Git command line, or even the AWS CLI to create one of your own:</p>
<ol>
<li>To create a branch using the AWS CodeCommit dashboard, simply select the <span class="packt_screen">Branches</span> option from the navigation pane.</li>
<li>Next, select the <span class="packt_screen">Create branch</span> option to bring up the <span class="packt_screen">Create</span> branch page. Here, provide a suitable <span class="packt_screen">Branch name</span> and also select where you would like this new branch to <span class="packt_screen">Branch from</span>. In this case, since you only have the <kbd>master</kbd> branch created, you can select that for now. Click on <span class="packt_screen">Create</span> once done.</li>
<li>You can also use the Git command line itself to achieve the same result. In this case, from the development server, type in the following command to create a new branch:</li>
</ol>
<pre style="padding-left: 60px"><strong># git checkout -b &lt;NEW_BRANCH_NAME&gt;</strong></pre>
<div class="CDPAlignCenter CDPAlign"><img src="Images/4d4cbea3-5d37-4ac6-8bee-738615e8e4ba.png" width="796" height="85"/></div>
<p>With the new branch created, you can also use the <span class="packt_screen">Compare</span> functionality provided by CodeCommit to compare the changes made to the branch against another branch. To do so, we first need to perform some changes in the application so that it can get reflected as a change.</p>
<p>Without changing the current branch of the repository, simply update any one of the WordPress files by adding or removing a comment. In my case, I simply made a few comment changes in the WordPress application's <kbd>index.php</kbd> file; however, feel free to modify any other file as you see fit. Once the changes are made, we once again need to stage, commit, and push the changes over to the new branch of our repository:</p>
<ol>
<li>Stage the changes by using the <kbd>git add</kbd> command. You can either add all the files for staging by using <kbd>*</kbd> or even specify the filename you wish to stage as well:</li>
</ol>
<pre style="padding-left: 60px"><strong># git add *</strong></pre>
<ol start="2">
<li>Next, commit the changes using the <kbd>git commit</kbd> command:</li>
</ol>
<pre style="padding-left: 60px"><strong># git commit -m "&lt;SOME_NEW_COMMIT_MESSAGE&gt;"</strong></pre>
<ol start="3">
<li>And, finally, push the changes over to the branch using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong># git push origin &lt;NEW_BRANCH_NAME&gt;</strong></pre>
<ol start="4">
<li>With the changes pushed, use the <span class="packt_screen">Compare</span> option provided under the <span class="packt_screen">Commits</span> section in the CodeCommit dashboard. Here, select the <span class="packt_screen">master</span> as the <em>source</em> branch and the branch that you created using the Git command line as the <span class="packt_screen">Destination</span> branch. Click on <span class="packt_screen">Compare</span> once done. You should see the changes compared, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="409" width="1041" src="Images/1a7930dc-5e9b-464a-be5d-744725a7061a.png"/></div>
<p>You can use the <span class="packt_screen">Go to file</span> drop-down list to toggle between different files, if you have made changes in them. Alternatively, you can also use the <span class="packt_screen">Unified</span> and <span class="packt_screen">Split</span> views to change the visual comparison as you see fit.</p>
<p>CodeCommit also provides an additional feature called <strong>triggers</strong> that you can use to either send notifications to or run some other external code build or process. You can assign up to 10 triggers per repository that you create, however, at the time of writing this book, CodeCommit only supports AWS SNS and AWS Lambda as its trigger mechanisms:</p>
<ol>
<li>To create a simple trigger, using the CodeCommit dashboard, select the <span class="packt_screen">Settings</span> tab from the navigation pane. Here, select the <span class="packt_screen">Triggers</span> tab to create as well as view the list of existing triggers, if any.</li>
<li>Select the <span class="packt_screen">Create trigger</span> option to bring up the <span class="packt_screen">Create trigger</span> page. Here, you can configure triggers in response to certain repository events, such as <span class="packt_screen">Push to an existing branch</span>, <span class="packt_screen">Create branch or tag</span>, <span class="packt_screen">Delete branch or tag</span>, or <span class="packt_screen">All repository events</span>.</li>
<li>Provide a <span class="packt_screen">Trigger name</span> and select the appropriate <span class="packt_screen">Events</span> and <span class="packt_screen">Branch name</span> that you wish to associate the trigger with. Once done, you can configure the trigger to either use an existing SNS topic or a Lambda function as its <span class="packt_screen">Service</span>. You can even test the functioning of the trigger by selecting the <span class="packt_screen">Test trigger</span> option. This will simulate a trigger based on the <em>event</em> that you would have selected earlier.</li>
</ol>
<p>In this way, you can configure triggers for sending notifications to your developers as well as trigger-specific Lambda functions based on your repository's requirements.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introducing AWS CodeDeploy</h1>
                </header>
            
            <article>
                
<p>With CodeCommit configured and ready to use for our WordPress application, we can now move on to yet another Code Suite service that can actually be used to deploy the code across thousands of EC2 instances! Here's introducing AWS CodeDeploy!</p>
<p>AWS CodeDeploy is basically a deployment service that allows you to automate the deployment of your applications to Amazon EC2 instances, Lambda functions, or even to on-premise instances. There is no limit to what an AWS CodeDeploy service can deploy. You can use it for deploying virtually anything from code, packages, binaries, scripts, files, and so on. As of writing this book, CodeDeploy only supports GitHub repositories and Amazon S3 buckets as the default application content repositories. Yes, you heard it right, CodeDeploy does not support CodeCommit as a repository source as of now.</p>
<p>Besides the automation, CodeDeploy also provides you with the following set of useful benefits. It allows you to:</p>
<ul>
<li><span>Quickly create new prototype software and deploy at scale without manual interventions</span></li>
<li>Easily update to your application code without any downtime</li>
<li>Rollback deployments in case of any errors</li>
<li>Scale your deployment from one to a thousand instances, all without disrupting to your existing applications</li>
</ul>
<p>In this section of the chapter, we will be looking at how to set up CodeDeploy for our own application deployments, but before we get into that, here's a quick look at some of CodeDeploy's essential concepts.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Concepts and terminologies</h1>
                </header>
            
            <article>
                
<p>CodeDeploy essentially comprises two main configurable sections that can be broadly classified as deployments and applications. Here's a look at each of these concepts:</p>
<ul>
<li><strong>Applications:</strong> Applications here imply simple names that are used by CodeDeploy to identify individual application codes targeted for specific deployments. An application can be deployed either on an EC2 instance, an on-premise instance, as well as on a serverless compute platform, such as AWS Lambda.</li>
<li><strong>Deployments</strong>: Deployments are a collection of deployment configurations and deployment types, including:
<ul>
<li><strong>Deployment configurations</strong>: Deployment configurations are a set of simple rules that determine how fast an application will be deployed and the success or failure conditions for that particular deployment. For example, for an EC2 deployment, the configuration rules can dictate the required minimum number of healthy instances, whereas with a Lambda function deployment, these rules can be used to specify how the traffic is routed to the functions during a deployment.</li>
<li><strong>Deployment group</strong>: This is a group of EC2 or on-premise instances that are either standalone or a part of an auto-scaling group. Since AWS Lambda is a managed service, it does not provide any deployment groups.</li>
<li><strong>Deployment types</strong>: Deployment types indicate the type of method used to get the latest version of your application deployed on a particular deployment group. There are two deployment types supported:
<ul>
<li><strong>In-place deployments</strong>: In this case, the application running on each EC2 instance is stopped, updated, started, and verified. This form of deployment is only supported for EC2 and on-premise instances.</li>
<li><strong>Blue/green deployments</strong>: In this scenario, the underlying instances are replaced by newer instances with the updated piece of code. The instances are registered to an <strong>Elastic Load Balancer</strong> (<strong>ELB</strong>) that routes traffic to the newer instances while the older instances can then be terminated. With the serverless platform, the traffic here too is shifted automatically by AWS from the current Lambda functions to the current updated ones. Note that all Lambda deployments are in fact blue/green deployments only.</li>
</ul>
</li>
</ul>
</li>
<li><strong>CodeDeploy agent</strong>: CodeDeploy agent is a simple software package that gets installed on either an EC2 or an on-premise instance and is used by CodeDeploy for setting up and working with application deployments. Once the agent is installed on an instance, an associated configuration file is created. This file contains application-specific directory paths and other settings that CodeDeploy uses to interact with the instances. The file is a simple YAML file and can be located in the following directories based on the instance's operating system:
<ul>
<li><strong>Amazon Linux, Ubuntu, RedHat Enterprise Linux</strong>: <kbd>/etc/codedeploy-agent/conf/codedeployagent.yml</kbd></li>
<li><strong>Windows Servers</strong>: <kbd>C:ProgramDataAmazonCodeDeployconf.yml</kbd></li>
</ul>
</li>
<li><strong>Application specification files</strong>: Application specification files, or AppSpec files, are used to define and manage individual deployments as a series of life cycle event hooks. Each hook itself can be another file, such as a simple script to start or stop services, install dependencies, and so on. AppSpec files are supported in both JSON as well as YAML formats. At the time of the deployment, the AWS CodeDeploy agent looks up the name of the current event in the hooks section of the AppSpec file. If an event is found, the agent retrieves the list of scripts to execute and runs them sequentially in the order in which they were written in the AppSpec file.</li>
</ul>
<p>With the basics out of the way, let's quickly look at how we can set up an EC2 instance to be used with CodeDeploy.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing and configuring the CodeDeploy agent</h1>
                </header>
            
            <article>
                
<p>Before we begin with the actual launch of our EC2 instance with the CodeDeploy agent installed on it, we need to set up an EC2 instance profile as well as an instance role that will grant our EC2 instances the necessary permissions to interact with both CodeCommit as well as with CodeDeploy:</p>
<ol>
<li>To get started, first log in to the AWS Management Console and select the <span class="packt_screen">IAM</span> service from the services <span class="packt_screen">Filter</span>. Alternatively, you can launch the IAM dashboard by selecting URL <a href="https://console.aws.amazon.com/iam/">https://console.aws.amazon.com/iam/</a>.</li>
<li>From the IAM dashboard, select the <span class="packt_screen">Policies</span> option from the navigation pane to bring up the IAM <span class="packt_screen">Policies</span> page. Here, click on <span class="packt_screen">Create policy</span> to get started.</li>
<li>In the <span class="packt_screen">Create policy</span> page, select the <span class="packt_screen">JSON</span> tab and paste the following lines of the policy document:</li>
</ol>
<pre style="padding-left: 60px">{ 
    "Version": "2012-10-17", 
    "Statement": [ 
        { 
            "Action": [ 
                "ec2:Describe*", 
                "sns:*", 
                "codecommit:*", 
                "codedeploy:*", 
                "codepipeline:*", 
                "codecommit:GetBranch", 
                "codecommit:GetCommit", 
                "codecommit:UploadArchive", 
                "codecommit:GetUploadArchiveStatus", 
                "codecommit:CancelUploadArchive", 
                "s3:*" 
            ], 
            "Effect": "Allow", 
            "Resource": "*" 
        } 
    ] 
}</pre>
<p style="padding-left: 90px">The policy document essentially provides the EC2 instance with the required set of permissions to interact with the likes of AWS services, such as CodeDeploy, CodeCommit, and CodePipeline.</p>
<ol start="4">
<li>Click on <span class="packt_screen">Review policy</span> once done. In the final <span class="packt_screen">Review policy</span> page, provide a suitable <span class="packt_screen">Name</span> for the policy and click <span class="packt_screen">Create policy</span> to complete the process.</li>
<li>With the policy created, we now simply assign this to a new IAM Role. To do so, select the <span class="packt_screen">Roles</span> option from the navigation pane to bring up the IAM <span class="packt_screen">Roles</span> page.</li>
<li>Click on <span class="packt_screen">Create role</span> to start the wizard. From the <span class="packt_screen">Select type of trusted entity</span> section, make sure you select <span class="packt_screen">AWS service</span> and filter out <span class="packt_screen">EC2</span> from there. Click on <span class="packt_screen">Next: Permissions</span> to proceed.</li>
<li>In the <span class="packt_screen">Attach permissions policy</span> page, filter the earlier created policy and attach it to our new role, as depicted in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="Images/ea4394d9-11ce-425f-9325-cc38a33b0aa9.png" width="828" height="256"/></div>
<ol start="8">
<li>Finally, at the <span class="packt_screen">Review</span> page, provide your role with a suitable <span class="packt_screen">Role Name</span> and click on <span class="packt_screen">Create role</span> to complete the process.</li>
<li>Before launching your EC2 instance with this newly created Role, ensure that the role's <span class="packt_screen">Trust Relationship</span> has the following set of AWS services added in its policy document:</li>
</ol>
<pre style="padding-left: 60px">{ 
  "Version": "2012-10-17", 
  "Statement": [ 
    { 
      "Sid": "", 
      "Effect": "Allow", 
      "Principal": { 
        "Service": [ 
          "codecommit.us-east-1.amazonaws.com", 
          "ec2.amazonaws.com", 
          "codedeploy.us-east-1.amazonaws.com", 
          "codepipeline.us-east-1.amazonaws.com" 
        ] 
      }, 
      "Action": "sts:AssumeRole" 
    } 
  ] 
} </pre>
<p>With this step completed, we are now ready to launch a simple EC2 instance and assign the newly created role:</p>
<ol>
<li>From the EC2 Management Console, select the <span class="packt_screen">Launch Instance</span> option to get started. For this particular use case, I've opted to go for the standard <span class="packt_screen">Amazon Linux</span> AMI (<kbd>amzn-ami-hvm-2017.09.1.20171120-x86_64-gp2 - ami-55ef662f</kbd>); however, you can very well opt for a different Linux OS distribution as per your requirements.</li>
<li>Select an appropriate <span class="packt_screen">Instance type</span> for hosting our simple WordPress application. For now, I've selected the <strong>t2.micro</strong> instance type itself.</li>
<li>Next, in the <span class="packt_screen">Configure Instance Details</span> page, select the appropriate <span class="packt_screen">Network</span>, <span class="packt_screen">Subnet</span>, and <span class="packt_screen">IAM Role</span> for our new EC2 instance. Paste the following set of lines as <span class="packt_screen">User data</span> under the <span class="packt_screen">Advanced Details</span> section, as shown in the following code. This simple user data script will copy and install the CodeDeploy agent along with a few other essential dependencies. You can find the complete copy of the following code at <a href="https://github.com/yoyoclouds/Administering-AWS-Volume2">https://github.com/yoyoclouds/Administering-AWS-Volume2</a>:</li>
</ol>
<pre style="padding-left: 60px">#!/bin/bash 
yum -y update 
yum install -y ruby 
yum install -y aws-cli 
cd /home/ec2-user 
aws s3 cp s3://aws-codedeploy-us-east-1/latest/install . --region us-east-1 
chmod +x ./install 
./install auto </pre>
<div style="padding-left: 60px" class="packt_infobox">Remember to change the <kbd>region</kbd> parameter as per your current operational region value.</div>
<ol start="4">
<li>Once the required storage is assigned to the instance, move on and assign a few essential tags for our EC2 instance. These tags will be used later in CodeDeploy to reference our EC2 instances, so make a note of the same.</li>
<li>Finally, create a new security group and make sure that the ports <kbd>22</kbd> (SSH) and <kbd>80</kbd> (HTTP) are open for internet traffic.</li>
<li>Review the settings of your instance and launch it. Additionally, remember to associate your instance with a key pair as well before you launch it, as it can be useful to verify or troubleshoot the AWS CodeDeploy agent.</li>
</ol>
<p>With this, you now have successfully launched and set up a CodeDeploy agent on an EC2 instance. In the next section of this chapter, we will look at how you can take this installation further by configuring the AppSpec file for the final CodeDeploy deployment.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up the AppSpec file</h1>
                </header>
            
            <article>
                
<p>As mentioned earlier, the AppSpec, or the application specifications file, is basically a YAML or JSON backed file used to define life cycle hooks for a particular deployment. In this case, with our EC2 instance prepped and ready with the CodeDeploy agent, we still need the AppSpec file to define a set of dependencies that will essentially install the necessary packages on the EC2 instance, start or stop the services, change permissions, and much more.</p>
<p>The AppSpec file comprises the following sections:</p>
<ul>
<li><strong>Version</strong>: The version of the AppSpec file. Currently, the version number supported with CodeDeploy is <kbd>0.0</kbd>. Do not change this value.</li>
<li><strong>OS</strong>: Specifies the operating system of the underlying EC2/on-premise instance.</li>
<li><strong>Files</strong>: Specifies the files that need to be copied on the instance at the time of the deployment process. You can additionally specify a source and a destination folder as well for your applications here.</li>
<li><strong>Hooks</strong>: Hooks essentially specify when a particular deployment life cycle has to be triggered. There are four main types of hooks: <kbd>BeforeInstall</kbd>, <kbd>AfterInstall</kbd>, <kbd>ApplicationStart</kbd>, and <kbd>ApplicationStop</kbd>. Each hook further requires additional parameters, such as the <kbd>location</kbd> of the scripts to execute, a <kbd>timeout</kbd> value, and how the scripts should be <kbd>runas</kbd>.</li>
</ul>
<p>Here is a representation of a simple AppSpec file for our WordPress deployment. Since we are using the Amazon Linux-backed instance, the <kbd>os</kbd> value is set to <kbd>linux</kbd> along with other essential parameters, such as <kbd>files</kbd> and <kbd>hooks</kbd>. Note in our case, we are configuring the WordPress application files to be copied from their default location over to <kbd>/var/www/html/WordPress</kbd> as well:</p>
<pre>version: 0.0 
os: linux 
files: 
  - source: / 
    destination: /var/www/html/WordPress 
hooks: 
  BeforeInstall: 
    - location: scripts/install_dependencies.sh 
      timeout: 300 
      runas: root 
  AfterInstall: 
    - location: scripts/change_permissions.sh 
      timeout: 300 
      runas: root 
  ApplicationStart: 
    - location: scripts/start_server.sh 
      timeout: 300 
      runas: root 
  ApplicationStop: 
    - location: scripts/stop_server.sh 
      timeout: 300 
      runas: root </pre>
<p>To create this file, login to your development server and not your CodeDeploy instance. Once logged into the development server, open the WordPress application directory that we used during the CodeCommit sections of this chapter. This is the same directory that we used to sync with our master CodeCommit repository as well:</p>
<ol>
<li>Here, at the application's root directory, create a blank <kbd>appspec.yml</kbd>, and copy-paste the <kbd>appspec</kbd> contents explained earlier:</li>
</ol>
<pre style="padding-left: 60px"><strong># vi appspec.yml</strong> </pre>
<ol start="2">
<li>With the AppSpec file created, we now move on to create the individual files for the life cycle hooks. To do so, create a folder named <kbd>scripts</kbd> within the WordPress application directory and create each of these individual shell scripts within it:</li>
</ol>
<pre style="padding-left: 60px"><strong># mkdir scripts</strong></pre>
<ol start="3">
<li>Create the <kbd>install_dependencies.sh</kbd> script that will essentially install the necessary packages required to run WordPress on an instance:</li>
</ol>
<pre style="padding-left: 60px"><strong># vi scripts/install_dependencies.sh 
#!/bin/bash 
sudo yum install -y httpd mysql mysql-server php 
sudo yum install -y php-mysql</strong> </pre>
<ol start="4">
<li>Similarly, create the <kbd>change_permissions.sh</kbd> script that modifies the permissions of the files present in the scripts folder to <em>executable</em>:</li>
</ol>
<pre style="padding-left: 60px"><strong># vi scripts/change_permissions.sh 
#!/bin/bash 
chmod -R 755 /var/www/html/WordPress</strong> </pre>
<ol start="5">
<li>And, finally, create the <kbd>start_server.sh</kbd> and the <kbd>stop_server.sh</kbd> scripts that will start and stop the <kbd>httpd</kbd> and <kbd>mysql</kbd> services on the deployment EC2 instances:</li>
</ol>
<pre style="padding-left: 60px"><strong># vi scripts/start_server.sh 
#!/bin/bash 
service httpd start 
service mysqld start </strong><br/><br/><strong># vi scripts/stop_server.sh 
#!/bin/bash 
isExistApp=`pgrep httpd` 
if [[ -n  $isExistApp ]]; then 
   service httpd stop 
fi 
isExistApp=`pgrep mysqld` 
if [[ -n  $isExistApp ]]; then 
    service mysqld stop 
fi</strong> </pre>
<p>Got this far? Awesome! We are almost done with the AppSpec files, with just one small step left: uploading these changes to our CodeCommit repository!</p>
<p>To do so, run the following set of commands from the deployment server:</p>
<pre><strong># git add * 
# git commit -m "Added scripts directory with AppSpec file!" 
# git push -u origin &lt;NEW_BRANCH_NAME&gt;</strong></pre>
<p>Et voila! The WordPress application and our deployment scripts are all uploaded to our CodeCommit branch and ready for deployment! In the next section, we will create and configure an application and deployment group for our CodeDeploy.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a CodeDeploy application and deployment group</h1>
                </header>
            
            <article>
                
<p>With our AppSpec file and scripts in place and the EC2 instance set up with the CodeDeploy agent as well, the final thing left is to configure AWS CodeDeploy and tie these things together:</p>
<ol>
<li>Start off by logging into the AWS CodeDeploy service by selecting URL <a href="https://console.aws.amazon.com/codedeploy/home">https://console.aws.amazon.com/codedeploy/home</a>.<a href="https://console.aws.amazon.com/codedeploy/home"/></li>
<li>Since this is the first time we are using CodeDeploy, select the <span class="packt_screen">Get Started Now</span> option. Here, you will be prompted to select either a <span class="packt_screen">Sample deployment</span> that deploys a sample application on the EC2 instances or, alternatively, go for a <span class="packt_screen">Custom deployment</span> if you have your code and EC2 instances up and running. In this case, we will select the <span class="packt_screen">Custom deployment</span> option itself.</li>
<li>In the <span class="packt_screen">Create application</span> page, start off by providing a suitable <span class="packt_screen">Application name</span>, <span class="packt_screen">Compute Platform</span>, and a <span class="packt_screen">Deployment group name</span>. Remember to select the <span class="packt_screen">EC2/On-premises</span> option from the <span class="packt_screen">Compute Platform</span>, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="181" width="590" src="Images/35fbb4b7-afbf-4e1f-8b1e-f21272c33a64.png"/></div>
<ol start="4">
<li>Next, in the <span class="packt_screen">Deployment type</span> section, choose the <span class="packt_screen">In-place deployment</span> option for now. This will enable CodeDeploy to update the existing instances with the revised set of application code with some amount of downtime.</li>
</ol>
<ol start="5">
<li>In the <span class="packt_screen">Environment configuration</span> section, you can specify any combination of <span class="packt_screen">Auto Scaling groups</span>, <span class="packt_screen">Amazon EC2 instances</span>, and <span class="packt_screen">On-premises instances</span> to add instances to this deployment group. Since we have created an EC2 instance in our earlier steps with the CodeDeploy agent installed in it, select the <span class="packt_screen">Amazon EC2 instances</span> tab. From the <span class="packt_screen">Tag group</span> drop-down, select the instance's <span class="packt_screen">Key</span> and <span class="packt_screen">Value</span>, as shown.</li>
</ol>
<p style="padding-left: 90px">Note that these are the same tags that you would have configured to your instance before its launch in our earlier sections:</p>
<div class="CDPAlignCenter CDPAlign"><img height="384" width="926" src="Images/6c965bce-6159-4e2d-bc9a-e4c121dc0f99.png"/></div>
<ol start="6">
<li>Moving on, in the <span class="packt_screen">Deployment configuration</span> section, you can choose from a list of default and custom deployment configurations. As discussed earlier, a deployment configuration is a set of rules that determines how fast an application will be deployed along with the definition of success or failure conditions for a particular deployment.</li>
</ol>
<p style="padding-left: 90px">There are three default configurations provided by AWS CodeDeploy itself:</p>
<ul>
<li><strong>OneAtATime</strong>: Routes traffic to one instance in the replacement environment at a time</li>
<li><strong>HalfAtATime</strong>: Routes traffic to up to half the instances in the replacement environment at a time</li>
<li><strong>AllAtOnce</strong>: Routes traffic to all instances in the replacement environment all at once</li>
</ul>
<p style="padding-left: 90px">Since we are working with just a single EC2 instance as of now, go ahead and select the <span class="packt_screen">OneAtATime</span> deployment configuration option.</p>
<ol start="7">
<li>Finally, select the IAM Role that we created and assigned our EC2 instance to at the time of launching, using the <span class="packt_screen">Service Role</span> drop-down list. Once done, select the <span class="packt_screen">Create application</span> option to complete the process!</li>
</ol>
<p>There you have it! If you made it this far then you have successfully configured both AWS CodeCommit and AWS CodeDeploy for our WordPress application's deployment! But we are still missing the glue that ties all these services together, and that precisely is what we will be talking about in the next section with the introduction of AWS CodePipeline!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introducing AWS CodePipeline</h1>
                </header>
            
            <article>
                
<p>AWS CodePipeline is a continuous delivery service that you can use to model, visualize, and automate the steps required to release your application software. This is made possible by building <em>pipelines</em> that contain one or more <em>stages</em>. The stages can be broadly classified as <em>build</em>, where the code is compiled and built using, say, AWS CodeBuild or some other third-party tool, <em>staging</em>, and <em>deployment</em>, where the code is pushed on to compute instances using AWS CodeDeploy, and so on. Each stage internally describes a set of actions that it needs to perform in order to prepare the software for its release. This action can be anything from building your source code from a Git repository, to making changes to a file, or deploying packages, and so on. Every change made to either your code or some configurational setting within CodePipeline is considered as a <em>revision</em> and you can have multiple such revisions created within a single stage of a pipeline.</p>
<div class="packt_infobox">Even changes made to a single stage within the pipeline results in all actions across all stages being re-executed.</div>
<p>You can use these features provided by CodePipeline to effectively manage and monitor the release of your software. In this section, we will be continuing with our use case set up earlier using CodeCommit and CodeDeploy and see how we can truly build an end-to-end continuous delivery cycle using AWS CodePipeline.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating your own continuous delivery pipeline</h1>
                </header>
            
            <article>
                
<p>Getting started with CodePipeline is extremely easy provided you have all the necessary prerequisites met, which include setting up the CodeCommit repository with your latest piece of application code (in this case, the WordPress application), as well as configuring the application and the AppSpec file using CodeDeploy:</p>
<ol>
<li>To begin with, launch the CodePipeline Management dashboard by selecting URL <a href="https://console.aws.amazon.com/codepipeline/home">https://console.aws.amazon.com/codepipeline/home</a>.<a href="https://console.aws.amazon.com/codepipeline/home"/></li>
<li>Since this is our first setup, click on the <span class="packt_screen">Get Started</span> option to get going. This will bring up the <span class="packt_screen">Getting started with AWS CodePipeline</span> wizard, as shown in the following screenshot. Start off by providing a suitable <span class="packt_screen">Pipeline name</span> and click <span class="packt_screen">Next step</span> to continue:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="Images/6e2daad6-3d4c-4d2e-9e2c-7049f95fbd0c.png" width="863" height="212"/></div>
<ol start="3">
<li>Next, in the <span class="packt_screen">Source</span> page, we need to select and configure the source for our new pipeline. At the time of writing this book, CodePipeline supports three source code providers, namely Amazon S3, AWS CodeCommit, and GitHub. For the purpose of this use case, go ahead and select <span class="packt_screen">AWS CodeCommit</span> from the <span class="packt_screen">Source</span> drop-down list.</li>
<li>This will automatically prompt you to enter the subsequent CodeCommit <span class="packt_screen">Repository name</span> as well as its corresponding <span class="packt_screen">Branch name</span>. Make sure you provide the same branch name that contains the latest WordPress code as well as the AppSpec file. Click on <span class="packt_screen">Next step</span> to continue.</li>
<li>The third stage of the Pipeline setup is the <span class="packt_screen">Build</span> stage where you can specify the build provider. CodePipeline supports three build providers, namely AWS CodeBuild, Jenkins, and Solano CI. Since our WordPress installation doesn't require any compilations or build procedures, simply select the <span class="packt_screen">No Build</span> option from the drop-down list and click on <span class="packt_screen">Next step</span> to continue.</li>
</ol>
<ol start="6">
<li>The fourth state requires the <span class="packt_screen">Deployment</span> configurations to be set up for the pipeline. Here too you are provided with various options that you can choose to leverage based on your needs. At present, CodePipeline supports AWS Opsworks, AWS CodeDeploy, AWS CloudFormation, and AWS Elastic Beanstalk as the <span class="packt_screen">Deployment providers</span>. Since we have already configured AWS CodeDeploy for our use case, select the same from the drop-down list.</li>
<li>Next, fill in the correct <span class="packt_screen">Application name</span> as well as the <span class="packt_screen">Deployment group</span> that we configured during the setup of CodeDeploy. Click on <span class="packt_screen">Next step</span> once done:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="Images/1d2c518e-e810-42cb-b73a-9cb322e0dfd8.png" width="867" height="386"/></div>
<ol start="8">
<li>The final step required is to configure the <span class="packt_screen">Service Role</span>. The service role essentially grants CodePipeline permissions to use resources in your AWS account. Provide a suitable <span class="packt_screen">Role name</span> and click on <span class="packt_screen">Next step</span> to review the pipeline's configuration.</li>
<li>On the <span class="packt_screen">Review your pipeline</span> page, ensure that all the fields are correctly configured and click on <span class="packt_screen">Create pipeline</span> when done.</li>
</ol>
<p>Selecting this option first creates a unique S3 bucket within your environment that will contain and store all the necessary artifacts for this particular pipeline. Once the pipeline is created, you can view it on the AWS CodePipeline dashboard.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Putting it all together</h1>
                </header>
            
            <article>
                
<p>With the pipeline all set up, you can now test the entire setup as one cohesive solution!</p>
<p>First up, ensure that there are no errors in either of the stages during the deployments. In case there are any errors, simply select the particular error link provided in the stage and follow it back to its source, which can be anywhere from issues in CodeCommit to even the setting up of CodeDeploy. Here's a screenshot of the pipeline that we created using an accumulation of all of the preceding sections:</p>
<div class="CDPAlignCenter CDPAlign"><img height="555" width="629" src="Images/3c30e91b-5bea-434f-990b-7254d2b4b6b1.png"/></div>
<p>Here, you can choose to add more stages to your pipeline by simply selecting the <span class="packt_screen">Edit</span> option, as highlighted earlier. Additionally, you can also view your pipeline's execution history by selecting the <span class="packt_screen">View pipeline history</span> option.</p>
<p>In the <span class="packt_screen">Edit</span> pipeline page, you can choose to add one or more stages to your pipeline as you see fit. Simply select the <span class="packt_screen">+ Stage</span> option provided at the end of each existing stage. This will bring up a new dialog where you can specify the stage's <span class="packt_screen">Name</span> as well as define one or more actions.</p>
<p>Consider the following use case where we need to add an approval step before the code actually gets pushed into the staging area. In that case, we need to add a new stage between the existing <span class="packt_screen">Source</span> and <span class="packt_screen">Staging</span> stages:</p>
<ol>
<li>Click on the <span class="packt_screen">+ Stage</span> option and provide a suitable name for this new stage. Next, select the <span class="packt_screen">+ Action</span> option to add the rules for setting up the approval process.</li>
<li>In the <span class="packt_screen">Add action</span> dialog box, start by selecting the type of action from the <span class="packt_screen">Action category</span> drop-down list. The following list of actions can be added to a stage: <span class="packt_screen">Approval</span>, <span class="packt_screen">Source</span>, <span class="packt_screen">Build</span>, <span class="packt_screen">Test</span>, <span class="packt_screen">Deploy</span>, and <span class="packt_screen">Invoke</span>. For this use case, select <span class="packt_screen">Approval</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="299" width="595" src="Images/1fbe76eb-b778-45dc-ab77-3f728ce8f535.png"/></div>
<ol start="3">
<li>Fill in a suitable <span class="packt_screen">Action name</span> and select an appropriate <span class="packt_screen">Action type</span> as well. At present, only a <span class="packt_screen">Manual approval configuration</span> option is provided by CodePipeline.</li>
</ol>
<ol start="4">
<li>Finally, select either one of a pre-existing SNS topics using the <span class="packt_screen">SNS topic ARN</span> field and click on <span class="packt_screen">Add action</span> once completed.</li>
<li>With the new stage added, click on <span class="packt_screen">Save pipeline changes</span> to commit the change. You should have a new stage added and visible in your pipeline, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="620" width="230" src="Images/036a9d75-3287-41b0-af6a-48cbe498f564.png"/></div>
<ol start="6">
<li>Once the <span class="packt_screen">Source</span> stage is prepped, the pipeline automatically halts at the <span class="packt_screen">Approval</span> stage, as depicted in the following screenshot. Here, you can approve the process by simply selecting the <span class="packt_screen">Review</span> option and then selecting the <kbd>approval</kbd> command. Doing so initiates the final <span class="packt_screen">Staging</span> stage which invokes the CodeDeploy service to deploy the WordPress code over to our awaiting EC2 instance:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="666" width="1158" src="Images/86c23e34-02e9-45b2-8a8d-537bea5750a8.png"/></div>
<p>After a few minutes, the application is successfully uploaded on the instance and is up and running as well. You can verify this by making a note of your instances public IP address and typing in the following URL on a browser:</p>
<pre>http:///WordPress/wp-admin/index.php</pre>
<p>Remember to prefix <kbd>WordPress</kbd> in your URL since the <kbd>AppSpec</kbd> file clearly pointed to the root of the application at the <kbd>/var/www/html/WordPress</kbd> directory and not at <kbd>/var/www/html</kbd> itself.</p>
<p>In this way, you can easily leverage and automate the deployments of your application code using the AWS Code Suite of services! Amazing isn't it? But that's not all folks! There is a ton of other fascinating things that I would like you to learn and explore, all covered in the next section itself.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Planning your next steps</h1>
                </header>
            
            <article>
                
<p>Well, we have covered a lot of new features and services in this chapter. However, there are still a few things that I would recommend you need to read up on your own as well. First up is the AWS CodeStar!</p>
<p>AWS CodeStar is an amazing service that can help developers create, manage, and work on developing applications, all one place. The integral part of CodeStar that enables this is called <strong>projects</strong>. Developers can create projects based on predefined templates that contain a supported programming model which is ready to use for developing. You can additionally select hosting for your application from a variety of options that include Amazon EC2, Elastic Beanstalk, and AWS Lambda as well! CodeStar comes with easy connectivity with various IDEs as well: Eclipse, Visual Studio, just to name a few. You can read more about <em>AWS CodeStar</em> at <a href="http://docs.aws.amazon.com/codestar/latest/userguide/welcome.html">http://docs.aws.amazon.com/codestar/latest/userguide/welcome.html</a>.</p>
<p>The second awesome service worth trying out is AWS Cloud9! AWS Cloud9 is a cloud-based IDE that you can use to write, debug, and run code, all with a standard web browser! Cloud9 comes pre-packaged with essential tools for the most popular programming languages, including JavaScript, Python, PHP, Node.js, C++, and much more, and the best part is you can easily integrate Cloud9 with the likes of other AWS services, such as CodeCommit, CodeStar, and so on. You can read more about AWS Cloud9 at <a href="https://docs.aws.amazon.com/cloud9/latest/user-guide/welcome.html">https://docs.aws.amazon.com/cloud9/latest/user-guide/welcome.html</a>.<a href="https://docs.aws.amazon.com/cloud9/latest/user-guide/welcome.html"/></p>
<p>Last, but not least, I would also recommend that you try out a complete, end-to-end CI/CD solution provided by the <strong>AWS Partner Network</strong> (<strong>APN</strong>) blog that leverages a CloudFormation stack to deploy a full-fledged AWS Code Suite, including CodeBuild, CodeCommit, CodeDeploy, and CodePipeline! The stack gives you a feel for using AWS CodeBuild as a service and also provides you with a template to automate your own Code deployments using CloudFormation. To view the blog visit <a href="https://aws.amazon.com/blogs/apn/deploy-to-production-using-aws-codebuild-and-the-aws-developer-tools-suite/">https://aws.amazon.com/blogs/apn/deploy-to-production-using-aws-codebuild-and-the-aws-developer-tools-suite/</a>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Here's a quick round up of the topics that we have covered so far in this chapter!</p>
<p>We started off by learning and understanding a bit about the AWS Code Suite of services and how they tie into the continuous integration and continuous delivery life cycle. We then learned a bit about AWS CodeDeploy and how easy it is to get started with it. We created a simple CodeCommit repository and used that to store our sample WordPress application as well. Later, we looked at AWS CodeDeploy and how it works. We also configured a CodeDeploy agent and leveraged the AppSpec file for our WordPress application's deployment life cycle. Finally, we tied it all together by integrating the work done so far with AWS CodePipeline and ended the chapter with a few essential things to read and try out on your own!</p>
<p>In the next chapter, we will be exploring two application-specific services and look at how you can leverage them for your requirements: Amazon SQS and Amazon SNS. So stay tuned!</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  </body></html>