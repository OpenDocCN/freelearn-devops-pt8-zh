<html><head></head><body>
<div id="_idContainer027">
<h1 class="chapter-number" id="_idParaDest-16"><a id="_idTextAnchor039"/><span class="koboSpan" id="kobo.1.1">1</span></h1>
<h1 id="_idParaDest-17"><a id="_idTextAnchor040"/><span class="koboSpan" id="kobo.2.1">Understanding Terraform Architecture</span></h1>
<p><span class="koboSpan" id="kobo.3.1">At its core, </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">Terraform</span></strong><span class="koboSpan" id="kobo.5.1"> is a</span><a id="_idIndexMarker000"/><span class="koboSpan" id="kobo.6.1"> simple command-line program that evaluates source code, which describes what a desired state should look like, compares it against what the actual state is, constructs a plan to transform the actual state into the desired state, and can execute the plan. </span><span class="koboSpan" id="kobo.6.2">But don’t let its perceived simplicity fool you. </span><span class="koboSpan" id="kobo.6.3">Terraform’s internal complexity manifests itself in its </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">external simplicity.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">Terraform is a large, source-available project written in Go that maintains the command-line executable. </span><span class="koboSpan" id="kobo.8.2">It provides baseline functionality </span><a id="_idIndexMarker001"/><span class="koboSpan" id="kobo.9.1">such as </span><strong class="bold"><span class="koboSpan" id="kobo.10.1">HashiCorp Configuration Language</span></strong><span class="koboSpan" id="kobo.11.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.12.1">HCL</span></strong><span class="koboSpan" id="kobo.13.1">) parsing, state management, plan creation, </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">and execution.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">Terraform is extremely powerful, yet ironically, it does very little by itself. </span><span class="koboSpan" id="kobo.15.2">But here’s the exciting part: Terraform’s superpower comes from its extensibility, a power that is not limited to its creators. </span><span class="koboSpan" id="kobo.15.3">The actual Terraform executable, by itself, can’t do much, but when bundled with one</span><a id="_idIndexMarker002"/><span class="koboSpan" id="kobo.16.1"> of its plugins—called </span><strong class="bold"><span class="koboSpan" id="kobo.17.1">providers</span></strong><span class="koboSpan" id="kobo.18.1">—Terraform can do quite a lot! </span><span class="koboSpan" id="kobo.18.2">This extensibility is a testament to the collaborative nature of the Terraform community, where everyone can contribute to its growth </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">and capabilities.</span></span></p>
<p><span class="koboSpan" id="kobo.20.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.22.1">Understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">Terraform architecture</span></span></li>
<li><span class="koboSpan" id="kobo.24.1">Understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">Terraform state</span></span></li>
<li><span class="koboSpan" id="kobo.26.1">Understanding how to build and </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">consume modules</span></span></li>
<li><span class="koboSpan" id="kobo.28.1">Understanding how to use the </span><strong class="bold"><span class="koboSpan" id="kobo.29.1">command-line interface</span></strong><span class="koboSpan" id="kobo.30.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.31.1">CLI</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">) effectively</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.33.1">Terraform has four superpowers that distinguish it from other tools: </span><em class="italic"><span class="koboSpan" id="kobo.34.1">planning</span></em><span class="koboSpan" id="kobo.35.1">, </span><em class="italic"><span class="koboSpan" id="kobo.36.1">extensibility</span></em><span class="koboSpan" id="kobo.37.1">, </span><em class="italic"><span class="koboSpan" id="kobo.38.1">configuration language</span></em><span class="koboSpan" id="kobo.39.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.40.1">modularity</span></em><span class="koboSpan" id="kobo.41.1">. </span><span class="koboSpan" id="kobo.41.2">Some tools may share some of these, but they don’t have them all. </span><span class="koboSpan" id="kobo.41.3">With these powers combined, Terraform is a game changer in </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">cloud automatio</span><a id="_idTextAnchor041"/><span class="koboSpan" id="kobo.43.1">n.</span></span></p>
<h1 id="_idParaDest-18"><a id="_idTextAnchor042"/><span class="koboSpan" id="kobo.44.1">Understanding Terraform architecture</span></h1>
<p><span class="koboSpan" id="kobo.45.1">The biggest </span><a id="_idIndexMarker003"/><span class="koboSpan" id="kobo.46.1">differentiator of Terraform is that, well, Terraform plans ahead. </span><span class="koboSpan" id="kobo.46.2">Let’s look at how Terraform handles planning </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">in detail</span></span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">.</span></span></p>
<h2 id="_idParaDest-19"><a id="_idTextAnchor043"/><span class="koboSpan" id="kobo.49.1">The plan</span></h2>
<p><span class="koboSpan" id="kobo.50.1">When </span><a id="_idIndexMarker004"/><span class="koboSpan" id="kobo.51.1">working with Terraform, you will be following a process where Terraform is used to analyze the existing environment. </span><span class="koboSpan" id="kobo.51.2">In doing this analysis, Terraform is determining what (if any) changes in the code need to be applied to the actual environment to bring it up to date. </span><span class="koboSpan" id="kobo.51.3">Terraform itemizes these changes as actions within the plan. </span><span class="koboSpan" id="kobo.51.4">While Terraform does this analysis on our behalf, produces the plan, and is fully capable of executing that plan against the environment, we are still responsible for reviewing the plan and determining if the planned changes are what </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">we intended:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer007">
<span class="koboSpan" id="kobo.53.1"><img alt="Figure 1.1 – Terraform resources are straightforward machines with inputs and outputs" src="image/B21183_01_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.54.1">Figure 1.1 – Terraform resources are straightforward machines with inputs and outputs</span></p>
<p><span class="koboSpan" id="kobo.55.1">Terraform represents every component in your environment as a resource in this analysis. </span><span class="koboSpan" id="kobo.55.2">Resources are extremely simple machines. </span><span class="koboSpan" id="kobo.55.3">They take inputs and produce outputs. </span><span class="koboSpan" id="kobo.55.4">They also can be chained together, thus creating explicit relationships between the components within your environment. </span><span class="koboSpan" id="kobo.55.5">These relationships inform Terraform’s analysis of your environment and the sequence of actions enumerated in </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">the plan.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">Once we have decided that this plan is what we intended, we ask Terraform to execute it. </span><span class="koboSpan" id="kobo.57.2">Terraform will then apply that plan to our actual environment. </span><span class="koboSpan" id="kobo.57.3">The outcome of this process is that Terraform will bring our environment up to date with the description in </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">Terraform’s design encourages developers to repeat this process. </span><span class="koboSpan" id="kobo.59.2">Therefore, as the developer updates their code, with each iteration of the code applied to the environment, we will continually assess the current state and determine the future state to match the environment our code describes. </span><span class="koboSpan" id="kobo.59.3">Each time we run Terraform to assess the environment, it will produce a plan. </span><span class="koboSpan" id="kobo.59.4">This plan was generated at a point in time when evaluating the differences between the actual environment and the </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.61.1">On </span><em class="italic"><span class="koboSpan" id="kobo.62.1">Day 1</span></em><span class="koboSpan" id="kobo.63.1">, since</span><a id="_idIndexMarker005"/><span class="koboSpan" id="kobo.64.1"> the environment does not exist, everything Terraform must create the developer described within the code. </span><span class="koboSpan" id="kobo.64.2">On </span><em class="italic"><span class="koboSpan" id="kobo.65.1">Day 2</span></em><span class="koboSpan" id="kobo.66.1">, however, things are more complex. </span><span class="koboSpan" id="kobo.66.2">On </span><em class="italic"><span class="koboSpan" id="kobo.67.1">Day 1</span></em><span class="koboSpan" id="kobo.68.1">, we started cleaning. </span><span class="koboSpan" id="kobo.68.2">However, on </span><em class="italic"><span class="koboSpan" id="kobo.69.1">Day 2</span></em><span class="koboSpan" id="kobo.70.1">, we are still determining where we are starting because Terraform has already provisioned the environment once before. </span><span class="koboSpan" id="kobo.70.2">Many things could have changed since </span><em class="italic"><span class="koboSpan" id="kobo.71.1">Day 1</span></em><span class="koboSpan" id="kobo.72.1">. </span><span class="koboSpan" id="kobo.72.2">We could have intentionally modified the code base to change the environment. </span><span class="koboSpan" id="kobo.72.3">Likewise, </span><em class="italic"><span class="koboSpan" id="kobo.73.1">gremlins</span></em><span class="koboSpan" id="kobo.74.1"> could have altered our environment during the night, thus introducing drift into our environment and requiring us to roll back </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">their changes.</span></span></p>
<p><span class="koboSpan" id="kobo.76.1">To analyze the existing environment, Terraform consults two sources of information: </span><strong class="bold"><span class="koboSpan" id="kobo.77.1">Terraform state</span></strong><span class="koboSpan" id="kobo.78.1"> and the</span><a id="_idIndexMarker006"/><span class="koboSpan" id="kobo.79.1"> environment itself—via the provider (which is also informed by Terraform state). </span><span class="koboSpan" id="kobo.79.2">If the Terraform state is empty, then Terraform assumes the environment does not exist and creates a plan that will </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">create everything:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer008">
<span class="koboSpan" id="kobo.81.1"><img alt="Figure 1.2 – Resource plan, Day 1: everything needs to be created" src="image/B21183_01_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.82.1">Figure 1.2 – Resource plan, Day 1: everything needs to be created</span></p>
<p><span class="koboSpan" id="kobo.83.1">If Terraform state exists, things will get interesting, and Terraform will have to earn its paycheck. </span><span class="koboSpan" id="kobo.83.2">Terraform will use the Terraform state to analyze the environment by querying the provider (s) about the health and configuration of each resource declared within. </span><span class="koboSpan" id="kobo.83.3">Based on these results, Terraform will construct a set of instructions. </span><span class="koboSpan" id="kobo.83.4">Once Terraform executes these instructions, the current environment will match the desired environment—as described in the code. </span><span class="koboSpan" id="kobo.83.5">However, after the first time Terraform has executed your plan successfully, if you ask Terraform to create a plan again, it will consult the Terraform state and use the providers to consult the actual environment and see that no changes </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">are needed:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer009">
<span class="koboSpan" id="kobo.85.1"><img alt="Figure 1.3 – Resource plan, Day 2: no changes in your environment" src="image/B21183_01_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.86.1">Figure 1.3 – Resource plan, Day 2: no changes in your environment</span></p>
<p><span class="koboSpan" id="kobo.87.1">To create </span><a id="_idIndexMarker007"/><span class="koboSpan" id="kobo.88.1">such an instruction set, Terraform must generate a complete dependency graph of the resources within the environment to determine what order it must execute the instructions. </span><span class="koboSpan" id="kobo.88.2">The relationships between the resources infer these dependencies. </span><span class="koboSpan" id="kobo.88.3">If one resource takes in, as an input variable, the value of another resource’s output variable, Terraform will determine that there is a dependency between </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">these resources:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer010">
<span class="koboSpan" id="kobo.90.1"><img alt="Figure 1.4 – Dependencies: one resource’s inputs is another resource’s outputs" src="image/B21183_01_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.91.1">Figure 1.4 – Dependencies: one resource’s inputs is another resource’s outputs</span></p>
<p><span class="koboSpan" id="kobo.92.1">Sometimes, Terraform will only know the results of instructions after executing them. </span><span class="koboSpan" id="kobo.92.2">Hence, the obligatory warning message </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">known after apply</span></strong><span class="koboSpan" id="kobo.94.1">. </span><span class="koboSpan" id="kobo.94.2">However, this dependency graph and the subsequent plan are the crux of the </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">Terraform machine.</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">This process makes Terraform an idempotent tool, meaning it can be applied multiple times without changing the result beyond the initial application. </span><span class="koboSpan" id="kobo.96.2">Idempotence is not necessarily unique to Terraform across automation tools, as some tools operate similarly. </span><strong class="bold"><span class="koboSpan" id="kobo.97.1">Ansible</span></strong><span class="koboSpan" id="kobo.98.1"> is a </span><a id="_idIndexMarker008"/><span class="koboSpan" id="kobo.99.1">great example, also ensuring that repeat operations do not alter the state unless changes </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">are necess</span><a id="_idTextAnchor044"/><span class="koboSpan" id="kobo.101.1">ary.</span></span></p>
<h3><span class="koboSpan" id="kobo.102.1">Execution phases</span></h3>
<p><span class="koboSpan" id="kobo.103.1">Terraform’s</span><a id="_idIndexMarker009"/><span class="koboSpan" id="kobo.104.1"> core workflow follows a three-stage process: </span><em class="italic"><span class="koboSpan" id="kobo.105.1">initialize</span></em><span class="koboSpan" id="kobo.106.1">, </span><em class="italic"><span class="koboSpan" id="kobo.107.1">plan</span></em><span class="koboSpan" id="kobo.108.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">and </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.110.1">apply</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer011">
<span class="koboSpan" id="kobo.112.1"><img alt="Figure 1.5 – Terraform execution phases" src="image/B21183_01_5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.113.1">Figure 1.5 – Terraform execution phases</span></p>
<p><span class="koboSpan" id="kobo.114.1">Let’s </span><a id="_idIndexMarker010"/><span class="koboSpan" id="kobo.115.1">examine each stage to see what parts of our code base are being utilized and what actions Terraform </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">is ta</span><a id="_idTextAnchor045"/><span class="koboSpan" id="kobo.117.1">king.</span></span></p>
<h4><span class="koboSpan" id="kobo.118.1">Initialize</span></h4>
<p><span class="koboSpan" id="kobo.119.1">First, initialize</span><a id="_idIndexMarker011"/><span class="koboSpan" id="kobo.120.1"> the Terraform workspace using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">terraform init</span></strong><span class="koboSpan" id="kobo.122.1"> command, which loads and configures all referenced providers </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">and modules:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer012">
<span class="koboSpan" id="kobo.124.1"><img alt="Figure 1.6 – Terraform initialization loads provider and module dependencies and verifies backend connect﻿ivity" src="image/B21183_01_6.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.125.1">Figure 1.6 – Terraform initialization loads provider and module dependencies and verifies backend connect</span><a id="_idTextAnchor046"/><span class="koboSpan" id="kobo.126.1">ivity</span></p>
<h4><span class="koboSpan" id="kobo.127.1">Plan</span></h4>
<p><span class="koboSpan" id="kobo.128.1">Once a </span><a id="_idIndexMarker012"/><span class="koboSpan" id="kobo.129.1">Terraform has initialized its workspace, it can generate a plan using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">terraform plan</span></strong><span class="koboSpan" id="kobo.131.1"> command. </span><span class="koboSpan" id="kobo.131.2">Although the command seems simple, this is a very </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">complex process.</span></span></p>
<p><span class="koboSpan" id="kobo.133.1">First, a dependency graph is built of all resources using the implicit (and sometimes explicit relationships between them). </span><span class="koboSpan" id="kobo.133.2">Then, Terraform checks the state file to determine if it has already provisioned the resource. </span><span class="koboSpan" id="kobo.133.3">Suppose the resource exists in the state file. </span><span class="koboSpan" id="kobo.133.4">In that case, Terraform will communicate with the resource via its respective provider and compare the desired state with the expected state as stored in the state file and the actual state reported by the provider. </span><span class="koboSpan" id="kobo.133.5">Terraform makes note of any differences and creates an action plan for each resource. </span><span class="koboSpan" id="kobo.133.6">The action can be </span><em class="italic"><span class="koboSpan" id="kobo.134.1">create</span></em><span class="koboSpan" id="kobo.135.1">, </span><em class="italic"><span class="koboSpan" id="kobo.136.1">update</span></em><span class="koboSpan" id="kobo.137.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">or </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.139.1">destroy</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer013">
<span class="koboSpan" id="kobo.141.1"><img alt="Figure 1.7 – terraform plan evaluates the current code base with a set of input variables and compares it against the workspace’s Terraform ﻿state" src="image/B21183_01_7.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.142.1">Figure 1.7 – terraform plan evaluates the current code base with a set of input variables and compares it against the workspace’s Terraform </span><a id="_idTextAnchor047"/><span class="koboSpan" id="kobo.143.1">state</span></p>
<h4><span class="koboSpan" id="kobo.144.1">Apply</span></h4>
<p><span class="koboSpan" id="kobo.145.1">Once a </span><a id="_idIndexMarker013"/><span class="koboSpan" id="kobo.146.1">Terraform has generated a plan, it can optionally execute it against the actual environment using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">terraform apply</span></strong><span class="koboSpan" id="kobo.148.1"> command. </span><span class="koboSpan" id="kobo.148.2">Using the dependency graph, Terraform will execute each resource action in sequence. </span><span class="koboSpan" id="kobo.148.3">If resource actions are not dependent on each other, then Terraform will execute them in parallel. </span><span class="koboSpan" id="kobo.148.4">During this phase, Terraform will constantly communicate with each provider, initiating commands and checking the status of the relevant provider. </span><span class="koboSpan" id="kobo.148.5">As Terraform </span><a id="_idIndexMarker014"/><span class="koboSpan" id="kobo.149.1">completes resource actions, it will continually update the </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">Terraform state:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer014">
<span class="koboSpan" id="kobo.151.1"><img alt="Figure 1.8 – terraform apply executes the plan through communication with the providers, updates the Terraform state, and returns output var﻿iables" src="image/B21183_01_8.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.152.1">Figure 1.8 – terraform apply executes the plan through communication with the providers, updates the Terraform state, and returns output var</span><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.153.1">iables</span></p>
<h3><span class="koboSpan" id="kobo.154.1">Resource actions</span></h3>
<p><span class="koboSpan" id="kobo.155.1">When Terraform</span><a id="_idIndexMarker015"/><span class="koboSpan" id="kobo.156.1"> generates a plan, it evaluates each </span><a id="_idIndexMarker016"/><span class="koboSpan" id="kobo.157.1">resource to determine if change is required to achieve the desired state of the infrastructure. </span><span class="koboSpan" id="kobo.157.2">There are several different situations where Terraform will determine action is needed on a </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">particular r</span><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.159.1">esource.</span></span></p>
<h4><span class="koboSpan" id="kobo.160.1">Create</span></h4>
<p><span class="koboSpan" id="kobo.161.1">A create action</span><a id="_idIndexMarker017"/><span class="koboSpan" id="kobo.162.1"> can occur in </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">three situations:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.164.1">The resource is </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">completely new</span></span></li>
<li><span class="koboSpan" id="kobo.166.1">Something outside of Terraform deleted </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">the resource</span></span></li>
<li><span class="koboSpan" id="kobo.168.1">The developer updated a resource’s code in such a way that the provider requires it to be destroyed </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">and re-created</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.170.1">Here’s what</span><a id="_idIndexMarker018"/><span class="koboSpan" id="kobo.171.1"> adding a new resource </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">looks like:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer015">
<span class="koboSpan" id="kobo.173.1"><img alt="Figure 1.9 – Adding a new resource" src="image/B21183_01_9.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.174.1">Figure 1.9 – Adding a new resource</span></p>
<p><span class="koboSpan" id="kobo.175.1">When a resource is entirely new, it doesn’t exist in the Terraform state file. </span><span class="koboSpan" id="kobo.175.2">For example, we want to create</span><a id="_idIndexMarker019"/><span class="koboSpan" id="kobo.176.1"> a </span><strong class="bold"><span class="koboSpan" id="kobo.177.1">virtual machine</span></strong><span class="koboSpan" id="kobo.178.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.179.1">VM</span></strong><span class="koboSpan" id="kobo.180.1">) named </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">vm001</span></strong><span class="koboSpan" id="kobo.182.1">. </span><span class="koboSpan" id="kobo.182.2">If this is the case, Terraform doesn’t use the provider to check if the resource is there. </span><span class="koboSpan" id="kobo.182.3">As a result, you can run into situations where the plan will generate successfully, but when Terraform executes the plan, it will fail. </span><span class="koboSpan" id="kobo.182.4">This situation usually boils down to resource naming conflicts when another user has provisioned another unrelated resource with the same name as the one Terraform plans to create (that is, somebody has already provisioned a VM named </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">vm001</span></strong><span class="koboSpan" id="kobo.184.1">). </span><span class="koboSpan" id="kobo.184.2">This situation can occur if someone creates a resource manually or even when a resource is created through Terraform but in a different Terraform workspace and, consequently, a different Terraform </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">state file.</span></span></p>
<p><span class="koboSpan" id="kobo.186.1">A prime example of the </span><a id="_idIndexMarker020"/><span class="koboSpan" id="kobo.187.1">concept of </span><strong class="bold"><span class="koboSpan" id="kobo.188.1">drift</span></strong><span class="koboSpan" id="kobo.189.1"> is when someone manually deletes a resource outside </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">of Terraform:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer016">
<span class="koboSpan" id="kobo.191.1"><img alt="Figure 1.10 – Drift" src="image/B21183_01_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.192.1">Figure 1.10 – Drift</span></p>
<p><span class="koboSpan" id="kobo.193.1">When a developer</span><a id="_idIndexMarker021"/><span class="koboSpan" id="kobo.194.1"> changes a resource, sometimes the provider requires it to be destroyed </span><a id="_idIndexMarker022"/><span class="koboSpan" id="kobo.195.1">and then re-created. </span><span class="koboSpan" id="kobo.195.2">For example, we want to change our VM’s hardware profile from 4 CPU cores and 16 GB RAM to 8 CPU cores and 32 GB RAM. </span><span class="koboSpan" id="kobo.195.3">This logic exists in the provider’s code base at the resource level. </span><span class="koboSpan" id="kobo.195.4">It would help if you carefully check the documentation of the resources you are using to ensure you are aware of any potential disruptions or data loss that could occur when updates force a resource to be destroyed </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">and </span><a id="_idTextAnchor050"/><span class="koboSpan" id="kobo.197.1">re-created.</span></span></p>
<h4><span class="koboSpan" id="kobo.198.1">Change</span></h4>
<p><span class="koboSpan" id="kobo.199.1">A</span><a id="_idIndexMarker023"/><span class="koboSpan" id="kobo.200.1"> change action can occur in </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">two situations:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.202.1">The resource has changed </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">in code</span></span></li>
<li><span class="koboSpan" id="kobo.204.1">The resource has been modified outside </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">of Terraform</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.206.1">Here’s what changing an existing resource </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">looks like:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer017">
<span class="koboSpan" id="kobo.208.1"><img alt="Figure 1.11 – Updating an existing resource" src="image/B21183_01_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.209.1">Figure 1.11 – Updating an existing resource</span></p>
<p><span class="koboSpan" id="kobo.210.1">This change won’t require the resource to be destroyed and re-created. </span><span class="koboSpan" id="kobo.210.2">This could be something simple such as changing the tags of a resource. </span><span class="koboSpan" id="kobo.210.3">These types of changes can also be introduced by drift. </span><span class="koboSpan" id="kobo.210.4">For example, someone adds a new tag manually using the cloud platform’s management portal without updating the Terrafor</span><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.211.1">m </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">code base.</span></span></p>
<h4><span class="koboSpan" id="kobo.213.1">Destroy</span></h4>
<p><span class="koboSpan" id="kobo.214.1">A destroy action </span><a id="_idIndexMarker024"/><span class="koboSpan" id="kobo.215.1">can occur in </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">two situations:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.217.1">The developer deleted the resource from </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">the code</span></span></li>
<li><span class="koboSpan" id="kobo.219.1">The developer updated a resource’s code in such a way that the provider requires it to be destroyed </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">and re-created</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.221.1">Here’s what removing an existing resource </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">looks like:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer018">
<span class="koboSpan" id="kobo.223.1"><img alt="Figure 1.12 – Removing an existing resource" src="image/B21183_01_12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.224.1">Figure 1.12 – Removing an existing resource</span></p>
<p><span class="koboSpan" id="kobo.225.1">This could be as simple as removing an unused—or, more likely, no longer used—resource. </span><span class="koboSpan" id="kobo.225.2">For example, removing an</span><a id="_idIndexMarker025"/><span class="koboSpan" id="kobo.226.1"> unnecessary </span><strong class="bold"><span class="koboSpan" id="kobo.227.1">network security group</span></strong><span class="koboSpan" id="kobo.228.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.229.1">NSG</span></strong><span class="koboSpan" id="kobo.230.1">) rule—such as one that grants access to port </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">22</span></strong><span class="koboSpan" id="kobo.232.1"> to the entire internet—is probably a </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">good idea!</span></span></p>
<p><span class="koboSpan" id="kobo.234.1">Resource action plans can have a cascading effect. </span><span class="koboSpan" id="kobo.234.2">Naturally, dependent resources are also new if a resource is entirely new. </span><span class="koboSpan" id="kobo.234.3">However, it would be best to be mindful when the resource needs to be destroyed and re-created. </span><span class="koboSpan" id="kobo.234.4">This action</span><a id="_idIndexMarker026"/><span class="koboSpan" id="kobo.235.1"> is called a </span><strong class="bold"><span class="koboSpan" id="kobo.236.1">drop-create</span></strong><span class="koboSpan" id="kobo.237.1"> action. </span><span class="koboSpan" id="kobo.237.2">When a resource plays a critical role within the environment, it is very common that when a drop-create action occurs, there will be a large swath of the resource graph that will also be destroyed and then re-created—usually, any resource dependent on the resource </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">being</span><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.239.1"> drop-created.</span></span></p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.240.1">Configuration language</span></h2>
<p><span class="koboSpan" id="kobo.241.1">When </span><a id="_idIndexMarker027"/><span class="koboSpan" id="kobo.242.1">Terraform was first only a glimmer in the minds of Armon Dadgar and Mitchell Hashimoto, the industry had two paradigms </span><a id="_idIndexMarker028"/><span class="koboSpan" id="kobo.243.1">of </span><strong class="bold"><span class="koboSpan" id="kobo.244.1">Infrastructure-as-Code</span></strong><span class="koboSpan" id="kobo.245.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.246.1">IaC</span></strong><span class="koboSpan" id="kobo.247.1">): imperative, which dominated under the names of Chef and Puppet, using traditional programming languages such as Ruby and Python. </span><span class="koboSpan" id="kobo.247.2">However, there were declarative approaches, but most were an exercise of crafting large and complex </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">JSON documents.</span></span></p>
<p><span class="koboSpan" id="kobo.249.1">The two major </span><a id="_idIndexMarker029"/><span class="koboSpan" id="kobo.250.1">cloud platforms, </span><strong class="bold"><span class="koboSpan" id="kobo.251.1">Amazon Web Services</span></strong><span class="koboSpan" id="kobo.252.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.253.1">AWS</span></strong><span class="koboSpan" id="kobo.254.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.255.1">Microsoft Azure</span></strong><span class="koboSpan" id="kobo.256.1">, had already adopted resource typing in their respective IaC solutions. </span><span class="koboSpan" id="kobo.256.2">AWS CloudFormation</span><a id="_idIndexMarker030"/><span class="koboSpan" id="kobo.257.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.258.1">Azure Resource Manager</span></strong><span class="koboSpan" id="kobo.259.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.260.1">ARM</span></strong><span class="koboSpan" id="kobo.261.1">) templates</span><a id="_idIndexMarker031"/><span class="koboSpan" id="kobo.262.1"> leveraged a consistent schema to describe resources of various types. </span><span class="koboSpan" id="kobo.262.2">Each resource type had a standard set of attributes that helped the platform target the appropriate resource provider to handle the request. </span><span class="koboSpan" id="kobo.262.3">Likewise, each resource type had its own custom attributes and schema to configure its unique nature. </span><span class="koboSpan" id="kobo.262.4">But the solutions were silos within the respective </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">cloud platforms.</span></span></p>
<p><span class="koboSpan" id="kobo.264.1">So, in </span><a id="_idIndexMarker032"/><span class="koboSpan" id="kobo.265.1">many ways, the industry was primed and ready for a solution that would adopt a resource type-based approach and thus knock down the silos between cloud providers enabling, at the very least, a tool that could describe resources on multiple clouds within the same context. </span><span class="koboSpan" id="kobo.265.2">There were challenges with both imperative and </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">declarative approaches.</span></span></p>
<p><span class="koboSpan" id="kobo.267.1">Imperative approaches resulted in overly complex code, nested structures, and elaborate state-checking logic made for difficult-to-maintain code bases that could quickly descend into spaghetti code. </span><span class="koboSpan" id="kobo.267.2">Also, programming language and platform heritage could stoke religious rivalries between </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">developer camps.</span></span></p>
<p><span class="koboSpan" id="kobo.269.1">The </span><a id="_idIndexMarker033"/><span class="koboSpan" id="kobo.270.1">declarative solutions, on the other hand, relied on industry-standard document formats such as </span><strong class="bold"><span class="koboSpan" id="kobo.271.1">JSON</span></strong><span class="koboSpan" id="kobo.272.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.273.1">YAML</span></strong><span class="koboSpan" id="kobo.274.1">. </span><span class="koboSpan" id="kobo.274.2">These </span><a id="_idIndexMarker034"/><span class="koboSpan" id="kobo.275.1">formats encouraged a simple top-down approach and induced no tribalism due to their neutral nature. </span><span class="koboSpan" id="kobo.275.2">However, they made it difficult to represent complex expressions and implement simple iterations and loops, and even simple things such as annotating code with code comments were not possible or </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">overly cumbersome.</span></span></p>
<p><span class="koboSpan" id="kobo.277.1">Terraform brought the best of both worlds by bringing elements of an imperative language, such as expressions and looping, and fusing it with the best of the declarative model that encouraged a simple top-down approach to defining resources within </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">an environment.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.279.1">HCL</span></strong><span class="koboSpan" id="kobo.280.1"> uses</span><a id="_idIndexMarker035"/><span class="koboSpan" id="kobo.281.1"> simple block definitions that allow for a more concise representation of resources than other declarative solutions but a more code-like syntax, all linking between blocks that acknowledges the resource type-driven nature of cloud computing in </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">its bones:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.283.1">
    resource "random_string" "foo" {
      length  = 4
      upper   = false
      special = false
    }</span></pre> <p><span class="koboSpan" id="kobo.284.1">A block’s definition has </span><a id="_idIndexMarker036"/><span class="koboSpan" id="kobo.285.1">three parts: the </span><strong class="bold"><span class="koboSpan" id="kobo.286.1">block type</span></strong><span class="koboSpan" id="kobo.287.1">, the </span><strong class="bold"><span class="koboSpan" id="kobo.288.1">resource type</span></strong><span class="koboSpan" id="kobo.289.1">, and the </span><strong class="bold"><span class="koboSpan" id="kobo.290.1">reference name</span></strong><span class="koboSpan" id="kobo.291.1">. </span><span class="koboSpan" id="kobo.291.2">In </span><a id="_idIndexMarker037"/><span class="koboSpan" id="kobo.292.1">the preceding example, the block type is </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">resource</span></strong><span class="koboSpan" id="kobo.294.1">, the</span><a id="_idIndexMarker038"/><span class="koboSpan" id="kobo.295.1"> resource type is </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">random_string</span></strong><span class="koboSpan" id="kobo.297.1">, and the reference name is </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">foo</span></strong><span class="koboSpan" id="kobo.299.1">. </span><span class="koboSpan" id="kobo.299.2">To create dependencies between resources, we use the reference name and type to access output values from </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">the resource:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.301.1">
resource "azurerm_resource_group" "bar" {
  name     = "rg-${random_string.foo.result}"
  location = var.location
}</span></pre> <p><span class="koboSpan" id="kobo.302.1">In the</span><a id="_idIndexMarker039"/><span class="koboSpan" id="kobo.303.1"> preceding code, we create an Azure resource group by referencing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">result</span></strong><span class="koboSpan" id="kobo.305.1"> output value from the random string </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">foo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.309.1">This simple pattern describes how we can combine dozens, sometimes hundreds, of resources to build sophisticated </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">cloud architectures:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer019">
<span class="koboSpan" id="kobo.311.1"><img alt="Figure 1.13 – Chaining of Terraform resources, where the outputs of one resource act as inputs to another" src="image/B21183_01_13.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.312.1">Figure 1.13 – Chaining of Terraform resources, where the outputs of one resource act as inputs to another</span></p>
<p><span class="koboSpan" id="kobo.313.1">Using this preceding pattern in HCL allows Terraform to determine the relationships between our resources and construct a plan to provision them all. </span><span class="koboSpan" id="kobo.313.2">The funny part and the sheer brilliance of the whole thing is that it’s just a fancy ga</span><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.314.1">me of connecting </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">the dots.</span></span></p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.316.1">Modularity</span></h2>
<p><span class="koboSpan" id="kobo.317.1">Everything </span><a id="_idIndexMarker040"/><span class="koboSpan" id="kobo.318.1">lives in modules. </span><span class="koboSpan" id="kobo.318.2">When you make your first Terraform project, you inadvertently create your first Terraform module. </span><span class="koboSpan" id="kobo.318.3">That’s because every Terraform project is a root module. </span><span class="koboSpan" id="kobo.318.4">In your root module, you </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">declare providers,</span></span></p>
<p><span class="koboSpan" id="kobo.320.1">One ubiquitous pattern within Terraform is that when you code resources, modules, or data sources, you work with inputs and outputs. </span><span class="koboSpan" id="kobo.320.2">Each Terraform resource and data source works in this manner, as does your entire Terraform workspace, allowing Terraform to be embedded neatly into a toolchain within a pipeline to provision </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">an environment.</span></span></p>
<p><span class="koboSpan" id="kobo.322.1">The root module doesn’t have to be the only module that you write. </span><span class="koboSpan" id="kobo.322.2">You can create reusable modules that are designed to encapsulate reusable aspects of your solutions that can be shared across root modules. </span><span class="koboSpan" id="kobo.322.3">The difference between a root module and a reusable module is that the root module is designed to be the entry point for deploying one or more environments. </span><span class="koboSpan" id="kobo.322.4">Reusable modules are simply components that define useful patterns or best practices and allow you to save time having to re-create them whenever you want to create a new environ</span><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.323.1">ment or a </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">similar solution.</span></span></p>
<p><span class="koboSpan" id="kobo.325.1">Now that we have taken a high-level look at Terraform’s architecture and understand the core technology, we know that it comprises the Terraform command-line application and the HCL functional language. </span><span class="koboSpan" id="kobo.325.2">We also know that Terraform’s superpower is that the design of the core technology is highly extensible by leveraging providers to adapt the technology to a multitude of extremely diverse platforms and technologies and the built-in modularity that enables practitioners to easily create simple or sophisticated IaC solutions that can be packaged and made to be reusable across teams </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">and organizations.</span></span></p>
<p><span class="koboSpan" id="kobo.327.1">Next, we’ll delve into a critical subsystem that enables Terraform to achieve consistent, idempotent IaC motion across various </span><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.328.1">platforms </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">and technologies.</span></span></p>
<h1 id="_idParaDest-22"><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.330.1">Understanding Terraform state</span></h1>
<p><span class="koboSpan" id="kobo.331.1">Terraform </span><a id="_idIndexMarker041"/><span class="koboSpan" id="kobo.332.1">uses the state to remember what was previously provisioned in a given workspace. </span><span class="koboSpan" id="kobo.332.2">Some critics of Terraform, when they compare it to AWS CloudFormation or ARM templates, point out that these technologies don’t rely on this concept of maintaining state in an externalized file. </span><span class="koboSpan" id="kobo.332.3">Of course, this is only true because these tools only support a single target platform and can tightly couple to the proprietary nature in which those platforms maintain state. </span><span class="koboSpan" id="kobo.332.4">However, Terraform—with its flexible plugin architecture—can’t assume anything about the platform and the resources that it provisions to each target platform. </span><span class="koboSpan" id="kobo.332.5">Therefore, Terraform needs to drop to the lowest common denominator and ensure that it knows what it has provisioned before in a uniform and </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">consistent fashion.</span></span></p>
<p><span class="koboSpan" id="kobo.334.1">This approach to maintaining the state provides a couple of benefits. </span><span class="koboSpan" id="kobo.334.2">First, it uniformly records what Terraform has provisioned across platforms that maintain their internal state and those that don’t. </span><span class="koboSpan" id="kobo.334.3">Second, it allows Terraform to define a boundary between managed and </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">unmanaged resources.</span></span></p>
<p><span class="koboSpan" id="kobo.336.1">This problem is the </span><a id="_idIndexMarker042"/><span class="koboSpan" id="kobo.337.1">classic </span><strong class="bold"><span class="koboSpan" id="kobo.338.1">Jurassic Park problem</span></strong><span class="koboSpan" id="kobo.339.1">. </span><span class="koboSpan" id="kobo.339.2">In </span><em class="italic"><span class="koboSpan" id="kobo.340.1">Jurassic Park</span></em><span class="koboSpan" id="kobo.341.1">, they had genetically engineered all these dinosaurs. </span><span class="koboSpan" id="kobo.341.2">They engineered them with population control in mind—so that they couldn’t mate—or so they thought. </span><span class="koboSpan" id="kobo.341.3">In the park, they had all these sophisticated systems to track where all the dinosaurs were and how many of them there were. </span><span class="koboSpan" id="kobo.341.4">However, the big flaw of their design was that they programmed their systems to only look for dinosaurs that they genetically engineered. </span><span class="koboSpan" id="kobo.341.5">So, their system worked flawlessly and showed them where all the dinosaurs they created were. </span><span class="koboSpan" id="kobo.341.6">Wouldn’t you know it? </span><span class="koboSpan" id="kobo.341.7">The number of dinosaurs always matched the number they expected to see. </span><span class="koboSpan" id="kobo.341.8">That’s bad for Jurassic Park because, due to this flaw, they were unaware of a defect in their genetic engineering that allowed the dinosaurs to mate. </span><span class="koboSpan" id="kobo.341.9">Jurassic Park had too many dinosaurs, and things got—well—a little out </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">of hand:</span></span></p>
<p class="IMG---Figure"><span class="koboSpan" id="kobo.343.1">f</span></p>
<div>
<div class="IMG---Figure" id="_idContainer020">
<span class="koboSpan" id="kobo.344.1"><img alt="Figure 1.14 – The Jurassic Park problem" src="image/B21183_01_14.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.345.1">Figure 1.14 – The Jurassic Park problem</span></p>
<p><span class="koboSpan" id="kobo.346.1">Terraform </span><a id="_idIndexMarker043"/><span class="koboSpan" id="kobo.347.1">only looks for resources that it has provisioned. </span><span class="koboSpan" id="kobo.347.2">It can do that because</span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.348.1"> it maintains a state file. </span><span class="koboSpan" id="kobo.348.2">The state file is just like the list of dinosaurs that Jurassic Park thinks it has. </span><span class="koboSpan" id="kobo.348.3">This approach was terrible for Jurassic Park. </span><span class="koboSpan" id="kobo.348.4">But for Terraform, it’s a </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">good thing:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer021">
<span class="koboSpan" id="kobo.350.1"><img alt="Figure 1.15 – Terraform ignores resources provisioned externally, even if those resources draw dependencies on resources provisioned by Terraform" src="image/B21183_01_15.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.351.1">Figure 1.15 – Terraform ignores resources provisioned externally, even if those resources draw dependencies on resources provisioned by Terraform</span></p>
<p><span class="koboSpan" id="kobo.352.1">Why? </span><span class="koboSpan" id="kobo.352.2">Because not all resources are going to be—or need to be—created and managed by Terraform. </span><span class="koboSpan" id="kobo.352.3">By clearly scoping what Terraform is responsible for (and what it’s not), it allows Terraform to be flexible in allowing organizations to choose their level of involvement with Terraform. </span><span class="koboSpan" id="kobo.352.4">Some teams and organizations will start small and only deploy a few things with Terraform. </span><span class="koboSpan" id="kobo.352.5">At the same time, others might go nuts and provision everything with Terraform. </span><span class="koboSpan" id="kobo.352.6">Still, there will very likely be things that are happening that Terraform doesn’t know about. </span><span class="koboSpan" id="kobo.352.7">The Terraform state is constructing guard rails to keep Terraform in its box and let it know what it’s allowed to touch. </span><span class="koboSpan" id="kobo.352.8">Doing so enables Terraform to play well with others and gives freedom to teams and individuals to use whatever method or tools they want to contr</span><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.353.1">ol aspects of </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">an environment.</span></span></p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.355.1">State file</span></h2>
<p><span class="koboSpan" id="kobo.356.1">Terraform state </span><a id="_idIndexMarker045"/><span class="koboSpan" id="kobo.357.1">is a JSON data file stored somewhere Terraform knows how to find it. </span><span class="koboSpan" id="kobo.357.2">This file maintains a list of resources. </span><span class="koboSpan" id="kobo.357.3">Each resource has a resource type identifier and all configurations for </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">that resource.</span></span></p>
<p><span class="koboSpan" id="kobo.359.1">The state file mirrors what we describe in our code but is much more verbose than what we declare in our code. </span><span class="koboSpan" id="kobo.359.2">The following code generates a random string with a length of four characters, no uppercase characters, and no </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">special-case characters:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.361.1">
    resource "random_string" "foo" {
      length  = 4
      upper   = false
      special = false
    }</span></pre> <p><span class="koboSpan" id="kobo.362.1">After running </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">terraform apply</span></strong><span class="koboSpan" id="kobo.364.1">, Terraform will produce a state file containing the same resource but with </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">more context:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.366.1">
    {
      "mode": "managed",
      "type": "random_string",
      "name": "foo",
      "provider":
"provider[\"registry.terraform.io/hashicorp/random\"]",
      "instances": [
        {
          "schema_version": 2,
          "attributes": {
            "id": "vyoi",
            "keepers": null,
            "length": 4,
            "lower": true,
            "min_lower": 0,
            "min_numeric": 0,
            "min_special": 0,
            "min_upper": 0,
            "number": true,
            "numeric": true,
            "override_special": null,
            "result": "vyoi",
            "special": false,
            "upper": false
          },
          "sensitive_attributes": []
        }
      ]
    }</span></pre> <p><span class="koboSpan" id="kobo.367.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">provider</span></strong><span class="koboSpan" id="kobo.369.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">type</span></strong><span class="koboSpan" id="kobo.371.1"> instances help identify which resource type this resource is and which </span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.372.1">Terraform providers the </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">developer uses.</span></span></p>
<p><span class="koboSpan" id="kobo.374.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">schema_version</span></strong><span class="koboSpan" id="kobo.376.1"> parameter of the resource attribute helps identify whether the current resource is compatible with the current version of the provider. </span><span class="koboSpan" id="kobo.376.2">If it is not, it can help give the provider an indicator of how to upgrade it to th</span><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.377.1">e latest version of </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">the schema.</span></span></p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.379.1">Partial resource management</span></h2>
<p><span class="koboSpan" id="kobo.380.1">Due to </span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.381.1">Terraform’s nature as a piece of </span><strong class="bold"><span class="koboSpan" id="kobo.382.1">open source software</span></strong><span class="koboSpan" id="kobo.383.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.384.1">OSS</span></strong><span class="koboSpan" id="kobo.385.1">) and</span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.386.1"> the built-in assumption that these cloud providers are their own piece of software that is evolving over time, at a different pace than the Terraform providers, there will be periods of time where the cloud providers will have features that Terraform is </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">unaware of.</span></span></p>
<p><span class="koboSpan" id="kobo.388.1">When this </span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.389.1">happens, we don’t want Terraform to fight with the cloud provider to turn them off just because Terraform isn’t aware of them. </span><span class="koboSpan" id="kobo.389.2">This scenario is extremely common as it presents itself naturally when an environment is being managed by Terraform and a specific version of the Terraform provider. </span><span class="koboSpan" id="kobo.389.3">As the Terraform provider has new features added to keep pace with the target cloud platform, the provider version is not always kept up to date in the Terraform code—nor should it have </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">to be.</span></span></p>
<p><span class="koboSpan" id="kobo.391.1">Let’s say we provide an environment using Terraform and v1.0, our favorite cloud platform’s Terraform provider. </span><span class="koboSpan" id="kobo.391.2">The next day, our favorite cloud provider added this amazing feature, Feature X. </span><span class="koboSpan" id="kobo.391.3">We still have the same code and the same Terraform state file, but we are extremely eager to try out Feature X. </span><span class="koboSpan" id="kobo.391.4">However, we are using the latest version of the Terraform provider—v1.0—and it has no support for </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">Feature X.</span></span></p>
<p><span class="koboSpan" id="kobo.393.1">What can we do? </span><span class="koboSpan" id="kobo.393.2">Well, we can wait for our friendly internet strangers who contribute to the Terraform provider’s open source project to add support for Feature X. </span><span class="koboSpan" id="kobo.393.3">However, we don’t know when that </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">will be.</span></span></p>
<p><span class="koboSpan" id="kobo.395.1">Did we mention we were extremely eager to try out Feature X? </span><span class="koboSpan" id="kobo.395.2">If we just can’t wait, we could just enable Feature X directly on our favorite cloud platform. </span><em class="italic"><span class="koboSpan" id="kobo.396.1">Wouldn’t this create drift</span></em><span class="koboSpan" id="kobo.397.1">, you say? </span><span class="koboSpan" id="kobo.397.2">In normal circumstances—yes—as we’re modifying our Terraform-managed resource using our favorite cloud platform web interface. </span><span class="koboSpan" id="kobo.397.3">Normally, the next time we run </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">terraform apply</span></strong><span class="koboSpan" id="kobo.399.1">, Terraform will detect that changes have been made to that resource outside the environment and revert our changes. </span><span class="koboSpan" id="kobo.399.2">However, since we are on v1.0 of the Terraform provider, Terraform is happily ignorant of Feature X. </span><span class="koboSpan" id="kobo.399.3">Thus, any changes we make to the configuration of Feature X will go unnoticed by Terraform. </span><span class="koboSpan" id="kobo.399.4">This also means that if you delete that </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">terraform destroy</span></strong><span class="koboSpan" id="kobo.401.1"> resource and re-create it, you’d have to go out to the portal and manually reconfigure Feature X all </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">over again.</span></span></p>
<p><span class="koboSpan" id="kobo.403.1">That is, until we upgraded to v1.1 of the Terraform provider, which was released the day after we manually set up Feature X on our resource. </span><span class="koboSpan" id="kobo.403.2">Now that we are using v1.1 of the Terraform provider, the resource Terraform is using to provision that service to our favorite cloud platform is now aware of Feature X. </span><span class="koboSpan" id="kobo.403.3">If our code is still the same, it’s going to think that Feature X shouldn’t be enabled at all and should </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">remove it.</span></span></p>
<p><span class="koboSpan" id="kobo.405.1">To avoid this, we’ll need to carefully run </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">terraform plan</span></strong><span class="koboSpan" id="kobo.407.1"> with v1.1 of the Terraform provider to see what changes Terraform is planning using this upgraded version of the provider. </span><span class="koboSpan" id="kobo.407.2">Then, we’ll need to update our code to configure Feature X just as it is configured. </span><span class="koboSpan" id="kobo.407.3">Once</span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.408.1"> we do that, Terraform will see that no changes are required, and Terraform will bring Feature X </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">under management:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer022">
<span class="koboSpan" id="kobo.410.1"><img alt="Figure 1.16 – Managing the perpetual change that occurs as a new cloud platform’s capabilities are created, exposed through the Terraform provider and adopted in your Terraform codebase" src="image/B21183_01_16.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.411.1">Figure 1.16 – Managing the perpetual change that occurs as a new cloud platform’s capabilities are created, exposed through the Terraform provider and adopted in your Terraform codebase</span></p>
<p><span class="koboSpan" id="kobo.412.1">Now that we have looked at how Terraform maintains the state and how this aspect of its architecture </span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.413.1">affects how Terraform creates and executes plans, let’s move on to the more practical topic o</span><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.414.1">f developing and </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">consuming modules.</span></span></p>
<h1 id="_idParaDest-25"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.416.1">Understanding how to build and consume modules</span></h1>
<p><span class="koboSpan" id="kobo.417.1">One of Terraform’s most</span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.418.1"> powerful capabilities is its ease of organizing and packaging reusable code, which increases the maintainability of your code base and improves the reusability of common patterns in </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">your architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.420.1">Traditional developers have it easy—you must simply create a new method to encapsulate a reusable code block. </span><span class="koboSpan" id="kobo.420.2">In other IaC tools, doing the same thing is a challenge. </span><span class="koboSpan" id="kobo.420.3">In Terraform, all you need is a </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">new folder.</span></span></p>
<p><span class="koboSpan" id="kobo.422.1">Terraform scopes every module within a folder. </span><span class="koboSpan" id="kobo.422.2">When you run </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">terraform init</span></strong><span class="koboSpan" id="kobo.424.1">, Terraform transforms the current working directory into the root module of the workspace. </span><span class="koboSpan" id="kobo.424.2">You can use modules stored in other folders within the same repository just by using a relative path to reference the module. </span><span class="koboSpan" id="kobo.424.3">It is a standard convention within the Terraform community for </span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.425.1">storing local modules in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">modules</span></strong><span class="koboSpan" id="kobo.427.1"> directory near the root </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">module’s directory.</span></span></p>
<p><span class="koboSpan" id="kobo.429.1">Consider this </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">folder structure:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.431.1">
     /terraform
          /modules
               /rando
          /root</span></pre> <p><span class="koboSpan" id="kobo.432.1">The path to the root module is </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">/terraform/root</span></strong><span class="koboSpan" id="kobo.434.1">. </span><span class="koboSpan" id="kobo.434.2">The path to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">rando</span></strong><span class="koboSpan" id="kobo.436.1"> module </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">/terraform/modules/rando</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.440.1">Consider the contents of the </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">root module:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.442.1">
     main.tf
     outputs.tf
     variables.tf
     versions.tf</span></pre> <p><span class="koboSpan" id="kobo.443.1">The preceding list of files is a typical convention for the file structure of a module. </span><span class="koboSpan" id="kobo.443.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">versions.tf</span></strong><span class="koboSpan" id="kobo.445.1"> file, you should declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">terraform</span></strong><span class="koboSpan" id="kobo.447.1"> block, which contains both the Terraform</span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.448.1"> version and each of the referenced Terraform providers and their </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">corresponding versions.</span></span></p>
<p><span class="koboSpan" id="kobo.450.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">variables.tf</span></strong><span class="koboSpan" id="kobo.452.1"> file, you should declare all the input variables this module expects. </span><span class="koboSpan" id="kobo.452.2">It’s essential to keep all input variables declared in one place to make it easier for the module consumer to understand the contract for </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">this module.</span></span></p>
<p><span class="koboSpan" id="kobo.454.1">Likewise, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">outputs.tf</span></strong><span class="koboSpan" id="kobo.456.1"> file, you should be used to declare all the output values that this module </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">will produce.</span></span></p>
<p><span class="koboSpan" id="kobo.458.1">Since it is possible to declare input variables and outputs in any </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">.tf</span></strong><span class="koboSpan" id="kobo.460.1"> file within the folder, nothing prevents you from following this approach. </span><span class="koboSpan" id="kobo.460.2">However, you don’t want to make other developers scan every file in your module’s folder for a </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">variable</span></strong><span class="koboSpan" id="kobo.462.1"> block to get a good understanding of the </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">module’s interface.</span></span></p>
<p><span class="koboSpan" id="kobo.464.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">main.tf</span></strong><span class="koboSpan" id="kobo.466.1"> file, you should declare the </span><em class="italic"><span class="koboSpan" id="kobo.467.1">meat</span></em><span class="koboSpan" id="kobo.468.1"> of your module. </span><span class="koboSpan" id="kobo.468.2">This file is where the magic happens. </span><span class="koboSpan" id="kobo.468.3">However, you are not limited to just one file. </span><span class="koboSpan" id="kobo.468.4">At your discretion, you can create additional </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">.tf</span></strong><span class="koboSpan" id="kobo.470.1"> files to better organize more complex modules into relevant sections or groupings of </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">related resources.</span></span></p>
<p><span class="koboSpan" id="kobo.472.1">We need to understand the relative path to get to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">rando</span></strong><span class="koboSpan" id="kobo.474.1"> module to reference the </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">rando</span></strong><span class="koboSpan" id="kobo.476.1"> module from the root module. </span><span class="koboSpan" id="kobo.476.2">This relative path is calculated based on the root module’s working directory. </span><span class="koboSpan" id="kobo.476.3">Therefore, a declaration of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">rando</span></strong><span class="koboSpan" id="kobo.478.1"> module would look </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.480.1">
    module "foo" {
      source = "../modules/rando"
    }</span></pre> <p><span class="koboSpan" id="kobo.481.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">source</span></strong><span class="koboSpan" id="kobo.483.1"> meta-argument is a required attribute for every </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">module</span></strong><span class="koboSpan" id="kobo.485.1"> block. </span><span class="koboSpan" id="kobo.485.2">You’ll notice that declaring a module differs slightly from declaring a resource or a data source. </span><span class="koboSpan" id="kobo.485.3">For example, when declaring a module, the resource type is omitted. </span><span class="koboSpan" id="kobo.485.4">That’s because a </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">module</span></strong><span class="koboSpan" id="kobo.487.1"> block is both a block type and a resource type. </span><span class="koboSpan" id="kobo.487.2">Therefore, besides the module block definition, we only need a </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">reference name.</span></span></p>
<p><span class="koboSpan" id="kobo.489.1">We can reference our module’s output values simply by recognizing that </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">module</span></strong><span class="koboSpan" id="kobo.491.1"> is the </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">resource type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.493.1">
    locals {
      dynamic_name = "foo-${module.rando.result}"
    }</span></pre> <p><span class="koboSpan" id="kobo.494.1">As you </span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.495.1">can see in the preceding code, we are referencing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">result</span></strong><span class="koboSpan" id="kobo.497.1"> attribute on a module called </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">foo</span></strong><span class="koboSpan" id="kobo.499.1"> because modules are not as descriptive of a type; therefore, it’s even more important to give more detail in the </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">reference name.</span></span></p>
<p><span class="koboSpan" id="kobo.501.1">Now that we understand the basics for creating and referencing our custom modules, let’s look </span><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.502.1">deeper into the module </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">design question.</span></span></p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.504.1">Module design</span></h2>
<p><span class="koboSpan" id="kobo.505.1">In many ways, the </span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.506.1">decision to create a module in Terraform is the same as deciding to write a new method when writing in a traditional programming language such as Java </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">or C#.</span></span></p>
<p><span class="koboSpan" id="kobo.508.1">Just like in a traditional programming language, you could write all your code from start to finish in a single file using a single method, and if there were repeated parts, you would copy and paste them to </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">repeat them.</span></span></p>
<p><span class="koboSpan" id="kobo.510.1">Just like in a traditional programming language, there are reasons to write methods encapsulating repeating blocks of code. </span><span class="koboSpan" id="kobo.510.2">Otherwise, if you didn’t encapsulate that code into a method, you’d have to copy and paste </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">it repeatedly.</span></span></p>
<p><span class="koboSpan" id="kobo.512.1">The decision about when to create a module versus just putting it in the root module is an important one. </span><span class="koboSpan" id="kobo.512.2">You should have good reasons for creating a module. </span><span class="koboSpan" id="kobo.512.3">You should always focus on value. </span><span class="koboSpan" id="kobo.512.4">When someone uses your module—which could be just yourself or your team—doe</span><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.513.1">s it make their life easier by </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">using it?</span></span></p>
<h3><span class="koboSpan" id="kobo.515.1">Root modules</span></h3>
<p><span class="koboSpan" id="kobo.516.1">There are </span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.517.1">many different ways to set up your root module in Terraform. </span><span class="koboSpan" id="kobo.517.2">The</span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.518.1"> debate continues, with some vehemently advocating one method over the other. </span><span class="koboSpan" id="kobo.518.2">It’s important to be aware of the different approaches so that you can recognize them when you see them and e</span><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.519.1">valuate which approach works best </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">for you.</span></span></p>
<h4><span class="koboSpan" id="kobo.521.1">Folder per environment</span></h4>
<p><span class="koboSpan" id="kobo.522.1">One</span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.523.1"> common technique for structuring a root module is setting up a different folder for each environment you want to provision and maintain. </span><span class="koboSpan" id="kobo.523.2">In this approach, there is a folder for each long-lived environment. </span><span class="koboSpan" id="kobo.523.3">This folder contains a root module that can stand alone from the other environments. </span><span class="koboSpan" id="kobo.523.4">Consider the following </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">folder structure:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.525.1">
     /terraform
          /dev
               main.tf
               versions.tf
               variables.tf
               terraform.tfvars
          /test
               main.tf
               versions.tf
               variables.tf
               terraform.tfvars
          /prod
               main.tf
               versions.tf
               variables.tf
               terraform.tfvars</span></pre> <p><span class="koboSpan" id="kobo.526.1">The preceding folder structure has three environments: </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">dev</span></strong><span class="koboSpan" id="kobo.528.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">test</span></strong><span class="koboSpan" id="kobo.530.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">prod</span></strong><span class="koboSpan" id="kobo.532.1">. </span><span class="koboSpan" id="kobo.532.2">Each environment has its own root module that is completely isolated from other modules. </span><span class="koboSpan" id="kobo.532.3">It has its own </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">required_providers</span></strong><span class="koboSpan" id="kobo.534.1"> block and defines its own provider declarations. </span><span class="koboSpan" id="kobo.534.2">This approach has strong isolation between each environment—so much so that practically every aspect of the deployment could be altered from environment to environment. </span><span class="koboSpan" id="kobo.534.3">The </span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.535.1">version of Terraform, the version of the providers, and the version of the other modules used within the solution, the input parameters, and their values are all customized within the files within the corresponding folder for </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">the environment.</span></span></p>
<p><span class="koboSpan" id="kobo.537.1">This approach is more common where the practitioners aren’t comfortable using GitFlow and maintaining other branches and following a </span><strong class="bold"><span class="koboSpan" id="kobo.538.1">software development life cycle</span></strong><span class="koboSpan" id="kobo.539.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.540.1">SDLC</span></strong><span class="koboSpan" id="kobo.541.1">) where </span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.542.1">infrastructure updates are promoted from less mature-level branches (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">develop</span></strong><span class="koboSpan" id="kobo.544.1">) to more mature branches (for</span><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.545.1"> example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">main</span></strong><span class="koboSpan" id="kobo.547.1">—where production </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">code exists).</span></span></p>
<h4><span class="koboSpan" id="kobo.549.1">Variable file per environment</span></h4>
<p><span class="koboSpan" id="kobo.550.1">Another </span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.551.1">technique is to maintain a single Terraform code base and multiple input variable files for each environment. </span><span class="koboSpan" id="kobo.551.2">This approach is focused on maintaining consistency and compatibility between environments. </span><span class="koboSpan" id="kobo.551.3">It is more difficult with this approach to make massive structural differences between the environments as it becomes difficult to merge changes from branch </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">to branch.</span></span></p>
<p><span class="koboSpan" id="kobo.553.1">Consider the following </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">folder structure:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.555.1">
     /terraform
          /modules
               /solution
                    main.tf
                    versions.tf
                    variables.tf
          /env
               dev.tfvars
               test.tfvars
               prod.tfvars
          main.tf
          versions.tf
          variables.tf
          terraform.tfvars</span></pre> <p><span class="koboSpan" id="kobo.556.1">As </span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.557.1">with the previous approach, where we had explicit folders for each environment, this approach still allows the same variation between environments but requires you to maintain long-lived branches for each environment as you make changes to the core structure of the root module. </span><span class="koboSpan" id="kobo.557.2">This aligns more with a software development process called GitFlow (more on that in </span><a href="B21183_06.xhtml#_idTextAnchor330"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.558.1">Chapter 6</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.559.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.560.1">The key characteristics of this approach are that environmental differences are captured in different input variable values stored in the corresponding</span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">.tfvars</span></strong><span class="koboSpan" id="kobo.562.1"> files. </span><span class="koboSpan" id="kobo.562.2">The goal is that any variation between the environments will eventually be stored within these files, and the code bases for each environment—stored within several long-lived source code branches—will eventually mirror each other. </span><span class="koboSpan" id="kobo.562.3">This allows us to have different sizes and counts in our production environment versus our development environment and maintain consistency between the architecture and </span><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.563.1">configuration deployed across </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">each environment.</span></span></p>
<h3><span class="koboSpan" id="kobo.565.1">Reusable modules</span></h3>
<p><span class="koboSpan" id="kobo.566.1">Now that we</span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.567.1"> have our root module under control, it’s time</span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.568.1"> to start thinking about when to create reusable modules that can be utilized in our root modules to produce sophisticated cloud architecture</span><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.569.1">s that will power our applications </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">and solutions.</span></span></p>
<h4><span class="koboSpan" id="kobo.571.1">Encapsulation of complexity</span></h4>
<p><span class="koboSpan" id="kobo.572.1">The </span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.573.1">number of resources you plan to encapsulate within the module is an important metric, as it can indicate if you are reducing complexity by creating a module or adding more (spoiler alert: adding more is bad). </span><span class="koboSpan" id="kobo.573.2">Modules can range from one resource to dozens—even hundreds—of resources. </span><span class="koboSpan" id="kobo.573.3">When considering the number of resources you put into your module, you should consider the value you bring when someone uses </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">the module.</span></span></p>
<p><span class="koboSpan" id="kobo.575.1">If your module only encapsulates one resource block, your code would likely be simpler by directly referencing the resource. </span><span class="koboSpan" id="kobo.575.2">In this situation, the module adds a layer of abstraction on top of the underlying resource you are provisioning. </span><span class="koboSpan" id="kobo.575.3">If that’s all it’s doing, then you need to reduce the complexity more to justify the creation of </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">a module.</span></span></p>
<p><span class="koboSpan" id="kobo.577.1">Suppose</span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.578.1"> your module encapsulates a few tightly related resources that are highly dependent on each other and have limited integration points with other resources. </span><span class="koboSpan" id="kobo.578.2">For example, when creating an NSG and a collection of rules. </span><span class="koboSpan" id="kobo.578.3">Creating a module encapsulating these tightly coupled resources might be a good idea because it will make it easier and more concise for the developer to create an NSG. </span><span class="koboSpan" id="kobo.578.4">In that case, this is the sweet spot for creating a module. </span><span class="koboSpan" id="kobo.578.5">You are likely trading one or two additional input variables for one or two additional corresponding resource blocks. </span><span class="koboSpan" id="kobo.578.6">That’s a </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">good trade-off:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer023">
<span class="koboSpan" id="kobo.580.1"><img alt="Figure 1.17 – Module design: encapsulation of complexity" src="image/B21183_01_17.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.581.1">Figure 1.17 – Module design: encapsulation of complexity</span></p>
<p><span class="koboSpan" id="kobo.582.1">The preceding diagram shows that this module is provisioning three resource types. </span><span class="koboSpan" id="kobo.582.2">Our module defines a single interface that will provision this cluster of resources. </span><span class="koboSpan" id="kobo.582.3">Some simple inputs, </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">A</span></strong><span class="koboSpan" id="kobo.584.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">B</span></strong><span class="koboSpan" id="kobo.586.1">, are passed to the main resource and child resource 1. </span><span class="koboSpan" id="kobo.586.2">A more complex input object, </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">C</span></strong><span class="koboSpan" id="kobo.588.1">, which happens to be an array, is passed in and used to con</span><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.589.1">struct a resource block for each item in </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">the list.</span></span></p>
<h4><span class="koboSpan" id="kobo.591.1">Repeating patterns</span></h4>
<p><span class="koboSpan" id="kobo.592.1">Another </span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.593.1">common scenario is when you have many resources that you want to be repeated based on the size of a collection (either a list or a map). </span><span class="koboSpan" id="kobo.593.2">In this situation, you should tell each resource how many copies of it you want and pass in all the input variables to satisfy </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">its requirements:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer024">
<span class="koboSpan" id="kobo.595.1"><img alt="Figure 1.18 – Module design: repeating inside the module" src="image/B21183_01_18.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.596.1">Figure 1.18 – Module design: repeating inside the module</span></p>
<p><span class="koboSpan" id="kobo.597.1">However, if you encapsulate the repeating resources into a module, rather than repeating every resource, you repeat the module. </span><span class="koboSpan" id="kobo.597.2">This approach can significantly enhance the readability and maintainability of </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">your code:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer025">
<span class="koboSpan" id="kobo.599.1"><img alt="Figure 1.19 – Module design: repeating outside the module" src="image/B21183_01_19.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.600.1">Figure 1.19 – Module design: repeating outside the module</span></p>
<p><span class="koboSpan" id="kobo.601.1">The outside consumer of the module is responsible for introducing iteration on the module </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">resource itself:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.603.1">
    module "foo" {
      source = "../modules/rando"
      count  = 5
    }</span></pre> <p><span class="koboSpan" id="kobo.604.1">By applying </span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.605.1">the iterator to the module itself, we achieve the same outcome as if we adorn every resource declared in the module with a count and pass in the number of resources as an input variable to the module. </span><span class="koboSpan" id="kobo.605.2">However, working with every resource inside the module becomes </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">more difficult.</span></span></p>
<p><span class="koboSpan" id="kobo.607.1">When you design your module to be repeated by a parent module, your module doesn’t have to think about the complexity of how many resources the parent module wants to create across all items in the collection. </span><span class="koboSpan" id="kobo.607.2">Each module instance only has to worry about one instance of </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">each resource.</span></span></p>
<p><span class="koboSpan" id="kobo.609.1">Does it flatten or simplify the resource in a way that can make the resource easier </span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">to use?</span></span></p>
<p><span class="koboSpan" id="kobo.611.1">If you are starting from scratch, it’s best to let those patterns emerge over time. </span><span class="koboSpan" id="kobo.611.2">The code in the method is, by its very nature, a rather opinionated piece of code. </span><span class="koboSpan" id="kobo.611.3">Once you identify one, all it takes is a destroy, refractor, and re-apply, and you’re using your </span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">new module.</span></span></p>
<p><span class="koboSpan" id="kobo.613.1">Destroying the entire environment and starting over isn’t always an option. </span><span class="koboSpan" id="kobo.613.2">This approach can only be used in a development or testing environment. </span><span class="koboSpan" id="kobo.613.3">In production environments, you will need to take a </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">different approach.</span></span></p>
<p><span class="koboSpan" id="kobo.615.1">Sometimes, you can write a method you can use in many scenarios. </span><span class="koboSpan" id="kobo.615.2">This approach is most common when developing framework code that tackles a horizontal problem space. </span><span class="koboSpan" id="kobo.615.3">But sometimes methods are intended to do very </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">particular things.</span></span></p>
<p><span class="koboSpan" id="kobo.617.1">This same principle applies to Terraform module design. </span><span class="koboSpan" id="kobo.617.2">Some modules are highly flexible and designed in a framework, while others are more like </span><em class="italic"><span class="koboSpan" id="kobo.618.1">Hey, I want to do this specific thing, and I want to keep it simple.</span></em><span class="koboSpan" id="kobo.619.1"> With a scenario-driven module, the interface to the module will be very, very simple because it’s only about shepherding dependency inputs into the module’s scope that the module needs and doesn’t have on its own within </span><span class="No-Break"><span class="koboSpan" id="kobo.620.1">its scope.</span></span></p>
<p><span class="koboSpan" id="kobo.621.1">A framework </span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.622.1">module typically has a much more complex interface; as a result, it will have many more levers that the module consumer can pull. </span><span class="koboSpan" id="kobo.622.2">Sometimes, those inputs are no longer straightforward primitive types (</span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">string</span></strong><span class="koboSpan" id="kobo.624.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">bool</span></strong><span class="koboSpan" id="kobo.626.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">number</span></strong><span class="koboSpan" id="kobo.628.1">); they are complex objects you construct and pass in. </span><span class="koboSpan" id="kobo.628.2">As the number of scenarios your module supports increases, so does the complexity of your module. </span><span class="koboSpan" id="kobo.628.3">You have to pass in a lot more parameters to configure it. </span><span class="koboSpan" id="kobo.628.4">It will become much more tedious and error-prone to pass those complex objects as you may have to implement more object construction logic using </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">local variables.</span></span></p>
<p><span class="koboSpan" id="kobo.630.1">Most Terraform providers have resources that do not require you to construct complex objects to use them. </span><span class="koboSpan" id="kobo.630.2">You will use primitive types, sometimes collection types, and </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">nested blocks.</span></span></p>
<p><span class="koboSpan" id="kobo.632.1">However, when building modules, you do have the ability to create complex objects as input variables. </span><span class="koboSpan" id="kobo.632.2">You should avoid overly complex data structures because of the complexity that it adds. </span><span class="koboSpan" id="kobo.632.3">Frequently, the dependencies between resources are relatively small. </span><span class="koboSpan" id="kobo.632.4">So, if you only need small pathways to connect two objects, why create massive </span><strong class="bold"><span class="koboSpan" id="kobo.633.1">data transfer objects</span></strong><span class="koboSpan" id="kobo.634.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.635.1">DTOs</span></strong><span class="koboSpan" id="kobo.636.1">) to </span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.637.1">pass context from one object to another? </span><span class="koboSpan" id="kobo.637.2">It makes the code easier to understand and easier to maintain. </span><span class="koboSpan" id="kobo.637.3">Future authors and your module consumers will be cursing your name, just like in poorly written </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">traditional software.</span></span></p>
<p><span class="koboSpan" id="kobo.639.1">I’ve seen software where there have been methods where instead of using the correct primitive types such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">bool</span></strong><span class="koboSpan" id="kobo.641.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">number</span></strong><span class="koboSpan" id="kobo.643.1">, everything is a string. </span><span class="koboSpan" id="kobo.643.2">Will that work? </span><span class="koboSpan" id="kobo.643.3">Sure. </span><span class="koboSpan" id="kobo.643.4">But does that make it easy to understand? </span><span class="koboSpan" id="kobo.643.5">Does that inject additional complexity, such as constantly type-casting the input values back and forth between strings into their proper type? </span><span class="koboSpan" id="kobo.643.6">You should use the correct type and simplify </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">the interface.</span></span></p>
<p><span class="koboSpan" id="kobo.645.1">We have to strike a balance between using complex types and having too many input variables on a module because having too many input variables affects cyclomatic complexity, making it difficult to maintain. </span><span class="koboSpan" id="kobo.645.2">However, unlike other languages, working with HCL is challenging when using complex objects. </span><span class="koboSpan" id="kobo.645.3">Developers could be more efficient when constructing and transforming large, complex data types. </span><span class="koboSpan" id="kobo.645.4">HCL is excellent for developers when declaring and associating resour</span><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.646.1">ces by piping output variables into </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">input variables.</span></span></p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.648.1">Consuming modules</span></h2>
<p><span class="koboSpan" id="kobo.649.1">Now we</span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.650.1"> understand the design considerations for when and how to design sound modules, let’s look at how we can consume and manage modules, from small scenario-dr</span><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.651.1">iven modules to strongly versioned </span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">framework modules.</span></span></p>
<h3><span class="koboSpan" id="kobo.653.1">Local modules</span></h3>
<p><span class="koboSpan" id="kobo.654.1">Local modules</span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.655.1"> can maximize code reuse within your Terraform solutions without incurring the overhead of setting up and maintaining a separate </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">module repository.</span></span></p>
<p><span class="koboSpan" id="kobo.657.1">Using local modules for application-specific patterns, such as components or layers within your architecture, can be a great way to organize your Terraform code. </span><span class="koboSpan" id="kobo.657.2">One typical pattern when deploying to the cloud is active-active, multi-region deployments. </span><span class="koboSpan" id="kobo.657.3">In this situation, you should design the module to provision the application to a single region, and then this module should be deployed to a configurable set of regions using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">count</span></strong><span class="koboSpan" id="kobo.659.1"> or </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">for_each</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.661.1"> meta-argument:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer026">
<span class="koboSpan" id="kobo.662.1"><img alt="Figure 1.20 – Using Modules to encapsulate resources provisioned to a single region of a Cloud platform" src="image/B21183_01_20.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.663.1">Figure 1.20 – Using Modules to encapsulate resources provisioned to a single region of a Cloud platform</span></p>
<p><span class="koboSpan" id="kobo.664.1">With this approach, you can create load-balancing resources in the root module to distribute traffic across the regional endpoints, coupled with multiple instances of the regional </span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.665.1">deployment module in the desired number </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">of regions.</span></span></p>
<p><span class="koboSpan" id="kobo.667.1">This consumption approach is ideal when only the module is used within the current project. </span><span class="koboSpan" id="kobo.667.2">This scenario </span><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.668.1">can manifest in layered or </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">multi-region architectures.</span></span></p>
<h3><span class="koboSpan" id="kobo.670.1">Remote repositories</span></h3>
<p><span class="koboSpan" id="kobo.671.1">Using </span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.672.1">external modules is the best way to capitalize on highly reusable patterns within your architecture. </span><span class="koboSpan" id="kobo.672.2">Terraform allows you to reference a module that is not stored in your project’s source code repository. </span><span class="koboSpan" id="kobo.672.3">The most common way of referencing a remote module is via a Git repository. </span><span class="koboSpan" id="kobo.672.4">This method works with any Git-compatible repository, from GitHub to Azure DevOps </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">to GitLab.</span></span></p>
<p><span class="koboSpan" id="kobo.674.1">Publishing your modules publicly on the open internet makes it extremely easy to reference them from any source code repository, whether public or private. </span><span class="koboSpan" id="kobo.674.2">However, in some enterprise scenarios, public repositories are not allowed—corporate governance may only allow private repositories. </span><span class="koboSpan" id="kobo.674.3">In these situations, you must select an authentication mechanism to access those modules as an end user and from within your pipelines. </span><span class="koboSpan" id="kobo.674.4">You can authenticate with your private, remote Terraform module repositories using an SSH key or a public </span><span class="No-Break"><span class="koboSpan" id="kobo.675.1">access token.</span></span></p>
<p><span class="koboSpan" id="kobo.676.1">Once you have secured your authentication to the Git repository that stores your modules, you must reference the module from your </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">source code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.678.1">
    module "foo" {
      source = "git::ssh://git@ssh.dev.azure.com/v3/{AZDO_ORG}/{AZDO_PROJECT}/{AZDO_REPO}//{MODULE_PATH}"
    }</span></pre> <p><span class="koboSpan" id="kobo.679.1">The preceding examples show how you reference a specific module hosted in a Git repository on Azure DevOps. </span><span class="koboSpan" id="kobo.679.2">Using this approach, you will access the default branch for the Git repository, which will most likely be </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">main</span></strong><span class="koboSpan" id="kobo.681.1">, and it will take the latest commit from that branch—never a </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">good idea.</span></span></p>
<p><span class="koboSpan" id="kobo.683.1">The proper way is to specify a reference for a specific module version. </span><span class="koboSpan" id="kobo.683.2">When using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">ref</span></strong><span class="koboSpan" id="kobo.685.1"> query string parameter for your Git repository URL, you can target a specific tag, branch, or commit within the </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">Git repository:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.687.1">
    module "foo" {
      source = "git::ssh://git@ssh.dev.azure.com/v3/{AZDO_ORG}/{AZDO_PROJECT}/{AZDO_REPO}//{MODULE_PATH}?ref={AZDO_TAG}"
    }</span></pre> <p><span class="koboSpan" id="kobo.688.1">Tags are the </span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.689.1">ideal method to guarantee a specific version because creating a tag within a Git repository doesn’t require changing your branching strategy. </span><span class="koboSpan" id="kobo.689.2">Once you are done testing the module, you can push a tag and rest assured that you will always receive that exact version of th</span><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.690.1">e module when you specify that tag as the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">ref</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.692.1"> parameter.</span></span></p>
<h3><span class="koboSpan" id="kobo.693.1">Terraform registry</span></h3>
<p><span class="koboSpan" id="kobo.694.1">HashiCorp </span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.695.1">provides a mechanism for third-party module publishers to distribute their modules. </span><span class="koboSpan" id="kobo.695.2">This repository is accessible via </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">registry.terraform.io</span></strong><span class="koboSpan" id="kobo.697.1"> and houses a tremendous wealth of Terraform modules in a publicly accessible, stable, and versioned environment. </span><span class="koboSpan" id="kobo.697.2">When you publish modules here, you must meet specific requirements to allow you and others to reference the module using a simple name </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">and version:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.699.1">
    module "caf" {
      source  = "aztfmod/caf/azurerm"
      version = "~&gt;5.5.0"
    }</span></pre> <p><span class="koboSpan" id="kobo.700.1">The Terraform module registry ultimately uses GitHub under the hood, so you are referencing a module in a GitHub repository. </span><span class="koboSpan" id="kobo.700.2">However, it allows you to use a simplified module name and version without the additional complexity of the GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">repository’s information.</span></span></p>
<p><span class="koboSpan" id="kobo.702.1">Now that we know how we can use modules to build more manageable IaC solutions and understand that modules can serve different purposes under different contexts, let’s move on to understand the CLI better so that we can build automation around Terraform to </span><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.703.1">integrate it with our release pipeline and </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">CI/CD process.</span></span></p>
<h1 id="_idParaDest-28"><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.705.1">Understanding how to use the CLI effectively</span></h1>
<p><span class="koboSpan" id="kobo.706.1">Now that we</span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.707.1"> understand Terraform’s core architecture, let’s examine its CLI and how to interact with it. </span><span class="koboSpan" id="kobo.707.2">There are many different commands, but we’ll focus on the important ones for implementing the core Terraform workflow. </span><span class="koboSpan" id="kobo.707.3">I’d encourage you to explore HashiCorp’s documentation for some of the more obscure ones, and later in </span><a href="B21183_17.xhtml#_idTextAnchor700"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.708.1">Chapter 17</span></em></span></a><span class="koboSpan" id="kobo.709.1">, when we discuss managing existing environments using Terraform, we</span><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.710.1">’ll be covering some more commands useful in </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">that context.</span></span></p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.712.1">init</span></h2>
<p><span class="koboSpan" id="kobo.713.1">This is an</span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.714.1"> important command and probably the first one you will ever execute when working with Terraform. </span><span class="koboSpan" id="kobo.714.2">The reason is that Terraform works within a working directory instead of other tools that operate on a single file (such as ARM or CloudFormation) or an entry point file (such as Ansible). </span><span class="koboSpan" id="kobo.714.3">Terraform also relies on hidden directories to load important context about the workspace. </span><span class="koboSpan" id="kobo.714.4">This</span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.715.1"> approach is very similar to how Git works when you clone a repository. </span><span class="koboSpan" id="kobo.715.2">Therefore, we must allow Terraform to set things up so that everything it needs is in the right place and makes itself at home. </span><span class="koboSpan" id="kobo.715.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">terraform init</span></strong><span class="koboSpan" id="kobo.717.1"> command does </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">just that:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.719.1">
    terraform init</span></pre> <p><span class="koboSpan" id="kobo.720.1">The Terraform initialize command accomplishes a </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">few things:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.722.1">Prov</span><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.723.1">ider installation</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.724.1">Module installation</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.725.1">Backend initialization</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.726.1">Provider installation</span></h3>
<p><span class="koboSpan" id="kobo.727.1">First, it </span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.728.1">analyzes the directory and searches for provider declarations and downloads and installs those providers. </span><span class="koboSpan" id="kobo.728.2">It doesn’t connect to the providers, so a successful </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">init</span></strong><span class="koboSpan" id="kobo.730.1"> process doesn’t indicate that your provider credentials are good. </span><span class="koboSpan" id="kobo.730.2">It suggests that the providers and specific versions of those providers you specified exist, and it installs them. </span><span class="koboSpan" id="kobo.730.3">As an extension of Terraform, each provider is </span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.731.1">just a Golang executable that Terraform interfaces with. </span><span class="koboSpan" id="kobo.731.2">Therefore, Terraform needs to download and stage that executable somewhere to know where to execute it when the </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">time comes.</span></span></p>
<p><span class="koboSpan" id="kobo.733.1">Each provider’s binary is downloaded and stored in the hidden directories created during the </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">init</span></strong><span class="koboSpan" id="kobo.735.1"> process. </span><span class="koboSpan" id="kobo.735.2">These hidden directories and their contents enable other Terraform operations to function. </span><span class="koboSpan" id="kobo.735.3">Still, they are not files that need special protection, so you should not be too concerned if you delete them accidentally—or on purpose. </span><span class="koboSpan" id="kobo.735.4">To bring them back, one m</span><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.736.1">ust rerun </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">init</span></strong><span class="koboSpan" id="kobo.738.1">, and Terraform will re-generate them </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">as before.</span></span></p>
<h3><span class="koboSpan" id="kobo.740.1">Module installation</span></h3>
<p><span class="koboSpan" id="kobo.741.1">Second, it</span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.742.1"> analyzes the working directory and searches for module declarations within the code base. </span><span class="koboSpan" id="kobo.742.2">It then downloads and installs those modules from their respective source locations. </span><span class="koboSpan" id="kobo.742.3">It doesn’t matter if you reference modules using a relative path or a remote GitHub repository; a local copy of the module folder will be downloaded and stored in the hidden directories that Terraform uses for execution. </span><span class="koboSpan" id="kobo.742.4">As with the provider binaries, these module files must be there for future Terraform operations to succeed. </span><span class="koboSpan" id="kobo.742.5">Again, just like the provider binaries, these files do not require protection as Terraform will also bring them back with a single call to </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">terraform init</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.745.1">If you are developing reusable modules, you are most likely simultaneously using those modules in a root module that you use to test them. </span><span class="koboSpan" id="kobo.745.2">You run </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">terraform init</span></strong><span class="koboSpan" id="kobo.747.1"> on the root module’s folder, and that root module references your reusable module. </span><span class="koboSpan" id="kobo.747.2">It’s important to note that if you change your module, simply rerunning </span><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">init</span></strong><span class="koboSpan" id="kobo.749.1"> will not automatically bring in those updates. </span><span class="koboSpan" id="kobo.749.2">If the version of the module reference has stayed the same, Terraform will check the folder in which it loaded the modules and see that it has already downloaded that module version. </span><span class="koboSpan" id="kobo.749.3">To force it to download a new copy of your modules, you will need to either increment the version of the module (which can be tedious during module development) or manually cl</span><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.750.1">ear the modules by deleting them from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">terraform</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.753.1"> directory.</span></span></p>
<h3><span class="koboSpan" id="kobo.754.1">Backend initialization</span></h3>
<p><span class="koboSpan" id="kobo.755.1">Lastly, Terraform </span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.756.1">will look for a </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">backend</span></strong><span class="koboSpan" id="kobo.758.1"> block within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">terraform</span></strong><span class="koboSpan" id="kobo.760.1"> block of your working directory’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">.tf</span></strong><span class="koboSpan" id="kobo.762.1"> files. </span><span class="koboSpan" id="kobo.762.2">Most backends require some configuration settings to work. </span><span class="koboSpan" id="kobo.762.3">Ultimately, a Terraform backend provides a location for the Terraform state file, so these configuration settings guide the Terraform backend on how to get to the Terraform </span><span class="No-Break"><span class="koboSpan" id="kobo.763.1">state file.</span></span></p>
<p><span class="koboSpan" id="kobo.764.1">For example, to use the ARM backend, you must specify a way to triangulate to the correct Azure Blob Storage account container state file. </span><span class="koboSpan" id="kobo.764.2">Terraform will pass several landmarks along the way on the journey that Terraform takes to get to the location of the desired state file: first, the resource group where the storage account lives, then the storage account where the storage container lives, then the storage container where the state file lives, and finally, the name of the state file, which Terraform locates using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">key</span></strong><span class="koboSpan" id="kobo.766.1"> value and the current Terraform </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">workspace name.</span></span></p>
<p><span class="koboSpan" id="kobo.768.1">A fully populated Terraform backend configuration for Azure would use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">key</span></strong><span class="koboSpan" id="kobo.770.1"> value and the current Terraform </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">workspace name.</span></span></p>
<p><span class="koboSpan" id="kobo.772.1">A fully populated Terraform backend configuration for Azure would look </span><span class="No-Break"><span class="koboSpan" id="kobo.773.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.774.1">
    terraform {
      backend "azurerm" {
        resource_group_name  = "rg-foo"
        storage_account_name = "stfoo"
        container_name       = "tfstate"
        key                  = "foo.tfstate"
      }
    }</span></pre> <p><span class="koboSpan" id="kobo.775.1">The Azure backend will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">resource_group_name</span></strong><span class="koboSpan" id="kobo.777.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">storage_account_name</span></strong><span class="koboSpan" id="kobo.779.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">container_name</span></strong><span class="koboSpan" id="kobo.781.1"> to get to the place on Azure where files are stored. </span><span class="koboSpan" id="kobo.781.2">Then, </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">key</span></strong><span class="koboSpan" id="kobo.783.1"> and the workspace name are used to formulate the name of the state file. </span><span class="koboSpan" id="kobo.783.2">If you are using the default workspace, then the name of the state file will be the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">key</span></strong><span class="koboSpan" id="kobo.785.1">. </span><span class="koboSpan" id="kobo.785.2">However, if you use a named workspace, the Azure backend will generate a state file name that looks like </span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">foo.tfstate:env:prod</span></strong><span class="koboSpan" id="kobo.787.1"> for a workspace </span><span class="No-Break"><span class="koboSpan" id="kobo.788.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.789.1">prod</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.790.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.791.1">Each Terraform backend plugin will have a different strategy for reading and writing state files and its logic for generating the state filename where the state is ultimately stored. </span><span class="koboSpan" id="kobo.791.2">Getting to know your provid</span><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.792.1">er, the available backend, and how to configure it </span><span class="No-Break"><span class="koboSpan" id="kobo.793.1">is essential.</span></span></p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.794.1">validate</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">terraform validate</span></strong><span class="koboSpan" id="kobo.796.1"> is a</span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.797.1"> helpful method that is essentially the closest thing to a compiler. </span><span class="koboSpan" id="kobo.797.2">It analyzes all code files within the scope and verifies references and syntax. </span><span class="koboSpan" id="kobo.797.3">If there are any broken references to data sources or resources, running this command will help you find them without having to initialize</span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.798.1"> your backend. </span><span class="koboSpan" id="kobo.798.2">As a result, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">validate</span></strong><span class="koboSpan" id="kobo.800.1"> command is a helpful command to execute as an early warning to det</span><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.801.1">ect any problems with your code before you move on to </span><span class="No-Break"><span class="koboSpan" id="kobo.802.1">other steps.</span></span></p>
<h2 id="_idParaDest-31"><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.803.1">workspace</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.804.1">terraform workspace</span></strong><span class="koboSpan" id="kobo.805.1"> is </span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.806.1">about creating forks of the same Terraform solution to have different instances or forks of the Terraform state. </span><span class="koboSpan" id="kobo.806.2">Just </span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.807.1">like in source code, when you create a fork, the idea is that you will modify the code, and those modifications will remain long-term. </span><span class="koboSpan" id="kobo.807.2">Therefore, you may never merge the newly forked code base into the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.808.1">main</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.809.1"> branch.</span></span></p>
<p><span class="koboSpan" id="kobo.810.1">Whether you realize it or not, you are using Terraform workspaces. </span><span class="koboSpan" id="kobo.810.2">You just aren’t using a custom-named workspace. </span><span class="koboSpan" id="kobo.810.3">You can find this out by running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.811.1">terraform workspace show</span></strong><span class="koboSpan" id="kobo.812.1"> command, which will </span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">say </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">default</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.815.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.816.1">Creating a new workspace for each long-lived environment is a good idea—even if you plan on segmenting </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">your backend.</span></span></p>
<p><span class="koboSpan" id="kobo.818.1">Running </span><strong class="source-inline"><span class="koboSpan" id="kobo.819.1">terraform workspace new dev</span></strong><span class="koboSpan" id="kobo.820.1"> will create a new workspace for your development environment. </span><span class="koboSpan" id="kobo.820.2">You can run the same command for your production environment, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.821.1">terraform workspace new prod</span></strong><span class="koboSpan" id="kobo.822.1">. </span><span class="koboSpan" id="kobo.822.2">From then on, any Terraform operation that utilizes the state will use the state file for the selected workspace. </span><span class="koboSpan" id="kobo.822.3">You can change back and forth between these state files by changing the workspace like this: </span><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">terraform workspace select dev</span></strong><span class="koboSpan" id="kobo.824.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">terraform workspace </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">select prod</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.827.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.828.1">With workspaces, you might create a workspace to test something out with the intent of eventually making those same updates in the </span><span class="No-Break"><span class="koboSpan" id="kobo.829.1">original workspace.</span></span></p>
<p><span class="koboSpan" id="kobo.830.1">Workspaces represent utterly different environments because the dev environment will always differ slightly from the test, staging, or production environments. </span><span class="koboSpan" id="kobo.830.2">These environments </span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.831.1">will live in isolated workspaces and have the same isolation within their </span><span class="No-Break"><span class="koboSpan" id="kobo.832.1">state file.</span></span></p>
<p><span class="koboSpan" id="kobo.833.1">The common thread is that the workspaces work off the same code base. </span><span class="koboSpan" id="kobo.833.2">The idea is that you will have the same code base and deploy multiple environments with it—most likely long-lived environments, but not </span><span class="No-Break"><span class="koboSpan" id="kobo.834.1">necessarily so.</span></span></p>
<h2 id="_idParaDest-32"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.835.1">plan</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">terraform plan</span></strong><span class="koboSpan" id="kobo.837.1"> is a</span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.838.1"> read-only operation that requires access to</span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.839.1"> your backend state and requires you to have executed </span><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">terraform init</span></strong><span class="koboSpan" id="kobo.841.1"> prior. </span><span class="koboSpan" id="kobo.841.2">Also, if you use a non-default workspace, you should select your workspace before you run </span><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">plan</span></strong><span class="koboSpan" id="kobo.843.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">terraform workspace select</span></strong><span class="koboSpan" id="kobo.845.1"> allows you to </span><span class="No-Break"><span class="koboSpan" id="kobo.846.1">do that.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">terraform plan</span></strong><span class="koboSpan" id="kobo.848.1"> will perform a read-only operation, checking the state file and checking in with every resource in the state file. </span><span class="koboSpan" id="kobo.848.2">This process can take a while, depending on how many resources are in your state file and how long it takes for the provider to get a response from whoever it’s talking to. </span><span class="koboSpan" id="kobo.848.3">So, to keep your Terraform projects lean and fast, consider how much scope you want to keep within a single </span><span class="No-Break"><span class="koboSpan" id="kobo.849.1">Terraform workspace.</span></span></p>
<p><span class="koboSpan" id="kobo.850.1">You may consider splitting those chunks into sub-workspaces if it’s too big. </span><span class="koboSpan" id="kobo.850.2">I’ve seen projects where an entire solution is in one Terraform state file, and it takes 45 minutes to run a plan. </span><span class="koboSpan" id="kobo.850.3">Having too broad workspace isolation can be extremely painful, and I would highly advise you to consider the boundaries of the components of your system and organize your Terraform workspaces so that you have smaller, semi-dependent workspaces. </span><span class="koboSpan" id="kobo.850.4">It’s okay to have dependencies between workspaces. </span><span class="koboSpan" id="kobo.850.5">Still, you need to call out those dependencies using data sources so that you don’t get into a situation where you can make a circular reference between two </span><span class="No-Break"><span class="koboSpan" id="kobo.851.1">Terraform workspaces.</span></span></p>
<p><span class="koboSpan" id="kobo.852.1">Terraform needs you to set all your input variables before you can run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">plan</span></strong><span class="koboSpan" id="kobo.854.1"> operation. </span><span class="koboSpan" id="kobo.854.2">You can do this in three ways: through an individual command-line argument, a variable file, and </span><span class="No-Break"><span class="koboSpan" id="kobo.855.1">environment variables.</span></span></p>
<p><span class="koboSpan" id="kobo.856.1">An </span><strong class="bold"><span class="koboSpan" id="kobo.857.1">individual command-line argument</span></strong><span class="koboSpan" id="kobo.858.1"> is </span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.859.1">helpful for small projects with interactive command-line sessions. </span><span class="koboSpan" id="kobo.859.2">Still, it quickly becomes unmanageable when the environment grows more complex or you want to use a pipeline tool—a scenario on which we will spend the bulk of </span><span class="No-Break"><span class="koboSpan" id="kobo.860.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.861.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.862.1">environment variable</span></strong><span class="koboSpan" id="kobo.863.1"> approach</span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.864.1"> is instrumental in the pipeline tool approach because it allows you to execute Terraform commands without modifying the arguments to the command </span><span class="No-Break"><span class="koboSpan" id="kobo.865.1">you run.</span></span></p>
<h2 id="_idParaDest-33"><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.866.1">apply</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">terraform apply</span></strong><span class="koboSpan" id="kobo.868.1"> is the </span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.869.1">most crucial operation in the arsenal. </span><span class="koboSpan" id="kobo.869.2">Before execution, this command requires </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">terraform init</span></strong><span class="koboSpan" id="kobo.871.1"> to have been </span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.872.1">executed successfully. </span><span class="koboSpan" id="kobo.872.2">Selecting the correct workspace corresponding to the input parameters you specify will also </span><span class="No-Break"><span class="koboSpan" id="kobo.873.1">be essential.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">terraform apply</span></strong><span class="koboSpan" id="kobo.875.1"> is also unique compared to other operations: you can execute it by pointing at a single file rather than a working directory. </span><span class="koboSpan" id="kobo.875.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">terraform plan</span></strong><span class="koboSpan" id="kobo.877.1"> command outputs the plan file. </span><span class="koboSpan" id="kobo.877.2">If a plan file is not specified, </span><strong class="source-inline"><span class="koboSpan" id="kobo.878.1">terraform apply</span></strong><span class="koboSpan" id="kobo.879.1"> will execute a plan before the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">apply</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.881.1"> stage.</span></span></p>
<p><span class="koboSpan" id="kobo.882.1">It is best practice to execute </span><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">apply</span></strong><span class="koboSpan" id="kobo.884.1"> by always passing in a plan file. </span><span class="koboSpan" id="kobo.884.2">Doing so will ensure that you don’t have any surprises when you execute. </span><span class="koboSpan" id="kobo.884.3">However, there is still a chance that something changed in the environment between when you last ran </span><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">plan</span></strong><span class="koboSpan" id="kobo.886.1"> and when you finally </span><span class="No-Break"><span class="koboSpan" id="kobo.887.1">executed </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.888.1">apply</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.889.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.890.1">This is particularly important when working on a team of multiple people that might be introducing change to the environment, either using Terraform locally or through a CI/CD pipeline. </span><span class="koboSpan" id="kobo.890.2">Changes could also be introduced outside of Terraform through manual changes within the cloud platform’s management portal. </span><span class="koboSpan" id="kobo.890.3">Using a Terraform plan file when you run </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">terraform apply</span></strong><span class="koboSpan" id="kobo.892.1"> will help keep the plan you execute exactly how you intended with the best information available at the time </span><span class="No-Break"><span class="koboSpan" id="kobo.893.1">of provisioning.</span></span></p>
<p><span class="koboSpan" id="kobo.894.1">As with </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">plan</span></strong><span class="koboSpan" id="kobo.896.1">, input variables can set their values in </span><span class="No-Break"><span class="koboSpan" id="kobo.897.1">many ways.</span></span></p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.898.1">destroy</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">terraform destroy</span></strong><span class="koboSpan" id="kobo.900.1"> is </span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.901.1">how you can completely </span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.902.1">eradicate your entire environment. </span><span class="koboSpan" id="kobo.902.2">The ability to do so is advantageous when your solution spans multipl</span><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.903.1">e logical groups within the target platform or when using </span><span class="No-Break"><span class="koboSpan" id="kobo.904.1">multiple providers.</span></span></p>
<h3><span class="koboSpan" id="kobo.905.1">Logical container deletion</span></h3>
<p><span class="koboSpan" id="kobo.906.1">Some </span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.907.1">platforms make it easy to manage the life cycle of related resources. </span><span class="koboSpan" id="kobo.907.2">For example, Microsoft Azure resources every resource to be provisioned within a resource group, and on </span><strong class="bold"><span class="koboSpan" id="kobo.908.1">Google Cloud Platform</span></strong><span class="koboSpan" id="kobo.909.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.910.1">GCP</span></strong><span class="koboSpan" id="kobo.911.1">), every </span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.912.1">resource is provisioned within the context of a project. </span><span class="koboSpan" id="kobo.912.2">The Azure resource group and Google Cloud project are logical containers you can use to clean up after yourself quickly with a cascading delete operation. </span><span class="koboSpan" id="kobo.912.3">Platforms that lack this feature can make it extremely tedious to clean up after yourself, such as in AWS, where you must navigate to many different portal pages to ensure you delete everything. </span><span class="koboSpan" id="kobo.912.4">Savvy command-line power users can string together their clean-up scripts using a well-planned tagging scheme. </span><span class="koboSpan" id="kobo.912.5">Still, tools such as Terraform add a lot of value in </span><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.913.1">just being able to delete every resource you provisioned with a </span><span class="No-Break"><span class="koboSpan" id="kobo.914.1">single command.</span></span></p>
<h3><span class="koboSpan" id="kobo.915.1">Cross-platform deletion</span></h3>
<p><span class="koboSpan" id="kobo.916.1">Even on</span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.917.1"> cloud platforms with logical containers, to collectively manage the life cycle of related resources, you still need help </span><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.918.1">with associated resources that you provision in tangential systems </span><span class="No-Break"><span class="koboSpan" id="kobo.919.1">or platforms.</span></span></p>
<h1 id="_idParaDest-35"><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.920.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.921.1">In this chapter, we took an in-depth look at Terraform’s architecture. </span><span class="koboSpan" id="kobo.921.2">We primarily focused on two critical architectural components: state and modularity. </span><span class="koboSpan" id="kobo.921.3">Having a sound understanding of Terraform’s architecture is vital for you to be able to use Terraform to its fullest effectively. </span><span class="koboSpan" id="kobo.921.4">Finally, we ended by looking at Terraform’s CLI, which will enable you to, when you’re ready, integrate Terraform with your own CI/CD pipelines. </span><span class="koboSpan" id="kobo.921.5">In the next chapter, we will explore HCL so that we can lay the foundation on which we can start building IaC </span><span class="No-Break"><span class="koboSpan" id="kobo.922.1">using Terraform.</span></span></p>
</div>
</body></html>