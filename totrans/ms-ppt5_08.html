<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Extending Puppet with Tasks and Discovery</h1>
                </header>
            
            <article>
                
<p class="mce-root">Since the launch of Puppet 5, three new services have been announced by Puppet: Tasks, Discovery, and Pipelines. Puppet Tasks provides us an imperative solution for automating ad hoc tasks. Puppet Discovery allows us to discover the state of infrastructure. Puppet Pipelines, which will be discussed briefly in the next chapter, covers application-level CI/CD.</p>
<p>In this chapter, we'll investigate and use Puppet Tasks to help manage a web server. We'll walk through some best practices and appropriate times for using Puppet Tasks. We'll then dive into Puppet Discovery and inspect our infrastructure. We'll use Puppet Discovery to make intelligent decisions on what to automate in our infrastructure.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Puppet Tasks</h1>
                </header>
            
            <article>
                
<p>Puppet is designed to provide continual enforcement of an end-state on nodes in an infrastructure. While Puppet can cover most infrastructure tasks, some things are better left to ad hoc tasks. Puppet Tasks are on-demand actions that can be run on nodes and containers. You write tasks in a similar way to scripts, and they can be written in any language that's available on the target node.  When deciding on the right tool for the job, between a task or a Puppet manifest, I stick to a simple thought process: is this something I want permanently, or a single one-off action? </p>
<p>Let's think about some things in a normal workplace that would be permanent, or stateful. The physical address of where I work and the building, rooms, and furniture are examples of physical things I'd want permanently enforced. Things like weekly meetings or the daily scrum would also be something to continually enforce, as a business rule. All of these things have components, from the brick and mortar to the time and place of the weekly scrum. If we could manage the real world with our IT tools, Puppet would be the perfect tool to describe our office and business rules, which we expect to stay constant. </p>
<p>In the same context, an impromptu meeting or after-work function would consist of a series of tasks, performed once, but mostly in the same manner every time (with variables). If a customer orders something, we'd use a task to deliver the request. If the request was custom, we'd instead use a series of tasks to build the composite whole. These are the things we do consistently, but with variations and at unknown points in time. An external event or person drives the creation of this work, but we try to repeat things in an automated way to save time and increase consistency.</p>
<p class="mce-root">The chief difference between Tasks and Puppet for management is imperative and declarative models. In this section, we'll be setting up Bolt (the technology that powers tasks), building a web server with Puppet, and then deploying our websites on demand with Bolt.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bolt</h1>
                </header>
            
            <article>
                
<p>Bolt is the primary driver for Puppet Tasks, and is an open source project written in Ruby for remotely executing scripts of any language, on systems over SSH and WinRM. You can write your tasks in any language supported by the end host, such as PowerShell and Bash on Windows and Linux, or Ruby and Python if interpreters are available. Bolt was designed as an agentless system to distribute scripts and execute remote commands over standard protocols, using SSH public key encryption or a username and password. There is also a built-in command-line tool for building inventory files over PuppetDB queries. Bolt also supports task plans, packaged in forge modules, which chain multiple tasks together, providing more complex tasks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing Bolt</h1>
                </header>
            
            <article>
                
<p>Bolt can be installed via a number of methods, all described at <a href="https://puppet.com/docs/bolt/0.x/bolt_installing.html">https://puppet.com/docs/bolt/0.x/bolt_installing.html</a>:</p>
<ul>
<li>A downloadable package from <a href="http://downloads.puppet.com/">http://downloads.puppet.com/</a></li>
<li>A public Chocolatey package</li>
<li>OSX Homebrew installation</li>
<li>Linux native package repositories</li>
<li>Rubygems</li>
</ul>
<div class="packt_tip"><span>Bolt works remotely over standard connection protocols. Try installing it and using it on your workstation, instead of the Puppet Master, during this lesson.</span></div>
<p>On my MacBook, I'll install Bolt using Homebrew:</p>
<pre><strong>rary at Ryans-MacBook-Pro in ~/workspace/packt</strong><br/><strong>$ brew cask install puppetlabs/puppet/puppet-bolt</strong><br/><strong>==&gt; Tapping puppetlabs/puppet</strong><br/><strong>Cloning into '/usr/local/Homebrew/Library/Taps/puppetlabs/homebrew-puppet'...</strong><br/><strong>remote: Counting objects: 15, done.</strong><br/><strong>remote: Compressing objects: 100% (14/14), done.</strong><br/><strong>remote: Total 15 (delta 1), reused 8 (delta 1), pack-reused 0</strong><br/><strong>Unpacking objects: 100% (15/15), done.</strong><br/><strong>Tapped 3 casks (49 files, 54.9KB).</strong><br/><strong>==&gt; Satisfying dependencies</strong><br/><strong>==&gt; Downloading https://downloads.puppet.com/mac/puppet5/10.13/x86_64/puppet-bolt-0.22.0-1.osx10.13.dmg</strong><br/><strong>######################################################################## 100.0%</strong><br/><strong>==&gt; Verifying SHA-256 checksum for Cask 'puppet-bolt'.</strong><br/><strong>==&gt; Installing Cask puppet-bolt</strong><br/><strong>==&gt; Running installer for puppet-bolt; your password may be necessary.</strong><br/><strong>==&gt; Package installers may write to any location; options such as --appdir are ignored.</strong><br/><strong>Password:</strong><br/><strong>installer: Package name is puppet-bolt</strong><br/><strong>installer: Installing at base path /</strong><br/><strong>installer: The install was successful.</strong><br/><strong>puppet-bolt was successfully installed!</strong></pre>
<p>I'll then close my Terminal, and reopen it and verify that the <kbd>bolt</kbd> command is in my path:</p>
<pre><strong>$ bolt</strong><br/><strong>Usage: bolt &lt;subcommand&gt; &lt;action&gt; [options]</strong><br/><br/><strong>Available subcommands:</strong><br/><strong>  bolt command run &lt;command&gt; Run a command remotely</strong><br/><strong>  bolt file upload &lt;src&gt; &lt;dest&gt; Upload a local file</strong><br/><strong>  bolt script run &lt;script&gt; Upload a local script and run it remotely</strong><br/><strong>  bolt task show Show list of available tasks</strong><br/><strong>  bolt task show &lt;task&gt; Show documentation for task</strong><br/><strong>  bolt task run &lt;task&gt; [params] Run a Puppet task</strong><br/><strong>  bolt plan show Show list of available plans</strong><br/><strong>  bolt plan show &lt;plan&gt; Show details for plan</strong><br/><strong>  bolt plan run &lt;plan&gt; [params] Run a Puppet task plan</strong><br/><strong>  bolt puppetfile install Install modules from a Puppetfile into a Boltdir</strong><br/><br/><strong>Run `bolt &lt;subcommand&gt; --help` to view specific examples.</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing nodes</h1>
                </header>
            
            <article>
                
<p>In Bolt, we have to explicitly list the nodes that we want to manage. We can do this via the <kbd>--nodes</kbd> command flag, or by providing an inventory file. An inventory file is a YAML file that contains groups of nodes, with configuration options already set. By default, an <kbd>inventory</kbd> file placed at <kbd>~/.puppetlabs/bolt/inventory.yaml</kbd> will be used by Bolt. For this section, we'll only be targeting our Puppet Master, so I'll ensure that it is in the <kbd>inventory</kbd> file:</p>
<pre><strong># <span>~/.puppetlabs/bolt/inventory.yaml</span></strong><br/><strong>---</strong><br/><strong>groups:</strong><br/><strong>  - name: puppetserver</strong><br/><strong>    nodes:</strong><br/><strong>    - pe-puppet-master.puppet.net</strong><br/><strong>    config:</strong><br/><strong>      transport: ssh</strong><br/><strong>      ssh:</strong><br/><strong>        user: root</strong></pre>
<p>Before I can run Bolt to that server, I'm going to need to ensure that my SSH key is available as the root user on that system. I'll use the <kbd>ssh-copy-id</kbd> utility to transfer this from my UNIX-based system to the root user:</p>
<pre><strong>rary at Ryans-MacBook in ~/workspace/packt</strong><br/><strong>$ ssh-copy-id root@pe-puppet-master.puppet.net</strong><br/><br/><strong>/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed</strong><br/><strong>/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys</strong><br/><strong>root@pe-puppet-master.puppet.net's password:</strong><br/><br/><strong>Number of key(s) added: 1</strong><br/><br/><strong>Now try logging into the machine, with: "ssh 'root@pe-puppet-master.puppet.net'"</strong><br/><strong>and check to make sure that only the key(s) you wanted were added.</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ad hoc commands</h1>
                </header>
            
            <article>
                
<p>At the very basic core of Puppet Bolt, we issue remote commands, send scripts, and run scripts. Bolt provides three simple commands to do just that: <kbd>bolt command run</kbd>, <kbd>bolt file upload</kbd>, and <kbd>bolt script run</kbd>. To test our SSH key from earlier, let's run a simple command using <kbd>bolt command run</kbd>:</p>
<pre><strong>rary at Ryans-MacBook-Pro-3 in ~/workspace/packt/bolt</strong><br/><strong>$ bolt command run "echo 'Hello World'" --nodes puppetserver --no-host-key-check</strong><br/><strong>Started on puppetserver.puppet.net...</strong><br/><strong>Finished on puppetserver.puppet.net:</strong><br/><strong>  STDOUT:</strong><br/><strong>    Hello World</strong><br/><strong>Successful on 1 node: pe-puppet-master.puppet.net</strong><br/><strong>Ran on 1 node in 0.40 seconds</strong></pre>
<p>For simple one-off tasks, running the <kbd>bolt</kbd> command can be a great way to inspect a system. When we have a larger list of instructions to send, we'll want to write a script and run it remotely. Here is a simple script that returns users and all open ports:</p>
<pre><strong>#./inspect.sh</strong><br/><br/><strong>#!/bin/bash</strong><br/><br/><strong>echo 'Users:'</strong><br/><strong>cat /etc/passwd | cut -f 1 -d ':'</strong><br/><strong>echo 'Ports:'</strong><br/><strong>netstat -tulpn</strong></pre>
<p>When we run this script via <kbd>bolt script run</kbd>, we get the following:</p>
<pre><strong>$ bolt script run inspect.sh --nodes puppetserver --no-host-key-check</strong><br/><strong>Started on puppetserver.puppet.net...</strong><br/><strong>Finished on puppetserver.puppet.net:</strong><br/><strong>  STDOUT:</strong><br/><strong>    Users:</strong><br/><strong>    root</strong><br/><strong>    ...</strong><br/><strong>    vboxadd</strong><br/><strong>    vagrant</strong><br/><strong>    Ports:</strong><br/><strong>    Active Internet connections (only servers)</strong><br/><strong>    Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name</strong><br/><strong>    tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1258/sshd</strong><br/><strong>    ...</strong><br/><strong>Successful on 1 node: puppetserver.puppet.net</strong><br/><strong>Ran on 1 node in 0.85 seconds</strong></pre>
<p>Finally, if I wanted to make this script available on the Puppet Server for a local user, I could send it over with <kbd>bolt script upload</kbd>:</p>
<pre><strong>rary at Ryans-MacBook in ~/workspace/packt/bolt</strong><br/><strong>$ bolt file upload inspect.sh /tmp/inspect.sh --nodes puppetserver --no-host-key-check</strong><br/><strong>Started on puppetserver.puppet.net...</strong><br/><strong>Finished on puppetserver.puppet.net:</strong><br/><strong>  Uploaded 'inspect.sh' to 'puppetserver.puppet.net:/tmp/inspect.sh'</strong><br/><strong>Successful on 1 node: puppetserver.puppet.net</strong><br/><strong>Ran on 1 node in 0.66 seconds</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bolt tasks</h1>
                </header>
            
            <article>
                
<p>Bolt tasks allow us to write and extend a script with additional metadata parameters. These parameters can be provided on execution by environment variables, PowerShell named arguments, or as JSON input in more advanced cases. Bolt tasks are similar to resources in Puppet, allowing us to parameterize an action and use a command in a repeatable way. We'll be writing a simple task that allows us to inspect certain log files on the Puppet Master by name. This task will be part of a logs module, named <kbd>puppetserver</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">task.json</h1>
                </header>
            
            <article>
                
<p>This JSON parameter file is an optional component for tasks and allows the passing of parameters as environment variables to our scripts. We can use this file to also limit user input as well, leaving a small number of options available for our users if necessary. In the following example, our script will accept a log and store the parameter. The log parameter will only allow three choices, which determine where to find the log file the user is searching for. The store parameter will be off by default, but will allow us to aggregate logs for the plan we'll build in the next section:</p>
<pre>#logs/tasks/puppetserver.json<br/>{<br/>  "puppet_task_version": 1,<br/>  "supports_noop": false,<br/>  "description": "Retrieve a log file from the puppetserver",<br/>  "parameters": {<br/>    "log": {<br/>      "description": "The Puppetserver log you want to read",<br/>      "type": "Enum[console,puppetdb,puppetserver]"<br/>    },<br/>    "store": {<br/>      "description": "Store logfile in /tmp/puppetlog.log",<br/>      "type": "Optional[Boolean]"<br/>    }<br/>  }<br/>}</pre>
<div class="packt_tip">The parameters use the same data types as Puppet. You can use any data type available to Puppet as a data type for Puppet tasks.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Task</h1>
                </header>
            
            <article>
                
<p>Our task will be a simple shell script that reads a named file based on our input parameters, makes a decision on whether or not to store the output, and then returns the output as JSON to Bolt. It's important that our return comes back as JSON so that it can be picked up by Bolt. In more complex use cases, we could even use this JSON to pass key value pairs to a follow-on task in plans, which we'll cover in the next section.</p>
<div class="packt_tip">A task can be written in any language available to the system. This example will use Bash, as nearly every administrator has worked with it. If you haven't tried writing scripts in Python, Ruby, Golang, or any other scripting language outside of shell, give it a shot. These tasks actually become easier to write in these more advanced languages.</div>
<p>There are a few things worth noting in our shell script:</p>
<ul>
<li>Values returned from our JSON parameters file become environment variables, and start with <kbd>PT_</kbd>. Our script refers to <kbd>$PT_log and $PT_store</kbd> to check the values that will be sent over the command line.</li>
<li>We're using a case statement to map <kbd>$PT_log</kbd> to a log file. This use is similar to a selector statement in Puppet.</li>
<li>If <kbd>$PT_store</kbd> is true, we'll build a log file that can be appended to.</li>
<li>The log is printed out in the final line as JSON so that Puppet Tasks knows it is a valid output to the command line:</li>
</ul>
<pre><strong># logs/tasks/puppetserver.sh</strong><br/><strong>#!/bin/sh</strong><br/><br/><strong># Map $PT_log to a $logfile variable</strong><br/><strong>case "$PT_log" in</strong><br/><strong>  'console') logfile='/var/log/puppetlabs/console-services/console-services.log' ;;</strong><br/><strong>  'puppetdb') logfile='/var/log/puppetlabs/puppetdb/puppetdb.log' ;;</strong><br/><strong>  'puppetserver') logfile='/var/log/puppetlabs/puppetserver/puppetserver.log' ;;</strong><br/><strong>esac</strong><br/><br/><strong># Variable that stores all the text from inside the logfile</strong><br/><strong>log=`cat $logfile`</strong><br/><br/><strong># If store is true, build a header and then print out $log</strong><br/><strong>if [ $PT_store == 'true' ]</strong><br/><strong>then</strong><br/><strong>  echo "${PT_log}\r============" &gt;&gt; /tmp/puppetlog.log</strong><br/><strong>  echo $log &gt;&gt; /tmp/puppetlog.log</strong><br/><strong>fi</strong><br/><br/><strong># print out the key value of "&lt;chosen log&gt;":"all log contents" in JSON to be</strong><br/><strong># read by the Bolt interpreter</strong><br/><strong>echo -e "{'${PT_log}':'$log'}"</strong></pre>
<p>Let's double check that the files we've written are in the proper location before we run our command:</p>
<pre>logs<br/>├── files<br/>├── manifests<br/>├── tasks<br/>│   ├── puppetserver.json<br/>│   └── puppetserver.sh<br/>└── templates</pre>
<p>We can then run our command on the command line. We've added some parameters that help along the way:</p>
<ul>
<li><kbd>nodes</kbd>: This determines which nodes based on our inventory file to run on.</li>
<li><kbd>modulepath</kbd>: Where to look for modules. Because we're working on this module directly, we've just set the modulepath to the directory above the module.</li>
<li><kbd>--no-host-key-check</kbd>: You may not need this, but to ease troubleshooting of SSH in this section, we'll use this flag.</li>
<li><kbd>log=puppetdb</kbd>: This is the parameter which we wrote in our JSON file. It will be transformed into <kbd>$PT_log</kbd> and used in our shell script:</li>
</ul>
<pre><strong>$ bolt task run logs::puppetserver --nodes puppetserver --modulepath .. log=puppetdb --no-host-key-check</strong><br/><br/><strong>Started on pe-puppet-master.puppet.net...</strong><br/><strong>Finished on pe-puppet-master.puppet.net:</strong><br/><strong>  {'puppetdb':'2018-09-23T00:20:55.115Z INFO [p.p.command] [8-1537662054876] [212 ms] 'replace facts' command processed for pe-puppet-master</strong><br/><strong>  2018-09-23T00:21:12.077Z INFO [p.p.command] [9-1537662071679] [370 ms] 'store report' puppet v5.5.2 command processed for pe-puppet-master</strong><br/><strong>  2018-09-23T00:21:53.936Z INFO [p.p.c.services] Starting sweep of stale nodes (threshold: 7 days)</strong><br/><strong>  ...'}</strong><br/><strong>  {</strong><br/><strong>  }</strong><br/><strong>Successful on 1 node: pe-puppet-master.puppet.net</strong><br/><strong>Ran on 1 node in 0.89 seconds</strong></pre>
<p>Try the command out for yourself. It will return a different log file for each command, and if you pass <kbd>store=true</kbd>, it will even start appending this log to a file in <kbd>/tmp</kbd> named <kbd>puppetlog.log</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bolt plans</h1>
                </header>
            
            <article>
                
<p>If Puppet tasks are our imperative resources, Puppet plans are our Puppet manifests. Here, we combine multiple tasks and commands to form an orchestrated plan. These plans are written in the same DSL as Puppet code, although at the time of writing this book, only puppet functions can be used, and not many objects like resources or class are included.</p>
<p>In our sample plan, we're going to introduce two parameters: </p>
<ul>
<li><kbd>$enterprise</kbd>: This is used to determine if <kbd>pe-console-services</kbd> should be checked in the plan (it is possible to use facts from the target or PuppetDB as well)</li>
<li><kbd>$servers</kbd>: This is a list of servers that's passed as a comma-separated list</li>
</ul>
<p>Our task will clean up any existing stored logs and build a fresh set. This script will run the log scraper task we built in the last section for each section, and aggregate all the logs together. Enterprise, as an optional flag, will determine if <kbd>pe-console-services.log</kbd> is included as well. After we've built the log, we'll simply read the log file and ensure that it is returned to the command line with the <kbd>return</kbd> function. Finally, we'll clean up after ourselves and clean the aggregated log we just built in <kbd>/tmp</kbd>:</p>
<pre># logs/plans/puppetserver.pp<br/>plan logs::puppetserver (<br/>  Boolean $enterprise,<br/>  TargetSpec $servers,<br/>) {<br/><br/>  run_command('rm -f /tmp/puppetlog.log', $servers)<br/>  run_task('logs::puppetserver', $servers, log =&gt; 'puppetserver', store =&gt; true)<br/>  run_task('logs::puppetserver', $servers, log =&gt; 'puppetdb', store =&gt; true)<br/><br/>  if $enterprise == true {<br/>    run_task('logs::puppetserver', $servers, log =&gt; 'console', store =&gt; true)<br/>  }<br/><br/>  return run_command('cat /tmp/puppetlog.log', $servers)<br/>  run_command('rm -f /tmp/puppetlog.log', $servers)<br/><br/>}</pre>
<p>Once we've built our plan, we can run <kbd>bolt plan run</kbd>, passing our <kbd>modulepath</kbd> and parameters:</p>
<pre><strong>rary at Ryans-MacBook-Pro-3 in ~/workspace/packt/logs</strong><br/><strong>$ bolt plan run logs::puppetserver --modulepath .. --no-host-key-check enterprise=false servers=root@pe-puppet-master</strong><br/><strong>Starting: plan logs::puppetserver</strong><br/><strong>Starting: command 'rm -f /tmp/puppetlog.log' on root@pe-puppet-master</strong><br/><strong>Finished: command 'rm -f /tmp/puppetlog.log' with 0 failures in 0.38 sec</strong><br/><strong>Starting: task logs::puppetserver on root@pe-puppet-master</strong><br/><strong>Finished: task logs::puppetserver with 0 failures in 0.39 sec</strong><br/><strong>Starting: task logs::puppetserver on root@pe-puppet-master</strong><br/><strong>Finished: task logs::puppetserver with 0 failures in 0.45 sec</strong><br/><strong>Starting: command 'cat /tmp/puppetlog.log' on root@pe-puppet-master</strong><br/><strong>Finished: command 'cat /tmp/puppetlog.log' with 0 failures in 0.15 sec</strong><br/><strong>Finished: plan logs::puppetserver in 1.39 sec</strong><br/><strong>[</strong><br/><strong>  {</strong><br/><strong>    "node": "root@pe-puppet-master",</strong><br/><strong>    "status": "success",</strong><br/><strong>    "result": {</strong><br/><strong>      "stdout": "puppetserver\n============\n2018-09-23T00:20:54.905Z INFO [qtp417202273-69] [puppetserver] Puppet 'replace_facts' command for pe-puppet-master submitted to PuppetDB with UUID fc691079-debf-4c99-896b-3244f353a753\n2018-09-23T00:20:55.268Z ERROR [qtp417202273-69] [puppetserver] Puppet Could not find node statement with name 'default' or 'pe-puppet-master' on node pe-puppet-master\n ...",</strong><br/><strong>      "stderr": "",</strong><br/><strong>      "exit_code": 0</strong><br/><strong>    }</strong><br/><strong>  }</strong><br/><strong>]</strong></pre>
<p>You may notice that the log comes back as a big JSON object, with no line breaks represented. If you want to view this aggregated log file for yourself, try running the following command and inspecting the new <kbd>puppetlog.log</kbd> file:</p>
<pre><strong>$ rm -f *.log;bolt plan run logs::puppetserver --modulepath .. --no-host-key-check enterprise=false servers=root@pe-puppet-master &gt; compressed.log; head -n 6 compressed.log | tail -n 1 | awk '{gsub("\\\\n","\n")};1' &gt; puppetlog.log</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Puppet Enterprise Task Management</h1>
                </header>
            
            <article>
                
<p>Bolt is a fully-featured open source product. It does not need Puppet Enterprise to work well in your environment. That being said, the console for Puppet Enterprise ties in very nicely with Bolt. There is a single tasks page on the left-hand side of the console that will take you to the main tasks page. Once you enter, you'll be greeted with the <span class="packt_screen">Run a task</span> page, which provides you with a few convenient features if you're sharing yours tasks in your organization.</p>
<div class="packt_infobox"><span>This section is only relevant for Puppet Enterprise users. This module will need to be in </span><kbd>/etc/puppetlabs/code/environments/production/modules</kbd><span> via r10k or manual placement to be read by the Puppet Enterprise console.</span></div>
<p>The first main feature is the ability to directly view the supporting JSON parameters file before running the task. Notice that our description and optional parameters are represented in tasks when we add <kbd>logs::puppetserver</kbd>, making documentation for other users convenient:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/42da619d-e125-47ff-b7c4-e9c5d9fa40b2.png" style="width:44.17em;height:25.75em;"/></div>
<p>Every parameter is also represented as a drop-down menu. Because we selected <span class="packt_screen">Enum[console,puppetdb,puppetserver]</span> as our type in <kbd>puppetserver.json</kbd>, those are the only options available to the users in the console. Store is also a true or false only value drop-down, thanks to our Boolean selection:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f88b2203-b70f-4c09-a399-1b67f26f6b04.png"/></div>
<p>Once we run the job, we'll get back a cleaned up version of the logs that we've selected. If you're in a large organization, you could put this task into the inventory and allow administrators to remotely view log files on demand without ever needing to log into the server or manage the code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cff42a38-a4e4-4dff-94cc-9d30ddd6a56f.png" style="font-size: 1em;"/></p>
<p>This task was meant to be a simple example. With complicated tasks and plans, you can orchestrate automation of any kind and in any language across your infrastructure, using just SSH or WinRM. Our tasks have the ability to import and export JSON variables, allowing us to build more complex dependencies between tasks. Puppet Tasks is still relatively new to the Puppet ecosystem, but is a promising new addition, allowing for the rapid sharing of administration automation tasks within an organization.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Puppet Discovery</h1>
                </header>
            
            <article>
                
<p>Puppet Discovery is a new product by Puppet. Puppet Discovery is a standalone containerized application built to discover information about containers and virtual machines in real-time. This platform is designed to have an inventory of all IT resources, discover details about each resource, and take action on those machines. Although still in the early phases of development, I expect to see tighter integration between Discovery, Puppet Tasks, and the greater Puppet ecosystem.</p>
<div class="packt_tip"><span>Puppet Discovery is generally safe to install and use to inspect a production-level system. Puppet Discovery does do an active scan of all sources, and may trigger security warnings in your organization. Make sure that you coordinate with a security team if you decide to use Puppet Discovery against corporate resources.</span></div>
<p>In this section, we'll be installing Puppet Discovery and viewing what is available to us. We'll start by installing the system, followed by adding an IP CIDR block of our infrastructure machine, and then connect to our machines using credentials. Then we'll explore Puppet Discovery to view details of individual nodes and packages across our infrastructure.</p>
<div class="packt_tip">This may trigger security alerts in production if security isn't notified.</div>
<p> </p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing Discovery</h1>
                </header>
            
            <article>
                
<p><span>Puppet Discovery is not a </span><strong>Free and Open Source Software</strong><span> (</span><strong>FOSS</strong><span>). We'll need a license from Puppet, which can be obtained at </span><a href="http://licenses.puppet.com/">licenses.puppet.com</a><span>. Select an available Puppet Discovery license to get started and then download it to the target machine you'll run Puppet Discovery on. This JSON file will be used in the installation of our Puppet Discovery application.</span></p>
<div class="packt_infobox">You'll need Docker available on the machine. In order to install Puppet Discovery, you'll need to have Docker on the host.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preparing Puppet Discovery</h1>
                </header>
            
            <article>
                
<p>Download Puppet Discovery for your operating system at <a href="https://puppet.com/download-puppet-discovery">https://puppet.com/download-puppet-discovery</a>. This section will help us put the binary in our path and set up Puppet Discovery for the first time.</p>
<p>After we've downloaded Puppet Discovery, we'll want to move the binary into our path. On most Unix-based operating systems, <kbd>/usr/local/bin</kbd> is in your path. We need to place our binary in our path, make it executable, and ensure we can run it as the local user:</p>
<div class="packt_tip">If <kbd>/usr/local/bin</kbd> is not in your path, you can see which directories are in your path by using <kbd>echo $PATH</kbd> on your system. This will come back as a list separated by colons.</div>
<pre><strong>rary at Ryans-MacBook-Pro in ~/workspace</strong><br/><strong>$ mv ~/Downloads/puppet-discovery /usr/local/bin</strong><br/><br/><strong>rary at Ryans-MacBook-Pro in ~/workspace</strong><br/><strong>$ chmod a+x /usr/local/bin/puppet-discovery</strong><br/><br/><strong>rary at Ryans-MacBook-Pro in ~/workspace</strong><br/><strong>$ puppet-discovery</strong><br/><strong>A discovery application for cloud-native infrastructure</strong><br/><br/><strong>  Find more information at https://puppet.com/products/puppet-discovery</strong><br/><br/><strong>Usage:</strong><br/><strong>  puppet-discovery [command]</strong><br/><br/><strong>...</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>Once we've verified that the binary works, we'll run <kbd>puppet-discovery start</kbd> to start the service. We'll be prompted to provide a license key, read the EULA (which will pop up in a browser), and generate an administrative password:</p>
<pre><strong>rary at Ryans-MacBook-Pro in ~</strong><br/><strong>$ puppet-discovery start</strong><br/><strong>Please enter the path to your Puppet Discovery license: Documents/License-puppet-discovery-trial-2018-10-23.puppet_discovery.json</strong><br/><br/><strong>By continuing with installation, you agree to terms outlined in the Puppet Discovery End User License Agreement located here: /Users/rary/.puppet-discovery/data/puppet-discovery-eula-1537730629.html</strong><br/><br/><strong>Do you agree? [y/n]: y</strong><br/><br/><strong>*************************************************************************</strong><br/><strong>* NOTE: If you forget your password you lose all of your discovery data *</strong><br/><strong>*************************************************************************</strong><br/><br/><strong>Password requirements:</strong><br/><strong>* Password must have at least 6 characters</strong><br/><strong>* Password must use at least 3 of the 4 character types: lowercase letters, uppercase letters, numbers, symbols</strong><br/><strong>* Password cannot be the same as current password</strong><br/><br/><strong>Please create an admin password: **************</strong><br/><strong>Verify by entering the same password again: **************</strong><br/><br/><strong>Puppet Discovery: started 15s [====================================================================] 100%</strong><br/><strong>Puppet Discovery: pulled [8/8] 1m3s [====================================================================] 100%</strong><br/><strong>Opening Puppet Discovery at https://localhost:8443 ...</strong></pre>
<p>Once we've finished this step, Puppet Discovery will be running on port <kbd>8443</kbd> on our target machine in a Docker container.</p>
<div class="packt_tip">At the time of writing this book, the license prompt uses a relative path not an absolute path, so ensure you're running this command from somewhere you can find that JSON file.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing sources</h1>
                </header>
            
            <article>
                
<p>Our initial login won't take us to our splash screen until we've provided a basic list of target machines and credentials to Puppet Discovery. Puppet Discovery has the ability to tie into an entire Amazon Web Services, Google Compute Platform, Microsoft Azure, or VMWare VSphere account and perform automatic discovery of available resources. We can also provide a direct list of IP addresses if no API-driven platform is available.</p>
<p>In this section, we'll be adding a CIDR block of IP addresses to Discovery, which will be available to all users regardless of platform and hypervisor.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding sources by IP address</h1>
                </header>
            
            <article>
                
<p>If you're using a cloud provider to test this setup, go ahead and use the cloud provider instead. The rest of this section will not be reliant on the methodology that we use to connect to machines.</p>
<p>During the writing of this book, several nodes have been created in my Puppet Infrastructure so that we can inspect them. I've used Vagrant and VirtualBox as my platform, and I will be using my local network of <kbd>10.20.1.0/24</kbd> to discover all of my Puppet infrastructure. When selecting the IP address you will use to demonstrate this section, make sure that the machine you've installed Docker on has the ability to find the nodes over the network provided:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e872e04f-b7a5-42ff-8afc-b16277b84ab2.png" style="width:56.42em;height:25.67em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing credentials</h1>
                </header>
            
            <article>
                
<p>After our first list of nodes to discover, Puppet Discovery will automatically take us to a splash page, allowing us to select an authentication method. At the time of writing this book, three methods are available: an SSH Private Key, an SSH Credential, and a WinRM Credential. SSH Private Keys are generally the most secure method available, but if SSH keys are not available on the remote systems, a username and password is taken via SSH Credential for Linux or WinRM Credential for Windows.</p>
<p>In this section, we'll be using an SSH key to provide connections to the machines we discovered in the previous step.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SSH key file</h1>
                </header>
            
            <article>
                
<p>If you're using vagrant for testing this, rather than a cloud provider, I'm simply using the default insecure keys provided by vagrant. This key can always be found at <a href="https://github.com/hashicorp/vagrant/tree/master/keys">https://github.com/hashicorp/vagrant/tree/master/keys</a>.</p>
<p>When adding credentials, we're also scoping our credentials. In an SSH private key credential, you begin by selecting the PEM file you wish to apply from your local hard drive. We have three available RBAC options:</p>
<ul>
<li><strong>Discover data on hosts</strong>: Should this key be used to discover information?</li>
<li><strong>Run tasks on target hosts</strong>: Should this key be able to run and execute tasks?</li>
<li><strong>Escalate privileges to root</strong>: Should this user become the root user for discovery and tasks?</li>
</ul>
<p>Finally, we have a username and passphrase. Our username is the user we want to connect as to our remote machines. As my machines are all in vagrant, vagrant is also the user I'll be connecting with. The passphrase is used to decrypt the SSH key, and is optional if your key doesn't have a passphrase like mine:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6f84d545-1672-4fde-9f9b-8fb8a1721929.png"/></p>
<p>Once we've set up our first set of hosts and credentials, we'll be ready to use Puppet Discovery.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Discovering</h1>
                </header>
            
            <article>
                
<p>It may take some time for Puppet Discovery to collect all the information on your infrastructure. Additionally, browser caching can prevent population of this page after discovery. You may need to wait and clear your cache before you see any data populate on the dashboard.</p>
<p>Our splash page now displays all the hosts, packages, and containers that can be found against all of the sources we've provided and all authentication methods we've entered. This dashboard is interactive, and clicking any box will take you into a view, displaying all nodes that represent the information on the dashboard:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/118d339b-bffb-4597-89c5-e3e7a67965ae.png" style="font-size: 1em;width:52.50em;height:39.08em;"/></p>
<p>If you're curious about the process used to discover these nodes, you can click the <span class="packt_screen">Previous Events</span> icon in the top-left corner of Discovery and view the log for the discovery.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Viewing the Discovery</h1>
                </header>
            
            <article>
                
<p class="CDPAlignLeft CDPAlign">In my original sample, I provided the <kbd>10.20.1.0/24</kbd> CIDR block to scan. Puppet Discovery attempted a connection to the entire IP range using my provided credentials and returned all my nodes. You may had noticed that I have one failed node, which is actually my gateway and cannot be logged into using my credentials:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f055ae46-3faa-458f-a6e4-7febc8905c46.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Discovering hosts</h1>
                </header>
            
            <article>
                
<p>Back on the dashboard, let's go ahead and select <span class="packt_screen">Hosts</span> to view a list of all hosts, not narrowed down to specific information. We'll see some basic information displayed about all of these hosts, from the operating system to the uptime of the machine itself:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ed81f5b4-a442-4c28-bbc7-eaeaf6d0e8e3.png" style="font-size: 1em;width:38.00em;height:18.75em;"/></p>
<p>If we select the hyperlink for any individual node, we'll get a much more useful list of objects to work with, which provides us with detailed information about each host. Each tab will present us with different information:</p>
<ul>
<li><strong>Attributes</strong>: The primary attributes used by Puppet Discovery itself, including hostname, DNS name, and operating system details</li>
<li><strong>Services</strong>: All services on the node, and their current state (running, stopped)</li>
<li><strong>Users</strong>: All users on the system, and their home directory</li>
<li><strong>Groups</strong>: All groups available on the system</li>
<li><strong>Packages</strong>: Each package on the system, their version, and the method used to install them</li>
<li><strong>Tags</strong>: Any tags listed by the cloud provider</li>
<li><strong>Containers</strong>: Any containers running on the host system</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Discovering packages</h1>
                </header>
            
            <article>
                
<p>We can inspect packages as a whole in Puppet Discovery. When you select packages from the dashboard, you'll be taken to a page that lists all packages, their version, package manager, and, most importantly, the number of instances they're running on. We can use this information to see if software has been universally installed on our infrastructure, or to track versioning across infrastructure. This information is particularly helpful in security remediation when attempting to determine vulnerable systems in the infrastructure:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/19b8d522-4399-4ab0-a0ba-4b069e9a752c.png" style="width:51.08em;height:26.17em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Acting</h1>
                </header>
            
            <article>
                
<p>Puppet Discovery also allows us to take a very limited set of actions against our infrastructure today: installing Puppet agents and managing services. In the future, Puppet Discovery may include the ability to federate tasks over your infrastructure as well. You can access these actions by selecting the <span class="packt_screen">Act +</span> icon in the top bar of Puppet Discovery. You'll be redirected to the <span class="packt_screen">Select a task</span> page:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c91ac103-9e6b-482b-a52e-fa54d110359e.png" style="width:54.58em;height:24.67em;"/></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing agents</h1>
                </header>
            
            <article>
                
<p>Installing agents using Puppet Discovery is one of the easiest ways to install Puppet agents throughout your infrastructure. You're currently able to provide the following parameters and apply the tasks to a list of hosts:</p>
<ul>
<li><kbd>master</kbd>: Which Puppet Master to use. This is the only non-optional parameter.</li>
<li><kbd>cacert_content</kbd>: Expected CA certificate the Master should return.</li>
<li><kbd>certname</kbd>: Certname of agent.</li>
<li><kbd>environment</kbd>: Environment the node should run in.</li>
<li><kbd>dns_alt_names</kbd>: DNS alternate names baked into the agent certificate.</li>
<li><kbd>custom_attributes</kbd>: Any custom CSR attributes.</li>
<li><kbd>extension_request</kbd>: Any specific extension requests (such as <kbd>pp_role</kbd>) to add to the certificate.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing services</h1>
                </header>
            
            <article>
                
<p>Managing services is also available in Puppet Discovery, and gives us only two fields to use: <strong>Action</strong> and <strong>Name</strong>. Use these two fields to find a service on the machine and start, stop, or restart any services on the node. This is a convenient agent-free way to do some basic management of your infrastructure before introducing Puppet on each node.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Uses for Discovery</h1>
                </header>
            
            <article>
                
<p>Discovery is still pretty new to the Puppet ecosystem. It is meant to be the first thing installed before determining how you want to proceed with your greater Puppet infrastructure rollout. That being said, Puppet Discovery has a few key uses:</p>
<ul>
<li>Determining what you already have in your environment</li>
<li>Ensuring that security patches are properly installed on target machines</li>
<li>Inspecting resources at a higher level, rather than executing on them</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we took a look at Puppet Tasks and Puppet Discovery. Bolt and Puppet Tasks allow us to perform remote ad hoc commands on target machines. We can parameterize these ad hoc commands and build tasks that are highly shareable actions in our organization. We can even chain together these tasks as Puppet Plans to build more complex actions that we can share across our infrastructure. We inspected Puppet Discovery, installed it on our local system, and viewed the existing infrastructure. We learned how to view and deploy agents, as well as manage services with Puppet Discovery.</p>
<p>We will cover virtual and exported resources in Puppet in the next chapter.</p>


            </article>

            
        </section>
    </body></html>