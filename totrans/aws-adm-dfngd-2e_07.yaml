- en: Transforming Application Development Using the AWS Code Suite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we explored a few interesting and really useful enhancements
    made to the AWS **Identity and Access Management Service** (**IAM**) along with
    a quick deep dive into AWS Organizations as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be learning and exploring three extremely useful and
    powerful services provided by AWS that are specially catered toward enhancing
    a developer''s experience with continuous code deployments: AWS CodeCommit, AWS
    CodeDeploy, and AWS CodePipeline!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping this in mind, let''s have a quick look at the various topics that we
    will be covering in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing AWS CodeCommit, AWS CodeDeploy, and AWS CodePipeline along with
    each service's concepts and internal workings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your first CodeCommit repository and uploading an application to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running basic Git commands against your new code repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the CodeDeploy agent on an EC2 instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging the AppSpec file for configuring application life cycle deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your own continuous delivery system using CodePipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So without any further ado, let's get started right away!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the AWS Code Suite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides providing a plethora of infrastructure-related services, AWS also provides
    a few services that are designed to help developers quickly design, develop, build,
    and deploy their applications on the AWS cloud platform. In this section, we will
    have a quick look at these services and how you can leverage them together to
    build your very own continuous integration and delivery pipelines:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AWS CodeCommit**: An important starting point for any CI/ CD pipeline is
    a simple yet functional source control repository. Traditionally, this would be
    set up on one or more physical servers in the form a Git or SVN repository that
    developers would use to push their code and updates to; however, maintaining such
    code repositories and scaling them was always going to be a challenge. That''s
    where AWS CodeCommit comes into play! AWS CodeCommit is a managed source control
    service that enables developers to securely store their code on the AWS cloud.
    It offers many of the features that you would require and use while working with
    different source control repositories, such as branching, commits, rollbacks,
    and much more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS CodeBuild**: AWS CodeBuild is a code build service that developers can
    leverage to automate their source code compilations, tests, executions, and code
    packaging for deployments. Similar to its other counterpart services in the Code
    Suite, CodeBuild too is managed completely by AWS, thus eliminating any unnecessary
    administrative overheads, such as patching or scaling the code build software.
    CodeBuild is highly extensible and it also easily integrates with your existing
    CI/CD workflows as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS CodeDeploy**: With your application code stored securely and compiled,
    the final step requires the code to be deployed across your fleet of EC2 instances.
    This can be easily achieved with the help of our next Code Suite service, called
    AWS CodeDeploy. Using CodeDeploy, a developer can automate code deployments to
    any environment that runs off of either EC2 instances as well as servers that
    are running in an on-premise datacenter. CodeDeploy essentially eliminates deployment
    complexities by allowing you to automate the delivery of your code across thousands
    of instances without having to undergo any major downtimes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS CodePipeline**: AWS CodePipeline is a full fledge CI/CD service provided
    by AWS that developers can leverage to build end-to-end CI/CD pipelines either
    by using the AWS Code Suite of services or even with other popular third-party
    tools, such as GitHub, Jenkins, and so on. Using CodePipeline, you can also create
    and define custom software release models using which your application gets updated
    with the latest set of updates, tested, and packaged as well for the next iterative
    set of deployments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a brief representation of how these services map together collaboratively
    to create a comprehensive CI/CD pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e3d7b23-e812-4d55-ba50-ad84c36c0288.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For the purpose of this chapter, however, we will be working with only three
    AWS Code Suite services, namely AWS **CodeCommit**, AWS **CodeDeploy**, and AWS
    **CodePipeline**. The chapter will showcase how these three services can be leveraged
    together to build your very own CI/CD pipelines for our sample WordPress application.
    Here is a high-level depiction of our overall use case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea5db7c2-66dd-46e7-b588-94de46987c18.png)'
  prefs: []
  type: TYPE_IMG
- en: With the basic understanding of the Code Suite services out of the way, let's
    learn a bit more about AWS CodeCommit and how you can leverage it as your very
    own source code repository!
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started with AWS CodeCommit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As discussed earlier, AWS CodeCommit is a secure and highly scalable source
    control service which allows you to create multiple private Git repositories without
    having to bother about any of the underlying management overheads. You can use
    it to store anything, from code, to application binaries, to even code packages,
    all using the standard Git-like functionality. This makes CodeCommit extremely
    easy to work with even if you have not used it before. Here is the gist of some
    of the most commonly used Git commands and how you can leverage them with CodeCommit:'
  prefs: []
  type: TYPE_NORMAL
- en: '`git clone`: Used to clone and connect the AWS CodeCommit repository over to
    your local development server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git add`: Once the repository is cloned locally, you can use it to add, edit,
    or delete files as you see fit. Once done, use the `git add` command to stage
    the modifications in your local Git repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git commit`: Used to commit the modifications made to the files to the local
    Git repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git push`: Used to push the committed files and changes over to the AWS CodeCommit
    repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git pull`: Used to ensure that the files you are working on are synced and
    are of the latest version from the AWS CodeCommit repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this section, we will be looking at a few simple steps to enable you to
    create your very own source code repository using the AWS Management Console.
    However, before we move on to that, it is important to understand some of the
    different connections that you can use to connect to your CodeCommit repository.
    This can vary based on your development environments as well as security requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using the HTTPS connections**: Configuring Git credentials using HTTPS connections
    is by far the simplest and most widely used method for connecting to your Git
    repository. With this set up, you simply generate a static username and password
    using AWS IAM. Once the credentials are created, you can then use them with Git
    and any third-party tool, such as an IDE, for authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using the SSH connections**: In this case, a user will be required to create
    public and private key files on your local development server that Git and AWS
    CodeCommit can use for SSH authentication. The public key generated in this process
    gets associated with your IAM user, whereas the private key remains on the local
    development server. The generation of the keys varies from operating system to
    operating system and can be a tedious process at times to manage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For this section, however, we will be leveraging the SSH connections method
    itself for connecting to our AWS CodeCommit repository:'
  prefs: []
  type: TYPE_NORMAL
- en: To get started, first log in to your AWS Management Console and filter the IAM
    service using the Filter option provided. Alternatively, you can also select URL
    [https://console.aws.amazon.com/iam/](https://console.aws.amazon.com/iam/) to
    view the IAM dashboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we will start off by creating a dedicated user that will have full management
    rights to our CodeCommit repository. Select the Users option from the IAM dashboard's
    navigation pane to bring up the list of currently created IAM users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, select the Add user option. This will bring up the Add user page where
    you can provide a suitable User name as well as opt for the user's Access type.
    In this case, the CodeCommit user will only require Programmatic access. Click
    Next to proceed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Moving on, in the Permissions page, we are required to filter and attach the
    `AWSCodeCommitFullAccess` policy to our newly created user. To do so, select the
    Attach existing policies directly option and select the `AWSCodeCommitFullAccess` policy,
    as shown in the following screenshot. Alternatively, you can also provide a customized
    access policy here based on your requirements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7fe3b055-8f07-4ffc-9425-639d123653f6.png)'
  prefs: []
  type: TYPE_IMG
- en: Complete the user creation process by reviewing the changes and making a note
    of the user's new access and secret keys as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, with your CodeCommit IAM user created, we now move on to the
    next part of this section where we create and configure a set of public and private
    keys for the IAM user, using a simple Linux-based development server. Follow URL [http://docs.aws.amazon.com/codecommit/latest/userguide/setting-up-ssh-windows.html](http://docs.aws.amazon.com/codecommit/latest/userguide/setting-up-ssh-windows.html) if
    you are using a Windows operating system as your development server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in to your development server and run the following command to generate
    the new set of keys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When prompted, save the keys in the following directory structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Make a note of the public and private keys'' locations, as depicted in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/495a035a-aed2-4591-ad52-5155b48b7e98.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, display and copy the public key''s contents, using the following command.
    Note the public key will be saved in the file with a `.pub` extension:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Log in to your IAM dashboard once again and select the newly created user from
    the Users page. Select the user's Security Credentials tab. Here, under the SSH
    keys for AWS CodeCommit section, click on Upload SSH public key to paste the entire
    copied text from the earlier step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once completed, you should now see a unique key auto-generated under the SSH
    key ID column, as shown in the following screenshot. Copy this SSH key ID as we
    will be requiring it in the next steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/baf12b4f-1415-4f5b-ae4c-211bae5c221f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With the public key uploaded to IAM and the new SSH key ID generated, the final
    step is to create a simple `config` file in your local development server with
    the following contents pasted into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file once done. Remember to modify the permissions of your `config` file
    before moving on to the verification step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify the connectivity, simply use the following command to SSH to the
    AWS CodeCommit endpoint. Since this will be a first connect, you will be prompted
    to verify the connection for authenticity. Type in `yes` when prompted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The endpoint you use will be specific to the AWS region that you operate out
    of. You can view the list of region-specific CodeCommit URLs along with the availability
    of the CodeCommit service at [http://docs.aws.amazon.com/codecommit/latest/userguide/regions.html](http://docs.aws.amazon.com/codecommit/latest/userguide/regions.html).
  prefs: []
  type: TYPE_NORMAL
- en: With this step, we have successfully validated and connected our development
    server with the AWS CodeCommit service! But where is our CodeCommit repository?
  prefs: []
  type: TYPE_NORMAL
- en: To create the repository, log in to the AWS CodeCommit service using URL [https://console.aws.amazon.com/codecommit](https://console.aws.amazon.com/codecommit).
    Remember to change the Region based on what you selected during the key verification
    state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since this is our first time working with CodeCommit, select the Get Started option
    to begin with. This will display the Create repository page, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bcb3f74e-2d2b-4fce-abb0-176341c6a6f9.png)'
  prefs: []
  type: TYPE_IMG
- en: Provide a suitable Repository name and an optional Description. Click on Create
    repository once done.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can additionally configure notifications for specific Event types, such
    as pull requests and commits made to your repo in the Configure email notifications page.
    Simply select an existing SNS topic or opt to Create a new topic based on your
    requirements. Once done, click on Save to complete the repository creation process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the repository created, you can now use the development server and connect
    to it using a simple `git clone` command. You can obtain your repository''s connection
    URL anytime by simply selecting the Connect option present on the Code page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a snapshot of the first `git clone` command output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3a3932d-ee79-422d-90c0-e441dafb63b9.png)'
  prefs: []
  type: TYPE_IMG
- en: Since the repository is empty, the cloning process simply creates a folder with
    your repository's name on your development server. You can now use this folder
    as a code source control by simply adding your program files, binaries, and other
    application-specific data to it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be using this repository as our WordPress application
    source control and explore a few simple commands and features that are provided
    as a part of AWS CodeCommit.
  prefs: []
  type: TYPE_NORMAL
- en: Working with branches, commits, and triggers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With your CodeCommit repo created, it's now time to go ahead and use this repository
    as our source control repository. To do so, we will first push a standard WordPress
    application from our local development server to the AWS CodeCommit repository
    using simple Git commands and later run a few more Git commands as well as AWS
    actions to branch and commit our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can obtain a WordPress application ZIP file by downloading it from here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/WordPress/WordPress](https://github.com/WordPress/WordPress)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, first we will need to copy the WordPress application contents
    over to our local repository that was cloned earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the WordPress application is downloaded to your local development server,
    simply unzip and copy its contents over to the local repository. Your local repository
    should now show a folder structure similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/15239bc3-a5e8-4b6e-b3bb-4bc2e291f633.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With the code in place, simply use the following Git commands to commit and
    push the code over to your AWS CodeCommit repository. First up, stage the files
    using the `git add` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, commit the changes using the `git commit` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And, finally, push the commit over to the AWS CodeCommit repository. Here,
    the keyword `origin` is the default remote name used by Git for your AWS CodeCommit
    repository, whereas `master` is the default branch name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the code get uploaded to your AWS CodeCommit repository, as
    shown in the following image. You can cross-verify this by refreshing and checking
    the Code page on your AWS CodeCommit dashboard as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fac448f3-bb8b-45ef-961e-5261da4ba809.png)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, you and your fellow developers can edit and commit the code back
    to the AWS CodeCommit repository. You can also create multiple branches of your
    repository so that developers can work independently on the code without affecting
    the `master` branch. Once the features are all thoroughly tested and verified,
    the individual developer branches can be merged into a more stable `master` branch
    of the software.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a branch in CodeCommit is an extremely easy process! You can use the
    CodeCommit dashboard, the Git command line, or even the AWS CLI to create one
    of your own:'
  prefs: []
  type: TYPE_NORMAL
- en: To create a branch using the AWS CodeCommit dashboard, simply select the Branches option
    from the navigation pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, select the Create branch option to bring up the Create branch page. Here,
    provide a suitable Branch name and also select where you would like this new branch
    to Branch from. In this case, since you only have the `master` branch created,
    you can select that for now. Click on Create once done.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can also use the Git command line itself to achieve the same result. In
    this case, from the development server, type in the following command to create
    a new branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/4d4cbea3-5d37-4ac6-8bee-738615e8e4ba.png)'
  prefs: []
  type: TYPE_IMG
- en: With the new branch created, you can also use the Compare functionality provided
    by CodeCommit to compare the changes made to the branch against another branch.
    To do so, we first need to perform some changes in the application so that it
    can get reflected as a change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without changing the current branch of the repository, simply update any one
    of the WordPress files by adding or removing a comment. In my case, I simply made
    a few comment changes in the WordPress application''s `index.php` file; however,
    feel free to modify any other file as you see fit. Once the changes are made,
    we once again need to stage, commit, and push the changes over to the new branch
    of our repository:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Stage the changes by using the `git add` command. You can either add all the
    files for staging by using `*` or even specify the filename you wish to stage
    as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, commit the changes using the `git commit` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And, finally, push the changes over to the branch using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With the changes pushed, use the Compare option provided under the Commits section
    in the CodeCommit dashboard. Here, select the master as the *source* branch and
    the branch that you created using the Git command line as the Destination branch.
    Click on Compare once done. You should see the changes compared, as shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1a7930dc-5e9b-464a-be5d-744725a7061a.png)'
  prefs: []
  type: TYPE_IMG
- en: You can use the Go to file drop-down list to toggle between different files,
    if you have made changes in them. Alternatively, you can also use the Unified and
    Split views to change the visual comparison as you see fit.
  prefs: []
  type: TYPE_NORMAL
- en: 'CodeCommit also provides an additional feature called **triggers** that you
    can use to either send notifications to or run some other external code build
    or process. You can assign up to 10 triggers per repository that you create, however,
    at the time of writing this book, CodeCommit only supports AWS SNS and AWS Lambda
    as its trigger mechanisms:'
  prefs: []
  type: TYPE_NORMAL
- en: To create a simple trigger, using the CodeCommit dashboard, select the Settings tab
    from the navigation pane. Here, select the Triggers tab to create as well as view
    the list of existing triggers, if any.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Create trigger option to bring up the Create trigger page. Here,
    you can configure triggers in response to certain repository events, such as Push
    to an existing branch, Create branch or tag, Delete branch or tag, or All repository
    events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide a Trigger name and select the appropriate Events and Branch name that
    you wish to associate the trigger with. Once done, you can configure the trigger
    to either use an existing SNS topic or a Lambda function as its Service. You can
    even test the functioning of the trigger by selecting the Test trigger option.
    This will simulate a trigger based on the *event* that you would have selected
    earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this way, you can configure triggers for sending notifications to your developers
    as well as trigger-specific Lambda functions based on your repository's requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing AWS CodeDeploy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With CodeCommit configured and ready to use for our WordPress application, we
    can now move on to yet another Code Suite service that can actually be used to
    deploy the code across thousands of EC2 instances! Here's introducing AWS CodeDeploy!
  prefs: []
  type: TYPE_NORMAL
- en: AWS CodeDeploy is basically a deployment service that allows you to automate
    the deployment of your applications to Amazon EC2 instances, Lambda functions,
    or even to on-premise instances. There is no limit to what an AWS CodeDeploy service
    can deploy. You can use it for deploying virtually anything from code, packages,
    binaries, scripts, files, and so on. As of writing this book, CodeDeploy only
    supports GitHub repositories and Amazon S3 buckets as the default application
    content repositories. Yes, you heard it right, CodeDeploy does not support CodeCommit
    as a repository source as of now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the automation, CodeDeploy also provides you with the following set
    of useful benefits. It allows you to:'
  prefs: []
  type: TYPE_NORMAL
- en: Quickly create new prototype software and deploy at scale without manual interventions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easily update to your application code without any downtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rollback deployments in case of any errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scale your deployment from one to a thousand instances, all without disrupting
    to your existing applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section of the chapter, we will be looking at how to set up CodeDeploy
    for our own application deployments, but before we get into that, here's a quick
    look at some of CodeDeploy's essential concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Concepts and terminologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CodeDeploy essentially comprises two main configurable sections that can be
    broadly classified as deployments and applications. Here''s a look at each of
    these concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Applications:** Applications here imply simple names that are used by CodeDeploy
    to identify individual application codes targeted for specific deployments. An
    application can be deployed either on an EC2 instance, an on-premise instance,
    as well as on a serverless compute platform, such as AWS Lambda.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployments**: Deployments are a collection of deployment configurations
    and deployment types, including:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment configurations**: Deployment configurations are a set of simple
    rules that determine how fast an application will be deployed and the success
    or failure conditions for that particular deployment. For example, for an EC2
    deployment, the configuration rules can dictate the required minimum number of
    healthy instances, whereas with a Lambda function deployment, these rules can
    be used to specify how the traffic is routed to the functions during a deployment.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment group**: This is a group of EC2 or on-premise instances that are
    either standalone or a part of an auto-scaling group. Since AWS Lambda is a managed
    service, it does not provide any deployment groups.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment types**: Deployment types indicate the type of method used to
    get the latest version of your application deployed on a particular deployment
    group. There are two deployment types supported:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In-place deployments**: In this case, the application running on each EC2
    instance is stopped, updated, started, and verified. This form of deployment is
    only supported for EC2 and on-premise instances.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blue/green deployments**: In this scenario, the underlying instances are
    replaced by newer instances with the updated piece of code. The instances are
    registered to an **Elastic Load Balancer** (**ELB**) that routes traffic to the
    newer instances while the older instances can then be terminated. With the serverless
    platform, the traffic here too is shifted automatically by AWS from the current
    Lambda functions to the current updated ones. Note that all Lambda deployments
    are in fact blue/green deployments only.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CodeDeploy agent**: CodeDeploy agent is a simple software package that gets
    installed on either an EC2 or an on-premise instance and is used by CodeDeploy
    for setting up and working with application deployments. Once the agent is installed
    on an instance, an associated configuration file is created. This file contains
    application-specific directory paths and other settings that CodeDeploy uses to
    interact with the instances. The file is a simple YAML file and can be located
    in the following directories based on the instance''s operating system:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon Linux, Ubuntu, RedHat Enterprise Linux**: `/etc/codedeploy-agent/conf/codedeployagent.yml`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows Servers**: `C:ProgramDataAmazonCodeDeployconf.yml`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application specification files**: Application specification files, or AppSpec
    files, are used to define and manage individual deployments as a series of life
    cycle event hooks. Each hook itself can be another file, such as a simple script
    to start or stop services, install dependencies, and so on. AppSpec files are
    supported in both JSON as well as YAML formats. At the time of the deployment,
    the AWS CodeDeploy agent looks up the name of the current event in the hooks section
    of the AppSpec file. If an event is found, the agent retrieves the list of scripts
    to execute and runs them sequentially in the order in which they were written
    in the AppSpec file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the basics out of the way, let's quickly look at how we can set up an EC2
    instance to be used with CodeDeploy.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring the CodeDeploy agent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we begin with the actual launch of our EC2 instance with the CodeDeploy
    agent installed on it, we need to set up an EC2 instance profile as well as an
    instance role that will grant our EC2 instances the necessary permissions to interact
    with both CodeCommit as well as with CodeDeploy:'
  prefs: []
  type: TYPE_NORMAL
- en: To get started, first log in to the AWS Management Console and select the IAM service
    from the services Filter. Alternatively, you can launch the IAM dashboard by selecting
    URL [https://console.aws.amazon.com/iam/](https://console.aws.amazon.com/iam/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the IAM dashboard, select the Policies option from the navigation pane
    to bring up the IAM Policies page. Here, click on Create policy to get started.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Create policy page, select the JSON tab and paste the following lines
    of the policy document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The policy document essentially provides the EC2 instance with the required
    set of permissions to interact with the likes of AWS services, such as CodeDeploy,
    CodeCommit, and CodePipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Click on Review policy once done. In the final Review policy page, provide a
    suitable Name for the policy and click Create policy to complete the process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the policy created, we now simply assign this to a new IAM Role. To do
    so, select the Roles option from the navigation pane to bring up the IAM Roles page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on Create role to start the wizard. From the Select type of trusted entity section,
    make sure you select AWS service and filter out EC2 from there. Click on Next:
    Permissions to proceed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Attach permissions policy page, filter the earlier created policy and
    attach it to our new role, as depicted in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ea4394d9-11ce-425f-9325-cc38a33b0aa9.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at the Review page, provide your role with a suitable Role Name and
    click on Create role to complete the process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before launching your EC2 instance with this newly created Role, ensure that
    the role''s Trust Relationship has the following set of AWS services added in
    its policy document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'With this step completed, we are now ready to launch a simple EC2 instance
    and assign the newly created role:'
  prefs: []
  type: TYPE_NORMAL
- en: From the EC2 Management Console, select the Launch Instance option to get started.
    For this particular use case, I've opted to go for the standard Amazon Linux AMI
    (`amzn-ami-hvm-2017.09.1.20171120-x86_64-gp2 - ami-55ef662f`); however, you can
    very well opt for a different Linux OS distribution as per your requirements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select an appropriate Instance type for hosting our simple WordPress application.
    For now, I've selected the **t2.micro** instance type itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, in the Configure Instance Details page, select the appropriate Network,
    Subnet, and IAM Role for our new EC2 instance. Paste the following set of lines
    as User data under the Advanced Details section, as shown in the following code.
    This simple user data script will copy and install the CodeDeploy agent along
    with a few other essential dependencies. You can find the complete copy of the
    following code at [https://github.com/yoyoclouds/Administering-AWS-Volume2](https://github.com/yoyoclouds/Administering-AWS-Volume2):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Remember to change the `region` parameter as per your current operational region
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Once the required storage is assigned to the instance, move on and assign a
    few essential tags for our EC2 instance. These tags will be used later in CodeDeploy
    to reference our EC2 instances, so make a note of the same.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, create a new security group and make sure that the ports `22` (SSH)
    and `80` (HTTP) are open for internet traffic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the settings of your instance and launch it. Additionally, remember to
    associate your instance with a key pair as well before you launch it, as it can
    be useful to verify or troubleshoot the AWS CodeDeploy agent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this, you now have successfully launched and set up a CodeDeploy agent
    on an EC2 instance. In the next section of this chapter, we will look at how you
    can take this installation further by configuring the AppSpec file for the final
    CodeDeploy deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the AppSpec file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, the AppSpec, or the application specifications file, is
    basically a YAML or JSON backed file used to define life cycle hooks for a particular
    deployment. In this case, with our EC2 instance prepped and ready with the CodeDeploy
    agent, we still need the AppSpec file to define a set of dependencies that will
    essentially install the necessary packages on the EC2 instance, start or stop
    the services, change permissions, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'The AppSpec file comprises the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Version**: The version of the AppSpec file. Currently, the version number
    supported with CodeDeploy is `0.0`. Do not change this value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OS**: Specifies the operating system of the underlying EC2/on-premise instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Files**: Specifies the files that need to be copied on the instance at the
    time of the deployment process. You can additionally specify a source and a destination
    folder as well for your applications here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hooks**: Hooks essentially specify when a particular deployment life cycle
    has to be triggered. There are four main types of hooks: `BeforeInstall`, `AfterInstall`,
    `ApplicationStart`, and `ApplicationStop`. Each hook further requires additional
    parameters, such as the `location` of the scripts to execute, a `timeout` value,
    and how the scripts should be `runas`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a representation of a simple AppSpec file for our WordPress deployment.
    Since we are using the Amazon Linux-backed instance, the `os` value is set to
    `linux` along with other essential parameters, such as `files` and `hooks`. Note
    in our case, we are configuring the WordPress application files to be copied from
    their default location over to `/var/www/html/WordPress` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To create this file, login to your development server and not your CodeDeploy
    instance. Once logged into the development server, open the WordPress application
    directory that we used during the CodeCommit sections of this chapter. This is
    the same directory that we used to sync with our master CodeCommit repository
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, at the application''s root directory, create a blank `appspec.yml`, and
    copy-paste the `appspec` contents explained earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With the AppSpec file created, we now move on to create the individual files
    for the life cycle hooks. To do so, create a folder named `scripts` within the
    WordPress application directory and create each of these individual shell scripts
    within it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `install_dependencies.sh` script that will essentially install the
    necessary packages required to run WordPress on an instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, create the `change_permissions.sh` script that modifies the permissions
    of the files present in the scripts folder to *executable*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And, finally, create the `start_server.sh` and the `stop_server.sh` scripts
    that will start and stop the `httpd` and `mysql` services on the deployment EC2
    instances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Got this far? Awesome! We are almost done with the AppSpec files, with just
    one small step left: uploading these changes to our CodeCommit repository!'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, run the following set of commands from the deployment server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Et voila! The WordPress application and our deployment scripts are all uploaded
    to our CodeCommit branch and ready for deployment! In the next section, we will
    create and configure an application and deployment group for our CodeDeploy.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a CodeDeploy application and deployment group
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our AppSpec file and scripts in place and the EC2 instance set up with
    the CodeDeploy agent as well, the final thing left is to configure AWS CodeDeploy
    and tie these things together:'
  prefs: []
  type: TYPE_NORMAL
- en: Start off by logging into the AWS CodeDeploy service by selecting URL [https://console.aws.amazon.com/codedeploy/home](https://console.aws.amazon.com/codedeploy/home).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since this is the first time we are using CodeDeploy, select the Get Started
    Now option. Here, you will be prompted to select either a Sample deployment that
    deploys a sample application on the EC2 instances or, alternatively, go for a
    Custom deployment if you have your code and EC2 instances up and running. In this
    case, we will select the Custom deployment option itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Create application page, start off by providing a suitable Application
    name, Compute Platform, and a Deployment group name. Remember to select the EC2/On-premises option
    from the Compute Platform, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/35fbb4b7-afbf-4e1f-8b1e-f21272c33a64.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, in the Deployment type section, choose the In-place deployment option
    for now. This will enable CodeDeploy to update the existing instances with the
    revised set of application code with some amount of downtime.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Environment configuration section, you can specify any combination of
    Auto Scaling groups, Amazon EC2 instances, and On-premises instances to add instances
    to this deployment group. Since we have created an EC2 instance in our earlier
    steps with the CodeDeploy agent installed in it, select the Amazon EC2 instances tab.
    From the Tag group drop-down, select the instance's Key and Value, as shown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that these are the same tags that you would have configured to your instance
    before its launch in our earlier sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c965bce-6159-4e2d-bc9a-e4c121dc0f99.png)'
  prefs: []
  type: TYPE_IMG
- en: Moving on, in the Deployment configuration section, you can choose from a list
    of default and custom deployment configurations. As discussed earlier, a deployment
    configuration is a set of rules that determines how fast an application will be
    deployed along with the definition of success or failure conditions for a particular
    deployment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are three default configurations provided by AWS CodeDeploy itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OneAtATime**: Routes traffic to one instance in the replacement environment
    at a time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HalfAtATime**: Routes traffic to up to half the instances in the replacement
    environment at a time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AllAtOnce**: Routes traffic to all instances in the replacement environment
    all at once'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we are working with just a single EC2 instance as of now, go ahead and
    select the OneAtATime deployment configuration option.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, select the IAM Role that we created and assigned our EC2 instance to
    at the time of launching, using the Service Role drop-down list. Once done, select
    the Create application option to complete the process!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There you have it! If you made it this far then you have successfully configured
    both AWS CodeCommit and AWS CodeDeploy for our WordPress application's deployment!
    But we are still missing the glue that ties all these services together, and that
    precisely is what we will be talking about in the next section with the introduction
    of AWS CodePipeline!
  prefs: []
  type: TYPE_NORMAL
- en: Introducing AWS CodePipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS CodePipeline is a continuous delivery service that you can use to model,
    visualize, and automate the steps required to release your application software.
    This is made possible by building *pipelines* that contain one or more *stages*.
    The stages can be broadly classified as *build*, where the code is compiled and
    built using, say, AWS CodeBuild or some other third-party tool, *staging*, and
    *deployment*, where the code is pushed on to compute instances using AWS CodeDeploy,
    and so on. Each stage internally describes a set of actions that it needs to perform
    in order to prepare the software for its release. This action can be anything
    from building your source code from a Git repository, to making changes to a file,
    or deploying packages, and so on. Every change made to either your code or some
    configurational setting within CodePipeline is considered as a *revision* and
    you can have multiple such revisions created within a single stage of a pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Even changes made to a single stage within the pipeline results in all actions
    across all stages being re-executed.
  prefs: []
  type: TYPE_NORMAL
- en: You can use these features provided by CodePipeline to effectively manage and
    monitor the release of your software. In this section, we will be continuing with
    our use case set up earlier using CodeCommit and CodeDeploy and see how we can
    truly build an end-to-end continuous delivery cycle using AWS CodePipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own continuous delivery pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Getting started with CodePipeline is extremely easy provided you have all the
    necessary prerequisites met, which include setting up the CodeCommit repository
    with your latest piece of application code (in this case, the WordPress application),
    as well as configuring the application and the AppSpec file using CodeDeploy:'
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, launch the CodePipeline Management dashboard by selecting URL [https://console.aws.amazon.com/codepipeline/home](https://console.aws.amazon.com/codepipeline/home).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since this is our first setup, click on the Get Started option to get going.
    This will bring up the Getting started with AWS CodePipeline wizard, as shown
    in the following screenshot. Start off by providing a suitable Pipeline name and
    click Next step to continue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6e2daad6-3d4c-4d2e-9e2c-7049f95fbd0c.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, in the Source page, we need to select and configure the source for our
    new pipeline. At the time of writing this book, CodePipeline supports three source
    code providers, namely Amazon S3, AWS CodeCommit, and GitHub. For the purpose
    of this use case, go ahead and select AWS CodeCommit from the Source drop-down
    list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will automatically prompt you to enter the subsequent CodeCommit Repository
    name as well as its corresponding Branch name. Make sure you provide the same
    branch name that contains the latest WordPress code as well as the AppSpec file.
    Click on Next step to continue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The third stage of the Pipeline setup is the Build stage where you can specify
    the build provider. CodePipeline supports three build providers, namely AWS CodeBuild,
    Jenkins, and Solano CI. Since our WordPress installation doesn't require any compilations
    or build procedures, simply select the No Build option from the drop-down list
    and click on Next step to continue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The fourth state requires the Deployment configurations to be set up for the
    pipeline. Here too you are provided with various options that you can choose to
    leverage based on your needs. At present, CodePipeline supports AWS Opsworks,
    AWS CodeDeploy, AWS CloudFormation, and AWS Elastic Beanstalk as the Deployment
    providers. Since we have already configured AWS CodeDeploy for our use case, select
    the same from the drop-down list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, fill in the correct Application name as well as the Deployment group that
    we configured during the setup of CodeDeploy. Click on Next step once done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1d2c518e-e810-42cb-b73a-9cb322e0dfd8.png)'
  prefs: []
  type: TYPE_IMG
- en: The final step required is to configure the Service Role. The service role essentially
    grants CodePipeline permissions to use resources in your AWS account. Provide
    a suitable Role name and click on Next step to review the pipeline's configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the Review your pipeline page, ensure that all the fields are correctly configured
    and click on Create pipeline when done.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Selecting this option first creates a unique S3 bucket within your environment
    that will contain and store all the necessary artifacts for this particular pipeline.
    Once the pipeline is created, you can view it on the AWS CodePipeline dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the pipeline all set up, you can now test the entire setup as one cohesive
    solution!
  prefs: []
  type: TYPE_NORMAL
- en: 'First up, ensure that there are no errors in either of the stages during the
    deployments. In case there are any errors, simply select the particular error
    link provided in the stage and follow it back to its source, which can be anywhere
    from issues in CodeCommit to even the setting up of CodeDeploy. Here''s a screenshot
    of the pipeline that we created using an accumulation of all of the preceding
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c30e91b-5bea-434f-990b-7254d2b4b6b1.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, you can choose to add more stages to your pipeline by simply selecting
    the Edit option, as highlighted earlier. Additionally, you can also view your
    pipeline's execution history by selecting the View pipeline history option.
  prefs: []
  type: TYPE_NORMAL
- en: In the Edit pipeline page, you can choose to add one or more stages to your
    pipeline as you see fit. Simply select the + Stage option provided at the end
    of each existing stage. This will bring up a new dialog where you can specify
    the stage's Name as well as define one or more actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following use case where we need to add an approval step before
    the code actually gets pushed into the staging area. In that case, we need to
    add a new stage between the existing Source and Staging stages:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the + Stage option and provide a suitable name for this new stage.
    Next, select the + Action option to add the rules for setting up the approval
    process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Add action dialog box, start by selecting the type of action from the
    Action category drop-down list. The following list of actions can be added to
    a stage: Approval, Source, Build, Test, Deploy, and Invoke. For this use case,
    select Approval:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1fbe76eb-b778-45dc-ab77-3f728ce8f535.png)'
  prefs: []
  type: TYPE_IMG
- en: Fill in a suitable Action name and select an appropriate Action type as well.
    At present, only a Manual approval configuration option is provided by CodePipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, select either one of a pre-existing SNS topics using the SNS topic
    ARN field and click on Add action once completed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the new stage added, click on Save pipeline changes to commit the change.
    You should have a new stage added and visible in your pipeline, as shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/036a9d75-3287-41b0-af6a-48cbe498f564.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the Source stage is prepped, the pipeline automatically halts at the Approval stage,
    as depicted in the following screenshot. Here, you can approve the process by
    simply selecting the Review option and then selecting the `approval` command.
    Doing so initiates the final Staging stage which invokes the CodeDeploy service
    to deploy the WordPress code over to our awaiting EC2 instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/86c23e34-02e9-45b2-8a8d-537bea5750a8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After a few minutes, the application is successfully uploaded on the instance
    and is up and running as well. You can verify this by making a note of your instances
    public IP address and typing in the following URL on a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Remember to prefix `WordPress` in your URL since the `AppSpec` file clearly
    pointed to the root of the application at the `/var/www/html/WordPress` directory
    and not at `/var/www/html` itself.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, you can easily leverage and automate the deployments of your application
    code using the AWS Code Suite of services! Amazing isn't it? But that's not all
    folks! There is a ton of other fascinating things that I would like you to learn
    and explore, all covered in the next section itself.
  prefs: []
  type: TYPE_NORMAL
- en: Planning your next steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, we have covered a lot of new features and services in this chapter. However,
    there are still a few things that I would recommend you need to read up on your
    own as well. First up is the AWS CodeStar!
  prefs: []
  type: TYPE_NORMAL
- en: 'AWS CodeStar is an amazing service that can help developers create, manage,
    and work on developing applications, all one place. The integral part of CodeStar
    that enables this is called **projects**. Developers can create projects based
    on predefined templates that contain a supported programming model which is ready
    to use for developing. You can additionally select hosting for your application
    from a variety of options that include Amazon EC2, Elastic Beanstalk, and AWS
    Lambda as well! CodeStar comes with easy connectivity with various IDEs as well:
    Eclipse, Visual Studio, just to name a few. You can read more about *AWS CodeStar*
    at [http://docs.aws.amazon.com/codestar/latest/userguide/welcome.html](http://docs.aws.amazon.com/codestar/latest/userguide/welcome.html).'
  prefs: []
  type: TYPE_NORMAL
- en: The second awesome service worth trying out is AWS Cloud9! AWS Cloud9 is a cloud-based
    IDE that you can use to write, debug, and run code, all with a standard web browser!
    Cloud9 comes pre-packaged with essential tools for the most popular programming
    languages, including JavaScript, Python, PHP, Node.js, C++, and much more, and
    the best part is you can easily integrate Cloud9 with the likes of other AWS services,
    such as CodeCommit, CodeStar, and so on. You can read more about AWS Cloud9 at [https://docs.aws.amazon.com/cloud9/latest/user-guide/welcome.html](https://docs.aws.amazon.com/cloud9/latest/user-guide/welcome.html).
  prefs: []
  type: TYPE_NORMAL
- en: Last, but not least, I would also recommend that you try out a complete, end-to-end
    CI/CD solution provided by the **AWS Partner Network** (**APN**) blog that leverages
    a CloudFormation stack to deploy a full-fledged AWS Code Suite, including CodeBuild,
    CodeCommit, CodeDeploy, and CodePipeline! The stack gives you a feel for using
    AWS CodeBuild as a service and also provides you with a template to automate your
    own Code deployments using CloudFormation. To view the blog visit [https://aws.amazon.com/blogs/apn/deploy-to-production-using-aws-codebuild-and-the-aws-developer-tools-suite/](https://aws.amazon.com/blogs/apn/deploy-to-production-using-aws-codebuild-and-the-aws-developer-tools-suite/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here's a quick round up of the topics that we have covered so far in this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: We started off by learning and understanding a bit about the AWS Code Suite
    of services and how they tie into the continuous integration and continuous delivery
    life cycle. We then learned a bit about AWS CodeDeploy and how easy it is to get
    started with it. We created a simple CodeCommit repository and used that to store
    our sample WordPress application as well. Later, we looked at AWS CodeDeploy and
    how it works. We also configured a CodeDeploy agent and leveraged the AppSpec
    file for our WordPress application's deployment life cycle. Finally, we tied it
    all together by integrating the work done so far with AWS CodePipeline and ended
    the chapter with a few essential things to read and try out on your own!
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will be exploring two application-specific services
    and look at how you can leverage them for your requirements: Amazon SQS and Amazon
    SNS. So stay tuned!'
  prefs: []
  type: TYPE_NORMAL
