- en: Transforming Application Development Using the AWS Code Suite
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用AWS Code Suite改变应用程序开发
- en: In the previous chapter, we explored a few interesting and really useful enhancements
    made to the AWS **Identity and Access Management Service** (**IAM**) along with
    a quick deep dive into AWS Organizations as well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了AWS **身份和访问管理服务**（**IAM**）所做的一些有趣且非常有用的增强功能，以及对AWS组织的快速深入了解。
- en: 'In this chapter, we will be learning and exploring three extremely useful and
    powerful services provided by AWS that are specially catered toward enhancing
    a developer''s experience with continuous code deployments: AWS CodeCommit, AWS
    CodeDeploy, and AWS CodePipeline!'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习和探索由AWS提供的三项极其有用和强大的服务，专门为增强开发人员在持续代码部署方面的体验而设计：AWS CodeCommit、AWS
    CodeDeploy和AWS CodePipeline！
- en: 'Keeping this in mind, let''s have a quick look at the various topics that we
    will be covering in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 牢记这一点，让我们快速浏览一下本章将涵盖的各种主题：
- en: Introducing AWS CodeCommit, AWS CodeDeploy, and AWS CodePipeline along with
    each service's concepts and internal workings
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍AWS CodeCommit、AWS CodeDeploy和AWS CodePipeline以及每个服务的概念和内部工作原理
- en: Creating your first CodeCommit repository and uploading an application to it
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您的第一个CodeCommit存储库并将应用程序上传到其中
- en: Running basic Git commands against your new code repository
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行基本的Git命令来操作您的新代码存储库
- en: Configuring the CodeDeploy agent on an EC2 instance
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在EC2实例上配置CodeDeploy代理
- en: Leveraging the AppSpec file for configuring application life cycle deployment
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用AppSpec文件配置应用程序生命周期部署
- en: Creating your own continuous delivery system using CodePipeline
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CodePipeline创建您自己的持续交付系统
- en: So without any further ado, let's get started right away!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，不再拖延，让我们立即开始吧！
- en: Understanding the AWS Code Suite
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解AWS Code Suite
- en: 'Besides providing a plethora of infrastructure-related services, AWS also provides
    a few services that are designed to help developers quickly design, develop, build,
    and deploy their applications on the AWS cloud platform. In this section, we will
    have a quick look at these services and how you can leverage them together to
    build your very own continuous integration and delivery pipelines:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供大量基础设施相关的服务外，AWS还提供了一些旨在帮助开发人员快速设计、开发、构建和部署他们的应用程序在AWS云平台上的服务。在本节中，我们将快速浏览这些服务以及如何将它们结合起来利用，构建您自己的持续集成和交付流水线：
- en: '**AWS CodeCommit**: An important starting point for any CI/ CD pipeline is
    a simple yet functional source control repository. Traditionally, this would be
    set up on one or more physical servers in the form a Git or SVN repository that
    developers would use to push their code and updates to; however, maintaining such
    code repositories and scaling them was always going to be a challenge. That''s
    where AWS CodeCommit comes into play! AWS CodeCommit is a managed source control
    service that enables developers to securely store their code on the AWS cloud.
    It offers many of the features that you would require and use while working with
    different source control repositories, such as branching, commits, rollbacks,
    and much more.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS CodeCommit**：任何CI/CD流水线的重要起点是一个简单但功能强大的源代码控制存储库。传统上，这将在一个或多个物理服务器上设置为Git或SVN存储库的形式，开发人员将使用它们来推送他们的代码和更新；然而，维护这样的代码存储库并扩展它们总是具有挑战性的。这就是AWS
    CodeCommit发挥作用的地方！AWS CodeCommit是一项托管的源代码控制服务，使开发人员能够安全地将他们的代码存储在AWS云上。它提供了许多您在使用不同源代码控制存储库时需要和使用的功能，如分支、提交、回滚等。'
- en: '**AWS CodeBuild**: AWS CodeBuild is a code build service that developers can
    leverage to automate their source code compilations, tests, executions, and code
    packaging for deployments. Similar to its other counterpart services in the Code
    Suite, CodeBuild too is managed completely by AWS, thus eliminating any unnecessary
    administrative overheads, such as patching or scaling the code build software.
    CodeBuild is highly extensible and it also easily integrates with your existing
    CI/CD workflows as well.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS CodeBuild**：AWS CodeBuild是开发人员可以利用的代码构建服务，用于自动化他们的源代码编译、测试、执行和代码打包以进行部署。与Code
    Suite中的其他对应服务类似，CodeBuild也完全由AWS管理，从而消除了任何不必要的管理开销，如修补或扩展代码构建软件。CodeBuild具有高度可扩展性，也很容易与您现有的CI/CD工作流程集成。'
- en: '**AWS CodeDeploy**: With your application code stored securely and compiled,
    the final step requires the code to be deployed across your fleet of EC2 instances.
    This can be easily achieved with the help of our next Code Suite service, called
    AWS CodeDeploy. Using CodeDeploy, a developer can automate code deployments to
    any environment that runs off of either EC2 instances as well as servers that
    are running in an on-premise datacenter. CodeDeploy essentially eliminates deployment
    complexities by allowing you to automate the delivery of your code across thousands
    of instances without having to undergo any major downtimes.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS CodeDeploy**：当你的应用代码安全地存储并编译完成后，最后一步是将代码部署到你的 EC2 实例群集中。这可以通过我们下一个 Code
    套件服务，即 AWS CodeDeploy 来轻松实现。使用 CodeDeploy，开发人员可以自动将代码部署到运行 EC2 实例或本地数据中心服务器的任何环境。CodeDeploy
    本质上通过让你自动化代码交付至数千个实例，消除了部署复杂性，无需经历任何长时间的停机。'
- en: '**AWS CodePipeline**: AWS CodePipeline is a full fledge CI/CD service provided
    by AWS that developers can leverage to build end-to-end CI/CD pipelines either
    by using the AWS Code Suite of services or even with other popular third-party
    tools, such as GitHub, Jenkins, and so on. Using CodePipeline, you can also create
    and define custom software release models using which your application gets updated
    with the latest set of updates, tested, and packaged as well for the next iterative
    set of deployments.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS CodePipeline**：AWS CodePipeline 是 AWS 提供的一个完整的 CI/CD 服务，开发人员可以利用它构建端到端的
    CI/CD 流水线，既可以使用 AWS Code 套件服务，也可以使用其他流行的第三方工具，如 GitHub、Jenkins 等。使用 CodePipeline，你还可以创建和定义自定义的软件发布模型，通过这些模型，你的应用程序会更新最新的一系列更新，进行测试，并为下一个迭代的部署进行打包。'
- en: 'Here is a brief representation of how these services map together collaboratively
    to create a comprehensive CI/CD pipeline:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这些服务如何协同工作以创建一个完整的 CI/CD 流水线的简要表示：
- en: '![](img/6e3d7b23-e812-4d55-ba50-ad84c36c0288.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e3d7b23-e812-4d55-ba50-ad84c36c0288.png)'
- en: 'For the purpose of this chapter, however, we will be working with only three
    AWS Code Suite services, namely AWS **CodeCommit**, AWS **CodeDeploy**, and AWS
    **CodePipeline**. The chapter will showcase how these three services can be leveraged
    together to build your very own CI/CD pipelines for our sample WordPress application.
    Here is a high-level depiction of our overall use case:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，出于本章的目的，我们将只使用三个 AWS Code 套件服务，即 AWS **CodeCommit**、AWS **CodeDeploy** 和
    AWS **CodePipeline**。本章将展示如何将这三种服务结合起来，构建适用于我们示例 WordPress 应用的 CI/CD 流水线。以下是我们整体用例的高层次示意图：
- en: '![](img/ea5db7c2-66dd-46e7-b588-94de46987c18.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea5db7c2-66dd-46e7-b588-94de46987c18.png)'
- en: With the basic understanding of the Code Suite services out of the way, let's
    learn a bit more about AWS CodeCommit and how you can leverage it as your very
    own source code repository!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在对 Code 套件服务有了基本了解后，让我们深入了解 AWS CodeCommit，看看如何将它作为你自己的源代码仓库来使用！
- en: Getting Started with AWS CodeCommit
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 AWS CodeCommit
- en: 'As discussed earlier, AWS CodeCommit is a secure and highly scalable source
    control service which allows you to create multiple private Git repositories without
    having to bother about any of the underlying management overheads. You can use
    it to store anything, from code, to application binaries, to even code packages,
    all using the standard Git-like functionality. This makes CodeCommit extremely
    easy to work with even if you have not used it before. Here is the gist of some
    of the most commonly used Git commands and how you can leverage them with CodeCommit:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，AWS CodeCommit 是一个安全且高度可扩展的源代码控制服务，允许你创建多个私有 Git 仓库，而无需担心底层的管理工作。你可以用它来存储任何东西，从代码到应用程序二进制文件，再到代码包，所有这些都使用标准的
    Git 类似功能。这使得即使你之前没有使用过 CodeCommit，它也极其易于使用。以下是一些最常用的 Git 命令的要点，以及你如何在 CodeCommit
    中利用它们：
- en: '`git clone`: Used to clone and connect the AWS CodeCommit repository over to
    your local development server.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git clone`：用于将 AWS CodeCommit 仓库克隆并连接到你的本地开发服务器。'
- en: '`git add`: Once the repository is cloned locally, you can use it to add, edit,
    or delete files as you see fit. Once done, use the `git add` command to stage
    the modifications in your local Git repository.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git add`：一旦将仓库克隆到本地，你可以根据需要添加、编辑或删除文件。完成后，使用 `git add` 命令将修改暂存到本地 Git 仓库。'
- en: '`git commit`: Used to commit the modifications made to the files to the local
    Git repository.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git commit`：用于将对文件所做的修改提交到本地 Git 仓库。'
- en: '`git push`: Used to push the committed files and changes over to the AWS CodeCommit
    repository.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git push`：用于将提交的文件和更改推送到 AWS CodeCommit 仓库。'
- en: '`git pull`: Used to ensure that the files you are working on are synced and
    are of the latest version from the AWS CodeCommit repository.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git pull`：用于确保您正在处理的文件是最新版本，并且与 AWS CodeCommit 仓库中的版本保持同步。'
- en: 'In this section, we will be looking at a few simple steps to enable you to
    create your very own source code repository using the AWS Management Console.
    However, before we move on to that, it is important to understand some of the
    different connections that you can use to connect to your CodeCommit repository.
    This can vary based on your development environments as well as security requirements:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一些简单步骤，帮助您通过 AWS 管理控制台创建您自己的源代码仓库。然而，在我们继续之前，了解可以用来连接 CodeCommit 仓库的几种不同连接方式是非常重要的。连接方式可能会根据您的开发环境以及安全要求而有所不同：
- en: '**Using the HTTPS connections**: Configuring Git credentials using HTTPS connections
    is by far the simplest and most widely used method for connecting to your Git
    repository. With this set up, you simply generate a static username and password
    using AWS IAM. Once the credentials are created, you can then use them with Git
    and any third-party tool, such as an IDE, for authentication.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 HTTPS 连接**：通过 HTTPS 连接配置 Git 凭据是目前最简单和最广泛使用的连接 Git 仓库的方法。设置完成后，您只需使用 AWS
    IAM 生成一个静态用户名和密码。一旦凭据创建完成，您就可以在 Git 和任何第三方工具（如 IDE）中使用它们进行身份验证。'
- en: '**Using the SSH connections**: In this case, a user will be required to create
    public and private key files on your local development server that Git and AWS
    CodeCommit can use for SSH authentication. The public key generated in this process
    gets associated with your IAM user, whereas the private key remains on the local
    development server. The generation of the keys varies from operating system to
    operating system and can be a tedious process at times to manage.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 SSH 连接**：在这种情况下，用户需要在本地开发服务器上创建公钥和私钥文件，Git 和 AWS CodeCommit 将使用这些密钥进行
    SSH 身份验证。此过程中生成的公钥与您的 IAM 用户关联，而私钥则保留在本地开发服务器上。密钥的生成过程因操作系统而异，有时可能会是一个繁琐的过程。'
- en: 'For this section, however, we will be leveraging the SSH connections method
    itself for connecting to our AWS CodeCommit repository:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在本节中，我们将利用 SSH 连接方法本身来连接到我们的 AWS CodeCommit 仓库：
- en: To get started, first log in to your AWS Management Console and filter the IAM
    service using the Filter option provided. Alternatively, you can also select URL
    [https://console.aws.amazon.com/iam/](https://console.aws.amazon.com/iam/) to
    view the IAM dashboard.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，登录到 AWS 管理控制台，并使用提供的“筛选器”选项筛选 IAM 服务。或者，您也可以选择 URL [https://console.aws.amazon.com/iam/](https://console.aws.amazon.com/iam/)
    来查看 IAM 控制台。
- en: Here, we will start off by creating a dedicated user that will have full management
    rights to our CodeCommit repository. Select the Users option from the IAM dashboard's
    navigation pane to bring up the list of currently created IAM users.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们将从创建一个专门的用户开始，该用户将拥有对我们的 CodeCommit 仓库的完整管理权限。从 IAM 控制台的导航面板中选择“用户”选项，以显示当前创建的
    IAM 用户列表。
- en: Next, select the Add user option. This will bring up the Add user page where
    you can provide a suitable User name as well as opt for the user's Access type.
    In this case, the CodeCommit user will only require Programmatic access. Click
    Next to proceed.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择“添加用户”选项。这将打开“添加用户”页面，您可以在此页面上提供适当的用户名，并选择该用户的访问类型。在这种情况下，CodeCommit 用户仅需要编程访问权限。点击“下一步”继续。
- en: 'Moving on, in the Permissions page, we are required to filter and attach the
    `AWSCodeCommitFullAccess` policy to our newly created user. To do so, select the
    Attach existing policies directly option and select the `AWSCodeCommitFullAccess` policy,
    as shown in the following screenshot. Alternatively, you can also provide a customized
    access policy here based on your requirements:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在权限页面中，我们需要筛选并将 `AWSCodeCommitFullAccess` 策略附加到新创建的用户。为此，选择“直接附加现有策略”选项，并选择
    `AWSCodeCommitFullAccess` 策略，如下图所示。或者，您也可以根据需求在此处提供自定义访问策略：
- en: '![](img/7fe3b055-8f07-4ffc-9425-639d123653f6.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fe3b055-8f07-4ffc-9425-639d123653f6.png)'
- en: Complete the user creation process by reviewing the changes and making a note
    of the user's new access and secret keys as well.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成用户创建过程时，请审查更改并记下该用户的新访问密钥和秘密密钥。
- en: 'At this point, with your CodeCommit IAM user created, we now move on to the
    next part of this section where we create and configure a set of public and private
    keys for the IAM user, using a simple Linux-based development server. Follow URL [http://docs.aws.amazon.com/codecommit/latest/userguide/setting-up-ssh-windows.html](http://docs.aws.amazon.com/codecommit/latest/userguide/setting-up-ssh-windows.html) if
    you are using a Windows operating system as your development server:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，随着CodeCommit IAM用户的创建，我们进入本节的下一部分，即为IAM用户创建和配置一对公钥和私钥，使用一个简单的基于Linux的开发服务器。如果你使用的是Windows操作系统作为开发服务器，请访问URL
    [http://docs.aws.amazon.com/codecommit/latest/userguide/setting-up-ssh-windows.html](http://docs.aws.amazon.com/codecommit/latest/userguide/setting-up-ssh-windows.html)：
- en: 'Log in to your development server and run the following command to generate
    the new set of keys:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到开发服务器并运行以下命令生成新的密钥对：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When prompted, save the keys in the following directory structure:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提示时，将密钥保存在以下目录结构中：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Make a note of the public and private keys'' locations, as depicted in the
    following screenshot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 记下公钥和私钥的位置，如下图所示：
- en: '![](img/495a035a-aed2-4591-ad52-5155b48b7e98.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/495a035a-aed2-4591-ad52-5155b48b7e98.png)'
- en: 'Next, display and copy the public key''s contents, using the following command.
    Note the public key will be saved in the file with a `.pub` extension:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用以下命令显示并复制公钥的内容。注意，公钥将保存在以`.pub`扩展名结尾的文件中：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Log in to your IAM dashboard once again and select the newly created user from
    the Users page. Select the user's Security Credentials tab. Here, under the SSH
    keys for AWS CodeCommit section, click on Upload SSH public key to paste the entire
    copied text from the earlier step.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次登录到IAM控制台并从用户页面中选择新创建的用户。选择该用户的“安全凭证”选项卡。在AWS CodeCommit的SSH密钥部分，点击“上传SSH公钥”并粘贴之前步骤中复制的完整文本。
- en: 'Once completed, you should now see a unique key auto-generated under the SSH
    key ID column, as shown in the following screenshot. Copy this SSH key ID as we
    will be requiring it in the next steps:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，你应该能看到一个在SSH密钥ID列下自动生成的唯一密钥，如下图所示。复制此SSH密钥ID，因为在接下来的步骤中我们需要它：
- en: '![](img/baf12b4f-1415-4f5b-ae4c-211bae5c221f.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/baf12b4f-1415-4f5b-ae4c-211bae5c221f.png)'
- en: 'With the public key uploaded to IAM and the new SSH key ID generated, the final
    step is to create a simple `config` file in your local development server with
    the following contents pasted into it:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将公钥上传到IAM并生成新的SSH密钥ID后，最后一步是在本地开发服务器中创建一个简单的`config`文件，并将以下内容粘贴到文件中：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Save the file once done. Remember to modify the permissions of your `config` file
    before moving on to the verification step:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后保存文件。在继续验证步骤之前，记得修改`config`文件的权限：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To verify the connectivity, simply use the following command to SSH to the
    AWS CodeCommit endpoint. Since this will be a first connect, you will be prompted
    to verify the connection for authenticity. Type in `yes` when prompted:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证连接，只需使用以下命令SSH连接到AWS CodeCommit端点。由于这是首次连接，你将被提示验证连接的真实性。提示时输入`yes`：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The endpoint you use will be specific to the AWS region that you operate out
    of. You can view the list of region-specific CodeCommit URLs along with the availability
    of the CodeCommit service at [http://docs.aws.amazon.com/codecommit/latest/userguide/regions.html](http://docs.aws.amazon.com/codecommit/latest/userguide/regions.html).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用的端点将特定于你所在的AWS区域。你可以查看区域特定的CodeCommit URLs列表以及CodeCommit服务的可用性，访问[http://docs.aws.amazon.com/codecommit/latest/userguide/regions.html](http://docs.aws.amazon.com/codecommit/latest/userguide/regions.html)。
- en: With this step, we have successfully validated and connected our development
    server with the AWS CodeCommit service! But where is our CodeCommit repository?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此步骤后，我们成功验证并连接了开发服务器与AWS CodeCommit服务！但我们的CodeCommit存储库在哪里？
- en: To create the repository, log in to the AWS CodeCommit service using URL [https://console.aws.amazon.com/codecommit](https://console.aws.amazon.com/codecommit).
    Remember to change the Region based on what you selected during the key verification
    state.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建存储库，请通过URL [https://console.aws.amazon.com/codecommit](https://console.aws.amazon.com/codecommit)登录AWS
    CodeCommit服务。记得根据在密钥验证阶段选择的区域更改区域。
- en: 'Since this is our first time working with CodeCommit, select the Get Started option
    to begin with. This will display the Create repository page, as shown in the following
    screenshot:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这是我们第一次使用CodeCommit，请选择“Get Started”选项开始。这将显示创建存储库页面，如下图所示：
- en: '![](img/bcb3f74e-2d2b-4fce-abb0-176341c6a6f9.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bcb3f74e-2d2b-4fce-abb0-176341c6a6f9.png)'
- en: Provide a suitable Repository name and an optional Description. Click on Create
    repository once done.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个合适的仓库名称，并填写可选的描述。完成后点击“创建仓库”。
- en: You can additionally configure notifications for specific Event types, such
    as pull requests and commits made to your repo in the Configure email notifications page.
    Simply select an existing SNS topic or opt to Create a new topic based on your
    requirements. Once done, click on Save to complete the repository creation process.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还可以在“配置电子邮件通知”页面中，为特定的事件类型（如拉取请求和对你仓库的提交）配置通知。只需选择一个现有的SNS主题，或者根据需要选择“创建新主题”。完成后，点击“保存”以完成仓库创建过程。
- en: 'With the repository created, you can now use the development server and connect
    to it using a simple `git clone` command. You can obtain your repository''s connection
    URL anytime by simply selecting the Connect option present on the Code page:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库创建完成后，你可以使用开发服务器，并通过简单的`git clone`命令连接到它。你可以随时通过选择Code页面上的“连接”选项来获取仓库的连接URL：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here''s a snapshot of the first `git clone` command output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一次执行`git clone`命令的输出快照：
- en: '![](img/e3a3932d-ee79-422d-90c0-e441dafb63b9.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3a3932d-ee79-422d-90c0-e441dafb63b9.png)'
- en: Since the repository is empty, the cloning process simply creates a folder with
    your repository's name on your development server. You can now use this folder
    as a code source control by simply adding your program files, binaries, and other
    application-specific data to it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于仓库为空，克隆过程仅会在你的开发服务器上创建一个与仓库名称相同的文件夹。现在，你可以将该文件夹作为代码源控制，只需将程序文件、二进制文件和其他应用程序特定的数据添加到其中。
- en: In the next section, we will be using this repository as our WordPress application
    source control and explore a few simple commands and features that are provided
    as a part of AWS CodeCommit.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分中，我们将使用该仓库作为我们的WordPress应用程序源控制，并探索AWS CodeCommit提供的一些简单命令和功能。
- en: Working with branches, commits, and triggers
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与分支、提交和触发器一起工作
- en: With your CodeCommit repo created, it's now time to go ahead and use this repository
    as our source control repository. To do so, we will first push a standard WordPress
    application from our local development server to the AWS CodeCommit repository
    using simple Git commands and later run a few more Git commands as well as AWS
    actions to branch and commit our code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了CodeCommit仓库后，现在是时候将该仓库用作我们的源控制仓库了。为此，我们将首先使用简单的Git命令将本地开发服务器上的标准WordPress应用程序推送到AWS
    CodeCommit仓库，并稍后运行更多Git命令和AWS操作，以分支和提交我们的代码。
- en: 'You can obtain a WordPress application ZIP file by downloading it from here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过从这里下载WordPress应用程序的ZIP文件：
- en: '[https://github.com/WordPress/WordPress](https://github.com/WordPress/WordPress)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/WordPress/WordPress](https://github.com/WordPress/WordPress)'
- en: 'To begin with, first we will need to copy the WordPress application contents
    over to our local repository that was cloned earlier:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将WordPress应用程序的内容复制到之前克隆的本地仓库中：
- en: 'Once the WordPress application is downloaded to your local development server,
    simply unzip and copy its contents over to the local repository. Your local repository
    should now show a folder structure similar to the following screenshot:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦WordPress应用程序下载到本地开发服务器，只需解压并将其内容复制到本地仓库。你的本地仓库现在应该显示出类似以下截图的文件夹结构：
- en: '![](img/15239bc3-a5e8-4b6e-b3bb-4bc2e291f633.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/15239bc3-a5e8-4b6e-b3bb-4bc2e291f633.png)'
- en: 'With the code in place, simply use the following Git commands to commit and
    push the code over to your AWS CodeCommit repository. First up, stage the files
    using the `git add` command:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码准备好后，只需使用以下Git命令提交并将代码推送到你的AWS CodeCommit仓库。首先，使用`git add`命令暂存文件：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, commit the changes using the `git commit` command:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用`git commit`命令提交更改：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And, finally, push the commit over to the AWS CodeCommit repository. Here,
    the keyword `origin` is the default remote name used by Git for your AWS CodeCommit
    repository, whereas `master` is the default branch name:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将提交推送到AWS CodeCommit仓库。在这里，`origin`是Git用于你AWS CodeCommit仓库的默认远程名称，而`master`是默认的分支名称：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should see the code get uploaded to your AWS CodeCommit repository, as
    shown in the following image. You can cross-verify this by refreshing and checking
    the Code page on your AWS CodeCommit dashboard as well:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该能看到代码已上传到你的AWS CodeCommit仓库，如下图所示。你可以通过刷新并检查AWS CodeCommit仪表板上的Code页面来交叉验证：
- en: '![](img/fac448f3-bb8b-45ef-961e-5261da4ba809.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fac448f3-bb8b-45ef-961e-5261da4ba809.png)'
- en: Similarly, you and your fellow developers can edit and commit the code back
    to the AWS CodeCommit repository. You can also create multiple branches of your
    repository so that developers can work independently on the code without affecting
    the `master` branch. Once the features are all thoroughly tested and verified,
    the individual developer branches can be merged into a more stable `master` branch
    of the software.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你和其他开发人员可以编辑并提交代码到 AWS CodeCommit 仓库。你还可以创建多个仓库分支，以便开发人员可以独立工作，而不会影响 `master`
    分支。一旦功能经过充分测试并验证后，单独的开发者分支可以合并到更稳定的 `master` 分支中。
- en: 'Creating a branch in CodeCommit is an extremely easy process! You can use the
    CodeCommit dashboard, the Git command line, or even the AWS CLI to create one
    of your own:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CodeCommit 中创建分支是一个非常简单的过程！你可以使用 CodeCommit 仪表盘、Git 命令行，甚至 AWS CLI 来创建属于你自己的分支：
- en: To create a branch using the AWS CodeCommit dashboard, simply select the Branches option
    from the navigation pane.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要通过 AWS CodeCommit 仪表盘创建分支，只需从导航面板中选择 Branches 选项。
- en: Next, select the Create branch option to bring up the Create branch page. Here,
    provide a suitable Branch name and also select where you would like this new branch
    to Branch from. In this case, since you only have the `master` branch created,
    you can select that for now. Click on Create once done.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择 Create branch 选项，进入创建分支页面。在这里，提供一个合适的 Branch name，并选择你希望新分支从哪个分支创建。在这种情况下，由于你只创建了
    `master` 分支，因此可以选择它。完成后点击 Create。
- en: 'You can also use the Git command line itself to achieve the same result. In
    this case, from the development server, type in the following command to create
    a new branch:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以使用 Git 命令行来实现相同的效果。在这种情况下，从开发服务器上输入以下命令以创建新分支：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![](img/4d4cbea3-5d37-4ac6-8bee-738615e8e4ba.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d4cbea3-5d37-4ac6-8bee-738615e8e4ba.png)'
- en: With the new branch created, you can also use the Compare functionality provided
    by CodeCommit to compare the changes made to the branch against another branch.
    To do so, we first need to perform some changes in the application so that it
    can get reflected as a change.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新分支后，你还可以使用 CodeCommit 提供的 Compare 功能，将分支的更改与另一个分支进行比较。为此，我们首先需要在应用程序中进行一些更改，以便这些更改能够反映出来。
- en: 'Without changing the current branch of the repository, simply update any one
    of the WordPress files by adding or removing a comment. In my case, I simply made
    a few comment changes in the WordPress application''s `index.php` file; however,
    feel free to modify any other file as you see fit. Once the changes are made,
    we once again need to stage, commit, and push the changes over to the new branch
    of our repository:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在不更改当前仓库分支的情况下，简单地通过添加或删除注释来更新 WordPress 文件。在我的案例中，我仅在 WordPress 应用程序的 `index.php`
    文件中做了一些注释更改；但是，你可以根据需要修改任何其他文件。一旦完成更改，我们需要再次进行暂存、提交并将更改推送到我们仓库的新分支：
- en: 'Stage the changes by using the `git add` command. You can either add all the
    files for staging by using `*` or even specify the filename you wish to stage
    as well:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `git add` 命令暂存更改。你可以使用 `*` 将所有文件添加到暂存区，也可以指定你希望暂存的文件名：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, commit the changes using the `git commit` command:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用 `git commit` 命令提交更改：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And, finally, push the changes over to the branch using the following command:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用以下命令将更改推送到分支：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With the changes pushed, use the Compare option provided under the Commits section
    in the CodeCommit dashboard. Here, select the master as the *source* branch and
    the branch that you created using the Git command line as the Destination branch.
    Click on Compare once done. You should see the changes compared, as shown in the
    following screenshot:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在推送更改后，在 CodeCommit 仪表盘中的 Commits 部分使用 Compare 选项。在这里，选择 **master** 作为 *源* 分支，选择你通过
    Git 命令行创建的分支作为目标分支。完成后点击 Compare。你应该会看到所做的更改进行比较，如下图所示：
- en: '![](img/1a7930dc-5e9b-464a-be5d-744725a7061a.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a7930dc-5e9b-464a-be5d-744725a7061a.png)'
- en: You can use the Go to file drop-down list to toggle between different files,
    if you have made changes in them. Alternatively, you can also use the Unified and
    Split views to change the visual comparison as you see fit.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在多个文件中做了更改，你可以使用 Go to file 下拉列表在不同文件之间切换。或者，你还可以使用 Unified 和 Split 视图来根据需要更改视觉比较方式。
- en: 'CodeCommit also provides an additional feature called **triggers** that you
    can use to either send notifications to or run some other external code build
    or process. You can assign up to 10 triggers per repository that you create, however,
    at the time of writing this book, CodeCommit only supports AWS SNS and AWS Lambda
    as its trigger mechanisms:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: CodeCommit 还提供了一个额外的功能，叫做 **触发器**，你可以用它来发送通知或运行其他外部的代码构建或处理过程。你可以为每个创建的仓库分配最多
    10 个触发器，但在撰写本书时，CodeCommit 只支持 AWS SNS 和 AWS Lambda 作为触发机制：
- en: To create a simple trigger, using the CodeCommit dashboard, select the Settings tab
    from the navigation pane. Here, select the Triggers tab to create as well as view
    the list of existing triggers, if any.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个简单的触发器，使用 CodeCommit 仪表盘，从导航面板中选择“设置”选项卡。在这里，选择“触发器”选项卡，以创建和查看现有的触发器列表（如果有的话）。
- en: Select the Create trigger option to bring up the Create trigger page. Here,
    you can configure triggers in response to certain repository events, such as Push
    to an existing branch, Create branch or tag, Delete branch or tag, or All repository
    events.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“创建触发器”选项以打开“创建触发器”页面。在这里，你可以根据某些仓库事件配置触发器，例如推送到现有分支、创建分支或标签、删除分支或标签，或者所有仓库事件。
- en: Provide a Trigger name and select the appropriate Events and Branch name that
    you wish to associate the trigger with. Once done, you can configure the trigger
    to either use an existing SNS topic or a Lambda function as its Service. You can
    even test the functioning of the trigger by selecting the Test trigger option.
    This will simulate a trigger based on the *event* that you would have selected
    earlier.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供触发器名称，并选择你希望与触发器关联的适当事件和分支名称。完成后，你可以将触发器配置为使用现有的 SNS 主题或 Lambda 函数作为其服务。你甚至可以通过选择“测试触发器”选项来测试触发器的功能。这将根据你之前选择的
    *事件* 模拟触发器。
- en: In this way, you can configure triggers for sending notifications to your developers
    as well as trigger-specific Lambda functions based on your repository's requirements.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，你可以根据仓库的需求配置触发器，以便向开发人员发送通知并触发特定的 Lambda 函数。
- en: Introducing AWS CodeDeploy
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 AWS CodeDeploy。
- en: With CodeCommit configured and ready to use for our WordPress application, we
    can now move on to yet another Code Suite service that can actually be used to
    deploy the code across thousands of EC2 instances! Here's introducing AWS CodeDeploy!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 CodeCommit 配置好并为我们的 WordPress 应用程序做好准备后，我们可以继续使用另一个可以实际将代码部署到成千上万 EC2 实例的
    Code Suite 服务！这就是 AWS CodeDeploy 的介绍！
- en: AWS CodeDeploy is basically a deployment service that allows you to automate
    the deployment of your applications to Amazon EC2 instances, Lambda functions,
    or even to on-premise instances. There is no limit to what an AWS CodeDeploy service
    can deploy. You can use it for deploying virtually anything from code, packages,
    binaries, scripts, files, and so on. As of writing this book, CodeDeploy only
    supports GitHub repositories and Amazon S3 buckets as the default application
    content repositories. Yes, you heard it right, CodeDeploy does not support CodeCommit
    as a repository source as of now.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CodeDeploy 本质上是一个部署服务，允许你自动化将应用程序部署到 Amazon EC2 实例、Lambda 函数，甚至本地实例。AWS
    CodeDeploy 的部署内容没有限制。你可以使用它部署几乎任何内容，从代码、包、二进制文件、脚本、文件等。到目前为止，CodeDeploy 仅支持 GitHub
    仓库和 Amazon S3 存储桶作为默认的应用内容仓库。是的，你没听错，目前 CodeDeploy 不支持 CodeCommit 作为仓库源。
- en: 'Besides the automation, CodeDeploy also provides you with the following set
    of useful benefits. It allows you to:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 除了自动化之外，CodeDeploy 还为你提供了一系列有用的好处。它使你能够：
- en: Quickly create new prototype software and deploy at scale without manual interventions
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速创建新的原型软件并大规模部署，无需人工干预。
- en: Easily update to your application code without any downtime
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻松更新你的应用程序代码，而无需任何停机。
- en: Rollback deployments in case of any errors
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在出现错误时回滚部署。
- en: Scale your deployment from one to a thousand instances, all without disrupting
    to your existing applications
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的部署规模从一个实例扩展到一千个实例，而且不会中断现有应用程序的运行。
- en: In this section of the chapter, we will be looking at how to set up CodeDeploy
    for our own application deployments, but before we get into that, here's a quick
    look at some of CodeDeploy's essential concepts.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这一部分，我们将探讨如何为我们自己的应用程序部署设置 CodeDeploy，但在此之前，先简要了解一下 CodeDeploy 的一些基本概念。
- en: Concepts and terminologies
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概念和术语。
- en: 'CodeDeploy essentially comprises two main configurable sections that can be
    broadly classified as deployments and applications. Here''s a look at each of
    these concepts:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: CodeDeploy本质上由两个主要的可配置部分组成，可以广泛地分类为部署和应用程序。以下是这些概念的详细介绍：
- en: '**Applications:** Applications here imply simple names that are used by CodeDeploy
    to identify individual application codes targeted for specific deployments. An
    application can be deployed either on an EC2 instance, an on-premise instance,
    as well as on a serverless compute platform, such as AWS Lambda.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序**：这里的应用程序指的是CodeDeploy用来识别针对特定部署的单个应用程序代码的简单名称。应用程序可以部署到EC2实例、本地实例，也可以部署到无服务器计算平台，如AWS
    Lambda。'
- en: '**Deployments**: Deployments are a collection of deployment configurations
    and deployment types, including:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署**：部署是部署配置和部署类型的集合，包括：'
- en: '**Deployment configurations**: Deployment configurations are a set of simple
    rules that determine how fast an application will be deployed and the success
    or failure conditions for that particular deployment. For example, for an EC2
    deployment, the configuration rules can dictate the required minimum number of
    healthy instances, whereas with a Lambda function deployment, these rules can
    be used to specify how the traffic is routed to the functions during a deployment.'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署配置**：部署配置是一组简单的规则，决定了应用程序的部署速度以及该部署的成功或失败条件。例如，对于EC2部署，配置规则可以指定所需的最小健康实例数量，而对于Lambda函数部署，这些规则可以用来指定部署期间流量如何路由到这些函数。'
- en: '**Deployment group**: This is a group of EC2 or on-premise instances that are
    either standalone or a part of an auto-scaling group. Since AWS Lambda is a managed
    service, it does not provide any deployment groups.'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署组**：这是一个由EC2或本地实例组成的组，这些实例可以是独立的，也可以是自动扩展组的一部分。由于AWS Lambda是一个托管服务，它不提供任何部署组。'
- en: '**Deployment types**: Deployment types indicate the type of method used to
    get the latest version of your application deployed on a particular deployment
    group. There are two deployment types supported:'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署类型**：部署类型指示用于将应用程序的最新版本部署到特定部署组的方法类型。支持两种部署类型：'
- en: '**In-place deployments**: In this case, the application running on each EC2
    instance is stopped, updated, started, and verified. This form of deployment is
    only supported for EC2 and on-premise instances.'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原地部署**：在这种情况下，每个EC2实例上运行的应用程序会被停止、更新、启动并进行验证。这种部署方式仅支持EC2和本地实例。'
- en: '**Blue/green deployments**: In this scenario, the underlying instances are
    replaced by newer instances with the updated piece of code. The instances are
    registered to an **Elastic Load Balancer** (**ELB**) that routes traffic to the
    newer instances while the older instances can then be terminated. With the serverless
    platform, the traffic here too is shifted automatically by AWS from the current
    Lambda functions to the current updated ones. Note that all Lambda deployments
    are in fact blue/green deployments only.'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蓝绿部署**：在这种情况下，底层实例会被新版本的实例替换，这些新实例运行更新后的代码。这些实例会注册到**Elastic Load Balancer**（**ELB**），ELB将流量路由到新的实例，而旧的实例则可以被终止。在无服务器平台上，流量也会自动由AWS从当前的Lambda函数切换到更新后的Lambda函数。请注意，所有的Lambda部署实际上都是蓝绿部署。'
- en: '**CodeDeploy agent**: CodeDeploy agent is a simple software package that gets
    installed on either an EC2 or an on-premise instance and is used by CodeDeploy
    for setting up and working with application deployments. Once the agent is installed
    on an instance, an associated configuration file is created. This file contains
    application-specific directory paths and other settings that CodeDeploy uses to
    interact with the instances. The file is a simple YAML file and can be located
    in the following directories based on the instance''s operating system:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CodeDeploy代理**：CodeDeploy代理是一个简单的软件包，安装在EC2实例或本地实例上，并由CodeDeploy用于设置和管理应用程序部署。一旦代理安装在实例上，会生成一个关联的配置文件。该文件包含应用程序特定的目录路径以及其他CodeDeploy用来与实例交互的设置。该文件是一个简单的YAML文件，基于实例的操作系统，可以位于以下目录：'
- en: '**Amazon Linux, Ubuntu, RedHat Enterprise Linux**: `/etc/codedeploy-agent/conf/codedeployagent.yml`'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amazon Linux、Ubuntu、RedHat Enterprise Linux**：`/etc/codedeploy-agent/conf/codedeployagent.yml`'
- en: '**Windows Servers**: `C:ProgramDataAmazonCodeDeployconf.yml`'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows服务器**：`C:ProgramDataAmazonCodeDeployconf.yml`'
- en: '**Application specification files**: Application specification files, or AppSpec
    files, are used to define and manage individual deployments as a series of life
    cycle event hooks. Each hook itself can be another file, such as a simple script
    to start or stop services, install dependencies, and so on. AppSpec files are
    supported in both JSON as well as YAML formats. At the time of the deployment,
    the AWS CodeDeploy agent looks up the name of the current event in the hooks section
    of the AppSpec file. If an event is found, the agent retrieves the list of scripts
    to execute and runs them sequentially in the order in which they were written
    in the AppSpec file.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序规范文件**：应用程序规范文件，或称AppSpec文件，用于将单个部署定义为一系列生命周期事件钩子。每个钩子本身可以是另一个文件，例如启动或停止服务、安装依赖项等的简单脚本。AppSpec文件支持JSON和YAML格式。在部署时，AWS
    CodeDeploy代理会在AppSpec文件的钩子部分查找当前事件的名称。如果找到该事件，代理将检索要执行的脚本列表，并按它们在AppSpec文件中的顺序依次运行这些脚本。'
- en: With the basics out of the way, let's quickly look at how we can set up an EC2
    instance to be used with CodeDeploy.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 完成基本设置后，让我们快速看一下如何设置一个EC2实例，以便与CodeDeploy一起使用。
- en: Installing and configuring the CodeDeploy agent
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置CodeDeploy代理
- en: 'Before we begin with the actual launch of our EC2 instance with the CodeDeploy
    agent installed on it, we need to set up an EC2 instance profile as well as an
    instance role that will grant our EC2 instances the necessary permissions to interact
    with both CodeCommit as well as with CodeDeploy:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实际启动安装了CodeDeploy代理的EC2实例之前，我们需要设置EC2实例配置文件以及实例角色，这将授予我们的EC2实例与CodeCommit和CodeDeploy交互所需的权限：
- en: To get started, first log in to the AWS Management Console and select the IAM service
    from the services Filter. Alternatively, you can launch the IAM dashboard by selecting
    URL [https://console.aws.amazon.com/iam/](https://console.aws.amazon.com/iam/).
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，登录到AWS管理控制台，从服务过滤器中选择IAM服务。或者，您也可以通过选择网址[https://console.aws.amazon.com/iam/](https://console.aws.amazon.com/iam/)来启动IAM仪表板。
- en: From the IAM dashboard, select the Policies option from the navigation pane
    to bring up the IAM Policies page. Here, click on Create policy to get started.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从IAM仪表板中，选择导航窗格中的“策略”选项，以打开IAM策略页面。然后，点击“创建策略”开始。
- en: 'In the Create policy page, select the JSON tab and paste the following lines
    of the policy document:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“创建策略”页面，选择JSON标签并粘贴以下策略文档内容：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The policy document essentially provides the EC2 instance with the required
    set of permissions to interact with the likes of AWS services, such as CodeDeploy,
    CodeCommit, and CodePipeline.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 策略文档基本上为EC2实例提供了与AWS服务（如CodeDeploy、CodeCommit和CodePipeline）交互所需的权限集。
- en: Click on Review policy once done. In the final Review policy page, provide a
    suitable Name for the policy and click Create policy to complete the process.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后点击“审核策略”。在最终的“审核策略”页面，提供一个合适的策略名称，并点击“创建策略”以完成过程。
- en: With the policy created, we now simply assign this to a new IAM Role. To do
    so, select the Roles option from the navigation pane to bring up the IAM Roles page.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建策略后，我们现在只需将其分配给一个新的IAM角色。为此，从导航窗格中选择“角色”选项，以打开IAM角色页面。
- en: 'Click on Create role to start the wizard. From the Select type of trusted entity section,
    make sure you select AWS service and filter out EC2 from there. Click on Next:
    Permissions to proceed.'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“创建角色”以启动向导。在“选择可信实体类型”部分，确保选择AWS服务并从中筛选出EC2。点击“下一步：权限”继续。
- en: 'In the Attach permissions policy page, filter the earlier created policy and
    attach it to our new role, as depicted in the following screenshot:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“附加权限策略”页面，筛选之前创建的策略并将其附加到我们的新角色，如下图所示：
- en: '![](img/ea4394d9-11ce-425f-9325-cc38a33b0aa9.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea4394d9-11ce-425f-9325-cc38a33b0aa9.png)'
- en: Finally, at the Review page, provide your role with a suitable Role Name and
    click on Create role to complete the process.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在“审核”页面，给您的角色提供一个合适的角色名称，并点击“创建角色”以完成过程。
- en: 'Before launching your EC2 instance with this newly created Role, ensure that
    the role''s Trust Relationship has the following set of AWS services added in
    its policy document:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用此新创建的角色启动EC2实例之前，请确保角色的信任关系在其策略文档中添加了以下AWS服务：
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With this step completed, we are now ready to launch a simple EC2 instance
    and assign the newly created role:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此步骤后，我们现在可以启动一个简单的EC2实例，并分配新创建的角色：
- en: From the EC2 Management Console, select the Launch Instance option to get started.
    For this particular use case, I've opted to go for the standard Amazon Linux AMI
    (`amzn-ami-hvm-2017.09.1.20171120-x86_64-gp2 - ami-55ef662f`); however, you can
    very well opt for a different Linux OS distribution as per your requirements.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 EC2 管理控制台中，选择“启动实例”选项开始操作。对于这个特定的用例，我选择了标准的 Amazon Linux AMI (`amzn-ami-hvm-2017.09.1.20171120-x86_64-gp2
    - ami-55ef662f`)，但是，您也可以根据需要选择其他 Linux 操作系统发行版。
- en: Select an appropriate Instance type for hosting our simple WordPress application.
    For now, I've selected the **t2.micro** instance type itself.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为托管我们简单的 WordPress 应用程序选择一个合适的实例类型。目前，我选择了 **t2.micro** 实例类型。
- en: 'Next, in the Configure Instance Details page, select the appropriate Network,
    Subnet, and IAM Role for our new EC2 instance. Paste the following set of lines
    as User data under the Advanced Details section, as shown in the following code.
    This simple user data script will copy and install the CodeDeploy agent along
    with a few other essential dependencies. You can find the complete copy of the
    following code at [https://github.com/yoyoclouds/Administering-AWS-Volume2](https://github.com/yoyoclouds/Administering-AWS-Volume2):'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在“配置实例详细信息”页面，选择适当的网络、子网和 IAM 角色来配置我们的新 EC2 实例。将以下几行作为用户数据粘贴到高级详细信息部分，如下所示。这个简单的用户数据脚本将会复制并安装
    CodeDeploy 代理以及其他一些必要的依赖项。您可以在 [https://github.com/yoyoclouds/Administering-AWS-Volume2](https://github.com/yoyoclouds/Administering-AWS-Volume2)
    找到完整的代码：
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Remember to change the `region` parameter as per your current operational region
    value.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请记得根据您当前的操作区域值更改 `region` 参数。
- en: Once the required storage is assigned to the instance, move on and assign a
    few essential tags for our EC2 instance. These tags will be used later in CodeDeploy
    to reference our EC2 instances, so make a note of the same.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦为实例分配了所需的存储，继续为我们的 EC2 实例分配一些必要的标签。这些标签稍后将在 CodeDeploy 中用于引用我们的 EC2 实例，因此请记下它们。
- en: Finally, create a new security group and make sure that the ports `22` (SSH)
    and `80` (HTTP) are open for internet traffic.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个新的安全组，并确保 `22`（SSH）和 `80`（HTTP）端口对互联网流量开放。
- en: Review the settings of your instance and launch it. Additionally, remember to
    associate your instance with a key pair as well before you launch it, as it can
    be useful to verify or troubleshoot the AWS CodeDeploy agent.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 审查实例的设置并启动它。此外，记得在启动实例之前将其与密钥对关联，因为这对验证或排查 AWS CodeDeploy 代理的问题可能很有用。
- en: With this, you now have successfully launched and set up a CodeDeploy agent
    on an EC2 instance. In the next section of this chapter, we will look at how you
    can take this installation further by configuring the AppSpec file for the final
    CodeDeploy deployment.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，您已成功在 EC2 实例上启动并设置了 CodeDeploy 代理。在本章的下一节中，我们将介绍如何通过配置 AppSpec 文件来进一步推进这一安装过程，完成最终的
    CodeDeploy 部署。
- en: Setting up the AppSpec file
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 AppSpec 文件
- en: As mentioned earlier, the AppSpec, or the application specifications file, is
    basically a YAML or JSON backed file used to define life cycle hooks for a particular
    deployment. In this case, with our EC2 instance prepped and ready with the CodeDeploy
    agent, we still need the AppSpec file to define a set of dependencies that will
    essentially install the necessary packages on the EC2 instance, start or stop
    the services, change permissions, and much more.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，AppSpec 或应用程序规范文件实际上是一个基于 YAML 或 JSON 的文件，用于定义特定部署的生命周期钩子。在这种情况下，虽然我们的
    EC2 实例已经准备好并安装了 CodeDeploy 代理，但我们仍然需要 AppSpec 文件来定义一组依赖项，这些依赖项将会在 EC2 实例上安装必要的包，启动或停止服务，修改权限等。
- en: 'The AppSpec file comprises the following sections:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: AppSpec 文件包括以下部分：
- en: '**Version**: The version of the AppSpec file. Currently, the version number
    supported with CodeDeploy is `0.0`. Do not change this value.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本**：AppSpec 文件的版本。目前，CodeDeploy 支持的版本号为 `0.0`。请勿更改此值。'
- en: '**OS**: Specifies the operating system of the underlying EC2/on-premise instance.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统**：指定底层 EC2/本地实例的操作系统。'
- en: '**Files**: Specifies the files that need to be copied on the instance at the
    time of the deployment process. You can additionally specify a source and a destination
    folder as well for your applications here.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件**：指定在部署过程中需要复制到实例上的文件。您还可以为应用程序指定源文件夹和目标文件夹。'
- en: '**Hooks**: Hooks essentially specify when a particular deployment life cycle
    has to be triggered. There are four main types of hooks: `BeforeInstall`, `AfterInstall`,
    `ApplicationStart`, and `ApplicationStop`. Each hook further requires additional
    parameters, such as the `location` of the scripts to execute, a `timeout` value,
    and how the scripts should be `runas`.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**钩子**：钩子本质上指定了在何时触发特定的部署生命周期。钩子主要有四种类型：`BeforeInstall`、`AfterInstall`、`ApplicationStart`和`ApplicationStop`。每个钩子还需要附加参数，如要执行的脚本的`位置`、`超时`值，以及脚本应该以何种`身份运行`。'
- en: 'Here is a representation of a simple AppSpec file for our WordPress deployment.
    Since we are using the Amazon Linux-backed instance, the `os` value is set to
    `linux` along with other essential parameters, such as `files` and `hooks`. Note
    in our case, we are configuring the WordPress application files to be copied from
    their default location over to `/var/www/html/WordPress` as well:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们WordPress部署的一个简单AppSpec文件示例。由于我们使用的是Amazon Linux支持的实例，`os`值被设置为`linux`，并包含其他重要参数，如`files`和`hooks`。请注意，在我们的情况下，我们将配置WordPress应用程序文件从默认位置复制到`/var/www/html/WordPress`：
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To create this file, login to your development server and not your CodeDeploy
    instance. Once logged into the development server, open the WordPress application
    directory that we used during the CodeCommit sections of this chapter. This is
    the same directory that we used to sync with our master CodeCommit repository
    as well:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个文件，登录到你的开发服务器，而不是你的CodeDeploy实例。登录到开发服务器后，打开我们在本章CodeCommit部分使用过的WordPress应用程序目录。这与我们用来同步主CodeCommit仓库的目录是同一个：
- en: 'Here, at the application''s root directory, create a blank `appspec.yml`, and
    copy-paste the `appspec` contents explained earlier:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序的根目录下，创建一个空白的`appspec.yml`文件，并复制粘贴之前解释过的`appspec`内容：
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With the AppSpec file created, we now move on to create the individual files
    for the life cycle hooks. To do so, create a folder named `scripts` within the
    WordPress application directory and create each of these individual shell scripts
    within it:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建完AppSpec文件后，我们继续创建生命周期钩子的各个单独文件。为此，在WordPress应用程序目录内创建一个名为`scripts`的文件夹，并在其中创建这些单独的Shell脚本：
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create the `install_dependencies.sh` script that will essentially install the
    necessary packages required to run WordPress on an instance:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`install_dependencies.sh`脚本，该脚本将安装运行WordPress所需的必要软件包：
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Similarly, create the `change_permissions.sh` script that modifies the permissions
    of the files present in the scripts folder to *executable*:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，创建`change_permissions.sh`脚本，修改`scripts`文件夹内文件的权限，使其*可执行*：
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And, finally, create the `start_server.sh` and the `stop_server.sh` scripts
    that will start and stop the `httpd` and `mysql` services on the deployment EC2
    instances:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建`start_server.sh`和`stop_server.sh`脚本，这些脚本将在部署的EC2实例上启动和停止`httpd`和`mysql`服务：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Got this far? Awesome! We are almost done with the AppSpec files, with just
    one small step left: uploading these changes to our CodeCommit repository!'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里了吗？太棒了！我们快完成AppSpec文件了，剩下的唯一步骤就是：将这些更改上传到我们的CodeCommit仓库！
- en: 'To do so, run the following set of commands from the deployment server:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，从部署服务器运行以下一组命令：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Et voila! The WordPress application and our deployment scripts are all uploaded
    to our CodeCommit branch and ready for deployment! In the next section, we will
    create and configure an application and deployment group for our CodeDeploy.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Et voila！WordPress应用程序和我们的部署脚本都已上传到CodeCommit分支，准备好进行部署！在下一部分，我们将创建并配置CodeDeploy的应用程序和部署组。
- en: Creating a CodeDeploy application and deployment group
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个CodeDeploy应用程序和部署组
- en: 'With our AppSpec file and scripts in place and the EC2 instance set up with
    the CodeDeploy agent as well, the final thing left is to configure AWS CodeDeploy
    and tie these things together:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了AppSpec文件和脚本，并且EC2实例也已经配置好CodeDeploy代理，最后需要做的是配置AWS CodeDeploy并将这些内容连接起来：
- en: Start off by logging into the AWS CodeDeploy service by selecting URL [https://console.aws.amazon.com/codedeploy/home](https://console.aws.amazon.com/codedeploy/home).
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过选择URL [https://console.aws.amazon.com/codedeploy/home](https://console.aws.amazon.com/codedeploy/home)
    登录AWS CodeDeploy服务。
- en: Since this is the first time we are using CodeDeploy, select the Get Started
    Now option. Here, you will be prompted to select either a Sample deployment that
    deploys a sample application on the EC2 instances or, alternatively, go for a
    Custom deployment if you have your code and EC2 instances up and running. In this
    case, we will select the Custom deployment option itself.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这是我们第一次使用CodeDeploy，请选择“立即开始”选项。在这里，您将被提示选择一个示例部署，它会在EC2实例上部署一个示例应用程序；或者，如果您已有代码和EC2实例正在运行，您可以选择自定义部署。在本例中，我们将选择自定义部署选项。
- en: 'In the Create application page, start off by providing a suitable Application
    name, Compute Platform, and a Deployment group name. Remember to select the EC2/On-premises option
    from the Compute Platform, as shown in the following screenshot:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“创建应用程序”页面，首先提供合适的应用程序名称、计算平台和部署组名称。记得从计算平台中选择“EC2/本地部署”选项，如下图所示：
- en: '![](img/35fbb4b7-afbf-4e1f-8b1e-f21272c33a64.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35fbb4b7-afbf-4e1f-8b1e-f21272c33a64.png)'
- en: Next, in the Deployment type section, choose the In-place deployment option
    for now. This will enable CodeDeploy to update the existing instances with the
    revised set of application code with some amount of downtime.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在部署类型部分，暂时选择“原地部署”选项。这将允许CodeDeploy使用更新后的应用程序代码更新现有实例，并带有一定的停机时间。
- en: In the Environment configuration section, you can specify any combination of
    Auto Scaling groups, Amazon EC2 instances, and On-premises instances to add instances
    to this deployment group. Since we have created an EC2 instance in our earlier
    steps with the CodeDeploy agent installed in it, select the Amazon EC2 instances tab.
    From the Tag group drop-down, select the instance's Key and Value, as shown.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在环境配置部分，您可以指定任何组合的自动扩展组、Amazon EC2实例和本地实例，以将实例添加到此部署组中。由于我们在之前的步骤中已经创建了一个EC2实例，并安装了CodeDeploy代理，因此请选择“Amazon
    EC2实例”标签。然后，在标签组下拉列表中选择实例的“键”和值，如图所示。
- en: 'Note that these are the same tags that you would have configured to your instance
    before its launch in our earlier sections:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些标签与您在之前部分中为实例配置的标签相同：
- en: '![](img/6c965bce-6159-4e2d-bc9a-e4c121dc0f99.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c965bce-6159-4e2d-bc9a-e4c121dc0f99.png)'
- en: Moving on, in the Deployment configuration section, you can choose from a list
    of default and custom deployment configurations. As discussed earlier, a deployment
    configuration is a set of rules that determines how fast an application will be
    deployed along with the definition of success or failure conditions for a particular
    deployment.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在部署配置部分，您可以从默认和自定义部署配置列表中进行选择。如前所述，部署配置是一组规则，决定了应用程序的部署速度，并定义了特定部署的成功或失败条件。
- en: 'There are three default configurations provided by AWS CodeDeploy itself:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CodeDeploy本身提供了三种默认配置：
- en: '**OneAtATime**: Routes traffic to one instance in the replacement environment
    at a time'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OneAtATime**：将流量一次路由到替换环境中的一个实例'
- en: '**HalfAtATime**: Routes traffic to up to half the instances in the replacement
    environment at a time'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HalfAtATime**：将流量一次路由到替换环境中最多一半的实例'
- en: '**AllAtOnce**: Routes traffic to all instances in the replacement environment
    all at once'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AllAtOnce**：将流量一次性路由到替换环境中的所有实例'
- en: Since we are working with just a single EC2 instance as of now, go ahead and
    select the OneAtATime deployment configuration option.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们目前只在使用一个EC2实例，因此请选择“OneAtATime”部署配置选项。
- en: Finally, select the IAM Role that we created and assigned our EC2 instance to
    at the time of launching, using the Service Role drop-down list. Once done, select
    the Create application option to complete the process!
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，选择我们在启动时创建并分配给EC2实例的IAM角色，通过“服务角色”下拉列表进行选择。完成后，选择“创建应用程序”选项以完成该过程！
- en: There you have it! If you made it this far then you have successfully configured
    both AWS CodeCommit and AWS CodeDeploy for our WordPress application's deployment!
    But we are still missing the glue that ties all these services together, and that
    precisely is what we will be talking about in the next section with the introduction
    of AWS CodePipeline!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！如果您已经完成到这里，那么您已经成功配置了AWS CodeCommit和AWS CodeDeploy来部署我们的WordPress应用程序！但我们仍然缺少将这些服务串联起来的“粘合剂”，这正是我们在下一部分介绍AWS
    CodePipeline时要讲解的内容！
- en: Introducing AWS CodePipeline
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍AWS CodePipeline
- en: AWS CodePipeline is a continuous delivery service that you can use to model,
    visualize, and automate the steps required to release your application software.
    This is made possible by building *pipelines* that contain one or more *stages*.
    The stages can be broadly classified as *build*, where the code is compiled and
    built using, say, AWS CodeBuild or some other third-party tool, *staging*, and
    *deployment*, where the code is pushed on to compute instances using AWS CodeDeploy,
    and so on. Each stage internally describes a set of actions that it needs to perform
    in order to prepare the software for its release. This action can be anything
    from building your source code from a Git repository, to making changes to a file,
    or deploying packages, and so on. Every change made to either your code or some
    configurational setting within CodePipeline is considered as a *revision* and
    you can have multiple such revisions created within a single stage of a pipeline.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CodePipeline 是一种持续交付服务，你可以用它来建模、可视化并自动化发布应用软件所需的步骤。这是通过构建包含一个或多个*阶段*的“流水线”来实现的。这些阶段大致可以分为*构建*，即使用
    AWS CodeBuild 或其他第三方工具编译并构建代码，*暂存*，以及*部署*，即通过 AWS CodeDeploy 将代码推送到计算实例等。每个阶段内部描述了为准备软件发布所需执行的一组操作。这些操作可以是从
    Git 仓库构建源代码，到修改文件或部署包等等。对代码或 CodePipeline 中任何配置设置的每次更改都被视为一个*修订*，并且你可以在流水线的单个阶段中创建多个修订。
- en: Even changes made to a single stage within the pipeline results in all actions
    across all stages being re-executed.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在流水线中的单个阶段进行更改，也会导致所有阶段中的所有操作被重新执行。
- en: You can use these features provided by CodePipeline to effectively manage and
    monitor the release of your software. In this section, we will be continuing with
    our use case set up earlier using CodeCommit and CodeDeploy and see how we can
    truly build an end-to-end continuous delivery cycle using AWS CodePipeline.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 CodePipeline 提供的这些功能来有效地管理和监控软件的发布。在本节中，我们将继续使用之前设置的案例，利用 CodeCommit 和
    CodeDeploy，看看如何利用 AWS CodePipeline 真正构建一个端到端的持续交付周期。
- en: Creating your own continuous delivery pipeline
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你自己的持续交付流水线
- en: 'Getting started with CodePipeline is extremely easy provided you have all the
    necessary prerequisites met, which include setting up the CodeCommit repository
    with your latest piece of application code (in this case, the WordPress application),
    as well as configuring the application and the AppSpec file using CodeDeploy:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CodePipeline 入门非常简单，只要你满足所有必要的先决条件，这些条件包括设置带有最新应用代码（在本例中为 WordPress 应用）的
    CodeCommit 仓库，以及使用 CodeDeploy 配置应用程序和 AppSpec 文件：
- en: To begin with, launch the CodePipeline Management dashboard by selecting URL [https://console.aws.amazon.com/codepipeline/home](https://console.aws.amazon.com/codepipeline/home).
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过选择 URL [https://console.aws.amazon.com/codepipeline/home](https://console.aws.amazon.com/codepipeline/home)
    启动 CodePipeline 管理仪表板。
- en: 'Since this is our first setup, click on the Get Started option to get going.
    This will bring up the Getting started with AWS CodePipeline wizard, as shown
    in the following screenshot. Start off by providing a suitable Pipeline name and
    click Next step to continue:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这是我们的第一次设置，点击“开始使用”选项以启动。这将显示“使用 AWS CodePipeline 入门”向导，如以下截图所示。首先提供一个合适的流水线名称，然后点击“下一步”继续：
- en: '![](img/6e2daad6-3d4c-4d2e-9e2c-7049f95fbd0c.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e2daad6-3d4c-4d2e-9e2c-7049f95fbd0c.png)'
- en: Next, in the Source page, we need to select and configure the source for our
    new pipeline. At the time of writing this book, CodePipeline supports three source
    code providers, namely Amazon S3, AWS CodeCommit, and GitHub. For the purpose
    of this use case, go ahead and select AWS CodeCommit from the Source drop-down
    list.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在“源”页面，我们需要选择并配置新流水线的源。在撰写本书时，CodePipeline 支持三个源代码提供者，即 Amazon S3、AWS CodeCommit
    和 GitHub。为了本案例，选择“源”下拉列表中的 AWS CodeCommit。
- en: This will automatically prompt you to enter the subsequent CodeCommit Repository
    name as well as its corresponding Branch name. Make sure you provide the same
    branch name that contains the latest WordPress code as well as the AppSpec file.
    Click on Next step to continue.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将自动提示你输入后续的 CodeCommit 仓库名称以及其对应的分支名称。确保提供包含最新 WordPress 代码和 AppSpec 文件的相同分支名称。点击“下一步”继续。
- en: The third stage of the Pipeline setup is the Build stage where you can specify
    the build provider. CodePipeline supports three build providers, namely AWS CodeBuild,
    Jenkins, and Solano CI. Since our WordPress installation doesn't require any compilations
    or build procedures, simply select the No Build option from the drop-down list
    and click on Next step to continue.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管道设置的第三个阶段是“Build”阶段，您可以在此指定构建提供程序。CodePipeline支持三种构建提供程序，即AWS CodeBuild、Jenkins和Solano
    CI。由于我们的WordPress安装不需要任何编译或构建过程，因此只需从下拉列表中选择“No Build”选项，然后单击“下一步”继续。
- en: The fourth state requires the Deployment configurations to be set up for the
    pipeline. Here too you are provided with various options that you can choose to
    leverage based on your needs. At present, CodePipeline supports AWS Opsworks,
    AWS CodeDeploy, AWS CloudFormation, and AWS Elastic Beanstalk as the Deployment
    providers. Since we have already configured AWS CodeDeploy for our use case, select
    the same from the drop-down list.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第四个状态需要为管道设置部署配置。在这里，您也可以根据需要选择利用的各种选项。目前，CodePipeline支持AWS Opsworks、AWS CodeDeploy、AWS
    CloudFormation和AWS Elastic Beanstalk作为部署提供程序。由于我们已经为我们的用例配置了AWS CodeDeploy，因此从下拉列表中选择相同选项。
- en: 'Next, fill in the correct Application name as well as the Deployment group that
    we configured during the setup of CodeDeploy. Click on Next step once done:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，填写正确的应用程序名称以及在设置CodeDeploy期间配置的部署组。完成后，单击“下一步”：
- en: '![](img/1d2c518e-e810-42cb-b73a-9cb322e0dfd8.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d2c518e-e810-42cb-b73a-9cb322e0dfd8.png)'
- en: The final step required is to configure the Service Role. The service role essentially
    grants CodePipeline permissions to use resources in your AWS account. Provide
    a suitable Role name and click on Next step to review the pipeline's configuration.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是配置服务角色。服务角色基本上授予了CodePipeline在您的AWS账户中使用资源的权限。提供适当的角色名称，并单击“下一步”以审查管道的配置。
- en: On the Review your pipeline page, ensure that all the fields are correctly configured
    and click on Create pipeline when done.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Review your pipeline”页面上，确保所有字段都正确配置，并在完成后单击“创建管道”。
- en: Selecting this option first creates a unique S3 bucket within your environment
    that will contain and store all the necessary artifacts for this particular pipeline.
    Once the pipeline is created, you can view it on the AWS CodePipeline dashboard.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 选择此选项首先在您的环境中创建一个唯一的S3存储桶，该存储桶将包含并存储该特定管道所需的所有必要工件。创建管道后，您可以在AWS CodePipeline仪表板上查看它。
- en: Putting it all together
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起
- en: With the pipeline all set up, you can now test the entire setup as one cohesive
    solution!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 完成管道设置后，现在可以将整个设置作为一个协同解决方案进行测试！
- en: 'First up, ensure that there are no errors in either of the stages during the
    deployments. In case there are any errors, simply select the particular error
    link provided in the stage and follow it back to its source, which can be anywhere
    from issues in CodeCommit to even the setting up of CodeDeploy. Here''s a screenshot
    of the pipeline that we created using an accumulation of all of the preceding
    sections:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 首先确保在部署过程中的任何阶段中都没有错误。如果有任何错误，请简单地选择阶段提供的特定错误链接，并跟随其源头，可能是从CodeCommit的问题到甚至是CodeDeploy的设置。以下是我们使用前述所有部分积累创建的管道的屏幕截图：
- en: '![](img/3c30e91b-5bea-434f-990b-7254d2b4b6b1.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c30e91b-5bea-434f-990b-7254d2b4b6b1.png)'
- en: Here, you can choose to add more stages to your pipeline by simply selecting
    the Edit option, as highlighted earlier. Additionally, you can also view your
    pipeline's execution history by selecting the View pipeline history option.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，您可以通过简单选择“Edit”选项来为您的管道添加更多阶段，正如前面所强调的那样。此外，您还可以通过选择“View pipeline history”选项来查看您的管道执行历史记录。
- en: In the Edit pipeline page, you can choose to add one or more stages to your
    pipeline as you see fit. Simply select the + Stage option provided at the end
    of each existing stage. This will bring up a new dialog where you can specify
    the stage's Name as well as define one or more actions.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在“Edit pipeline”页面上，您可以根据需要选择添加一个或多个阶段到您的管道中。只需选择每个现有阶段末尾提供的“+ Stage”选项即可。这将弹出一个新对话框，在其中您可以指定阶段的名称以及定义一个或多个操作。
- en: 'Consider the following use case where we need to add an approval step before
    the code actually gets pushed into the staging area. In that case, we need to
    add a new stage between the existing Source and Staging stages:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下用例，我们需要在代码实际推送到暂存区之前添加一个批准步骤。在这种情况下，我们需要在现有的“Source”和“Staging”阶段之间添加一个新阶段：
- en: Click on the + Stage option and provide a suitable name for this new stage.
    Next, select the + Action option to add the rules for setting up the approval
    process.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 + 阶段 选项，为这个新阶段提供一个合适的名称。接着，选择 + 操作 选项，添加设置审批过程的规则。
- en: 'In the Add action dialog box, start by selecting the type of action from the
    Action category drop-down list. The following list of actions can be added to
    a stage: Approval, Source, Build, Test, Deploy, and Invoke. For this use case,
    select Approval:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加操作对话框中，首先从操作类别下拉列表中选择操作类型。以下操作可以添加到阶段中：审批、源、构建、测试、部署和调用。对于这个用例，选择审批：
- en: '![](img/1fbe76eb-b778-45dc-ab77-3f728ce8f535.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1fbe76eb-b778-45dc-ab77-3f728ce8f535.png)'
- en: Fill in a suitable Action name and select an appropriate Action type as well.
    At present, only a Manual approval configuration option is provided by CodePipeline.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写合适的操作名称，并选择一个合适的操作类型。目前，CodePipeline 只提供手动审批配置选项。
- en: Finally, select either one of a pre-existing SNS topics using the SNS topic
    ARN field and click on Add action once completed.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，选择一个预先存在的 SNS 主题，使用 SNS 主题 ARN 字段，然后点击添加操作按钮，一旦完成。
- en: 'With the new stage added, click on Save pipeline changes to commit the change.
    You should have a new stage added and visible in your pipeline, as shown in the
    following screenshot:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加新阶段后，点击“保存管道更改”以提交更改。你应该能看到新阶段已成功添加并出现在你的管道中，截图如下所示：
- en: '![](img/036a9d75-3287-41b0-af6a-48cbe498f564.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/036a9d75-3287-41b0-af6a-48cbe498f564.png)'
- en: 'Once the Source stage is prepped, the pipeline automatically halts at the Approval stage,
    as depicted in the following screenshot. Here, you can approve the process by
    simply selecting the Review option and then selecting the `approval` command.
    Doing so initiates the final Staging stage which invokes the CodeDeploy service
    to deploy the WordPress code over to our awaiting EC2 instance:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦源阶段准备好，管道会自动停在审批阶段，如下图所示。在这里，你只需选择“审核”选项并选择 `approval` 命令，即可批准流程。这将启动最终的 Staging
    阶段，进而触发 CodeDeploy 服务，将 WordPress 代码部署到我们等待中的 EC2 实例上：
- en: '![](img/86c23e34-02e9-45b2-8a8d-537bea5750a8.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86c23e34-02e9-45b2-8a8d-537bea5750a8.png)'
- en: 'After a few minutes, the application is successfully uploaded on the instance
    and is up and running as well. You can verify this by making a note of your instances
    public IP address and typing in the following URL on a browser:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，应用程序成功上传至实例并正常运行。你可以通过记下实例的公共 IP 地址，并在浏览器中输入以下 URL 来验证：
- en: '[PRE24]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Remember to prefix `WordPress` in your URL since the `AppSpec` file clearly
    pointed to the root of the application at the `/var/www/html/WordPress` directory
    and not at `/var/www/html` itself.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 请记得在 URL 前缀中添加`WordPress`，因为 `AppSpec` 文件明确指向的是应用程序根目录 `/var/www/html/WordPress`，而不是
    `/var/www/html` 本身。
- en: In this way, you can easily leverage and automate the deployments of your application
    code using the AWS Code Suite of services! Amazing isn't it? But that's not all
    folks! There is a ton of other fascinating things that I would like you to learn
    and explore, all covered in the next section itself.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，你可以轻松利用并自动化部署你的应用代码，使用 AWS Code 服务套件！是不是很棒？但这还不是全部！接下来还有许多有趣的内容，我希望你能够学习和探索，所有内容都会在下一节中讲解。
- en: Planning your next steps
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划你的下一步
- en: Well, we have covered a lot of new features and services in this chapter. However,
    there are still a few things that I would recommend you need to read up on your
    own as well. First up is the AWS CodeStar!
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们在这一章中涵盖了许多新功能和服务。然而，还是有一些事情我建议你自己也需要深入了解。首先是 AWS CodeStar！
- en: 'AWS CodeStar is an amazing service that can help developers create, manage,
    and work on developing applications, all one place. The integral part of CodeStar
    that enables this is called **projects**. Developers can create projects based
    on predefined templates that contain a supported programming model which is ready
    to use for developing. You can additionally select hosting for your application
    from a variety of options that include Amazon EC2, Elastic Beanstalk, and AWS
    Lambda as well! CodeStar comes with easy connectivity with various IDEs as well:
    Eclipse, Visual Studio, just to name a few. You can read more about *AWS CodeStar*
    at [http://docs.aws.amazon.com/codestar/latest/userguide/welcome.html](http://docs.aws.amazon.com/codestar/latest/userguide/welcome.html).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CodeStar 是一个了不起的服务，可以帮助开发人员在一个地方创建、管理和开发应用程序。实现这一点的 CodeStar 的重要部分称为**项目**。开发人员可以基于预定义模板创建项目，这些模板包含支持的编程模型，可用于开发。您还可以从多种选项中选择应用程序的托管，包括
    Amazon EC2、Elastic Beanstalk 和 AWS Lambda！CodeStar 还可以与多种 IDE（如 Eclipse、Visual
    Studio 等）轻松连接。您可以在 [http://docs.aws.amazon.com/codestar/latest/userguide/welcome.html](http://docs.aws.amazon.com/codestar/latest/userguide/welcome.html)
    上了解更多关于 *AWS CodeStar* 的信息。
- en: The second awesome service worth trying out is AWS Cloud9! AWS Cloud9 is a cloud-based
    IDE that you can use to write, debug, and run code, all with a standard web browser!
    Cloud9 comes pre-packaged with essential tools for the most popular programming
    languages, including JavaScript, Python, PHP, Node.js, C++, and much more, and
    the best part is you can easily integrate Cloud9 with the likes of other AWS services,
    such as CodeCommit, CodeStar, and so on. You can read more about AWS Cloud9 at [https://docs.aws.amazon.com/cloud9/latest/user-guide/welcome.html](https://docs.aws.amazon.com/cloud9/latest/user-guide/welcome.html).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个值得尝试的令人惊叹的服务是 AWS Cloud9！AWS Cloud9 是一个基于云的 IDE，您可以使用标准的 Web 浏览器编写、调试和运行代码！Cloud9
    预装了最受欢迎的编程语言（包括 JavaScript、Python、PHP、Node.js、C++ 等）的基本工具，最好的部分是您可以轻松将 Cloud9
    与 AWS 的其他服务（如 CodeCommit、CodeStar 等）集成。您可以在 [https://docs.aws.amazon.com/cloud9/latest/user-guide/welcome.html](https://docs.aws.amazon.com/cloud9/latest/user-guide/welcome.html)
    上了解更多关于 AWS Cloud9 的信息。
- en: Last, but not least, I would also recommend that you try out a complete, end-to-end
    CI/CD solution provided by the **AWS Partner Network** (**APN**) blog that leverages
    a CloudFormation stack to deploy a full-fledged AWS Code Suite, including CodeBuild,
    CodeCommit, CodeDeploy, and CodePipeline! The stack gives you a feel for using
    AWS CodeBuild as a service and also provides you with a template to automate your
    own Code deployments using CloudFormation. To view the blog visit [https://aws.amazon.com/blogs/apn/deploy-to-production-using-aws-codebuild-and-the-aws-developer-tools-suite/](https://aws.amazon.com/blogs/apn/deploy-to-production-using-aws-codebuild-and-the-aws-developer-tools-suite/).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，我还建议您尝试一下由 **AWS 合作伙伴网络** (**APN**) 提供的完整的端到端 CI/CD 解决方案，该解决方案利用
    CloudFormation 堆栈部署了全面的 AWS Code 套件，包括 CodeBuild、CodeCommit、CodeDeploy 和 CodePipeline！该堆栈使您能够体验使用
    AWS CodeBuild 作为服务，并为您提供一个使用 CloudFormation 自动化部署代码的模板。您可以访问博客了解更多信息：[https://aws.amazon.com/blogs/apn/deploy-to-production-using-aws-codebuild-and-the-aws-developer-tools-suite/](https://aws.amazon.com/blogs/apn/deploy-to-production-using-aws-codebuild-and-the-aws-developer-tools-suite/)。
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Here's a quick round up of the topics that we have covered so far in this chapter!
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章迄今为止涵盖的主题的快速总结！
- en: We started off by learning and understanding a bit about the AWS Code Suite
    of services and how they tie into the continuous integration and continuous delivery
    life cycle. We then learned a bit about AWS CodeDeploy and how easy it is to get
    started with it. We created a simple CodeCommit repository and used that to store
    our sample WordPress application as well. Later, we looked at AWS CodeDeploy and
    how it works. We also configured a CodeDeploy agent and leveraged the AppSpec
    file for our WordPress application's deployment life cycle. Finally, we tied it
    all together by integrating the work done so far with AWS CodePipeline and ended
    the chapter with a few essential things to read and try out on your own!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先学习了解了 AWS Code 套件的一些服务，以及它们如何与持续集成和持续交付生命周期相关联。然后我们学习了 AWS CodeDeploy 的基础知识，以及如何轻松入门。我们创建了一个简单的
    CodeCommit 仓库，并将我们的示例 WordPress 应用程序存储在其中。随后，我们深入了解了 AWS CodeDeploy 的工作原理。我们还配置了一个
    CodeDeploy 代理，并利用了 AppSpec 文件来管理我们的 WordPress 应用程序的部署生命周期。最后，我们通过将迄今为止完成的工作与 AWS
    CodePipeline 集成，将所有内容整合在一起，并在章节结束时介绍了一些自行尝试的基本内容！
- en: 'In the next chapter, we will be exploring two application-specific services
    and look at how you can leverage them for your requirements: Amazon SQS and Amazon
    SNS. So stay tuned!'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨两个特定应用的服务，并看看你如何利用它们来满足你的需求：Amazon SQS 和 Amazon SNS。敬请期待！
