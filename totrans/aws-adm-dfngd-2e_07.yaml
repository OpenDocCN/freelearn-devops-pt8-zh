- en: Transforming Application Development Using the AWS Code Suite
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用AWS Code Suite改变应用程序开发
- en: In the previous chapter, we explored a few interesting and really useful enhancements
    made to the AWS **Identity and Access Management Service** (**IAM**) along with
    a quick deep dive into AWS Organizations as well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了AWS **身份和访问管理服务**（**IAM**）所做的一些有趣且非常有用的增强功能，以及对AWS组织的快速深入了解。
- en: 'In this chapter, we will be learning and exploring three extremely useful and
    powerful services provided by AWS that are specially catered toward enhancing
    a developer''s experience with continuous code deployments: AWS CodeCommit, AWS
    CodeDeploy, and AWS CodePipeline!'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习和探索由AWS提供的三项极其有用和强大的服务，专门为增强开发人员在持续代码部署方面的体验而设计：AWS CodeCommit、AWS
    CodeDeploy和AWS CodePipeline！
- en: 'Keeping this in mind, let''s have a quick look at the various topics that we
    will be covering in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 牢记这一点，让我们快速浏览一下本章将涵盖的各种主题：
- en: Introducing AWS CodeCommit, AWS CodeDeploy, and AWS CodePipeline along with
    each service's concepts and internal workings
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍AWS CodeCommit、AWS CodeDeploy和AWS CodePipeline以及每个服务的概念和内部工作原理
- en: Creating your first CodeCommit repository and uploading an application to it
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您的第一个CodeCommit存储库并将应用程序上传到其中
- en: Running basic Git commands against your new code repository
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行基本的Git命令来操作您的新代码存储库
- en: Configuring the CodeDeploy agent on an EC2 instance
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在EC2实例上配置CodeDeploy代理
- en: Leveraging the AppSpec file for configuring application life cycle deployment
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用AppSpec文件配置应用程序生命周期部署
- en: Creating your own continuous delivery system using CodePipeline
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CodePipeline创建您自己的持续交付系统
- en: So without any further ado, let's get started right away!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，不再拖延，让我们立即开始吧！
- en: Understanding the AWS Code Suite
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解AWS Code Suite
- en: 'Besides providing a plethora of infrastructure-related services, AWS also provides
    a few services that are designed to help developers quickly design, develop, build,
    and deploy their applications on the AWS cloud platform. In this section, we will
    have a quick look at these services and how you can leverage them together to
    build your very own continuous integration and delivery pipelines:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供大量基础设施相关的服务外，AWS还提供了一些旨在帮助开发人员快速设计、开发、构建和部署他们的应用程序在AWS云平台上的服务。在本节中，我们将快速浏览这些服务以及如何将它们结合起来利用，构建您自己的持续集成和交付流水线：
- en: '**AWS CodeCommit**: An important starting point for any CI/ CD pipeline is
    a simple yet functional source control repository. Traditionally, this would be
    set up on one or more physical servers in the form a Git or SVN repository that
    developers would use to push their code and updates to; however, maintaining such
    code repositories and scaling them was always going to be a challenge. That''s
    where AWS CodeCommit comes into play! AWS CodeCommit is a managed source control
    service that enables developers to securely store their code on the AWS cloud.
    It offers many of the features that you would require and use while working with
    different source control repositories, such as branching, commits, rollbacks,
    and much more.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS CodeCommit**：任何CI/CD流水线的重要起点是一个简单但功能强大的源代码控制存储库。传统上，这将在一个或多个物理服务器上设置为Git或SVN存储库的形式，开发人员将使用它们来推送他们的代码和更新；然而，维护这样的代码存储库并扩展它们总是具有挑战性的。这就是AWS
    CodeCommit发挥作用的地方！AWS CodeCommit是一项托管的源代码控制服务，使开发人员能够安全地将他们的代码存储在AWS云上。它提供了许多您在使用不同源代码控制存储库时需要和使用的功能，如分支、提交、回滚等。'
- en: '**AWS CodeBuild**: AWS CodeBuild is a code build service that developers can
    leverage to automate their source code compilations, tests, executions, and code
    packaging for deployments. Similar to its other counterpart services in the Code
    Suite, CodeBuild too is managed completely by AWS, thus eliminating any unnecessary
    administrative overheads, such as patching or scaling the code build software.
    CodeBuild is highly extensible and it also easily integrates with your existing
    CI/CD workflows as well.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS CodeBuild**：AWS CodeBuild是开发人员可以利用的代码构建服务，用于自动化他们的源代码编译、测试、执行和代码打包以进行部署。与Code
    Suite中的其他对应服务类似，CodeBuild也完全由AWS管理，从而消除了任何不必要的管理开销，如修补或扩展代码构建软件。CodeBuild具有高度可扩展性，也很容易与您现有的CI/CD工作流程集成。'
- en: '**AWS CodeDeploy**: With your application code stored securely and compiled,
    the final step requires the code to be deployed across your fleet of EC2 instances.
    This can be easily achieved with the help of our next Code Suite service, called
    AWS CodeDeploy. Using CodeDeploy, a developer can automate code deployments to
    any environment that runs off of either EC2 instances as well as servers that
    are running in an on-premise datacenter. CodeDeploy essentially eliminates deployment
    complexities by allowing you to automate the delivery of your code across thousands
    of instances without having to undergo any major downtimes.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS CodePipeline**: AWS CodePipeline is a full fledge CI/CD service provided
    by AWS that developers can leverage to build end-to-end CI/CD pipelines either
    by using the AWS Code Suite of services or even with other popular third-party
    tools, such as GitHub, Jenkins, and so on. Using CodePipeline, you can also create
    and define custom software release models using which your application gets updated
    with the latest set of updates, tested, and packaged as well for the next iterative
    set of deployments.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a brief representation of how these services map together collaboratively
    to create a comprehensive CI/CD pipeline:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e3d7b23-e812-4d55-ba50-ad84c36c0288.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: 'For the purpose of this chapter, however, we will be working with only three
    AWS Code Suite services, namely AWS **CodeCommit**, AWS **CodeDeploy**, and AWS
    **CodePipeline**. The chapter will showcase how these three services can be leveraged
    together to build your very own CI/CD pipelines for our sample WordPress application.
    Here is a high-level depiction of our overall use case:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea5db7c2-66dd-46e7-b588-94de46987c18.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: With the basic understanding of the Code Suite services out of the way, let's
    learn a bit more about AWS CodeCommit and how you can leverage it as your very
    own source code repository!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started with AWS CodeCommit
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As discussed earlier, AWS CodeCommit is a secure and highly scalable source
    control service which allows you to create multiple private Git repositories without
    having to bother about any of the underlying management overheads. You can use
    it to store anything, from code, to application binaries, to even code packages,
    all using the standard Git-like functionality. This makes CodeCommit extremely
    easy to work with even if you have not used it before. Here is the gist of some
    of the most commonly used Git commands and how you can leverage them with CodeCommit:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '`git clone`: Used to clone and connect the AWS CodeCommit repository over to
    your local development server.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git add`: Once the repository is cloned locally, you can use it to add, edit,
    or delete files as you see fit. Once done, use the `git add` command to stage
    the modifications in your local Git repository.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git commit`: Used to commit the modifications made to the files to the local
    Git repository.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git push`: Used to push the committed files and changes over to the AWS CodeCommit
    repository.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git pull`: Used to ensure that the files you are working on are synced and
    are of the latest version from the AWS CodeCommit repository.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this section, we will be looking at a few simple steps to enable you to
    create your very own source code repository using the AWS Management Console.
    However, before we move on to that, it is important to understand some of the
    different connections that you can use to connect to your CodeCommit repository.
    This can vary based on your development environments as well as security requirements:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '**Using the HTTPS connections**: Configuring Git credentials using HTTPS connections
    is by far the simplest and most widely used method for connecting to your Git
    repository. With this set up, you simply generate a static username and password
    using AWS IAM. Once the credentials are created, you can then use them with Git
    and any third-party tool, such as an IDE, for authentication.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using the SSH connections**: In this case, a user will be required to create
    public and private key files on your local development server that Git and AWS
    CodeCommit can use for SSH authentication. The public key generated in this process
    gets associated with your IAM user, whereas the private key remains on the local
    development server. The generation of the keys varies from operating system to
    operating system and can be a tedious process at times to manage.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For this section, however, we will be leveraging the SSH connections method
    itself for connecting to our AWS CodeCommit repository:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: To get started, first log in to your AWS Management Console and filter the IAM
    service using the Filter option provided. Alternatively, you can also select URL
    [https://console.aws.amazon.com/iam/](https://console.aws.amazon.com/iam/) to
    view the IAM dashboard.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we will start off by creating a dedicated user that will have full management
    rights to our CodeCommit repository. Select the Users option from the IAM dashboard's
    navigation pane to bring up the list of currently created IAM users.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, select the Add user option. This will bring up the Add user page where
    you can provide a suitable User name as well as opt for the user's Access type.
    In this case, the CodeCommit user will only require Programmatic access. Click
    Next to proceed.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Moving on, in the Permissions page, we are required to filter and attach the
    `AWSCodeCommitFullAccess` policy to our newly created user. To do so, select the
    Attach existing policies directly option and select the `AWSCodeCommitFullAccess` policy,
    as shown in the following screenshot. Alternatively, you can also provide a customized
    access policy here based on your requirements:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7fe3b055-8f07-4ffc-9425-639d123653f6.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: Complete the user creation process by reviewing the changes and making a note
    of the user's new access and secret keys as well.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, with your CodeCommit IAM user created, we now move on to the
    next part of this section where we create and configure a set of public and private
    keys for the IAM user, using a simple Linux-based development server. Follow URL [http://docs.aws.amazon.com/codecommit/latest/userguide/setting-up-ssh-windows.html](http://docs.aws.amazon.com/codecommit/latest/userguide/setting-up-ssh-windows.html) if
    you are using a Windows operating system as your development server:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in to your development server and run the following command to generate
    the new set of keys:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When prompted, save the keys in the following directory structure:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Make a note of the public and private keys'' locations, as depicted in the
    following screenshot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/495a035a-aed2-4591-ad52-5155b48b7e98.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: 'Next, display and copy the public key''s contents, using the following command.
    Note the public key will be saved in the file with a `.pub` extension:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Log in to your IAM dashboard once again and select the newly created user from
    the Users page. Select the user's Security Credentials tab. Here, under the SSH
    keys for AWS CodeCommit section, click on Upload SSH public key to paste the entire
    copied text from the earlier step.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once completed, you should now see a unique key auto-generated under the SSH
    key ID column, as shown in the following screenshot. Copy this SSH key ID as we
    will be requiring it in the next steps:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/baf12b4f-1415-4f5b-ae4c-211bae5c221f.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: 'With the public key uploaded to IAM and the new SSH key ID generated, the final
    step is to create a simple `config` file in your local development server with
    the following contents pasted into it:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Save the file once done. Remember to modify the permissions of your `config` file
    before moving on to the verification step:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To verify the connectivity, simply use the following command to SSH to the
    AWS CodeCommit endpoint. Since this will be a first connect, you will be prompted
    to verify the connection for authenticity. Type in `yes` when prompted:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The endpoint you use will be specific to the AWS region that you operate out
    of. You can view the list of region-specific CodeCommit URLs along with the availability
    of the CodeCommit service at [http://docs.aws.amazon.com/codecommit/latest/userguide/regions.html](http://docs.aws.amazon.com/codecommit/latest/userguide/regions.html).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: With this step, we have successfully validated and connected our development
    server with the AWS CodeCommit service! But where is our CodeCommit repository?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: To create the repository, log in to the AWS CodeCommit service using URL [https://console.aws.amazon.com/codecommit](https://console.aws.amazon.com/codecommit).
    Remember to change the Region based on what you selected during the key verification
    state.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since this is our first time working with CodeCommit, select the Get Started option
    to begin with. This will display the Create repository page, as shown in the following
    screenshot:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bcb3f74e-2d2b-4fce-abb0-176341c6a6f9.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
- en: Provide a suitable Repository name and an optional Description. Click on Create
    repository once done.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can additionally configure notifications for specific Event types, such
    as pull requests and commits made to your repo in the Configure email notifications page.
    Simply select an existing SNS topic or opt to Create a new topic based on your
    requirements. Once done, click on Save to complete the repository creation process.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the repository created, you can now use the development server and connect
    to it using a simple `git clone` command. You can obtain your repository''s connection
    URL anytime by simply selecting the Connect option present on the Code page:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here''s a snapshot of the first `git clone` command output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3a3932d-ee79-422d-90c0-e441dafb63b9.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: Since the repository is empty, the cloning process simply creates a folder with
    your repository's name on your development server. You can now use this folder
    as a code source control by simply adding your program files, binaries, and other
    application-specific data to it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be using this repository as our WordPress application
    source control and explore a few simple commands and features that are provided
    as a part of AWS CodeCommit.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Working with branches, commits, and triggers
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With your CodeCommit repo created, it's now time to go ahead and use this repository
    as our source control repository. To do so, we will first push a standard WordPress
    application from our local development server to the AWS CodeCommit repository
    using simple Git commands and later run a few more Git commands as well as AWS
    actions to branch and commit our code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'You can obtain a WordPress application ZIP file by downloading it from here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/WordPress/WordPress](https://github.com/WordPress/WordPress)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, first we will need to copy the WordPress application contents
    over to our local repository that was cloned earlier:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the WordPress application is downloaded to your local development server,
    simply unzip and copy its contents over to the local repository. Your local repository
    should now show a folder structure similar to the following screenshot:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/15239bc3-a5e8-4b6e-b3bb-4bc2e291f633.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: 'With the code in place, simply use the following Git commands to commit and
    push the code over to your AWS CodeCommit repository. First up, stage the files
    using the `git add` command:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, commit the changes using the `git commit` command:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And, finally, push the commit over to the AWS CodeCommit repository. Here,
    the keyword `origin` is the default remote name used by Git for your AWS CodeCommit
    repository, whereas `master` is the default branch name:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should see the code get uploaded to your AWS CodeCommit repository, as
    shown in the following image. You can cross-verify this by refreshing and checking
    the Code page on your AWS CodeCommit dashboard as well:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fac448f3-bb8b-45ef-961e-5261da4ba809.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: Similarly, you and your fellow developers can edit and commit the code back
    to the AWS CodeCommit repository. You can also create multiple branches of your
    repository so that developers can work independently on the code without affecting
    the `master` branch. Once the features are all thoroughly tested and verified,
    the individual developer branches can be merged into a more stable `master` branch
    of the software.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a branch in CodeCommit is an extremely easy process! You can use the
    CodeCommit dashboard, the Git command line, or even the AWS CLI to create one
    of your own:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: To create a branch using the AWS CodeCommit dashboard, simply select the Branches option
    from the navigation pane.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, select the Create branch option to bring up the Create branch page. Here,
    provide a suitable Branch name and also select where you would like this new branch
    to Branch from. In this case, since you only have the `master` branch created,
    you can select that for now. Click on Create once done.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can also use the Git command line itself to achieve the same result. In
    this case, from the development server, type in the following command to create
    a new branch:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![](img/4d4cbea3-5d37-4ac6-8bee-738615e8e4ba.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
- en: With the new branch created, you can also use the Compare functionality provided
    by CodeCommit to compare the changes made to the branch against another branch.
    To do so, we first need to perform some changes in the application so that it
    can get reflected as a change.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'Without changing the current branch of the repository, simply update any one
    of the WordPress files by adding or removing a comment. In my case, I simply made
    a few comment changes in the WordPress application''s `index.php` file; however,
    feel free to modify any other file as you see fit. Once the changes are made,
    we once again need to stage, commit, and push the changes over to the new branch
    of our repository:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Stage the changes by using the `git add` command. You can either add all the
    files for staging by using `*` or even specify the filename you wish to stage
    as well:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, commit the changes using the `git commit` command:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And, finally, push the changes over to the branch using the following command:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With the changes pushed, use the Compare option provided under the Commits section
    in the CodeCommit dashboard. Here, select the master as the *source* branch and
    the branch that you created using the Git command line as the Destination branch.
    Click on Compare once done. You should see the changes compared, as shown in the
    following screenshot:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1a7930dc-5e9b-464a-be5d-744725a7061a.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: You can use the Go to file drop-down list to toggle between different files,
    if you have made changes in them. Alternatively, you can also use the Unified and
    Split views to change the visual comparison as you see fit.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'CodeCommit also provides an additional feature called **triggers** that you
    can use to either send notifications to or run some other external code build
    or process. You can assign up to 10 triggers per repository that you create, however,
    at the time of writing this book, CodeCommit only supports AWS SNS and AWS Lambda
    as its trigger mechanisms:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: To create a simple trigger, using the CodeCommit dashboard, select the Settings tab
    from the navigation pane. Here, select the Triggers tab to create as well as view
    the list of existing triggers, if any.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Create trigger option to bring up the Create trigger page. Here,
    you can configure triggers in response to certain repository events, such as Push
    to an existing branch, Create branch or tag, Delete branch or tag, or All repository
    events.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide a Trigger name and select the appropriate Events and Branch name that
    you wish to associate the trigger with. Once done, you can configure the trigger
    to either use an existing SNS topic or a Lambda function as its Service. You can
    even test the functioning of the trigger by selecting the Test trigger option.
    This will simulate a trigger based on the *event* that you would have selected
    earlier.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this way, you can configure triggers for sending notifications to your developers
    as well as trigger-specific Lambda functions based on your repository's requirements.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Introducing AWS CodeDeploy
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With CodeCommit configured and ready to use for our WordPress application, we
    can now move on to yet another Code Suite service that can actually be used to
    deploy the code across thousands of EC2 instances! Here's introducing AWS CodeDeploy!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: AWS CodeDeploy is basically a deployment service that allows you to automate
    the deployment of your applications to Amazon EC2 instances, Lambda functions,
    or even to on-premise instances. There is no limit to what an AWS CodeDeploy service
    can deploy. You can use it for deploying virtually anything from code, packages,
    binaries, scripts, files, and so on. As of writing this book, CodeDeploy only
    supports GitHub repositories and Amazon S3 buckets as the default application
    content repositories. Yes, you heard it right, CodeDeploy does not support CodeCommit
    as a repository source as of now.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the automation, CodeDeploy also provides you with the following set
    of useful benefits. It allows you to:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Quickly create new prototype software and deploy at scale without manual interventions
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easily update to your application code without any downtime
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rollback deployments in case of any errors
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scale your deployment from one to a thousand instances, all without disrupting
    to your existing applications
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section of the chapter, we will be looking at how to set up CodeDeploy
    for our own application deployments, but before we get into that, here's a quick
    look at some of CodeDeploy's essential concepts.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Concepts and terminologies
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CodeDeploy essentially comprises two main configurable sections that can be
    broadly classified as deployments and applications. Here''s a look at each of
    these concepts:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '**Applications:** Applications here imply simple names that are used by CodeDeploy
    to identify individual application codes targeted for specific deployments. An
    application can be deployed either on an EC2 instance, an on-premise instance,
    as well as on a serverless compute platform, such as AWS Lambda.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployments**: Deployments are a collection of deployment configurations
    and deployment types, including:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment configurations**: Deployment configurations are a set of simple
    rules that determine how fast an application will be deployed and the success
    or failure conditions for that particular deployment. For example, for an EC2
    deployment, the configuration rules can dictate the required minimum number of
    healthy instances, whereas with a Lambda function deployment, these rules can
    be used to specify how the traffic is routed to the functions during a deployment.'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment group**: This is a group of EC2 or on-premise instances that are
    either standalone or a part of an auto-scaling group. Since AWS Lambda is a managed
    service, it does not provide any deployment groups.'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment types**: Deployment types indicate the type of method used to
    get the latest version of your application deployed on a particular deployment
    group. There are two deployment types supported:'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In-place deployments**: In this case, the application running on each EC2
    instance is stopped, updated, started, and verified. This form of deployment is
    only supported for EC2 and on-premise instances.'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blue/green deployments**: In this scenario, the underlying instances are
    replaced by newer instances with the updated piece of code. The instances are
    registered to an **Elastic Load Balancer** (**ELB**) that routes traffic to the
    newer instances while the older instances can then be terminated. With the serverless
    platform, the traffic here too is shifted automatically by AWS from the current
    Lambda functions to the current updated ones. Note that all Lambda deployments
    are in fact blue/green deployments only.'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CodeDeploy agent**: CodeDeploy agent is a simple software package that gets
    installed on either an EC2 or an on-premise instance and is used by CodeDeploy
    for setting up and working with application deployments. Once the agent is installed
    on an instance, an associated configuration file is created. This file contains
    application-specific directory paths and other settings that CodeDeploy uses to
    interact with the instances. The file is a simple YAML file and can be located
    in the following directories based on the instance''s operating system:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon Linux, Ubuntu, RedHat Enterprise Linux**: `/etc/codedeploy-agent/conf/codedeployagent.yml`'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows Servers**: `C:ProgramDataAmazonCodeDeployconf.yml`'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application specification files**: Application specification files, or AppSpec
    files, are used to define and manage individual deployments as a series of life
    cycle event hooks. Each hook itself can be another file, such as a simple script
    to start or stop services, install dependencies, and so on. AppSpec files are
    supported in both JSON as well as YAML formats. At the time of the deployment,
    the AWS CodeDeploy agent looks up the name of the current event in the hooks section
    of the AppSpec file. If an event is found, the agent retrieves the list of scripts
    to execute and runs them sequentially in the order in which they were written
    in the AppSpec file.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the basics out of the way, let's quickly look at how we can set up an EC2
    instance to be used with CodeDeploy.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring the CodeDeploy agent
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we begin with the actual launch of our EC2 instance with the CodeDeploy
    agent installed on it, we need to set up an EC2 instance profile as well as an
    instance role that will grant our EC2 instances the necessary permissions to interact
    with both CodeCommit as well as with CodeDeploy:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: To get started, first log in to the AWS Management Console and select the IAM service
    from the services Filter. Alternatively, you can launch the IAM dashboard by selecting
    URL [https://console.aws.amazon.com/iam/](https://console.aws.amazon.com/iam/).
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the IAM dashboard, select the Policies option from the navigation pane
    to bring up the IAM Policies page. Here, click on Create policy to get started.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Create policy page, select the JSON tab and paste the following lines
    of the policy document:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The policy document essentially provides the EC2 instance with the required
    set of permissions to interact with the likes of AWS services, such as CodeDeploy,
    CodeCommit, and CodePipeline.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Click on Review policy once done. In the final Review policy page, provide a
    suitable Name for the policy and click Create policy to complete the process.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the policy created, we now simply assign this to a new IAM Role. To do
    so, select the Roles option from the navigation pane to bring up the IAM Roles page.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on Create role to start the wizard. From the Select type of trusted entity section,
    make sure you select AWS service and filter out EC2 from there. Click on Next:
    Permissions to proceed.'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Attach permissions policy page, filter the earlier created policy and
    attach it to our new role, as depicted in the following screenshot:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ea4394d9-11ce-425f-9325-cc38a33b0aa9.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: Finally, at the Review page, provide your role with a suitable Role Name and
    click on Create role to complete the process.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before launching your EC2 instance with this newly created Role, ensure that
    the role''s Trust Relationship has the following set of AWS services added in
    its policy document:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With this step completed, we are now ready to launch a simple EC2 instance
    and assign the newly created role:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: From the EC2 Management Console, select the Launch Instance option to get started.
    For this particular use case, I've opted to go for the standard Amazon Linux AMI
    (`amzn-ami-hvm-2017.09.1.20171120-x86_64-gp2 - ami-55ef662f`); however, you can
    very well opt for a different Linux OS distribution as per your requirements.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select an appropriate Instance type for hosting our simple WordPress application.
    For now, I've selected the **t2.micro** instance type itself.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, in the Configure Instance Details page, select the appropriate Network,
    Subnet, and IAM Role for our new EC2 instance. Paste the following set of lines
    as User data under the Advanced Details section, as shown in the following code.
    This simple user data script will copy and install the CodeDeploy agent along
    with a few other essential dependencies. You can find the complete copy of the
    following code at [https://github.com/yoyoclouds/Administering-AWS-Volume2](https://github.com/yoyoclouds/Administering-AWS-Volume2):'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Remember to change the `region` parameter as per your current operational region
    value.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Once the required storage is assigned to the instance, move on and assign a
    few essential tags for our EC2 instance. These tags will be used later in CodeDeploy
    to reference our EC2 instances, so make a note of the same.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, create a new security group and make sure that the ports `22` (SSH)
    and `80` (HTTP) are open for internet traffic.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the settings of your instance and launch it. Additionally, remember to
    associate your instance with a key pair as well before you launch it, as it can
    be useful to verify or troubleshoot the AWS CodeDeploy agent.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this, you now have successfully launched and set up a CodeDeploy agent
    on an EC2 instance. In the next section of this chapter, we will look at how you
    can take this installation further by configuring the AppSpec file for the final
    CodeDeploy deployment.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the AppSpec file
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, the AppSpec, or the application specifications file, is
    basically a YAML or JSON backed file used to define life cycle hooks for a particular
    deployment. In this case, with our EC2 instance prepped and ready with the CodeDeploy
    agent, we still need the AppSpec file to define a set of dependencies that will
    essentially install the necessary packages on the EC2 instance, start or stop
    the services, change permissions, and much more.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'The AppSpec file comprises the following sections:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '**Version**: The version of the AppSpec file. Currently, the version number
    supported with CodeDeploy is `0.0`. Do not change this value.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OS**: Specifies the operating system of the underlying EC2/on-premise instance.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Files**: Specifies the files that need to be copied on the instance at the
    time of the deployment process. You can additionally specify a source and a destination
    folder as well for your applications here.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hooks**: Hooks essentially specify when a particular deployment life cycle
    has to be triggered. There are four main types of hooks: `BeforeInstall`, `AfterInstall`,
    `ApplicationStart`, and `ApplicationStop`. Each hook further requires additional
    parameters, such as the `location` of the scripts to execute, a `timeout` value,
    and how the scripts should be `runas`.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a representation of a simple AppSpec file for our WordPress deployment.
    Since we are using the Amazon Linux-backed instance, the `os` value is set to
    `linux` along with other essential parameters, such as `files` and `hooks`. Note
    in our case, we are configuring the WordPress application files to be copied from
    their default location over to `/var/www/html/WordPress` as well:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To create this file, login to your development server and not your CodeDeploy
    instance. Once logged into the development server, open the WordPress application
    directory that we used during the CodeCommit sections of this chapter. This is
    the same directory that we used to sync with our master CodeCommit repository
    as well:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, at the application''s root directory, create a blank `appspec.yml`, and
    copy-paste the `appspec` contents explained earlier:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With the AppSpec file created, we now move on to create the individual files
    for the life cycle hooks. To do so, create a folder named `scripts` within the
    WordPress application directory and create each of these individual shell scripts
    within it:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create the `install_dependencies.sh` script that will essentially install the
    necessary packages required to run WordPress on an instance:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Similarly, create the `change_permissions.sh` script that modifies the permissions
    of the files present in the scripts folder to *executable*:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And, finally, create the `start_server.sh` and the `stop_server.sh` scripts
    that will start and stop the `httpd` and `mysql` services on the deployment EC2
    instances:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Got this far? Awesome! We are almost done with the AppSpec files, with just
    one small step left: uploading these changes to our CodeCommit repository!'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, run the following set of commands from the deployment server:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Et voila! The WordPress application and our deployment scripts are all uploaded
    to our CodeCommit branch and ready for deployment! In the next section, we will
    create and configure an application and deployment group for our CodeDeploy.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Creating a CodeDeploy application and deployment group
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our AppSpec file and scripts in place and the EC2 instance set up with
    the CodeDeploy agent as well, the final thing left is to configure AWS CodeDeploy
    and tie these things together:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Start off by logging into the AWS CodeDeploy service by selecting URL [https://console.aws.amazon.com/codedeploy/home](https://console.aws.amazon.com/codedeploy/home).
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since this is the first time we are using CodeDeploy, select the Get Started
    Now option. Here, you will be prompted to select either a Sample deployment that
    deploys a sample application on the EC2 instances or, alternatively, go for a
    Custom deployment if you have your code and EC2 instances up and running. In this
    case, we will select the Custom deployment option itself.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Create application page, start off by providing a suitable Application
    name, Compute Platform, and a Deployment group name. Remember to select the EC2/On-premises option
    from the Compute Platform, as shown in the following screenshot:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/35fbb4b7-afbf-4e1f-8b1e-f21272c33a64.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: Next, in the Deployment type section, choose the In-place deployment option
    for now. This will enable CodeDeploy to update the existing instances with the
    revised set of application code with some amount of downtime.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Environment configuration section, you can specify any combination of
    Auto Scaling groups, Amazon EC2 instances, and On-premises instances to add instances
    to this deployment group. Since we have created an EC2 instance in our earlier
    steps with the CodeDeploy agent installed in it, select the Amazon EC2 instances tab.
    From the Tag group drop-down, select the instance's Key and Value, as shown.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that these are the same tags that you would have configured to your instance
    before its launch in our earlier sections:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c965bce-6159-4e2d-bc9a-e4c121dc0f99.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: Moving on, in the Deployment configuration section, you can choose from a list
    of default and custom deployment configurations. As discussed earlier, a deployment
    configuration is a set of rules that determines how fast an application will be
    deployed along with the definition of success or failure conditions for a particular
    deployment.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are three default configurations provided by AWS CodeDeploy itself:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '**OneAtATime**: Routes traffic to one instance in the replacement environment
    at a time'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HalfAtATime**: Routes traffic to up to half the instances in the replacement
    environment at a time'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AllAtOnce**: Routes traffic to all instances in the replacement environment
    all at once'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we are working with just a single EC2 instance as of now, go ahead and
    select the OneAtATime deployment configuration option.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Finally, select the IAM Role that we created and assigned our EC2 instance to
    at the time of launching, using the Service Role drop-down list. Once done, select
    the Create application option to complete the process!
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There you have it! If you made it this far then you have successfully configured
    both AWS CodeCommit and AWS CodeDeploy for our WordPress application's deployment!
    But we are still missing the glue that ties all these services together, and that
    precisely is what we will be talking about in the next section with the introduction
    of AWS CodePipeline!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Introducing AWS CodePipeline
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS CodePipeline is a continuous delivery service that you can use to model,
    visualize, and automate the steps required to release your application software.
    This is made possible by building *pipelines* that contain one or more *stages*.
    The stages can be broadly classified as *build*, where the code is compiled and
    built using, say, AWS CodeBuild or some other third-party tool, *staging*, and
    *deployment*, where the code is pushed on to compute instances using AWS CodeDeploy,
    and so on. Each stage internally describes a set of actions that it needs to perform
    in order to prepare the software for its release. This action can be anything
    from building your source code from a Git repository, to making changes to a file,
    or deploying packages, and so on. Every change made to either your code or some
    configurational setting within CodePipeline is considered as a *revision* and
    you can have multiple such revisions created within a single stage of a pipeline.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Even changes made to a single stage within the pipeline results in all actions
    across all stages being re-executed.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: You can use these features provided by CodePipeline to effectively manage and
    monitor the release of your software. In this section, we will be continuing with
    our use case set up earlier using CodeCommit and CodeDeploy and see how we can
    truly build an end-to-end continuous delivery cycle using AWS CodePipeline.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own continuous delivery pipeline
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Getting started with CodePipeline is extremely easy provided you have all the
    necessary prerequisites met, which include setting up the CodeCommit repository
    with your latest piece of application code (in this case, the WordPress application),
    as well as configuring the application and the AppSpec file using CodeDeploy:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, launch the CodePipeline Management dashboard by selecting URL [https://console.aws.amazon.com/codepipeline/home](https://console.aws.amazon.com/codepipeline/home).
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since this is our first setup, click on the Get Started option to get going.
    This will bring up the Getting started with AWS CodePipeline wizard, as shown
    in the following screenshot. Start off by providing a suitable Pipeline name and
    click Next step to continue:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6e2daad6-3d4c-4d2e-9e2c-7049f95fbd0c.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: Next, in the Source page, we need to select and configure the source for our
    new pipeline. At the time of writing this book, CodePipeline supports three source
    code providers, namely Amazon S3, AWS CodeCommit, and GitHub. For the purpose
    of this use case, go ahead and select AWS CodeCommit from the Source drop-down
    list.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will automatically prompt you to enter the subsequent CodeCommit Repository
    name as well as its corresponding Branch name. Make sure you provide the same
    branch name that contains the latest WordPress code as well as the AppSpec file.
    Click on Next step to continue.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The third stage of the Pipeline setup is the Build stage where you can specify
    the build provider. CodePipeline supports three build providers, namely AWS CodeBuild,
    Jenkins, and Solano CI. Since our WordPress installation doesn't require any compilations
    or build procedures, simply select the No Build option from the drop-down list
    and click on Next step to continue.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The fourth state requires the Deployment configurations to be set up for the
    pipeline. Here too you are provided with various options that you can choose to
    leverage based on your needs. At present, CodePipeline supports AWS Opsworks,
    AWS CodeDeploy, AWS CloudFormation, and AWS Elastic Beanstalk as the Deployment
    providers. Since we have already configured AWS CodeDeploy for our use case, select
    the same from the drop-down list.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, fill in the correct Application name as well as the Deployment group that
    we configured during the setup of CodeDeploy. Click on Next step once done:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1d2c518e-e810-42cb-b73a-9cb322e0dfd8.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: The final step required is to configure the Service Role. The service role essentially
    grants CodePipeline permissions to use resources in your AWS account. Provide
    a suitable Role name and click on Next step to review the pipeline's configuration.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the Review your pipeline page, ensure that all the fields are correctly configured
    and click on Create pipeline when done.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Selecting this option first creates a unique S3 bucket within your environment
    that will contain and store all the necessary artifacts for this particular pipeline.
    Once the pipeline is created, you can view it on the AWS CodePipeline dashboard.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the pipeline all set up, you can now test the entire setup as one cohesive
    solution!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'First up, ensure that there are no errors in either of the stages during the
    deployments. In case there are any errors, simply select the particular error
    link provided in the stage and follow it back to its source, which can be anywhere
    from issues in CodeCommit to even the setting up of CodeDeploy. Here''s a screenshot
    of the pipeline that we created using an accumulation of all of the preceding
    sections:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c30e91b-5bea-434f-990b-7254d2b4b6b1.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: Here, you can choose to add more stages to your pipeline by simply selecting
    the Edit option, as highlighted earlier. Additionally, you can also view your
    pipeline's execution history by selecting the View pipeline history option.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: In the Edit pipeline page, you can choose to add one or more stages to your
    pipeline as you see fit. Simply select the + Stage option provided at the end
    of each existing stage. This will bring up a new dialog where you can specify
    the stage's Name as well as define one or more actions.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following use case where we need to add an approval step before
    the code actually gets pushed into the staging area. In that case, we need to
    add a new stage between the existing Source and Staging stages:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Click on the + Stage option and provide a suitable name for this new stage.
    Next, select the + Action option to add the rules for setting up the approval
    process.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Add action dialog box, start by selecting the type of action from the
    Action category drop-down list. The following list of actions can be added to
    a stage: Approval, Source, Build, Test, Deploy, and Invoke. For this use case,
    select Approval:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1fbe76eb-b778-45dc-ab77-3f728ce8f535.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
- en: Fill in a suitable Action name and select an appropriate Action type as well.
    At present, only a Manual approval configuration option is provided by CodePipeline.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, select either one of a pre-existing SNS topics using the SNS topic
    ARN field and click on Add action once completed.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the new stage added, click on Save pipeline changes to commit the change.
    You should have a new stage added and visible in your pipeline, as shown in the
    following screenshot:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/036a9d75-3287-41b0-af6a-48cbe498f564.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: 'Once the Source stage is prepped, the pipeline automatically halts at the Approval stage,
    as depicted in the following screenshot. Here, you can approve the process by
    simply selecting the Review option and then selecting the `approval` command.
    Doing so initiates the final Staging stage which invokes the CodeDeploy service
    to deploy the WordPress code over to our awaiting EC2 instance:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/86c23e34-02e9-45b2-8a8d-537bea5750a8.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
- en: 'After a few minutes, the application is successfully uploaded on the instance
    and is up and running as well. You can verify this by making a note of your instances
    public IP address and typing in the following URL on a browser:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Remember to prefix `WordPress` in your URL since the `AppSpec` file clearly
    pointed to the root of the application at the `/var/www/html/WordPress` directory
    and not at `/var/www/html` itself.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: In this way, you can easily leverage and automate the deployments of your application
    code using the AWS Code Suite of services! Amazing isn't it? But that's not all
    folks! There is a ton of other fascinating things that I would like you to learn
    and explore, all covered in the next section itself.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Planning your next steps
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, we have covered a lot of new features and services in this chapter. However,
    there are still a few things that I would recommend you need to read up on your
    own as well. First up is the AWS CodeStar!
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'AWS CodeStar is an amazing service that can help developers create, manage,
    and work on developing applications, all one place. The integral part of CodeStar
    that enables this is called **projects**. Developers can create projects based
    on predefined templates that contain a supported programming model which is ready
    to use for developing. You can additionally select hosting for your application
    from a variety of options that include Amazon EC2, Elastic Beanstalk, and AWS
    Lambda as well! CodeStar comes with easy connectivity with various IDEs as well:
    Eclipse, Visual Studio, just to name a few. You can read more about *AWS CodeStar*
    at [http://docs.aws.amazon.com/codestar/latest/userguide/welcome.html](http://docs.aws.amazon.com/codestar/latest/userguide/welcome.html).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The second awesome service worth trying out is AWS Cloud9! AWS Cloud9 is a cloud-based
    IDE that you can use to write, debug, and run code, all with a standard web browser!
    Cloud9 comes pre-packaged with essential tools for the most popular programming
    languages, including JavaScript, Python, PHP, Node.js, C++, and much more, and
    the best part is you can easily integrate Cloud9 with the likes of other AWS services,
    such as CodeCommit, CodeStar, and so on. You can read more about AWS Cloud9 at [https://docs.aws.amazon.com/cloud9/latest/user-guide/welcome.html](https://docs.aws.amazon.com/cloud9/latest/user-guide/welcome.html).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Last, but not least, I would also recommend that you try out a complete, end-to-end
    CI/CD solution provided by the **AWS Partner Network** (**APN**) blog that leverages
    a CloudFormation stack to deploy a full-fledged AWS Code Suite, including CodeBuild,
    CodeCommit, CodeDeploy, and CodePipeline! The stack gives you a feel for using
    AWS CodeBuild as a service and also provides you with a template to automate your
    own Code deployments using CloudFormation. To view the blog visit [https://aws.amazon.com/blogs/apn/deploy-to-production-using-aws-codebuild-and-the-aws-developer-tools-suite/](https://aws.amazon.com/blogs/apn/deploy-to-production-using-aws-codebuild-and-the-aws-developer-tools-suite/).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here's a quick round up of the topics that we have covered so far in this chapter!
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: We started off by learning and understanding a bit about the AWS Code Suite
    of services and how they tie into the continuous integration and continuous delivery
    life cycle. We then learned a bit about AWS CodeDeploy and how easy it is to get
    started with it. We created a simple CodeCommit repository and used that to store
    our sample WordPress application as well. Later, we looked at AWS CodeDeploy and
    how it works. We also configured a CodeDeploy agent and leveraged the AppSpec
    file for our WordPress application's deployment life cycle. Finally, we tied it
    all together by integrating the work done so far with AWS CodePipeline and ended
    the chapter with a few essential things to read and try out on your own!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will be exploring two application-specific services
    and look at how you can leverage them for your requirements: Amazon SQS and Amazon
    SNS. So stay tuned!'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
