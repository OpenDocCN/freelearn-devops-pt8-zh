<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Provisioning IaaS with Terraform"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Provisioning IaaS with Terraform</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Configuring the Terraform AWS provider</li><li class="listitem" style="list-style-type: disc">Creating and using an SSH key pair to use on AWS</li><li class="listitem" style="list-style-type: disc">Using AWS security groups with Terraform</li><li class="listitem" style="list-style-type: disc">Creating an Ubuntu EC2 instance with Terraform</li><li class="listitem" style="list-style-type: disc">Generating meaningful outputs with Terraform</li><li class="listitem" style="list-style-type: disc">Using contextual defaults with Terraform</li><li class="listitem" style="list-style-type: disc">Managing S3 storage with Terraform</li><li class="listitem" style="list-style-type: disc">Creating private Docker repositories with Terraform</li><li class="listitem" style="list-style-type: disc">Creating a PostgreSQL RDS database with Terraform</li><li class="listitem" style="list-style-type: disc">Enabling CloudWatch Logs for Docker with Terraform</li><li class="listitem" style="list-style-type: disc">Managing IAM users with Terraform</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec27"/>Introduction</h1></div></div></div><p>A modern infrastructure often uses multiple providers <span class="strong"><strong>Amazon Web Services</strong></span> (<span class="strong"><strong>AWS</strong></span>), OpenStack, Google Cloud, Digital Ocean, and many others), combined with multiple external services (DNS, mail, monitoring, and others). Many providers propose their own automation tool, but the power of Terraform is that it allows you to manage it all from one place, all using code. With it, you can dynamically create machines at two IaaS providers depending on the environment, register their names at another DNS provider, enable monitoring at a third-party monitoring company, while configuring the company GitHub account and sending the application logs to an appropriate service. On top of that, it can delegate configuration to those who do it well (configuration management tools such as Chef, Puppet, and so on), all with the same tool. The state of your infrastructure is described, stored, versioned, and shared.</p><p>In this chapter, we'll discover how to use Terraform to bootstrap a fully capable infrastructure <a id="id125" class="indexterm"/>on AWS. You'll know everything from launching fine-tuned EC2 instances and optimized RDS databases dynamically in different regions, to creating tight security groups, deploying SSH key pairs and securing IAM access keys, enabling log storage with CloudWatch, generating useful outputs, handling infinite <span class="strong"><strong>Simple Storage Service</strong></span> (<span class="strong"><strong>S3</strong></span>) storage, and using private Docker repositories.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>The Terraform version in use for this book is 0.7.2.</p></div></div></div></div>
<div class="section" title="Configuring the Terraform AWS provider"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec28"/>Configuring the Terraform AWS provider</h1></div></div></div><p>We can <a id="id126" class="indexterm"/>use Terraform with many IaaS providers, such as Google Cloud or Digital Ocean. Here, we'll configure Terraform to be used with AWS and stick with this provider for the rest of the chapter.</p><p>For <a id="id127" class="indexterm"/>Terraform to interact with an IaaS, it needs to have a <span class="emphasis"><em>provider</em></span> configured.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec64"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An AWS account with keys</li><li class="listitem" style="list-style-type: disc">A working Terraform installation</li><li class="listitem" style="list-style-type: disc">An empty directory to store your infrastructure code</li><li class="listitem" style="list-style-type: disc">An Internet connection</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec65"/>How to do it…</h2></div></div></div><p>To configure the AWS provider in Terraform, we'll need the following three files:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A file declaring our variables, an optional description, and an optional default for each (<code class="literal">variables.tf</code>)</li><li class="listitem" style="list-style-type: disc">A file setting the variables for the whole project (<code class="literal">terraform.tfvars</code>)</li><li class="listitem" style="list-style-type: disc">A provider file (<code class="literal">provider.tf</code>)</li></ul></div><p>Lets declare our variables in the <code class="literal">variables.tf</code> file. We can start by declaring what's usually known as the <code class="literal">AWS_DEFAULT_REGION</code>, <code class="literal">AWS_ACCESS_KEY_ID</code>, and <code class="literal">AWS_SECRET_ACCESS_KEY</code> environment variables:</p><div class="informalexample"><pre class="programlisting">variable "aws_access_key" {
  description = "AWS Access Key"
}

variable "aws_secret_key" {
  description = "AWS Secret Key"
}

variable "aws_region" {
  default     = "eu-west-1"
  description = "AWS Region"
}</pre></div><p>Set the <a id="id128" class="indexterm"/>two variables matching the AWS account in the <code class="literal">terraform.tfvars</code> file. It's not recommended to check this file into <a id="id129" class="indexterm"/>source control: it's better to use an example file instead (that is: <code class="literal">terraform.tfvars.example</code>). It's also recommended to use a dedicated Terraform user for AWS, not the root account keys:</p><div class="informalexample"><pre class="programlisting">aws_access_key = "&lt; your AWS_ACCESS_KEY &gt;"
aws_secret_key = "&lt; your AWS_SECRET_KEY &gt;"</pre></div><p>Now, let's tie all this together into a single file, <code class="literal">provider.tf</code>:</p><div class="informalexample"><pre class="programlisting">provider "aws" {
  access_key = "${var.aws_access_key}"
  secret_key = "${var.aws_secret_key}"
  region     = "${var.aws_region}"
}</pre></div><p>Apply the following Terraform code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ terraform apply</strong></span>

<span class="strong"><strong>Apply complete! Resources: 0 added, 0 changed, 0 destroyed.</strong></span>
</pre></div><p>It only means the code is valid, not that it can really authenticate with AWS (try with a bad pair of keys). For this, we'll need to create a resource on AWS.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>You now have a new file named <code class="literal">terraform.tfstate</code> that has been created at the root of your repository. This file is critical: it's the stored state of your infrastructure. Don't hesitate to look at it, it's a text file.</p></div></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec66"/>How it works…</h2></div></div></div><p>This <a id="id130" class="indexterm"/>first encounter with <span class="strong"><strong>HashiCorp Configuration Language</strong></span> (<span class="strong"><strong>HCL</strong></span>), the language used by Terraform, and other Hashicorp products looks pretty familiar: it's a structured language fully compatible with JSON. We can find more information about HCL here: <a class="ulink" href="https://github.com/hashicorp/hcl">https://github.com/hashicorp/hcl</a>. In this case, we've declared variables with an optional description for reference. We could have declared them simply with the following:</p><div class="informalexample"><pre class="programlisting">variable "aws_access_key" { }</pre></div><p>All variables are referenced to use the following structure:</p><div class="informalexample"><pre class="programlisting">${var.variable_name}</pre></div><p>If the variable has been declared with a default, as our <code class="literal">aws_region</code> has been declared with a default of <code class="literal">eu-west-1</code>; this value will be used if there's no override in the <code class="literal">terraform.tfvars</code> file.</p><p>What <a id="id131" class="indexterm"/>would have happened if we didn't provide a safe default for our variable? Terraform would have asked us for a value when <a id="id132" class="indexterm"/>executed:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ terraform apply</strong></span>
<span class="strong"><strong>var.aws_region</strong></span>
<span class="strong"><strong>  AWS Region</strong></span>

<span class="strong"><strong>  Enter a value:</strong></span>
</pre></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec67"/>There's more…</h2></div></div></div><p>We've used values directly inside the Terraform code to configure our AWS credentials. If you're already using AWS on the command line, chances are you already have a set of standard environment variables:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ echo ${AWS_ACCESS_KEY_ID}</strong></span>
<span class="strong"><strong>&lt;your AWS_ACCESS_KEY_ID&gt;</strong></span>
<span class="strong"><strong>$ echo ${AWS_SECRET_ACCESS_KEY}</strong></span>
<span class="strong"><strong>&lt;your AWS_SECRET_ACCESS_KEY&gt;</strong></span>
<span class="strong"><strong>$ echo ${AWS_DEFAULT_REGION}</strong></span>
<span class="strong"><strong>eu-west-1</strong></span>
</pre></div><p>If not, you can simply set them as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ export AWS_ACCESS_KEY_ID="123"</strong></span>
<span class="strong"><strong>$ export AWS_SECRET_ACCESS_KEY="456"</strong></span>
<span class="strong"><strong>$ export AWS_DEFAULT_REGION="eu-west-1"</strong></span>
</pre></div><p>Then Terraform can use them directly, and the only code you have to type would be to declare your provider! That's handy when working with different tools.</p><p>The <code class="literal">provider.tf</code> will then look as simple as this:</p><div class="informalexample"><pre class="programlisting">provider "aws" { }</pre></div></div></div>
<div class="section" title="Creating and using an SSH key pair to use on AWS"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec29"/>Creating and using an SSH key pair to use on AWS</h1></div></div></div><p>Now <a id="id133" class="indexterm"/>we have our AWS provider configured in Terraform, let's add a SSH key pair to use on a default account of the virtual <a id="id134" class="indexterm"/>machines we intend to launch soon.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec68"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Terraform installation</li><li class="listitem" style="list-style-type: disc">An AWS provider configured in Terraform</li><li class="listitem" style="list-style-type: disc">Generate a pair of SSH keys somewhere you remember, for example, in the <code class="literal">keys</code> folder at the root of your repo:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mkdir keys</strong></span>
<span class="strong"><strong>$ ssh-keygen -q -f keys/aws_terraform -C aws_terraform_ssh_key -N ''</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc">An Internet connection</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec69"/>How to do it…</h2></div></div></div><p>The resource we want for this is named <code class="literal">aws_key_pair</code>. Let's use it inside a <code class="literal">keys.tf</code> file, and paste the public key content:</p><div class="informalexample"><pre class="programlisting">resource "aws_key_pair" "admin_key" {
  key_name   = "admin_key"
  public_key = "ssh-rsa AAAAB3[…]"
}</pre></div><p>This will simply upload your public key to your AWS account under the name <code class="literal">admin_key</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ terraform apply</strong></span>
<span class="strong"><strong>aws_key_pair.admin_key: Creating...</strong></span>
<span class="strong"><strong>  fingerprint: "" =&gt; "&lt;computed&gt;"</strong></span>
<span class="strong"><strong>  key_name:    "" =&gt; "admin_key"</strong></span>
<span class="strong"><strong>  public_key:  "" =&gt; "ssh-rsa AAAAB3[…]"</strong></span>
<span class="strong"><strong>aws_key_pair.admin_key: Creation complete</strong></span>

<span class="strong"><strong>Apply complete! Resources: 1 added, 0 changed, 0 destroyed.</strong></span>
</pre></div><p>If you manually navigate to your AWS account, in <span class="strong"><strong>EC2</strong></span> | <span class="strong"><strong>Network &amp; Security</strong></span> | <span class="strong"><strong>Key Pairs</strong></span>, you'll now find your key:</p><div class="mediaobject"><img src="graphics/B05671_02_01.jpg" alt="How to do it…"/></div><p>Another way to use our key with Terraform and AWS would be to read it directly from the file, and that would show us how to use file interpolation with Terraform.</p><p>To <a id="id135" class="indexterm"/>do this, let's declare a new empty variable to store our public key in <code class="literal">variables.tf</code>:</p><div class="informalexample"><pre class="programlisting">variable "aws_ssh_admin_key_file" { }</pre></div><p>Initialize <a id="id136" class="indexterm"/>the variable to the path of the key in <code class="literal">terraform.tfvars</code>:</p><div class="informalexample"><pre class="programlisting">aws_ssh_admin_key_file = "keys/aws_terraform"</pre></div><p>Now let's use it in place of our previous <code class="literal">keys.tf</code> code, using the <code class="literal">file()</code> interpolation:</p><div class="informalexample"><pre class="programlisting">resource "aws_key_pair" "admin_key" {
  key_name   = "admin_key"
  public_key = "${file("${var.aws_ssh_admin_key_file}.pub")}"
}</pre></div><p>This is a much clearer and more concise way of accessing the content of the public key from the Terraform resource. It's also easier to maintain, as changing the key will only require to replace the file and nothing more.</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec70"/>How it works…</h2></div></div></div><p>Our first resource, <code class="literal">aws_key_pair</code> takes two arguments (a key name and the public key content). That's how all resources in Terraform work.</p><p>We used our first <span class="emphasis"><em>file</em></span> interpolation, using a variable, to show how to use a more dynamic code for our infrastructure.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec71"/>There's more…</h2></div></div></div><p>Using Ansible, we can create a <span class="emphasis"><em>role</em></span> to do the same job. Here's how we can manage our EC2 key pair using a variable, with the name <code class="literal">admin_key</code>. For simplification, we're using the three usual environment variables—<code class="literal">AWS_ACCESS_KEY_ID</code>, <code class="literal">AWS_SECRET_ACCESS_KEY</code>, and <code class="literal">AWS_DEFAULT_REGION</code>:</p><p>Here's a typical Ansible file hierarchy:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>├── keys</strong></span>
<span class="strong"><strong>│   ├── aws_terraform</strong></span>
<span class="strong"><strong>│   └── aws_terraform.pub</strong></span>
<span class="strong"><strong>├── main.yml</strong></span>
<span class="strong"><strong>└── roles</strong></span>
<span class="strong"><strong>    └── ec2_keys</strong></span>
<span class="strong"><strong>        └── tasks</strong></span>
<span class="strong"><strong>            └── main.yml</strong></span>
</pre></div><p>In the <a id="id137" class="indexterm"/>main file (<code class="literal">main.yml</code>), let's declare <a id="id138" class="indexterm"/>that our host (<code class="literal">localhost</code>) will apply the role dedicated to manage our keys:</p><div class="informalexample"><pre class="programlisting">---
- hosts: localhost
  roles:
  - ec2_keys</pre></div><p>In the <code class="literal">ec2_keys</code> main task file, create the EC2 key (<code class="literal">roles/ec2_keys/tasks/main.yml</code>):</p><div class="informalexample"><pre class="programlisting">---
  - name: ec2 admin key
    ec2_key:
      name: admin_key
      key_material: "{{ item }}"
    with_file: './keys/aws_terraform.pub'</pre></div><p>Execute the code with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ansible-playbook -i localhost main.yml</strong></span>
<span class="strong"><strong>TASK [ec2_keys : ec2 admin key] ************************************************</strong></span>
<span class="strong"><strong>ok: [localhost] =&gt; (item=ssh-rsa AAAA[…] aws_terraform_ssh)</strong></span>

<span class="strong"><strong>PLAY RECAP *********************************************************************</strong></span>
<span class="strong"><strong>localhost                  : ok=2    changed=0    unreachable=0    failed=0</strong></span>
</pre></div></div></div>
<div class="section" title="Using AWS security groups with Terraform"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec30"/>Using AWS security groups with Terraform</h1></div></div></div><p>Amazon's <a id="id139" class="indexterm"/>security groups are similar to <a id="id140" class="indexterm"/>traditional firewalls, with ingress (incoming traffic) and egress (outgoing traffic) rules applied to EC2 instances. Those rules can be updated on-demand. We'll create an initial security group allowing ingress <span class="strong"><strong>Secure Shell</strong></span> (<span class="strong"><strong>SSH</strong></span>) traffic only for our own IP <a id="id141" class="indexterm"/>address, while allowing all outgoing traffic.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec72"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Terraform installation</li><li class="listitem" style="list-style-type: disc">An AWS provider configured in Terraform (refer to the previous recipe)</li><li class="listitem" style="list-style-type: disc">An Internet connection</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec73"/>How to do it…</h2></div></div></div><p>The resource we're using is called <code class="literal">aws_security_group</code>. Here's the basic structure:</p><div class="informalexample"><pre class="programlisting">resource "aws_security_group" "base_security_group" {
  name        = "base_security_group"
  description = "Base Security Group"

  ingress { }

  egress { }

}</pre></div><p>We <a id="id142" class="indexterm"/>know we want to allow inbound TCP/22 for <a id="id143" class="indexterm"/>SSH only for our own IP (replace 1.2.3.4/32 with yours!), and allow everything outbound. Here's how it looks:</p><div class="informalexample"><pre class="programlisting">ingress {
  from_port   = 22
  to_port     = 22
  protocol    = "tcp"
  cidr_blocks = ["1.2.3.4/32"]
 }

egress {
  from_port   = 0
  to_port     = 0
  protocol    = "-1"
  cidr_blocks = ["0.0.0.0/0"]
}</pre></div><p>You can add a name tag for easier reference later:</p><div class="informalexample"><pre class="programlisting">tags {
  Name = "base_security_group"
}</pre></div><p>Apply this and you're good to go:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ terraform apply</strong></span>
<span class="strong"><strong>aws_security_group.base_security_group: Creating...</strong></span>
<span class="strong"><strong>[…]</strong></span>
<span class="strong"><strong>aws_security_group.base_security_group: Creation complete</strong></span>

<span class="strong"><strong>Apply complete! Resources: 1 added, 0 changed, 0 destroyed.</strong></span>
</pre></div><p>You can see your newly created security group by logging into the AWS Console and navigating to <span class="strong"><strong>EC2 Dashboard</strong></span> | <span class="strong"><strong>Network &amp; Security</strong></span> | <span class="strong"><strong>Security Groups</strong></span>:</p><div class="mediaobject"><img src="graphics/B05671_02_02.jpg" alt="How to do it…"/></div><p>Another <a id="id144" class="indexterm"/>way of accessing the same AWS <a id="id145" class="indexterm"/>Console information is through the AWS command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ aws ec2 describe-security-groups --group-names base_security_group</strong></span>
<span class="strong"><strong>{...}</strong></span>
</pre></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec74"/>There's more…</h2></div></div></div><p>We can achieve the same result using Ansible. Here's the equivalent of what we just did with Terraform in this recipe:</p><div class="informalexample"><pre class="programlisting">---
  - name: base security group
    ec2_group:
      name: base_security_group
      description: Base Security Group
      rules:
        - proto: tcp
          from_port: 22
          to_port: 22
          cidr_ip: 1.2.3.4/32</pre></div></div></div>
<div class="section" title="Creating an Ubuntu EC2 instance with Terraform"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec31"/>Creating an Ubuntu EC2 instance with Terraform</h1></div></div></div><p>We have <a id="id146" class="indexterm"/>previously created the requirements to launch a standard virtual machine on AWS EC2 (an SSH key pair and a security group). Let's now launch this virtual machine on EC2, using the specified SSH key pair <a id="id147" class="indexterm"/>to log into it and placed inside the security group, so (in our case) SSH is only available from a specific IP address.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>This example uses the <code class="literal">t2.micro</code> instance available for free in the AWS Free Tier.</p></div></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec75"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Terraform installation</li><li class="listitem" style="list-style-type: disc">An AWS provider, a SSH key pair, and a Security Group configured in Terraform (refer to the previous recipes)</li><li class="listitem" style="list-style-type: disc">An Internet connection</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec76"/>How to do it…</h2></div></div></div><p>First, you need to find the correct AMI for your machine. An AMI is like a system disk image for AWS, and is referred to by its ID (that is: ami-df3bceb0 or ami-f2fc9d81). In the <a id="id148" class="indexterm"/>Ubuntu case, you can find the AMI you want by going to their Amazon EC2 AMI Locator page (<a class="ulink" href="https://cloud-images.ubuntu.com/locator/ec2/">https://cloud-images.ubuntu.com/locator/ec2/</a>). In this case, I selected a Xenial release (16.04 LTS), on the eu-west-1 zone (Ireland), running on HVM virtualization and backed by SSD disks. This leaves us with one result—<code class="literal">ami-ee6b189d</code>:</p><div class="mediaobject"><img src="graphics/B05671_02_03.jpg" alt="How to do it…"/></div><p>Start by declaring this variable in the <code class="literal">variables.tf</code> file started in the first recipe, using a default value corresponding to the AMI ID we found previously:</p><div class="informalexample"><pre class="programlisting">variable "ami" {
  default = "ami-ee6b189d"
}</pre></div><p>Now let's declare the instance type, specifying it as a default:</p><div class="informalexample"><pre class="programlisting">variable "aws_instance_type" {
  default = "t2.micro"
}</pre></div><p>Let's use those variables to create the Terraform <code class="literal">aws_instance</code> resource. Locally declared <a id="id149" class="indexterm"/>variables are available using <a id="id150" class="indexterm"/>the <code class="literal">${var.variable_name}</code> structure, and internal resource attributes are accessed using the <code class="literal">${resource_type.resource_name.attribute}</code> structure:</p><div class="informalexample"><pre class="programlisting">resource "aws_instance" "dev" {
  ami                         = "${var.ami}"
  instance_type               = "${var.aws_instance_type}"
  key_name                    = "${aws_key_pair.admin_key.key_name}"
  security_groups             = ["${aws_security_group.base_security_group.name}"]
  associate_public_ip_address = true

  tags {
    Name = "Ubuntu launched by Terraform"
  }
}</pre></div><p>Apply the following code:</p><div class="informalexample"><pre class="programlisting">$ terraform apply
aws_key_pair.admin_key: Creating...
[…]
aws_security_group.base_security_group: Creating...
[…]
aws_instance.dev: Creating...
[…]</pre></div><p>Navigate to the AWS EC2 dashboard under <span class="strong"><strong>Instances</strong></span> | <span class="strong"><strong>Instances</strong></span>, select your instance and note the public IP:</p><div class="mediaobject"><img src="graphics/B05671_02_04.jpg" alt="How to do it…"/></div><p>Try to log into it:</p><div class="informalexample"><pre class="programlisting">$ ssh -i keys/aws_terraform ubuntu@52.210.12.27
Welcome to Ubuntu 16.04.1 LTS (GNU/Linux 4.4.0-36-generic x86_64)
ubuntu@ip-172-31-18-156:~$</pre></div><p>You <a id="id151" class="indexterm"/>can apply and apply by refreshing its state against Amazon's as Terraform knows remote and local states are the same, and <a id="id152" class="indexterm"/>therefore it doesn't recreate endlessly new VMs each time.</p><p>You've successfully launched your first AWS EC2 instance using repeatable Terraform code!</p><div class="section" title="Scaling the number of instances"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec33"/>Scaling the number of instances</h3></div></div></div><p>What if <a id="id153" class="indexterm"/>you want to launch two similar instances, maybe for debugging purposes, or for instant action behind a load balancer? It's very easy with Terraform, just use the <code class="literal">count</code> option inside the <code class="literal">aws_instance</code> resource, and that will launch the required amount of instances:</p><div class="informalexample"><pre class="programlisting">count = 2</pre></div><p>Next, <code class="literal">terraform apply</code> this and observe Terraform automatically creating a new machine according to the counter:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ terraform apply</strong></span>
<span class="strong"><strong>aws_key_pair.admin_key: Refreshing state... (ID: admin_key)</strong></span>
<span class="strong"><strong>aws_security_group.base_security_group: Refreshing state... (ID: sg-d3dbd8b4)</strong></span>
<span class="strong"><strong>aws_instance.dev.0: Refreshing state... (ID: i-0018b1044953371ae)</strong></span>
<span class="strong"><strong>aws_instance.dev.1: Creating...</strong></span>
<span class="strong"><strong>[...]</strong></span>
<span class="strong"><strong>aws_instance.dev.1: Creation complete</strong></span>

<span class="strong"><strong>Apply complete! Resources: 1 added, 0 changed, 0 destroyed.</strong></span>
</pre></div><p>The second server shows up in the AWS Console:</p><div class="mediaobject"><img src="graphics/B05671_02_05.jpg" alt="Scaling the number of instances"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>Remember, the command to destroy a Terraform infrastructure is <code class="literal">terraform destroy</code>.</p></div></div></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec77"/>There's more…</h2></div></div></div><p>We can <a id="id154" class="indexterm"/>achieve similar results using Ansible. Here's how it looks, using <code class="literal">admin_key</code> and <code class="literal">base_security_group</code> created in the previous recipes:</p><div class="informalexample"><pre class="programlisting">---
  - name: dev instance
    ec2:
      key_name: admin_key
      group: base_security_group
      instance_type: t2.micro
      image: ami-ee6b189d
      wait: yes</pre></div></div></div>
<div class="section" title="Generating meaningful outputs with Terraform"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec32"/>Generating meaningful outputs with Terraform</h1></div></div></div><p>Wouldn't it <a id="id155" class="indexterm"/>be great if Terraform could show us useful, informational output after a successful run? Following what we've done so far, <a id="id156" class="indexterm"/>it would be helpful to know how to connect to the instance, what are the local and public IP addresses, or see the security groups used. That's what Terraform's outputs are for.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec78"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Terraform installation</li><li class="listitem" style="list-style-type: disc">An AWS provider and an EC2 instance (using a SSH keypair and a Security Group), all configured in Terraform (refer to the previous recipes)</li><li class="listitem" style="list-style-type: disc">An Internet connection</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec79"/>How to do it…</h2></div></div></div><p>Thankfully, we can use the same syntax we're already using to access variables and attributes of references, but this time in an <code class="literal">output</code> resource.</p><p>Let's start by simply adding a line in <code class="literal">outputs.tf</code> that would show us how to connect to our <a id="id157" class="indexterm"/>virtual machine, using the <code class="literal">public_ip</code> attribute of our <code class="literal">dev</code> EC2 instance:</p><div class="informalexample"><pre class="programlisting">output "login" {
  value = "ssh ubuntu@${aws_instance.dev.public_ip} -i ${var.aws_ssh_admin_key_file}"
}</pre></div><p>When <a id="id158" class="indexterm"/>applying terraform next time, it will display the following:</p><div class="informalexample"><pre class="programlisting">login = ssh ubuntu@52.51.242.17 -i keys/aws_terraform</pre></div><p>No doubt it's much quicker than having to log into the AWS dashboard, find the instance, and copy and paste the IP in the terminal.</p><p>What if it's important for us to know at a glimpse under what security groups our EC2 instance is running? We know security groups can be multiple, so it's an array. We can access the content of this array using the <code class="literal">formatlist</code> interpolation syntax as follows:</p><div class="informalexample"><pre class="programlisting">output "security_groups" {
  value = "${formatlist("%v", aws_instance.dev.security_groups)}"
}</pre></div><p>So now, at the next <code class="literal">terraform apply</code>, we'll instantly know our security groups:</p><div class="informalexample"><pre class="programlisting">security_groups = [
    base_security_group
]</pre></div><p>Also, if we have a lot of information to display from multiple sources, we can use the same syntax:</p><div class="informalexample"><pre class="programlisting">output "instance_information" {
  value = "${formatlist("instance: %v public: %v private: %v", aws_instance.dev.*.id, aws_instance.dev.*.public_ip, aws_instance.dev.*.private_ip)}"
}</pre></div><p>This will display the instance ID and its local and public IP addresses.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec80"/>There's more…</h2></div></div></div><p>Note that we used<code class="literal"> ${aws_instance.dev.public_ip}</code> in the first output and <code class="literal">aws_instance.dev.*.public_ip</code> in our last output. If you use the latter, the output will <a id="id159" class="indexterm"/>iterate through all available machines. It's very useful if you launch more than one instance using the <code class="literal">count=n</code> parameter <a id="id160" class="indexterm"/>in the <code class="literal">aws_instance</code> Terraform resource.</p></div></div>
<div class="section" title="Using contextual defaults with Terraform"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec33"/>Using contextual defaults with Terraform</h1></div></div></div><p>We've seen <a id="id161" class="indexterm"/>how to declare and use default values in our Terraform code, such as the Ubuntu AMI for our region or our VM size. An interesting <a id="id162" class="indexterm"/>feature in Terraform is the ability to declare and use <span class="emphasis"><em>maps</em></span> of values, so, depending on a key, the variable can have a different value. We'll see how it applies to the correct AMI of the corresponding AWS.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec81"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Terraform installation</li><li class="listitem" style="list-style-type: disc">An AWS provider and an EC2 instance (using a SSH key pair and a security group), all configured in Terraform (refer to the previous recipes)</li><li class="listitem" style="list-style-type: disc">An Internet connection</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec82"/>How to do it…</h2></div></div></div><p>Here's how we simply declared the AMI we wanted for the <code class="literal">eu-west-1</code> region in the <code class="literal">variables.tf</code> file:</p><div class="informalexample"><pre class="programlisting">variable "ami" {
  default = "ami-ee6b189d"
}</pre></div><p>We accessed it easily like this in the <code class="literal">instances.tf</code> file:</p><div class="informalexample"><pre class="programlisting">ami = "${var.ami}"</pre></div><p>A similar, but more explicit way would be to use a map, so we know which region the value refers to:</p><div class="informalexample"><pre class="programlisting">variable "ami" {
  default = {
    eu-west-1 = "ami-ee6b189d"
  }
}</pre></div><p>Here's how we access the same value in a map:</p><div class="informalexample"><pre class="programlisting">ami = "${var.ami["eu-west-1"]}"</pre></div><p>Now let's add more valid AMI IDs for other regions:</p><div class="informalexample"><pre class="programlisting">variable "ami" {
  default = {
    eu-west-1 = "ami-ee6b189d"
    us-east-1 = "ami-4f680658"
    us-west-1 = "ami-68a9e408"
  }
}</pre></div><p>The <code class="literal">ami</code> variable can now be valid for either of the three regions if accessed correctly in the <code class="literal">instances.tf</code> file:</p><div class="informalexample"><pre class="programlisting">ami = "${var.ami["us-east-1"]}"</pre></div><p>Now is a good time to start managing the AWS region directly in the code, for better portability. Add the following to <code class="literal">variables.tf</code> to use <code class="literal">eu-west-1</code> as a default region:</p><div class="informalexample"><pre class="programlisting">variable "aws_region" {
  default = "eu-west-1"
}</pre></div><p>You <a id="id163" class="indexterm"/>can now use this variable in the <code class="literal">provider.tf</code> file to set the region:</p><div class="informalexample"><pre class="programlisting">provider "aws" {
  region = "${var.aws_region}"
}</pre></div><p>Now the <a id="id164" class="indexterm"/>region variable is globally available, let's use it to access our map in <code class="literal">instances.tf</code>:</p><div class="informalexample"><pre class="programlisting">ami = "${var.ami["${var.aws_region}"]}"</pre></div><p>We now have an easily geographically deployable infrastructure that anyone in your team can launch close to him or her without the need to change code.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec83"/>There's more…</h2></div></div></div><p>We can perform the same dynamic access to a map using the <code class="literal">lookup()</code> function in Terraform:</p><div class="informalexample"><pre class="programlisting">ami = "${lookup(var.ami, var.aws_region)}"</pre></div></div></div>
<div class="section" title="Managing S3 storage with Terraform"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec34"/>Managing S3 storage with Terraform</h1></div></div></div><p>Storing and accessing <a id="id165" class="indexterm"/>files easily and in a scalable way is an essential part of a modern infrastructure. Amazon S3 is <a id="id166" class="indexterm"/>Amazon's answer to this need. S3 stores "objects" in "buckets" and has no storage limit (one exception <a id="id167" class="indexterm"/>is the bucket name: it has to be unique on Amazon's S3, the namespace being shared). We'll see how to make the best use of S3 with Terraform.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec84"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Terraform installation</li><li class="listitem" style="list-style-type: disc">An AWS provider configured in Terraform (refer to the previous recipes)</li><li class="listitem" style="list-style-type: disc">An Internet connection</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec85"/>How to do it…</h2></div></div></div><p>We'll start by creating a simple and explicitly public bucket on S3 named <code class="literal">iac-book</code>, using the <code class="literal">aws_s3_bucket</code> resource (and a tag for the sake of it):</p><div class="informalexample"><pre class="programlisting">resource "aws_s3_bucket" "iac_book" {
  bucket = "iac-book"
  acl    = "public-read"

  tags {
    Name = "IAC Book Bucket in ${var.aws_region}"
  }
}</pre></div><p>After a <code class="literal">terraform apply</code>, your bucket is immediately available for storing objects. You can see it on the AWS <a id="id168" class="indexterm"/>S3 Console (<a class="ulink" href="https://console.aws.amazon.com/s3/">https://console.aws.amazon.com/s3/</a>):</p><div class="mediaobject"><img src="graphics/B05671_02_06.jpg" alt="How to do it…"/></div><p>Let's store a first object right now, a very simple file containing a simple string (<code class="literal">"Hello Infrastructure-as-Code Cookbook!"</code>). The resource is named <code class="literal">aws_s3_bucket_object</code>, and you need to reference the bucket previously created, the destination name (<code class="literal">index.html</code>), and its content. The ACL is here again explicitly public:</p><div class="informalexample"><pre class="programlisting">resource "aws_s3_bucket_object" "index" {
  bucket = "${aws_s3_bucket.iac_book.bucket}"
  key = "index.html"
  content = "&lt;h1&gt;Hello Infrastructure-as-Code Cookbook!&lt;/h1&gt;"
  content_type = "text/html"
  acl    = "public-read"
}</pre></div><p>You <a id="id169" class="indexterm"/>can alternatively provide a file directly instead of its content:</p><div class="informalexample"><pre class="programlisting">source = "index.html"</pre></div><p>If you <a id="id170" class="indexterm"/>navigate to the AWS S3 Console, you can see it available with some extended information:</p><div class="mediaobject"><img src="graphics/B05671_02_07.jpg" alt="How to do it…"/></div><p>It would be awesome if we could know easily the URL of our file right from Terraform, so we could give it to others. Unfortunately, there's no easy function for that. However, we know how URLs are constructed: <code class="literal">http://s3-&lt;region&gt;.amazonaws.com/bucket_name/object_name</code>. Let's create an output containing this information:</p><div class="informalexample"><pre class="programlisting">output "S3" {
  value = "http://s3-${aws_s3_bucket.iac_book.region}.amazonaws.com/${aws_s3_bucket.iac _book.id}/${aws_s3_bucket_object.index.key}"
}</pre></div><p>Paste the link in a web browser and you'll be able to access your file.</p><p>A workaround is to use the <span class="emphasis"><em>static website hosting</em></span> feature of S3 by simply adding the following to your <code class="literal">aws_s3_bucket</code> resource:</p><div class="informalexample"><pre class="programlisting">website {
  index_document = "index.html"
}</pre></div><p>An optional output will give you its static hosting URL (in our case, <a class="ulink" href="http://iac-book.s3-website-eu-west-1.amazonaws.com">iac-book.s3-website-eu-west-1.amazonaws.com</a> instead of <a class="ulink" href="http://s3-eu-west-1.amazonaws.com/iac-book/index.html">http://s3-eu-west-1.amazonaws.com/iac-book/index.html</a>):</p><div class="informalexample"><pre class="programlisting">output "S3 Endpoint" {
  value = "${aws_s3_bucket.iac_book.website_endpoint}"
}</pre></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec86"/>There's more…</h2></div></div></div><p>Using <a id="id171" class="indexterm"/>Ansible, there are many ways to create a bucket. Here's a simple bucket with public read permissions, using the <a id="id172" class="indexterm"/>classic <code class="literal">s3</code> module:</p><div class="informalexample"><pre class="programlisting">---
- name: create iac-book bucket
  s3:
    bucket: iac-book
    mode: create
    permission: public-read</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>Note that Ansible 2.2 also comes with an <code class="literal">s3_website</code> module for specifically handling S3 websites.</p></div></div><p>Here's how we would simply upload our previous <code class="literal">index.html</code> file using the same <code class="literal">s3</code> module:</p><div class="informalexample"><pre class="programlisting">- name: create index.html file
  s3:
    bucket: iac-book
    object: index.html
    src: index.html
    mode: put
    permission: public-read</pre></div></div></div>
<div class="section" title="Creating private Docker repositories with Terraform"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec35"/>Creating private Docker repositories with Terraform</h1></div></div></div><p>To host <a id="id173" class="indexterm"/>your Docker images, you need what's called a <span class="strong"><strong>registry</strong></span>. This registry <a id="id174" class="indexterm"/>is either run by you or as a service. It stores your images for you and sometimes builds them too. The Docker <a id="id175" class="indexterm"/>Hub and Quay.io <a id="id176" class="indexterm"/>from CoreOS are the main Docker-managed registries you can subscribe to. Both are interesting in terms of features or pricing. However, an interesting alternative is AWS <span class="strong"><strong>Elastic Container Registry</strong></span> (<span class="strong"><strong>ECR</strong></span>): pricing is different and fully integrated in the AWS ecosystem. Let's create countless repositories simply with Terraform!</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec87"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Terraform installation</li><li class="listitem" style="list-style-type: disc">An AWS provider configured in Terraform (refer to the previous recipes)</li><li class="listitem" style="list-style-type: disc">A configured <a id="id177" class="indexterm"/>AWS CLI (<a class="ulink" href="http://docs.aws.amazon.com/cli/latest/userguide/installing.html">http://docs.aws.amazon.com/cli/latest/userguide/installing.html</a>)</li><li class="listitem" style="list-style-type: disc">An Internet connection</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec88"/>How to do it…</h2></div></div></div><p>Let's say you want to store your application container in a repository named <code class="literal">myapp</code>, so you <a id="id178" class="indexterm"/>can deploy it easily. It's very simple with Terraform. Add the following code to a file named <code class="literal">ecr.tf</code>:</p><div class="informalexample"><pre class="programlisting">resource "aws_ecr_repository" "myapp" {
  name = "myapp"
}</pre></div><p>If you <a id="id179" class="indexterm"/>want to know the URL to access your new repository, you can create an output using the corresponding exported attribute:</p><div class="informalexample"><pre class="programlisting">output "ECR" {
  value = "${aws_ecr_repository.myapp.repository_url}"
}</pre></div><p>If you're used to the other Docker registries, the first step is to authenticate so you create private repositories. Here, no login or password are provided by AWS. We need to use the official AWS command line to authenticate, and that will give us temporary Docker credentials. The output of this command is the Docker command to type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ aws ecr get-login --region eu-west-1</strong></span>
<span class="strong"><strong>docker login -u AWS -p AQECAHh... -e none https://&lt;account_number&gt;.dkr.ecr.eu-west-1.amazonaws.com</strong></span>
</pre></div><p>Now we can <code class="literal">docker build</code>, <code class="literal">tag</code>, and <code class="literal">push</code> images at will! (See more about using Docker images in the dedicated chapter of this book.)</p><p>A nice advanced feature is the ability to use fine-grained policies for each repository created.</p></div></div>
<div class="section" title="Creating a PostgreSQL RDS database with Terraform"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec36"/>Creating a PostgreSQL RDS database with Terraform</h1></div></div></div><p>
<span class="strong"><strong>Amazon Relational Database Service</strong></span> (<span class="strong"><strong>RDS</strong></span>) is an on-demand, ready-to-use, and resizable <a id="id180" class="indexterm"/>EC2 instance specifically tailored and configured to run the requested database server. You can launch many <a id="id181" class="indexterm"/>different relational database servers on RDS, and we'll focus on PostgreSQL for this recipe.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec89"/>Getting ready</h2></div></div></div><p>To step <a id="id182" class="indexterm"/>through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Terraform installation</li><li class="listitem" style="list-style-type: disc">An AWS provider configured in Terraform (refer to the previous recipes)</li><li class="listitem" style="list-style-type: disc">An Internet connection</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec90"/>How to do it…</h2></div></div></div><p>There are many parameters at play in a database deployment, even a simple one. To be certain of what we'll deploy, we'll start by filling a simple table with the database requirements, and build on it:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Parameter</p>
</th><th style="text-align: left" valign="bottom">
<p>Variable name</p>
</th><th style="text-align: left" valign="bottom">
<p>Value</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>RDS Database Engine</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">rds_engine</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">postgresql</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>RDS Database Engine Version</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">rds_engine_version</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">9.5.2</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>RDS Instance Name</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">rds_identifier</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">db</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>RDS Instance Type</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">rds_instance_type</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">db.t2.micro</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>RDS Storage Size (GB)</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">rds_storage_size</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">5</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>RDS First Database Name</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">rds_db_name</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">iac_book_db</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>RDS Administrator Username</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">rds_admin_user</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">dbadmin</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>RDS Administrator Password</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">rds_admin_password</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">super_secret_password</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>RDS Publicly Accessible</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">rds_publicly_accessible</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">true</code>
</p>
</td></tr></tbody></table></div><p>Let's set all those variables in our <code class="literal">variables.tf</code> file:</p><div class="informalexample"><pre class="programlisting">variable "rds_identifier" {
  default = "db"
}

variable "rds_instance_type" {
  default = "db.t2.micro"
}
variable "rds_storage_size" {
  default = "5"
}

variable "rds_engine" {
  default = "postgres"
}

variable "rds_engine_version" {
  default = "9.5.2"
}

variable "rds_db_name" {
  default = "iac_book_db"
}

variable "rds_admin_user" {
  default = "dbadmin"
}

variable "rds_admin_password" {
  default = "super_secret_password"
}

variable "rds_publicly_accessible" {
  default = "true"
}</pre></div><p>As we're <a id="id183" class="indexterm"/>running PostgreSQL <a id="id184" class="indexterm"/>and we want it to be available on the Internet (though generally not a good idea for production), we'll need a security group allowing just the default PgSQL port (TCP/5432) for our IP address (refer to the <span class="emphasis"><em>Using AWS security groups with Terraform</em></span> recipe), in <code class="literal">securitygroups.tf</code>:</p><div class="informalexample"><pre class="programlisting">resource "aws_security_group" "rds_security_group" {
  name        = "rds_security_group"
  description = "RDS Security Group"

  ingress {
    from_port   = 5432
    to_port     = 5432
    protocol    = "tcp"
    cidr_blocks = ["1.2.3.4/32"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags {
    Name = "rds_security_group"
  }
}</pre></div><p>Now <a id="id185" class="indexterm"/>we have everything in place to construct the <code class="literal">aws_db_instance</code> resource:</p><div class="informalexample"><pre class="programlisting">resource "aws_db_instance" "db" {
  engine            = "${var.rds_engine}"
  engine_version    = "${var.rds_engine_version}"
  identifier        = "${var.rds_identifier}"
  instance_class    = "${var.rds_instance_type}"
  allocated_storage = "${var.rds_storage_size}"
  name              = "${var.rds_db_name}"
  username          = "${var.rds_admin_user}"
  password          = "${var.rds_admin_password}"
  publicly_accessible    = "${var.rds_publicly_accessible}"
  vpc_security_group_ids = ["${aws_security_group.rds_security_group.id}"]
  tags {
    Name = "IAC Database in ${var.aws_region}"
  }
}</pre></div><p>As we <a id="id186" class="indexterm"/>did previously, a quick output giving us the FQDN of our new database will help us to use it quickly, in <code class="literal">outputs.tf</code>:</p><div class="informalexample"><pre class="programlisting">output "RDS" {
  value = "address: ${aws_db_instance.db.address}"
}</pre></div><p>Let's <code class="literal">terraform apply</code> now and try the result:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># psql -h &lt;your_db_address&gt; -d iac_book_db -U dbadmin</strong></span>
<span class="strong"><strong>Password for user dbadmin:</strong></span>
<span class="strong"><strong>psql (9.5.4, server 9.5.2)</strong></span>
<span class="strong"><strong>[...]</strong></span>

<span class="strong"><strong>iac_book_db=&gt; \l</strong></span>
<span class="strong"><strong>                                   List of databases</strong></span>
<span class="strong"><strong>    Name     |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges</strong></span>
<span class="strong"><strong>-------------+----------+----------+-------------+-------------+-----------------------</strong></span>
<span class="strong"><strong> iac_book_db | dbadmin  | UTF8     | en_US.UTF-8 | en_US.UTF-8 |</strong></span>
<span class="strong"><strong> postgres    | dbadmin  | UTF8     | en_US.UTF-8 | en_US.UTF-8 |</strong></span>
<span class="strong"><strong> rdsadmin    | rdsadmin | UTF8     | en_US.UTF-8 | en_US.UTF-8 | rdsadmin=CTc/rdsadmin</strong></span>
<span class="strong"><strong> template0   | rdsadmin | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/rdsadmin          +</strong></span>
<span class="strong"><strong>             |          |          |             |             | rdsadmin=CTc/rdsadmin</strong></span>
<span class="strong"><strong> template1   | dbadmin  | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/dbadmin           +</strong></span>
<span class="strong"><strong>             |          |          |             |             | dbadmin=CTc/dbadmin</strong></span>
<span class="strong"><strong>(5 rows)</strong></span>
</pre></div><p>There are <a id="id187" class="indexterm"/>many more useful <a id="id188" class="indexterm"/>options you can use or set, such as maintenance windows, backup retention periods, dedicated database subnets, storage encryption, and master/slave configuration.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec91"/>There's more…</h2></div></div></div><p>How would that work when using Ansible to do a similar job with the same values? Just as easy as usual:</p><div class="informalexample"><pre class="programlisting">---
- name: create RDS PgSQL
  rds:
    command: create
    instance_name: db
    db_engine: postgres
    engine_version: 9.5.2
    db_name: iac_book_db
    size: 5
    instance_type: db.t2.micro
    username: dbadmin
    password: super_secure_password
    publicly_accessible: yes
    tags:
      Name: IAC Database</pre></div><p>After <a id="id189" class="indexterm"/>executing this playbook, a <a id="id190" class="indexterm"/>similar PostgreSQL server will run on RDS as we just did with Terraform.</p></div></div>
<div class="section" title="Enabling CloudWatch Logs for Docker with Terraform"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec37"/>Enabling CloudWatch Logs for Docker with Terraform</h1></div></div></div><p>
<span class="strong"><strong>CloudWatch Logs</strong></span> is <a id="id191" class="indexterm"/>a log <a id="id192" class="indexterm"/>aggregation service by Amazon you can use to send your logs to. It's very useful to keep some logs centralized, share access to them, receive alarms <a id="id193" class="indexterm"/>when errors happen, or simply store them safely. We'll see how to create a CloudWatch Log group and use it to <a id="id194" class="indexterm"/>stream logs from a Docker container logs inside it.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec92"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Terraform installation</li><li class="listitem" style="list-style-type: disc">An AWS provider configured in Terraform (refer to the previous recipes)</li><li class="listitem" style="list-style-type: disc">An Internet connection</li><li class="listitem" style="list-style-type: disc">A Docker Engine running on Linux for the optional usage demonstration</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec93"/>How to do it…</h2></div></div></div><p>Let's say we want the log group to be named <code class="literal">docker_logs</code>, and that we want to keep those logs for seven days. In the <code class="literal">variables.tf</code> file, that would look like this:</p><div class="informalexample"><pre class="programlisting">variable "log_group_name" {
  default = "docker_logs"
}

variable "log_retention_days" {
  default = "7"
}</pre></div><p>Also, in a new <code class="literal">cloudwatch.tf</code> file, we can use the simple <code class="literal">aws_cloudwatch_log_group</code> resource:</p><div class="informalexample"><pre class="programlisting">resource "aws_cloudwatch_log_group" "docker_logs" {
  name              = "${var.log_group_name}"
  retention_in_days = "${var.log_retention_days}"
}</pre></div><p>After <a id="id195" class="indexterm"/>a <code class="literal">terraform apply</code>, if <a id="id196" class="indexterm"/>you navigate to the AWS <a id="id197" class="indexterm"/>CloudWatch page, you'll <a id="id198" class="indexterm"/>see the newly created group under the <span class="strong"><strong>Log Groups</strong></span> entry on the left (<a class="ulink" href="https://eu-west-1.console.aws.amazon.com/cloudwatch/">https://eu-west-1.console.aws.amazon.com/cloudwatch/</a>).</p><div class="mediaobject"><img src="graphics/B05671_02_08.jpg" alt="How to do it…"/></div><div class="section" title="Amazon CloudWatch Logs Docker logging driver"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec34"/>Amazon CloudWatch Logs Docker logging driver</h3></div></div></div><p>You can <a id="id199" class="indexterm"/>now use this group to create a log stream from an application or a container. Using it as recommended by AWS is well documented, so let's use it with Docker instead. It only requires to give the Docker daemon access to the <code class="literal">AWS_ACCESS_KEY_ID</code> and <code class="literal">AWS_SECRET_ACCESS_KEY</code> environment variables (configuring the Docker daemon is out of the scope of this chapter, but that's under <code class="literal">/etc/sysconfig/docker</code> for Red Hat-based systems such as Fedora or CentOS, and <code class="literal">/etc/default/docker</code> for Debian/Ubuntu systems). Restart the daemon and start logging your containers output using a new Docker logging driver, using the log group name specified in Terraform earlier (<code class="literal">docker_logs</code>):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker run -it --rm -p 80:80 --log-driver=awslogs --log-opt awslogs-region=eu-west-1 --log-opt awslogs-group=docker_logs --log-opt awslogs-stream=nginx nginx:stable</strong></span>
</pre></div><p>Generate some activity on the container:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl -IL http://localhost</strong></span>
<span class="strong"><strong>HTTP/1.1 200 OK</strong></span>
</pre></div><p>Refresh the AWS CloudWatch page and you'll see a new entry named <code class="literal">nginx</code> with the container logs. You can run all your containers in your infrastructure like this and get centralized <a id="id200" class="indexterm"/>logging very easily!</p><div class="mediaobject"><img src="graphics/B05671_02_09.jpg" alt="Amazon CloudWatch Logs Docker logging driver"/></div></div></div></div>
<div class="section" title="Managing IAM users with Terraform"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec38"/>Managing IAM users with Terraform</h1></div></div></div><p>An essential <a id="id201" class="indexterm"/>part of using AWS is controlling access to the resources. We've seen with all the previous recipes how often we need to <a id="id202" class="indexterm"/>use the AWS Access Keys, and it's surely not a good idea to use a single key for all your activities. Imagine what would happen if a single one of your services was hacked—the intruder would get the main AWS key and would be able to do everything on your behalf.</p><p>A good <a id="id203" class="indexterm"/>secure setup would be dedicated keys with a dedicated scope of access rights for every person in your team and every service in your infrastructure.</p><p>Thankfully, <span class="strong"><strong>Identity and Access Management</strong></span> (<span class="strong"><strong>IAM</strong></span>) is there just for that. We'll see how to use it with Terraform.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec94"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Terraform installation</li><li class="listitem" style="list-style-type: disc">An AWS provider configured in Terraform (refer to the previous recipes)</li><li class="listitem" style="list-style-type: disc">An Internet connection</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec95"/>How to do it…</h2></div></div></div><p>Let's start with a simple case: two members of a team (Mary and Joe) need to access resources on AWS. They currently all share the same main key, which is a disaster if a <a id="id204" class="indexterm"/>leakage happens. So let's ask them what exactly they need to access in the AWS space:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Mary</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>S3 in read and write</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Joe</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>EC2 in read only</p>
</td></tr></tbody></table></div><p>As expected, neither user really needs full access!</p><p>Amazon <a id="id205" class="indexterm"/>helps by offering prebuilt security policies for IAM. If those aren't enough, you can tailor the ones you need:</p><div class="mediaobject"><img src="graphics/B05671_02_10.jpg" alt="How to do it…"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>You can <a id="id206" class="indexterm"/>find all AWS Managed IAM Policies at <a class="ulink" href="https://console.aws.amazon.com/iam/home#policies">https://console.aws.amazon.com/iam/home#policies</a>.</p></div></div><div class="section" title="An IAM user for S3 access"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec35"/>An IAM user for S3 access</h3></div></div></div><p>Let's create <a id="id207" class="indexterm"/>a first IAM user for Mary in a new <code class="literal">iam.tf</code> file using the <code class="literal">aws_iam_user</code> resource:</p><div class="informalexample"><pre class="programlisting">resource "aws_iam_user" "mary" {
  name = "mary"
  path = "/team/"
}</pre></div><p>The <code class="literal">path</code> is purely optional and informative, I'm simply suggesting structured paths. So we'll have <code class="literal">/apps/</code> as well later.</p><p>We can now create an AWS Access Key for our user Mary, using the <code class="literal">aws_iam_access_key</code> resource with reference to our user:</p><div class="informalexample"><pre class="programlisting">resource "aws_iam_access_key" "mary" {
  user = "${aws_iam_user.mary.name}"
}</pre></div><p>And finally, as we know, we want to attach to this user the <code class="literal">AmazonS3FullAccess</code> managed policy, let's use the dedicated resource:</p><div class="informalexample"><pre class="programlisting">resource "aws_iam_user_policy_attachment" "mary_s3full" {
  user = "${aws_iam_user.mary.name}"
  policy_arn = "arn:aws:iam::aws:policy/AmazonS3FullAccess"
}</pre></div><p>Let's <a id="id208" class="indexterm"/>write an <code class="literal">output</code> so we know both parts of the key in <code class="literal">outputs.tf</code>:</p><div class="informalexample"><pre class="programlisting">output "mary" {
  value = "ACCESS_KEY: ${aws_iam_access_key.mary.id}, SECRET: ${aws_iam_access_key.mary.secret}"
}</pre></div><p>Also, <code class="literal">terraform apply</code> this to create the <code class="literal">mary</code> user:</p><div class="informalexample"><pre class="programlisting">[...]
Outputs:
mary = ACCESS_KEY: AKIAJPQB7HBK2KLAARRQ, SECRET: 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</pre></div></div><div class="section" title="Testing the restrictions"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec36"/>Testing the restrictions</h3></div></div></div><p>Now,<code class="literal"> terraform apply</code> this, and confirm using an S3 browser that you can access S3! Here's an example of <a id="id209" class="indexterm"/>creating a simple S3 bucket with <code class="literal">s3cmd</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ s3cmd --access_key=&lt;mary_access_key&gt; --secret_key=&lt;mary_secret_key&gt; mb s3://iacbook-iam-bucket</strong></span>
<span class="strong"><strong>Bucket 's3://iacbook-iam-bucket/' created</strong></span>
</pre></div><p>Is this account really limited to S3, as it pretends to be? Let's try to list EC2 hosts with Mary's account using the <code class="literal">aws</code> command line (provided you configured the <code class="literal">aws</code> tool accordingly):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ aws --profile iacbook-mary ec2 describe-hosts</strong></span>
<span class="strong"><strong>An error occurred (UnauthorizedOperation) when calling the DescribeHosts operation: You are not authorized to perform this operation.</strong></span>
</pre></div><p>So it <a id="id210" class="indexterm"/>all looks good and secure! Mary can do her job on S3 safely.</p></div><div class="section" title="An IAM user for EC2 in read-only"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec37"/>An IAM user for EC2 in read-only</h3></div></div></div><p>Is there <a id="id211" class="indexterm"/>a similar managed policy for Joe, with a read-only scope on EC2? Fortunately, there is! It's creatively named <code class="literal">AmazonEC2ReadOnlyAccess</code>.</p><p>Let's create our second user, with this IAM policy in the <code class="literal">iam.tf</code> file:</p><div class="informalexample"><pre class="programlisting">resource "aws_iam_user" "joe" {
  name = "joe"
  path = "/team/"
}

resource "aws_iam_access_key" "joe" {
  user = "${aws_iam_user.joe.name}"
}

resource "aws_iam_user_policy_attachment" "joe_ec2ro" {
  user = "${aws_iam_user.joe.name}"
  policy_arn = "arn:aws:iam::aws:policy/AmazonEC2ReadOnlyAccess"
}</pre></div><p>Don't forget the useful output that comes with it:</p><div class="informalexample"><pre class="programlisting">output "joe" {
  value = "ACCESS_KEY: ${aws_iam_access_key.joe.id}, SECRET: ${aws_iam_access_key.joe.secret}"
}</pre></div><p>Next, <code class="literal">terraform apply</code> this once again, and can the Joe user see what's on S3? No, he can't:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ s3cmd --access_key=&lt;joe_access_key&gt; --secret_key=&lt;joe_secret_key&gt; ls</strong></span>
<span class="strong"><strong>ERROR: S3 error: 403 (AccessDenied): Access Denied</strong></span>
</pre></div><p>But can the Joe user simply list the EC2 VMs as he needs to, with the same command that was forbidden to Mary? Yes, he can:</p><div class="informalexample"><pre class="programlisting">$ aws --profile iacbook-joe ec2 describe-hosts
{
  "Hosts": []
}</pre></div><p>We're on <a id="id212" class="indexterm"/>track to securely manage our infrastructure access using code!</p></div><div class="section" title="An application user IAM – CloudWatch Logs"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec38"/>An application user IAM – CloudWatch Logs</h3></div></div></div><p>We've <a id="id213" class="indexterm"/>used the CloudWatch Logs service in a previous recipe. If you remember, you had to enter once again your keys in the Docker Engine configuration. If you had 100 servers, your master keys would be on each of them. This is rather unnecessary, if you consider that the scope of this configuration in Docker is just to send logs. Fortunately, there's a managed IAM policy for that named <code class="literal">CloudWatchLogsFullAccess</code>.</p><p>So let's create another user, exactly as before for Mary and Joe, except this one will be for our Docker Engines and not for a real user in <code class="literal">iam.tf</code>. I suggest using a different path, just to separate real users and application users. However, that's totally optional and opinionated:</p><div class="informalexample"><pre class="programlisting">resource "aws_iam_user" "logs" {
  name = "logs"
  path = "/apps/"
}

resource "aws_iam_access_key" "logs" {
  user = "${aws_iam_user.logs.name}"
}

resource "aws_iam_user_policy_attachment" "logs_cloudwatch_full" {
  user = "${aws_iam_user.logs.name}"
  policy_arn = "arn:aws:iam::aws:policy/CloudWatchLogsFullAccess"
}</pre></div><p>The relevant <code class="literal">output</code> in <code class="literal">outputs.tf</code> is as follows:</p><div class="informalexample"><pre class="programlisting">output "logs" {
  value = "ACCESS_KEY: ${aws_iam_access_key.logs.id}, SECRET: ${aws_iam_access_key.logs.secret}"
}</pre></div><p>Now, <code class="literal">terraform apply</code> this and try the <span class="emphasis"><em>Enabling CloudWatch Logs for Docker with Terraform</em></span> recipe again with those credentials instead of the master keys: it will still work on the CloudWatch scope, but if something goes wrong, it will never put the rest of your infrastructure in danger. The worst that can happen in this area is the total waste of the logs.</p><div class="informalexample"><pre class="programlisting">[...]
Outputs:

joe = ACCESS_KEY: AKIAJQPSXBKSD3DY47BQ, SECRET: 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
logs = ACCESS_KEY: AKIAISIUXTG5RIJZAEYA, SECRET: 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
mary = ACCESS_KEY: AKIAJPQB7HBK2KLAARRQ, SECRET: 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</pre></div><div class="mediaobject"><img src="graphics/B05671_02_11.jpg" alt="An application user IAM – CloudWatch Logs"/></div></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec96"/>There's more…</h2></div></div></div><p>If you'd <a id="id214" class="indexterm"/>prefer to see how this would work using Ansible, it's a bit different. IAM support is not equivalent, as there's no IAM Managed Policies support. However, you can simply create users like this:</p><div class="informalexample"><pre class="programlisting">---
- name: create mary user
  iam:
    iam_type: user
    name: mary
    state: present
    access_key_state: create
    path: /team/</pre></div><p>As there's currently no IAM Managed Policy support, a workaround is to use the JSON from <a id="id215" class="indexterm"/>the IAM Policy we want, such as <code class="literal">AmazonS3FullAccess</code> for our user Mary. It's easy to find in the AWS Console in the <span class="strong"><strong>Policies</strong></span> section (<a class="ulink" href="https://console.aws.amazon.com/iam/home#policies">https://console.aws.amazon.com/iam/home#policies</a>). Paste the following JSON content in <code class="literal">AmazonS3FullAccess.json</code> at the root of the <code class="literal">Ansible</code> folder:</p><div class="informalexample"><pre class="programlisting">{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": "s3:*",
      "Resource": "*"
    }
  ]
}</pre></div><p>Use <a id="id216" class="indexterm"/>this <a id="id217" class="indexterm"/>local policy in the <code class="literal">iam_policy</code> module:</p><div class="informalexample"><pre class="programlisting">- name: Assign a AmazonS3FullAccess policy to mary
  iam_policy:
    iam_type: user
    iam_name: mary
    policy_name: AmazonS3FullAccess
    state: present
    policy_document: AmazonS3FullAccess.json</pre></div></div></div></body></html>