<html><head></head><body>
        <section>

            <header>
                <h1 class="header-title">Networking</h1>
            </header>

            <article>
                
<p>In this chapter, we will cover:</p>
<ul>
<li>Building a secure network</li>
<li>Creating a NAT gateway</li>
<li>Canary deployment via DNS</li>
<li>Hosting a domain</li>
<li>Routing based on location with failover</li>
<li>Network logging and troubleshooting</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Introduction</h1>
            </header>

            <article>
                
<p>Networking is a foundational component of using other AWS services such as EC2, RDS, and others. Using constructs such as VPCs and NAT gateways gives you the capability and confidence to secure your resources at a networking level. At a DNS level, Route 53 provides connectivity to your users in a responsive and fault-tolerant way that ensures the best performance in a variety of scenarios.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Building a secure network</h1>
            </header>

            <article>
                
<p>In this recipe, we're going to build a secure network (VPC) in AWS. This network will consist of two public and private subnets split across two Availability Zones. It will also allow inbound connections to the public subnets for the following:</p>
<ul>
<li>SSH (port <kbd>22</kbd>)</li>
<li>HTTP (port <kbd>80</kbd>)</li>
<li>HTTPS (port <kbd>443</kbd>)</li>
</ul>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_07_001.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Building a secure network</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Getting ready</h1>
            </header>

            <article>
                
<p>Before we proceed, you're going to need to know the names of at least two Availability Zones in the region we're deploying to. The recipes in this book will typically deploy to <kbd>us-east-</kbd>, so to get things moving you can just use the following:</p>
<ul>
<li><kbd>us-east-1a</kbd></li>
<li><kbd>us-east-1b</kbd></li>
</ul>
<div class="packt_infobox">When you create an AWS account, your zones are randomly allocated. This means that <kbd>us-east-1a</kbd> in your account isn't necessarily the same data center as <kbd>us-east-1a</kbd> in my account.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<p>Go ahead and create a new CloudFormation template for our VPC. Just a heads-up: this will be one of the larger templates that we'll create in this book:</p>
<ol>
<li>The first two <kbd>Parameters</kbd> correspond to the Availability Zones we discussed previously. We don't provide any default values for these parameters, to maintain region portability:</li>
</ol>
<pre>
      Parameters:<br/>        AvailabilityZone1: <br/>          Description: Availability zone 1 name (e.g. us-east-1a) <br/>          Type: AWS::EC2::AvailabilityZone::Name <br/>        AvailabilityZone2: <br/>          Description: Availability zone 2 name (e.g. us-east-1b) <br/>          Type: AWS::EC2::AvailabilityZone::Name
</pre>
<ol start="2">
<li>The shell of our VPC has now been created. At this point, it's not connected to the Internet, so it's not entirely useful to us. We need to add an Internet gateway and attach it to our VPC. Go ahead and do that, as follows:</li>
</ol>
<pre>
      Resources: <br/>        # VPC &amp; subnets <br/>        ExampleVPC: <br/>          Type: AWS::EC2::VPC <br/>          Properties: <br/>            CidrBlock: !Ref VPCCIDR <br/>            EnableDnsSupport: true <br/>            EnableDnsHostnames: true <br/>          Tags: <br/>            - { Key: Name, Value: Example VPC } <br/>        PublicSubnetA: <br/>          Type: AWS::EC2::Subnet <br/>          Properties: <br/>            AvailabilityZone: !Ref AvailabilityZone1 <br/>            CidrBlock: !Ref PublicSubnetACIDR <br/>            MapPublicIpOnLaunch: true <br/>            VpcId: !Ref ExampleVPC <br/>          Tags: <br/>            - { Key: Name, Value: Public Subnet A } <br/>        PublicSubnetB: <br/>          Type: AWS::EC2::Subnet <br/>          Properties: <br/>            AvailabilityZone: !Ref AvailabilityZone2 <br/>            CidrBlock: !Ref PublicSubnetBCIDR <br/>            MapPublicIpOnLaunch: true <br/>            VpcId: !Ref ExampleVPC <br/>          Tags: <br/>            - { Key: Name, Value: Public Subnet B } <br/>        PrivateSubnetA: <br/>          Type: AWS::EC2::Subnet <br/>          Properties: <br/>            AvailabilityZone: !Ref AvailabilityZone1 <br/>            CidrBlock: !Ref PrivateSubnetACIDR <br/>            VpcId: !Ref ExampleVPC <br/>          Tags: <br/>            - { Key: Name, Value: Private Subnet A } <br/>        PrivateSubnetB: <br/>          Type: AWS::EC2::Subnet <br/>          Properties: <br/>            AvailabilityZone: !Ref AvailabilityZone2 <br/>            CidrBlock: !Ref PrivateSubnetBCIDR <br/>            VpcId: !Ref ExampleVPC <br/>          Tags: <br/>            - { Key: Name, Value: Private Subnet B }
</pre>
<ol start="3">
<li>The remaining <kbd>Parameters</kbd> define the IP address ranges for the following:
<ul>
<li>The entire VPC</li>
<li>The public subnets (A and B)</li>
<li>The private subnets (A and B)</li>
</ul>
</li>
</ol>
<ol start="4">
<li>The default values we provide for the subnets will allocate 512 IP addresses to each subnet:</li>
</ol>
<div class="packt_infobox">AWS reserves a small number of IP addresses in your IP space for AWS-specific services. The VPC DNS server is one such example of this. It's usually located at the second (<kbd>*.2</kbd>) IP address in the block allocated to your VPC.</div>
<pre>
      VPCCIDR: <br/>        Description: CIDR block for VPC <br/>        Type: String <br/>        Default: "172.31.0.0/21" # 2048 IP addresses <br/>      PublicSubnetACIDR: <br/>        Description: CIDR block for public subnet A <br/>        Type: String <br/>        Default: "172.31.0.0/23" # 512 IP address <br/>      PublicSubnetBCIDR: <br/>        Description: CIDR block for public subnet B <br/>        Type: String <br/>        Default: "172.31.2.0/23" # 512 IP address <br/>      PrivateSubnetACIDR: <br/>        Description: CIDR block for private subnet A <br/>        Type: String <br/>        Default: "172.31.4.0/23" # 512 IP address <br/>      PrivateSubnetBCIDR: <br/>        Description: CIDR block for private subnet B <br/>        Type: String <br/>        Default: "172.31.6.0/23" # 512 IP address
</pre>
<ol start="5">
<li>Now we can start to define <kbd>Resources</kbd>. We'll start by defining the VPC itself, as well as the two public and two private subnets inside it:</li>
</ol>
<pre>
        # Internet Gateway <br/>        ExampleIGW: <br/>          Type: AWS::EC2::InternetGateway <br/>          Properties: <br/>            Tags: <br/>              - { Key: Name, Value: Example Internet Gateway } <br/>        IGWAttachment: <br/>          Type: AWS::EC2::VPCGatewayAttachment <br/>          DependsOn: ExampleIGW <br/>          Properties: <br/>            VpcId: !Ref ExampleVPC <br/>            InternetGatewayId: !Ref ExampleIGW
</pre>
<ol start="6">
<li>We need to create a couple of route tables. The first one we'll focus on is the public route table. We'll assign this route table to the two public subnets we've created. This route table will have just one route in it, which will direct all Internet-bound traffic to the Internet gateway we created in the previous step:</li>
</ol>
<pre>
        # Public Route Table <br/>        # Add a route for Internet bound traffic pointing to our IGW <br/>        # A route for VPC bound traffic will automatically be added <br/>        PublicRouteTable: <br/>          Type: AWS::EC2::RouteTable <br/>          Properties: <br/>            VpcId: !Ref ExampleVPC <br/>            Tags: <br/>              - { Key: Name, Value: Public Route Table } <br/>        PublicInternetRoute: <br/>          Type: AWS::EC2::Route <br/>          DependsOn: IGWAttachment <br/>          Properties: <br/>            RouteTableId: !Ref PublicRouteTable <br/>            GatewayId: !Ref ExampleIGW <br/>            DestinationCidrBlock: "0.0.0.0/0" <br/>        RouteAssociationPublicA: <br/>          Type: AWS::EC2::SubnetRouteTableAssociation <br/>          Properties: <br/>            RouteTableId: !Ref PublicRouteTable <br/>            SubnetId: !Ref PublicSubnetA <br/>        RouteAssociationPublicB: <br/>          Type: AWS::EC2::SubnetRouteTableAssociation <br/>          Properties: <br/>            RouteTableId: !Ref PublicRouteTable <br/>            SubnetId: !Ref PublicSubnetB
</pre>
<ol start="7">
<li>We'll create the private route table in a similar fashion. Since the private subnet is isolated from the Internet, we won't add a route to the Internet gateway. Note that if you were to follow the NAT gateway recipe in this book, it will require a route table as an input parameterâ€”this is the route table you want to add NAT routes to:</li>
</ol>
<pre>
        # Private Route Table <br/>        # We don't add any entries to this route table because there is<br/>          no NAT gateway <br/>        # However a route for VPC bound traffic will automatically be added <br/>        PrivateRouteTable: <br/>          Type: AWS::EC2::RouteTable <br/>          Properties: <br/>            VpcId: !Ref ExampleVPC <br/>            Tags: <br/>              - { Key: Name, Value: Private Route Table } <br/>        PrivateSubnetAssociationA: <br/>          Type: AWS::EC2::SubnetRouteTableAssociation <br/>          Properties: <br/>            RouteTableId: !Ref PrivateRouteTable <br/>            SubnetId: !Ref PrivateSubnetA <br/>        PrivateSubnetAssociationB: <br/>          Type: AWS::EC2::SubnetRouteTableAssociation <br/>          Properties: <br/>            RouteTableId: !Ref PrivateRouteTable <br/>            SubnetId: !Ref PrivateSubnetB
</pre>
<ol start="8">
<li>We can now focus on the security aspects of our network. Let's focus on the public subnets. These are the subnets you'll add your load balancers to; you'll also add things such as bastion boxes and NAT gateways. So we need to add a <strong>Network ACL</strong> (<strong>NACL</strong>) with several entries:
<ul>
<li>Allow outbound traffic to all ports. Outbound access is unrestricted from hosts in our public subnets.</li>
<li>Allow inbound traffic to ephemeral ports (above <kbd>1024</kbd>). This ensures that packets returned to us from our outbound connections are not dropped.</li>
<li>Allow inbound access to low port numbers for SSH, HTTP, and HTTPS (<kbd>22</kbd>, <kbd>80</kbd>, and <kbd>443</kbd>):</li>
</ul>
</li>
</ol>
<pre>
              # Public NACL <br/>              PublicNACL: <br/>                Type: AWS::EC2::NetworkAcl <br/>                Properties: <br/>                  VpcId: !Ref ExampleVPC <br/>                  Tags: <br/>                    - { Key: Name, Value: Example Public NACL } <br/>              # Allow outbound to everywhere <br/>              NACLRulePublicEgressAllowAll: <br/>                Type: AWS::EC2::NetworkAclEntry <br/>                Properties: <br/>                  CidrBlock: "0.0.0.0/0" <br/>                  Egress: true <br/>                  Protocol: 6 <br/>                  PortRange: { From: 1, To: 65535 } <br/>                  RuleAction: allow <br/>                  RuleNumber: 100 <br/>                  NetworkAclId: !Ref PublicNACL <br/>              # Allow outbound to VPC on all protocols <br/>              NACLRulePublicEgressAllowAllToVPC: <br/>                Type: AWS::EC2::NetworkAclEntry <br/>                Properties: <br/>                  CidrBlock: !Ref VPCCIDR <br/>                  Egress: true <br/>                  Protocol: -1 <br/>                  RuleAction: allow <br/>                  RuleNumber: 200 <br/>                  NetworkAclId: !Ref PublicNACL <br/>              # Allow inbound from everywhere to ephemeral ports<br/>                (above 1024) <br/>              NACLRulePublicIngressAllowEphemeral: <br/>                Type: AWS::EC2::NetworkAclEntry <br/>                Properties: <br/>                  CidrBlock: "0.0.0.0/0" <br/>                  Protocol: 6 <br/>                  PortRange: { From: 1024, To: 65535 } <br/>                  RuleAction: allow <br/>                  RuleNumber: 100 <br/>                  NetworkAclId: !Ref PublicNACL <br/>              # Allow inbound from everywhere on port 22 for SSH <br/>              NACLRulePublicIngressAllowSSH: <br/>                Type: AWS::EC2::NetworkAclEntry <br/>                Properties: <br/>                  CidrBlock: "0.0.0.0/0" <br/>                  Protocol: 6 <br/>                  PortRange: { From: 22, To: 22 } <br/>                  RuleAction: allow <br/>                  RuleNumber: 200 <br/>                  NetworkAclId: !Ref PublicNACL <br/>              # Allow inbound from everywhere on port 443 for HTTPS <br/>              NACLRulePublicIngressAllowHTTPS: <br/>                Type: AWS::EC2::NetworkAclEntry <br/>                Properties: <br/>                  CidrBlock: "0.0.0.0/0" <br/>                  Protocol: 6 <br/>                  PortRange: { From: 443, To: 443 } <br/>                  RuleAction: allow <br/>                  RuleNumber: 300 <br/>                  NetworkAclId: !Ref PublicNACL <br/>              # Allow inbound from everywhere on port 80 for HTTP <br/>              NACLRulePublicIngressAllowHTTP: <br/>                Type: AWS::EC2::NetworkAclEntry <br/>                Properties: <br/>                  CidrBlock: "0.0.0.0/0" <br/>                  Protocol: 6 <br/>                  PortRange: { From: 80, To: 80 } <br/>                  RuleAction: allow <br/>                  RuleNumber: 400 <br/>                  NetworkAclId: !Ref PublicNACL <br/>              # Allow inbound from VPC on all protocols <br/>              NACLRulePublicIngressAllowFromVPC: <br/>                Type: AWS::EC2::NetworkAclEntry <br/>                Properties: <br/>                  CidrBlock: !Ref VPCCIDR <br/>                  Protocol: -1 <br/>                  RuleAction: allow <br/>                  RuleNumber: 500 <br/>                  NetworkAclId: !Ref PublicNACL <br/>              NACLAssociationPublicSubnetA: <br/>                Type: AWS::EC2::SubnetNetworkAclAssociation <br/>                Properties: <br/>                  NetworkAclId: !Ref PublicNACL <br/>                  SubnetId: !Ref PublicSubnetA <br/>              NACLAssociationPublicSubnetB: <br/>                Type: AWS::EC2::SubnetNetworkAclAssociation <br/>                Properties: <br/>                  NetworkAclId: !Ref PublicNACL <br/>                  SubnetId: !Ref PublicSubnetB
</pre>
<ol start="9">
<li>We need to do the same for our private subnets. These subnets are somewhat easier to deal with. They should <em>only</em> be allowed to talk to hosts within our VPC, so we just need to add some NACLs allowing inbound and outbound traffic to our VPCs IP range:</li>
</ol>
<pre>
      # Private NACL <br/>      PrivateNACL: <br/>        Type: AWS::EC2::NetworkAcl <br/>        Properties: <br/>          VpcId: !Ref ExampleVPC <br/>          Tags: <br/>            - { Key: Name, Value: Example Private NACL } <br/>      # Allow all protocols from VPC range <br/>      NACLRulePrivateIngressAllowVPC: <br/>        Type: AWS::EC2::NetworkAclEntry <br/>        Properties: <br/>          CidrBlock: !Ref VPCCIDR <br/>          Protocol: -1 <br/>          RuleAction: allow <br/>          RuleNumber: 100 <br/>          NetworkAclId: !Ref PrivateNACL <br/>      # Allow TCP responses from everywhere <br/>      NACLRulePrivateIngressAllowEphemeral: <br/>        Type: AWS::EC2::NetworkAclEntry <br/>        Properties: <br/>          CidrBlock: "0.0.0.0/0" <br/>          Protocol: 6 <br/>          PortRange: { From: 1024, To: 65535 } <br/>          RuleAction: allow <br/>          RuleNumber: 200 <br/>          NetworkAclId: !Ref PrivateNACL <br/>      # Allow outbound traffic to everywhere, all protocols <br/>      NACLRulePrivateEgressAllowVPC: <br/>        Type: AWS::EC2::NetworkAclEntry <br/>        Properties: <br/>          CidrBlock: "0.0.0.0/0" <br/>          Egress: true <br/>          Protocol: -1 <br/>          RuleAction: allow <br/>          RuleNumber: 100 <br/>          NetworkAclId: !Ref PrivateNACL <br/>      NACLAssociationPrivateSubnetA: <br/>        Type: AWS::EC2::SubnetNetworkAclAssociation <br/>        Properties: <br/>          NetworkAclId: !Ref PrivateNACL <br/>          SubnetId: !Ref PrivateSubnetA <br/>      NACLAssociationPrivateSubnetB: <br/>        Type: AWS::EC2::SubnetNetworkAclAssociation <br/>        Properties: <br/>          NetworkAclId: !Ref PrivateNACL <br/>          SubnetId: !Ref PrivateSubnetB
</pre>
<ol start="10">
<li>Finally, we'll add some <kbd>Outputs</kbd> to our template. These outputs are usually candidates for feeding into other templates or components of automation:</li>
</ol>
<pre>
      Outputs: <br/>        ExampleVPC: <br/>          Value: !Ref ExampleVPC <br/>        PublicSubnetA: <br/>          Value: !Ref PublicSubnetA <br/>        PublicSubnetB: <br/>          Value: !Ref PublicSubnetB <br/>        PrivateRouteTable: <br/>          Value: !Ref PrivateRouteTable <br/>        PublicRouteTable: <br/>          Value: !Ref PublicRouteTable <br/>        PrivateSubnetA: <br/>          Value: !Ref PrivateSubnetA <br/>        PrivateSubnetB: <br/>          Value: !Ref PrivateSubnetB
</pre>
<ol start="11">
<li>You can go ahead and create your VPC in the web console or via the CLI using the following command:</li>
</ol>
<pre>
<strong>      aws cloudformation create-stack \</strong><br/><strong>        --stack-name secure-vpc \</strong><br/><strong>        --template-body file://07-building-a-secure-network.yaml \</strong><br/><strong>        --parameters \</strong><br/><strong>        ParameterKey=AvailabilityZone1,ParameterValue=&lt;az-1&gt; \</strong><br/><strong>        ParameterKey=AvailabilityZone2,ParameterValue=&lt;az-2&gt;</strong>
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>When you run this template, AWS will go ahead and create an isolated, secure network just for you. While it contains a number of resources and concepts which will be familiar to network administrators, it's essentially an empty shell, which you can now go ahead and populate.</p>
<p>For example, each VPC contains a virtual router. You can't see it and you can't log into it to perform any special configuration, but you can customize its behavior by modifying the route tables in this template.</p>
<p>The NACLs we've deployed are not stateful and should <em>not</em> be considered a substitution for security groups. NACLs are <em>complementary</em> to security groups, which are stateful and frankly much easier to change and manage than NACLs. While the NACLs in our recipe allow everywhere (<kbd>0.0.0.0/0</kbd>) to make inbound connections to port <kbd>22</kbd>, for example, you'll want to use security groups to lock this down to a specific IP range (your corporate data center, for example).</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">There's more...</h1>
            </header>

            <article>
                
<p>Actually, there's a <em>lot</em> more. Despite the amount of code in this recipe, we've really only covered the basics of what's possible with VPCs and networking in AWS. Here are some of the main VPC topics you'll encounter as you progress with your VPC usage:</p>
<ul>
<li><strong>Direct Connect</strong>: This is a method of connecting your DC to your VPC using a private, dedicated pipe. Doing this often provides better network performance, and may also be cheaper than a VPN connection over the Internet.</li>
<li><strong>Virtual Private Gateway</strong> (<strong>VPN</strong>): You can configure your VPC to connect to your corporate DC over the Internet via VPN. This requires that you run supported VPN hardware in your DC.</li>
<li>IPv6 support was added recently. We've left it out to keep things simple.</li>
<li><strong>VPC endpoints</strong>: This feature exposes AWS endpoints inside your VPC so that you don't have to route traffic over public Internet to consume them. Only S3 is supported at the time of writing.</li>
<li><strong>VPC peering</strong>: You can peer a VPC to one or more VPCs so that (unencrypted) traffic can flow between them. The IP ranges must not clash and, while the peering is free, you will still need to pay for traffic between VPCs. Transitive peering isn't supported, so if you need traffic to traverse VPCs you'll require a VPN/routing appliance of some kind. Cross-account VPC peering is supported (we use this feature quite often), but cross-region peering isn't yet available.</li>
<li><strong>VPC sizing</strong>:
<ul>
<li>IPv4: You can deploy networks between sizes /28 and /16.</li>
<li>IPv6: Your VPCs will be fixed in size at /56.</li>
<li>Once your VPC has been deployed you can't change its size. If you run out of IP space, your only option is to deploy a larger VPC and migrate everything (ouch!), or you can perhaps mitigate your problem with VPC peering.Â </li>
</ul>
</li>
</ul>
<ul>
<li><strong>VPC flow-logs</strong>: You will want to enable VPC flow-logs in order to monitor traffic and do any kind of network debugging.</li>
<li>Multicast traffic isn't supported.</li>
<li>Subnets must reside in a single availability zone; they can't span Availability Zones.</li>
<li><strong>Elastic Load Balancers</strong> (<strong>ELBs</strong>) can scale out to use a lot of private IP addresses if you are sending a large amount of traffic through them. Keep this in mind when you're sizing your subnets.</li>
<li>The number of VPCs you can deploy is limited to five per region, per account. You can request to increase this limit if necessary. Internet gateways have the same limit, and increasing one limit increases the other.</li>
<li>The <em>default</em> VPC:
<ul>
<li>First and foremost, the default VPC is created automatically for you when you create your account. It has some different properties and behaviors to the VPCs you create for yourself.</li>
<li>If you try to launch an EC2 instance without specifying a subnet ID, AWS will attempt to launch it in your default VPC.</li>
<li>It consists of only public subnets. These subnets are configured to provide a public IP address to all instances by default.</li>
<li>It's possible to delete the default VPC in a region. If you do this by mistake, or have simply decided that you'd like to undo this action, you'll need to log a support ticket with AWS to have them create a new one for you.</li>
</ul>
</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also...</h1>
            </header>

            <article>
                
<ul>
<li>The <em>Creating a NAT gateway</em> recipe</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating a NAT gateway</h1>
            </header>

            <article>
                
<p>Unless required, your instances should not be publicly exposed to the Internet. When your instances are on the Internet, you have to assume they will be attacked at some stage.</p>
<p>This means most of your workloads should run on instances in private subnets. Private subnets are those that are not connected directly to the Internet.</p>
<p>In order to give your private instances access to the Internet, you use <strong>network address translation</strong> (<strong>NAT</strong>). A NAT gateway allows your instances to initiate a connection <em>to</em> the Internet, without allowing connections <em>from</em> the Internet.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Getting ready</h1>
            </header>

            <article>
                
<p>For this recipe, you must have the following existing resources:</p>
<ul>
<li>A VPC with an <strong>Internet gateway</strong> (<strong>IGW</strong>)</li>
<li>A public subnet</li>
<li>A private subnet route table</li>
</ul>
<p>You will need the IDs for the public subnet and private subnet route table. Both of these resources should be in the same AZ.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Start with the usual CloudFormation template version and description:</li>
</ol>
<pre>
      AWSTemplateFormatVersion: "2010-09-09" <br/>      Description: Create NAT Gateway and associated route.
</pre>
<ol start="2">
<li>The template must take the following required parameters:</li>
</ol>
<pre>
      Parameters: <br/>        PublicSubnetId: <br/>          Description: Public Subnet ID to add the NAT Gateway to <br/>          Type: AWS::EC2::Subnet::Id <br/>        RouteTableId: <br/>          Description: The private subnet route table to add the NAT<br/>          Gateway route to <br/>          Type: String
</pre>
<ol start="3">
<li>In the <kbd>Resources</kbd> section, define an <strong>Elastic IP</strong> (<strong>EIP</strong>) that will be assigned to the NAT gateway:</li>
</ol>
<pre>
      Resources: <br/>        EIP: <br/>          Type: AWS::EC2::EIP <br/>          Properties: <br/>            Domain: vpc
</pre>
<ol start="4">
<li>Create the NAT gateway resource, assigning it the EIP you just defined in the public subnet:</li>
</ol>
<pre>
      NatGateway: <br/>        Type: AWS::EC2::NatGateway <br/>        Properties: <br/>          AllocationId: !GetAtt EIP.AllocationId <br/>          SubnetId: !Ref PublicSubnetId
</pre>
<ol start="5">
<li>Finally, define the route to the NAT gateway and associate it with the private subnet's route table:</li>
</ol>
<pre>
      Route: <br/>        Type: AWS::EC2::Route <br/>        Properties: <br/>          RouteTableId: !Ref RouteTableId <br/>          DestinationCidrBlock: 0.0.0.0/0 <br/>          NatGatewayId: !Ref NatGateway
</pre>
<ol start="6">
<li>Save the template with a known filename; for example, <kbd>07-nat-gateway.yaml</kbd>.</li>
<li>Launch the template with the following CLI command:</li>
</ol>
<pre>
<strong>      aws cloudformation create-stack \</strong><br/><strong>        --stack-name nat-gateway \</strong><br/><strong>        --template-body file://07-nat-gateway.yaml \</strong><br/><strong>        --parameters \</strong><br/><strong>        ParameterKey=RouteTableId,ParameterValue=&lt;route-table-id&gt; \</strong><br/><strong>        ParameterKey=PublicSubnetId,ParameterValue=&lt;public-subnet-id&gt;</strong>
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>The parameters required for this recipe are as follows:</p>
<ul>
<li>A public subnet ID</li>
<li>A private subnet route table ID</li>
</ul>
<p>The public subnet ID is needed to host the NAT gateway, which must have Internet access. The private subnet route table will be updated with a route to the NAT gateway.</p>
<p>Using the AWS NAT gateway service means that AWS takes care of hosting and securing the service for you. The service will be hosted redundantly in a single AZ.</p>
<div class="packt_infobox">You can use this recipe multiple times to deploy NAT gateways in each of your private subnets. Just make sure the public subnet and the private subnet are in the same AZ.</div>
<p>In the unlikely (but possible) event of an AZ outage, you should deploy a NAT gateway per subnet. This means that if one NAT gateway goes offline, instances in the other AZ can continue to access the Internet as normal. You are deploying your application in multiple subnets, aren't you?</p>
<p>This recipe will only work if you have created your own private subnets, as the default subnets in a new AWS account are all <em>public</em>. Instances in a public subnet have direct access to the Internet (via an IGW), so they do not need a NAT gateway.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<ul>
<li>The <em>Building a secure network</em> recipe</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Canary deployment via DNS</h1>
            </header>

            <article>
                
<p>Canary deployment is a popular deployment method in the cloud. It allows you to deploy new versions of your resources alongside your old resources, gradually and selectively directing parts of your traffic to the new resource.</p>
<p>By directing a small portion of your traffic to your new resources, you can get valuable real-world data and metrics. This means you don't need to engage in a <em>big bang</em> deploymentâ€”where you switch over all of your traffic at once.</p>
<p>It also gives you more flexibility in terms of troubleshooting and monitoring; if you see errors for your new resources, you can redirect the traffic back to your old resources while you investigate.</p>
<p>In this recipe, we will create the resources necessary to do a DNS-based canary deployment, and cut traffic from one resource to another (that is, old to new).</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Getting ready</h1>
            </header>

            <article>
                
<p>This recipe requires a few things to be in place:</p>
<ul>
<li>A Route 53 hosted zone for your domain suffix</li>
<li>Existing DNS records for your <em>old</em> and <em>new</em> resources/endpoints</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>In a new file, define the template version and description:</li>
</ol>
<pre>
      AWSTemplateFormatVersion: "2010-09-09"  <br/>      Description: Create a weighted DNS setup for canary deployments.
</pre>
<ol start="2">
<li>Start the <kbd>Parameters</kbd> section and the required parameters:</li>
</ol>
<pre>
      Parameters: <br/>        HostedZoneName: <br/>          Type: String <br/>          Description: The hosted zone to create records in <br/> <br/>        DomainName: <br/>          Type: String <br/>          Description: The domain name to create in the hosted zone <br/> <br/>        OldResource: <br/>          Type: String <br/>          Description: The older resource domain name <br/> <br/>        NewResource: <br/>          Type: String <br/>          Description: The newer resource domain name
</pre>
<ol start="3">
<li>Include the optional parameters (such as those with defaults) in the <kbd>Parameters</kbd> section:</li>
</ol>
<pre>
      OldWeight: <br/>        Type: Number <br/>        Default: 1 <br/>        Description: The ratio of requests to send to the older endpoint <br/> <br/>      NewWeight: <br/>        Type: Number <br/>        Default: 0 <br/>        Description: The ratio of requests to send to the newer endpoint
</pre>
<ol start="4">
<li>Start the <kbd>Resources</kbd> section of the template, and define your record set group:</li>
</ol>
<pre>
      Resources: <br/>        RecordSetGroup: <br/>          Type: AWS::Route53::RecordSetGroup <br/>          Properties: <br/>            HostedZoneName: !Ref HostedZoneName <br/>            Comment: Canary deployment record set group <br/>            RecordSets: <br/>              - Name: !Join [ ".", [ Ref: DomainName, Ref: <br/>                  HostedZoneName ] ] <br/>                Type: CNAME <br/>                TTL: "300" <br/>                SetIdentifier: Old <br/>                Weight: !Ref OldWeight <br/>                ResourceRecords: <br/>                  - !Ref OldResource <br/>              - Name: !Join [ ".", [ Ref: DomainName, Ref: <br/>                  HostedZoneName ] ] <br/>                Type: CNAME <br/>                TTL: "300" <br/>                SetIdentifier: New <br/>                Weight: !Ref NewWeight <br/>                ResourceRecords: <br/>                  - !Ref NewResource
</pre>
<ol start="5">
<li>Save the template with a known filename; for example, <kbd>07-canary-deployments.yaml</kbd>.</li>
<li>Launch the template with the following CLI command:</li>
</ol>
<pre>
<strong>      aws cloudformation create-stack \</strong><br/><strong>        --stack-name canary \</strong><br/><strong>        --template-body file://07-canary-deployments.yaml \</strong><br/><strong>        --parameters \</strong><br/><strong>        ParameterKey=DomainName,ParameterValue=&lt;your-domain-name&gt; \</strong><br/><strong>        ParameterKey=OldResource,ParameterValue=&lt;old-resource-dns&gt; \</strong><br/><strong>        ParameterKey=NewResource,ParameterValue=&lt;new-resource-dns&gt; \</strong><br/><strong>        ParameterKey=HostedZoneName,ParameterValue=&lt;your-hosted-zone&gt; </strong>
</pre>
<ol start="7">
<li>When ready, update the stack to change (just) the domain weighting with the following CLI command:</li>
</ol>
<pre>
<strong>      aws cloudformation update-stack \</strong><br/><strong>        --stack-name canary \</strong><br/><strong>        --parameters \</strong><br/><strong>        ParameterKey=HostedZoneName,UsePreviousValue=true \</strong><br/><strong>        ParameterKey=DomainName,UsePreviousValue=true \</strong><br/><strong>        ParameterKey=OldResource,UsePreviousValue=true \</strong><br/><strong>        ParameterKey=NewResource,UsePreviousValue=true \</strong><br/><strong>        ParameterKey=OldWeight,ParameterValue=0 \</strong><br/><strong>        ParameterKey=NewWeight,ParameterValue=1 \</strong><br/><strong>        --use-previous-template</strong>
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>This template focuses on utilizing the features of a Route 53 record set group, and the most useful properties have been parameterized.</p>
<p>The value for your <kbd>DomainName</kbd> parameter will be created as multiple <kbd>CNAME</kbd> records in your hosted zone (as set in <kbd>HostedZoneName</kbd>), one for each of your resources, old and new.</p>
<p>The <kbd>OldResource</kbd> and <kbd>NewResource</kbd> parameters represent the target domain names that the incoming requests will be shared between.</p>
<p>Once the stack is deployed, you will be able to go to your domain name and see your <em>old</em> resource. By default, this template will send all traffic to the old resource endpoint.</p>
<p>Once you've verified the setup is working correctly, you can start to deploy by updating the stack to send <em>some</em> of your requests to the new resource.</p>
<p>Changing the resource record set's weightings via the CLI is quite involved, as it requires passing a complex JSON object as an argument. It is much simpler and safer to simply update the existing CloudFormation stack you deployed, changing just the weighting parameters that are already present.</p>
<p>With the <kbd>update-stack</kbd> command, the new weightings will be propagated to your record set group members (without interruption) and the new distribution of traffic will start taking effect.</p>
<p>For the parameters without default values, you must explicitly tell CloudFormation to use the previous values, as well as the template body supplied previously.</p>
<p>Remember that the distribution will be determined by the target's weight divided by the total weight value of all targets. This means you can easily <em>turn off</em> a target by setting its weight to <kbd>0</kbd>, regardless of the other weight values. In this recipe, we have used <kbd>0</kbd> and <kbd>1</kbd> as simple values to illustrate the impact, but you can (and should) use more fine-grained parameters.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Hosting a domain</h1>
            </header>

            <article>
                
<p>In this recipe, we'll show you how to host a domain in Route 53 and add some records to it:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" height="282" src="assets/B06236_07_02.png" width="519"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Hosting a domain</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Getting ready</h1>
            </header>

            <article>
                
<p>You technically don't need to have registered a domain name in order to proceed with this recipe, but it sure helps if you have a real domain that you can use.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Create a new CloudFormation template and add the following <kbd>Parameter</kbd> to it:</li>
</ol>
<pre>
      Parameters: <br/>        DomainName: <br/>          Description: Your domain name (example.org) <br/>          Type: String
</pre>
<ol start="2">
<li>Next we need to add a <kbd>HostedZone</kbd> resource to our template, as follows:</li>
</ol>
<pre>
      Resources: <br/>        DNSHostedZone:  <br/>          Type: AWS::Route53::HostedZone <br/>          Properties: <br/>            Name: !Ref DomainName
</pre>
<ol start="3">
<li>You're now ready to go ahead and create your hosted zone in Route 53. You can do so via the CloudFormation web console, or use the following CLI command:</li>
</ol>
<pre>
<strong>      aws cloudformation create-stack \</strong><br/><strong>        --stack-name example-hosted-zone \</strong><br/><strong>        --template-body file://07-hosting-a-domain.yaml \</strong><br/><strong>        --parameters \</strong><br/><strong>        ParameterKey=DomainName,ParameterValue=&lt;your-domain-name&gt;</strong>
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>This will create a hosted zone in Route 53. Once the stack has finished creating, go and find it in the web console. You'll see that there are a number of name servers associated with it. These are the name servers to use if you wish to proceed with delegating your domain name to AWS's Route 53 servers using your domain name registrar's control panel.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">There's more...</h1>
            </header>

            <article>
                
<p>A hosted zone with no DNS records will be of limited use to you. Here are some examples of records that you may wish to add to your template:</p>
<pre>
  DNSRecords: <br/>    Type: AWS::Route53::RecordSetGroup <br/>    Properties: <br/>      HostedZoneId: <br/>        Ref: DNSHostedZone <br/>      RecordSets: <br/>      - Name: !Ref DomainName <br/>        Type: A <br/>        TTL: 60 <br/>        ResourceRecords: <br/>          - "127.0.0.1" <br/>      - Name: !Ref DomainName <br/>        Type: MX <br/>        TTL: 60 <br/>        ResourceRecords: <br/>          - "10 smtp.example.org" <br/>          - "20 smtp.example.org" <br/>      - Name: !Ref DomainName <br/>        Type: TXT <br/>        TTL: 60 <br/>        ResourceRecords: <br/>          - '"v=spf1 include:spf.example.org ?all"'
</pre>
<div class="packt_infobox"><span class="packt_screen">Some items of note:<br/></span> For the priority in <kbd>MX</kbd> records, add the number at the start of the record followed by a space.<br/>
For <kbd>TXT</kbd> records such as <kbd>spf</kbd> entries, which are typically required to be quoted, you can surround double quotes with single quotes.</div>
<p>Here's how they look in the Route 53 web console:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" src="assets/B06236_07_03-1.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Hosting a domain</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also...</h1>
            </header>

            <article>
                
<ul>
<li>The <em>Hosting a static website</em> recipe in <a href="3061e8a1-9092-4f75-931a-8c4da66160b7.xhtml"><span class="ChapterrefPACKT">Chapter 3</span></a>, <em>Storage and Content Delivery</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Routing based on location with failover</h1>
            </header>

            <article>
                
<p>In this recipe, we're going to show you two Route 53 routing policies:</p>
<ul>
<li>Geolocation routing</li>
<li>Failover routing</li>
</ul>
<p>In fact, we're actually going to combine these two policies together. A perusal of the AWS documentation might lead you to believe that this isn't particularly common practice, but understand that by combining routing policies, you can do great things for your performance and availability.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Getting ready</h1>
            </header>

            <article>
                
<p>Given that we're demonstrating a failover task, you'll want to set up two ELBs before we proceed. We're going to assume you're doing this in different regions, but this isn't strictly necessary. These ELBs will need to accept HTTP connections (on port <kbd>80</kbd> of course) and have at least one instance attached to them (which is passing its health check and serving content).</p>
<div class="packt_infobox">The <em>Creating security groups</em> recipe in <a href="beece917-78ff-43b8-934b-706eca5968f9.xhtml"><span class="ChapterrefPACKT">Chapter 4</span></a>, <em>Using AWS Compute</em> deployed in two different regions, should fit the bill nicely.</div>
<p>You'll also need a domain name that you'd like to create as a new hosted zone in Route 53. You technically don't need to delegate this domain to Route 53 from your registrar, so you can complete this recipe with any domain you choose. Just remember that using a real domain you can delegate to Route 53, which will save you messing with your localhost's file or DNS setup in order to test this recipe.</p>
<p>In summary, you'll need the following:</p>
<ul>
<li>The DNS names for both ELBs</li>
<li>The hosted zone IDs for both ELBs</li>
<li>A domain name of your choosing</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Go ahead and create a new CloudFormation template. We'll add some <kbd>Parameters</kbd> for the items we've mentioned previously:</li>
</ol>
<pre>
      Parameters: <br/>        DomainName: <br/>          Description: Your domain name (example.org) <br/>          Type: String <br/>        LoadBalancerDNSNameRegionA: <br/>          Description: The DNS name of your ELB in region A <br/>          Type: String <br/>        LoadBalancerHostedZoneRegionA: <br/>          Description: The Hosted Zone ID of your ELB in region A <br/>          Type: String <br/>        LoadBalancerDNSNameRegionB: <br/>          Description: The DNS name of your ELB in region B <br/>          Type: String <br/>        LoadBalancerHostedZoneRegionB: <br/>          Description: The Hosted Zone ID of your ELB in region B <br/>          Type: String
</pre>
<ol start="2">
<li>The first <kbd>Resource</kbd> we want is the <kbd>HostedZone</kbd> resource for our domain name. Add it to your template as follows:</li>
</ol>
<pre>
      Resources: <br/>        DNSHostedZone: <br/>          Type: AWS::Route53::HostedZone <br/>          Properties: <br/>            Name: !Ref DomainName
</pre>
<ol start="3">
<li>In order to have failover happen automatically, we're going to need to set up some health checks. We want health checks on the ELBs in both regions:</li>
</ol>
<pre>
        RegionAHealthCheck: <br/>          Type: AWS::Route53::HealthCheck <br/>          Properties: <br/>            HealthCheckConfig: <br/>              FailureThreshold: 3 <br/>              FullyQualifiedDomainName: !Ref LoadBalancerDNSNameRegionA <br/>              Port: 80 <br/>              RequestInterval: 30 <br/>              ResourcePath: "/" <br/>              Type: HTTP <br/>            HealthCheckTags: <br/>              - { Key: Name, Value: Region A Health Check } <br/>        RegionBHealthCheck: <br/>          Type: AWS::Route53::HealthCheck <br/>          Properties: <br/>            HealthCheckConfig: <br/>              FailureThreshold: 3 <br/>              FullyQualifiedDomainName: !Ref LoadBalancerDNSNameRegionB <br/>              Port: 80 <br/>              RequestInterval: 30 <br/>              ResourcePath: "/" <br/>              Type: HTTP <br/>            HealthCheckTags: <br/>              - { Key: Name, Value: Region B Health Check }
</pre>
<ol start="4">
<li>We're now going to create four record sets for your domain:
<ul>
<li><kbd>a.&lt;your-domain&gt;-PRIMARY</kbd></li>
<li><kbd>b.&lt;your-domain&gt;-PRIMARY</kbd></li>
<li><kbd>a.&lt;your-domain&gt;-SECONDARY</kbd> (failover to <kbd>b</kbd>)</li>
<li><kbd>b.&lt;your-domain&gt;-SECONDARY</kbd> (failover to <kbd>a</kbd>)</li>
</ul>
</li>
</ol>
<ol start="5">
<li>These records correspond to ELB A and ELB B (or <em>site</em> A and B, if that term makes more sense to you), and they will allow each region to fail over to the other if the health check fails.</li>
<li>Let's start with the primary records for both ELBs:</li>
</ol>
<pre>
        RegionAPrimary: <br/>          Type: AWS::Route53::RecordSet <br/>          Properties: <br/>            Name: !Join [ ., [ a, Ref: DomainName ] ] <br/>            Type: A <br/>            HostedZoneId: !Ref DNSHostedZone <br/>            AliasTarget: <br/>              HostedZoneId: !Ref LoadBalancerHostedZoneRegionA <br/>              DNSName: !Ref LoadBalancerDNSNameRegionA <br/>              Failover: PRIMARY <br/>              SetIdentifier: primary-region-a <br/>              HealthCheckId: !Ref RegionAHealthCheck <br/>        RegionBPrimary: <br/>          Type: AWS::Route53::RecordSet <br/>          Properties: <br/>            Name: !Join [ ., [ b, Ref: DomainName ] ] <br/>            Type: A <br/>            HostedZoneId: !Ref DNSHostedZone <br/>            AliasTarget: <br/>              HostedZoneId: !Ref LoadBalancerHostedZoneRegionB <br/>              DNSName: !Ref LoadBalancerDNSNameRegionB <br/>              Failover: PRIMARY <br/>              SetIdentifier: primary-region-b <br/>              HealthCheckId: !Ref RegionBHealthCheck
</pre>
<ol start="7">
<li>Now add the secondary (failover) records:</li>
</ol>
<pre>
        RegionAFailover: <br/>          Type: AWS::Route53::RecordSet <br/>          Properties: <br/>            Name: !Join [ ., [ a, Ref: DomainName ] ] <br/>            Type: A <br/>            HostedZoneId: !Ref DNSHostedZone <br/>            AliasTarget: <br/>              HostedZoneId: !Ref LoadBalancerHostedZoneRegionB <br/>              DNSName: !Ref LoadBalancerDNSNameRegionB <br/>              Failover: SECONDARY <br/>              SetIdentifier: secondary-region-a <br/>        RegionBFailover: <br/>          Type: AWS::Route53::RecordSet <br/>          Properties: <br/>            Name: !Join [ ., [ b, Ref: DomainName ] ] <br/>            Type: A <br/>            HostedZoneId: !Ref DNSHostedZone <br/>            AliasTarget: <br/>              HostedZoneId: !Ref LoadBalancerHostedZoneRegionA <br/>              DNSName: !Ref LoadBalancerDNSNameRegionA <br/>              Failover: SECONDARY <br/>              SetIdentifier: secondary-region-b
</pre>
<ol start="8">
<li>Now we're going to add the root/apex record for our domain. For the purposes of this recipe, we're going to send requests originating from North America to region/ELB A, and requests from the rest of the world to region/ELB B:</li>
</ol>
<pre>
        NorthAmericaGeolocation: <br/>          Type: AWS::Route53::RecordSet <br/>          Properties: <br/>            Name: !Ref DomainName <br/>            Type: A <br/>            HostedZoneId: !Ref DNSHostedZone <br/>            AliasTarget: <br/>              HostedZoneId: !Ref DNSHostedZone <br/>              DNSName: !Join [ ., [ a, Ref: DomainName ] ] <br/>            GeoLocation: <br/>              ContinentCode: NA # North America <br/>            SetIdentifier: geolocation-region-a <br/>        RestOfWorldGeolocation: <br/>          Type: AWS::Route53::RecordSet <br/>          Properties: <br/>            Name: !Ref DomainName <br/>            Type: A <br/>            HostedZoneId: !Ref DNSHostedZone <br/>            AliasTarget: <br/>              HostedZoneId: !Ref DNSHostedZone <br/>              DNSName: !Join [ ., [ b, Ref: DomainName ] ] <br/>            GeoLocation: <br/>              CountryCode: "*" # Rest of world <br/>            SetIdentifier: geolocation-region-b
</pre>
<ol start="9">
<li>That's it! You can now run this CloudFormation template in the AWS web console or via the CLI, as follows:</li>
</ol>
<pre>
<strong>      aws cloudformation create-stack \</strong><br/><strong>        --stack-name geolocation-failover \</strong><br/><strong>        --template-body file://07-routing-based-on-location.yaml \</strong><br/><strong>        --parameters \</strong><br/><strong>        ParameterKey=DomainName,ParameterValue=gitrepository.com \</strong><br/><strong>        ParameterKey=LoadBalancerDNSNameRegionA,ParameterValue=&lt;elb-a&gt; \</strong><br/><strong>        ParameterKey=LoadBalancerHostedZoneRegionA, \<br/>        ParameterValue=&lt;elb-zoneid-a&gt; \</strong><br/><strong>        ParameterKey=LoadBalancerDNSNameRegionB,ParameterValue=&lt;elb-b&gt; \</strong><br/><strong>        ParameterKey=LoadBalancerHostedZoneRegionB, \<br/>        ParameterValue=&lt;elb-zoneid-b&gt;</strong>
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>We've effectively constructed a small decision tree, as follows:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_07_004.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Route 53 flow</div>
<p>In order to test this for yourself, you'll need to have some way of performing DNS responses from other regions. In the following screenshots, we have provisioned a machine using AWS workspaces in North America (left), while our actual location is in Australia (right).<br/></p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Normal operation (geolocation routing)</h1>
            </header>

            <article>
                
<p>Under normal operation, our North American user (left) will connect to region A, which, for practical reasons, we've deployed in <kbd>us-east-1</kbd>, although it could be in any region. Our Australian user (right) will connect to region B, which is the region we've designated as being for theÂ <em>rest of the world</em>. Again, for practical reasons, we deployed this site to the <kbd>ap-southeast-2</kbd> region:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_07_005.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Left: Region A served to North American user. Right: Region B served to Australian user.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Region A failure</h1>
            </header>

            <article>
                
<p>To simulate a failure of region A, we'll simply stop the web server, which is attached to the ELB as follows:</p>
<pre>
    <strong>[root@ip-172-30-0-153 ec2-user]# service nginx stop</strong><br/>    <strong>Stopping nginx:                                            [  OK  ]</strong>
</pre>
<p>After a short period, the web console will show that the health check for region A is failing:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" height="273" src="assets/B06236_07_06.png" width="505"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Region A failing health check</div>
<p>Our North American user (left) now sees region B instead:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="274" src="assets/image_07_007.png" width="505"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Left: Region B served to North American users due to failover. Right: Region B served to Australian users as normal.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Region B failure</h1>
            </header>

            <article>
                
<p>We'll now flip the script and simulate the same scenario in region B. This time, the web server in this region is stopped, but the server in region A is healthy:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" src="assets/B06236_07_08.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Region B failing health check</div>
<p>Region A content will now be shown to both North American users and those designated as theÂ <em>rest of the world</em> (including Australia):</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_07_009.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Left: Region A served to North American users as normal. Right: Region A served to Australian users due to failover.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">There's more...</h1>
            </header>

            <article>
                
<p>Route 53 offers a couple of other useful routing policies, so you should have a think about which best suits you:</p>
<ul>
<li><strong>Latency-based routing</strong>: This policy makes the Route 53 DNS servers respond to you with IP addresses that provide the lowest latency. This will not necessarily be the endpoint geographically closest to you.</li>
<li><strong>Weighted routing</strong>: This allows you to divvy up your traffic between endpoints based on a weighting system. You might have a 50/50 split between two regions, or you may elect to have a 90/10 ratio instead.</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also...</h1>
            </header>

            <article>
                
<ul>
<li>The <em>Hosting a static website</em> recipe in <a href="3061e8a1-9092-4f75-931a-8c4da66160b7.xhtml"><span class="ChapterrefPACKT">Chapter 3</span></a>,Â <em>Storage and Content Delivery</em></li>
<li>The <em>Creating security groups</em> recipe in <a href="beece917-78ff-43b8-934b-706eca5968f9.xhtml"><span class="ChapterrefPACKT">Chapter 4</span></a>, <em>Using AWS Compute</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Network logging and troubleshooting</h1>
            </header>

            <article>
                
<p>One of the benefits of using virtualized infrastructure is that you can get a level of introspection that is difficult or costly with physical hardware. Being able to quickly switch on logging at a network-device level is an extremely useful feature, especially when getting used to the interactions between VPCs, subnets, NACLs, routing, and security groups.</p>
<p>In this recipe, we will turn on logging for our network resources. You could do this all the time, to give yourself another layer for monitoring and auditing, or you could selectively enable it during troubleshooting, saving yourself any additional datastorage charges.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Getting ready</h1>
            </header>

            <article>
                
<p>For this recipe, you must have a VPC to log activity on.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Start by defining the template version and description:</li>
</ol>
<pre>
      AWSTemplateFormatVersion: "2010-09-09" <br/>      Description: Flow logs for networking resources
</pre>
<ol start="2">
<li>Define the <kbd>Parameters</kbd>Â for the template. In this case, it is just the <kbd>VpcId</kbd> to turn logging on for:</li>
</ol>
<pre>
      Parameters: <br/>        VpcId: <br/>          Type: String <br/>          Description: The VPC to create flow logs for
</pre>
<ol start="3">
<li>Create the <kbd>Resources</kbd> section of the template and define the log group to use to send our flow-logs to:</li>
</ol>
<pre>
      Resources: <br/>        LogGroup: <br/>          Type: AWS::Logs::LogGroup <br/>          DeletionPolicy: Delete <br/>          Properties: <br/>            LogGroupName: LogGroup
</pre>
<ol start="4">
<li>Next we define the IAM role that will give the flow-logs service permission to write the logs:</li>
</ol>
<pre>
        IamRole: <br/>          Type: AWS::IAM::Role <br/>          Properties: <br/>            AssumeRolePolicyDocument: <br/>              Version: "2012-10-17" <br/>              Statement: <br/>                - <br/>                  Effect: Allow <br/>                  Principal: <br/>                    Service: vpc-flow-logs.amazonaws.com <br/>                  Action: sts:AssumeRole <br/>            Policies: <br/>              - <br/>                PolicyName: CloudWatchLogsAccess <br/>                PolicyDocument: <br/>                  Version: "2012-10-17" <br/>                  Statement: <br/>                    - <br/>                      Action: <br/>                        - logs:CreateLogGroup <br/>                        - logs:CreateLogStream <br/>                        - logs:PutLogEvents <br/>                        - logs:DescribeLogGroups <br/>                        - logs:DescribeLogStreams <br/>                      Effect: Allow <br/>                      Resource: "*"
</pre>
<ol start="5">
<li>Finally, we define the flow-log itself:</li>
</ol>
<pre>
        FlowLog: <br/>          Type: AWS::EC2::FlowLog <br/>          DependsOn: LogGroup <br/>          Properties: <br/>            DeliverLogsPermissionArn: !GetAtt IamRole.Arn <br/>            LogGroupName: LogGroup <br/>            ResourceId: !Ref VpcId <br/>            ResourceType: VPC <br/>            TrafficType: ALL
</pre>
<ol start="6">
<li>Save the template, and give it a known filename such as <kbd>07-flow-logs.yaml</kbd>.</li>
</ol>
<ol start="7">
<li>Create the flow-logs and associated resources by creating the template with the following command:</li>
</ol>
<pre>
<strong>      aws cloudformation create-stack \</strong><br/><strong>        --stack-name VpcFlowLogs \</strong><br/><strong>        --template-body file://07-flow-logs.yml \</strong><br/><strong>        --capabilities CAPABILITY_IAM \</strong><br/><strong>        --parameters ParameterKey=VpcId,ParameterValue=&lt;your-vpc-id&gt;</strong>
</pre>
<ol start="8">
<li>Once launched (and assuming you have network activity), you will be able to see your flow-log in the CloudWatch logs console.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>The only parameter required for this template is the VPC ID to target. We specifically target a VPC to turn on flow-logging for, because it gives us the most <em>bang for buck</em>. While you can enable flow-logs for subnets and <strong>Elastic Network Interfaces</strong> (<strong>ENIs</strong>) individually, if you enable them on a VPC you get flow-logs for all the networking resources contained in that VPCâ€”which includes subnets and ENIs.</p>
<p>In the resources section, we start by explicitly defining the log group to <em>hold</em> the flow-logs. If you don't create the log group yourself (and specify it in your flow-log resource configuration), a log group will be created for you. This means that you will still be able to use flow-logs, but the log group won't be managed by CloudFormation and will have to be maintained (for example, deleted) manually. We have also set a <strong>deletion policy</strong> of <em>delete</em> for our log group. This means it will be deleted if the CloudFormation stack is deleted, which is fine for a demonstration such as this. If using in a <em>real</em> environment (such as production), remove the <kbd>DeletionPolicy</kbd> property and its value.</p>
<div class="packt_infobox">By default, CloudWatch log groups are <em>not</em> deleted when the stack that created them is deleted. This lets you retain any important logs, but it can incur an ongoing cost.</div>
<p>Next we define the IAM role to use. Via the <kbd>AssumeRolePropertyDocument</kbd> value, we give the AWS flow-logs service permission to assume this role. Without this access, the flow-logs service cannot access the account. In the <kbd>Policies</kbd> property, we give the role permission to create and update log groups and streams.</p>
<p>Finally, now that we have created the dependent resources, we define the flow-log resource itself. You don't need to define the resources in order of dependencies, but it is usually easier to read if you do. In the resource, we also define a <kbd>DependsOn</kbd> relationship to the log group we defined earlier, so that the log group is ready to receive the flow-logs when it is created.</p>
<p>The final step is to launch the template you have created, passing the VPC ID as parameter. As this template creates an IAM role to allow the VPC service to send logs to CloudWatch logs, the command to create the stack must be given the <kbd>CAPABILITY_IAM</kbd> flag to signify that you are aware of the potential impact of launching this template.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">There's more...</h1>
            </header>

            <article>
                
<p>Turning on logging is just the start of the troubleshooting process. There are a few other things you should be aware of when using flow-logs.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Log format</h1>
            </header>

            <article>
                
<p>Once logging is enabled, you can view the logs in the CloudWatch logs console. Here is a summary of the type of information you will see in the flow-log (in order):</p>
<ul>
<li>The VPC flow-logs version</li>
<li>The AWS account ID</li>
<li>The ID of the network interface</li>
<li>The source IPv4 or IPv6 address</li>
<li>The destination IPv4 or IPv6 address</li>
<li>The source port of the traffic</li>
<li>The destination port of the traffic</li>
<li>The IANA protocol number of the traffic</li>
<li>The number of packets transferred</li>
<li>The number of bytes transferred</li>
<li>The start time of the capture window (in Unix seconds)</li>
<li>The end time of the capture window (in Unix seconds)</li>
<li>The action associated with the traffic; for example, <kbd>ACCEPT</kbd> or <kbd>REJECT</kbd></li>
<li>The logging status of the flow-log; for example, <kbd>OK</kbd>, <kbd>NODATA</kbd>, or <kbd>SKIPDATA</kbd></li>
</ul>
<div class="packt_infobox">To identify the protocol, check the protocol number field against the IANA protocol numbers list at <a href="http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml"><span class="URLPACKT">http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml</span></a><span class="URLPACKT">.</span></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Updates</h1>
            </header>

            <article>
                
<p>You cannot update the configuration of an existing flow-log; you must delete it and recreate it if you want to change any settings associated. This is another reason why it is good to explicitly create and manage the associated log group.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Omissions</h1>
            </header>

            <article>
                
<p>Some traffic is not captured by the flow-logs service, as follows:</p>
<ul>
<li>Traffic to the Amazon DNS server (<kbd>x.x.x.2</kbd> in your allocated range)</li>
<li>Traffic for Amazon Windows license activation (obviously only applicable to Windows instances)</li>
<li>Traffic to and from the instance metadata service (that is, IP address <kbd>169.254.169.254</kbd>)</li>
<li>DHCP traffic</li>
<li>Traffic to the reserved VPC IP address for the default VPC router (<kbd>x.x.x.1</kbd> in your allocated range)</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<ul>
<li>The <em>Building a secure network</em> recipe</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </body></html>