- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Provisioning Infrastructure Using Infrastructure as Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously we covered CI/CD topics related to building, testing, packaging,
    and deploying applications. In this chapter, we will learn how to provision and
    configure the destination where deployment will be taking place using automation,
    the benefits of such a process, and a few tips and tricks while we’re at it. You
    will understand why this is important, and even required, in these times when
    we need to deliver fast and with quality.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will dive into this by covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding **Infrastructure as** **Code** (**IaC**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with **Azure Resource Manager** (**ARM**) **templates**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with **AWS CloudFormation**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with **Terraform**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take care of the technical requirements first.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on which section you are interested in completing in this chapter,
    you will need the following software installed on your workstation. You will find
    the code for this chapter in the GitHub repository at [https://github.com/PacktPublishing/Implementing-CI-CD-Using-Azure-Pipelines/tree/main/ch08](https://github.com/PacktPublishing/Implementing-CI-CD-Using-Azure-Pipelines/tree/main/ch08).
  prefs: []
  type: TYPE_NORMAL
- en: Installing Azure tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Azure CLI is a cross-platform command-line tool to connect to Microsoft
    Azure and execute commands to create, update, or destroy resources. Depending
    on the **operating system** (**OS**) of your workstation, you can choose the appropriate
    installation method at [https://learn.microsoft.com/en-us/cli/azure/install-azure-cli](https://learn.microsoft.com/en-us/cli/azure/install-azure-cli).
    Since the instructions for each OS are different, it’s up to you to complete the
    installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installed, run the `az version` command and you’ll see a response like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can choose any text editor you wish to work with. However, we recommend
    **Visual Studio Code** (**VS Code** for short), as it is one of the most popular
    editors in the community; it’s free and provides a large number of community-supported
    extensions for many programming languages and other tools, especially supporting
    **ARM templates**, **AWS CloudFormation**, and **Terraform**, as we will see in
    the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: To install VS Code, proceed to [https://code.visualstudio.com/](https://code.visualstudio.com/).
    From there, you will see options to install it based on your workstation’s OS.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you must install the ARM Tools VS Code extension from [https://marketplace.visualstudio.com/items?itemName=msazurermtools.azurerm-vscode-tools](https://marketplace.visualstudio.com/items?itemName=msazurermtools.azurerm-vscode-tools).
  prefs: []
  type: TYPE_NORMAL
- en: Installing AWS tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The AWS CLI is a cross-platform command-line tool to connect to **Amazon Web
    Services** (**AWS**) and execute commands to create, update, or destroy resources.
    Instructions to install it based on your OS can be found at [https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.xhtml](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installed, run the `aws --version` command in a shell and you’ll see a
    response like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, you must install the **AWS Toolkit** VS Code extension from[https://marketplace.visualstudio.com/items?itemName=AmazonWebServices.aws-toolkit-vscode](https://marketplace.visualstudio.com/items?itemName=AmazonWebServices.aws-toolkit-vscode).
  prefs: []
  type: TYPE_NORMAL
- en: Installing Terraform tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Terraform CLI is a cross-platform command-line tool to execute a variety
    of subcommands such as `plan`, `apply`, or `destroy`, which we will cover later
    in this chapter. You can install it using the instructions provided at [https://developer.hashicorp.com/terraform/tutorials/azure-get-started/install-cli#install-terraform](https://developer.hashicorp.com/terraform/tutorials/azure-get-started/install-cli#install-terraform).
    Once installed, run `terraform version` in a shell and you’ll see a response like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, you can install the HashiCorp Terraform VS Code extension from
    [https://marketplace.visualstudio.com/items?itemName=HashiCorp.terraform](https://marketplace.visualstudio.com/items?itemName=HashiCorp.terraform).
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Terraform Marketplace extension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Terraform Marketplace extension** for Azure DevOps must be installed.
    You can find it at [https://marketplace.visualstudio.com/items?itemName=ms-devlabs.custom-terraform-tasks](https://marketplace.visualstudio.com/items?itemName=ms-devlabs.custom-terraform-tasks).
  prefs: []
  type: TYPE_NORMAL
- en: Access to an Azure account
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You must have access to an Azure account to complete the steps in this chapter.
    If you don’t have one, you can create a free one at [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).
  prefs: []
  type: TYPE_NORMAL
- en: Access to an AWS account
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You must have access to an AWS account to complete the steps in this chapter.
    If you don’t have one, you can create a free one at [https://aws.amazon.com/free](https://aws.amazon.com/free).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have taken care of all the technical requirements, let’s walk through
    what it means to automate infrastructure using code.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding IaC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the past, infrastructure was typically provisioned and configured manually
    with manually documented steps and/or a combination of scripts. This made the
    whole process error-prone and slow.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way that you use a rigorous process for your application code, you
    should practice that for your infrastructure. The purpose of this approach is
    to make deployments repeatable and immutable, reduce the chances of error, and
    accelerate the deployment process by avoiding/eliminating any human interaction
    whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: IaC is the practice of codifying and storing in source control a descriptive
    model that defines and deploys all the infrastructure needed to run your applications
    and any supporting dependencies. It can encompass network configuration, load
    balancers, virtual machines, and any other application or data services your application
    architecture requires to operate and is applicable to on-premises data centers
    and cloud provider platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to picture all this working together is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – CI/CD incorporating IaC](img/B18875_08_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – CI/CD incorporating IaC
  prefs: []
  type: TYPE_NORMAL
- en: Let’s jump into working with ARM templates now and see how we can do this on
    the Microsoft Azure cloud platform.
  prefs: []
  type: TYPE_NORMAL
- en: Working with ARM templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ARM templates are one of the IaC options available to deploy infrastructure
    in Azure, Microsoft’s cloud platform available in many regions around the world.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft also provides other tools such as the Azure CLI, Azure PowerShell,
    and a newer, domain-specific language called Bicep that uses a declarative syntax
    to deploy resources. You can also use the Azure portal, a web-based UI that provides
    access to all your resources in Azure and the ability to create, update, and delete
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'ARM templates are JSON files with the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: ARM templates can define required and optional input **parameters**, **variables**
    that can be calculated for use within the template, user-defined **functions**
    that you can use within the template in addition to built-in ones, **resources**
    that define all properties to configure for one or more resources, and **outputs**
    that can contain properties or values calculated from the deployed resources.
    ARM templates can also be nested to logically separate your services.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will focus on how to deploy ARM templates using Azure Pipelines,
    without getting into the details of how to create them, as that is outside the
    scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deploying ARM templates comes down to the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a service principal in Azure
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a service connection to Azure
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating an ARM template
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Validating the ARM template
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploying the ARM template
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s start by creating a service principal in Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a service principal in Azure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **service principal** is a type of identity in Azure used by applications,
    services, and automation tools to provide fine-grained control to access resources
    and perform actions based on roles.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: This section assumes that you are logged in to Azure using the `az` `login`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a service principal with the following Azure CLI command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You would replace `<subscription-id>`, which should be a GUID-like value from
    the Azure portal. Setting the scope at the subscription level is fine for testing
    purposes, but in your ideal setup, you will want to restrict it further – say,
    to a resource group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you execute this command, you should get a response similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Service principal details](img/B18875_08_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Service principal details
  prefs: []
  type: TYPE_NORMAL
- en: You must handle the service principal details as a secret. This is sensitive
    information that provides access to your Azure environment. You will need this
    for the next steps.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s see how to create the service connection to Azure using the service
    principal.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a service connection to Azure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As seen in previous chapters, integrating with external services in Azure Pipelines
    requires a service connection. This can be done by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to **Project Settings** | **Pipelines** | **Service connections**,
    where you will click on the **New service** **connection** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.3 – New service connection](img/B18875_08_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – New service connection
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, you will select the **Azure Resource Manager** option and click
    the **Next** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Selecting the service connection type](img/B18875_08_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Selecting the service connection type
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, select an authentication method, using the **Service principal (manual)**
    option, and click the **Next** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Select an authentication method for the Azure service connection](img/B18875_08_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Select an authentication method for the Azure service connection
  prefs: []
  type: TYPE_NORMAL
- en: Although the preceding screenshot shows **Service principal (automatic)** as
    **Recommended**, this is only from the standpoint of a user just getting started
    with Azure and Azure Pipelines. When you have many Azure subscriptions and resource
    groups, that authentication method makes it difficult to complete the setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step allows you to enter the details for the following parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`appId` from the previous section, as shown in *Figure 8.2*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password` from the previous section, as shown in *Figure 8.2*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tenant` from the previous section, as shown in *Figure 8.2*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`azure-packt-rg`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have entered all these values, you have the option to click on the
    **Verify and save** button, which will test that a connection to Azure can be
    established and store the service connection details.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have a service connection, let’s move on to creating an ARM template.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an ARM template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many ways to create ARM templates:'
  prefs: []
  type: TYPE_NORMAL
- en: From scratch, by following the reference documentation at [https://learn.microsoft.com/en-us/azure/azure-resource-manager/templates/quickstart-create-templates-use-visual-studio-code](https://learn.microsoft.com/en-us/azure/azure-resource-manager/templates/quickstart-create-templates-use-visual-studio-code)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the Azure portal, by downloading a template before deployment from the
    Marketplace or an existing resource group, as described at [https://learn.microsoft.com/en-us/azure/azure-resource-manager/templates/export-template-portal](https://learn.microsoft.com/en-us/azure/azure-resource-manager/templates/export-template-portal)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying an existing sample template at [https://learn.microsoft.com/en-us/samples/browse/?expanded=azure&products=azure-resource-manager](https://learn.microsoft.com/en-us/samples/browse/?expanded=azure&products=azure-resource-manager)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, for simplicity, we will use a modified version of an existing
    sample that deploys an Azure App Service resource. You can find the template at
    [https://github.com/PacktPublishing/Implementing-CI-CD-Using-Azure-Pipelines/blob/main/ch08/azure/azuredeploy.json](https://github.com/PacktPublishing/Implementing-CI-CD-Using-Azure-Pipelines/blob/main/ch08/azure/azuredeploy.json)
  prefs: []
  type: TYPE_NORMAL
- en: 'This ARM template will deploy two resources:'
  prefs: []
  type: TYPE_NORMAL
- en: An **Azure App Service plan**, which defines the pricing tier, OS, and other
    platform-level capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **Azure App Service web app**, which defines the application-level stack,
    such as the PHP runtime and version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let’s see how we can validate this template using Azure Pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Validating the ARM template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In your build or CI pipelines, you should consider validating your templates
    to ensure the format is correct. For this purpose, the **ARM** template deployment
    task is available, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: YAML is a very strict language that is whitespace-sensitive and case-sensitive.
    When working with YAML files, make sure that you are using an editor that properly
    handles these requirements and make sure you are aware of any issues when formatting
    the content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break this down to the different parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`deploymentScope` dictates the layer to which this will be applied. Possible
    values are `Management Group`, `Resource Group`, and `Subscription`. These are
    different types of governance layers within the Azure platform and the templates
    follow different schemas.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`azureResourceManagerConnection` is a reference to an existing service connection
    of type `Azure` `Resource Manager`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscriptionId` is the GUID value for the Azure subscription ID. In this case,
    you can see it as being a reference from a variable using the `$(AzureSubscriptionId)`
    notation. We will see how to create this in the next section, *Creating a* *pipeline
    variable*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`action` indicates whether a resource group will be created, updated, or deleted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resourceGroupName` is the name of the resource group in the Azure target for
    the deployment. If the action is set to `create` or `update` and the resource
    group does not exist, it will be created by the task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`location` is any of the existing Azure regions available for deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`templateLocation` indicates whether the ARM template file will be available
    as `Linked artifact` or `URL of the file`. In the latter case, it must be a fully
    qualified URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`csmFile` is the path to the ARM template file, required when `templateLocation
    = ''Linked artifact''` is set. Otherwise, you would use `csmFileLink`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, `deploymentMode` indicates how to treat the deployment. In this case,
    the `Validation` value will only perform validation of the file format. We will
    talk about the other values this accepts in the next section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a pipeline variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create the variable used in this task, perform the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Variables** button on the Azure Pipelines edit screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Accessing pipeline variables](img/B18875_08_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – Accessing pipeline variables
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **New variable** button to define your first variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Adding a new variable](img/B18875_08_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – Adding a new variable
  prefs: []
  type: TYPE_NORMAL
- en: 'You then proceed to fill in `AzureSubscriptionId` and the subscription ID you
    obtained from the Azure portal, respectively. Also make sure to check the **Keep
    this value secret** option, to store it securely and make it impossible for it
    to be visible during pipeline execution. Clicking **OK** on this screen stores
    the value temporarily:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.8 – New variable with secret value](img/B18875_08_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – New variable with secret value
  prefs: []
  type: TYPE_NORMAL
- en: 'You must click **Save** on the next screen to ensure the variable is stored
    in the pipeline:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.9 – Saving pipeline variables](img/B18875_08_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – Saving pipeline variables
  prefs: []
  type: TYPE_NORMAL
- en: Once you have all of this in place, the pipeline should run and validate the
    ARM template successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'When deploying ARM templates for the first time, you must ensure that the corresponding
    Azure resource providers have been registered in the subscription or you will
    get an error. For the template used in this section, you must have the `Microsoft.Web`
    resource provider registered. You can accomplish this by running the following
    Azure CLI command and waiting for it to complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '`az provider register –namespace` `Microsoft.Web --wait`'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how to validate the template, let’s see how to deploy
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying ARM templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Switching from validation to deployment requires changing the value of the `deploymentMode`
    property to either `Incremental` or `Complete`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Incremental` deployment mode tells ARM that the resources in the template
    will be created if they don’t exist or updated to match the template if already
    present. Any other resources in the resource group not defined in the template
    will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, if the `Complete` deployment mode is used, ARM will ensure that the
    resource group only contains the resources defined in the template, create those
    that don’t exist, update the existing ones to match, and delete any not defined
    in the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The `Complete` deployment mode must be used with caution, and ensure you have
    a rigorous process where resources are only being created via templates. Otherwise,
    you could have destructive results that you were not expecting, such as services
    or applications not working anymore or loss of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the pipeline has been executed, you can validate the resources in the
    Azure portal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Azure resources deployed via Azure Pipelines](img/B18875_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – Azure resources deployed via Azure Pipelines
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more, head to [https://aka.ms/arm-syntax](https://aka.ms/arm-syntax).
    Now let’s see how we can do something similar in AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Working with AWS CloudFormation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**AWS Cloud Formation** is a service that allows you to define a template that
    describes a set of resources to be deployed together using JSON or YAML syntax.
    The templates follow this structure in the JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Deploying with AWS CloudFormation comes down to the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an IAM user with the AWS CLI
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a service connection to AWS
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating an AWS CloudFormation template
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Validating the AWS CloudFormation template
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploying the AWS CloudFormation template
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s start with discussing how to create an IAM user.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an IAM user with the AWS CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An **IAM user** is a user defined in the **Identity and Access Management**
    (**IAM**) service in AWS and provides fine-grained access control to create, update,
    or delete resources in AWS, but is also used to grant/deny permissions to interact
    with other services.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: This section assumes you have already configured your AWS credentials using
    the `aws` `configure` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'These commands will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a user group called `resources-admin`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach a security policy to the user group
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a user called `azure-pipelines`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `azure-pipelines` user to the `resources-admin` user group
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create access keys for the `azure-pipelines` user
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After executing these commands, you should have an output like that shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – AWS access keys for the azure-pipelines user](img/B18875_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – AWS access keys for the azure-pipelines user
  prefs: []
  type: TYPE_NORMAL
- en: The `AccessKeyId` and `SecretAccessKey` values will be needed in the next step.
    Make sure to save them in a secure place as they provide programmatic access to
    AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Important
  prefs: []
  type: TYPE_NORMAL
- en: The `arn:aws:iam::aws:policy/AdministratorAccess` policy used in this step is
    very permissive. It provides the highest level of access to the AWS console. This
    is not recommended for your environments. Instead, you should always provide access
    following a least-privilege approach and add more permissions when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now see how we create a service connection from Azure Pipelines to AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a service connection to AWS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As seen in previous chapters, integrating with external services in Azure Pipelines
    requires a service connection, which is done within **Project Settings** | **Pipelines**
    | **Service connections**, where you will click on the **New service connection**
    button and select the **AWS** option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12 – AWS service connection type](img/B18875_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – AWS service connection type
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step allows you to enter the following details:'
  prefs: []
  type: TYPE_NORMAL
- en: '`the AccessKeyId value` from the previous step'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`the SecretAccessKey value` from the previous step'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aws-packt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a service connection, let’s proceed to define the AWS CloudFormation
    template.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an AWS CloudFormation template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can create these templates from scratch following the reference documentation.
    Start from a sample template or use AWS CloudFormation Designer, a graphical tool
    that helps you create, visualize, and modify a template without worrying about
    all the formatting aspects. To learn more, go to [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-guide.xhtml](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-guide.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will use a modified version of an existing sample that
    deploys a virtual machine using the **Elastic Compute Cloud** (**EC2**) service.
    You can find the template at [https://github.com/PacktPublishing/Implementing-CI-CD-Using-Azure-Pipelines/blob/main/ch08/aws/template.json](https://github.com/PacktPublishing/Implementing-CI-CD-Using-Azure-Pipelines/blob/main/ch08/aws/template.json):'
  prefs: []
  type: TYPE_NORMAL
- en: An EC2 key pair – a set of security credentials used to connect to Linux instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An EC2 instance, which depends on the key pair and uses an Amazon Linux OS base
    image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let’s see how we can validate the template.
  prefs: []
  type: TYPE_NORMAL
- en: Validating the AWS CloudFormation template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In your build or CI pipelines, you should consider validating your templates
    to ensure the format is correct. For this purpose, the AWS CLI task is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down the parameters in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`awsCredentials` is a reference to the service connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regionName` is any of the available AWS Regions. Typically, you want to set
    this to the same region where the template would be deployed, to ensure it validates
    correctly based on the availability of services in that region.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`awsCommand` is the top-level command in the AWS CLI that provides AWS CloudFormation
    operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`awsSubcommand` indicates that you want to perform a template validation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`awsArguments` includes the options needed for the template validation to be
    completed. In this case, since the file was placed in the root folder of the repository,
    the template body is provided by passing the `file:` operator to read the contents
    of the file and perform the validation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once executed, the validation should show a message like that shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – AWS CloudFormation template successful validation](img/B18875_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 – AWS CloudFormation template successful validation
  prefs: []
  type: TYPE_NORMAL
- en: 'If there were an error, you would see a different message and task failure,
    as shown in the following screenshot, where a resource type was purposely mistyped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know how to validate the template, let’s see how to deploy it.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the AWS CloudFormation template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deploying the AWS CloudFormation template is known as creating an **AWS CloudFormation
    stack**, which is a service in AWS that allows you to group all resources in the
    template logically and has some additional benefits such as tracking drift, implementing
    a rollback strategy in case of errors, and the ability to delete the stack and
    all related resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Azure Pipelines, you have two options to deploy the template:'
  prefs: []
  type: TYPE_NORMAL
- en: An AWS CLI task with the `aws cloudformation` `create-stack` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the `Cloud Formation Create or Update Stack` task, as shown in this code
    block:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s break the preceding code down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`awsCredentials` is a reference to the service connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regionName` is any of the AWS regions available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stackName` is a name to identify this stack in the AWS console and must be
    unique.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`templateSource` in this case is `file`; however, it could also be a `url`
    to a template, perhaps outside of Azure Pipelines; `s3`, which refers to a storage
    service in AWS, and you would provide a bucket and object key; or `usePrevious`,
    which indicates you want to use the template in an existing stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`templateFile` is used to provide the location of the file with the template
    and is only needed because `file` has been set to `templateSource`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `capibilityIAM` and `capabilityNamedIAM` parameters are set to `false`.
    These are additional properties needed for some type of deployment where IAM changes
    would be applied. In the case of the template used in this example, they are not
    required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the `onFailure` property indicates what to do with the stack if something
    goes wrong. With the `DELETE` value, it would be deleted and any resources that
    might have been deployed successfully would be deleted as well. The `DO_NOTHING`
    value would simply stop applying the template and you would be able to see in
    the AWS console what had happened so far. Lastly, the `ROLLBACK` value, which
    is the default, would revert any changes made prior to applying the template.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the deployment completed successfully, you should be able to see the status
    in the AWS console, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – AWS CloudFormation stack deployed successfully](img/B18875_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.14 – AWS CloudFormation stack deployed successfully
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also be able to see the resources deployed as part of the CloudFormation
    stack, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15 – AWS CloudFormation stack resources](img/B18875_08_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.15 – AWS CloudFormation stack resources
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have learned about Azure and AWS cloud platform-specific IaC capabilities;
    however, these only work for each of these platforms. If you want to do IaC in
    a generic way and aim for multiple types of targets – say, on-premises and other
    cloud providers, there are other tools on the market that can accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: Some other IaC tools are Ansible, Chef, Pulumi, Puppet, SaltStack, and Terraform,
    to name a few. In this chapter, we will focus on **Terraform** because it is one
    of the most popular choices among the open source community due to its versatility
    and declarative nature. Let’s next learn how to use Terraform for IaC.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s first learn about how Terraform works and then we will walk through using
    it within Azure Pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: How does Terraform work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Terraform is a tool that allows you to write IaC and define resources for both
    cloud and on-premises resources using a domain-specific language. It uses providers
    as a means to encapsulate the resource definition for supported targets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts the high-level architecture of Terraform:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.16 – Terraform architecture](img/B18875_08_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.16 – Terraform architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'It works by way of the following three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Write**: You define the resources in templates to deploy all the resources
    you need, across the targets required. There could be more than one.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Plan**: Terraform creates an execution plan to determine the changes that
    need to be made to match the definition, calculating the sequential order of operations
    and understanding any resource dependencies. This could mean creating resources,
    updating them, or destroying them.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Apply**: Once you agree with the plan, Terraform performs the necessary operations
    in the sequence calculated by the plan.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Part of the process Terraform follows involves calculating the state of the
    target in comparison to the plan. This is called the **Terraform state file**.
    This file will contain details about the resources, their metadata in the target
    destination, and their dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the edition of Terraform you are using, you might be responsible
    for managing the location of this file or use built-in features to manage the
    state file for you.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the location of the state file is critical in Terraform. It can be
    stored locally or remotely via a **backend** configuration. When you are getting
    started, you will likely use the **local backend**; however, as you evolve your
    configuration to support multiple environments, you will switch to a **remote
    backend**. To read more about remote backends, go to [https://developer.hashicorp.com/terraform/language/settings/backends/remote](https://developer.hashicorp.com/terraform/language/settings/backends/remote).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Terraform works in absolutes, meaning it expects to control every resource defined
    in the templates you create by comparing them with the current state file every
    time. This means that no changes should be made without the use of Terraform in
    the environment. Otherwise, these changes will be lost the next time you run the
    `terraform` `apply` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Terraform comes in three editions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Open source**: Free, downloadable, and flexible to use with your existing
    source control and CI/CD tools'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cloud**: A SaaS application that allows you to run it in a stable and remote
    environment, with secure storage of the state files and secrets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enterprise**: Allows you to set up a private Terraform Cloud instance or
    self-hosted distribution with customizable resource limits and tighten security.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s now look at how to create a simple Terraform template.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Terraform template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Terraform templates are usually written in what is called configuration syntax,
    which is a pseudo-JSON format. All files have the `.tf` extension and typically
    you will have the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`providers.tf`: Defines the base configuration and providers to use'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main.tf`: The entry point of your template – say, your starting point'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`variables.tf`: Defines values to be used throughout the templates that can
    be overridden when planning/applying the configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outputs.tf`: Values to extract from the resources deployed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will use a simple set of templates targeting the Azure cloud
    platform, creating a resource group, and using the `azurerm` backend. See the
    templates at [https://github.com/PacktPublishing/Implementing-CI-CD-Using-Azure-Pipelines/tree/main/ch08/terraform](https://github.com/PacktPublishing/Implementing-CI-CD-Using-Azure-Pipelines/tree/main/ch08/terraform).
  prefs: []
  type: TYPE_NORMAL
- en: For more details on the Terraform configuration language, head to [https://developer.hashicorp.com/terraform/language](https://developer.hashicorp.com/terraform/language).
    For tutorials and training material, head to [https://developer.hashicorp.com/tutorials/library?product=terraform](https://developer.hashicorp.com/tutorials/library?product=terraform).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned the Terraform basics for creating templates, let’s
    put together a pipeline to validate them.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the Terraform state file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can put together a build pipeline, we need to ensure that the **state
    file** is managed accordingly – in this case, remotely. Since our template will
    target Azure, we will need to set up the corresponding backend for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, you can execute the following Azure CLI commands, once logged in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'These commands perform the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a resource group in Azure named `tfstate` in the `eastus` region
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a storage account in Azure named `tfstate` in the `tfstate` resource
    group in the `eastus` region with the `Standard_LRS` pricing tier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a blob container named `tfstate` in the `tfstate` storage account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important
  prefs: []
  type: TYPE_NORMAL
- en: The storage account name in the previous commands must be unique globally, so
    you will have to adjust the name in these commands and any following sections
    for everything to work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have set up the state file management, let’s put together a pipeline
    to validate the template.
  prefs: []
  type: TYPE_NORMAL
- en: Validating a Terraform template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In your build or CI pipelines, you should consider validating your templates
    to ensure the format is correct. For this purpose, tasks are available in the
    Terraform Marketplace extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s break this code down:'
  prefs: []
  type: TYPE_NORMAL
- en: The `TerraformInstaller@0` task installs the Terraform CLI in the agent if necessary.
    This is required if you need to ensure a specific version of the tool is required
    for your templates. Microsoft-hosted agents typically have a version of Terraform
    installed, but if you want to use an older or newer version, this task will allow
    you to use the version of Terraform that you need.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `TerraformTask@4` task allows you to run any of the Terraform CLI commands.
    For the first task with `displayName: init`, it will correspondingly execute the
    `terraform init` command with the following parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`backendServiceArm` indicating the name of the ARM service connection to use'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`backendAzureRmResourceGroupName` indicating the resource group in Azure where
    the state file will be stored'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`backendAzureRmStorageAccountName` with the name of the Azure storage account
    where the state file will be stored'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`backendAzureRmContainerName` with the blob container name in the Azure storage
    account where the state file will be stored'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`backendAzureRmKey` indicating the name of the state file'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, the last task with `displayName: validate` will execute the `terraform`
    `validate` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the pipeline runs, the validation should complete successfully and you
    should see a message similar to the following for the validation task:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.17 – Successful Terraform template validation](img/B18875_08_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.17 – Successful Terraform template validation
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve learned how to validate the template, let’s proceed to deploy
    resources with Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a Terraform template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned previously, deploying resources with Terraform is a two-step process,
    requiring you to execute the `plan` and `apply` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break this code down:'
  prefs: []
  type: TYPE_NORMAL
- en: The `TerraformInstaller@0` task installs the Terraform CLI in the agent if necessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `TerraformTask@4` task with `displayName: init` initializes Terraform as
    explained in the previous section'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `TerraformTask@4` task with `displayName: plan` executes the `terraform
    plan` command, performing the comparison necessary and updating the state file
    accordingly with changes to be made'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `TerraformTask@4` task with `displayName: apply` executes the `terraform
    apply` command and performs the changes necessary in Azure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We covered a lot of ground in this chapter. Let’s finish off with a summary
    of what we learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about different tools available to create, update,
    and delete resources on the Microsoft Azure and AWS cloud platforms.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to create, validate, and deploy ARM templates, the role of service
    principals in Azure, and the security considerations of deploying with automation.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about AWS CloudFormation templates and stacks, and how to create
    them and update them from Azure Pipelines. At the same time, we learned how AWS
    has a similar security model to Azure and about the security implications of credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned about Terraform as an abstraction language to define IaC
    for on-premises and cloud platforms such as Azure and AWS, and how to validate
    templates in Azure Pipelines and deploy resources with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of which IaC tool you choose to use, they are important because
    they will allow you to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Have a repeatable and immutable process for deployments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accelerate deployments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce or eliminate errors while deploying with Azure Pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recover from issues easily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spend more time working on your application code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will be putting everything we have learned together
    for end-to-end pipeline building and packaging applications to deploy them on
    different Microsoft Azure cloud platform services.
  prefs: []
  type: TYPE_NORMAL
- en: Part 3:CI/CD for Real-World Scenarios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, in the last part of this book, we will compile everything we’ve learned
    so far to create end-to-end scenarios typically found in the real world, using
    cloud platforms, and we will walk through some best practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B18875_09.xhtml#_idTextAnchor135), *Implementing CI/CD for Azure
    Services*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B18875_10.xhtml#_idTextAnchor153), *Implementing CI/CD for AWS*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B18875_11.xhtml#_idTextAnchor168), *Automating CI/CD for Cross-Mobile
    Applications by Using Flutter*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B18875_12.xhtml#_idTextAnchor181), *Navigating Common Pitfalls
    and Future Trends in Azure Pipelines*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
