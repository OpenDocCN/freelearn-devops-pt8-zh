<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Separation of Code and Data with Hiera</h1>
                </header>
            
            <article>
                
<p>Working through the first seven chapters, you have used the basic structural elements of Puppet in numerous examples and contexts. There has been a quick demonstration of the more advanced language features, and you should have a good idea of what distinguishes the manifest writing process in Puppet 4 from those of the earlier releases.</p>
<p>For all their expressive power, manifests do have some limitations. A manifest that is designed by the principles taught up to this point mixes logic with data. Logic is not only evident in control structures, such as <kbd>if</kbd> and <kbd>else</kbd>, but it also emerges from the network of classes and defines that include and instantiate one another.</p>
<p>However, you cannot configure a machine by just including some generic classes. Many properties of a given system are individual and must be passed as parameters. This can have maintenance implications for a manifest that must accommodate a large number of nodes. This chapter will teach you how to bring order back to such complex code bases. In this chapter, we will cover the following topics:</p>
<ul>
<li>Understanding the need for separate data storage</li>
<li>Building hierarchical data structures</li>
<li>Fetching data from classes</li>
<li>Debugging data lookups</li>
<li>Managing resources from data</li>
<li>Data in modules and environments</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the need for separate data storage</h1>
                </header>
            
            <article>
                
<p>Looking back at what you have implemented during this book so far, you have managed to create some very versatile code that did very useful things in an automatic fashion. Your nodes can distribute entries for <kbd>/etc/hosts</kbd> among themselves. They register each other's public SSH key for authentication. A node can automatically register itself to a central Cacti server.</p>
<p>Thanks to Facter, Puppet has the information that allows the effortless handling of these use cases. Many configuration items are unique to each node only because they refer to a detail (such as an IP address or a generated key) that is already defined. Sometimes, the required configuration data can only be found on a remote machine, which Puppet handles through exported resources. Such manifest designs that can rely on facts are very economical. The information has already been gathered, and a single class can most likely behave correctly for many or all of your nodes, and can manage a common task in a graceful manner.</p>
<p>However, some configuration tasks have to be performed individually for each node, and these can incorporate settings that are rather arbitrary and not directly derived from the node's existing properties:</p>
<ul>
<li>In a complex MySQL replication setup that spans multiple servers, each participant requires a unique server ID. Duplicates must be prevented under any circumstances, so randomly generating the ID numbers is not safe</li>
<li>Some of your networks might require regular maintenance jobs to be run from <kbd>cron</kbd>. Puppet should define a starting time for each machine to prevent the overlapping of the runs on any two machines</li>
<li>In server operations, you have to perform the monitoring of the disk space usage on all systems. Most disks should generate early warnings so that there is time to react. However, other disks will be expected to be almost full most of the time, and should have a much higher warning threshold</li>
</ul>
<p>When custom-built systems and software are managed through Puppet, they are also likely to require this type of micromanagement for each instance. The examples here represent only a tiny slice of the things that Puppet must manage explicitly and independently.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Consequences of defining data in the manifest</h1>
                </header>
            
            <article>
                
<p>There are a number of ways in which a Puppet manifest can approach this problem of micromanagement. The most direct way is to define whole sets of classes one for each individual node:</p>
<pre>class site::mysql_server01 { 
  class { 'mysql': server_id =&gt; '1', ... } 
} 
class site::mysql_server02 { 
  class { 'mysql': server_id =&gt; '2', ... } 
} 
...  
class site::mysql_aux01 { 
  class { 'mysql': server_id =&gt; '101', ... } 
} 
# and so forth ... </pre>
<p>This is a very high-maintenance solution for the following reasons:</p>
<ul>
<li>The individual classes can become quite elaborate because all required <kbd>mysql</kbd> class parameters have to be used in each one</li>
<li>There is much redundancy among the parameters that are, in fact, identical across all nodes</li>
<li>The individually different values can be hard to spot, and must be carefully kept unique throughout the whole collection of classes</li>
<li>This is only really feasible by keeping these classes close together, which might conflict with other organizational principles of your code base</li>
</ul>
<p>In short, this is a brute-force approach that introduces its own share of cost. A more economic approach would be to pass the values that are different among nodes (and only those!) to a wrapper class:</p>
<pre>node 'xndp12-sql09.example.net' { 
  class { 'site::mysql_server': 
    mysql_server_id =&gt; '103', 
  } 
} </pre>
<p>This wrapper can declare the <kbd>mysql</kbd> class in a generic fashion, thanks to the individual parameter value per node:</p>
<pre>class site::mysql_server( 
  String $mysql_server_id 
) { 
  class { 'mysql':  
    server_id =&gt; $mysql_server_id,  
    ... 
  } 
} </pre>
<p>This is much better because it eliminates the redundancy and its impact on maintainability. The wrinkle is that the <kbd>node</kbd> blocks can become quite messy with parameter assignments for many different subsystems. Explanatory comments contribute to the wall of text that each <kbd>node</kbd> block can become.</p>
<p>You can take this a step further by defining lookup tables in hash variables,<br/>
outside of any <kbd>node</kbd> or <kbd>class</kbd>, on the global scope:</p>
<pre>$mysql_config_table = { 
  'xndp12-sql01.example.net' =&gt; { 
    server_id   =&gt; '1', 
    buffer_pool =&gt; '12G', 
  }, 
  ... 
} </pre>
<p>This alleviates the need to declare any variables in <kbd>node</kbd> blocks. The classes look up the values directly from the hash:</p>
<pre>class site::mysql_server( 
  $config = $mysql_config_table[$::certname] 
) { 
  class { 'mysql': 
    server_id =&gt; $config['server_id'],  
    ... 
  } 
} </pre>
<p>This is pretty sophisticated, and is actually close to the even better way that you will learn about later in this chapter. Note that this approach still retains a leftover possibility of redundancy. Some configuration values are likely to be identical among all nodes that belong to one group, but are unique to each group (for example, preshared keys of any variety).</p>
<p>This requires that all servers in the hypothetical <kbd>xndp12</kbd> cluster contain some key-value pairs that are identical for all members:</p>
<pre>$crypt_key_xndp12 = 'xneFGl%23ndfAWLN34a0t9w30.zges4'<br/>$config = {<br/>'xndp12-stor01.example.net' =&gt; { $crypt_key =&gt;<br/>  $crypt_key_xndp12, … },<br/>'xndp12-stor02.example.net' =&gt; { $crypt_key =&gt;<br/>  $crypt_key_xndp12, … },<br/> 'xndp12-sql01.example.net' =&gt; { $crypt_key =&gt;<br/>  $crypt_key_xndp12, … },<br/>...<br/>}</pre>
<p>This is not ideal, but let's stop here. There is no point in worrying about even more elaborate ways to sort configuration data into recursive hash structures. Such solutions will quickly grow very difficult to understand and maintain anyway. The silver bullet is an external database that holds all individual and shared values. Before I go into the details of using Hiera for just this purpose, let's discuss the general ideas of hierarchical data storage.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building hierarchical data structures</h1>
                </header>
            
            <article>
                
<p>In the previous section, we reduced the data problem to a simple need for key-value pairs that are specific to each node under Puppet management. Puppet and its manifests then serve as the engine that generates actual configuration from these minimalistic bits of information.</p>
<p>A simplistic approach to this problem is an <kbd>ini</kbd> style configuration file that has a section for each node that sets values for all configurable keys. Shared values will be declared in one or more general sections:</p>
<pre>[mysql]<br/>buffer_pool=15G<br/>log_file_size=500M<br/>...<br/>[xndp12-sql01.example.net]<br/>psk=xneFGl%23ndfAWLN34a0t9w30.zges4<br/>server_id=1</pre>
<p>Rails applications customarily do something similar and store their configuration in a YAML format. The user can define different environments, such as <kbd>production</kbd>, <kbd>staging</kbd>, and <kbd>testing</kbd>. The values that are defined per environment override the global setting values.</p>
<p>This is quite close to the type of hierarchical configuration that Puppet allows through its Hiera binding. The hierarchies that the aforementioned Rails applications and <kbd>ini</kbd> files achieve through configuration environments are quite flat there is a global layer and an overlay for specialized configuration. With Hiera and Puppet, a single configuration database will typically handle whole clusters of machines and entire networks of such clusters. This implies the need for a more elaborate hierarchy.</p>
<p>Hiera allows you to define your own hierarchical layers. There are some typical, proven examples, which are found in many configurations out there:</p>
<ul>
<li>The <kbd>common</kbd> layer holds default values for all agents</li>
<li>A <kbd>location</kbd> layer can override some values in accordance with the data center that houses each respective node</li>
<li>Each agent machine typically fills a distinct <kbd>role</kbd> in your infrastructure, such as <kbd>wordpress_appserver</kbd> or <kbd>puppetdb_server</kbd></li>
<li>Some configurations are specific to each single <kbd>machine</kbd></li>
</ul>
<p>For example, consider the configuration of a hypothetical reporting client. Your <kbd>common</kbd> layer will hold lots of presets, such as default verbosity settings, the transport compression option, and other choices that should work for most machines. On the <kbd>location</kbd> layer, you ensure that each machine checks in to the respective local server reporting should not use WAN resources.</p>
<p>Settings per role are perhaps the most interesting part. They allow fine-grained settings that are specific to a class of servers. Perhaps your application servers should monitor their memory consumption in very close intervals. For the database servers, you will want a closer view of hard drive operations and performance. For your Puppet servers, there might be special plugins that gather specific data.</p>
<p>The <kbd>machine</kbd> layer is very useful in declaring any exceptions to the rule. There are always some machines that require special treatment for one reason or another. With a top hierarchy layer that holds data for each single agent, you get full control over all the data that an agent uses.</p>
<p>These ideas are still quite abstract, so let's finally look at the actual application of Hiera.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring Hiera</h1>
                </header>
            
            <article>
                
<p>The support for retrieving data values from Hiera has been built into Puppet since version 3. All you need in order to get started is a <kbd>hiera.yaml</kbd> file in the configuration directory.</p>
<p>Of course, the location and name of the configuration is customizable, as is almost everything that is related to configuration. Look for the <kbd>hiera_config</kbd> setting.</p>
<p>As the filename extension suggests, the configuration is in the YAML format and contains a hash with keys for the backends, the hierarchy, and backend-specific settings. The keys are noted as Ruby symbols with a leading colon:</p>
<pre># /etc/puppetlabs/puppet/hiera.yaml<br/>:backends:<br/>  - yaml<br/>:hierarchy: <br/>  - node/%{::clientcert}<br/>  - role/%{::role}<br/>  - location/%{::datacenter}<br/>  - common<br/>:yaml: <br/>  :datadir: /etc/puppetlabs/code/environments/%{::environment}/hieradata</pre>
<p>Note that the value of <kbd>:backends</kbd> is actually a single-element array. You can pick multiple backends. The significance will be explained later. The <kbd>:hierarchy</kbd> value contains a list of the actual layers that were described earlier. Each entry is the name of a data source. When Hiera retrieves a value, it searches each data source in turn. The <kbd>%{}</kbd> expression allows you to access the values of Puppet variables. Use only facts or global scope variables here; anything else will make Hiera's behavior quite confusing.</p>
<p>Finally, you will need to include configurations for each of your backends. The preceding configuration uses the YAML backend only, so there is only a hash for <kbd>:yaml</kbd> with the one supported <kbd>:datadir</kbd> key. This is where Hiera will expect to find YAML files with data. For each data source, the <kbd>datadir</kbd> can contain one <kbd>.yaml</kbd> file. As the names of the sources are dynamic, you will typically create more than four or five data source files. Let's create some examples before we have a short discussion on the combination of multiple backends.</p>
<div class="packt_tip">Hiera version 5 was released with Puppet 4.9. This new version of Hiera uses another layout of the configuration file and offers more flexibility. We will first introduce Hiera 3, prior to explaining the setup, migration, and additional features of Hiera 5, as most of the basic concepts are identical.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Storing Hiera data</h1>
                </header>
            
            <article>
                
<p>The backend of your Hiera setup determines how you have to store your configuration values. For the YAML backend, you fill <kbd>datadir</kbd> with files that each hold a hash of values. Let's put some elements of the reporting engine configuration into the example hierarchy:</p>
<pre># /etc/puppetlabs/code/environments/production/hieradata/common.yaml<br/>reporting::server: stats01.example.net<br/>reporting::server_port: 9033</pre>
<p>The values in <kbd>common.yaml</kbd> are defaults that are used for all agents. They are at the broad base of the hierarchy. Values that are specific to a <kbd>location</kbd> or <kbd>role</kbd> apply to smaller groups of your agents. For example, the database servers of the <kbd>postgres</kbd> role should run some special reporting plugins:</p>
<pre># /etc/puppetlabs/code/environments/production/hieradata/role/postgres.yaml 
reporting::plugins: 
  - iops 
  - cpuload </pre>
<p>On such a high layer, you can also override the values from the lower layers. For example, a role-specific data source, such as <kbd>role/postgres.yaml</kbd>, can set a value for <kbd>reporting::server_port</kbd> as well. The layers are searched from the most to the least specific, and the first value is used. This is why it is a good idea to have a node-specific data source at the top of the hierarchy. On this layer, you can override any value for each agent. In this example, the reporting node can use the loopback interface to reach itself:</p>
<pre>#/etc/puppetlabs/.../hieradata/node/stats01.example.net.yaml 
reporting::server: localhost </pre>
<p>Each agent receives a patchwork of configuration values according to the concrete YAML files that make up its specific hierarchy.</p>
<p>Don't worry if all this feels a bit overwhelming; there are more examples in this chapter. Hiera also has the charming characteristic of seeming rather complicated on paper, but it feels very natural and intuitive once you try using it yourself.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Choosing your backends</h1>
                </header>
            
            <article>
                
<p>There are two built-in backends: YAML and JSON. This chapter will focus on YAML, because it's a very convenient and efficient form of data notation. The JSON backend is very similar to YAML. It looks for data in <kbd>.json</kbd> files instead of <kbd>.yaml</kbd> for each data source; these files use a different data notation format.</p>
<p>The use of multiple backends should never be truly necessary. In most cases, a well thought-out hierarchy will suffice for your needs. With a second backend, data lookup will traverse your hierarchy once per backend. This means that the lowest level of your primary backend will rank higher than any layer from additional backends.</p>
<p>In some cases, it might be worthwhile to add another backend just to get the ability to define even more basic defaults in an alternative location perhaps a distributed filesystem or a source control repository with different commit privileges.</p>
<p>Also, note that you can add custom backends to Hiera, so these might also be sensible choices for secondary or even tertiary backends. A Hiera backend is written in Ruby, like the Puppet plugins. The details of creating such a backend are beyond the scope of this book.</p>
<p>A particularly popular backend plugin is <kbd>eyaml</kbd>, available through the <kbd>hiera-eyaml</kbd> Ruby gem. This backend allows you to incorporate encrypted strings in your YAML data. Puppet decrypts the data upon retrieval.</p>
<div class="packt_infobox">With Puppet 5, the eyaml plugin is already part of the Puppet build OS packages.</div>
<p>You have studied the theory of storing data in Hiera at length, so it's finally time to see how to make use of this in Puppet.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fetching data from classes</h1>
                </header>
            
            <article>
                
<p>Looking up a key value in Hiera is easy. Puppet comes with a very straightforward function for this:</p>
<pre>$plugins = hiera('reporting::plugins') </pre>
<p>Whenever the compiler encounters such a call in the manifest of the current agent node, it triggers a search in the hierarchy. The specific data sources are determined by the hierarchy in your <kbd>hiera.yaml</kbd> file. It will almost always rely on fact values provided by the agent to make flexible data source selections.</p>
<p>If the named key cannot be found in the agent's hierarchy, the master aborts the catalog compilation with an error. To prevent this, it is often sensible to supply a default value with the lookup:</p>
<pre>$plugins = hiera('reporting::plugins', []) </pre>
<p>In this case, Puppet uses an empty array if the hierarchy mentions no plugins.</p>
<p>On the other hand, you can purposefully omit the default value. Just as with <kbd>class</kbd> and <kbd>define</kbd> parameters, this signals that the Hiera value is required. If the user fails to supply it, Puppet will abort the manifest compilation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with simple values</h1>
                </header>
            
            <article>
                
<p>You have seen how to invoke the <kbd>hiera</kbd> function for value retrieval. There is really not more to it than what you have seen in the previous section, except for an optional parameter. It allows you to include an additional layer at the top of your hierarchy. If the key is found in the named data source, it will override the result from the regular hierarchy:</p>
<pre>$plugins = hiera('reporting::plugins', [], 'global-overrides') </pre>
<p>If the <kbd>reporting::plugins</kbd> key is found in the <kbd>global-overrides</kbd> data source, the value is taken from there. Otherwise, the normal hierarchy is searched.</p>
<p>Generally, assigning the retrieved value to a manifest variable is quite common. However, you can also invoke the <kbd>hiera</kbd> function in other useful contexts, such as the following:</p>
<pre>@@cacti_device { $::fqdn: 
  ip =&gt; hiera('snmp_address', $::ipaddress), 
} </pre>
<p>The lookup result can be handed to a resource directly as a parameter value. This is an example of how to allow Hiera to define a specific IP address per machine that should be used for a specific service. It acts as a simple way to manually override Facter's assumptions.</p>
<p>It is generally safer to store Hiera lookup results in a variable first. This allows you to check their data type. In Puppet 3, you need to use an <kbd>assert</kbd> function from the <kbd>stdlib</kbd> module. Puppet 4 has an operator for this purpose:</p>
<pre>$max_threads = hiera('max_threads') 
if $max_threads !~ Integer { 
    fail "The max_threads value must be an integer number" 
}</pre>
<p>Another frequent occurrence is a parameter default that is made dynamic through a Hiera lookup:</p>
<pre>define logrotate::config( 
  Integer $rotations = hiera('logrotate::rotations', 7) 
) { 
  # regular define code here 
} </pre>
<p>For <kbd>logrotate::config</kbd> resources that are declared with an explicit parameter value, the Hiera value is ignored:</p>
<pre>logrotate::config { '/var/log/cacti.log': rotations =&gt; 12 } </pre>
<p>This can be a little confusing. Still, the pattern adds some convenience. Most agents can rely on the default. The hierarchy allows you to tune this default on multiple levels of granularity.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Binding class parameter values automatically</h1>
                </header>
            
            <article>
                
<p>The concept of parameterized classes might have gotten a somewhat tarnished reputation, judging from our coverage of it so far. It allegedly makes it difficult to include classes from multiple places in the manifest, or silently allows it under shifting circumstances. While that is <kbd>true</kbd>, you can avoid these issues by relying on Hiera for your class parameterization needs.</p>
<p>Since Puppet's version 3.2, it has been possible to choose the values for any<br/>
class's parameters right in the Hiera data. Whenever you include a class that has any parameters, Puppet will query Hiera to find a value for each of them. The keys must be named after the class and parameter names, joined by a double colon. Remember the <kbd>cacti</kbd> class from <a href="3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a><a href="3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml"/>, <em>Combining Classes, Configuration Files, and Extensions into Modules.</em> It had a <kbd>$redirect</kbd> parameter. To define its value in Hiera, add the <kbd>cacti::redirect</kbd> key:</p>
<pre># node/cacti01.example.net.yaml 
cacti::redirect: false </pre>
<p>Some classes have very elaborate interfaces the <kbd>apache</kbd> class from the Puppet Labs Apache module accepts 70 parameters at the time of writing this. If you need many of those, you can put them into the target machine's dedicated YAML file as one coherent block of keys with values. It will be quite readable because the <kbd>apache::</kbd> prefixes line up.</p>
<p>You don't save any lines compared to specifying the parameters right in the manifest, but at least the wall of options will not get in your way while you're programming in your manifests, you separated data from code.</p>
<p>The point that is perhaps the most redeeming for class parameterization is that each key is independent in your hierarchy. Many parameters can most likely be defined for many or all of your machines. Clusters of application servers can share some settings (if your hierarchy includes a layer on which they are grouped together), and you can override parameters for single machines as you see fit:</p>
<pre># common.yaml 
apache::default_ssl_cert: /etc/puppetlabs/puppet/ssl/certs/%{::clientcert}.pem 
apache::default_ssl_key: /etc/puppetlabs/puppet/ssl/private_keys/%{::clientcert}.pem 
apache::purge_configs: false </pre>
<p>The preceding example prepares your site to use the Puppet certificates for HTTPS. This is a good choice for internal services, because trust to the Puppet CA can be easily established, and the certificates are available on all agent machines. The third parameter, <kbd>purge_configs</kbd>, prevents the module from obliterating any existing Apache configuration that is not under Puppet's management.</p>
<p>Let's see an example of a more specific hierarchy layer that overrides this setting:</p>
<pre># role/httpsec.yaml 
apache::purge_configs: true 
apache::server_tokens: Minimal 
apache::server_signature: off 
apache::trace_enable: off </pre>
<p>On machines that have the <kbd>httpsec</kbd> role, the Apache configuration should be purged so that it matches the managed configuration completely. The hierarchy of such machines also defines some additional values that are not defined in the <kbd>common</kbd> layer. The SSL settings from <kbd>common</kbd> remain untouched.</p>
<p>A specific machine's YAML can override keys from either layer if need be:</p>
<pre># node/sec02-sxf12.yaml 
apache::default_ssl_cert: /opt/ssl/custom.pem 
apache::default_ssl_key: /opt/ssl/custom.key 
apache::trace_enable: extended </pre>
<p>All these settings require no additional work. They take effect automatically, provided that the <kbd>apache</kbd> class from the <kbd>puppetlabs-apache</kbd> module is included.</p>
<p>For some users, this might be the only way in which Hiera is employed on their master, which is perfectly valid. You can even design your manifests specifically to expose all configurable items as class parameters. However, keep in mind that another advantage of Hiera is that any value can be retrieved from many different places in your manifest.</p>
<p>For example, if your firewalled servers are reachable through dedicated NAT ports, you will want to add those ports to each machine's Hiera data. The manifest can export this value not only to the firewall server itself, but also to external servers that use it in scripts and configurations to reach the exporting machine:</p>
<pre>$nat_port = hiera('site::net::nat_port') 
@@firewall { "650 forward port ${nat_port} to ${::fqdn}": 
  proto       =&gt; 'tcp', 
  dport       =&gt; $nat_port,  
  destination =&gt; hiera('site::net::nat_ip'), 
  jump        =&gt; 'DNAT', 
  todest      =&gt; $::ipaddress, 
  tag         =&gt; hiera('site::net::firewall_segment'), 
}<strong> </strong></pre>
<p>The values will most likely be defined on different hierarchical layers. <kbd>nat_port</kbd> is agent-specific and can only be defined in the <kbd>%{::fqdn}</kbd> (or <kbd>%{::clientcert}</kbd> for better security) derived data source. <kbd>nat_ip</kbd> will probably be identical for all servers in the same cluster. They might share a server role. <kbd>firewall_segment</kbd> could well be identical for all servers that share the same location:</p>
<pre># stor03.example.net.yaml 
site::net::nat_port: 12020 
... 
# role/storage.yaml 
site::net::nat_ip: 198.58.119.126 
... 
# location/portland.yaml 
site::net::firewall_segment: segment04 
... </pre>
<p>As previously mentioned, some of this data will be helpful in other contexts as well. Assume that you deploy a script through a defined type. The script sends messages to remote machines. The destination address and port are passed to the defined type as parameters. Each node that should be targeted can export this script resource:</p>
<pre>@@site::maintenance_script {"/usr/local/bin/maint-${::fqdn}": 
  address =&gt; hiera('site::net::nat_ip'), 
  port    =&gt; hiera('site::net::nat_port'), 
}<strong> </strong></pre>
<p>It would be impractical to do all this in one class that takes the port and address as parameters. You would want to retrieve the same value from within different classes or even modules, each taking care of the respective exports.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling hashes and arrays</h1>
                </header>
            
            <article>
                
<p>Some examples in this chapter defined array values in Hiera. The good news is that retrieving arrays and hashes from Hiera is not at all different from retrieving simple strings, numbers, or Boolean values. The <kbd>hiera</kbd> function will return all these values, which are ready for use in the manifest.</p>
<p>There are two more functions that offer special handling for such values; the <kbd>hiera_array</kbd> and <kbd>hiera_hash</kbd> functions.</p>
<p>The presence of these functions can be somewhat confusing. New users might assume that these are required whenever retrieving hashes or arrays from the hierarchy. When inheriting Puppet code, it can be a good idea to double-check that these derived functions are actually used correctly in a given context.</p>
<p>When the <kbd>hiera_array</kbd> function is invoked, it gathers all named values from the whole hierarchy and merges them into one long array that comprises all elements that were found. Take the example of the distributed firewall configuration once more. Each node should be able to export a list of rules that open ports for public access. The manifest for this would be completely driven by Hiera:</p>
<pre>if hiera('site::net::nat_ip', false) { 
  @@firewall { "200 NAT ports for ${::fqdn}": 
    port        =&gt; hiera_array('site::net::nat_ports'), 
    proto       =&gt; 'tcp', 
    destination =&gt; hiera('site::net::nat_ip'), 
    jump        =&gt; 'DNAT', 
    todest      =&gt; $::ipaddress, 
  } 
} </pre>
<p>Please note that the title <kbd>200 NAT ports</kbd> does not allude to the number of ports, but just adheres to the naming conventions for <kbd>firewall</kbd> resources. The numeric prefix makes it easy to maintain order. Also, note the seemingly nonsensical default value of <kbd>false</kbd> for the <kbd>site::net::nat_ip</kbd> key in the <kbd>if</kbd> clause. This forms a useful pattern, though the resource should only be exported if <kbd>public_ip</kbd> is defined for the respective node.</p>
<p>Care must be taken if <kbd>false</kbd> or the empty string is a conceivable value for the key in question. In this case, the <kbd>if</kbd> clause will ignore that value. In such cases, you should use a well-defined comparison instead:</p>
<pre>if hiera('feature_flag_A', undef) != undef { ... }</pre>
<p>The hierarchy can then hold ports on several layers:</p>
<pre># common.yaml 
nat_ports: 22 </pre>
<p>The SSH port should be available for all nodes that get a public address. Note that this value is not an array itself. This is fine Hiera will include scalar values in the resulting list without any complaints:</p>
<pre># role-webserver.yaml 
nat_ports: [ 80, 443 ] </pre>
<p>Standalone web application servers present their HTTP and HTTPS ports to<br/>
the public:</p>
<pre># tbt-backend-test.example.net.yaml 
nat_ports:  
  - 5973 
  - 5974 
  - 5975 
  - 6630 </pre>
<p>The testing instance for your new cloud service should expose a range of ports for custom services. If it has the <kbd>webserver</kbd> role (somehow), it will lead to an export of ports <kbd>22</kbd>, <kbd>80</kbd>, and <kbd>443</kbd>, as well as its individually chosen list.</p>
<p>When designing such a construct, keep in mind that the array merge is only ever cumulative. There is no way to exclude values that were added in lower layers from the final result. In this example, you will have no opportunity to disable the SSH port <kbd>22</kbd> for any given machine. You should take good care when adding common values.</p>
<p>A similar alternative lookup function exists for hashes. The <kbd>hiera_hash</kbd> function also traverses the whole hierarchy and constructs a hash by merging all hashes it finds under the given Hiera key from all hierarchy layers. Hash keys in higher layers overwrite those from lower layers. All values must be hashes. Strings, arrays, or other data types are not allowed in this case:</p>
<pre># common.yaml 
haproxy_settings: 
  log_socket: /dev/log 
  log_level: info 
  user: haproxy 
  group: haproxy 
  daemon: true </pre>
<p>These are the default settings for <kbd>haproxy</kbd> at the lowest hierarchy level. On web servers, the daemon should run as the general web service user:</p>
<pre># role/webserver.yaml 
haproxy_settings: 
  user: www-data 
  group: www-data </pre>
<p>When retrieved using <kbd>hiera('haproxy_settings')</kbd>, this will just evaluate to the hash, <kbd>{'user'=&gt;'www-data','group'=&gt;'www-data'}</kbd>. The hash at the role-specific layer completely overrides the default settings.</p>
<p>To get all values, create a merger using <kbd>hiera_hash('haproxy_settings')</kbd> instead. The result is likely to be more useful:</p>
<pre>{ 'log_socket' =&gt;'/dev/log', 'log_level' =&gt; 'info', 
'user' =&gt; 'www-data', 'group' =&gt; 'www-data', 'daemon' =&gt; true } </pre>
<p>The limitations are similar to those of <kbd>hiera_array</kbd>. Keys from any hierarchy level cannot be removed; they can only be overwritten with different values. The end result is quite similar to what you would get from replacing the hash with a group of keys:</p>
<pre># role/webserver.yaml 
haproxy::user: www-data 
haproxy::group: www-data </pre>
<p>If you opt to do this, the data can also be easily fitted to a class that can bind these values to parameters automatically. Preferring flat structures can, therefore, be beneficial. Defining hashes in Hiera is still generally worthwhile, as the next section explains. <a href="https://docs.puppetlabs.com/references/latest/function.html#createresources"><span class="MsoHyperlink">https://docs.puppetlabs.com/references/latest/function.html#createresources</span></a> originally been conceived for. Hiera can serve as a basic ENC.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Choosing between manifest and Hiera designs</h1>
                </header>
            
            <article>
                
<p>You can now move most of the concrete configuration to the data storage.<br/>
Classes can be included from the manifest or through Hiera. Puppet looks up parameter values in the hierarchy, and you can flexibly distribute the configuration values there in order to achieve the desired result for each node with minimal effort and redundancy.</p>
<p>This does not mean that you don't write actual manifest code anymore. The manifest is still the central pillar of your design. You will often need logic that uses the configuration data as input. For example, there might be classes that should only be included if a certain value is retrieved from Hiera:</p>
<pre>if hiera('use_caching_proxy', false) { 
    include nginx 
} </pre>
<p>If you try and rely on Hiera exclusively, you will have to add <kbd>nginx</kbd> to the <kbd>classes</kbd> array at all places in the hierarchy that set the <kbd>use_caching_proxy</kbd> flag to <kbd>true</kbd>. This is prone to mistakes. What's worse is that the flag can be overridden from <kbd>true</kbd> to <kbd>false</kbd> at a more specific layer, but the <kbd>nginx</kbd> element cannot be removed from an array that is retrieved by <kbd>hiera_include</kbd>.</p>
<p>It is important to keep in mind that the manifest and data should complement each other. You should primarily build manifests and add lookup function calls at opportune places. Defining flags and values in Hiera should allow you (or the user of your modules) to alter the behavior of the manifest. The data should not be the driver of the catalog composition, except for places in which you replace large numbers of static resources with large data structures.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Debugging data lookups</h1>
                </header>
            
            <article>
                
<p>As you can see from the preceding example, the data that contributes to the complete configuration of any module can be rather dispersed throughout the set of your data sources. It can be challenging to determine where the respective values are retrieved from for any given agent node. It can be frustrating to trace data sources to find out why a change at some level will not take effect for some of your agents.</p>
<p>To help make the process more transparent, Hiera comes with a command-line tool called <kbd>hiera</kbd>. Invoking it is simple:</p>
<pre><strong>root@puppetmaster # hiera -c /etc/puppetlabs/code/hiera.yaml demo::atoms</strong>  </pre>
<p>It retrieves a given key using the specified configuration from <kbd>hiera.yaml</kbd>. Make sure that you use the same Hiera configuration as Puppet.</p>
<p>Of course, this can only work sensibly if Hiera selects the same data sources as the compiler, which uses fact values to form a concrete hierarchy. These required facts can be given right on the command line as the final parameters:</p>
<pre><strong>root@puppetmaster # hiera -c /etc/puppetlabs/code/hiera.yaml demo::atoms <br/>::clientcert=int01-web01.example.net ::role=webserver ::location=ny</strong>  </pre>
<p>This prints the <kbd>demo::atoms</kbd> value of the specified server to the console. The fact values can also be retrieved from a YAML file or other alternative sources. Use <kbd>hiera --help</kbd> to get information about the available scenarios.</p>
<p>Make sure that you add the <kbd>-d</kbd> (or <kbd>--debug</kbd>) flag in order to get helpful information about the traversal of the hierarchy:</p>
<pre><strong>root@puppetmaster # hiera -d -c ...</strong></pre>
<div class="packt_tip">Hiera 5 allows for another way of debugging data lookups. We will cover Hiera 5 later in this chapter.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing resources from data</h1>
                </header>
            
            <article>
                
<p>You can now move configuration settings to Hiera and dedicate your manifest to logic. This works seamlessly as far as classes and their parameters are concerned, because class parameters automatically retrieve their values from Hiera. For configuration that requires you to instantiate resources, you still need to write the full manifests and add manual lookup function calls.</p>
<p>For example, an Apache web server requires some global settings, but the interesting parts of its configuration are typically performed in virtual host configuration files. Puppet models them with defined resource types. If you want to configure an <kbd>iptables</kbd> firewall, you have to declare lots of resources of the <kbd>firewall</kbd> type (available through the <kbd>puppetlabs-firewall</kbd> module).</p>
<p>Such elaborate resources can clutter up your manifest, yet they mostly represent data. There is no inherent logic to many firewall rules (although sometimes a set of rules is derived from one or several key values). Virtual hosts often stand for themselves as well, with little or no relation to configuration details that are relevant to other parts of the setup.</p>
<p>Puppet comes with yet another function that allows you to move whole sets of such resources to Hiera data. The pattern is straightforward: a group of resources of the same type are represented by a hash. The keys are resource titles, and the values are yet another layer of hashes with key-value pairs for attributes:</p>
<pre>services: 
  apache2: 
    enable: true 
    ensure: running 
  syslog-ng: 
    enable: false </pre>
<p>This YAML data represents two <kbd>service</kbd> resources. To make Puppet add them as actual resources to the catalog, use the iterator function from Puppet 4:</p>
<pre>$resource_hash.each |$res_title,$attributes| { 
  service { $res_title: 
    ensure =&gt; $attributes['ensure'], 
    enable =&gt; $attributes['enable'], 
  } 
} </pre>
<p>Within older Puppet code, one will most likely find the usage of the <kbd>create_resources</kbd> function:</p>
<pre>$resource_hash = hiera('services', {}) 
create_resources('service', $resource_hash) </pre>
<p>The first argument is the name of the resource type, and the second must be the hash of actual resources. There are some more aspects to this technique, but do note that, with Puppet 4, it is no longer necessary to rely on the <kbd>create_resources</kbd> function.</p>
<p>It's useful to be aware of the basics of it anyway. It is still in broad use for existing manifests, and it is still the most compact way of converting data into resources. To learn more, refer to the online documentation at <span class="MsoHyperlink"><a href="https://docs.puppetlabs.com/references/latest/function.html#createresources">https://docs.puppetlabs.com/references/latest/function.html#createresources</a></span>.</p>
<p>The Puppet 4 iterator has a few advantages over the <kbd>create_resources</kbd> approach:</p>
<ul>
<li>You can perform data transformations, such as adding a prefix to string values, or deriving additional attribute values</li>
<li>Each iteration can do more than just creating one resource per inner hash, for example, including required classes</li>
<li>You can devise a data structure that deviates from the strict expectancies of <kbd>create_resources</kbd></li>
<li>The manifest is more clear and intuitive, especially to uninitiated readers</li>
</ul>
<p>For creating many simple resources (such as the services in the preceding example), you might wish to avoid <kbd>create_resource</kbd> in Puppet 4 manifests. Just keep in mind that if you don't take advantage of doing so, you can keep the manifest more succinct by sticking to <kbd>create_resources</kbd> after all.</p>
<p>Puppet 4 comes with a useful tool to generate YAML data that is suitable for <kbd>create_resources</kbd>. With the following command, you can make Puppet emit service type resources that represent the set of available services on the local system, along with their current property values:</p>
<pre><strong>puppet resource -y service </strong></pre>
<div class="packt_tip">The <kbd>-y</kbd> switch selects a YAML output instead of Puppet DSL.</div>
<p>In theory, these techniques allow you to move almost all your code to Hiera data (the next section discusses how desirable that really is). There is one more feature that goes one step further in this direction:</p>
<pre>hiera_include('classes') </pre>
<p>This call gathers values from all over the hierarchy; just the same as <kbd>hiera_array</kbd>. The resulting array is interpreted as a list of class names. All these named classes are included. This allows for some additional consolidation in your manifest:</p>
<pre># common.yaml 
classes: 
  - ssh 
  - syslog 
... 
# role-webserver.yaml 
classes: 
  - apache 
  - logrotate 
  - syslog </pre>
<p>You can possibly even use <kbd>hiera_include</kbd> to declare these classes outside of any <kbd>node</kbd> block. The data will then affect all nodes. Additionally, from some distinct classes, you might also declare other classes via <kbd>hiera_include</kbd>, whose names are stored under a different Hiera key.</p>
<p>The ability to enumerate classes for each node to include is what Puppet's <strong>External Node Classifiers</strong> (<strong>ENCs</strong>) had originally been conceived for. Hiera can serve as a basic ENC thanks to the <kbd>hiera_include</kbd> function. This is most likely preferred over writing a custom ENC. However, it should be noted that some open source ENCs, such as Foreman, are quite powerful and can add much more convenience; as a result, Hiera has not supplanted the concept as a whole.</p>
<p>The combination of these tools opens some ways for you to shrink your manifests to their essential parts and configure your machines gracefully through Hiera.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hiera version 5</h1>
                </header>
            
            <article>
                
<p>Hiera 5 was released with Puppet 4.9. Earlier Puppet 4 releases had Hiera 4 bundled. The main difference between older Hiera and Hiera 5 is the concept of multilayered Hiera hierarchies:</p>
<ul>
<li>The first layer is the module layer. Hiera 5 allows you to use Hiera data in modules by specifying a Hiera 5 config version <kbd>hiera.yaml</kbd> file inside the module root</li>
<li>The second layer is the environment layer where you place a <kbd>hiera.yaml</kbd> file inside the environment root</li>
</ul>
<p>The last layer is the main layer, where <kbd>hiera.yaml</kbd> resides in <kbd>/etc/puppetlabs/puppet/hiera.yaml</kbd>. This was the only layer available in older Hiera versions.</p>
<div class="packt_tip">The main layer is no longer considered best practice, and exists for compatibility reasons. Everybody is encouraged to migrate data from the main layer to the environment layer.</div>
<p>With Hiera 5, the configuration file has completely different content. It is still a YAML style file, but backends are no longer globally configured but put into the hierarchy level. This allows you to specify different backends for different Hiera hierarchies.</p>
<p>Let's convert the <kbd>hiera.yaml</kbd> file from Hiera 3 to Hiera 5:</p>
<pre># /etc/puppetlabs/puppet/hiera.yaml 
:backends: 
  - yaml 
:hierarchy:  
  - node/%{::clientcert} 
  - role/%{::role} 
  - location/%{::datacenter} 
  - common 
:yaml:  
  :datadir: /etc/puppetlabs/code/environments/%{::environment<br/>     }/hieradata </pre>
<p>Transform this file to the Hiera 5 <kbd>.yaml</kbd> file:</p>
<pre># /etc/puppetlabs/code/environments/production/hiera.yaml 
--- 
version: 5 
# specify the default datadir and yaml backend 
defaults: 
  datadir: hieradata 
  data_hash: yaml_data 
# build hierarchy. Note that paths need the file ending! 
hierarchy: 
  - name: "Per-node data" 
    path: "node/%{::clientcert}.yaml" 
  - name: "Per-role data" 
    path: "role/%{::role}.yaml" 
  - name: "Per-location data" 
    path: "location/%{::datacenter}.yaml" 
  - name: "Common data" 
    path: 'common.yaml' 
 </pre>
<p>Besides this, it is possible to configure the Hiera lookup behavior by adding <kbd>lookup_options</kbd> keys to your Hiera data. On each data lookup, Hiera 5 will first check for the <kbd>lookup_options</kbd> key and will then use this information to look up the desired data. But how should Hiera know which layer to use?</p>
<p>With Hiera 3 we used the <kbd>hiera</kbd>, <kbd>hiera_array</kbd>, or <kbd>hiera_hash</kbd> function to retrieve data. With Hiera 5, these functions have been replaced by a single lookup function.</p>
<ul>
<li><kbd>hiera</kbd> (key) gets converted to lookup(key)</li>
<li><kbd>hiera_array</kbd> (key) gets converted to lookup(key, array, unique)</li>
<li><kbd>hiera_hash</kbd> (key) gets converted to lookup(key, hash, hash)</li>
</ul>
<p>The automatic data lookup from classes works without any further changes. Another change with Hiera 5 is the way we debug Hiera data lookups. Puppet now has the puppet lookup interface. Remember the Hiera cli tool:</p>
<pre><strong>root@puppetmaster # hiera -c /etc/puppetlabs/code/hiera.yaml demo::atoms <br/>::clientcert=int01-web01.example.net ::role=webserver ::location=ny</strong>  </pre>
<p>Now we can use the Puppet lookup cli:</p>
<pre><strong><span class="MsoHyperlink">root@puppetmaster</span>
<strong># puppet lookup demo::atoms -node int01-web01.example.net</strong></strong>  </pre>
<p>The main difference is that Puppet lookup uses facts stored on the Puppet master instead of adding each used fact on cli. Besides this, there is an additional option <kbd>--explain</kbd>, which replaces the debug option from Hiera cli.</p>
<p>When using Puppet lookup with the <kbd>--explain</kbd> option, the output also shows the lookup for the merge behavior.</p>
<p>Describing all of the new features, especially the paths and globbing possibilities and the configuration of Hiera lookup behavior inside Hiera, is beyond the scope of this book:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="216" src="assets/1706dbd4-a78d-4735-a7fc-1e0c1d0c36a0.png" width="463"/></div>
<p><a href="http://www.craigdunn.org/2012/05/239/">http://www.craigdunn.org/2012/05/239/</a>, and the design has since been adopted by many users.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Hiera is a tool that stores and retrieves data in a hierarchical fashion. Each retrieval uses a distinct data source from each hierarchy layer and traverses your hierarchy from the most to the least specific level. The hierarchy is defined by the user as an array in a YAML file.</p>
<p>Puppet has Hiera support built in, and you can use it to separate data from code. From manifests, you will mainly perform lookups through the <kbd>hiera</kbd> function. In most cases, the respective entries will rely on fact values.</p>
<p>Another common way to employ Hiera through Puppet is to name the Hiera keys in the <kbd>&lt;class-name&gt;::&lt;parameter-name&gt;</kbd> format. When including a parameterized class, Puppet will look for such keys in Hiera. If the manifest does not supply a parameter value, Puppet automatically binds the value from Hiera to the respective parameter.</p>
<p>Manifests that boast large numbers of static resources can be cleaned up by converting the declarations to hashes and using the <kbd>create_resources</kbd> or <kbd>each</kbd> function to declare resources from the data.</p>
<p>Hiera 5 offers a broad set of new functionality, including data in modules and data in environments. This chapter gave you guidance on how to migrate data to Hiera 5.</p>
<p>Within <a href="0a0cf4b0-23fa-48fd-abf9-77ed851bb581.xhtml">Chapter 9</a>, <em>Puppet Roles and Profiles</em>, we will discuss how modules and node classification should work together, and how to automatically build and deploy a Puppet code environment.</p>


            </article>

            
        </section>
    </body></html>