- en: Puppet Roles and Profiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a complete overview of the Puppet DSL and its concepts, it
    is time to look at how to build implementations based on Puppet that reflect your
    infrastructure settings and requirements.
  prefs: []
  type: TYPE_NORMAL
- en: In the early days of Puppet, it was common practice to add resources and variables
    to a node classification. This mostly led to duplicate code and made refactoring
    almost impossible. This pattern mostly reflected the usual admin work, which was
    done by configuring individual systems.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid difficult to manage and hard to maintain code, a community around Puppet
    modules emerged. This community took care to implement technical parts of a system
    into Puppet modules. Modules have the benefit of being reusable by parameters
    and get bug-fixes and new implementations faster due to shared efforts.
  prefs: []
  type: TYPE_NORMAL
- en: As we now have a large set of modules available, we must rethink the pattern
    of our node classification in combination with modules. Here, the roles and profiles
    pattern comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within this chapter, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Technical component modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing components in profiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building roles from profiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The business use case and the node classification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Placing code on the Puppet server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical component modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have referred to modules as a strict directory structure containing
    classes, static files, templates, and extensions. We now must differentiate between
    upstream or generic modules and our platform implementation modules.
  prefs: []
  type: TYPE_NORMAL
- en: Modules that take care of a specific technical component are now referred to
    as technical component modules. Technical components themselves are a set of configurations
    for a certain software running on a system, such as Nginx, Postgres, or LDAP.
  prefs: []
  type: TYPE_NORMAL
- en: 'There has always been the problem of whether a module is a technical component
    module or not. There are some patterns that allow you to identify technical component
    modules:'
  prefs: []
  type: TYPE_NORMAL
- en: Developed upstream with active community
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open source with `README` and `LICENSE` files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only manages what is required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clearly described entry class with parameters for adoption and reusability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows stacking together with other technical component classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses a module name related to the configured technology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usually has support for multiple operating systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has public information such as package and configuration filenames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does not have private data, as your internal DNS server IP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing components in profiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Puppet code that is not taken from upstream, but developed in-house describing
    your infrastructure, usually is an implementation of resources and upstream classes.
    This implementation is called a profile class.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, a profile is a module containing classes, and optionally has parameters,
    defines, files, and templates. On very rare occasions, it might be valuable to
    also have custom facts or custom functions within profiles.
  prefs: []
  type: TYPE_NORMAL
- en: Inside a profile, one specifies data and resources. Data can either be static
    data, which is valid for the whole platform, or placed into Hiera. Resources can
    be anything such as class, file, package, and service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Combining these into a profile builds another layer of abstraction:'
  prefs: []
  type: TYPE_NORMAL
- en: Data is abstracted by Hiera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CLI commands are abstracted by resource types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource types are abstracted by technical component modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical component modules are abstracted by profiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When one searches for profiles on the internet, you will mostly find stubs with
    Apache, MySQL, and WordPress installation.
  prefs: []
  type: TYPE_NORMAL
- en: Profiles are not meant to be made public, as they usually contain private information
    about your infrastructure. Instead, one has to develop profiles on their own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with an example: a `phpmyadmin` based database management system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The system consists of several base technical components: remote login, backup,
    firewall, webserver, database, `php`, and `phpmyadmin`. Each of these components
    is managed by an upstream developed technical component module. The way we want
    to have the implementation is done in profiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of writing a single profile for every different setup, it is possible
    to either add parameters to the profile and make use of Hiera lookup, or to stack
    components together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The same pattern can be used for MySQL. The main `mysql` profile just installs
    a single MySQL instance using the `puppetlabs-mysql` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The same pattern follows for the `php` and `phpmyadmin` installation using
    upstream modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Grouping profiles within a directory structure has no technical need. Think
    about an infrastructure that has lots of profiles or even lots of similar profiles,
    such as PostgreSQL, MySQL, MariaDB, Galera Cluster, or Oracle DB, and MSSQL. In
    this case, the grouping is preferred to flat file space, as many flat files lead
    to a difficult to read directory structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The business use case and node classification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all implementations now being in place, we look forward to how to do node
    classification.
  prefs: []
  type: TYPE_NORMAL
- en: There are several options available and which one is the best solution mostly
    depends on your platform.
  prefs: []
  type: TYPE_NORMAL
- en: When you have a very diverse platform, the concept of roles as another abstraction
    layer is not very useful, as it mostly leads to duplicate code. In this case,
    most people decided to use profiles for node classification.
  prefs: []
  type: TYPE_NORMAL
- en: When you have large sets of identically configured systems, one wants to go
    ahead with the role pattern and classify systems by their business use case.
  prefs: []
  type: TYPE_NORMAL
- en: The business use case allows you to describe systems not by what they do, but
    by what they are used for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think about the `phpmyadmin` installation. Depending on use case and business
    owner, one might have different classification names:'
  prefs: []
  type: TYPE_NORMAL
- en: A technician will use the term `database control panel`. If the `phpmyadmin`
    installation is used by the sales team, it might be possible that they name the
    same system `crm data management system`.
  prefs: []
  type: TYPE_NORMAL
- en: The best solution is to identify the application stake holder and ask what the
    application is used for. This has the positive side effect of getting an overview
    of all business use cases. If you identify a system having more than one business
    use case, it is now easy to understand the business impact in the event of a system
    outage.
  prefs: []
  type: TYPE_NORMAL
- en: In the past, people stacked many applications onto a single system to allow
    for the best hardware usage. These are infrastructures where one node will have
    multiple business use cases. With the concept of virtual machines, this is obsolete.
    Today, a single virtual machine should serve a single business use case only.
  prefs: []
  type: TYPE_NORMAL
- en: Building roles from profiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's continue with the `phpmyadmin` example, which has been built for the sales
    department so that they can manage their CRM database.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we build a role for that system based on implementation profiles.
    The name of the role reflects the business use case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Within a role, one only declares profiles. No code logic, no resources, no data
    lookups. This allows flexible use of roles. Don't try to build almost identical
    roles, as this will lead to duplicate code. Instead, it would be better to create
    profiles with data lookups to reflect individual usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previously mentioned role can then be used for a node classification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can now see, we have a single instance with a single role. This is always
    useful when building systems from scratch. Within existing infrastructures, one
    can use this concept to identify which business units are affected when a single
    system is not available. Besides this, one learns about where to separate services
    when required.
  prefs: []
  type: TYPE_NORMAL
- en: There are environments where the concept of roles and profiles does not fit
    very well. Mostly, these are existing platforms where multiple services (roles)
    are running on a single system and many different implementations for the same
    profile exist. In these cases, one should verify whether the implementation layer
    (profile) alone is sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: Placing code on the Puppet server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From a technical perspective, roles and profiles are classes inside modules.
    Usually, modules are put into the `modules` directory of an environment. But roles
    and profiles are different to modules, as they are implementations of modules
    and collections of implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To reflect this different behavior, it is common practice to add another `module`
    directory to an environment. This configuration can be done in the `environment.conf`
    file inside an environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Within our example, we have added a new path to the module path setting: site.
    This directory resides inside our environment (`/etc/puppetlabs/code/environments/production/site`).
    This directory will have all of our roles and profiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to keep roles and profiles in a separate directory structure
    and have modules by itself.
  prefs: []
  type: TYPE_NORMAL
- en: The Puppet control repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually, Puppet modules are the same as libraries that are developed upstream.
    We want to ensure that modules that we use within our Puppet code are stored in
    a way that allows upgrades. Therefore, we cannot place the modules directly in
    our environment Git repository. Besides this, we want to test Puppet code updates
    prior to putting them into production.
  prefs: []
  type: TYPE_NORMAL
- en: 'Best practice is to have a control repository that has our roles and profiles,
    the manifest''s node classification, the environment configuration file, and Hiera
    v5 configuration. Now we add another file: `Puppetfile`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `Puppetfile` references modules and, optionally, their source location and
    version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When no source is given, the module will be installed from Puppet Forge ([https://forge.puppet.com](https://forge.puppet.com)).
    As most production systems are not allowed to connect to the internet, it is useful
    to have a clone of the upstream module development repository on your private
    Git server.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Puppet control repository can have the following files and directory structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Synchronizing upstream modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Usually, one can use the workstation for synchronization. First, an empty repository
    is created on the local Git server and cloned to the workstation. Within this
    local repository, a new remote location is added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the upstream code is fetched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Git separates code and objects. Usually, upstream uses tags to identify version
    releases of their module. Tags are part of the non-code objects. Next, the non-code
    objects are fetched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the local repository server gets the code pushed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to also `push` the tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: R10K code deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually, companies have staging systems where a new development is tested prior
    to being put into production. The development team has a development stage. From
    this stage, the changes will be deployed to a quality gate stage and placed into
    the production stage after successful tests.
  prefs: []
  type: TYPE_NORMAL
- en: Many people use these names for the Puppet code environments. But what happens
    if your Puppet change will break the whole development stage? In this case, the
    development team is unable to continue working on urgent improvements or fixes.
    This can lead to time and cost intensive work where the development stage is built
    from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: But how do we develop and test Puppet code changes? Usually, this requires another
    stage for infrastructure developers. All other infrastructure stages (development,
    QA, production) are then deployed using the stable production Puppet environment
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads to two Puppet environments: **development** and **production**.'
  prefs: []
  type: TYPE_NORMAL
- en: But we don't want these to be two separate Git repositories, as this makes the
    staging of changes very difficult. This is where R10K comes into place. R10K uses
    branches on the Puppet control repository and deploys these onto the Puppet Master
    as environments. Code changes can now be done by merge requests from one branch
    to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Names of branches can be freely chosen, except some special names that should
    not be used: master, agent, main. Especially for Git repositories, where the default
    branch will be master, this needs some reconfiguration on the default branch name.'
  prefs: []
  type: TYPE_NORMAL
- en: 'R10K must be installed and configured on the Puppet Master. We can use Puppet
    for installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `r10k` configuration file must be placed at `/etc/puppetlabs/r10k/r10k.yaml`.
    Within this file, we activate the desired `cache` directory where `r10k` stores
    local copies of all repositories. Remember to keep these caches in clean state
    and remove the whole cache in a case of misbehavior relating to the local Git
    repository caches.
  prefs: []
  type: TYPE_NORMAL
- en: R10K allows the usage of multiple control-repositories. These can easily coexist
    within one environment, as they get prefixed with the source name provided. Control
    repositories are placed into the sources section and get a unique name. Then,
    we specify the remote URL where R10K can get the code from. Code is deployed into
    the path mentioned within the `basedir` setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last two settings are related to fetching code. The first one refers to Git
    access. Within the Git setting, one can set a provider. There are two providers
    available: `shellgit` and rugged. The `shellgit` provider uses the `git` binary,
    which must be available on the Puppet master. The user who runs the `R10K` command
    must have a configured `git` shell environment, as specifying the `ssh` key to
    use for authorization. Rugged is a Ruby implementation where one can specify the Git
    `ssh` settings directly in a `r10k.yaml` file. Usually, `shellgit` is sufficient
    to use. The last setting specifies how R10K should fetch modules from Puppet Forge.
    Here, we can only specify a proxy that should be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The deployment of branches from a control repository and installation of modules
    is done by running `r10k`. Please ensure that you run this command only as the
    user who needs to fetch the code. When running this command as `root`, either
    ssh credentials might be wrong or the environment belongs to the `root` user afterwards.
    The parameter -v enables verbose mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of manually running the `r10K` command-line tool, it is possible to
    install a webhook using the `puppet-r10k` module from `voxpupuli` ([https://github.com/voxpupili/puppet-r10k](https://github.com/voxpupuli/puppet-r10k)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This webhook can be triggered from Git server or from a CI/CD test/deployment
    toolchain such as Jenkins or GoCD. Usually, a combination of both is a valid setup,
    where you want to deploy feature branches as fast as possible and run updates
    on a development or a production environment only after successful tests.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building and maintaining Puppet code bases, it is a good idea to implement
    the roles and profiles pattern. It makes you define roles to cover all of your
    machine use cases. The roles mix and match profile classes, which are basically
    collectors of classes from custom and open source modules that manage actual resources.
  prefs: []
  type: TYPE_NORMAL
- en: When setting up your first large Puppet installation, it is a good idea to adhere
    to the pattern from day one, because it will allow you to scale your manifests
    without getting tangled up in complicated structures.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment of Puppet code is managed via `r10k`, where Git branch names reflect
    your Puppet code quality. Using `Puppetfile` allows you to separate your own Puppet
    code development from upstream module development.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our tour of *Puppet Essentials*. We have covered quite some ground,
    but as you can imagine, we barely scratched the surface of some of the topics,
    such as Puppet code testing, provider development, or exploiting PuppetDB. What
    you have learned will most likely satisfy your immediate requirements. For information
    beyond these lessons, don't hesitate to look up the excellent online documentation
    at [https://docs.puppet.com/](https://docs.puppet.com/), or join the community
    and ask your questions in chat, Slack, or on the mailing list.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks for reading, and have lots of fun with Puppet and its family of management
    tools.
  prefs: []
  type: TYPE_NORMAL
