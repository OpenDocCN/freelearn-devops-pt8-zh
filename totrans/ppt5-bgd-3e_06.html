<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Managing data with Hiera"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Managing data with Hiera</h1></div></div></div><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><span class="emphasis"><em>What you don't know can't hurt me.</em></span></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<span class="attribution"><span class="emphasis"><em>Edward S. Marshall</em></span></span></td></tr></table></div><p>In this chapter, you will learn why it's useful to separate your data and code. You will see how to set up Puppet's built-in Hiera mechanism, how to use it to store and query configuration data, including encrypted secrets such as passwords, and how to use Hiera data to create Puppet resources.</p><div class="mediaobject"><img src="graphics/8880_06_01.jpg" alt="Managing data with Hiera"/></div><div class="section" title="Why Hiera?"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec27"/>Why Hiera?</h1></div></div></div><p>What do we mean <a id="id240" class="indexterm"/>by <span class="strong"><strong>configuration data</strong></span>? There will be lots of pieces of information in your manifests which we can regard as configuration data: for example, the values of all your resource attributes. Look at the following example:</p><div class="informalexample"><pre class="programlisting">package { 'puppet-agent':
  ensure =&gt; '5.2.0-1xenial',
}</pre></div><p>The preceding manifest declares that version <code class="literal">5.2.0-1xenial</code> of the <code class="literal">puppet-agent</code> package should be installed. But what happens when a new version of Puppet is released? When you want to upgrade to it, you'll have to find this code, possibly deep in multiple levels of directories, and edit it to change the desired version number.</p><div class="section" title="Data needs to be maintained"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec81"/>Data needs to be maintained</h2></div></div></div><p>Multiply this by all the <a id="id241" class="indexterm"/>packages managed throughout your manifest, and there is there's already a problem. But this is just one piece of data that needs to be maintained, and there are many more: the times of cron jobs, the email addresses for reports to be sent to, the URLs of files to fetch from the web, the parameters for monitoring checks, the amount of memory to configure for the database server, and so on. If these values are embedded in code in hundreds of manifest files, you're setting up trouble for the future.</p><p>How can you make your config data easy to find and maintain?</p></div><div class="section" title="Settings depend on nodes"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec82"/>Settings depend on nodes</h2></div></div></div><p>Mixing data with code makes it <a id="id242" class="indexterm"/>harder to find and edit that data. But there's another problem. What if you have two nodes to manage with Puppet, and there's a config value which needs to be different on each of them? For example, they might both have a cron job to run the backup, but the job needs to run at a different time on each node.</p><p>How can you use different values for different nodes, without having lots of complicated logic in your manifest?</p></div><div class="section" title="Operating systems differ"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec83"/>Operating systems differ</h2></div></div></div><p>What if you have some <a id="id243" class="indexterm"/>nodes running Ubuntu 16, and some on Ubuntu 18? As you'll know if you've ever had to upgrade the operating system on a node, things change from one version to the next. For example, the name of the database server package might have changed from <code class="literal">mysql-server</code> to <code class="literal">mariadb-server</code>.</p><p>How can you find the right value to <a id="id244" class="indexterm"/>use in your manifest depending on what operating system the node is running?</p></div><div class="section" title="The Hiera way"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec84"/>The Hiera way</h2></div></div></div><p>What we want is a kind of central database in Puppet where we can look up configuration settings. The data should be stored separately from Puppet code, and make it easy to find and edit values. It should be possible <a id="id245" class="indexterm"/>to look up values with a simple function call in Puppet code or templates. Further, we need to be able to specify different values depending on things like the hostname of the node, the operating system, or potentially anything else. We would also like to be able to enforce a particular data type for values, such as String or Boolean. The database should do all of this work for us, and just return the appropriate value to the manifest where it's needed.</p><p>Fortunately, Hiera does exactly this. Hiera lets you store your config data in simple text files (actually, YAML, JSON, or HOCON files, which use popular structured text formats), and it looks like the following example:</p><div class="informalexample"><pre class="programlisting">---
  test: 'This is a test'
  consul_node: true
  apache_worker_factor: 100
  apparmor_enabled: true
  ...</pre></div><p>In your manifest, you query the database using the <code class="literal">lookup()</code> function, as in the following example (<code class="literal">lookup.pp</code>):</p><div class="informalexample"><pre class="programlisting">file { lookup('backup_path', String):
  ensure =&gt; directory,
}</pre></div><p>The arguments to <code class="literal">lookup</code> are the name of the Hiera key you want to retrieve (for example <code class="literal">backup_path</code>), and the expected data type (for example <code class="literal">String</code>).</p></div></div></div>
<div class="section" title="Setting up Hiera"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec28"/>Setting up Hiera</h1></div></div></div><p>Hiera needs to know one or <a id="id246" class="indexterm"/>two things before you can start using it, which are specified in the Hiera configuration file, named <code class="literal">hiera.yaml</code> (not to be confused this with Hiera data files, which are also YAML files, and we'll find about those later in this chapter.) Each Puppet environment has its own local Hiera config file, located at the root of the environment directory (for example, for the <code class="literal">production</code> environment, the local Hiera config file would be <code class="literal">/etc/puppetlabs/code/environments/production/hiera.yaml</code>).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip29"/>Tip</h3><p>Hiera can also use a global config file located at <code class="literal">/etc/puppetlabs/puppet/hiera.yaml</code>, which takes precedence over the per-environment file, but the Puppet documentation recommends you only use this config layer for certain exceptional purposes, such as temporary overrides; all your normal <a id="id247" class="indexterm"/>Hiera data and configuration should live at the environment layer.</p></div></div><p>The following example shows a minimal <code class="literal">hiera.yaml</code> file (<code class="literal">hiera_minimal.config.yaml</code>):</p><div class="informalexample"><pre class="programlisting">---
version: 5

defaults:
  datadir: data
  data_hash: yaml_data

hierarchy:
  - name: "Common defaults"
    path: "common.yaml"</pre></div><p>YAML files begin with three dashes and a newline (<code class="literal">---</code>). This is part of the YAML format, not a Hiera feature; it's the syntax indicating the start of a new YAML document.</p><p>The most important setting in the <code class="literal">defaults</code> section is <code class="literal">datadir</code>. This tells Hiera in which directory to look for its data files. Conventionally, this is in a <code class="literal">data/</code> subdirectory of the Puppet manifest directory, but you can change this if you need to.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip30"/>Tip</h3><p>Large organizations may find it useful to manage Hiera data files separately to Puppet code, perhaps in a separate Git repo (for example, you might want to give certain people permission to edit Hiera data, but not Puppet manifests).</p></div></div><p>The <code class="literal">hierarchy</code> section is also interesting. This tells Hiera which files to read for its data and in which order. In the example only <code class="literal">Common defaults</code> is defined, telling Hiera to look for data in a file called <code class="literal">common.yaml</code>. We'll see later in this chapter what else you can do with the <code class="literal">hierarchy</code> section.</p></div>
<div class="section" title="Adding Hiera data to your Puppet repo"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec29"/>Adding Hiera data to your Puppet repo</h1></div></div></div><p>Your Vagrant <a id="id248" class="indexterm"/>VM is already set up with a suitable Hiera config and the sample data file, in the <code class="literal">/etc/puppetlabs/code/environments/pbg</code> directory. Try it now:</p><p>Run the following <a id="id249" class="indexterm"/>commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo puppet lookup --environment pbg test</strong></span>
--- This is a test</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip31"/>Tip</h3><p>We haven't seen the <code class="literal">--environment</code> switch before, so it's time to briefly introduce Puppet environments. A Puppet <span class="strong"><strong>environment</strong></span> is a directory containing a Hiera config file, Hiera data, a set of Puppet manifests—in other words, a complete, self-contained Puppet setup. Each environment lives in a named directory under <code class="literal">/etc/puppetlabs/code/environments</code>. The default environment is <code class="literal">production</code>, but you can use any environment you like by giving the <code class="literal">--environment</code> switch to the <code class="literal">puppet lookup</code> command. In the example, we are telling Puppet to use the <code class="literal">/etc/puppetlabs/code/environments/pbg</code> directory.</p></div></div><p>When you come to add Hiera data to your own Puppet environment, you can use the example <code class="literal">hiera.yaml</code> and data files as a starting point.</p><div class="section" title="Troubleshooting Hiera"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec85"/>Troubleshooting Hiera</h2></div></div></div><p>If you don't get the result <code class="literal">This is a test</code> <a id="id250" class="indexterm"/>, your Hiera setup is not working properly. If you see the warning <code class="literal">Config file not found, using Hiera defaults</code>, check that your Vagrant box has an <code class="literal">/etc/puppetlabs/code/environments/pbg</code> directory. If not, destroy and re-provision your Vagrant box with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>vagrant destroy</strong></span>
<span class="strong"><strong>scripts/start_vagrant.sh</strong></span>
</pre></div><p>If you see an error like the following, it generally indicates a problem with the Hiera data file syntax:</p><div class="informalexample"><pre class="programlisting">Error: Evaluation Error: Error while evaluating a Function Call, (/etc/puppetlabs/code/environments/pbg/hiera.yaml): did not find expected key while parsing a block mapping at line 11 column 5  at line 1:8 on node ubuntu-xenial</pre></div><p>If this is the case, check the syntax of your Hiera data files.</p></div></div>
<div class="section" title="Querying Hiera"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec30"/>Querying Hiera</h1></div></div></div><p>In Puppet manifests, you can use <a id="id251" class="indexterm"/>the <code class="literal">lookup()</code> function to query Hiera for the specified key (you can think of Hiera as a key-value database, where the keys are strings, and values can be any type).</p><p>In general, you can use a call to <a id="id252" class="indexterm"/>
<code class="literal">lookup()</code> anywhere in your Puppet manifests you might otherwise use a literal value. The following code shows some examples of this (<code class="literal">lookup2.pp</code>):</p><div class="informalexample"><pre class="programlisting">notice("Apache is set to use ${lookup('apache_worker_factor', Integer)} workers")

unless lookup('apparmor_enabled', Boolean) {
  exec { 'apt-get -y remove apparmor': }
}

notice('dns_allow_query enabled: ', lookup('dns_allow_query', Boolean))</pre></div><p>To apply this manifest in the example environment, run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo puppet apply --environment pbg /examples/lookup2.pp</strong></span>
Notice: Scope(Class[main]): Apache is set to use 100 workers
Notice: Scope(Class[main]): dns_allow_query enabled:  true</pre></div><div class="section" title="Typed lookups"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec86"/>Typed lookups</h2></div></div></div><p>As we've seen, <code class="literal">lookup()</code> takes a <a id="id253" class="indexterm"/>second parameter which specifies the expected type of the value to be retrieved. Although this is optional, you should always specify it, to help catch errors. If you accidentally look up the wrong key, or mistype the value in the data file, you'll get an error like this:</p><div class="informalexample"><pre class="programlisting">Error: Evaluation Error: Error while evaluating a Function Call, Found value has wrong type, expects a Boolean value, got String at /examples/lookup_type.pp:1:8 on node ubuntu-xenial</pre></div></div></div>
<div class="section" title="Types of Hiera data"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec31"/>Types of Hiera data</h1></div></div></div><p>As we've seen, Hiera data is <a id="id254" class="indexterm"/>stored in text files, structured using the format called <span class="strong"><strong>YAML Ain't Markup Language</strong></span>, which is a common way <a id="id255" class="indexterm"/>of organizing data. Here's another snippet from our sample Hiera data file, which you'll find at <code class="literal">/etc/puppetlabs/code/environments/pbg/data/common.yaml</code> on the VM:</p><div class="informalexample"><pre class="programlisting">  syslog_server: '10.170.81.32'
  monitor_ips:
    - '10.179.203.46'
    - '212.100.235.160'
    - '10.181.120.77'
    - '94.236.56.148'
  cobbler_config:
    manage_dhcp: true
    pxe_just_once: true</pre></div><p>There are actually three different <a id="id256" class="indexterm"/>kinds of Hiera data structures present: <span class="strong"><strong>single values</strong></span>, <span class="strong"><strong>arrays</strong></span>, and <span class="strong"><strong>hashes</strong></span>. We'll examine these in detail in a moment.</p><div class="section" title="Single values"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec87"/>Single values</h2></div></div></div><p>Most Hiera data consists of <a id="id257" class="indexterm"/>a key associated with a single value, as in the previous example:</p><div class="informalexample"><pre class="programlisting">syslog_server: '10.170.81.32'</pre></div><p>The value can be any <a id="id258" class="indexterm"/>legal Puppet value, such as a String, as in this case, or it can be an Integer:</p><div class="informalexample"><pre class="programlisting">apache_worker_factor: 100</pre></div></div><div class="section" title="Boolean values"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec88"/>Boolean values</h2></div></div></div><p>You should specify Boolean <a id="id259" class="indexterm"/>values in Hiera as either <code class="literal">true</code> or <code class="literal">false</code>, without <a id="id260" class="indexterm"/>surrounding quotes. However, Hiera is fairly liberal in what it interprets as Boolean values: any of <code class="literal">true</code>, <code class="literal">on</code>, or <code class="literal">yes</code> (with or without quotes) are interpreted as a true value, and <code class="literal">false</code>, <code class="literal">off</code>, or <code class="literal">no</code> are interpreted as a false value. For clarity, though, stick to the following format:</p><div class="informalexample"><pre class="programlisting">consul_node: true</pre></div><p>When you use <code class="literal">lookup()</code> to return a Boolean value in your Puppet code, you can use it as the conditional expression in, for example, an <code class="literal">if</code> statement:</p><div class="informalexample"><pre class="programlisting">if lookup('is_production', Boolean) {
  ...</pre></div></div><div class="section" title="Arrays"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec89"/>Arrays</h2></div></div></div><p>Usefully, Hiera can also store an <a id="id261" class="indexterm"/>array of values associated with <a id="id262" class="indexterm"/>a single key:</p><div class="informalexample"><pre class="programlisting">monitor_ips:
  - '10.179.203.46'
  - '212.100.235.160'
  - '10.181.120.77'
  - '94.236.56.148'</pre></div><p>The key (<code class="literal">monitor_ips</code>) is followed <a id="id263" class="indexterm"/>by a list of values, each on its own line and preceded by a hyphen (<code class="literal">-</code>). When you call <code class="literal">lookup('monitor_ips', Array)</code> in <a id="id264" class="indexterm"/>your code, the values will be returned as a Puppet array.</p></div><div class="section" title="Hashes"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec90"/>Hashes</h2></div></div></div><p>As we saw in <a class="link" href="ch05.html" title="Chapter 5. Variables, expressions, and facts">Chapter 5</a>, <span class="emphasis"><em>Variables, expressions, and facts</em></span>, a hash (also called a <span class="strong"><strong>dictionary</strong></span> in some programming languages) is like <a id="id265" class="indexterm"/>an array where each value has an identifying <a id="id266" class="indexterm"/>name (called the <span class="strong"><strong>key</strong></span>), as in the following <a id="id267" class="indexterm"/>example:</p><div class="informalexample"><pre class="programlisting">cobbler_config:
  manage_dhcp: true
  pxe_just_once: true</pre></div><p>Each key-value pair in the hash is listed, indented on its own line. The <code class="literal">cobbler_config</code> hash has two keys, <code class="literal">manage_dhcp</code> and <code class="literal">pxe_just_once</code>. The value associated with each of those keys is <code class="literal">true</code>.</p><p>When you call <code class="literal">lookup('cobbler_config', Hash)</code> in a manifest, the data will be returned as a Puppet hash, and you can reference individual values in it using the normal Puppet hash syntax, as we saw in <a class="link" href="ch05.html" title="Chapter 5. Variables, expressions, and facts">Chapter 5</a>, <span class="emphasis"><em>Variables, expressions, and facts</em></span> (<code class="literal">lookup_hash.pp</code>):</p><div class="informalexample"><pre class="programlisting">$cobbler_config = lookup('cobbler_config', Hash)
$manage_dhcp = $cobbler_config['manage_dhcp']
$pxe_just_once = $cobbler_config['pxe_just_once']
if $pxe_just_once {
  notice('pxe_just_once is enabled')
} else {
  notice('pxe_just_once is disabled')
}</pre></div><p>Since it's very common for Hiera data to be a hash of hashes, you can retrieve values from several levels down in a hash by using the following "dot notation" (<code class="literal">lookup_hash_dot.pp</code>):</p><div class="informalexample"><pre class="programlisting">$web_root = lookup('cms_parameters.static.web_root', String)
notice("web_root is ${web_root}")</pre></div></div></div>
<div class="section" title="Interpolation in Hiera data"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec32"/>Interpolation in Hiera data</h1></div></div></div><p>Hiera data is not restricted to <a id="id268" class="indexterm"/>literal values; it can also include the value of Facter facts or Puppet variables, as in the following example:</p><div class="informalexample"><pre class="programlisting"> backup_path: "/backup/%{facts.hostname}"</pre></div><p>Anything within the <code class="literal">%{}</code> delimiters inside a quoted string is evaluated and interpolated by Hiera. Here, we're using the dot notation to reference a value inside the <code class="literal">$facts</code> hash.</p><div class="section" title="Using lookup()"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec91"/>Using lookup()</h2></div></div></div><p>Helpfully, you <a id="id269" class="indexterm"/>can also interpolate Hiera data in Hiera data, by using the <code class="literal">lookup()</code> function as part of the value. This can save you repeating the same value many times, and can make your data more readable, as in the following example (also from <code class="literal">hiera_sample.yaml</code>):</p><div class="informalexample"><pre class="programlisting">ips:
  home: '130.190.0.1'
  office1: '74.12.203.14'
  office2: '95.170.0.75'
firewall_allow_list:
  - "%{lookup('ips.home')}"
  - "%{lookup('ips.office1')}"
  - "%{lookup('ips.office2')}"</pre></div><p>This is much more readable than simply listing a set of IP addresses with no indication of what they represent, and it prevents you accidentally introducing errors by updating a value in one place but not another. Use Hiera interpolation to make your data self-documenting.</p></div><div class="section" title="Using alias()"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec92"/>Using alias()</h2></div></div></div><p>When you use the <a id="id270" class="indexterm"/>
<code class="literal">lookup()</code> function in a Hiera string value, the result is always a string. This is fine if you're working with string data, or if you want to interpolate a Hiera value into a string containing other text. However, if you're working with arrays, hashes, or Boolean values, you need to use the <code class="literal">alias()</code> function instead. This lets you re-use any Hiera data structure within Hiera, just by referencing its name:</p><div class="informalexample"><pre class="programlisting">firewall_allow_list:
  - "%{lookup('ips.home')}"
  - "%{lookup('ips.office1')}"
  - "%{lookup('ips.office2')}"
vpn_allow_list: "%{alias('firewall_allow_list')}"</pre></div><p>Don't be fooled by the surrounding quotes: it may look as though <code class="literal">vpn_allow_list</code> will be a string value, but <a id="id271" class="indexterm"/>because we are using <code class="literal">alias()</code>, it will actually be an array, just like the value it is aliasing (<code class="literal">firewall_allow_list</code>).</p></div><div class="section" title="Using literal()"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec93"/>Using literal()</h2></div></div></div><p>Because the percent <a id="id272" class="indexterm"/>character (<code class="literal">%</code>) tells Hiera to interpolate a value, you might be wondering how to specify a literal percent sign in data. For example, Apache uses the percent sign in its configuration to refer to variable names like <code class="literal">%{HTTP_HOST}</code>. To write values like these in Hiera data, we need to use the <code class="literal">literal()</code> function, which exists only to refer to a literal percent character. For example, to write the value <code class="literal">%{HTTP_HOST}</code> as Hiera data, we would need to write:</p><div class="informalexample"><pre class="programlisting">%{literal('%')}{HTTP_HOST}</pre></div><p>You can see a more complicated example in the sample Hiera data file:</p><div class="informalexample"><pre class="programlisting">force_www_rewrite:
  comment: "Force WWW"
  rewrite_cond: "%{literal('%')}{HTTP_HOST} !^www\\. [NC]"
  rewrite_rule: "^(.*)$ https://www.%{literal('%')}{HTTP_HOST}%{literal('%')}{REQUEST_URI} [R=301,L]"</pre></div></div></div>
<div class="section" title="The hierarchy"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec33"/>The hierarchy</h1></div></div></div><p>So far, we've only used a single <a id="id273" class="indexterm"/>Hiera data source (<code class="literal">common.yaml</code>). Actually, you can have as many data sources as you like. Each usually corresponds to a YAML file, and they are listed in the <code class="literal">hierarchy</code> section of the <code class="literal">hiera.yaml</code> file, with the highest-priority source first and the lowest last:</p><div class="informalexample"><pre class="programlisting">hierarchy:
  ...
  - name: "Host-specific data"
    path: "nodes/%{facts.hostname}.yaml"
  - name: "OS release-specific data"
    path: "os/%{facts.os.release.major}.yaml"
  - name: "OS distro-specific data"
    path: "os/%{facts.os.distro.codename}.yaml"
  - name: "Common defaults"
    path: "common.yaml"</pre></div><p>In general, though, you should keep as much data as possible in the <code class="literal">common.yaml</code> file, simply because it's easier to find and maintain data if it's in one place, rather than scattered through several files.</p><p>For example, if you have some <a id="id274" class="indexterm"/>Hiera data which is only used on the <code class="literal">monitor</code> node, you might be tempted to put it in a <code class="literal">nodes/monitor.yaml</code> file. But, unless it has to override some settings in <code class="literal">common.yaml</code>, you'll just be making it harder to find and update. Put everything in <code class="literal">common.yaml</code> that you can, and reserve other data sources only for overrides to common values.</p><div class="section" title="Dealing with multiple values"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec94"/>Dealing with multiple values</h2></div></div></div><p>You may be wondering what <a id="id275" class="indexterm"/>happens if the same key is listed in more than one Hiera data source. For example, imagine the first source contains the following:</p><div class="informalexample"><pre class="programlisting">consul_node: false</pre></div><p>Also, assume that <code class="literal">common.yaml</code> contains:</p><div class="informalexample"><pre class="programlisting">consul_node: true</pre></div><p>What happens when you call <code class="literal">lookup('consul_node', Boolean)</code> with this data? There are two different values for <code class="literal">consul_node</code> in two different files, so which one does Hiera return?</p><p>The answer is that Hiera searches data sources in the order they are listed in the <code class="literal">hierarchy</code> section; that is to say, in priority order. It returns the first value found, so if there are multiple values, only the value from the first—that is, highest-priority— data source will be returned (that's the "hierarchy" part).</p></div><div class="section" title="Merge behaviors"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec95"/>Merge behaviors</h2></div></div></div><p>We said in the previous <a id="id276" class="indexterm"/>section that if there is more than one value matching the specified key, the first matching data source takes priority over the others. This is the default behavior, and this is what you'll usually want. However, sometimes you may want <code class="literal">lookup()</code> to return the union of all the matching values found, throughout the hierarchy. Hiera allows you to specify which of these strategies it should use when multiple values match your lookup.</p><p>This is called a <span class="strong"><strong>merge behavior</strong></span>, and <a id="id277" class="indexterm"/>you can specify which merge behavior you want as the third argument to <code class="literal">lookup()</code>, after the key and data type (<code class="literal">lookup_merge.pp</code>):</p><div class="informalexample"><pre class="programlisting">notice(lookup('firewall_allow_list', Array, 'unique'))</pre></div><p>The default merge behavior is called <code class="literal">first</code>, and it returns only one value, the first found value. By contrast, the <code class="literal">unique</code> merge behavior returns all the values found, as a flattened array, with duplicates removed (hence <code class="literal">unique</code>).</p><p>If you are looking up hash <a id="id278" class="indexterm"/>data, you can use the <code class="literal">hash</code> merge behavior to return a merged hash containing all the keys and values from all matching hashes found. If Hiera finds two hash keys with the same name, only the value of the first will <a id="id279" class="indexterm"/>be returned. This is known as a <span class="strong"><strong>shallow merge</strong></span>. If <a id="id280" class="indexterm"/>you want a deep merge (that is, one where matching hashes will be merged at all levels, instead of just the top level) use the <code class="literal">deep</code>
<a id="id281" class="indexterm"/>merge behavior.</p><p>If this all sounds a bit complicated, don't worry. The default merge behavior is probably what you want most of the time, and if you should happen to need one of the other behaviors instead, you can read more about it in the Puppet documentation.</p></div><div class="section" title="Data sources based on facts"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec96"/>Data sources based on facts</h2></div></div></div><p>The hierarchy mechanism lets <a id="id282" class="indexterm"/>you set common default values for all situations (usually in <code class="literal">common.yaml</code>), but override them in specific circumstances. For example, you can set a data source in the hierarchy based on the value of a Puppet fact, such as the hostname:</p><div class="informalexample"><pre class="programlisting">  - name: "Host-specific data"
    path: "nodes/%{facts.hostname}.yaml"</pre></div><p>Hiera will look up the value of the specified fact and search for a data file with that name in the <code class="literal">nodes/</code> directory. In the previous example, if the node's hostname is <code class="literal">web1</code>, Hiera will look for the data file <code class="literal">nodes/web1.yaml</code> in the Hiera data directory. If this file exists and contains the specified Hiera key, the <code class="literal">web1</code> node will receive that value for its lookup, while other nodes will get the default value from <code class="literal">common</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>Note that you can organize your Hiera data files in subdirectories under the main <code class="literal">data/</code> directory if you like, such as <code class="literal">data/nodes/</code>.</p></div></div><p>Another useful fact to reference in the hierarchy is the operating system major version or codename. This is very useful when you need your manifest to work on more than one release of the operating system. If you have more than a handful of nodes, migrating to the latest OS release is usually a gradual process, upgrading one node at a time. If something has changed from one version to the next that affects your Puppet manifest, you can use the <code class="literal">os.distro.codename</code> fact to select the appropriate Hiera data, as in the following example:</p><div class="informalexample"><pre class="programlisting">  - name: "OS-specific data"
    path: "os/%{facts.os.distro.codename}.yaml"</pre></div><p>Alternatively, you can use the <code class="literal">os.release.major</code> fact:</p><div class="informalexample"><pre class="programlisting">  - name: "OS-specific data"
    path: "os/%{facts.os.release.major}.yaml"</pre></div><p>For example, if your node is <a id="id283" class="indexterm"/>running Ubuntu 16.04 Xenial, Hiera will look for a data file named <code class="literal">os/xenial.yaml</code> (if you're using <code class="literal">os.distro.codename</code>) or <code class="literal">os/16.04.yaml</code> (if you're using <code class="literal">os.release.major</code>) in the Hiera data directory.</p><p>For more information about facts in Puppet, see <a class="link" href="ch05.html" title="Chapter 5. Variables, expressions, and facts">Chapter 5</a>, <span class="emphasis"><em>Variables, expressions, and facts</em></span>.</p></div><div class="section" title="What belongs in Hiera?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec97"/>What belongs in Hiera?</h2></div></div></div><p>What data should you put in Hiera, and <a id="id284" class="indexterm"/>what should be in your Puppet manifests? A good rule of thumb about when to separate data and code is to ask yourself what might <span class="strong"><strong>change</strong></span> in the future. For example, the exact version of a package is a good candidate for Hiera data, because it's quite likely you'll need to update it in the future.</p><p>Another characteristic of data that belongs in Hiera is that it's <span class="strong"><strong>specific</strong></span> to your site or company. If you take your Puppet manifest and give it to someone else in another company or organization, and she has to modify any values in the code to make it work at her site, then those values should probably be in Hiera. This makes it much easier to share and re-use code; all you have to do is edit some values in Hiera.</p><p>If the same data is needed in <span class="strong"><strong>more than one place</strong></span> in your manifests, it's also a good idea for that data to be stored in Hiera. Otherwise, you have to either repeat the data, which makes it harder to maintain, or use a global variable, which is bad style in any programming language, and especially so in Puppet.</p><p>If you have to change a data value when you apply your manifests on a different <span class="strong"><strong>operating system</strong></span>, that's also a candidate for Hiera data. As we've seen in this chapter, you can use the hierarchy to select the correct value based on facts, such as the operating system or version.</p><p>One other kind of data that belongs in Hiera is parameter values for classes and modules; we'll see more about that in <a class="link" href="ch07.html" title="Chapter 7. Mastering modules">Chapter 7</a>, <span class="emphasis"><em>Mastering modules</em></span>.</p></div></div>
<div class="section" title="Creating resources with Hiera data"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec34"/>Creating resources with Hiera data</h1></div></div></div><p>When we started working <a id="id285" class="indexterm"/>with Puppet, we created resources directly in the manifest using literal attribute values. In this chapter, we've seen how to use Hiera data to fill in the title and attributes of resources in the manifest. We can now take this idea one step further and create resources <span class="strong"><strong>directly from Hiera</strong></span> queries. The advantage of this method is that we can create any number of resources of any type, based purely on data.</p><div class="section" title="Building resources from Hiera arrays"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec98"/>Building resources from Hiera arrays</h2></div></div></div><p>In <a class="link" href="ch05.html" title="Chapter 5. Variables, expressions, and facts">Chapter 5</a>, <span class="emphasis"><em>Variables, expressions, and facts</em></span>, we learned how to use Puppet's <code class="literal">each</code> function to <a id="id286" class="indexterm"/>iterate over an array or hash, creating resources as we go. Let's apply this technique to some Hiera data. In our first example, we'll create some user resources from a Hiera array.</p><p>Run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo puppet apply --environment pbg /examples/hiera_users.pp</strong></span>
Notice: /Stage[main]/Main/User[katy]/ensure: created
Notice: /Stage[main]/Main/User[lark]/ensure: created
Notice: /Stage[main]/Main/User[bridget]/ensure: created
Notice: /Stage[main]/Main/User[hsing-hui]/ensure: created
Notice: /Stage[main]/Main/User[charles]/ensure: created</pre></div><p>Here's the data we're using (from the <code class="literal">/etc/puppetlabs/code/environments/pbg/data/common.yaml</code> file):</p><div class="informalexample"><pre class="programlisting">users:
  - 'katy'
  - 'lark'
  - 'bridget'
  - 'hsing-hui'
  - 'charles'</pre></div><p>And here's the code which reads it and creates the corresponding user instances (<code class="literal">hiera_users.pp</code>):</p><div class="informalexample"><pre class="programlisting">lookup('users', Array[String]).each | String $username | {
  user { $username:
    ensure =&gt; present,
  }
}</pre></div><p>Combining Hiera data with resource iteration is a powerful idea. This short manifest could manage all the users in your infrastructure, without you ever having to edit the Puppet code to make changes. To add new users, you need only edit the Hiera data.</p></div><div class="section" title="Building resources from Hiera hashes"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec99"/>Building resources from Hiera hashes</h2></div></div></div><p>Of course, real life is <a id="id287" class="indexterm"/>never quite as simple as a programming language example. If you were really managing users with Hiera data in this way, you'd need to include more data than just their names: you'd need to be able to manage shells, UIDs, and so on, and you'd also need to be able to remove the users if necessary. To do that, we will need to add some structure to the Hiera data.</p><p>Run the following <a id="id288" class="indexterm"/>command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo puppet apply --environment pbg /examples/hiera_users2.pp</strong></span>
Notice: Compiled catalog for ubuntu-xenial in environment pbg in 0.05 seconds
Notice: /Stage[main]/Main/User[katy]/uid: uid changed 1001 to 1900
Notice: /Stage[main]/Main/User[katy]/shell: shell changed '' to '/bin/bash'
Notice: /Stage[main]/Main/User[lark]/uid: uid changed 1002 to 1901
Notice: /Stage[main]/Main/User[lark]/shell: shell changed '' to '/bin/sh'
Notice: /Stage[main]/Main/User[bridget]/uid: uid changed 1003 to 1902
Notice: /Stage[main]/Main/User[bridget]/shell: shell changed '' to '/bin/bash'
Notice: /Stage[main]/Main/User[hsing-hui]/uid: uid changed 1004 to 1903
Notice: /Stage[main]/Main/User[hsing-hui]/shell: shell changed '' to '/bin/sh'
Notice: /Stage[main]/Main/User[charles]/uid: uid changed 1005 to 1904
Notice: /Stage[main]/Main/User[charles]/shell: shell changed '' to '/bin/bash'
Notice: Applied catalog in 0.17 seconds</pre></div><p>The first difference from the previous example is that instead of the data being a simple array, it's a hash of hashes:</p><div class="informalexample"><pre class="programlisting">users2:
  'katy':
    ensure: present
    uid: 1900
    shell: '/bin/bash'
  'lark':
    ensure: present
    uid: 1901
    shell: '/bin/sh'
  'bridget':
    ensure: present
    uid: 1902
    shell: '/bin/bash'
  'hsing-hui':
    ensure: present
    uid: 1903
    shell: '/bin/sh'
  'charles':
    ensure: present
    uid: 1904
    shell: '/bin/bash'</pre></div><p>Here's the code which <a id="id289" class="indexterm"/>processes that data (<code class="literal">hiera_users2.pp</code>):</p><div class="informalexample"><pre class="programlisting">lookup('users2', Hash, 'hash').each | String $username, Hash $attrs | {
  user { $username:
    * =&gt; $attrs,
  }
}</pre></div><p>Each of the keys in the <code class="literal">users2</code> hash is a username, and each value is a hash of user attributes such as <code class="literal">uid</code> and <code class="literal">shell</code>.</p><p>When we call <code class="literal">each</code> on this hash, we specify two parameters to the loop instead of one:</p><div class="informalexample"><pre class="programlisting">| String $username, Hash $attrs |</pre></div><p>As we saw in <a class="link" href="ch05.html" title="Chapter 5. Variables, expressions, and facts">Chapter 5</a>, <span class="emphasis"><em>Variables, expressions, and facts</em></span>, when iterating over a hash, these two parameters receive the hash key and its value, respectively.</p><p>Inside the loop, we create a user resource for each element of the hash:</p><div class="informalexample"><pre class="programlisting">user { $username:
  * =&gt; $attrs,
}</pre></div><p>You may recall from the previous chapter that the <code class="literal">*</code> operator (the attribute splat operator) tells Puppet to treat <code class="literal">$attrs</code> as a hash of attribute-value pairs. So the first time round the loop, with user <code class="literal">katy</code>, Puppet will create a user resource equivalent to the following manifest:</p><div class="informalexample"><pre class="programlisting">user { 'katy':
  ensure =&gt; present,
  uid    =&gt; 1900,
  shell  =&gt; '/bin/bash',
}</pre></div><p>Every time we go round the loop with the next element of <code class="literal">users</code>, Puppet will create another user resource with the specified attributes.</p></div><div class="section" title="The advantages of managing resources with Hiera data"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec100"/>The advantages of managing resources with Hiera data</h2></div></div></div><p>The previous <a id="id290" class="indexterm"/>example makes it easy to manage users across your network without having to edit Puppet code: if you want to remove a user, for example, you would simply change her <code class="literal">ensure</code> attribute in the Hiera data to <code class="literal">absent</code>. Although each of the users happens to have the same set of attributes specified, this isn't essential; you could add any attribute supported by the Puppet <code class="literal">user</code> resource to any user in the data. Also, if there's an attribute whose value is always the same for all users, you need not list it in the Hiera data for every user. You can add it as a literal attribute value of the <code class="literal">user</code> resource inside the loop, and thus every user will have it.</p><p>This makes it easier to add and update users on a routine basis, but there are other advantages too: for example, you could write a simple web application which allowed HR staff to add or edit users using a browser interface, and it would only need to output a YAML file with the <a id="id291" class="indexterm"/>required data. This is much easier and more robust than trying to generate Puppet code automatically. Even better, you could pull user data from an LDAP or <span class="strong"><strong>Active Directory</strong></span> (<span class="strong"><strong>AD</strong></span>) server and put it into <a id="id292" class="indexterm"/>Hiera YAML format for input into this manifest.</p><p>This is a very powerful and flexible technique, and of course you can use it to manage any kind of Puppet resource: files, packages, Apache virtual hosts, MySQL databases—anything you can do with a resource you can do with Hiera data and <code class="literal">each</code>. You can also use Hiera's override mechanism to create different sets of resources for different nodes, roles, or operating systems.</p><p>However, you shouldn't over-use this technique. Creating resources from Hiera data adds a layer of abstraction which makes it harder to understand the code for anyone trying to read or maintain it. With Hiera, it can also be difficult to work out from inspection exactly what data the node will get in a given set of circumstances. Keep your hierarchy as simple as possible, and reserve the data-driven resources trick for situations where you have a large and variable number of resources which you need to update frequently. In <a class="link" href="ch11.html" title="Chapter 11. Orchestrating cloud resources">Chapter 11</a>, <span class="emphasis"><em>Orchestrating cloud resources</em></span>, we'll see how to use the same technique to manage cloud instances, for example.</p></div></div>
<div class="section" title="Managing secret data"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec35"/>Managing secret data</h1></div></div></div><p>Puppet often needs to <a id="id293" class="indexterm"/>know your secrets; for example, passwords, private keys, and other credentials need to be configured on the node, and Puppet must have access to this information. The problem is how to make sure that no-one else does. If you are checking this data into a Git repo, it will be available to anybody who has access to the repo, and if it's a public GitHub repo, everybody in the world can see it.</p><p>Clearly, it's essential to be able to encrypt secret data in such a way that Puppet can decrypt it on individual nodes where it's needed, but it's indecipherable to anybody who does not have the key. The popular GnuPG encryption tool is a good choice for this. It lets you encrypt data using a public key which can be distributed widely, but only someone with the corresponding private key can decrypt the information.</p><p>Hiera has a pluggable <span class="strong"><strong>backend</strong></span> system which allows it to support various different ways of storing data. One such <a id="id294" class="indexterm"/>backend is called <code class="literal">hiera-eyaml-gpg</code>, which allows Hiera to use a GnuPG-encrypted data store. Rather than encrypting a whole data file, <code class="literal">hiera-eyaml-gpg</code> lets you mix encrypted and plaintext data in the same YAML file. That way, even someone who doesn't have the private key can still edit and update the plaintext values in Hiera data files, although the encrypted data values will be unreadable to them.</p><div class="section" title="Setting up GnuPG"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec101"/>Setting up GnuPG</h2></div></div></div><p>First, we'll need to install <a id="id295" class="indexterm"/>GnuPG and create a key pair for use with Hiera. The <a id="id296" class="indexterm"/>following instructions will help you do this:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Run the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo apt-get install gnupg rng-tools</strong></span>
</pre></div></li><li class="listitem">Once GnuPG is installed, run the following command to generate a new key pair:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>gpg --gen-key</strong></span>
</pre></div></li><li class="listitem">When prompted, select the RSA and RSA key type:<div class="informalexample"><pre class="programlisting">Please select what kind of key you want:
   (1) RSA and RSA (default)
   (2) DSA and Elgamal
   (3) DSA (sign only)
   (4) RSA (sign only)
Your selection? <span class="strong"><strong>1</strong></span>
</pre></div></li><li class="listitem">Select a 2,048 bit key size:<div class="informalexample"><pre class="programlisting">RSA keys may be between 1024 and 4096 bits long.
What keysize do you want? (2048) <span class="strong"><strong>2048</strong></span>
</pre></div></li><li class="listitem">Enter <code class="literal">0</code> for the key expiry time:<div class="informalexample"><pre class="programlisting">Key is valid for? (0) <span class="strong"><strong>0</strong></span>
Key does not expire at all
Is this correct? (y/N) <span class="strong"><strong>y</strong></span>
</pre></div></li><li class="listitem">When prompted for a real name, email address, and comment for the key, enter whatever is appropriate for your site:<div class="informalexample"><pre class="programlisting">Real name: <span class="strong"><strong>Puppet</strong></span>
Email address: <span class="strong"><strong>puppet@cat-pictures.com</strong></span>
Comment:
You selected this USER-ID:
    "Puppet &lt;puppet@cat-pictures.com&gt;"

Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? <span class="strong"><strong>o</strong></span>
</pre></div></li><li class="listitem">When prompted for a passphrase, just hit <span class="emphasis"><em>Enter</em></span> (the key can't have a passphrase, because Puppet won't be able to supply it).</li></ol></div><p>It may take a few moments <a id="id297" class="indexterm"/>to generate the key, but once this is complete, GnuPG will print out the key fingerprint and details (yours will look different):</p><div class="informalexample"><pre class="programlisting">pub   2048R/40486112 2016-09-30
      Key fingerprint = 6758 6CEE D221 7AA0 8369  FF3A FEC1 0055 4048 6112
uid                  Puppet &lt;puppet@cat-pictures.com&gt;
sub   2048R/472954EB 2016-09-30</pre></div><p>This key is now stored in your GnuPG keyring, and Hiera will be able to use it to encrypt and decrypt your secret data on this node. We'll see later in the chapter how to distribute this key to other nodes managed by Puppet.</p></div><div class="section" title="Adding an encrypted Hiera source"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec102"/>Adding an encrypted Hiera source</h2></div></div></div><p>A Hiera source using <a id="id298" class="indexterm"/>GPG-encrypted data needs a couple of extra parameters. Here's the relevant section from the example <code class="literal">hiera.yaml</code> file:</p><div class="informalexample"><pre class="programlisting">  - name: "Secret data (encrypted)"
    lookup_key: eyaml_lookup_key
    path: "secret.eyaml"
    options:
      gpg_gnupghome: '/home/ubuntu/.gnupg'</pre></div><p>As with normal data sources, we a have <code class="literal">name</code> and a <code class="literal">path</code> to the data file, but we also need to specify the <code class="literal">lookup_key</code> function, which in this case is <code class="literal">eyaml_lookup_key</code>, and set <code class="literal">options['gpg_gnupghome']</code> to point to the GnuPG directory, where the decryption key lives.</p></div><div class="section" title="Creating an encrypted secret"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec103"/>Creating an encrypted secret</h2></div></div></div><p>You're now ready to <a id="id299" class="indexterm"/>add some secret data to your Hiera store.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new empty Hiera data file with the following commands:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cd /etc/puppetlabs/code/environments/pbg</strong></span>
<span class="strong"><strong>sudo touch data/secret.eyaml</strong></span>
</pre></div></li><li class="listitem">Run the following command to edit the data file using the <code class="literal">eyaml</code> editor (which automatically encrypts the data for you when you save it). Instead of <code class="literal">puppet@cat-pictures.com</code>, use the email address that you entered when you created your GPG key.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo /opt/puppetlabs/puppet/bin/eyaml edit --gpg-always-trust --gpg-recipients=puppet@cat-pictures.com data/secret.eyaml</strong></span>
</pre></div></li><li class="listitem">If the system prompts you to select your default editor, choose the editor you prefer. If you're familiar with Vim, I recommend you choose that, but otherwise, you will probably find <code class="literal">nano</code> the easiest option. (You should learn Vim, but that's a subject for another book.)</li><li class="listitem">Your selected editor will be started with the following text already inserted in the file:<div class="informalexample"><pre class="programlisting">#| This is eyaml edit mode. This text (lines starting with #| at the top of the
#| file) will be removed when you save and exit.
#|  - To edit encrypted values, change the content of the DEC(&lt;num&gt;)::PKCS7[]!
#|    block (or DEC(&lt;num&gt;)::GPG[]!).
#|    WARNING: DO NOT change the number in the parentheses.
#|  - To add a new encrypted value copy and paste a new block from the
#|    appropriate example below. Note that:
#|     * the text to encrypt goes in the square brackets
#|     * ensure you include the exclamation mark when you copy and paste
#|     * you must not include a number when adding a new block
#|    e.g. DEC::PKCS7[]! -or- DEC::GPG[]!</pre></div></li><li class="listitem">Enter the following text below the commented message, exactly as shown, including the beginning three hyphens:<div class="informalexample"><pre class="programlisting">---
  test_secret: DEC::GPG[This is a test secret]!</pre></div></li><li class="listitem">Save the file and exit the editor.</li><li class="listitem">Run the following <a id="id300" class="indexterm"/>command to test that Puppet can read and decrypt your secret:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo puppet lookup --environment pbg test_secret</strong></span>
--- This is a test secret</pre></div></li></ol></div></div><div class="section" title="How Hiera decrypts secrets"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec104"/>How Hiera decrypts secrets</h2></div></div></div><p>To prove to <a id="id301" class="indexterm"/>yourself that the secret data is actually encrypted, run the following command to see what it looks like in the data file on disk:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cat data/secret.eyaml</strong></span>
---
  test_secret: ENC[GPG,hQEMA4+8DyxHKVTrAQf/QQPL4zD2kkU7T+FhaEdptu68RAw2m2KAXGujjnQPXoONrbh1QjtzZiJBlhqOP+7JwvzejED0NXNMkmWTGfCrOBvQlZS0U9Vrgsyq5mACPHyeLqFbdeOjNEIR7gLP99aykAmbO2mRqfXvns+cZgaTUEPXOPyipY5Q6w6/KeBEvekTIZ6ME9Oketj+1/zyDz4qWH+0nLwdD9L279d7hnokpts2tp+gpCUc0/qKsTXpdTRPE2R0kg9Bl84OP3fFlTSTgcT+pS8Dfa1/ZzALfHmULcC3hckG9ZSR+0cd6MyJzucwiJCreIfR/cDfqpsENNM6PNkTAHEHrAqPrSDXilg1KtJSAfZ9rS8KtRyhoSsk+XyrxIRH/S1Qg1dgFb8VqJzWjFl6GBJZemy7z+xjoWHyznbABVwp0KXNGgn/0idxfhz1mTo2/49POFiVF4MBo/6/EEU4cw==]</pre></div><p>Of course, the actual ciphertext will be different for you, since you're using a different encryption key. The point is, though, the message is completely scrambled. GnuPG's encryption algorithms are extremely strong; even using every computer on Earth simultaneously, it would take (on average) many times the current age of the Universe to unscramble data encrypted with a 2,048-bit key. (Or, to put it a different way, the chances of decrypting the data within a reasonable amount of time are many billions to one.)</p><p>When you reference a Hiera key such as <code class="literal">test_secret</code> in your manifest, what happens next? Hiera consults its list of data sources configured in <code class="literal">hiera.yaml</code>. The first source in the hierarchy is <code class="literal">secret.eyaml</code>, which contains the key we're interested in (<code class="literal">test_secret</code>). Here's the value:</p><div class="informalexample"><pre class="programlisting">ENC[GPG,hQEMA4 … EEU4cw==]</pre></div><p>The <code class="literal">ENC</code> tells Hiera that this is an encrypted value, and the <code class="literal">GPG</code> identifies which type of encryption is being used (<code class="literal">hiera-eyaml</code> supports several encryption methods, of which GPG is one). Hiera calls the GPG subsystem to process the encrypted data, and GPG searches the keyring to find the appropriate decryption key. Assuming it finds the key, GPG decrypts the data and passes the result back to Hiera, which returns it to Puppet, and the result is the plaintext:</p><div class="informalexample"><pre class="programlisting">This is a test secret</pre></div><p>The beauty of the system is <a id="id302" class="indexterm"/>that all of this complexity is hidden from you; all you have to do is call the function <code class="literal">lookup('test_secret', String)</code> in your manifest, and you get the answer.</p></div><div class="section" title="Editing or adding encrypted secrets"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec105"/>Editing or adding encrypted secrets</h2></div></div></div><p>If the secret <a id="id303" class="indexterm"/>data is stored in encrypted form, you might be wondering how to edit it when you want to change the secret value. Fortunately, there's a <a id="id304" class="indexterm"/>way to do this. Recall that when you first entered the secret data, you used the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo /opt/puppetlabs/puppet/bin/eyaml edit --gpg-always-trust --gpg-recipients=puppet@cat-pictures.com data/secret.eyaml</strong></span>
</pre></div><p>If you run the same command again, you'll find that you're looking at your original plaintext (along with some explanatory comments):</p><div class="informalexample"><pre class="programlisting">---
  test_secret: DEC(1)::GPG[This is a test secret]!</pre></div><p>You can edit the <code class="literal">This is a test secret</code> string (make sure to leave everything else exactly as it is, including the <code class="literal">DEC::GPG[]!</code> delimiters). When you save the file and close the editor, the data will be re-encrypted using your key, if it has changed.</p><p>Don't remove the <code class="literal">(1)</code> in parentheses after <code class="literal">DEC</code>; it tells Hiera that this is an existing secret, not a new one. As you add more secrets to this file, they will be identified with increasing numbers.</p><p>For convenience of editing, I suggest you make a shell script, called something like <code class="literal">/usr/local/bin/eyaml_edit</code>, which runs the <code class="literal">eyaml edit</code> command. There's an example on your Vagrant box, at <code class="literal">/examples/eyaml_edit.sh</code>, which you can copy to <code class="literal">/usr/local/bin</code> and edit (as before, substitute the <code class="literal">gpg-recipients</code> email address with the one associated with your GPG key):</p><div class="informalexample"><pre class="programlisting">#!/bin/bash
/opt/puppetlabs/puppet/bin/eyaml edit --gpg-always-trust --gpg-recipients=puppet@cat-pictures.com /etc/puppetlabs/code/environments/pbg/data/secret.eyaml</pre></div><p>Now, whenever you need to edit your secret data, you can simply run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo eyaml_edit</strong></span>
</pre></div><p>To add a new secret, add a line like this:</p><div class="informalexample"><pre class="programlisting">  new_secret: DEC::GPG[Somebody wake up Hicks]!</pre></div><p>When you save and <a id="id305" class="indexterm"/>quit the editor, the newly-encrypted <a id="id306" class="indexterm"/>secret will be stored in the data file.</p></div><div class="section" title="Distributing the decryption key"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec106"/>Distributing the decryption key</h2></div></div></div><p>Now that your Puppet <a id="id307" class="indexterm"/>manifests use encrypted Hiera data, you'll need to make sure that each node running Puppet has a copy of the decryption key. Export the key to a text file using the following command (use your key's email address, of course):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo sh -c 'gpg --export-secret-key -a puppet@cat-pictures.com &gt;key.txt'</strong></span>
</pre></div><p>Copy the <code class="literal">key.txt</code> file to any nodes which need the key, and run the following command to import it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo gpg --import key.txt</strong></span>
<span class="strong"><strong>sudo rm key.txt</strong></span>
</pre></div><p>Make sure that you delete all copies of the text file once you have imported the key.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>
<span class="strong"><strong>Important note</strong></span>
</p><p>Because all Puppet nodes have a copy of the decryption key, this method only protects your secret data from someone who does not have access to the nodes. It is still considerably better than putting secret data in your manifests in plaintext, but it has the disadvantage that someone with access to a node can decrypt, modify, and re-encrypt the secret data. For improved security you should use a secrets management system where the node does not have the key, and Puppet has read-only access to secrets. Some options here include Vault, from Hashicorp, and Summon, from Conjur.</p></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec36"/>Summary</h1></div></div></div><p>In this chapter we've outlined some of the problems with maintaining configuration data in Puppet manifests, and introduced Hiera as a powerful solution. We've seen how to configure Puppet to use the Hiera data store, and how to query Hiera keys in Puppet manifests using <code class="literal">lookup()</code>.</p><p>We've looked at how to write Hiera data sources, including string, array, and hash data structures, and how to interpolate values into Hiera strings using <code class="literal">lookup()</code>, including Puppet facts and other Hiera data, and how to duplicate Hiera data structures using <code class="literal">alias()</code>. We've learned how Hiera's hierarchy works, and how to configure it using the <code class="literal">hiera.yaml</code> file.</p><p>We've seen how our example Puppet infrastructure is configured to use Hiera data, and demonstrated the process by looking up a data value in a Puppet manifest. In case of problems, we also looked at some common Hiera errors, and we've discussed rules of thumb about when to put data into Hiera.</p><p>We've explored using Hiera data to create resources, using an <code class="literal">each</code> loop over an array or hash. Finally, we've covered using encrypted data with Hiera, using the <code class="literal">hiera-eyaml-gpg</code> backend, and we've seen how to create a GnuPG key and use it to encrypt a secret value, and retrieve it again via Puppet. We've explored the process Hiera uses to find and decrypt secret data, developed a simple script to make it easy to edit encrypted data files, and outlined a basic way to distribute the decryption key to multiple nodes.</p><p>In the next chapter, we'll look at how to find and use public modules from Puppet Forge; how to use public modules to manage software including Apache, MySQL, and archive files; how to use the <code class="literal">r10k</code> tool to deploy and manage third-party modules; and how to write and structure your own modules.</p></div></body></html>