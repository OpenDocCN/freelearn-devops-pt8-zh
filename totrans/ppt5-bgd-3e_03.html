<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Managing your Puppet code with Git"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Managing your Puppet code with Git</h1></div></div></div><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><span class="emphasis"><em>We define ourselves by our actions. With each decision, we tell ourselves and the world who we are.</em></span></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<span class="attribution"><span class="emphasis"><em>Bill Watterson</em></span></span></td></tr></table></div><p>In this chapter, you'll learn how to use the Git version control system to manage your Puppet manifests. I'll also show you how to use Git to distribute the manifests to multiple nodes, so that you can start managing your whole network with Puppet.</p><div class="mediaobject"><img src="graphics/B08880_03_01.jpg" alt="Managing your Puppet code with Git"/></div><div class="section" title="What is version control?"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>What is version control?</h1></div></div></div><p>If you're already familiar <a id="id55" class="indexterm"/>with Git, you can save some reading by skipping ahead to the <span class="emphasis"><em>Creating a Git repo</em></span> section. If not, here's a gentle introduction.</p><p>Even if you're the only person who works on a piece of source code (for example, Puppet manifests), it's still useful to be able to see what changes you made, and when. For example, you might realize that you introduced a bug at some point in the past, and you need to examine exactly when a certain file was modified and exactly what the change was. A version control system lets you do that, by keeping a complete history of the changes you've made to a set of files over time.</p><div class="section" title="Tracking changes"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec13"/>Tracking changes</h2></div></div></div><p>When you're working on <a id="id56" class="indexterm"/>code with others, you also need a way to communicate with the rest of the team about your changes. A version control tool such as Git not only tracks everyone's changes, but lets you record a <span class="strong"><strong>commit message</strong></span>, explaining what <a id="id57" class="indexterm"/>you did and why. The following example illustrates some aspects of a good commit message:</p><div class="informalexample"><pre class="programlisting">Summarize changes in around 50 characters or less

More detailed explanatory text, if necessary. Wrap it to about 72
characters or so. In some contexts, the first line is treated as
the subject of the commit and the rest of the text as the body.
The blank line separating the summary from the body is critical
(unless you omit the body entirely); various tools like `log`,
`shortlog`, and `rebase` can get confused if you run the two together.

Explain the problem that this commit is solving. Focus on why you
are making this change as opposed to how (the code explains that).
Are there side effects or other unintuitive consequences of this
change? Here's the place to explain them.

Further paragraphs come after blank lines.

 - Bullet points are okay, too

 - Typically a hyphen or asterisk is used for the bullet, preceded
   by a single space, with blank lines in between, but conventions
   vary here

If you use an issue tracker, put references to them at the bottom,
like this:

Resolves: #123
See also: #456, #789</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>This example is taken from Chris Beams' excellent blog post on <span class="emphasis"><em>How to Write a Git Commit Message</em></span>:</p><p>
<a class="ulink" href="https://chris.beams.io/posts/git-commit/">https://chris.beams.io/posts/git-commit/</a>
</p><p>Of course, you won't often need such a long and detailed message; most of the time, a single line will suffice. However, it's better to give more information than less.</p></div></div><p>Git also records when the change happened, who made it, what files were changed, added, or deleted, and which lines were added, altered, or removed. As you can imagine, if you're trying to track down a bug, and you can see a complete history of changes to the code, that's a big help. It also means you can, if necessary, roll back the state of the code to any point in history and examine it.</p><p>You might think this introduces a lot of extra complication. In fact, it's very simple. Git keeps out of your way until you need it, and all you have to do is write a commit message when you decide to record <a id="id58" class="indexterm"/>changes to the code.</p></div><div class="section" title="Sharing code"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec14"/>Sharing code</h2></div></div></div><p>A set of files under Git <a id="id59" class="indexterm"/>version control is called a <span class="strong"><strong>repository</strong></span>, which is usually equivalent to a project. A Git repository (from now on, just <span class="strong"><strong>repo</strong></span>) is also a great way to <a id="id60" class="indexterm"/>distribute your code to others, whether privately or publicly, so that they <a id="id61" class="indexterm"/>can use it, modify it, contribute changes back to you, or develop it in a different direction for their own requirements. The public GitHub repo for this book which we looked at in <a class="link" href="ch01.html" title="Chapter 1. Getting started with Puppet">Chapter 1</a>, <span class="emphasis"><em>Getting started with Puppet</em></span> is a good example of this. You'll be able to use this repo for working through examples throughout the book, but you can also use it for help and inspiration when building Puppet manifests for your own infrastructure.</p><p>Because Git is so important for managing Puppet code, it's a good idea to get familiar with it, and the only way to do that is to use it for real. So let's start a new Git repo we can use to experiment with.</p></div></div></div>
<div class="section" title="Creating a Git repo"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Creating a Git repo</h1></div></div></div><p>It's very easy to <a id="id62" class="indexterm"/>create a Git repo. Follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Make a directory to hold your versioned files using the following commands:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cd</strong></span>
<span class="strong"><strong>mkdir puppet</strong></span>
</pre></div></li><li class="listitem">Now run the following <a id="id63" class="indexterm"/>commands to turn the directory into a Git repo:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cd puppet</strong></span>
<span class="strong"><strong>git init</strong></span>
Initialized empty Git repository in /home/ubuntu/puppet/.git/</pre></div></li></ol></div><div class="section" title="Making your first commit"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec15"/>Making your first commit</h2></div></div></div><p>You can change the <a id="id64" class="indexterm"/>files in your repo as much as you like, but Git will not know about the changes until you make what's called a <span class="strong"><strong>commit</strong></span>. You can think of a <a id="id65" class="indexterm"/>commit as being like a snapshot of the repo at a particular moment, but it also stores information about what changed in the repo since the previous commit. Commits are stored forever, so you will always be able to roll back the repo to the state it was in at a certain commit, or show what files were changed in a past commit and compare them to the state of the repo at any other commit.</p><p>Let's make our first commit to the new repo:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Because Git records not only changes to the code, but also who made them, it needs to know who you are. Set your identification details for Git (use your own name and email address, unless you particularly prefer mine) using the following commands:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>git config --global user.name "John Arundel"</strong></span>
<span class="strong"><strong>git config --global user.email john@bitfieldconsulting.com</strong></span>
</pre></div></li><li class="listitem">It's traditional for Git repos to have a <code class="literal">README</code> file, which explains what's in the repo and how to use it. For the moment, let's just create this file with a placeholder message:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>echo "Watch this space... coming soon!" &gt;README.md</strong></span>
</pre></div></li><li class="listitem">Run the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>git status</strong></span>
On branch master
Initial commit
Untracked files:
  (use "git add &lt;file&gt;..." to include in what will be committed)
        README.md
nothing added to commit but untracked files present (use "git add" to track)</pre></div></li><li class="listitem">Because we've added a new file to the repo, changes to it won't be tracked by Git unless we explicitly tell it to. We do this by using the <code class="literal">git add</code> command, as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>git add README.md</strong></span>
</pre></div></li><li class="listitem">Git now knows about this file, and changes to it will be included in the next commit. We can check <a id="id66" class="indexterm"/>this by running <code class="literal">git status</code> again:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>git status</strong></span>
On branch master
Initial commit
Changes to be committed:
  (use "git rm --cached &lt;file&gt;..." to unstage)
        new file:   README.md</pre></div></li><li class="listitem">The file is listed under <code class="literal">Changes to be committed</code>, so we can now actually make the commit:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>git commit -m 'Add README file'</strong></span>
[master (root-commit) ee21595] Add README file
 1 file changed, 1 insertion(+)
 create mode 100644 README.md</pre></div></li><li class="listitem">You can always see the complete history of commits in a repo by using the <code class="literal">git log</code> command. Try it now to see the commit you just made:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>git log</strong></span>
commit ee215951199158ef28dd78197d8fa9ff078b3579
Author: John Arundel &lt;john@bitfieldconsulting.com&gt;
Date:   Tue Aug 30 05:59:42 2016 -0700
    Add README file</pre></div></li></ol></div></div><div class="section" title="How often should I commit?"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec16"/>How often should I commit?</h2></div></div></div><p>A common practice is to <a id="id67" class="indexterm"/>commit when the code is in a consistent, working state, and have the commit include a set of related changes made for some particular purpose. So, for example, if you are working to fix bug number 75 in your issue-tracking system, you might make changes to quite a few separate files and then, once you're happy the work is complete, make a single commit with a message such as:</p><div class="informalexample"><pre class="programlisting">Make nginx restart more reliable (fixes issue #75)</pre></div><p>On the other hand, if you are <a id="id68" class="indexterm"/>making a large number of complicated changes and you are not sure when you'll be done, it might be wise to make a few separate commits along the way, so that if necessary you can roll the code back to a previous state. Commits cost nothing, so when you feel a commit is needed, go ahead and make it.</p></div><div class="section" title="Branching"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec17"/>Branching</h2></div></div></div><p>Git has a powerful feature <a id="id69" class="indexterm"/>called <span class="strong"><strong>branching</strong></span>, which lets you create a parallel copy of the code (a branch) and make changes to it independently. At any time, you can choose to merge <a id="id70" class="indexterm"/>those changes back into the master branch. Or, if changes have been made to the master branch in the meantime, you can incorporate those into your working branch and carry on.</p><p>This is extremely useful when working with Puppet, because it means you can switch a single node to your branch while you're testing it and working on it. The changes you make won't be visible to other nodes which aren't on your branch, so there's no danger of accidentally rolling out changes before you're ready.</p><p>Once you're done, you can merge your changes back into master and have them roll out to all nodes.</p><p>Similarly, two or more people can work independently on their own branches, exchanging individual commits with each other and with the master branch as they choose. This is a very flexible and useful way of working.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>For more information about Git branching, and indeed about Git in general, I recommend the excellent book '<span class="emphasis"><em>Pro Git</em></span>', by <span class="emphasis"><em>Scott Chacon</em></span> and <span class="emphasis"><em>Ben Straub</em></span>, published by <span class="emphasis"><em>Apress</em></span>. The whole book is available for free at <a class="ulink" href="https://git-scm.com/book/en/v2">https://git-scm.com/book/en/v2</a>.</p></div></div></div></div>
<div class="section" title="Distributing Puppet manifests"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Distributing Puppet manifests</h1></div></div></div><p>So far in this book we've <a id="id71" class="indexterm"/>only applied Puppet manifests to one node, using <code class="literal">puppet apply</code> with a local copy of the manifest. To manage several nodes at once, we need to distribute the Puppet manifests to each node so that they can be applied.</p><p>There are several ways to do this, and as we saw in <a class="link" href="ch01.html" title="Chapter 1. Getting started with Puppet">Chapter 1</a>, <span class="emphasis"><em>Getting started with Puppet</em></span>, one approach is to use the <span class="strong"><strong>agent/master</strong></span> architecture, where a central Puppet master server compiles your <a id="id72" class="indexterm"/>manifests and distributes the <span class="strong"><strong>catalog</strong></span> (the desired node state) to all nodes.</p><p>Another way to use Puppet is to do without the master server altogether, and use Git to distribute manifests to client nodes, which then runs <code class="literal">puppet apply</code> to update their configuration. This <span class="strong"><strong>stand-alone</strong></span> Puppet architecture doesn't require a dedicated Puppet master server, and there's no single point of failure.</p><p>Both agent/master and <a id="id73" class="indexterm"/>stand-alone architectures are officially supported by Puppet, and it's possible to change from one to the other if you decide you need to. The examples in this book were developed with the stand-alone architecture, but will work just as well with agent/master if you prefer it. There is no difference in the Puppet manifests, language, or structure; the only difference is in the way the manifests are applied.</p><p>All you need for a stand-alone Puppet architecture is a Git server which each node can connect to and clone the repo. You can run your own Git server if you like, or use a public Git hosting service such as GitHub. For ease of explanation, I'm going to use GitHub for this example setup.</p><p>In the following sections, we'll create a GitHub account, push our new Puppet repo to GitHub, and then set up our virtual machine to automatically pull any changes from the GitHub repo and apply them with Puppet.</p><div class="section" title="Creating a GitHub account and project"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec18"/>Creating a GitHub account and project</h2></div></div></div><p>If you already have a <a id="id74" class="indexterm"/>GitHub account, or you're using another Git server, you can skip this section.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Browse to <a class="ulink" href="https://github.com/">https://github.com/</a></li><li class="listitem">Enter the username you want to use, your email address, and a password.</li><li class="listitem">Choose the <span class="strong"><strong>Unlimited public repositories for free</strong></span> plan.</li><li class="listitem">GitHub will send you an email to verify your email address. When you get the email, click on the verification link.</li><li class="listitem">Select <span class="strong"><strong>Start a project</strong></span>.</li><li class="listitem">Enter a name for your repo (I suggest <code class="literal">puppet</code>, but it doesn't matter).</li><li class="listitem">Free GitHub accounts can only create public repos, so select <span class="strong"><strong>Public</strong></span>.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip07"/>Tip</h3><p>Be careful what information you put into a public Git repo, because it can be read by anybody. Never put passwords, login credentials, private keys, or other confidential information into a repo like this unless it is encrypted. We'll see how to encrypt secret information in your Puppet repo in <a class="link" href="ch06.html" title="Chapter 6. Managing data with Hiera">Chapter 6</a>, <span class="emphasis"><em>Managing data with Hiera</em></span>.</p></div></div></li><li class="listitem">Click <span class="strong"><strong>Create repository</strong></span>.</li><li class="listitem">GitHub will show you a page of instructions about how to initialize or import code into your new <a id="id75" class="indexterm"/>repository. Look for the <code class="literal">https</code> URL which identifies your repo; it will be something like this (<code class="literal">https://github.com/pbgtest/puppet.git</code>):<div class="mediaobject"><img src="graphics/B08880_03_02.jpg" alt="Creating a GitHub account and project"/></div></li></ol></div></div><div class="section" title="Pushing your repo to GitHub"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec19"/>Pushing your repo to GitHub</h2></div></div></div><p>You're now <a id="id76" class="indexterm"/>ready to take the Git repo you created locally <a id="id77" class="indexterm"/>earlier in this chapter and push it to GitHub so that you can share it with other nodes.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In your repo directory, run the following commands. After <code class="literal">git remote add origin</code>, specify the URL to your GitHub repo:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>git remote add origin YOUR_REPO_URL</strong></span>
<span class="strong"><strong>git push -u origin master</strong></span>
</pre></div></li><li class="listitem">GitHub <a id="id78" class="indexterm"/>will prompt you for your username <a id="id79" class="indexterm"/>and password:<div class="informalexample"><pre class="programlisting">Username for 'https://github.com': <span class="strong"><strong>pbgtest</strong></span>
Password for 'https://pbgtest@github.com':
Counting objects: 3, done.
Writing objects: 100% (3/3), 262 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://github.com/pbgtest/puppet.git
 * [new branch]      master -&gt; master
Branch master set up to track remote branch master from origin.</pre></div></li><li class="listitem">You can check that everything has worked properly by visiting the repo URL in your browser. It should look something like this:<div class="mediaobject"><img src="graphics/B08880_03_03.jpg" alt="Pushing your repo to GitHub"/></div></li></ol></div></div><div class="section" title="Cloning the repo"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec20"/>Cloning the repo</h2></div></div></div><p>In order to manage <a id="id80" class="indexterm"/>multiple nodes with Puppet, you will need a copy of the <a id="id81" class="indexterm"/>repo on each node. If you have a node you'd like to manage with Puppet, you can use it in this example. Otherwise, use the Vagrant box we've been working with in previous chapters.</p><p>Run the following <a id="id82" class="indexterm"/>commands (replace the argument to <code class="literal">git clone</code> with the URL of your own GitHub repo, but don't lose the <code class="literal">production</code> at the end):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cd /etc/puppetlabs/code/environments</strong></span>
<span class="strong"><strong>sudo mv production production.sample</strong></span>
<span class="strong"><strong>sudo git clone YOUR_REPO_URL production</strong></span>
Cloning into 'production'...
remote: Counting objects: 3, done.
remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), done.
Checking connectivity... done.</pre></div><p>How does this work? The standard place for Puppet manifests in a production environment is the <code class="literal">/etc/puppetlabs/code/environments/production/</code> directory, so that's where our cloned repo <a id="id83" class="indexterm"/>needs to end up. However, the Puppet package installs some sample manifests in that directory, and Git will refuse to clone into a directory that already exists, so we move that directory out of the way with the <code class="literal">mv production production.sample</code> command. The <code class="literal">git clone</code> command then recreates that directory, but this time it contains our manifests from the repo.</p></div></div>
<div class="section" title="Fetching and applying changes automatically"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Fetching and applying changes automatically</h1></div></div></div><p>In a stand-alone <a id="id84" class="indexterm"/>Puppet architecture, each node needs to automatically <a id="id85" class="indexterm"/>fetch any changes from the Git repo at regular intervals, and apply them with Puppet. We can use a simple shell script for this, and there's one in the example repo (<code class="literal">/examples/files/run-puppet.sh</code>):</p><div class="informalexample"><pre class="programlisting">#!/bin/bash
cd /etc/puppetlabs/code/environments/production &amp;&amp; git pull
/opt/puppetlabs/bin/puppet apply manifests/</pre></div><p>We will need to install this script on the node to be managed by Puppet, and create a cron job to run it regularly (I suggest every 15 minutes). Of course, we could do this work manually, but isn't this book partly about the advantages of automation? Very well, then: let's practice what we're preaching.</p><div class="section" title="Writing a manifest to set up regular Puppet runs"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec21"/>Writing a manifest to set up regular Puppet runs</h2></div></div></div><p>In this section, we'll <a id="id86" class="indexterm"/>create the necessary Puppet manifests to install the <code class="literal">run-puppet</code> script on a node and run it regularly from cron:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Run the following commands to create the required directories in your Puppet repo:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cd /home/ubuntu/puppet</strong></span>
<span class="strong"><strong>mkdir manifests files</strong></span>
</pre></div></li><li class="listitem">Run the following command to copy the <code class="literal">run-puppet</code> script from the <code class="literal">examples/</code> directory:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cp /examples/files/run-puppet.sh files/</strong></span>
</pre></div></li><li class="listitem">Run the following command to copy the <code class="literal">run-puppet</code> manifest from the <code class="literal">examples/</code> directory:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cp /ubuntu/examples/run-puppet.pp manifests/</strong></span>
</pre></div></li><li class="listitem">Add and commit the files to Git with the following commands:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>git add manifests files</strong></span>
<span class="strong"><strong>git commit -m 'Add run-puppet script and cron job'</strong></span>
<span class="strong"><strong>git push origin master</strong></span>
</pre></div></li></ol></div><p>Your Git repo now contains everything you need to automatically pull and apply changes on your managed nodes. In the next section, we'll see how to set up this process on a node.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>You might have noticed that every time you push files to your GitHub repo, Git prompts you for your username and password. If you want to avoid this, you can associate an SSH key with your GitHub account. Once you've done this, you'll be able to push without having to re-enter your credentials every time. For more information about using an SSH key with your GitHub account see this article:</p><p>
<a class="ulink" href="https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/">https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/</a>
</p></div></div></div><div class="section" title="Applying the run-puppet manifest"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec22"/>Applying the run-puppet manifest</h2></div></div></div><p>Having created <a id="id87" class="indexterm"/>and pushed the manifest necessary to set up automatic Puppet runs, we now need to pull and apply it on the target node.</p><p>In the cloned copy of your repo in <code class="literal">/etc/puppetlabs/code/environments/production</code>, run the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo git pull</strong></span>
<span class="strong"><strong>sudo puppet apply manifests/</strong></span>
Notice: Compiled catalog for localhost in environment production in 0.08 seconds
Notice: /Stage[main]/Main/File[/usr/local/bin/run-puppet]/ensure: defined content as '{md5}83a6903e69564bcecc8fd1a83b1a7beb'
Notice: /Stage[main]/Main/Cron[run-puppet]/ensure: created
Notice: Applied catalog in 0.07 seconds</pre></div><p>You can see from Puppet's output that it has created the <code class="literal">/usr/local/bin/run-puppet</code> script and the <code class="literal">run-puppet</code> cron job. This will now run automatically every 15 minutes, pull any new changes from the Git repo, and apply the updated manifest.</p></div><div class="section" title="The run-puppet script"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec23"/>The run-puppet script</h2></div></div></div><p>The <code class="literal">run-puppet</code> script <a id="id88" class="indexterm"/>does the following two things in order to automatically <a id="id89" class="indexterm"/>update the target node:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Pull any changes from the Git server (<code class="literal">git pull</code>).</li><li class="listitem">Apply the manifest (<code class="literal">puppet apply</code>).</li></ol></div><p>Our Puppet manifest in <code class="literal">run-puppet.pp</code> deploys this script to the target node, using a <code class="literal">file</code> resource, and then sets up a cron job to run it every 15 minutes, using a <code class="literal">cron</code> resource. We haven't met the <code class="literal">cron</code> resource before, but we will cover it in more detail in <a class="link" href="ch04.html" title="Chapter 4. Understanding Puppet resources">Chapter 4</a>, <span class="emphasis"><em>Understanding Puppet resources</em></span>.</p><p>For now, just note that the <code class="literal">cron</code> resource has a name (<code class="literal">run-puppet</code>), which is just for the benefit of us humans, to remind us what it does, and it also has a <code class="literal">command</code> to run and <code class="literal">hour</code> and <code class="literal">minute</code> attributes to control when it runs. The value <code class="literal">*/15</code> tells <code class="literal">cron</code> to run the job every 15 minutes.</p></div><div class="section" title="Testing automatic Puppet runs"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Testing automatic Puppet runs</h2></div></div></div><p>To prove that the <a id="id90" class="indexterm"/>automatic Puppet run works, make a change to your manifest which creates a file (<code class="literal">/tmp/hello.txt</code>, for example). Commit and push this change to Git. Wait 15 minutes, and check your target node. The file should be present. If not, something is broken. To troubleshoot the problem, try running <code class="literal">sudo run-puppet</code> manually. If this works, check that the cron job is correctly installed by running <code class="literal">sudo crontab -l</code>. It should look something like the following:</p><div class="informalexample"><pre class="programlisting"># HEADER: This file was autogenerated at 2017-04-05 01:46:03 -0700 by puppet.
# HEADER: While it can still be managed manually, it is definitely not recommended.
# HEADER: Note particularly that the comments starting with 'Puppet Name' should
# HEADER: not be deleted, as doing so could cause duplicate cron jobs.
# Puppet Name: run-puppet
*/15 * * * * /usr/local/bin/run-puppet</pre></div></div><div class="section" title="Managing multiple nodes"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Managing multiple nodes</h2></div></div></div><p>You now have a <a id="id91" class="indexterm"/>fully automated stand-alone Puppet infrastructure. Any change that you check in to your Git repo will be automatically applied to all nodes under Puppet management. To add more nodes to your infrastructure, follow these steps for each new node:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Install Puppet (not necessary if you're using the Vagrant box).</li><li class="listitem">Clone your Git repo (as described in the <span class="emphasis"><em>Cloning the repo</em></span> section).</li><li class="listitem">Apply the manifest (as described in the <span class="emphasis"><em>Applying the run-puppet manifest</em></span> section).</li></ol></div><p>You might be wondering how to tell Puppet how to apply different manifests to different nodes. For example, you might be managing two nodes, one of which is a web server and the other a database server. Naturally, they will need different resources.</p><p>We'll learn more about nodes and how to control the application of resources to different nodes in <a class="link" href="ch08.html" title="Chapter 8. Classes, roles, and profiles">Chapter 8</a>, <span class="emphasis"><em>Classes, roles, and profiles</em></span>, but first, we need to learn about Puppet's resources and how to use them. We'll do that in the next chapter.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Summary</h1></div></div></div><p>In this chapter, we introduced the concepts of version control, and the essentials of Git in particular. We set up a new Git repo, created a GitHub account, pushed our code to it, and cloned it on a node. We wrote a shell script to automatically pull and apply changes from the GitHub repo on any node, and a Puppet manifest to install this script and run it regularly from <code class="literal">cron</code>.</p><p>In the next chapter, we'll explore the power of Puppet resources, going into more detail about the Puppet <code class="literal">file</code>, <code class="literal">package</code>, and <code class="literal">service</code> resources we've already encountered, and introducing three more important resource types: <code class="literal">user</code>, <code class="literal">cron</code>, and <code class="literal">exec</code>.</p></div></body></html>