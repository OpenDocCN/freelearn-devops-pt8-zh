<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Developing Cloud Functions</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will deliver an overview of Google Cloud Functions. It will provide you with a good understanding of the what, why, and how of Google Cloud Functions. Knowing the basis for any technology and its use case will assist with integration and application in the real world.</p>
<p class="mce-root"><span><span>To achieve this outcome, we will again build an application throughout the chapter to illustrate some critical aspects of Cloud Functions. </span></span></p>
<p>The topics covered in this chapter include the following:</p>
<ul>
<li>Introducing Google Cloud Functions</li>
<li>Developing with the Functions Framework</li>
<li>Exploring the Cloud Functions workflow</li>
<li>Understanding the HTTP protocol</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, to complete the exercises, you will require a Google Cloud project or a Qwiklabs account.</p>
<p class="mce-root">You can find the code files of this chapter in the GitHub repository for the book under the <kbd>ch04</kbd> <span>subdirectory </span>at <a href="https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch04">https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch04</a>.<a href="https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud-Platform"/></p>
<div class="mce-root packt_infobox">While you are going through code snippets in the book, you will notice that, in a few instances, a few lines from the code/outputs have been removed and replaced with ellipses (<kbd>...</kbd>). The use of ellipses is to show only <span>relevant code/output. The complete code is available on GitHub at the preceding link.</span></div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing Google Cloud Functions</h1>
                </header>
            
            <article>
                
<p>The description of Cloud Functions on Google Cloud indicates an event-driven serverless compute platform. What this means is that functions are triggered either by HTTP endpoints or via a background service (for example, Google Cloud Storage or Cloud Pub/Sub and other sources within Google Cloud). Operationally, Cloud Functions are <em>single-use</em> pieces of code that are quick to deploy and provide the <em>glue</em> between multiple services. The exciting aspect of Cloud Functions is that they can be stitched together quite easily in the same way a traditional application would be. It is entirely feasible to create a couple of HTTP endpoint functions that link through to a Cloud Pub/Sub backend, and by keeping your service simple, the build can quickly complete.</p>
<p>While the default setting for functions is public, authentication can be enabled for features to secure the environment in which they operate. Cloud Functions are executed using a service account and are, therefore, configurable via Google Cloud <strong>Identity and Access Management</strong> (<strong>IAM</strong>). It is important to note that functions do not share memory space, which means an isolated context for each instance executed.</p>
<p>Additionally, it is essential to note that functions are stateless in nature; they are therefore not expected to persist information within the Cloud Function.</p>
<div class="packt_tip">The exception to this is scenario is something like persisting a database connection that should be stored globally in code. Doing this means the next Cloud Function invocation doesn't need to introduce any additional latency retrieving the connection information.</div>
<p>Further to this, the following properties are central to the DNA of Cloud Functions:</p>
<ul>
<li><span>They operate in a secure operation context.</span></li>
<li><span>They don't share memory across functions.</span></li>
<li><span>No state is maintained.</span></li>
</ul>
<p><span>Working with Cloud Functions provides an excellent way to execute single-purpose Cloud Functions without needing to spend a lifetime coding an application. Further use cases exist and are denoted in the following section.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the use cases</h1>
                </header>
            
            <article>
                
<p>As developers have become more exposed to cloud infrastructure, an exciting outcome is the evolution of lightweight functions. Consider the applications you use daily and how they have matured over time. How many of these now feature an HTTP endpoint that can be used independently from the application? What would happen if everything became an API; how cool would that be? Situations such as these are analogous to the processing of logs in which records were held internally in a proprietary format. Then someone had the bright idea to export application data to a centralized solution to capture information. A tipping point occurred, and we all adopted this typical pattern as the de-facto mechanism for the management of logging.</p>
<p>Back to Cloud Functions â€“ consider how much more convenient it is to develop an application when you have standard solutions and patterns that can easily integrate with your resolution. Also, consider the level of design required upfront to ensure that an application retains a degree of compatibility. Working with a protocol such as HTTP provides a very well-understood interface that is recognized by a wide range of people. Having a typical frame of reference provides an excellent method of moving the industry forward, and HTTP provides just the vehicle for adoption and propagation of the development of abstracted interfaces. So, <span>we'll reflect on</span> the types of use cases that Cloud Functions are most appropriate for <span>over the next couple of sections.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Processing with backend services</h1>
                </header>
            
            <article>
                
<p>Backend serverless compute is triggered by services such as Cloud Pub/Sub and Cloud Storage. The scope of these services is made more interesting by the prospect of being able to integrate different Google Cloud services with your Cloud Functions.</p>
<p>We already know that we can use <span>Cloud Functions </span>for many scenarios. As outlined previously in the use case introduction, serverless backend processing is an excellent use case for this solution. In this situation, the Cloud Function design addresses a request to provide specific information. This request presents a particular signature of the service that encapsulates the information necessary to complete processing some arbitrary data. At the outset of this processing, the function responds to indicate it has completed the assigned activity. The response can note success or failure; however, in terms of the service, its life cycle is complete, and it will fade out of existence.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Processing with real-time data</h1>
                </header>
            
            <article>
                
<p>Another scenario that sits well with serverless compute is that of real-time data processing. In this situation, Cloud Functions' on-demand provisioning enables them to meet processing requirements for a service designed against minimal latency. As we discussed earlier in the book, it may be useful to understand several attributes before the development of a solution. The ability to quickly provision infrastructure in a short amount of time is a significant factor for solutions requiring real-time processing. Cloud Functions support a startup time of less than 2.5 seconds for memory allocations of less than 1,024 MB and this can be highly beneficial where an application requires immediate processing. As many systems move from batch to near real-time processing, the adoption of these types of capabilities will become more prevalent. Accordingly, it is therefore increasingly important to understand how to adapt and incorporate these patterns in the services designed.</p>
<p>Beyond the example scenarios laid out in the preceding section, many other use cases exist. Working with Cloud Functions minimizes the work needed to integrate your code and removes the obligation to provide the associated infrastructure.</p>
<p>To use Cloud Functions requires very little in the way of additional knowledge of the backend architecture. In truth, as long as you are comfortable in one of the language runtimes, you can be up and running very quickly. Having said that, we should take the time to explain what is happening in the background and how you can go about extending this to meet your needs.</p>
<p>In the next section, we move on to cover the Functions Framework. One thing Google Cloud is keen to ensure is that developers get an excellent experience. To achieve this typically means allowing them to work in their existing environment. So how about being able to work locally but being still able to deploy code to a cloud environment?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing with the Functions Framework</h1>
                </header>
            
            <article>
                
<p>At this point, please take a moment to consider the benefit of the Functions Framework we have been discussing â€“ the various options available on Google Cloud, meaning we can run <span>code</span><span> </span><span>in different environments. As a platform that prides itself as being developer-centric, allowing engineers to pick up and use their code in different contexts is highly advantageous.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing the Functions Framework</h1>
                </header>
            
            <article>
                
<p><span>The Functions Framework is an open source project that enables you to build your functions in multiple environments, for example, locally. As with any magic trick, the beauty is not understanding the mechanics of the illusion, but with how it makes you feel. In this instance, let's pull back the curtains to see how this particular trick is done and also what it means in terms of Cloud Functions.</span></p>
<p><span>So why do we need something like this? Well, working in a local, often highly customized environment provides a friendly comfort zone for developers. The context you are working in will be familiar, and the tools, locations, and access can all easily be checked and validated. There is an inherent comfort associated with working in this way. Moving to the cloud removes some of those psychological comforts from the user.</span></p>
<p><span>Having the ability to work locally, despite being counter to the end objective of running code in the cloud, is something folks want to do. Being able to work across a variety of environments using Cloud Functions leads us to the Functions Framework. The framework is a lightweight dependency that allows developers to run simple interfaces in a range of settings, such as the following:</span></p>
<ul>
<li><span>Cloud Functions</span></li>
<li><span>Local development</span></li>
<li><span>Cloud Run and Cloud Run for Anthos</span></li>
<li><span>Knative environments</span></li>
</ul>
<p><span>Building on the <strong>Functions as a Service</strong> (<strong>FaaS</strong>) platform for Google Cloud, the availability of this framework provides a simple mechanism to achieve portability across multiple environments. To incorporate the code is as simple as adding the relevant package to your project. In the next section, we will walk through a simple example to demonstrate its usage in a project. In the following case, we create a basic Node application to process some web-based information.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deploying an application locally with the Functions Framework</h1>
                </header>
            
            <article>
                
<p>Most developers prefer the local experience of working within a development environment. The Functions Framework provides Cloud Functions developers with the ability to continue to use this local work environment and propagate their code to the cloud in a seamless manner:</p>
<ol>
<li>First, create a directory for the example code to be built and initialize the environment. In my example, I have created a directory named <kbd>functions-framework</kbd> and will be using this to develop my code.</li>
</ol>
<div class="packt_infobox">It is important to note that in my local environment I am using Node v10+, as this is a requirement to use the Functions Framework. Also, I have npm v6.9.0 installed on my testing machine.</div>
<ol start="2">
<li>To check the Node version on your environment, run the command:</li>
</ol>
<pre style="padding-left: 60px"><strong><span>node -v</span></strong></pre>
<ol start="3">
<li>Using an editor, create a file named <kbd>index.js</kbd> and add the following content to it:</li>
</ol>
<pre style="padding-left: 60px">exports.helloWorldLocal = (req, res) =&gt; {<br/>    res.send('Hello, Functions Framework from a local machine');<br/>};</pre>
<ol start="4">
<li>To create a template <kbd>package.json</kbd> file, run <kbd>npm init</kbd> from the command line. Edit the content as necessary:</li>
</ol>
<pre style="padding-left: 60px">{<br/>    "name": "lab01_FF",<br/>    "version": "1.0.0",<br/>    "description": "Example use of the Functions Framework (FaaS)",<br/>    "main": "index.js",<br/>    "scripts": {<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<br/>    },<br/>    "author": "Rich Rose",<br/>    "license": "ISC"<br/>}</pre>
<p class="CDPAlignLeft CDPAlign" style="padding-left: 60px"><span>As you can see from the</span> above code extract, I <span>have the bare minimum added to my file.</span></p>
<ol start="5">
<li>Next, install the <kbd>functions-framework</kbd> package. My assumption here is that this is not already present on your local machine. To install this package, you will use <kbd>npm</kbd> to get the necessary package information:</li>
</ol>
<pre style="padding-left: 60px"><strong><span>npm install @google-cloud/functions-</span><span>framework</span></strong></pre>
<ol start="6">
<li>Once this command has been completed, you will see that the <kbd>package.json</kbd> file has been updated to include reference to the Function Framework under the <kbd>dependencies</kbd> category, as follows:</li>
</ol>
<pre style="padding-left: 60px">{<br/>    "name": "lab01_FF",<br/>    "version": "1.0.0",<br/>    "description": "Example use of the Functions Framework (FaaS)",<br/>    "main": "index.js",<br/>    "scripts": {<br/>        "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<br/>    },<br/>    "author": "Rich Rose",<br/>    "license": "ISC",<br/>    "dependencies": {<br/>        "@google-cloud/functions-framework": "^1.1.1"<br/>    }<br/>}</pre>
<p style="padding-left: 60px">Now our environment is ready to build functions, so let's make a really simple application to test our environment.</p>
<ol start="7">
<li>With our new code, we need to tell the application to run a script when the application is run. In the existing <kbd>package.json</kbd>, add the following reference to the code to call the Functions Framework and pass a <kbd>target</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">{<br/>    "name": "lab01_FF",<br/>    "version": "1.0.0",<br/>    "description": "Example use of the Functions Framework (FaaS)",<br/>    "main": "index.js",<br/>    "scripts": {<br/>        "start": "functions-framework --target=helloWorldLocal"<br/>        "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<br/>    },<br/>    "author": "Rich Rose",<br/>    "license": "ISC",<br/>    "dependencies": {<br/>        "@google-cloud/functions-framework": "^1.1.1"<br/>    }<br/>}</pre>
<p style="padding-left: 60px">Great job; we now have our <kbd>index.js</kbd> and <kbd>package.json</kbd> ready to use the Functions Framework.</p>
<ol start="8">
<li>Run the application locally using the standard calling method  <kbd>npm start</kbd> from the command line.</li>
<li>Note that, in our example environment, the running application is bound to port <kbd>8080</kbd> over the HTTP protocol. Open your browser and access this URL, <span><kbd>http://localhost:8080</kbd></span>, to see the output from your application as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-897 image-border" src="assets/1d5b8844-041a-4d42-aeb7-49a8ae0e0417.png" style=""/></div>
<p>Building code to run locally on a development machine is trivial using this framework. However, how would this scenario differ if we wanted to deploy to the cloud? In the next section, we look at how to deploy code to the cloud.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deploying an application to the cloud with the Functions Framework</h1>
                </header>
            
            <article>
                
<p>When migrating our local application to a cloud environment, surprisingly, there is little that we need to do in terms of preparation. In this example, I will assume you have already installed and initialized the Google Cloud SDK to enable you to connect and provision resources on Google Cloud.</p>
<p>For the sake of clarity, I will create another function that says something slightly different; however, you can use the same Cloud Function defined in the code created previously:</p>
<ol>
<li>In the <kbd>index.js</kbd> <span>file, </span>create a second function named <kbd>helloWorldCloud</kbd>.</li>
</ol>
<ol start="2">
<li>Give this new function the attributes as defined previously; however, we will use a different message to illustrate that a different function is called:</li>
</ol>
<pre style="padding-left: 60px">exports.helloWorldCloud = (req, res) =&gt; {<br/>    res.send('Hello, Functions Framework from a Google Cloud project');<br/>};</pre>
<ol start="3">
<li>Save the new content for the application and test to ensure it continues to work as per the previous run.</li>
<li>Run <kbd>npm start</kbd> from the command line. Remember, the only thing we have changed in this iteration is the code base.</li>
<li>Running the <kbd>npm start</kbd> command allows us to browse to <kbd>localhost:8080</kbd> and see the message from our application.</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-898 image-border" src="assets/430a00ce-56fb-4e0f-a933-d5abc49b098c.png" style=""/></div>
<ol start="6">
<li>Now we want to run our code base in the Cloud by deploying the Cloud Function. For this instance, we rely on the Cloud SDK to get our code running in a Google Cloud project. Run the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong><span>gcloud functions deploy helloWorldCloud --runtime nodejs10 --trigger-http --region us-central1</span></strong></pre>
<ol start="7">
<li>To confirm that the information created from the source uploaded successfully, take a look at the running Cloud Function source code. Here, we can see it includes the same source code that has been archived and uploaded to Google Cloud. However the resulting display is showing the message specifically relating to our new function.</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-899 image-border" src="assets/1cd48c72-8399-4654-9c2d-55a2a12b9f18.png" style=""/></div>
<p>At this point, we now know how to deploy code to our local environment and also to a Google Cloud project using Cloud Functions. But what exactly are Cloud Functions for and what can it do? In the next section, we go into some further details on the relative benefits and use cases for this service.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploring the Cloud Functions workflow</h1>
                </header>
            
            <article>
                
<p>So, it seems like Cloud Functions are pretty useful, and together with the Functions Framework, it would appear to be a match made in heaven. Besides, the overall approach seems very extensible, and working with other products and services within Google Cloud seems greatly simplified. So, if you are already in <em>team Google Cloud</em>, using Cloud Functions is a no-brainer.</p>
<p>For those of you who are not in <em>team Google Cloud</em> or may be sitting on the fence, there is more to this story. Serverless is a general term that has taken some critical feedback over the years. For most folks, serverless relates to the lack of requirement-driven infrastructure management when deploying code. For others, it means, services being available immediately and being capable of achieving sizing <span>appropriate </span>to the needs of the application used, with the ability to self-heal.</p>
<p>Depending on your perspective, Cloud Functions may or may not meet your needs. The main concern that people highlight is the time taken to deploy code. <em>Why isn't the function available immediately?</em>, <em>Why is the memory constrained?</em>, and so on â€“ <em>When I use provider X, the services are available immediately, the memory isn't constrained, and they serve tea and cakes for every deployment!</em></p>
<p>So before we go into the details on Cloud Functions, it feels like a good time to bring up what is happening behind the scenes as we deploy our code to the cloud. Google has laid out an excellent architecture in terms of mapping out the leading products regarding capability for a data processing pipeline. The data life cycle is useful from an architecture perspective as it outlines the produce available to render specific aspects of your pipeline. In terms of the common topics of ingestion, storage, processing, and analytics, this approach provides an exciting way to break down the component architecture.</p>
<p>So how do you create a function? Let's examine this in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cloud Function properties</h1>
                </header>
            
            <article>
                
<p>As discussed earlier, Cloud Functions provides support for several runtimes on Google Cloud, including Node.js, Python, Go, Java, and Ruby. Getting started with Cloud Functions is as easy as accessing the Google Cloud console and selecting the most appropriate runtime. Each runtime includes template code that presents the blueprint for a primary Cloud Function plus all the ancillary system code necessary to get an example up and running in no time.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>A key consideration for code is how much time an algorithm will take to process and how much this matters. For example, if the algorithm is part of the UX, then any delay in processing will likely be noticeable to the end user. Asynchronous code permits long-lived processing actions to be offloaded from the main thread and executed in the background. Taking this action is key to maintaining performance across the application space as it provides the ability to delineate between resources requiring fast or slow responses.</p>
<p>Besides, as you are now aware, functions are generally stateless applications that should not persist any information. As a general rule, this means that the service utilizes a short life-cycle in which data processes and the task comes to an end. To minimize potential latency reduce  long-lived request and response cycles, by using asynchronous calls within code.</p>
<p>For stateful applications, the need to maintain information presents an issue in terms of the potential latency associated with the persistence of data. It should be clear that anything requiring the read/write cycle outside of memory will introduce some level of delay. Trying to minimize this delay presents an interesting design problem that ultimately depends on what you want to give up and to what degree you want to move away from the performance, loose coupling, data design, and so on.</p>
<p>To call a function, the event notification mechanism on Google Cloud is a trigger. The trigger is an important consideration when starting out developing a Cloud Function. Design of a function does require some thought to determine what pieces are needed to deliver a suitable model. As an event-driven architecture, there are some options available, as indicated in the following table:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td style="width: 37.951%"><strong>Trigger</strong></td>
<td style="width: 22.049%"><strong>Event</strong></td>
<td style="width: 21%"><strong>Destination</strong></td>
</tr>
<tr>
<td style="width: 37.951%">HTTP</td>
<td style="width: 22.049%">HTTP</td>
<td style="width: 21%">URL</td>
</tr>
<tr>
<td style="width: 37.951%">Cloud Pub/Sub</td>
<td style="width: 22.049%">Topic</td>
<td style="width: 21%"/>
</tr>
<tr>
<td style="width: 37.951%">Cloud Storage</td>
<td style="width: 22.049%">
<ul>
<li>Finalize/create</li>
<li>Delete</li>
<li>Archive</li>
<li>Metadata</li>
</ul>
</td>
<td style="width: 21%">Bucket</td>
</tr>
<tr>
<td style="width: 37.951%">Cloud Firestore</td>
<td style="width: 22.049%">
<ul>
<li>Write</li>
<li>Create</li>
<li>Update</li>
<li>Delete</li>
</ul>
</td>
<td style="width: 21%"/>
</tr>
<tr>
<td style="width: 37.951%"><span>Google Analytics for Firebase</span></td>
<td style="width: 22.049%">Log</td>
<td style="width: 21%">Log Event Name</td>
</tr>
<tr>
<td style="width: 37.951%"><span>Firebase Authentication</span></td>
<td style="width: 22.049%">
<ul>
<li>Create</li>
<li>Delete</li>
</ul>
</td>
<td style="width: 21%"/>
</tr>
<tr>
<td style="width: 37.951%">Firebase Realtime Database</td>
<td style="width: 22.049%">
<ul>
<li>Write</li>
<li>Create</li>
<li>Update</li>
<li>Delete</li>
</ul>
</td>
<td style="width: 21%">Database</td>
</tr>
<tr>
<td style="width: 37.951%">Firebase Remote Config</td>
<td style="width: 22.049%"><kbd><span>remoteconfig.update</span></kbd></td>
<td style="width: 21%"/>
</tr>
</tbody>
</table>
<p> </p>
<p>In addition to the runtime, there are also additional properties included when commencing creating a Cloud Function. Memory allocation is an essential consideration as the expectation is that the processing performed exists in-memory. Cloud Functions provide memory allocation from 128 KB to 2 GB that can be adjusted by the developer based on the requirement of the application developed.</p>
<p>Before moving onto the more general options, it's worth having a brief overview of authentication and how this relates to Cloud Functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authentication</h1>
                </header>
            
            <article>
                
<p>The default authentication for Cloud Functions represents public access; that is, it can be accessed by anyone, anywhere. From the Cloud Functions configuration screen, select <span class="packt_screen">Allow unauthenticated invocations</span> to create a publically exposed endpoint. The <kbd>allUsers</kbd> IAM setting provides public access assignment to the service account associated with the Cloud Function. An invocation of a function relies on the association of a service account. A service account is a particular account used for non-interactive access, as in the entrance is for another computer rather than a human. The user account is assigned role permission, and this is bound to the service. By default, Cloud Functions binds an <kbd>allUser</kbd> permission, but alterations before and after the creation of a function are possible.</p>
<p>Note that the initial function designation allows adjustment through IAM settings. This approach brings Cloud Functions into line with other services on Google Cloud. Later in this book, Cloud Functions security will be discussed, and it will cover the configuration of service accounts concerning Cloud Functions to limit privilege.</p>
<p>For now, let's move on to the options available regarding accessing the source versions for a function.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Source control</h1>
                </header>
            
            <article>
                
<p><span>Working with source code presents many challenges. Thankfully, Cloud Functions provides several options to integrate source code. The Cloud Functions source code can be accessed from the sources such as those outlined here:</span></p>
<ul>
<li><span><strong>Inline editor</strong>: Create and amend the function code in the Google Cloud Console.</span></li>
<li><span><strong>ZIP upload</strong>: Upload a local ZIP file to an intermediary staging Cloud Storage bucket.</span></li>
<li><span><strong>ZIP from Cloud Storage</strong>: Use an existing ZIP file located in a Cloud Storage bucket.</span></li>
<li><span><strong>Cloud Source repository</strong>: Use source version control.</span></li>
</ul>
<p><span>For a quick bout of development, the inline editor can be quite useful; however, it will probably make more sense to use one of the many other options when writing more intricate code. In most instances, you can continue to use your favorite editor and upload code with whichever method meets your needs.</span></p>
<p><span>Knowing how to upload source code takes us nicely onto the next topic, that is, selecting a language runtime.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with different runtime languages</h1>
                </header>
            
            <article>
                
<p>Throughout the next few paragraphs, we will outline the baseline functions using Node, Python, and Go, and discuss the high-level differences between the various runtime languages.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Node.js</h1>
                </header>
            
            <article>
                
<p>Our discussion begins with Node.js (v10). In this template code, we can see that the actual function consists of a couple of lines of code. In terms of Node.js, the exact flavor is Express.js. Express.js is a concise framework that works in conjunction with Node.js to enhance functionality through additions such as routing middleware and HTML rendering.</p>
<p>Looking at the following example code, we can see a function definition based on <kbd>exports.helloWorld</kbd>. The <kbd>exports</kbd> keyword indicates the function executes (that is, exposed as a callable function) once deployed. Note also that the service to be exported takes two parameters mapped to the HTTP request and response values.</p>
<p class="mce-root"/>
<p>The default Google Cloud Function written in Node.js is illustrated as follows:</p>
<pre>1. /**<br/>2. * Responds to any HTTP request.<br/>3. *<br/>4. * @param {!express:Request} req HTTP request context.<br/>5. * @param {!express:Response} res HTTP response context.<br/>6. */<br/>7. exports.helloWorld = (req, res) =&gt; {<br/>8.     let message = req.query.message || req.body.message || 'Hello World!';<br/>9.     res.status(200).send(message);<br/>10.};</pre>
<p>The body of the function examines the request made to determine the addition of a query message or message body.</p>
<p>Reviewing the Express.js documentation tells us a bit more about the access requirement for the message assignment statement. For a GET message, we understand that a query can pass additional data to the function.</p>
<p>If not, the default message of <kbd>Hello World</kbd> will be returned in the message variable. Next, <kbd>res.status</kbd> is set to the value of 200 and the message variable added to the response. Remember from the previous discussion on HTTP response codes that a 200 represents a successful transaction.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Python</h1>
                </header>
            
            <article>
                
<p>The current revision of Python supported on Google Cloud is version 3.7. From the example code, what we do not see is that the Flask package handles HTTP communication. At first glance, there is undoubtedly a lot more code present than in the example for Node.js.</p>
<p>To start, we define our function and can see an immediate difference in the naming convention. In Python, we have named our service <kbd>hello_world</kbd>, which is different from the sample Node.js template. Feel free to change the name to be consistent, but it does not ultimately matter. Ensure you use the correct name for the function to execute, as this can be a frustrating error to fix:</p>
<pre>def hello_world(request):<br/>""" Responds to any HTTP request.<br/>    Args:<br/>        request (flask.Request): HTTP request object.<br/>        Returns:<br/>    The response text or any set of values that can be turned into a<br/>    Response object using<br/>    `make_response<br/>    &lt;http://flask.pocoo.org/docs/1.0/api/#flask.Flask.make_response&gt;`.<br/>"""<br/>request_json = request.get_json()<br/>if request.args and 'message' in request.args:<br/>    return request.args.get('message')<br/>elif request_json and 'message' in request_json:<br/>    return request_json['message']<br/>else:<br/>    return f'Hello World!'</pre>
<p>In the body of the function, we can see a call to return a JSON object. Similar to the Node.js Cloud Function, we check the argument for the message to indicate if we are to override the default message. To cover the bases, we again ensure this example works for both GET and POST messages. Finally, if the user has not added a message in the required format, we return the default message of <kbd>Hello World!</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Go</h1>
                </header>
            
            <article>
                
<p>Go is currently supported <span>on Google Cloud for version</span> 1.11+. As you would expect, the revision compatibility is maintained as each version is released, so the recommendation is to maintain compatibility with newer versions.</p>
<p>In the following example code, we import some packages to enable our application to perform the necessary access to HTTP and JSON. The function signature remains the same with request and response arguments, both used as an entry point to the function.</p>
<p>For the body of the function, our code will default to a standard message if the program does not provide one:</p>
<pre>// Package p contains an HTTP Cloud Function.<br/>package p<br/>    import (<br/>        "encoding/json"<br/>        "fmt"<br/>        "html"<br/>    "net/http"<br/>)<br/>// HelloWorld prints the JSON encoded "message" field in the body<br/>// of the request or "Hello, World!" if there isn't one.<br/>func HelloWorld(w http.ResponseWriter, r *http.Request) {<br/>    var d struct {<br/>        Message string 'json:"message"'<br/>    }<br/>    if err := json.NewDecoder(r.Body).Decode(&amp;d); err != nil {<br/>        fmt.Fprint(w, "Hello World!")<br/>        return<br/>    }<br/>    if d.Message == "" {<br/>        fmt.Fprint(w, "Hello World!")<br/>        return<br/>    }<br/>    fmt.Fprint(w, html.EscapeString(d.Message))<br/>}</pre>
<p>Working with Cloud Functions, we see that irrespective of the runtime language chosen, many of the properties are shared nonetheless. In terms of languages, we also observed the different forms of example code used for Node, Python, and Go.</p>
<p>In terms of coding our functions, looking for design patterns will help us to avoid reinventing the wheel. We know a bit more about the available language runtimes and have seen an example of the boilerplate code associated with each one. To test the function, we would need a triggering event, and, in the next section, we will discuss an approach to this situation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing the runtime triggering event</h1>
                </header>
            
            <article>
                
<p>To test the function, we can craft some data with which to confirm the success criteria of our service. Again, Cloud Functions can assist with this task by allowing the entry of JSON data to be passed directly to the function at runtime in the testing window:</p>
<ol>
<li>A typical URL for a cloud function will resemble syntax of the following link. Hitting the endpoint will access the default information associated with the Cloud Function:</li>
</ol>
<pre style="padding-left: 60px">https://[REGION]-[PROJECT].cloudfunctions.net/[CLOUD-FUNCTION]</pre>
<ol start="2">
<li>For the template code, we can supplant a new message by adding some additional information to the URL, as follows:</li>
</ol>
<pre style="padding-left: 60px">https://[REGION]-[PROJECT].cloudfunctions.net/[CLOUD-FUNCTION]?message=Yo%20Gabba %20Gabba!</pre>
<p style="padding-left: 60px"><span>In this example, the <kbd>req.query</kbd> property returns an object with information, in this case, a message to be displayed in place of the default <kbd>Hello World!</kbd>.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="3">
<li>If you go ahead and run this function without entering any additional parameters, a message of <kbd>Hello World</kbd> will be displayed and a response code of <kbd>200</kbd> generated. Triggering the event in this way is similar to accessing the function URL directly, in that no additional information will be incorporated into the query:</li>
</ol>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign" style="padding-left: 30px"><strong>Message</strong></td>
<td class="CDPAlignCenter CDPAlign" style="padding-left: 30px"><strong>Triggering Event</strong></td>
<td class="CDPAlignCenter CDPAlign" style="padding-left: 30px"><strong>Output</strong></td>
<td class="CDPAlignCenter CDPAlign" style="padding-left: 30px"><strong>Response return code</strong></td>
</tr>
<tr style="padding-left: 30px">
<td class="CDPAlignLeft CDPAlign">  1</td>
<td class="CDPAlignCenter CDPAlign" style="padding-left: 30px"><kbd>{}</kbd></td>
<td class="CDPAlignCenter CDPAlign" style="padding-left: 30px"><kbd>Hello World!</kbd></td>
<td class="CDPAlignCenter CDPAlign" style="padding-left: 30px"><kbd>200</kbd></td>
</tr>
</tbody>
</table>
<p> </p>
<ol start="4">
<li>Alternatively, by adding some parameters to the triggering event, we can output a specific string when running the function. </li>
</ol>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>Message</strong></td>
<td><strong>Triggering Event</strong></td>
<td><strong>Output</strong></td>
<td><strong>Response return code</strong></td>
</tr>
<tr>
<td class="CDPAlignLeft CDPAlign">  2</td>
<td><kbd><span>{"message":"Yo Gabba Gabba!"}</span></kbd></td>
<td><kbd><span>Yo Gabba Gabba!</span></kbd></td>
<td class="CDPAlignCenter CDPAlign"><kbd>200</kbd></td>
</tr>
</tbody>
</table>
<p> </p>
<p>In the preceding example shown, the triggering event has a JSON string added. In this instance, the output to the function changes to display the string entered earlier. As before, the return code generated is <kbd>200</kbd>.</p>
<p>Being able to test an application is fundamental to any developer workflow. However, it is just as essential to be able to reference the logs and application-specific information for monitoring purposes. To achieve this on Google Cloud, we use Stackdriver.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Stackdriver</h1>
                </header>
            
            <article>
                
<p>Each time traffic reaches the endpoint, information relating to the Cloud Function will be captured automatically in Stackdriver. If you are not familiar with Stackdriver, it is a centralized logging and monitoring system for Google Cloud. We will discuss Stackdriver in greater depth later in the book in <a href="5a03622d-8dae-4385-a141-7b04988f5672.xhtml" target="_blank">Chapter 10</a>, <em>Cloud Run Labs</em>;<span> however, for the time being, it is essential to know that this is where to access real-time information for a function. To search for function execution, use a filter in Stackdriver, as follows:</span></p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td class="CDPAlignLeft CDPAlign" style="width: 51.1019%"><strong>Field</strong></td>
<td class="CDPAlignLeft CDPAlign" style="width: 48.0716%"><strong>Example content</strong></td>
</tr>
<tr>
<td class="CDPAlignLeft CDPAlign" style="width: 51.1019%"><kbd>resource.type</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="width: 48.0716%"><kbd>cloud_function</kbd></td>
</tr>
<tr>
<td class="CDPAlignLeft CDPAlign" style="width: 51.1019%"><kbd>resource.labels.function_name</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="width: 48.0716%"><kbd>function-1</kbd></td>
</tr>
<tr>
<td class="CDPAlignLeft CDPAlign" style="width: 51.1019%"><kbd>resource.labels.region</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="width: 48.0716%"><kbd>us-central1</kbd></td>
</tr>
<tr>
<td class="CDPAlignLeft CDPAlign" style="width: 51.1019%"><kbd>labels.execution_id</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="width: 48.0716%"><kbd><span>4ubpvdgz7c8w</span></kbd></td>
</tr>
</tbody>
</table>
<p class="mce-root"/>
<p>The determining factor for which runtime language to use will largely depend on your personal experience. I have used Node.js t<span>hroughout this book </span>as it is very accessible. The interface is straightforward and efficient and doesn't take too much head-scratching to understand the code. Of course, you may have your personal favorite, and, hopefully, similar packages are available in those runtime languages.</p>
<p>Working with the boilerplate code is the beginning of your journey, so do not be afraid to experiment with different approaches and techniques. In the next section, we provide an overview of the HTTP protocol.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the HTTP protocol</h1>
                </header>
            
            <article>
                
<p>In the context of our discussion on Cloud Functions, it is essential to consider how the HTTP protocol worksâ€”learning the necessary foundation of the API to enable communication between request and response.</p>
<p>HTTP verbs, such as GET, PUT, POST, DELETE, and so on, provide the basis for the HTTP protocol to perform its various functions. The design of the contract is one that has generally stood the test of time as more advanced use cases have been more prevalent over time. Typically running over TCP, the protocol requires a reliable medium on which to transmit messagesâ€”utilizing a contract such as TCP establishes some level of resilience for the data transmission and acknowledgment when performing machine-to-machine communication. In terms of commonality, GET and POST represent the most common methods used for applications.</p>
<p>In the next section, we provide a quick overview of these methods to understand their use.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining GET/POST methods</h1>
                </header>
            
            <article>
                
<p>Accessing a web page typically uses the GET method to gather content stored on remote servers. Whenever you are surfing the internet and looking at the contents of various websites, the HTTP GET method is used to achieve this. The GET method is, at its most basic, an idempotent retrieval mechanism for HTTP. Think about the GET method as a simple retrieval mechanism, that is, <em>get this information from the remote server</em>. Sending this command to a remote server tells it to provide a message response.</p>
<div class="packt_infobox">The GET method also allows query information to be sent to the remote server; however, this information is displayed as part of the URL. The message payload is typically served as a stream of bytes, after which the remote server will close the open TCP connection indicating the completion of the <span>transaction</span>.</div>
<p>When working with web pages, in addition to retrieving information from a website using the GET method, there is also the POST method. The POST method provides the ability to supply additional information as part of the query sent to the remote server. In contrast to the GET method, there is no exposure via the URL of query information, and the request made is non-idempotent. These attributes make the POST method more useful for incorporating information that should not disclose content via the URL and is susceptible to change. A typical use for this type of arrangement is web forms, in which field values are sent as part of the HTTP request query.</p>
<p>Once the request/response cycle has completed, a status code indicating the status of the transaction is returned. In the next topic, an overview of HTTP codes outlines the general categories.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unmasking HTTP response codes</h1>
                </header>
            
            <article>
                
<p>An HTTP response's three-digit response code indicates the success of the communication performed. These response codes are vital to ensure the smooth running of any HTTP-based application server.</p>
<p>If you have ever needed to configure or maintain a web server, the following information will undoubtedly be very familiar to you:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>Return Value</strong></td>
<td><strong>Type</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>1xx</td>
<td>Information</td>
<td><span>An informational response code indicating the request was understood.</span></td>
</tr>
<tr>
<td>2xx</td>
<td>Success</td>
<td><span>The more common method of confirming the success of the request is by returning this status code.</span></td>
</tr>
<tr>
<td>3xx</td>
<td>Redirect</td>
<td><span>Redirection associated with the client request; typically no user interaction is required as a redirect is automatically enacted to complete the action.</span></td>
</tr>
<tr>
<td>4xx</td>
<td>Client Error</td>
<td><span>A request-based error that indicates something was wrong with the information sent from the client to the server.</span></td>
</tr>
<tr>
<td>5xx</td>
<td>Server Error</td>
<td><span>An error relating to the response from the server-side communication has occurred, meaning the request could not be fulfilled.</span></td>
</tr>
</tbody>
</table>
<p>The full list of HTTP status code is maintained by the <strong>Internet Assigned Numbers Authority</strong> (<strong>IANA</strong>). The broad categories associated with the HTTP status code ensure that most situations are catered for when working in this area.</p>
<p>Another area that may be of use in extending your understanding is how to work across domains with web content. In the next section, we'll look at a concise overview of cross-origin resource sharing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with Cross-Origin Resource Sharing (CORS)</h1>
                </header>
            
            <article>
                
<p><span>Enabling CORS in the HTTP header enables a range of actions to be performed across domains. The addition of this provides an extra capability beyond that of traditional single-domain, client-to-server information exchange. As you would expect of the client, their responsibility is to initiate a request that includes indicating the method and header requirements. From a server perspective, the range of header properties is more numerous, allowing the achievement of a richer set of functionality.</span></p>
<p>An application may not always be in a situation where execution takes place in the same domain. <span>For these types of situations, there is</span> CORS, <span>and this provides the ability to enable communication across domains:</span></p>
<table border="1" style="border-collapse: collapse;width: 50%">
<tbody>
<tr>
<td style="width: 45.796%"><strong>Client</strong></td>
<td style="width: 80.204%"><strong>Server</strong></td>
</tr>
<tr>
<td style="width: 45.796%">
<ul>
<li>Origin</li>
<li>Access-Control-Request-Method</li>
<li>Access-Control-Request-Headers</li>
</ul>
</td>
<td style="width: 80.204%">
<ul>
<li>Access-Control-Allow-Origin</li>
<li>Access-Control-Allow-Credentials</li>
<li>Access-Control-Expose-Headers</li>
<li>Access-Control-Max-Age</li>
<li>Access-Control-Allow-Methods</li>
<li>Access-Control-Allow-Headers</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Finally, we outlined the event-driven triggers associated with Cloud Functions. Looking at the options, it's clear that these triggers are capable of meeting many of the use cases related to building systems. Thinking of events and triggers like <em>glue</em> or <em>lego</em> pieces is a good metaphor for the use of these components. When it comes to building new components or designing a serverless application, it is often surprising how easy it is to use these building blocks together. But it doesn't stop there â€“ imagine extending beyond Google Cloud to other cloud providers and using their services. Serverless provides a real and exciting disruption to the existing design and application development process. Single-use functions focused on delivering a clean interface with defined inputs and outputs make for a more efficient delivery and maintenance experience.</p>
<p>Working through each of the options, we discussed how each could be used to significant effect when building a serverless application. To achieve this, an adaptive type of architecture requires more than Cloud Functions, for example, when incorporating authentication (via Firebase), proxy access (via Cloud Endpoints), or temporary storage (via Google Cloud Storage). Working with best practices and combining different approaches isn't a one-size-fits-all affair, and you have the ability to utilize both open source and commercial software seamlessly, moving beyond the serverless platform and looking out to the broader aspects of your system. While serverless provides a simple method of achieving scale, introducing network scale in other aspects of your portfolio will still require careful planning.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we walked through a broad overview of Cloud Functions and where it sits within the Google Cloud Serverless portfolio. Also, we looked at a few tangential aspects that are relevant to the use of FaaS, such as HTTP2 and the data life cycle.</p>
<p>By exploring the runtimes and observing the associated code throughout the chapter, we are now aware of how to structure Cloud Functions in multiple languages. We also are aware of how to test and resolve issues by incorporating monitoring and logging into our development workflow. As you will know, Google provides a full array of tools and services to get you to the point where you can quickly develop a <strong>minimum viable product</strong> (<strong>MVP</strong>).</p>
<p>In the next chapter, we will cover some more examples in greater depth. Building an application provides an excellent way to learn the critical elements of a serverless application environment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What port does Cloud Functions run on? </li>
<li>What trigger is used by Cloud Pub/Sub?</li>
<li>What runtime languages are supported by Google Cloud Functions?</li>
<li>What is the HTTP response code for success?</li>
<li>What is the HTTP response code for a client-side error?</li>
<li>What is the HTTP response code for a server-side error?</li>
<li>What is the purpose of CORS?</li>
<li>How is CORS enabled?</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li><strong>Introduction to HTTP/2</strong>: <a href="https://developers.google.com/web/fundamentals/performance/http2">https://developers.google.com/web/fundamentals/performance/http2</a></li>
<li><strong>HTTP/2 for load balancing with Ingress</strong>: <a href="https://cloud.google.com/kubernetes-engine/docs/how-to/ingress-http2">https://cloud.google.com/kubernetes-engine/docs/how-to/ingress-http2</a></li>
<li><strong>Functions Framework</strong>: <a href="https://cloud.google.com/functions/docs/functions-framework">https://cloud.google.com/functions/docs/functions-framework</a></li>
</ul>


            </article>

            
        </section>
    </body></html>