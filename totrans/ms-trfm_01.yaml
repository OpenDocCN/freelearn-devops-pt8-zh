- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Understanding Terraform Architecture
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Terraform 架构
- en: At its core, **Terraform** is a simple command-line program that evaluates source
    code, which describes what a desired state should look like, compares it against
    what the actual state is, constructs a plan to transform the actual state into
    the desired state, and can execute the plan. But don’t let its perceived simplicity
    fool you. Terraform’s internal complexity manifests itself in its external simplicity.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，**Terraform** 是一个简单的命令行程序，它评估源代码，该源代码描述了期望状态应该是什么样的，随后将其与实际状态进行比较，构建一个计划，将实际状态转变为期望状态，并能够执行该计划。但不要让它表面上的简单性欺骗了你。Terraform
    的内部复杂性体现在它的外部简单性中。
- en: Terraform is a large, source-available project written in Go that maintains
    the command-line executable. It provides baseline functionality such as **HashiCorp
    Configuration Language** (**HCL**) parsing, state management, plan creation, and
    execution.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 是一个由 Go 编写的开源项目，维护着命令行可执行文件。它提供了诸如**HashiCorp 配置语言**（**HCL**）解析、状态管理、计划创建和执行等基础功能。
- en: 'Terraform is extremely powerful, yet ironically, it does very little by itself.
    But here’s the exciting part: Terraform’s superpower comes from its extensibility,
    a power that is not limited to its creators. The actual Terraform executable,
    by itself, can’t do much, but when bundled with one of its plugins—called **providers**—Terraform
    can do quite a lot! This extensibility is a testament to the collaborative nature
    of the Terraform community, where everyone can contribute to its growth and capabilities.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 极其强大，但具有讽刺意味的是，它本身做的很少。但有一个令人兴奋的部分：Terraform 的超能力来自于其可扩展性，这种能力不仅限于其创造者。实际的
    Terraform 可执行文件本身不能做太多事情，但当与其插件——称为**提供者**——捆绑在一起时，Terraform 就能做很多事情！这种可扩展性证明了
    Terraform 社区的协作性质，每个人都可以为它的成长和能力做出贡献。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding Terraform architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Terraform 架构
- en: Understanding Terraform state
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Terraform 状态
- en: Understanding how to build and consume modules
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何构建和使用模块
- en: Understanding how to use the **command-line interface** (**CLI**) effectively
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何有效使用**命令行界面**（**CLI**）
- en: 'Terraform has four superpowers that distinguish it from other tools: *planning*,
    *extensibility*, *configuration language*, and *modularity*. Some tools may share
    some of these, but they don’t have them all. With these powers combined, Terraform
    is a game changer in cloud automation.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 有四个超能力，使其与其他工具区分开来：*规划*、*可扩展性*、*配置语言*和*模块化*。一些工具可能共享其中的一些功能，但它们并不具备所有这些功能。拥有这些能力的组合，Terraform
    在云自动化中是一款改变游戏规则的工具。
- en: Understanding Terraform architecture
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Terraform 架构
- en: The biggest differentiator of Terraform is that, well, Terraform plans ahead.
    Let’s look at how Terraform handles planning in detail.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 最显著的差异化特点是，它能够提前规划。让我们详细了解 Terraform 如何处理规划。
- en: The plan
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计划
- en: 'When working with Terraform, you will be following a process where Terraform
    is used to analyze the existing environment. In doing this analysis, Terraform
    is determining what (if any) changes in the code need to be applied to the actual
    environment to bring it up to date. Terraform itemizes these changes as actions
    within the plan. While Terraform does this analysis on our behalf, produces the
    plan, and is fully capable of executing that plan against the environment, we
    are still responsible for reviewing the plan and determining if the planned changes
    are what we intended:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Terraform 时，你将遵循一个过程，Terraform 用于分析现有环境。在进行此分析时，Terraform 确定代码中需要应用的（如果有的话）变更，以使实际环境保持最新。Terraform
    将这些变更作为操作项列出在计划中。尽管 Terraform 代表我们执行这项分析，生成计划，并完全能够在环境中执行该计划，但我们仍然有责任审查计划，确定计划中的变更是否是我们所期望的：
- en: '![Figure 1.1 – Terraform resources are straightforward machines with inputs
    and outputs](img/B21183_01_1.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – Terraform 资源是具有输入和输出的简单机器](img/B21183_01_1.jpg)'
- en: Figure 1.1 – Terraform resources are straightforward machines with inputs and
    outputs
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – Terraform 资源是具有输入和输出的简单机器
- en: Terraform represents every component in your environment as a resource in this
    analysis. Resources are extremely simple machines. They take inputs and produce
    outputs. They also can be chained together, thus creating explicit relationships
    between the components within your environment. These relationships inform Terraform’s
    analysis of your environment and the sequence of actions enumerated in the plan.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 在这个分析中将环境中的每个组件表示为一个资源。资源是极其简单的机器。它们接受输入并产生输出。它们还可以连接在一起，从而在环境中的组件之间创建明确的关系。这些关系为
    Terraform 对环境的分析和计划中列出的行动顺序提供了信息。
- en: Once we have decided that this plan is what we intended, we ask Terraform to
    execute it. Terraform will then apply that plan to our actual environment. The
    outcome of this process is that Terraform will bring our environment up to date
    with the description in the code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们决定这个计划是我们所期望的，我们会请求 Terraform 执行它。然后，Terraform 会将该计划应用到我们的实际环境中。这个过程的结果是，Terraform
    会将我们的环境更新为代码中的描述。
- en: Terraform’s design encourages developers to repeat this process. Therefore,
    as the developer updates their code, with each iteration of the code applied to
    the environment, we will continually assess the current state and determine the
    future state to match the environment our code describes. Each time we run Terraform
    to assess the environment, it will produce a plan. This plan was generated at
    a point in time when evaluating the differences between the actual environment
    and the code base.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 的设计鼓励开发者重复这一过程。因此，随着开发者更新代码，每次将代码应用到环境中时，我们将不断评估当前状态，并确定未来状态，以匹配代码所描述的环境。每次运行
    Terraform 来评估环境时，它都会生成一个计划。这个计划是在评估实际环境与代码库之间差异时生成的。
- en: On *Day 1*, since the environment does not exist, everything Terraform must
    create the developer described within the code. On *Day 2*, however, things are
    more complex. On *Day 1*, we started cleaning. However, on *Day 2*, we are still
    determining where we are starting because Terraform has already provisioned the
    environment once before. Many things could have changed since *Day 1*. We could
    have intentionally modified the code base to change the environment. Likewise,
    *gremlins* could have altered our environment during the night, thus introducing
    drift into our environment and requiring us to roll back their changes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第 1 天*，由于环境尚不存在，Terraform 必须创建开发者在代码中描述的所有内容。然而，到了*第 2 天*，事情变得更复杂了。在*第 1 天*，我们开始了清理工作。但在*第
    2 天*，我们仍然需要确定我们的起点，因为 Terraform 已经提前配置过一次环境。自*第 1 天*以来，许多事情可能发生了变化。我们可能故意修改了代码库来更改环境。同样，*gremlins*
    可能在夜间改变了我们的环境，从而引入了漂移，迫使我们回滚这些变化。
- en: 'To analyze the existing environment, Terraform consults two sources of information:
    **Terraform state** and the environment itself—via the provider (which is also
    informed by Terraform state). If the Terraform state is empty, then Terraform
    assumes the environment does not exist and creates a plan that will create everything:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要分析现有环境，Terraform 会参考两个信息来源：**Terraform 状态**和环境本身——通过提供者（该提供者同样受 Terraform 状态的影响）。如果
    Terraform 状态为空，Terraform 会假定环境不存在，并创建一个计划以创建所有内容：
- en: '![Figure 1.2 – Resource plan, Day 1: everything needs to be created](img/B21183_01_2.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 资源计划，第 1 天：所有内容都需要被创建](img/B21183_01_2.jpg)'
- en: 'Figure 1.2 – Resource plan, Day 1: everything needs to be created'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 资源计划，第 1 天：所有内容都需要被创建
- en: 'If Terraform state exists, things will get interesting, and Terraform will
    have to earn its paycheck. Terraform will use the Terraform state to analyze the
    environment by querying the provider (s) about the health and configuration of
    each resource declared within. Based on these results, Terraform will construct
    a set of instructions. Once Terraform executes these instructions, the current
    environment will match the desired environment—as described in the code. However,
    after the first time Terraform has executed your plan successfully, if you ask
    Terraform to create a plan again, it will consult the Terraform state and use
    the providers to consult the actual environment and see that no changes are needed:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Terraform 状态已存在，事情就变得有趣了，Terraform 将不得不证明其价值。Terraform 会使用 Terraform 状态来分析环境，向提供者查询每个声明资源的健康状态和配置。根据这些结果，Terraform
    会构建一组指令。一旦 Terraform 执行了这些指令，当前环境将与代码中描述的期望环境一致。然而，在 Terraform 第一次成功执行您的计划之后，如果您再次要求
    Terraform 创建一个计划，它会查询 Terraform 状态并使用提供者来检查实际环境，看到不需要进行任何更改：
- en: '![Figure 1.3 – Resource plan, Day 2: no changes in your environment](img/B21183_01_3.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – 资源计划，第二天：环境中没有变化](img/B21183_01_3.jpg)'
- en: 'Figure 1.3 – Resource plan, Day 2: no changes in your environment'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 资源计划，第二天：环境中没有变化
- en: 'To create such an instruction set, Terraform must generate a complete dependency
    graph of the resources within the environment to determine what order it must
    execute the instructions. The relationships between the resources infer these
    dependencies. If one resource takes in, as an input variable, the value of another
    resource’s output variable, Terraform will determine that there is a dependency
    between these resources:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成这样的指令集，Terraform 必须生成一个完整的资源依赖关系图，以确定必须按什么顺序执行指令。资源之间的关系推断出这些依赖关系。如果一个资源将另一个资源的输出变量作为输入变量，Terraform
    会判断这两个资源之间存在依赖关系：
- en: '![Figure 1.4 – Dependencies: one resource’s inputs is another resource’s outputs](img/B21183_01_4.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4 – 依赖关系：一个资源的输入是另一个资源的输出](img/B21183_01_4.jpg)'
- en: 'Figure 1.4 – Dependencies: one resource’s inputs is another resource’s outputs'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 依赖关系：一个资源的输入是另一个资源的输出
- en: Sometimes, Terraform will only know the results of instructions after executing
    them. Hence, the obligatory warning message `known after apply`. However, this
    dependency graph and the subsequent plan are the crux of the Terraform machine.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，Terraform 只有在执行完指令后才能知道其结果。因此，必然会有一个警告信息 `apply 后才知道`。然而，这个依赖关系图和随后的计划是 Terraform
    机器的关键所在。
- en: This process makes Terraform an idempotent tool, meaning it can be applied multiple
    times without changing the result beyond the initial application. Idempotence
    is not necessarily unique to Terraform across automation tools, as some tools
    operate similarly. **Ansible** is a great example, also ensuring that repeat operations
    do not alter the state unless changes are necessary.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程使得 Terraform 成为一个幂等工具，意味着它可以多次应用，而不会改变初次应用后的结果。幂等性并不仅仅是 Terraform 独有的，许多自动化工具也具有类似的功能。**Ansible**
    就是一个很好的例子，它也确保重复操作不会改变状态，除非必要时进行更改。
- en: Execution phases
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行阶段
- en: 'Terraform’s core workflow follows a three-stage process: *initialize*, *plan*,
    and *apply*:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 的核心工作流遵循三个阶段的过程：*初始化*、*规划* 和 *应用*：
- en: '![Figure 1.5 – Terraform execution phases](img/B21183_01_5.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5 – Terraform 执行阶段](img/B21183_01_5.jpg)'
- en: Figure 1.5 – Terraform execution phases
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – Terraform 执行阶段
- en: Let’s examine each stage to see what parts of our code base are being utilized
    and what actions Terraform is taking.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一检查每个阶段，看看我们的代码库中哪些部分正在被使用，以及 Terraform 正在执行哪些操作。
- en: Initialize
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 初始化
- en: 'First, initialize the Terraform workspace using the `terraform init` command,
    which loads and configures all referenced providers and modules:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用 `terraform init` 命令初始化 Terraform 工作空间，它会加载并配置所有引用的提供者和模块：
- en: "![Figure 1.6 – Terraform initialization loads provider and module dependencies\
    \ and verifies backend connect\uFEFFivity](img/B21183_01_6.jpg)"
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.6 – Terraform 初始化加载提供者和模块依赖关系，并验证后台连接性](img/B21183_01_6.jpg)'
- en: Figure 1.6 – Terraform initialization loads provider and module dependencies
    and verifies backend connectivity
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – Terraform 初始化加载提供者和模块依赖关系，并验证后台连接性
- en: Plan
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 规划
- en: Once a Terraform has initialized its workspace, it can generate a plan using
    the `terraform plan` command. Although the command seems simple, this is a very
    complex process.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Terraform 初始化了其工作区，它可以使用 `terraform plan` 命令生成计划。尽管这个命令看起来简单，但它是一个非常复杂的过程。
- en: 'First, a dependency graph is built of all resources using the implicit (and
    sometimes explicit relationships between them). Then, Terraform checks the state
    file to determine if it has already provisioned the resource. Suppose the resource
    exists in the state file. In that case, Terraform will communicate with the resource
    via its respective provider and compare the desired state with the expected state
    as stored in the state file and the actual state reported by the provider. Terraform
    makes note of any differences and creates an action plan for each resource. The
    action can be *create*, *update*, or *destroy*:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用隐式（有时是显式）关系建立所有资源的依赖图。然后，Terraform 检查状态文件，确定是否已经配置了该资源。假设该资源存在于状态文件中，在这种情况下，Terraform
    将通过相应的提供者与资源进行通信，并将所需状态与存储在状态文件中的预期状态以及提供者报告的实际状态进行比较。Terraform 会记录任何差异，并为每个资源创建操作计划。操作可以是*创建*、*更新*或*销毁*：
- en: "![Figure 1.7 – terraform plan evaluates the current code base with a set of\
    \ input variables and compares it against the workspace’s Terraform \uFEFFstate](img/B21183_01_7.jpg)"
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.7 – terraform plan 使用一组输入变量评估当前代码库，并与工作区的 Terraform 状态进行比较](img/B21183_01_7.jpg)'
- en: Figure 1.7 – terraform plan evaluates the current code base with a set of input
    variables and compares it against the workspace’s Terraform state
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 – terraform plan 使用一组输入变量评估当前代码库，并与工作区的 Terraform 状态进行比较。
- en: Apply
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 应用
- en: 'Once a Terraform has generated a plan, it can optionally execute it against
    the actual environment using the `terraform apply` command. Using the dependency
    graph, Terraform will execute each resource action in sequence. If resource actions
    are not dependent on each other, then Terraform will execute them in parallel.
    During this phase, Terraform will constantly communicate with each provider, initiating
    commands and checking the status of the relevant provider. As Terraform completes
    resource actions, it will continually update the Terraform state:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Terraform 生成了计划，它可以选择使用 `terraform apply` 命令在实际环境中执行该计划。通过依赖图，Terraform 将按顺序执行每个资源操作。如果资源操作之间没有相互依赖，则
    Terraform 会并行执行它们。在此阶段，Terraform 会不断与每个提供者进行通信，发出命令并检查相关提供者的状态。随着 Terraform 完成资源操作，它会不断更新
    Terraform 状态：
- en: "![Figure 1.8 – terraform apply executes the plan through communication with\
    \ the providers, updates the Terraform state, and returns output var\uFEFFiables](img/B21183_01_8.jpg)"
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.8 – terraform apply 通过与提供者的通信执行计划，更新 Terraform 状态，并返回输出变量](img/B21183_01_8.jpg)'
- en: Figure 1.8 – terraform apply executes the plan through communication with the
    providers, updates the Terraform state, and returns output variables
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 – terraform apply 通过与提供者的通信执行计划，更新 Terraform 状态，并返回输出变量。
- en: Resource actions
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源操作
- en: When Terraform generates a plan, it evaluates each resource to determine if
    change is required to achieve the desired state of the infrastructure. There are
    several different situations where Terraform will determine action is needed on
    a particular resource.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Terraform 生成计划时，它会评估每个资源，确定是否需要更改以实现基础设施的期望状态。Terraform 会根据多种不同的情况判断是否需要对特定资源执行操作。
- en: Create
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建
- en: 'A create action can occur in three situations:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 创建操作可以在三种情况下发生：
- en: The resource is completely new
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该资源是全新的。
- en: Something outside of Terraform deleted the resource
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些非 Terraform 的操作删除了资源。
- en: The developer updated a resource’s code in such a way that the provider requires
    it to be destroyed and re-created
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者以一种方式更新了资源的代码，以至于提供者要求销毁并重新创建该资源。
- en: 'Here’s what adding a new resource looks like:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是添加新资源的示例：
- en: '![Figure 1.9 – Adding a new resource](img/B21183_01_9.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.9 – 添加新资源](img/B21183_01_9.jpg)'
- en: Figure 1.9 – Adding a new resource
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9 – 添加新资源
- en: When a resource is entirely new, it doesn’t exist in the Terraform state file.
    For example, we want to create a `vm001`. If this is the case, Terraform doesn’t
    use the provider to check if the resource is there. As a result, you can run into
    situations where the plan will generate successfully, but when Terraform executes
    the plan, it will fail. This situation usually boils down to resource naming conflicts
    when another user has provisioned another unrelated resource with the same name
    as the one Terraform plans to create (that is, somebody has already provisioned
    a VM named `vm001`). This situation can occur if someone creates a resource manually
    or even when a resource is created through Terraform but in a different Terraform
    workspace and, consequently, a different Terraform state file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个资源是全新的，它并不存在于 Terraform 状态文件中。例如，我们想创建一个 `vm001`。在这种情况下，Terraform 不会使用提供者来检查该资源是否存在。因此，您可能会遇到这种情况：计划生成成功，但当
    Terraform 执行计划时，它会失败。这种情况通常是因为资源命名冲突，当另一个用户已为与 Terraform 计划创建的资源无关的资源分配了相同的名称（即某人已经创建了名为
    `vm001` 的虚拟机）。这种情况可能发生在某人手动创建资源，或者即使资源是通过 Terraform 创建的，但位于不同的 Terraform 工作区，从而导致使用不同的
    Terraform 状态文件。
- en: 'A prime example of the concept of **drift** is when someone manually deletes
    a resource outside of Terraform:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**漂移**概念的一个典型例子是，当某人手动删除了 Terraform 之外的资源时：'
- en: '![Figure 1.10 – Drift](img/B21183_01_10.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.10 – 漂移](img/B21183_01_10.jpg)'
- en: Figure 1.10 – Drift
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10 – 漂移
- en: When a developer changes a resource, sometimes the provider requires it to be
    destroyed and then re-created. For example, we want to change our VM’s hardware
    profile from 4 CPU cores and 16 GB RAM to 8 CPU cores and 32 GB RAM. This logic
    exists in the provider’s code base at the resource level. It would help if you
    carefully check the documentation of the resources you are using to ensure you
    are aware of any potential disruptions or data loss that could occur when updates
    force a resource to be destroyed and re-created.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者更改资源时，有时提供者要求将其销毁并重新创建。例如，我们想将虚拟机的硬件配置从 4 核 CPU 和 16 GB 内存更改为 8 核 CPU 和
    32 GB 内存。这种逻辑存在于提供者的资源级代码库中。您应仔细查看所使用资源的文档，以确保了解在更新过程中强制销毁并重新创建资源时可能出现的任何中断或数据丢失。
- en: Change
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更改
- en: 'A change action can occur in two situations:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 变更操作可以发生在两种情况下：
- en: The resource has changed in code
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该资源已在代码中发生变化
- en: The resource has been modified outside of Terraform
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该资源已在 Terraform 之外被修改
- en: 'Here’s what changing an existing resource looks like:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是更改现有资源的情况：
- en: '![Figure 1.11 – Updating an existing resource](img/B21183_01_11.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.11 – 更新现有资源](img/B21183_01_11.jpg)'
- en: Figure 1.11 – Updating an existing resource
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11 – 更新现有资源
- en: This change won’t require the resource to be destroyed and re-created. This
    could be something simple such as changing the tags of a resource. These types
    of changes can also be introduced by drift. For example, someone adds a new tag
    manually using the cloud platform’s management portal without updating the Terraform
    code base.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这种更改不需要销毁并重新创建资源。它可能是一些简单的操作，比如更改资源的标签。这类更改也可能是由漂移引起的。例如，某人使用云平台的管理门户手动添加了一个新标签，但没有更新
    Terraform 代码库。
- en: Destroy
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 销毁
- en: 'A destroy action can occur in two situations:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 销毁操作可以发生在两种情况下：
- en: The developer deleted the resource from the code
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者已从代码中删除了该资源
- en: The developer updated a resource’s code in such a way that the provider requires
    it to be destroyed and re-created
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者更新了资源的代码，以至于提供者要求将其销毁并重新创建
- en: 'Here’s what removing an existing resource looks like:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是移除现有资源的情况：
- en: '![Figure 1.12 – Removing an existing resource](img/B21183_01_12.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.12 – 移除现有资源](img/B21183_01_12.jpg)'
- en: Figure 1.12 – Removing an existing resource
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12 – 移除现有资源
- en: This could be as simple as removing an unused—or, more likely, no longer used—resource.
    For example, removing an unnecessary `22` to the entire internet—is probably a
    good idea!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个简单的操作，比如移除一个不再使用的资源——或者更可能的是，已经不再使用的资源。例如，移除对整个互联网的多余的 `22` 端口——这可能是个好主意！
- en: Resource action plans can have a cascading effect. Naturally, dependent resources
    are also new if a resource is entirely new. However, it would be best to be mindful
    when the resource needs to be destroyed and re-created. This action is called
    a **drop-create** action. When a resource plays a critical role within the environment,
    it is very common that when a drop-create action occurs, there will be a large
    swath of the resource graph that will also be destroyed and then re-created—usually,
    any resource dependent on the resource being drop-created.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 资源操作计划可能会产生级联效应。自然地，如果一个资源是全新的，那么其依赖的资源也会变成新的。然而，最好在资源需要销毁并重新创建时保持谨慎。这个操作被称为**丢弃重建**（drop-create）操作。当资源在环境中扮演关键角色时，当发生丢弃重建操作时，通常会有一大片资源图也会被销毁并重新创建——通常是任何依赖于被丢弃重建资源的资源。
- en: Configuration language
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置语言
- en: 'When Terraform was first only a glimmer in the minds of Armon Dadgar and Mitchell
    Hashimoto, the industry had two paradigms of **Infrastructure-as-Code** (**IaC**):
    imperative, which dominated under the names of Chef and Puppet, using traditional
    programming languages such as Ruby and Python. However, there were declarative
    approaches, but most were an exercise of crafting large and complex JSON documents.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当Terraform最初只是在Armon Dadgar和Mitchell Hashimoto的脑海中闪现时，业界已经有两种**基础设施即代码**（**IaC**）的范式：命令式，该范式通过Chef和Puppet等工具占主导地位，使用传统的编程语言，如Ruby和Python。然而，也有声明式的方法，但大多数方法都只是编写大型复杂JSON文档的练习。
- en: The two major cloud platforms, **Amazon Web Services** (**AWS**) and **Microsoft
    Azure**, had already adopted resource typing in their respective IaC solutions.
    AWS CloudFormation and **Azure Resource Manager** (**ARM**) templates leveraged
    a consistent schema to describe resources of various types. Each resource type
    had a standard set of attributes that helped the platform target the appropriate
    resource provider to handle the request. Likewise, each resource type had its
    own custom attributes and schema to configure its unique nature. But the solutions
    were silos within the respective cloud platforms.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 两大云平台，**亚马逊网络服务**（**AWS**）和**微软Azure**，已经在各自的IaC解决方案中采用了资源类型化。AWS CloudFormation和**Azure资源管理器**（**ARM**）模板采用了一致的架构来描述各种类型的资源。每种资源类型都有一套标准属性，帮助平台定位适当的资源提供商来处理请求。同样，每种资源类型也有自己特定的属性和架构来配置其独特性。但是，这些解决方案仍然局限于各自的云平台内。
- en: So, in many ways, the industry was primed and ready for a solution that would
    adopt a resource type-based approach and thus knock down the silos between cloud
    providers enabling, at the very least, a tool that could describe resources on
    multiple clouds within the same context. There were challenges with both imperative
    and declarative approaches.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在许多方面，业界已经为一个采用资源类型化的方法的解决方案做好了准备，从而打破了云服务提供商之间的壁垒，至少提供了一个能够在同一上下文中描述多个云平台上资源的工具。命令式和声明式方法都有各自的挑战。
- en: Imperative approaches resulted in overly complex code, nested structures, and
    elaborate state-checking logic made for difficult-to-maintain code bases that
    could quickly descend into spaghetti code. Also, programming language and platform
    heritage could stoke religious rivalries between developer camps.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式方法导致代码过于复杂、嵌套结构过多，并且复杂的状态检查逻辑使得代码库难以维护，快速变成“意大利面条代码”。此外，编程语言和平台的遗产可能会激起开发者阵营之间的宗教性竞争。
- en: The declarative solutions, on the other hand, relied on industry-standard document
    formats such as **JSON** and **YAML**. These formats encouraged a simple top-down
    approach and induced no tribalism due to their neutral nature. However, they made
    it difficult to represent complex expressions and implement simple iterations
    and loops, and even simple things such as annotating code with code comments were
    not possible or overly cumbersome.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式解决方案则依赖于行业标准的文档格式，如**JSON**和**YAML**。这些格式鼓励简单的自上而下的方式，并由于其中立性避免了部落主义。然而，它们使得表示复杂表达式以及实现简单的迭代和循环变得困难，甚至像给代码添加注释这样的简单操作也无法实现，或者做起来非常繁琐。
- en: Terraform brought the best of both worlds by bringing elements of an imperative
    language, such as expressions and looping, and fusing it with the best of the
    declarative model that encouraged a simple top-down approach to defining resources
    within an environment.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform通过引入命令式语言的元素，如表达式和循环，并将其与声明式模型的优势相结合，从而带来了两者的最佳结合。声明式模型鼓励以简单的自上而下的方式定义环境中的资源。
- en: '**HCL** uses simple block definitions that allow for a more concise representation
    of resources than other declarative solutions but a more code-like syntax, all
    linking between blocks that acknowledges the resource type-driven nature of cloud
    computing in its bones:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**HCL** 使用简单的块定义，相比其他声明式解决方案，它能够更简洁地表示资源，但语法更像代码，所有块之间的链接都体现了云计算本质上基于资源类型的特点：'
- en: '[PRE0]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A block’s definition has three parts: the `resource`, the resource type is
    `random_string`, and the reference name is `foo`. To create dependencies between
    resources, we use the reference name and type to access output values from the
    resource:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一个块的定义有三个部分：`resource`、资源类型是`random_string`，以及引用名称是`foo`。为了在资源之间创建依赖关系，我们使用引用名称和类型来访问资源的输出值：
- en: '[PRE1]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, we create an Azure resource group by referencing the
    `result` output value from the random string named `foo`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过引用名为`foo`的随机字符串的`result`输出值来创建一个 Azure 资源组。
- en: 'This simple pattern describes how we can combine dozens, sometimes hundreds,
    of resources to build sophisticated cloud architectures:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的模式描述了我们如何将几十个，有时是上百个资源组合在一起，构建复杂的云架构：
- en: '![Figure 1.13 – Chaining of Terraform resources, where the outputs of one resource
    act as inputs to another](img/B21183_01_13.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.13 – Terraform 资源的链式连接，其中一个资源的输出作为另一个资源的输入](img/B21183_01_13.jpg)'
- en: Figure 1.13 – Chaining of Terraform resources, where the outputs of one resource
    act as inputs to another
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.13 – Terraform 资源的链式连接，其中一个资源的输出作为另一个资源的输入
- en: Using this preceding pattern in HCL allows Terraform to determine the relationships
    between our resources and construct a plan to provision them all. The funny part
    and the sheer brilliance of the whole thing is that it’s just a fancy game of
    connecting the dots.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种模式在 HCL 中，Terraform 可以确定资源之间的关系，并构建一个计划来配置它们。最有趣和最聪明的地方在于，这其实只是一个连接点的精妙游戏。
- en: Modularity
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块化
- en: Everything lives in modules. When you make your first Terraform project, you
    inadvertently create your first Terraform module. That’s because every Terraform
    project is a root module. In your root module, you declare providers,
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都存在于模块中。当你创建第一个 Terraform 项目时，你无意中创建了第一个 Terraform 模块。这是因为每个 Terraform 项目都是一个根模块。在根模块中，你声明提供者，
- en: One ubiquitous pattern within Terraform is that when you code resources, modules,
    or data sources, you work with inputs and outputs. Each Terraform resource and
    data source works in this manner, as does your entire Terraform workspace, allowing
    Terraform to be embedded neatly into a toolchain within a pipeline to provision
    an environment.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 中的一个普遍模式是，当你编写资源、模块或数据源时，你会处理输入和输出。每个 Terraform 资源和数据源都以这种方式工作，你的整个
    Terraform 工作区也是如此，这使得 Terraform 可以被整齐地嵌入到管道中的工具链中，以配置环境。
- en: The root module doesn’t have to be the only module that you write. You can create
    reusable modules that are designed to encapsulate reusable aspects of your solutions
    that can be shared across root modules. The difference between a root module and
    a reusable module is that the root module is designed to be the entry point for
    deploying one or more environments. Reusable modules are simply components that
    define useful patterns or best practices and allow you to save time having to
    re-create them whenever you want to create a new environment or a similar solution.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 根模块并不一定是你编写的唯一模块。你可以创建可重用的模块，设计用来封装解决方案中可重复使用的部分，并可以跨根模块共享。根模块和可重用模块之间的区别在于，根模块是为部署一个或多个环境而设计的入口点。可重用模块只是定义有用模式或最佳实践的组件，它们可以帮助你节省每次创建新环境或类似解决方案时重复创建它们的时间。
- en: Now that we have taken a high-level look at Terraform’s architecture and understand
    the core technology, we know that it comprises the Terraform command-line application
    and the HCL functional language. We also know that Terraform’s superpower is that
    the design of the core technology is highly extensible by leveraging providers
    to adapt the technology to a multitude of extremely diverse platforms and technologies
    and the built-in modularity that enables practitioners to easily create simple
    or sophisticated IaC solutions that can be packaged and made to be reusable across
    teams and organizations.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经高层次地了解了 Terraform 的架构，并理解了其核心技术，我们知道它包括 Terraform 命令行应用程序和 HCL 函数语言。我们还知道，Terraform
    的超能力在于，核心技术的设计通过利用提供者来扩展，非常适应不同的平台和技术，并且内置的模块化使得实践者能够轻松创建简单或复杂的 IaC 解决方案，这些解决方案可以被打包并在不同团队和组织之间重用。
- en: Next, we’ll delve into a critical subsystem that enables Terraform to achieve
    consistent, idempotent IaC motion across various platforms and technologies.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入探讨一个关键子系统，使 Terraform 能够在各种平台和技术上实现一致的、幂等的基础设施即代码（IaC）操作。
- en: Understanding Terraform state
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Terraform 状态
- en: Terraform uses the state to remember what was previously provisioned in a given
    workspace. Some critics of Terraform, when they compare it to AWS CloudFormation
    or ARM templates, point out that these technologies don’t rely on this concept
    of maintaining state in an externalized file. Of course, this is only true because
    these tools only support a single target platform and can tightly couple to the
    proprietary nature in which those platforms maintain state. However, Terraform—with
    its flexible plugin architecture—can’t assume anything about the platform and
    the resources that it provisions to each target platform. Therefore, Terraform
    needs to drop to the lowest common denominator and ensure that it knows what it
    has provisioned before in a uniform and consistent fashion.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 使用状态来记住在给定工作区中之前已配置的内容。一些 Terraform 的批评者在将其与 AWS CloudFormation 或
    ARM 模板进行比较时指出，这些技术并不依赖于将状态保存在外部文件中的概念。当然，这仅仅是因为这些工具只支持单一的目标平台，并且可以与这些平台维护状态的专有方式紧密耦合。然而，Terraform
    通过其灵活的插件架构，不能假设任何关于平台及其为每个目标平台配置的资源。因此，Terraform 需要回到最基本的层面，并确保它以统一和一致的方式知道自己之前配置了什么。
- en: This approach to maintaining the state provides a couple of benefits. First,
    it uniformly records what Terraform has provisioned across platforms that maintain
    their internal state and those that don’t. Second, it allows Terraform to define
    a boundary between managed and unmanaged resources.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种维护状态的方法提供了几个好处。首先，它统一地记录了 Terraform 在那些维护内部状态的以及那些不维护状态的平台上的配置内容。其次，它允许 Terraform
    定义受管理和未受管理资源之间的边界。
- en: 'This problem is the classic **Jurassic Park problem**. In *Jurassic Park*,
    they had genetically engineered all these dinosaurs. They engineered them with
    population control in mind—so that they couldn’t mate—or so they thought. In the
    park, they had all these sophisticated systems to track where all the dinosaurs
    were and how many of them there were. However, the big flaw of their design was
    that they programmed their systems to only look for dinosaurs that they genetically
    engineered. So, their system worked flawlessly and showed them where all the dinosaurs
    they created were. Wouldn’t you know it? The number of dinosaurs always matched
    the number they expected to see. That’s bad for Jurassic Park because, due to
    this flaw, they were unaware of a defect in their genetic engineering that allowed
    the dinosaurs to mate. Jurassic Park had too many dinosaurs, and things got—well—a
    little out of hand:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题就是经典的**侏罗纪公园问题**。在*侏罗纪公园*中，他们基因工程化了所有这些恐龙。他们在设计时考虑了种群控制——这样它们就无法交配——或者他们以为如此。在公园里，他们有所有这些复杂的系统来追踪恐龙的位置和数量。然而，他们设计的一个大缺陷是，他们只让系统查找他们基因工程化的恐龙。因此，他们的系统运行得完美无缺，能告诉他们所有他们创造的恐龙在哪里。你猜怎么着？恐龙的数量总是和他们预计的数量相符。这对侏罗纪公园来说是坏事，因为由于这个缺陷，他们没有意识到基因工程中的问题，使得恐龙能够交配。侏罗纪公园的恐龙数量过多，事情变得——嗯——有点失控：
- en: f
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: f
- en: '![Figure 1.14 – The Jurassic Park problem](img/B21183_01_14.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.14 – 侏罗纪公园问题](img/B21183_01_14.jpg)'
- en: Figure 1.14 – The Jurassic Park problem
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.14 – 侏罗纪公园问题
- en: 'Terraform only looks for resources that it has provisioned. It can do that
    because it maintains a state file. The state file is just like the list of dinosaurs
    that Jurassic Park thinks it has. This approach was terrible for Jurassic Park.
    But for Terraform, it’s a good thing:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 只会查找它所管理的资源。它能做到这一点是因为它维护着一个状态文件。这个状态文件就像《侏罗纪公园》认为自己拥有的恐龙清单。对于《侏罗纪公园》来说，这种做法很糟糕。但对于
    Terraform 来说，这是件好事：
- en: '![Figure 1.15 – Terraform ignores resources provisioned externally, even if
    those resources draw dependencies on resources provisioned by Terraform](img/B21183_01_15.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.15 – Terraform 忽略外部创建的资源，即便这些资源与 Terraform 创建的资源有依赖关系](img/B21183_01_15.jpg)'
- en: Figure 1.15 – Terraform ignores resources provisioned externally, even if those
    resources draw dependencies on resources provisioned by Terraform
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.15 – Terraform 忽略外部创建的资源，即便这些资源与 Terraform 创建的资源有依赖关系
- en: Why? Because not all resources are going to be—or need to be—created and managed
    by Terraform. By clearly scoping what Terraform is responsible for (and what it’s
    not), it allows Terraform to be flexible in allowing organizations to choose their
    level of involvement with Terraform. Some teams and organizations will start small
    and only deploy a few things with Terraform. At the same time, others might go
    nuts and provision everything with Terraform. Still, there will very likely be
    things that are happening that Terraform doesn’t know about. The Terraform state
    is constructing guard rails to keep Terraform in its box and let it know what
    it’s allowed to touch. Doing so enables Terraform to play well with others and
    gives freedom to teams and individuals to use whatever method or tools they want
    to control aspects of an environment.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？因为并非所有资源都会——或需要——由 Terraform 创建和管理。通过清晰地界定 Terraform 负责的内容（以及它不负责的内容），它使
    Terraform 在允许组织选择与 Terraform 互动的程度上更加灵活。一些团队和组织会从小处开始，只使用 Terraform 部署少量内容。与此同时，其他团队可能会非常积极，使用
    Terraform 管理一切。不过，仍然可能存在 Terraform 无法识别的操作。Terraform 的状态文件构建了防护栏，确保 Terraform
    只在其许可范围内工作，明确它可以处理哪些内容。这样做使得 Terraform 能够与其他工具兼容，并给予团队和个人在环境控制方面使用任何方法或工具的自由。
- en: State file
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态文件
- en: Terraform state is a JSON data file stored somewhere Terraform knows how to
    find it. This file maintains a list of resources. Each resource has a resource
    type identifier and all configurations for that resource.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 状态文件是一个 JSON 数据文件，存储在 Terraform 知道如何访问的某个位置。这个文件维护了一个资源列表。每个资源都有一个资源类型标识符和该资源的所有配置信息。
- en: 'The state file mirrors what we describe in our code but is much more verbose
    than what we declare in our code. The following code generates a random string
    with a length of four characters, no uppercase characters, and no special-case
    characters:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 状态文件反映了我们在代码中描述的内容，但比代码中声明的内容要详细得多。以下代码生成一个长度为四个字符的随机字符串，且不包含大写字母和特殊字符：
- en: '[PRE2]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After running `terraform apply`, Terraform will produce a state file containing
    the same resource but with more context:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `terraform apply` 后，Terraform 会生成一个状态文件，其中包含相同的资源，但会提供更多上下文信息：
- en: '[PRE3]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `provider` and `type` instances help identify which resource type this resource
    is and which Terraform providers the developer uses.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`provider` 和 `type` 实例有助于识别该资源的类型以及开发者使用的 Terraform 提供者。'
- en: The `schema_version` parameter of the resource attribute helps identify whether
    the current resource is compatible with the current version of the provider. If
    it is not, it can help give the provider an indicator of how to upgrade it to
    the latest version of the schema.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 资源属性中的 `schema_version` 参数有助于识别当前资源是否与提供者的当前版本兼容。如果不兼容，它可以帮助提供者判断如何将资源升级到最新版本的架构。
- en: Partial resource management
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分资源管理
- en: Due to Terraform’s nature as a piece of **open source software** (**OSS**) and
    the built-in assumption that these cloud providers are their own piece of software
    that is evolving over time, at a different pace than the Terraform providers,
    there will be periods of time where the cloud providers will have features that
    Terraform is unaware of.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Terraform 本身是一个 **开源软件** (**OSS**)，并且内置假设这些云服务商是各自独立的软件，在不断演化，与 Terraform
    提供者的更新速度不同，因此会有一段时间，云服务商会推出 Terraform 无法识别的功能。
- en: When this happens, we don’t want Terraform to fight with the cloud provider
    to turn them off just because Terraform isn’t aware of them. This scenario is
    extremely common as it presents itself naturally when an environment is being
    managed by Terraform and a specific version of the Terraform provider. As the
    Terraform provider has new features added to keep pace with the target cloud platform,
    the provider version is not always kept up to date in the Terraform code—nor should
    it have to be.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，我们不希望 Terraform 与云提供商争论禁用这些功能，仅仅因为 Terraform 无法识别它们。这个场景非常常见，因为当一个环境由
    Terraform 和特定版本的 Terraform 提供程序管理时，它自然而然地会出现。随着 Terraform 提供程序不断增加新功能以跟上目标云平台的步伐，提供程序版本在
    Terraform 代码中并不总是保持最新——而且它不必一直保持最新。
- en: Let’s say we provide an environment using Terraform and v1.0, our favorite cloud
    platform’s Terraform provider. The next day, our favorite cloud provider added
    this amazing feature, Feature X. We still have the same code and the same Terraform
    state file, but we are extremely eager to try out Feature X. However, we are using
    the latest version of the Terraform provider—v1.0—and it has no support for Feature
    X.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用 Terraform 和 v1.0 提供一个环境，使用的是我们最喜欢的云平台的 Terraform 提供程序。第二天，我们最喜欢的云提供商增加了一个令人惊叹的功能，Feature
    X。我们依然使用相同的代码和 Terraform 状态文件，但我们非常渴望尝试 Feature X。然而，我们使用的是最新版本的 Terraform 提供程序——v1.0——它并不支持
    Feature X。
- en: What can we do? Well, we can wait for our friendly internet strangers who contribute
    to the Terraform provider’s open source project to add support for Feature X.
    However, we don’t know when that will be.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们该怎么办呢？嗯，我们可以等着我们那些贡献于 Terraform 提供程序开源项目的友好的互联网陌生人来增加对 Feature X 的支持。但是，我们不知道什么时候会有支持。
- en: Did we mention we were extremely eager to try out Feature X? If we just can’t
    wait, we could just enable Feature X directly on our favorite cloud platform.
    *Wouldn’t this create drift*, you say? In normal circumstances—yes—as we’re modifying
    our Terraform-managed resource using our favorite cloud platform web interface.
    Normally, the next time we run `terraform apply`, Terraform will detect that changes
    have been made to that resource outside the environment and revert our changes.
    However, since we are on v1.0 of the Terraform provider, Terraform is happily
    ignorant of Feature X. Thus, any changes we make to the configuration of Feature
    X will go unnoticed by Terraform. This also means that if you delete that `terraform
    destroy` resource and re-create it, you’d have to go out to the portal and manually
    reconfigure Feature X all over again.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到过我们非常渴望尝试 Feature X 吗？如果我们实在等不及，我们可以直接在我们最喜欢的云平台上启用 Feature X。*这样不会造成偏差吗*，你可能会问？在正常情况下——是的——因为我们在使用最喜欢的云平台的网页界面修改
    Terraform 管理的资源。通常，下次我们运行 `terraform apply` 时，Terraform 会检测到资源在外部环境发生了变化，并将这些更改回滚。但是，由于我们使用的是
    v1.0 版本的 Terraform 提供程序，Terraform 对 Feature X 幸灾乐祸地一无所知。因此，我们对 Feature X 配置所做的任何更改都不会被
    Terraform 注意到。这也意味着，如果你删除了那个 `terraform destroy` 资源并重新创建它，你将不得不再次去门户网站手动重新配置 Feature
    X。
- en: That is, until we upgraded to v1.1 of the Terraform provider, which was released
    the day after we manually set up Feature X on our resource. Now that we are using
    v1.1 of the Terraform provider, the resource Terraform is using to provision that
    service to our favorite cloud platform is now aware of Feature X. If our code
    is still the same, it’s going to think that Feature X shouldn’t be enabled at
    all and should remove it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，直到我们升级到 v1.1 版本的 Terraform 提供程序，而该版本是在我们手动在资源上设置 Feature X 的第二天发布的。现在，我们正在使用
    v1.1 版本的 Terraform 提供程序，Terraform 用来将该服务部署到我们最喜欢的云平台的资源现在已经知道了 Feature X。如果我们的代码没有变化，它会认为
    Feature X 不应该被启用，并且会将其移除。
- en: 'To avoid this, we’ll need to carefully run `terraform plan` with v1.1 of the
    Terraform provider to see what changes Terraform is planning using this upgraded
    version of the provider. Then, we’ll need to update our code to configure Feature
    X just as it is configured. Once we do that, Terraform will see that no changes
    are required, and Terraform will bring Feature X under management:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，我们需要仔细使用 v1.1 版本的 Terraform 提供程序运行 `terraform plan`，查看 Terraform 在使用这个升级版本的提供程序时计划做出哪些更改。然后，我们需要更新我们的代码以按现有配置配置
    Feature X。一旦我们完成这个操作，Terraform 会看到无需做出更改，且 Terraform 将会将 Feature X 纳入管理：
- en: '![Figure 1.16 – Managing the perpetual change that occurs as a new cloud platform’s
    capabilities are created, exposed through the Terraform provider and adopted in
    your Terraform codebase](img/B21183_01_16.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.16 – 管理新云平台功能发布时，Terraform 提供程序中展示的持续变化，以及如何在 Terraform 代码库中采纳这些变化](img/B21183_01_16.jpg)'
- en: Figure 1.16 – Managing the perpetual change that occurs as a new cloud platform’s
    capabilities are created, exposed through the Terraform provider and adopted in
    your Terraform codebase
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.16 – 管理随着新云平台功能的创建、通过 Terraform 提供者暴露并在 Terraform 代码库中采纳所发生的持续变化
- en: Now that we have looked at how Terraform maintains the state and how this aspect
    of its architecture affects how Terraform creates and executes plans, let’s move
    on to the more practical topic of developing and consuming modules.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Terraform 如何维护状态以及这一架构方面如何影响 Terraform 创建和执行计划，让我们转向一个更实际的话题：开发和使用模块。
- en: Understanding how to build and consume modules
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解如何构建和使用模块
- en: One of Terraform’s most powerful capabilities is its ease of organizing and
    packaging reusable code, which increases the maintainability of your code base
    and improves the reusability of common patterns in your architecture.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 最强大的功能之一是它组织和打包可重用代码的便捷性，这增加了代码库的可维护性并提高了架构中常见模式的可重用性。
- en: Traditional developers have it easy—you must simply create a new method to encapsulate
    a reusable code block. In other IaC tools, doing the same thing is a challenge.
    In Terraform, all you need is a new folder.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 传统开发者相对容易——你只需要创建一个新方法来封装可重用的代码块。而在其他基础设施即代码（IaC）工具中，实现同样的功能却是一个挑战。在 Terraform
    中，你所需要的只是一个新文件夹。
- en: Terraform scopes every module within a folder. When you run `terraform init`,
    Terraform transforms the current working directory into the root module of the
    workspace. You can use modules stored in other folders within the same repository
    just by using a relative path to reference the module. It is a standard convention
    within the Terraform community for storing local modules in a `modules` directory
    near the root module’s directory.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 将每个模块作用域限定在一个文件夹内。当你运行`terraform init`时，Terraform 会将当前工作目录转变为工作区的根模块。你可以通过使用相对路径来引用存储在同一仓库内其他文件夹中的模块。在
    Terraform 社区中，将本地模块存储在接近根模块目录的`modules`目录下是一种标准约定。
- en: 'Consider this folder structure:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下这个文件夹结构：
- en: '[PRE4]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The path to the root module is `/terraform/root`. The path to the `rando` module
    is `/terraform/modules/rando`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 根模块的路径是`/terraform/root`。`rando`模块的路径是`/terraform/modules/rando`。
- en: 'Consider the contents of the root module:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑根模块的内容：
- en: '[PRE5]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding list of files is a typical convention for the file structure of
    a module. In the `versions.tf` file, you should declare the `terraform` block,
    which contains both the Terraform version and each of the referenced Terraform
    providers and their corresponding versions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 上述文件列表是模块文件结构的典型约定。在`versions.tf`文件中，你应该声明`terraform`块，该块包含 Terraform 版本及每个引用的
    Terraform 提供者和它们对应的版本。
- en: In the `variables.tf` file, you should declare all the input variables this
    module expects. It’s essential to keep all input variables declared in one place
    to make it easier for the module consumer to understand the contract for this
    module.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在`variables.tf`文件中，你应该声明该模块期望的所有输入变量。将所有输入变量集中声明在一个地方是非常重要的，这样可以让模块的使用者更容易理解该模块的合同。
- en: Likewise, in the `outputs.tf` file, you should be used to declare all the output
    values that this module will produce.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在`outputs.tf`文件中，你应该声明该模块将生成的所有输出值。
- en: Since it is possible to declare input variables and outputs in any `.tf` file
    within the folder, nothing prevents you from following this approach. However,
    you don’t want to make other developers scan every file in your module’s folder
    for a `variable` block to get a good understanding of the module’s interface.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可以在文件夹内的任何 `.tf` 文件中声明输入变量和输出，因此没有什么阻止你采用这种方法。然而，你不希望其他开发者需要扫描模块文件夹中的每个文件，寻找
    `variable` 块，以便清楚了解模块的接口。
- en: In the `main.tf` file, you should declare the *meat* of your module. This file
    is where the magic happens. However, you are not limited to just one file. At
    your discretion, you can create additional `.tf` files to better organize more
    complex modules into relevant sections or groupings of related resources.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.tf`文件中，你应该声明模块的*核心*内容。这是发生魔法的地方。然而，你并不局限于只有一个文件。根据需要，你可以创建额外的`.tf`文件，将更复杂的模块更好地组织成相关资源的不同部分或分组。
- en: 'We need to understand the relative path to get to the `rando` module to reference
    the `rando` module from the root module. This relative path is calculated based
    on the root module’s working directory. Therefore, a declaration of the `rando`
    module would look like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要理解相对路径，以便从根模块引用 `rando` 模块。这个相对路径是基于根模块的工作目录来计算的。因此，`rando` 模块的声明应该如下所示：
- en: '[PRE6]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `source` meta-argument is a required attribute for every `module` block.
    You’ll notice that declaring a module differs slightly from declaring a resource
    or a data source. For example, when declaring a module, the resource type is omitted.
    That’s because a `module` block is both a block type and a resource type. Therefore,
    besides the module block definition, we only need a reference name.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`source` 元素是每个 `module` 块的必需属性。你会注意到，声明模块与声明资源或数据源稍有不同。例如，声明模块时省略了资源类型。这是因为
    `module` 块既是一个块类型，也是一个资源类型。因此，除了模块块的定义外，我们只需要一个引用名称。'
- en: 'We can reference our module’s output values simply by recognizing that `module`
    is the resource type:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过简单地认识到 `module` 是资源类型来引用模块的输出值：
- en: '[PRE7]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see in the preceding code, we are referencing the `result` attribute
    on a module called `foo` because modules are not as descriptive of a type; therefore,
    it’s even more important to give more detail in the reference name.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在前面的代码中看到的，我们引用了名为 `foo` 的模块上的 `result` 属性，因为模块不像资源类型那样具有描述性，因此在引用名称中提供更多的细节就显得尤为重要。
- en: Now that we understand the basics for creating and referencing our custom modules,
    let’s look deeper into the module design question.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了创建和引用自定义模块的基础知识，让我们更深入地探讨模块设计的问题。
- en: Module design
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块设计
- en: In many ways, the decision to create a module in Terraform is the same as deciding
    to write a new method when writing in a traditional programming language such
    as Java or C#.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，在 Terraform 中创建模块的决定与在传统编程语言（如 Java 或 C#）中决定编写新方法相同。
- en: Just like in a traditional programming language, you could write all your code
    from start to finish in a single file using a single method, and if there were
    repeated parts, you would copy and paste them to repeat them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在传统编程语言中一样，你可以在一个文件中从头到尾编写所有代码，使用一个方法，如果有重复的部分，你会复制粘贴它们。
- en: Just like in a traditional programming language, there are reasons to write
    methods encapsulating repeating blocks of code. Otherwise, if you didn’t encapsulate
    that code into a method, you’d have to copy and paste it repeatedly.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在传统编程语言中一样，编写封装重复代码块的方法是有原因的。否则，如果你没有将这些代码封装到方法中，就必须反复复制粘贴。
- en: The decision about when to create a module versus just putting it in the root
    module is an important one. You should have good reasons for creating a module.
    You should always focus on value. When someone uses your module—which could be
    just yourself or your team—does it make their life easier by using it?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 关于何时创建模块与仅将其放在根模块中的决定是一个重要的决策。你应该有充分的理由来创建模块。你应该始终关注价值。当某人使用你的模块时——可能是你自己或你的团队——使用它是否让他们的生活更轻松？
- en: Root modules
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 根模块
- en: There are many different ways to set up your root module in Terraform. The debate
    continues, with some vehemently advocating one method over the other. It’s important
    to be aware of the different approaches so that you can recognize them when you
    see them and evaluate which approach works best for you.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Terraform 中有许多不同的方式来设置根模块。关于哪种方法最好，辩论仍在继续，有些人强烈支持一种方法。了解不同的方法很重要，这样你就能在看到它们时识别出来，并评估哪种方法最适合你。
- en: Folder per environment
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 每个环境一个文件夹
- en: 'One common technique for structuring a root module is setting up a different
    folder for each environment you want to provision and maintain. In this approach,
    there is a folder for each long-lived environment. This folder contains a root
    module that can stand alone from the other environments. Consider the following
    folder structure:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的根模块结构化方法是为每个你想要提供和维护的环境设置不同的文件夹。在这种方法中，每个长期存在的环境都有一个文件夹。这个文件夹包含一个可以独立于其他环境的根模块。考虑以下文件夹结构：
- en: '[PRE8]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding folder structure has three environments: `dev`, `test`, and `prod`.
    Each environment has its own root module that is completely isolated from other
    modules. It has its own `required_providers` block and defines its own provider
    declarations. This approach has strong isolation between each environment—so much
    so that practically every aspect of the deployment could be altered from environment
    to environment. The version of Terraform, the version of the providers, and the
    version of the other modules used within the solution, the input parameters, and
    their values are all customized within the files within the corresponding folder
    for the environment.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 上述文件夹结构包含三个环境：`dev`、`test` 和 `prod`。每个环境都有自己的根模块，完全与其他模块隔离。它有自己的 `required_providers`
    块，并定义了自己的提供程序声明。这种方法在每个环境之间有强隔离，几乎每个部署的方面都可以在不同环境中进行调整。Terraform 版本、提供程序版本以及解决方案中使用的其他模块版本、输入参数及其值都在对应环境文件夹中的文件内进行定制。
- en: This approach is more common where the practitioners aren’t comfortable using
    GitFlow and maintaining other branches and following a `develop`) to more mature
    branches (for example, `main`—where production code exists).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法更常见于那些不熟悉使用 GitFlow、管理其他分支并跟随 `develop` 到更成熟分支（例如，`main`——生产代码所在的分支）的实践者。
- en: Variable file per environment
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 每个环境的变量文件
- en: Another technique is to maintain a single Terraform code base and multiple input
    variable files for each environment. This approach is focused on maintaining consistency
    and compatibility between environments. It is more difficult with this approach
    to make massive structural differences between the environments as it becomes
    difficult to merge changes from branch to branch.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种技术是维护一个单一的 Terraform 代码库，并为每个环境使用多个输入变量文件。这种方法侧重于在环境之间保持一致性和兼容性。采用这种方法时，更难在环境之间做出大规模的结构差异，因为合并分支之间的更改会变得困难。
- en: 'Consider the following folder structure:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下文件夹结构：
- en: '[PRE9]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As with the previous approach, where we had explicit folders for each environment,
    this approach still allows the same variation between environments but requires
    you to maintain long-lived branches for each environment as you make changes to
    the core structure of the root module. This aligns more with a software development
    process called GitFlow (more on that in [*Chapter 6*](B21183_06.xhtml#_idTextAnchor330)).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的方法一样，我们为每个环境创建了明确的文件夹，这种方法仍然允许环境之间的变化，但需要你为每个环境维护长期存在的分支，以便在你对根模块的核心结构进行更改时。这种方法更符合一种名为
    GitFlow 的软件开发流程（更多内容请参见 [*第6章*](B21183_06.xhtml#_idTextAnchor330)）。
- en: The key characteristics of this approach are that environmental differences
    are captured in different input variable values stored in the corresponding`.tfvars`
    files. The goal is that any variation between the environments will eventually
    be stored within these files, and the code bases for each environment—stored within
    several long-lived source code branches—will eventually mirror each other. This
    allows us to have different sizes and counts in our production environment versus
    our development environment and maintain consistency between the architecture
    and configuration deployed across each environment.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的关键特点是，环境差异通过不同的输入变量值保存在对应的 `.tfvars` 文件中。目标是将环境之间的任何变化最终存储在这些文件中，并且每个环境的代码库——存储在几个长期存在的源代码分支中——最终会相互镜像。这使我们能够在生产环境和开发环境之间拥有不同的大小和数量，并在每个环境中保持架构和配置的一致性。
- en: Reusable modules
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可重用模块
- en: Now that we have our root module under control, it’s time to start thinking
    about when to create reusable modules that can be utilized in our root modules
    to produce sophisticated cloud architectures that will power our applications
    and solutions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经控制了根模块，是时候开始思考何时创建可以在根模块中使用的可重用模块，从而构建精密的云架构，推动我们的应用程序和解决方案。
- en: Encapsulation of complexity
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 复杂性的封装
- en: 'The number of resources you plan to encapsulate within the module is an important
    metric, as it can indicate if you are reducing complexity by creating a module
    or adding more (spoiler alert: adding more is bad). Modules can range from one
    resource to dozens—even hundreds—of resources. When considering the number of
    resources you put into your module, you should consider the value you bring when
    someone uses the module.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你计划在模块中封装的资源数量是一个重要的衡量标准，因为它可以表明你通过创建模块是在减少复杂性，还是在增加复杂性（剧透警告：增加复杂性是不好的）。模块的资源数量可以从一个资源到几十个，甚至是成百上千个资源不等。在考虑将资源放入模块时，你应该考虑当有人使用这个模块时，你所带来的价值。
- en: If your module only encapsulates one resource block, your code would likely
    be simpler by directly referencing the resource. In this situation, the module
    adds a layer of abstraction on top of the underlying resource you are provisioning.
    If that’s all it’s doing, then you need to reduce the complexity more to justify
    the creation of a module.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的模块仅封装了一个资源块，那么通过直接引用该资源，你的代码可能会更简单。在这种情况下，模块只是对你正在配置的基础资源增加了一层抽象。如果仅仅是这样做，那么你需要进一步简化复杂性，以证明创建模块的必要性。
- en: 'Suppose your module encapsulates a few tightly related resources that are highly
    dependent on each other and have limited integration points with other resources.
    For example, when creating an NSG and a collection of rules. Creating a module
    encapsulating these tightly coupled resources might be a good idea because it
    will make it easier and more concise for the developer to create an NSG. In that
    case, this is the sweet spot for creating a module. You are likely trading one
    or two additional input variables for one or two additional corresponding resource
    blocks. That’s a good trade-off:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的模块封装了一些紧密相关的资源，这些资源高度依赖于彼此，并且与其他资源的集成点有限。例如，创建一个 NSG 和一组规则。当你创建一个封装这些紧密耦合资源的模块时，这可能是个好主意，因为它将使得开发人员创建
    NSG 变得更加简洁和容易。在这种情况下，这就是创建模块的最佳时机。你可能需要为一个或两个额外的输入变量换取一个或两个额外的相应资源块。这是一个不错的权衡：
- en: '![Figure 1.17 – Module design: encapsulation of complexity](img/B21183_01_17.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.17 – 模块设计：封装复杂性](img/B21183_01_17.jpg)'
- en: 'Figure 1.17 – Module design: encapsulation of complexity'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.17 – 模块设计：封装复杂性
- en: The preceding diagram shows that this module is provisioning three resource
    types. Our module defines a single interface that will provision this cluster
    of resources. Some simple inputs, `A` and `B`, are passed to the main resource
    and child resource 1\. A more complex input object, `C`, which happens to be an
    array, is passed in and used to construct a resource block for each item in the
    list.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示显示，该模块正在配置三种资源类型。我们的模块定义了一个单一的接口，用来配置这一组资源。一些简单的输入变量，`A` 和 `B`，被传递到主资源和子资源
    1 中。一个更复杂的输入对象，`C`，它恰好是一个数组，被传入并用来为列表中的每个项构建资源块。
- en: Repeating patterns
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重复模式
- en: 'Another common scenario is when you have many resources that you want to be
    repeated based on the size of a collection (either a list or a map). In this situation,
    you should tell each resource how many copies of it you want and pass in all the
    input variables to satisfy its requirements:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的情况是，当你有许多资源，并希望根据集合的大小（无论是列表还是映射）进行重复。在这种情况下，你应该告诉每个资源你希望它重复多少次，并传入所有的输入变量以满足其需求：
- en: '![Figure 1.18 – Module design: repeating inside the module](img/B21183_01_18.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.18 – 模块设计：在模块内重复](img/B21183_01_18.jpg)'
- en: 'Figure 1.18 – Module design: repeating inside the module'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.18 – 模块设计：在模块内重复
- en: 'However, if you encapsulate the repeating resources into a module, rather than
    repeating every resource, you repeat the module. This approach can significantly
    enhance the readability and maintainability of your code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你将重复使用的资源封装进模块，而不是重复每个资源，你将重复模块。这种方法可以显著提高代码的可读性和可维护性：
- en: '![Figure 1.19 – Module design: repeating outside the module](img/B21183_01_19.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.19 – 模块设计：在模块外重复](img/B21183_01_19.jpg)'
- en: 'Figure 1.19 – Module design: repeating outside the module'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.19 – 模块设计：在模块外重复
- en: 'The outside consumer of the module is responsible for introducing iteration
    on the module resource itself:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的外部消费者负责对模块资源本身进行迭代：
- en: '[PRE10]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: By applying the iterator to the module itself, we achieve the same outcome as
    if we adorn every resource declared in the module with a count and pass in the
    number of resources as an input variable to the module. However, working with
    every resource inside the module becomes more difficult.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将迭代器应用到模块本身，我们能够实现与在模块中为每个资源添加`count`并将资源数量作为输入变量传入模块相同的结果。然而，在模块内操作每个资源会变得更加困难。
- en: When you design your module to be repeated by a parent module, your module doesn’t
    have to think about the complexity of how many resources the parent module wants
    to create across all items in the collection. Each module instance only has to
    worry about one instance of each resource.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当你设计模块以便由父模块重复使用时，你的模块不需要考虑父模块希望在集合中创建多少个资源的复杂性。每个模块实例只需关心每个资源的一个实例。
- en: Does it flatten or simplify the resource in a way that can make the resource
    easier to use?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 它是否以某种方式简化或扁平化资源，使得资源更容易使用？
- en: If you are starting from scratch, it’s best to let those patterns emerge over
    time. The code in the method is, by its very nature, a rather opinionated piece
    of code. Once you identify one, all it takes is a destroy, refractor, and re-apply,
    and you’re using your new module.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是从零开始，最好让这些模式随着时间的推移自然形成。方法中的代码本质上是具有强烈个人观点的代码。一旦你确定了一个模式，所需的只是销毁、重构和重新应用，你就可以使用你的新模块了。
- en: Destroying the entire environment and starting over isn’t always an option.
    This approach can only be used in a development or testing environment. In production
    environments, you will need to take a different approach.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 销毁整个环境并重新开始并非总是一个可行的选择。这种方法只能在开发或测试环境中使用。在生产环境中，你需要采取不同的方法。
- en: Sometimes, you can write a method you can use in many scenarios. This approach
    is most common when developing framework code that tackles a horizontal problem
    space. But sometimes methods are intended to do very particular things.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可以编写一个在多种场景中都能使用的方法。这种方法在开发框架代码时最为常见，尤其是当框架处理的是一个横向问题空间。但有时方法的设计是为了完成某些非常特定的任务。
- en: This same principle applies to Terraform module design. Some modules are highly
    flexible and designed in a framework, while others are more like *Hey, I want
    to do this specific thing, and I want to keep it simple.* With a scenario-driven
    module, the interface to the module will be very, very simple because it’s only
    about shepherding dependency inputs into the module’s scope that the module needs
    and doesn’t have on its own within its scope.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的原则适用于Terraform模块设计。有些模块非常灵活，设计成框架化的，而另一些模块则更像是*嘿，我想做这个特定的事情，并且想让它保持简单*。对于场景驱动的模块，其接口会非常简单，因为它只是将依赖输入导入模块的作用域，模块所需的那些依赖，而模块自身在其作用域内没有这些依赖。
- en: A framework module typically has a much more complex interface; as a result,
    it will have many more levers that the module consumer can pull. Sometimes, those
    inputs are no longer straightforward primitive types (`string`, `bool`, `number`);
    they are complex objects you construct and pass in. As the number of scenarios
    your module supports increases, so does the complexity of your module. You have
    to pass in a lot more parameters to configure it. It will become much more tedious
    and error-prone to pass those complex objects as you may have to implement more
    object construction logic using local variables.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 框架模块通常具有更复杂的接口；因此，它会有更多的杠杆，供模块使用者操控。有时，这些输入不再是简单的基本类型（`string`、`bool`、`number`）；它们是你需要构造并传入的复杂对象。随着模块支持的场景数量增加，模块的复杂性也会增加。你需要传入更多的参数来配置它。随着这些复杂对象的增加，传递它们会变得更加繁琐且容易出错，因为你可能需要使用局部变量实现更多的对象构造逻辑。
- en: Most Terraform providers have resources that do not require you to construct
    complex objects to use them. You will use primitive types, sometimes collection
    types, and nested blocks.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Terraform提供者的资源都不需要你构造复杂的对象来使用。你将使用基本类型，有时是集合类型和嵌套块。
- en: However, when building modules, you do have the ability to create complex objects
    as input variables. You should avoid overly complex data structures because of
    the complexity that it adds. Frequently, the dependencies between resources are
    relatively small. So, if you only need small pathways to connect two objects,
    why create massive **data transfer objects** (**DTOs**) to pass context from one
    object to another? It makes the code easier to understand and easier to maintain.
    Future authors and your module consumers will be cursing your name, just like
    in poorly written traditional software.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在构建模块时，你确实可以创建复杂对象作为输入变量。你应该避免过于复杂的数据结构，因为它会增加复杂性。通常，资源之间的依赖关系较小。所以，如果你只需要小路径来连接两个对象，为什么要创建庞大的
    **数据传输对象**（**DTOs**）来传递上下文呢？这样会让代码更易于理解和维护。未来的开发者和你的模块使用者会像在糟糕的传统软件中那样诅咒你的名字。
- en: I’ve seen software where there have been methods where instead of using the
    correct primitive types such as `bool` and `number`, everything is a string. Will
    that work? Sure. But does that make it easy to understand? Does that inject additional
    complexity, such as constantly type-casting the input values back and forth between
    strings into their proper type? You should use the correct type and simplify the
    interface.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾见过一些软件，在这些软件中，方法是将所有内容都定义为字符串，而不是使用正确的原始类型，如 `bool` 和 `number`。这样可以吗？当然可以。但这使得理解变得容易吗？是否会增加额外的复杂性，例如不断将输入值在字符串和其正确类型之间进行类型转换？你应该使用正确的类型并简化接口。
- en: We have to strike a balance between using complex types and having too many
    input variables on a module because having too many input variables affects cyclomatic
    complexity, making it difficult to maintain. However, unlike other languages,
    working with HCL is challenging when using complex objects. Developers could be
    more efficient when constructing and transforming large, complex data types. HCL
    is excellent for developers when declaring and associating resources by piping
    output variables into input variables.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在使用复杂类型和模块输入变量过多之间找到平衡，因为过多的输入变量会影响环路复杂度，使得维护变得困难。然而，与其他语言不同，使用复杂对象时，HCL
    的工作方式具有挑战性。在构建和转换大型复杂数据类型时，开发人员可能效率较低。HCL 在声明和关联资源时非常适合开发人员，尤其是通过将输出变量传递到输入变量。
- en: Consuming modules
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模块
- en: Now we understand the design considerations for when and how to design sound
    modules, let’s look at how we can consume and manage modules, from small scenario-driven
    modules to strongly versioned framework modules.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了在设计模块时的考虑因素，以及如何设计良好的模块，让我们来看看如何使用和管理模块，从小型场景驱动的模块到强版本控制的框架模块。
- en: Local modules
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地模块
- en: Local modules can maximize code reuse within your Terraform solutions without
    incurring the overhead of setting up and maintaining a separate module repository.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 本地模块可以在 Terraform 解决方案中最大化代码重用，而无需建立和维护单独的模块仓库。
- en: 'Using local modules for application-specific patterns, such as components or
    layers within your architecture, can be a great way to organize your Terraform
    code. One typical pattern when deploying to the cloud is active-active, multi-region
    deployments. In this situation, you should design the module to provision the
    application to a single region, and then this module should be deployed to a configurable
    set of regions using the `count` or `for_each` meta-argument:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本地模块来实现特定于应用程序的模式，例如架构中的组件或层，是组织 Terraform 代码的一个好方法。部署到云中的一个典型模式是活跃-活跃、多区域部署。在这种情况下，您应该设计模块来将应用程序部署到单一区域，然后使用
    `count` 或 `for_each` 元参数将该模块部署到一组可配置的区域：
- en: '![Figure 1.20 – Using Modules to encapsulate resources provisioned to a single
    region of a Cloud platform](img/B21183_01_20.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.20 – 使用模块封装云平台单一区域中提供的资源](img/B21183_01_20.jpg)'
- en: Figure 1.20 – Using Modules to encapsulate resources provisioned to a single
    region of a Cloud platform
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.20 – 使用模块封装云平台单一区域中提供的资源
- en: With this approach, you can create load-balancing resources in the root module
    to distribute traffic across the regional endpoints, coupled with multiple instances
    of the regional deployment module in the desired number of regions.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方法，你可以在根模块中创建负载均衡资源，将流量分配到各个区域的端点，同时在所需区域的多个实例中部署区域模块。
- en: This consumption approach is ideal when only the module is used within the current
    project. This scenario can manifest in layered or multi-region architectures.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当当前项目中只使用该模块时，这种消费方式是理想的。这个场景可以在分层或多区域架构中体现出来。
- en: Remote repositories
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 远程仓库
- en: Using external modules is the best way to capitalize on highly reusable patterns
    within your architecture. Terraform allows you to reference a module that is not
    stored in your project’s source code repository. The most common way of referencing
    a remote module is via a Git repository. This method works with any Git-compatible
    repository, from GitHub to Azure DevOps to GitLab.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用外部模块是充分利用你架构中高度可复用模式的最佳方式。Terraform 允许你引用一个不存储在项目源代码仓库中的模块。引用远程模块最常见的方式是通过
    Git 仓库。这种方法适用于任何 Git 兼容的仓库，从 GitHub 到 Azure DevOps 再到 GitLab。
- en: Publishing your modules publicly on the open internet makes it extremely easy
    to reference them from any source code repository, whether public or private.
    However, in some enterprise scenarios, public repositories are not allowed—corporate
    governance may only allow private repositories. In these situations, you must
    select an authentication mechanism to access those modules as an end user and
    from within your pipelines. You can authenticate with your private, remote Terraform
    module repositories using an SSH key or a public access token.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的模块公开发布到开放的互联网上使得从任何源代码仓库（无论是公共的还是私有的）引用它们变得极为简单。然而，在一些企业场景中，公共仓库是不允许的——公司治理可能只允许私有仓库。在这些情况下，你必须选择一种身份验证机制，以便作为最终用户以及在你的流水线中访问这些模块。你可以使用
    SSH 密钥或公共访问令牌来验证私有的远程 Terraform 模块仓库。
- en: 'Once you have secured your authentication to the Git repository that stores
    your modules, you must reference the module from your source code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了对存储模块的 Git 仓库的身份验证，你就必须在源代码中引用该模块：
- en: '[PRE11]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding examples show how you reference a specific module hosted in a
    Git repository on Azure DevOps. Using this approach, you will access the default
    branch for the Git repository, which will most likely be `main`, and it will take
    the latest commit from that branch—never a good idea.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例展示了如何引用托管在 Azure DevOps 上 Git 仓库中的特定模块。采用这种方法，你将访问 Git 仓库的默认分支，通常为 `main`，并获取该分支的最新提交——这通常不是一个好主意。
- en: 'The proper way is to specify a reference for a specific module version. When
    using the `ref` query string parameter for your Git repository URL, you can target
    a specific tag, branch, or commit within the Git repository:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的方法是为特定模块版本指定一个引用。当你使用 `ref` 查询字符串参数来指定 Git 仓库 URL 时，你可以定位到 Git 仓库中的特定标签、分支或提交：
- en: '[PRE12]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tags are the ideal method to guarantee a specific version because creating a
    tag within a Git repository doesn’t require changing your branching strategy.
    Once you are done testing the module, you can push a tag and rest assured that
    you will always receive that exact version of the module when you specify that
    tag as the `ref` parameter.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 标签是保证特定版本的理想方法，因为在 Git 仓库中创建标签不需要更改分支策略。一旦你完成模块的测试，就可以推送一个标签，并放心地知道当你将该标签作为
    `ref` 参数时，你总是能获取到该模块的确切版本。
- en: Terraform registry
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Terraform 注册表
- en: 'HashiCorp provides a mechanism for third-party module publishers to distribute
    their modules. This repository is accessible via `registry.terraform.io` and houses
    a tremendous wealth of Terraform modules in a publicly accessible, stable, and
    versioned environment. When you publish modules here, you must meet specific requirements
    to allow you and others to reference the module using a simple name and version:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: HashiCorp 提供了一种机制，供第三方模块发布者分发他们的模块。这个仓库可以通过 `registry.terraform.io` 访问，并且在一个公开可访问、稳定且版本化的环境中，存放了大量的
    Terraform 模块。当你在此发布模块时，必须满足特定要求，以便你和其他人可以通过简单的名称和版本来引用该模块：
- en: '[PRE13]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The Terraform module registry ultimately uses GitHub under the hood, so you
    are referencing a module in a GitHub repository. However, it allows you to use
    a simplified module name and version without the additional complexity of the
    GitHub repository’s information.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 模块注册表最终在后台使用 GitHub，因此你实际上是在引用 GitHub 仓库中的模块。然而，它允许你使用简化的模块名称和版本，而无需
    GitHub 仓库的额外复杂信息。
- en: Now that we know how we can use modules to build more manageable IaC solutions
    and understand that modules can serve different purposes under different contexts,
    let’s move on to understand the CLI better so that we can build automation around
    Terraform to integrate it with our release pipeline and CI/CD process.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何使用模块构建更易管理的 IaC 解决方案，并理解模块可以在不同的上下文中提供不同的功能，接下来我们将更好地理解 CLI，以便我们可以围绕
    Terraform 构建自动化，将其集成到我们的发布管道和 CI/CD 过程中。
- en: Understanding how to use the CLI effectively
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解如何有效使用 CLI
- en: Now that we understand Terraform’s core architecture, let’s examine its CLI
    and how to interact with it. There are many different commands, but we’ll focus
    on the important ones for implementing the core Terraform workflow. I’d encourage
    you to explore HashiCorp’s documentation for some of the more obscure ones, and
    later in [*Chapter 17*](B21183_17.xhtml#_idTextAnchor700), when we discuss managing
    existing environments using Terraform, we’ll be covering some more commands useful
    in that context.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Terraform 的核心架构，接下来我们将研究其 CLI 以及如何与之互动。有很多不同的命令，但我们将重点讨论实现核心 Terraform
    工作流的重要命令。我建议你探索 HashiCorp 的文档，以了解一些更冷门的命令，稍后在 [*第17章*](B21183_17.xhtml#_idTextAnchor700)
    中，当我们讨论如何使用 Terraform 管理现有环境时，我们将介绍一些在此上下文中有用的命令。
- en: init
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: init
- en: 'This is an important command and probably the first one you will ever execute
    when working with Terraform. The reason is that Terraform works within a working
    directory instead of other tools that operate on a single file (such as ARM or
    CloudFormation) or an entry point file (such as Ansible). Terraform also relies
    on hidden directories to load important context about the workspace. This approach
    is very similar to how Git works when you clone a repository. Therefore, we must
    allow Terraform to set things up so that everything it needs is in the right place
    and makes itself at home. The `terraform init` command does just that:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的命令，可能是你在使用 Terraform 时执行的第一个命令。原因在于，Terraform 是在工作目录中运行的，而不像其他工具（例如 ARM
    或 CloudFormation）在单个文件上操作，或者像 Ansible 在入口文件上操作。Terraform 还依赖于隐藏目录来加载关于工作空间的重要上下文。这种方法与
    Git 在克隆仓库时的工作方式非常相似。因此，我们必须允许 Terraform 设置一切，使其所需的所有东西都在正确的位置并使其能够正常运行。`terraform
    init` 命令正是执行这一操作：
- en: '[PRE14]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The Terraform initialize command accomplishes a few things:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 初始化命令完成了几项工作：
- en: Provider installation
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供程序安装
- en: Module installation
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块安装
- en: Backend initialization
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端初始化
- en: Provider installation
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供程序安装
- en: First, it analyzes the directory and searches for provider declarations and
    downloads and installs those providers. It doesn’t connect to the providers, so
    a successful `init` process doesn’t indicate that your provider credentials are
    good. It suggests that the providers and specific versions of those providers
    you specified exist, and it installs them. As an extension of Terraform, each
    provider is just a Golang executable that Terraform interfaces with. Therefore,
    Terraform needs to download and stage that executable somewhere to know where
    to execute it when the time comes.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它分析目录并搜索提供程序声明，下载并安装这些提供程序。它不会连接到这些提供程序，所以成功的 `init` 过程并不表示你的提供程序凭证是有效的。它表示你指定的提供程序及其特定版本存在，并且已被安装。作为
    Terraform 的扩展，每个提供程序只是一个 Terraform 与之交互的 Golang 可执行文件。因此，Terraform 需要下载并将该可执行文件放置在某个位置，以便在需要时执行它。
- en: Each provider’s binary is downloaded and stored in the hidden directories created
    during the `init` process. These hidden directories and their contents enable
    other Terraform operations to function. Still, they are not files that need special
    protection, so you should not be too concerned if you delete them accidentally—or
    on purpose. To bring them back, one must rerun `init`, and Terraform will re-generate
    them as before.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 每个提供程序的二进制文件会被下载并存储在 `init` 过程创建的隐藏目录中。这些隐藏目录及其内容使得其他 Terraform 操作能够正常运行。然而，这些文件并不需要特殊保护，所以如果你不小心删除了它们（或者故意删除），也不必过于担心。要恢复它们，只需重新运行
    `init`，Terraform 会像之前一样重新生成这些文件。
- en: Module installation
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块安装
- en: Second, it analyzes the working directory and searches for module declarations
    within the code base. It then downloads and installs those modules from their
    respective source locations. It doesn’t matter if you reference modules using
    a relative path or a remote GitHub repository; a local copy of the module folder
    will be downloaded and stored in the hidden directories that Terraform uses for
    execution. As with the provider binaries, these module files must be there for
    future Terraform operations to succeed. Again, just like the provider binaries,
    these files do not require protection as Terraform will also bring them back with
    a single call to `terraform init`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，Terraform 会分析工作目录并搜索代码库中的模块声明。然后，它会从各自的源位置下载并安装这些模块。无论你是使用相对路径还是远程的 GitHub
    仓库引用模块，都无关紧要；Terraform 会下载该模块文件夹的本地副本，并将其存储在 Terraform 执行时使用的隐藏目录中。与提供程序二进制文件类似，这些模块文件必须存在，才能确保将来
    Terraform 操作的成功。同样，像提供程序二进制文件一样，这些文件无需保护，因为 Terraform 会通过一次 `terraform init` 调用自动带回它们。
- en: If you are developing reusable modules, you are most likely simultaneously using
    those modules in a root module that you use to test them. You run `terraform init`
    on the root module’s folder, and that root module references your reusable module.
    It’s important to note that if you change your module, simply rerunning `init`
    will not automatically bring in those updates. If the version of the module reference
    has stayed the same, Terraform will check the folder in which it loaded the modules
    and see that it has already downloaded that module version. To force it to download
    a new copy of your modules, you will need to either increment the version of the
    module (which can be tedious during module development) or manually clear the
    modules by deleting them from the `.``terraform` directory.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在开发可复用的模块，你很可能同时在一个根模块中使用这些模块来进行测试。你在根模块的文件夹中运行 `terraform init`，而根模块会引用你的可复用模块。需要注意的是，如果你修改了模块，仅仅重新运行
    `init` 并不会自动带入这些更新。如果模块引用的版本没有变化，Terraform 会检查加载模块的文件夹，看到它已经下载了该模块的版本。要强制重新下载模块的副本，你需要增加模块的版本（在模块开发期间，这可能会显得繁琐），或者通过从
    `.terraform` 目录中手动删除模块来清空它们。
- en: Backend initialization
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后端初始化
- en: Lastly, Terraform will look for a `backend` block within the `terraform` block
    of your working directory’s `.tf` files. Most backends require some configuration
    settings to work. Ultimately, a Terraform backend provides a location for the
    Terraform state file, so these configuration settings guide the Terraform backend
    on how to get to the Terraform state file.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Terraform 会在工作目录的 `.tf` 文件中的 `terraform` 块里寻找一个 `backend` 块。大多数后端需要一些配置设置才能工作。最终，Terraform
    后端提供了一个存放 Terraform 状态文件的位置，因此这些配置设置会引导 Terraform 后端如何找到 Terraform 状态文件。
- en: 'For example, to use the ARM backend, you must specify a way to triangulate
    to the correct Azure Blob Storage account container state file. Terraform will
    pass several landmarks along the way on the journey that Terraform takes to get
    to the location of the desired state file: first, the resource group where the
    storage account lives, then the storage account where the storage container lives,
    then the storage container where the state file lives, and finally, the name of
    the state file, which Terraform locates using the `key` value and the current
    Terraform workspace name.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要使用 ARM 后端，你必须指定一种方式来三角定位到正确的 Azure Blob 存储账户容器状态文件。Terraform 在到达目标状态文件位置的过程中会经过多个标志：首先是存储账户所在的资源组，然后是存储容器所在的存储账户，再接着是状态文件所在的存储容器，最后是状态文件的名称，Terraform
    通过 `key` 值和当前的 Terraform 工作区名称来定位它。
- en: A fully populated Terraform backend configuration for Azure would use the `key`
    value and the current Terraform workspace name.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 Azure Terraform 后端配置会使用 `key` 值和当前的 Terraform 工作区名称。
- en: 'A fully populated Terraform backend configuration for Azure would look like
    this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 Azure Terraform 后端配置如下所示：
- en: '[PRE15]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The Azure backend will use `resource_group_name`, `storage_account_name`, and
    `container_name` to get to the place on Azure where files are stored. Then, `key`
    and the workspace name are used to formulate the name of the state file. If you
    are using the default workspace, then the name of the state file will be the value
    of `key`. However, if you use a named workspace, the Azure backend will generate
    a state file name that looks like `foo.tfstate:env:prod` for a workspace named
    `prod`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Azure后端将使用`resource_group_name`、`storage_account_name`和`container_name`来找到Azure上存储文件的位置。然后，`key`和工作区名称将用于制定状态文件的名称。如果你使用的是默认工作区，那么状态文件的名称将是`key`的值。然而，如果你使用一个命名工作区，Azure后端将生成一个类似`foo.tfstate:env:prod`的状态文件名称，表示一个名为`prod`的工作区。
- en: Each Terraform backend plugin will have a different strategy for reading and
    writing state files and its logic for generating the state filename where the
    state is ultimately stored. Getting to know your provider, the available backend,
    and how to configure it is essential.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Terraform后端插件都有不同的策略来读取和写入状态文件，以及生成最终存储状态文件的状态文件名的逻辑。了解你的提供者、可用的后端以及如何配置它是至关重要的。
- en: validate
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证
- en: '`terraform validate` is a helpful method that is essentially the closest thing
    to a compiler. It analyzes all code files within the scope and verifies references
    and syntax. If there are any broken references to data sources or resources, running
    this command will help you find them without having to initialize your backend.
    As a result, the `validate` command is a helpful command to execute as an early
    warning to detect any problems with your code before you move on to other steps.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`terraform validate`是一个有用的方法，实际上它是最接近编译器的东西。它分析作用范围内的所有代码文件，验证引用和语法。如果有任何对数据源或资源的引用断裂，运行此命令将帮助你在无需初始化后端的情况下找到它们。因此，`validate`命令是一个有用的命令，作为早期警告，用于在你继续其他步骤之前检测代码中的任何问题。'
- en: workspace
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作区
- en: '`terraform workspace` is about creating forks of the same Terraform solution
    to have different instances or forks of the Terraform state. Just like in source
    code, when you create a fork, the idea is that you will modify the code, and those
    modifications will remain long-term. Therefore, you may never merge the newly
    forked code base into the `main` branch.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`terraform workspace`是关于创建同一个Terraform解决方案的分支，以便拥有不同的实例或分支的Terraform状态。就像在源代码中一样，当你创建一个分支时，目标是修改代码，这些修改将长期保持。因此，你可能永远不会将新分支的代码库合并到`main`分支。'
- en: Whether you realize it or not, you are using Terraform workspaces. You just
    aren’t using a custom-named workspace. You can find this out by running the `terraform
    workspace show` command, which will say `default`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 不管你是否意识到，你正在使用Terraform工作区。只是你没有使用自定义命名的工作区。你可以通过运行`terraform workspace show`命令来发现这一点，它会显示`default`。
- en: Creating a new workspace for each long-lived environment is a good idea—even
    if you plan on segmenting your backend.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个长期存在的环境创建一个新的工作区是一个好主意——即使你计划将后端进行分段。
- en: 'Running `terraform workspace new dev` will create a new workspace for your
    development environment. You can run the same command for your production environment,
    such as `terraform workspace new prod`. From then on, any Terraform operation
    that utilizes the state will use the state file for the selected workspace. You
    can change back and forth between these state files by changing the workspace
    like this: `terraform workspace select dev` or `terraform workspace` `select prod`.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`terraform workspace new dev`将为你的开发环境创建一个新的工作区。你可以对生产环境运行相同的命令，例如`terraform
    workspace new prod`。从此以后，任何利用状态的Terraform操作都将使用所选工作区的状态文件。你可以通过像这样切换工作区来在这些状态文件之间来回切换：`terraform
    workspace select dev`或`terraform workspace select prod`。
- en: With workspaces, you might create a workspace to test something out with the
    intent of eventually making those same updates in the original workspace.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 使用工作区时，你可能会创建一个工作区来测试某些内容，目的是最终在原始工作区中进行相同的更新。
- en: Workspaces represent utterly different environments because the dev environment
    will always differ slightly from the test, staging, or production environments.
    These environments will live in isolated workspaces and have the same isolation
    within their state file.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 工作区代表完全不同的环境，因为开发环境总是与测试、预发布或生产环境略有不同。这些环境将生活在孤立的工作区中，并在它们的状态文件中具有相同的隔离性。
- en: The common thread is that the workspaces work off the same code base. The idea
    is that you will have the same code base and deploy multiple environments with
    it—most likely long-lived environments, but not necessarily so.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 共同的主题是工作空间基于相同的代码库。其思想是你将拥有相同的代码库，并利用它部署多个环境——很可能是长期存在的环境，但不一定如此。
- en: plan
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计划
- en: '`terraform plan` is a read-only operation that requires access to your backend
    state and requires you to have executed `terraform init` prior. Also, if you use
    a non-default workspace, you should select your workspace before you run `plan`.
    `terraform workspace select` allows you to do that.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`terraform plan` 是一个只读操作，它需要访问你的后端状态，并要求你先执行 `terraform init`。此外，如果你使用的是非默认工作空间，你应该在运行
    `plan` 之前选择你的工作空间。`terraform workspace select` 命令可以让你做到这一点。'
- en: '`terraform plan` will perform a read-only operation, checking the state file
    and checking in with every resource in the state file. This process can take a
    while, depending on how many resources are in your state file and how long it
    takes for the provider to get a response from whoever it’s talking to. So, to
    keep your Terraform projects lean and fast, consider how much scope you want to
    keep within a single Terraform workspace.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`terraform plan` 将执行一个只读操作，检查状态文件并与状态文件中的每个资源进行核对。这个过程可能需要一些时间，具体取决于状态文件中有多少资源以及提供程序与其交互的响应时间。因此，为了保持你的
    Terraform 项目精简和高效，考虑将一个 Terraform 工作空间的作用范围限制在多大范围内。'
- en: You may consider splitting those chunks into sub-workspaces if it’s too big.
    I’ve seen projects where an entire solution is in one Terraform state file, and
    it takes 45 minutes to run a plan. Having too broad workspace isolation can be
    extremely painful, and I would highly advise you to consider the boundaries of
    the components of your system and organize your Terraform workspaces so that you
    have smaller, semi-dependent workspaces. It’s okay to have dependencies between
    workspaces. Still, you need to call out those dependencies using data sources
    so that you don’t get into a situation where you can make a circular reference
    between two Terraform workspaces.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码块太大，你可以考虑将其拆分为子工作空间。我见过一些项目，其中一个完整的解决方案放在一个 Terraform 状态文件中，执行一个计划就需要 45
    分钟。如果工作空间隔离过于宽泛，会变得非常痛苦，我强烈建议你考虑系统组件的边界，并组织你的 Terraform 工作空间，使其成为较小、半依赖的工作空间。工作空间之间有依赖关系是可以的，但你需要通过数据源来明确这些依赖关系，避免出现两个
    Terraform 工作空间之间的循环引用问题。
- en: 'Terraform needs you to set all your input variables before you can run the
    `plan` operation. You can do this in three ways: through an individual command-line
    argument, a variable file, and environment variables.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 需要在运行 `plan` 操作之前设置所有输入变量。你可以通过三种方式完成：通过单个命令行参数、变量文件和环境变量。
- en: An **individual command-line argument** is helpful for small projects with interactive
    command-line sessions. Still, it quickly becomes unmanageable when the environment
    grows more complex or you want to use a pipeline tool—a scenario on which we will
    spend the bulk of this book.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**单个命令行参数**对于具有交互式命令行会话的小项目非常有帮助，但当环境变得更加复杂或你希望使用管道工具时，这种方法很快就变得难以管理——这是我们本书的主要讨论场景。'
- en: The **environment variable** approach is instrumental in the pipeline tool approach
    because it allows you to execute Terraform commands without modifying the arguments
    to the command you run.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**环境变量**方法在管道工具方法中起着重要作用，因为它允许你在不修改命令参数的情况下执行 Terraform 命令。'
- en: apply
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用
- en: '`terraform apply` is the most crucial operation in the arsenal. Before execution,
    this command requires `terraform init` to have been executed successfully. Selecting
    the correct workspace corresponding to the input parameters you specify will also
    be essential.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`terraform apply` 是工具集中的最关键操作。在执行之前，该命令需要先成功执行 `terraform init`。选择与指定输入参数对应的正确工作空间也至关重要。'
- en: '`terraform apply` is also unique compared to other operations: you can execute
    it by pointing at a single file rather than a working directory. The `terraform
    plan` command outputs the plan file. If a plan file is not specified, `terraform
    apply` will execute a plan before the `apply` stage.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`terraform apply` 与其他操作相比也有其独特之处：你可以通过指向单个文件来执行它，而不是一个工作目录。`terraform plan`
    命令输出计划文件。如果没有指定计划文件，`terraform apply` 会在 `apply` 阶段之前执行计划。'
- en: It is best practice to execute `apply` by always passing in a plan file. Doing
    so will ensure that you don’t have any surprises when you execute. However, there
    is still a chance that something changed in the environment between when you last
    ran `plan` and when you finally executed `apply`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是在执行 `apply` 时总是传入一个计划文件。这样做可以确保您在执行时没有任何意外。然而，仍然有可能在您上次运行 `plan` 和最终执行
    `apply` 之间，环境中发生了变化。
- en: This is particularly important when working on a team of multiple people that
    might be introducing change to the environment, either using Terraform locally
    or through a CI/CD pipeline. Changes could also be introduced outside of Terraform
    through manual changes within the cloud platform’s management portal. Using a
    Terraform plan file when you run `terraform apply` will help keep the plan you
    execute exactly how you intended with the best information available at the time
    of provisioning.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这在多个团队成员可能对环境进行更改时尤为重要，无论是通过本地使用 Terraform 还是通过 CI/CD 管道。更改也可能通过云平台管理门户中的手动更改引入到
    Terraform 之外。当您运行 `terraform apply` 时，使用 Terraform 计划文件将有助于确保您执行的计划与您在资源配置时的意图保持一致，并且利用了当时可用的最佳信息。
- en: As with `plan`, input variables can set their values in many ways.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `plan` 一样，输入变量的值可以通过多种方式进行设置。
- en: destroy
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 销毁
- en: '`terraform destroy` is how you can completely eradicate your entire environment.
    The ability to do so is advantageous when your solution spans multiple logical
    groups within the target platform or when using multiple providers.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`terraform destroy` 是您可以完全删除整个环境的命令。具备此能力在您的解决方案跨多个目标平台的逻辑组或使用多个提供商时尤为有利。'
- en: Logical container deletion
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑容器删除
- en: Some platforms make it easy to manage the life cycle of related resources. For
    example, Microsoft Azure resources every resource to be provisioned within a resource
    group, and on **Google Cloud Platform** (**GCP**), every resource is provisioned
    within the context of a project. The Azure resource group and Google Cloud project
    are logical containers you can use to clean up after yourself quickly with a cascading
    delete operation. Platforms that lack this feature can make it extremely tedious
    to clean up after yourself, such as in AWS, where you must navigate to many different
    portal pages to ensure you delete everything. Savvy command-line power users can
    string together their clean-up scripts using a well-planned tagging scheme. Still,
    tools such as Terraform add a lot of value in just being able to delete every
    resource you provisioned with a single command.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 一些平台使管理相关资源的生命周期变得简单。例如，Microsoft Azure 要求每个资源在资源组内进行配置，在 **Google Cloud Platform**
    (**GCP**) 中，所有资源都在项目的上下文中进行配置。Azure 资源组和 Google Cloud 项目是您可以用来快速清理的逻辑容器，通过级联删除操作实现。缺乏此功能的平台则会使清理工作变得非常繁琐，比如在
    AWS 中，您必须导航到许多不同的门户页面，以确保删除所有资源。精明的命令行高级用户可以通过精心设计的标签方案将清理脚本串联起来。然而，像 Terraform
    这样的工具在通过单一命令删除您所配置的所有资源时，提供了极大的价值。
- en: Cross-platform deletion
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跨平台删除
- en: Even on cloud platforms with logical containers, to collectively manage the
    life cycle of related resources, you still need help with associated resources
    that you provision in tangential systems or platforms.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在具有逻辑容器的云平台上，为了共同管理相关资源的生命周期，您仍然需要处理在其他系统或平台中配置的关联资源。
- en: Summary
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we took an in-depth look at Terraform’s architecture. We primarily
    focused on two critical architectural components: state and modularity. Having
    a sound understanding of Terraform’s architecture is vital for you to be able
    to use Terraform to its fullest effectively. Finally, we ended by looking at Terraform’s
    CLI, which will enable you to, when you’re ready, integrate Terraform with your
    own CI/CD pipelines. In the next chapter, we will explore HCL so that we can lay
    the foundation on which we can start building IaC using Terraform.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了 Terraform 的架构，重点关注两个关键的架构组件：状态和模块化。充分理解 Terraform 的架构对您有效使用 Terraform
    至关重要。最后，我们还介绍了 Terraform 的命令行接口（CLI），这将使您在准备好后能够将 Terraform 与您自己的 CI/CD 管道集成。在下一章中，我们将探索
    HCL，以便为使用 Terraform 构建基础设施即代码（IaC）奠定基础。
