- en: Chapter 3. Going Further with Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling different environments with Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provisioning a CentOS 7 EC2 instance with Chef using Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using data sources, templates, and local execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing remote commands at bootstrap using Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Docker with Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating infrastructure changes using Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Teamwork – sharing Terraform infrastructure state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintaining a clean and standardized Terraform code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One Makefile to rule them all
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Team workflow example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing GitHub with Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External monitoring integration with StatusCake
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll go beyond the essentials of using Terraform we covered
    in [Chapter 2](ch02.html "Chapter 2. Provisioning IaaS with Terraform"), *Provisioning
    IaaS with Terraform*. We'll discover many important techniques to use Terraform
    in conjunction with other players in the field such as Docker and Chef, how it
    can be used in multiple environments (such as development/staging/production),
    how powerful it can be to manage not only infrastructure but many SaaS as well,
    and how to integrate the tool within a team workflow (sharing, synchronizing,
    maintaining, harmonizing, and so on). These topics are all equally important,
    as they will define the quality of our daily work and our ability to interact
    with other people, services, and systems.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Terraform version in use for this book is 0.7.3.
  prefs: []
  type: TYPE_NORMAL
- en: Handling different environments with Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s a common and recommended setup to have different infrastructure environments,
    with some level of parity. Those environments can vary greatly between companies
    and projects in both names and focus, but here are commonly found environments:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Development: where developers can implement and quickly test new features'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Staging: where the new features are tested in a more consistent environment
    than the development one, sometimes very similar to a preproduction environment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Preproduction: this environment is the most similar possible to production'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Production: the full-featured live production environment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll see how using infrastructure-as-code and especially how Terraform fundamentally
    helps to build strong and replicated environments. This time we'll use a CoreOS
    AMI for a change.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Terraform installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AWS account with an SSH key configured in Terraform (refer to the [Chapter
    2](ch02.html "Chapter 2. Provisioning IaaS with Terraform"), *Provisioning IaaS
    with Terraform,* recipes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using infrastructure-as-code, the easiest thing is to simply duplicate the code
    to create as many environments as needed. However, there's a much more powerful
    way to leverage the full capabilities of Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define the requirements of simple target environments that we''ll translate
    into dynamic Terraform code:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Staging | Production |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Number of instances** | 1 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| **Type of instance** | `t2.micro` | `t2.medium` |'
  prefs: []
  type: TYPE_TB
- en: '| **Operating system** | CoreOS Stable | CoreOS Stable |'
  prefs: []
  type: TYPE_TB
- en: '| **AMI in eu-west-1** | `ami-85097ff6` | `ami-85097ff6` |'
  prefs: []
  type: TYPE_TB
- en: '| **AMI in us-east-1** | `ami-0aef8e1d` | `ami-0aef8e1d` |'
  prefs: []
  type: TYPE_TB
- en: '| **S3 bucket naming** | iacbook-staging | iacbook-production |'
  prefs: []
  type: TYPE_TB
- en: '| **Default environment** | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: Let's start by declaring those variables in the `variables.tf` file, exactly
    as we' saw in [Chapter 2](ch02.html "Chapter 2. Provisioning IaaS with Terraform"),
    *Provisioning laaS with Terraform*, except we'll describe environments such as
    *staging* and *production* instead of the AWS regions for the cluster size and
    instance types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the CoreOS AMI variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a cluster size variable with different values according to the environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, define the different AWS instance types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s use those in a highly dynamic infrastructure code (`instances.tf`),
    using the `aws_instance` resource and by choosing automatically the correct cluster
    size and instance type according to the environment, while choosing the right
    AMI according to the execution region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We constructed each instance `Name` tag according to its environment and its
    numerical value in the count (that is, `coreos_production_2`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our specification table indicates we need two different S3 buckets as well.
    Let''s reuse in `s3.tf` something close to what we did in [Chapter 2](ch02.html
    "Chapter 2. Provisioning IaaS with Terraform"), *Provisioning IaaS with Terraform*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It's the same construction here, each environment will get its bucket dynamically
    named after it.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping the tfstate isolated
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It''s strongly recommended to **not mix** Terraform state files between environments.
    One elegant solution to keep them well separated is to use the following option
    when executing the `terraform` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Your default environment (set to staging) will now reside in the `staging.tfstate`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the production flag
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we have our staging infrastructure running smoothly, it''s time to launch
    the real thing—the production environment. As we''re already using a dedicated
    terraform state file, let''s do the same for production, and set the `environment`
    variable directly through the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You now have two clearly separated environments using the very same code, but
    living independently from each other. Concise and elegant!
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning a CentOS 7 EC2 instance with Chef using Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the underlying infrastructure is generated by Terraform, chances are the
    job isn't already finished. That's the moment a configuration management tool
    such as Chef, Ansible, or Puppet enters the game, to provision the virtual machine.
    Thankfully, Chef is a first class provisioning tool in Terraform. We'll see here
    how to fully bootstrap a CentOS 7.2 instance on AWS with Terraform, from nothing
    to a fully configured node, by gracefully handing over the configuration to Chef
    after having it automatically deployed and registered on Hosted Chef.
  prefs: []
  type: TYPE_NORMAL
- en: If it's the first time you've launched CentOS 7 servers on AWS, you have to
    agree their terms and conditions at [https://aws.amazon.com/marketplace/pp/B00O7WM7QW](https://aws.amazon.com/marketplace/pp/B00O7WM7QW).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Terraform installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AWS account with an SSH key configured in Terraform and a security group
    allowing SSH connections from outside (refer to the [Chapter 2](ch02.html "Chapter 2. Provisioning
    IaaS with Terraform"), *Provisioning IaaS with Terraform,* recipes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An account on a Chef server (we recommend using a free hosted Chef account.
    Please refer to the *Creating a free hosted server Chef account and a Puppet server*
    recipe of [Chapter 6](ch06.html "Chapter 6. Fundamentals of Managing Servers with
    Chef and Puppet"), *Fundamentals of Managing Servers with Chef and Puppet*), with
    the default cookbook uploaded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As there''re a lot of sources involved, let''s put all the required information
    in a table (the Chef information is taken from the Chef Starter Kit, or your own
    Chef server, fill in your own values):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Hostname** | `centos-1` |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Instance type** | `t2.micro` |'
  prefs: []
  type: TYPE_TB
- en: '| **AMI in eu-west-1** | ami-7abd0209 |'
  prefs: []
  type: TYPE_TB
- en: '| **AMI in us-east-1** | ami-6d1c2007 |'
  prefs: []
  type: TYPE_TB
- en: '| **SSH username** | centos |'
  prefs: []
  type: TYPE_TB
- en: '| **SSH key** | `keys/aws_terraform` |'
  prefs: []
  type: TYPE_TB
- en: '| **TCP ports needed** | 22 |'
  prefs: []
  type: TYPE_TB
- en: '| **Cookbook(s) to apply** | starter |'
  prefs: []
  type: TYPE_TB
- en: '| **Chef server URL** | [https://api.chef.io/organizations/iacbook](https://api.chef.io/organizations/iacbook)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Validation key** | `iacbook.pem` |'
  prefs: []
  type: TYPE_TB
- en: '| **Validation client name** | iacbook |'
  prefs: []
  type: TYPE_TB
- en: '| **Chef client version** | 12.13.37 |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s start by declaring our AMIs as a map in the `variables.tf` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add the instance type in the same file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the Chef version we''re currently using in production, so it''s stable
    and stays the same:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the Chef server URL. If you''re using the book example with hosted
    Chef, you''ll find the correct address in the `knife.rb` file: it''s simply [https://api.chef.io/organizations/<your_organization_name>](https://api.chef.io/organizations/<your_organization_name>),
    otherwise, use your own Chef server):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the *validation client* name for the Chef server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To connect to the instance, we know the default username is `centos`, but as
    it can evolve or you may use your own images, it''s better to fix it in a variable
    as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creating the EC2 instance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We know from previous recipes that a basic instance running CentOS looks like
    this in Terraform''s `instances.tf` using a security group named `base_security_group`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to provide two kinds of information to our Terraform file: what
    to do with Chef on the server and how to connect to it.'
  prefs: []
  type: TYPE_NORMAL
- en: Passing connection information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To tell Terraform how to connect itself to the new EC2 instance, we use a `connection
    {}` block inside the `aws_instance` resource to tell it which user and key to
    use through SSH:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Giving Chef information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We need to give some information to Terraform to pass it on to Chef. This will
    all happen inside a `provisioner "chef" {}` block inside the `aws_instance` resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using all the variables we declared, here''s how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't forget to use a valid path for the validation key!
  prefs: []
  type: TYPE_NORMAL
- en: Now you can `terraform apply` this and see everything happen, from instance
    creation to Chef Client deployment and cookbook installation.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, Terraform creates the required AWS environment (keys, security groups,
    and instances), and once the instance is running, it connects to it with the right
    credentials by SSH, then deploys the specified Chef client version from the official
    source, and finally executes an initial chef-client run that registers the node
    on the Chef server and applies the requested cookbooks.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A lot more configuration options are possible for the Chef provisioner inside
    Terraform. For example, all available chef-client options can be passed as an
    array using `client_options`, and the Chef environment (usually very important)
    is passed using `environment` as a string. If you use a custom built image with
    the Chef client already baked in, you will be interested in setting `skip_install`
    to `true` so it doesn't get reinstalled.
  prefs: []
  type: TYPE_NORMAL
- en: Using data sources, templates, and local execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we deploy or update an infrastructure with Terraform, it's sometimes enjoyable
    to have some local content dynamically generated. For example, if you want to
    provision with Ansible the new virtual machine launched by Terraform, chances
    are you'll need to populate a `hosts` file with the public IP address of this
    host locally on your laptop.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible can use some dynamic inventories with AWS by itself, but we'll see here
    how to use a template in Terraform and dynamically fill in the required information
    so we end up with a working Ansible setup, thanks to Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Terraform installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AWS account with an SSH key configured in Terraform and a security group
    allowing SSH connections from outside (refer to the [Chapter 2](ch02.html "Chapter 2. Provisioning
    IaaS with Terraform"), *Provisioning IaaS with Terraform* recipes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by launching a standard CentOS 7.2 on AWS with a standard set
    of variables in `variables.tf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the simplest `instances.tf` file to launch the instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Data and templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, how does a typical `hosts` file look for Ansible? It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: So, later, Ansible will apply whatever role is needed for each server of each
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we want a simple section named `centos7_hosts` and the servers
    IP as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s construct our first template named `hosts.tpl` with a variable named
    `host_public_ipv4` that will ultimately be replaced by the real future IP of the
    host we''ll later launch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To generate this file, we''ll use a template with a variable in it, that Terraform
    will generate for us, using a `data` resource in `data.tf`—it simply contains
    the file interpolation of our template and passes it the variable we need from
    our AWS instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The local-exec Terraform provisioner
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This generates the template internally, meaning the data is available, but
    not dumped anywhere. That''s where the `local-exec` provisioner comes in, by simply
    echoing the rendered template from the data source into the file we want (in `data.tf`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We use `"null_resource"` for this purpose, so the generation of the template
    is independent of any other executing resource. In other situations, we can perfectly
    use the `"local-exec" { }` provisioner directly from inside a standard resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now `terraform apply` this setup. How does our `hosts` file look? Like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It's correctly populated!
  prefs: []
  type: TYPE_NORMAL
- en: Apply a configured Ansible
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our code repository is now ready for use by Ansible. Here''s a sample Ansible
    role that simply installs Docker and starts it, so we can play with it, under
    `ansible/main.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now you just have to execute Ansible when you want, it is all ready and configured!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Executing remote commands at bootstrap using Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's a very common practice to have a set of initial commands executed right
    after bootstrap, even before the proper configuration management system such as
    Chef or Ansible takes responsibility. It can include immediate full updating of
    the OS, initial registration on discovery systems such as Consul, or initial addition
    of local DNS servers. It really shouldn't go farther than delivering a system
    in a slightly more advanced and expected state for the next configuration system
    to take over. Under no circumstance should it replace a proper configuration management
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll launch a CentOS 7.2 system, then fully update it so it's
    as secure as possible, install EPEL so we have a greater library of available
    packages, add the Puppet Labs Yum repository and install a Puppet agent, and add
    a different name server so our system is ready for the next step (which we won't
    cover here, as it's probably executing Puppet code).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Terraform installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AWS account with an SSH key configured in Terraform and a security group
    allowing SSH connections from outside (refer to the [chapter 2](ch02.html "Chapter 2. Provisioning
    IaaS with Terraform"), *Provisioning IaaS with Terraform* recipes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before diving into the provisioning part, let''s start by describing a classic
    CentOS 7.2 AMI in `instances.tf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The variables in the `variables.tf` file are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, what are our immediate objectives for this system?:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fully update it: `sudo yum install -y`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enable the EPEL repository: `sudo yum install epel-release -y`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add a custom name server: `echo "nameserver 8.8.8.8" | sudo tee -a /etc/resolv.conf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add the Puppet Labs repository: `sudo yum install https://yum.puppetlabs.com/puppetlabs-release-pc1-el-7.noarch.rpm
    -y`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Install the Puppet agent: `sudo yum install puppet-agent -y`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Display the Puppet version: `sudo /opt/puppetlabs/bin/puppet agent --version`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s add those commands inside a `remote-exec` provisioner inside our `aws_instance`
    resource, changing the default username to `centos`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When you `terraform apply` this, you'll end up with a fully updated CentOS 7.2
    system, with EPEL available, a custom DNS server added and Puppet agent installed.
  prefs: []
  type: TYPE_NORMAL
- en: Ready for the next stage of deployment with Puppet!
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker with Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Terraform can also be used to manipulate Docker. The classical usage is against
    an already running Docker server on the network, but it will work exactly the
    same locally with your own Docker installation. Using Terraform for controlling
    Docker, we'll be able to dynamically trigger Docker image updates, execute containers
    with every imaginable option, manipulate Docker networks, and use Docker volumes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we''ll deploy an isolated blog container (Ghost) that will be publicly
    served by the `nginx-proxy` container over HTTP. This very useful `nginx-proxy`
    container is proposed by Jason Wilder from InfluxDB on his GitHub: [https://github.com/jwilder/nginx-proxy](https://github.com/jwilder/nginx-proxy).'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Terraform installation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working Docker installation (native Docker for Mac, Docker Engine on Linux,
    a remote server running Docker on TCP, and so on). Docker 1.12 is used for this
    recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before starting to code anything using Terraform, ensure you can connect to
    any kind of Docker Engine, local or remote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If you have issues at this point, you need to fix them before going further.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to serve, through an `nginx-proxy` container, a blog container (Ghost)
    that will not be directly available on the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re connecting to a remote Docker server, you need to configure the
    Docker provider (maybe in `provider.tf`). Alternatively, it can use the `DOCKER_HOST`
    environment variable, or just the local daemon if not specified. When using locally
    for this exercise, you can just forget about including the provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start by declaring two data sources for each of our Docker images (in
    `docker.tf`). The `ghost` image will be in its `0.10` version tag, while `nginx-proxy`
    will use the `0.4.0` version tag. Using a data source will help us manipulate
    the image later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we can access the image, let''s exactly do that, using the `docker_image`
    resource. We''re reusing all the information our data source is exposing to us,
    such as the image name or its SHA256, so we know if a new image is available to
    pull:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now declare the private Ghost container (without any port mapping),
    using the `docker_container` resource. Let''s use the image we just declared through
    the `docker_image` resource, and export an environment variable named `VIRTUAL_HOST`,
    to be used by the nginx-proxy container (refer to the nginx-proxy documentation
    for more information). Replace with the host you want if you''re not running against
    a local Docker host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s start the `nginx-proxy` container. We know from its documentation
    that it needs to share the Docker socket in read-only mode (`/var/run/docker.sock`)
    to dynamically access the running containers, and we want it to run on the default
    HTTP port (`tcp`/`80`). Let''s do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now if you `terraform apply` this, you can navigate over to `http://localhost/admin`
    (replace `localhost` with the Docker server you used) and set up your Ghost blog!
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B05671_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Simulating infrastructure changes using Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an earlier recipe, you learned how to manage different environments with
    Terraform, which is great. But how do we test for changes before applying them?
  prefs: []
  type: TYPE_NORMAL
- en: Terraform has a great internal mechanism that allows us to *plan* for changes
    by comparing what our infrastructure code wants and what the remote state includes.
    That way, we can safely check whether what we thought was a minor modification
    in our code has in fact a destructive impact (sometimes, some parameters in a
    resource trigger a full destruction of the resource!).
  prefs: []
  type: TYPE_NORMAL
- en: We'll cover different ways of anticipating, simulating, and targeting changes
    in our infrastructure, as an added safety check before applying the changes for
    good.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Terraform installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AWS account with an SSH key configured in Terraform (refer to the [Chapter
    2](ch02.html "Chapter 2. Provisioning IaaS with Terraform"), *Provisioning IaaS
    with Terraform* recipes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with a simple CoreOS machine on AWS. We know the AMI ID, we want
    a single `t2.micro` host. Let''s put that information in the `variables.tf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The simplest `aws_instance` resource we can make is the following in `instances.tf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Planning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Until now, we''ve used `terraform apply` for immediate action. There''s another
    command: `terraform plan`. It does what it says. It plans for changes, but doesn''t
    apply them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: So, by planning before applying, we can know what's about to happen to our infrastructure.
    We're happy about an instance with the right AMI being created, so let's `terraform
    apply`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the infrastructure is created, if you run a plan again, it will say nothing
    should be modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: A normally operating infrastructure should always be in a state where a `terraform
    plan` doesn't want to change anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s say we need our infrastructure to evolve, and create an S3 bucket.
    That would look like this in a file named `s3.tf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re not sure about what''s about to happen, so let''s plan with Terraform,
    so it''s telling us exactly what it''s intending to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The plan looks good—it seems to want to create an S3 bucket named the way we
    want! Let's `terraform apply` this and move on.
  prefs: []
  type: TYPE_NORMAL
- en: Quickly simulating changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We now wonder what would happen if we were to change the number of instances.
    That''s the `cluster_size` variable, currently set to `1`. Instead of messing
    with the code, we can test the impact of changing that value directly from the
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Good news! It looks like increasing the `cluster_size` value has the intended
    effect: creating a new instance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we wonder legitimately what would be the effect of changing the instance
    type, from `t2.micro` to `t2.medium`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Ouch! Changing the instance type seems to be a destructive action. Let''s work
    on that later, and add the change to a new file named `plan.tfvars`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We know we''d like to propose to change the number of instances to `2`, so
    let''s add that to the same file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now test against this file containing all our changes, using the `-var-file`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Good! You learn that our first instance will be destroyed and recreated to move
    from `t2.micro` to `t2.medium`, and that a second instance will be created with
    the same values. Let's not apply this, as added fees will be incurred.
  prefs: []
  type: TYPE_NORMAL
- en: Targeting for a specific change
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our colleague asks us if we''re sure our proposed changes have no impact specifically
    on the S3 bucket. Terraform allows us to get an answer to that question very specifically
    by targeting the resource directly in the planning phase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Our colleague is happy, and we're now sure that this change will do exactly
    what's intended. We can submit this change for review.
  prefs: []
  type: TYPE_NORMAL
- en: Teamwork – sharing Terraform infrastructure state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You probably work with a team, and now you''re using Terraform to manage your
    infrastructure, you''ll face an issue: how does your team work together on infrastructure-as-code?
    There''re many answers to that, and one crucial question to address is: how is
    transmitted or synchronized the Terraform state?'
  prefs: []
  type: TYPE_NORMAL
- en: We'll see here how we can share the state using Git (a version control system
    where developers can store code), AWS S3 (an Amazon Web Services storage system
    using HTTP) or Consul (a tool for service discovery and a key-value store), chosen
    among many other solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Terraform installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AWS account with an SSH key configured in Terraform (refer to the [Chapter
    2](ch02.html "Chapter 2. Provisioning IaaS with Terraform"), *Provisioning IaaS
    with Terraform* recipes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working Docker installation for the Consul simulation solution (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by having an initial infrastructure running (a single virtual
    machine for this example). Here''s an `aws_instance` resource in `instances.tf`
    for a CoreOS stable release taken from previous recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are example variables in `variables.tf`; feel free to adapt them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Terraform stores its state by default in a file named `terraform.tfstate`,
    with a backup file named `terraform.tfstate.backup`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Sharing with Git
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The simplest of all options is to share the state file using Git: you''re already
    supposed to version your infrastructure code! Go and create an account somewhere.
    GitHub ([https://github.com](https://github.com)) doesn''t have free private repositories,
    but GitLab ([https://gitlab.com](https://gitlab.com)) or BitBucket ([https://bitbucket.org](https://bitbucket.org))
    do. Follow the instructions to have your Git repository locally working.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `tfstate` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Commit the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Push the commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now your coworkers absolutely need to pull the changes before applying any
    action, or calamity might follow soon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Sharing remotely with S3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sharing the state file through Git works, to some extent. You'll end up someday
    in a situation where someone forgets to push or pull. Merging conflicts in a state
    file is really not something nice to do.
  prefs: []
  type: TYPE_NORMAL
- en: One solution to stop thinking about it is using S3 to share the state file and
    use the remote state feature of Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating an S3 bucket just for that, in `s3.tf`, with versioning enabled
    (so you can roll back to a previous version of the infrastructure):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s `terraform apply` this S3 bucket, and move on to the remote configuration
    with our information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now see the terraform state file in the S3 browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sharing remotely with S3](img/B05671_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now make any change to the infrastructure, such as adding a new S3 bucket,
    to see the file change in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'After a `terraform apply`, simply push the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'See the history in the S3 browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sharing remotely with S3](img/B05671_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The coworker has to configure their environment and pull the information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'A local copy is now residing in the `.terraform` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Sharing remotely with Consul
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A very nice way to share the state file is by using Consul, a powerful key/value
    storage from Hashicorp ([http://consul.io/)](http://consul.io/)). Using Consul
    to store the Terraform states makes it easier to work with a team, as there's
    only a single replicated state. No risk of using an old state file if we forgot
    to synchronize our git repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuring a proper Consul in cluster for production is out of the scope of
    this book, but if you don''t have a Consul cluster at hand to try this out, here''s
    a way to quickly have one, using Docker and a Consul image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s configure our Terraform remote for Consul, and name it `terraform/my_customer`,
    so we can manage multiple customers simultaneously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Job done! Your coworkers can now push and pull from the Consul source! In a
    production Consul cluster, it means replicated and synchronized states on each
    node, with added privacy.
  prefs: []
  type: TYPE_NORMAL
- en: Other state sharing options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There're many other ways to share the state, such as on Azure, using OpenStack
    Swift, any kind of HTTP server supporting REST, CoreOS's own etcd key-value store,
    Google Cloud storage, or Atlas, the commercial solution by Hashicorp.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining a clean and standardized Terraform code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everyone has coding styles, but enforcing a standardized and commonly readable
    style is the key for a smooth collaborative team work. That's why Terraform has
    a command to ensure both format and style are all right.
  prefs: []
  type: TYPE_NORMAL
- en: I encourage readers to use it extensively, and even integrate it in **Continuous
    Integration** (**CI**) systems and in Makefiles.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Terraform installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll intentionally write a simple Terraform code with non-standard style and
    with an error (a missing variable). This will help us manipulate the various tools
    Terraform offers to ensure the most consistent and homogenous code, so we can
    achieve more quickly a better quality and a higher level of standardization of
    our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a provider for AWS like this in `provider.tf` (deliberately on
    one line):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Syntax validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Try to validate that file, and it will notify us that we''re missing a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The validation fails, and the return code is `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add this variable to a `variables.tf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Hooray! A `terraform validate` is now happy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Style validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This thing is, we solved the obvious problem (a missing variable), but what
    about style? The preceding style perfectly works, but style might not be canonical.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the `fmt` option to check for styling issues, displaying the `diff`
    onscreen, but not writing the files automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We see our style was quite far away from the guidelines. Let''s fix this and
    automatically format our files correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Our two files are now correctly formatted!
  prefs: []
  type: TYPE_NORMAL
- en: I highly recommend putting those two commands in your CI tests (you are running
    infrastructure code tests in CI, aren't you?), and even before reaching the CI,
    it's even better if it's in the project's `Makefile`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simple `Makefile` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Now you can just type `make` in the Terraform directory and you're sure your
    code both validates and is coherently styled.
  prefs: []
  type: TYPE_NORMAL
- en: One Makefile to rule them all
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some languages have environment or version managers such as RVM for Ruby, NVM
    for Node, or even Rackspace's DVM for Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s highly recommended to lock the Terraform version, so everyone in the
    team uses the same version, and updates can be painlessly handled. To do that,
    I suggest using a Terraform container, so we''ll use here the one I use myself:
    `sjourdan/terraform:<version>` (from [https://github.com/sjourdan/terraform-docker](https://github.com/sjourdan/terraform-docker)).
    But I understand replacing the simple `terraform` command by something such as
    ``docker run -it --rm -v `pwd`:/data sjourdan/terraform:0.7.3`` can feel not so
    appealing. That''s why we can use a common `Makefile` for each project using Terraform.'
  prefs: []
  type: TYPE_NORMAL
- en: Using a common entry point for manipulating the infrastructure code helps a
    lot of sharing practices, enforcing policies, and integrating third-party services
    such as CI systems.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Terraform installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AWS account with an SSH key configured in Terraform (refer to the [Chapter
    2](ch02.html "Chapter 2. Provisioning IaaS with Terraform"), *Provisioning IaaS
    with Terraform* recipes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s begin by setting the Terraform version we want to use in a Makefile
    so it will be easy to manipulate for updates in the future:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now create a `TERRAFORM_BIN` variable that will include the full Docker
    command, plus share our local folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'I like auto-documenting my Makefile, and I propose a popular technique: `make`
    by default calls `make help`, which in turn parses the `Makefile` for comments,
    and displays them. That way, I can choose what to output by simply adding a comment.
    Here''s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Now simply use this feature to create an entry for the validation and formatting
    from the previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'If you simply type `make`, you''ll get an automatic help:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Now, a simple `make validate` will both validate the syntax and format the code.
  prefs: []
  type: TYPE_NORMAL
- en: It would be great to have the `plan` and `apply` commands as well, and if you
    followed the recipe on environment management with Terraform, that would be awesome
    if it worked right from the `Makefile`, we'd save a lot of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating the `Makefile` main "help" entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We added the validation step at each step, so we're always absolutely sure it
    passes full validation (and you can add your own validation steps).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check for an environment variable named `env`, passed at `make` execution
    (such as `make plan env=staging`), and returns an error if not set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can write what `terraform-plan` and `terraform-apply` are exactly running,
    with isolated Terraform states and environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'By the way, you can add support for environments to our previous `terraform-validate`
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Add as many features as you want to your project's `Makefile`; you'll soon realize
    this simple tool helps so much.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, I always add a `make destroy` command, so I can easily destroy
    a test infrastructure (be careful though!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Our Makefile now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, it can be used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Add absolutely anything that might make your lives easier, such as releases,
    tests, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The auto documented Makefile: [http://marmelab.com/blog/2016/02/29/auto-documented-makefile.html](http://marmelab.com/blog/2016/02/29/auto-documented-makefile.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rbenv: [https://github.com/rbenv/rbenv](https://github.com/rbenv/rbenv)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RVM: [https://github.com/rvm/rvm](https://github.com/rvm/rvm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DVM: [https://github.com/getcarina/dvm](https://github.com/getcarina/dvm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NVM: [https://github.com/creationix/nvm](https://github.com/creationix/nvm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Team workflow example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with infrastructure code is very similar to working with software code.
    Countless books and methods exist on the subject and approaches are usually very
    opinionated.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple workflow I propose to use here for our infrastructure-as-code work
    is based on what''s called the **GitHub Flow** ([https://guides.github.com/introduction/flow/](https://guides.github.com/introduction/flow/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Team workflow example](img/B05671_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An account on some Git hosting (self-hosted or commercial)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working Terraform installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AWS account with an SSH key configured in Terraform (refer to the [Chapter
    2](ch02.html "Chapter 2. Provisioning IaaS with Terraform"), *Provisioning IaaS
    with Terraform* recipes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start by creating a new repository for use with your team. Use any service
    that works for you: GitLab, GitHub, BitBucket, and others. This example uses GitHub.'
  prefs: []
  type: TYPE_NORMAL
- en: A simple Git repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a new repository on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We might be storing secrets in that repository, such as SSH private keys or
    passwords. It's probably a safer option to create a private Git repository for
    now.
  prefs: []
  type: TYPE_NORMAL
- en: '![A simple Git repository](img/B05671_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now import this new empty repository on your workstation, in a dedicated folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Initial infrastructure code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a new Git branch to work on an initial infrastructure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some Terraform code from the previous recipes, such as a single CoreOS
    instance. For the record, here''s the `variables.tf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a deliberately badly formatted `provider.tf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, here''s a CoreOS instance in `instances.tf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Terraform code validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s be sure our code validates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Thankfully, it does!
  prefs: []
  type: TYPE_NORMAL
- en: 'Does this code plan to do what we want it to do? Have a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: This looks exactly like our objective. Let's continue.
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure code commit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What are the new files on this branch that aren''t on master? Let''s find out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Good, those are the files we just created. Let''s add them to a `commit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s send the branch upstream so that our coworkers can see our work
    that''s still not yet in production:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Make a pull request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Navigate to your repository, and you''ll see something similar to the following
    screenshot, showing an information about the new branch being just pushed. GitHub
    proposes to easily create a pull request. A pull request is a request to merge
    the content of one branch to another branch. In our case, we want to ask our coworkers
    to merge our `new_infrastructure` branch into the master branch, to create some
    discussion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Make a pull request](img/B05671_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When you open a pull request, GitHub automatically tries the requested merge
    (in our case, from our branch to master). Here, no conflicts are noted, so we
    can write a message explaining what our request is all about. A pull request is
    often composed of multiple commits, so a summary is more than welcome:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Make a pull request](img/B05671_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now everyone from your team have access to your work and can discuss it right
    from GitHub if necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Make a pull request](img/B05671_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A few minutes later, one of your coworkers reviews your code and sends you
    a remark:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Make a pull request](img/B05671_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'She might be right; let''s find out with the Terraform formatter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Looks like there was a formatting issue! Use `git diff` to see what''s the
    difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re happy with that; let''s `add`, `commit`, and `push`. Pushing to our
    remote branch will automatically add our commit to the pull request as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Our coworker can now see in real time that we took her remark into account,
    as GitHub automatically marks it as outdated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Make a pull request](img/B05671_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now our coworker pulled the changes on her side, tried to plan the changes
    herself with Terraform, and announces she''s happy with the results as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Make a pull request](img/B05671_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Apply the changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So let''s do that right now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Is there anything new in our repository? Have a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Sure, now we have to ship our infrastructure state to the pull request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Our coworker sees that everything is all right, and she also checked the server
    is doing well. So, now she can merge our branch, close the pull request with a
    message, and then delete the now useless branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Apply the changes](img/B05671_03_11.jpg)![Apply the changes](img/B05671_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our code and its fixes are now on master, along with the updated infrastructure
    state, all done in full collaboration with a coworker.
  prefs: []
  type: TYPE_NORMAL
- en: 'For any new feature, anything added to the infrastructure should follow the
    same pattern: create a branch, insert your changes, open a pull request, discuss
    the changes with the coworkers, apply the change, and merge to master. Master
    is now the reference again.'
  prefs: []
  type: TYPE_NORMAL
- en: Managing GitHub with Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There're many service providers to use with Terraform. GitHub is one of them,
    and we'll see how to manage members of an organization, various teams, and control
    repository access, right from our infrastructure code. That way, we have an automatic
    history log of who accesses what.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Terraform installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A GitHub account (with an API token)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We want to manage a GitHub organization named **ACME**. Here are the users
    and their groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '| GitHub username | GitHub team name | Membership level | Team privacy |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| John | Documentation | member | closed |'
  prefs: []
  type: TYPE_TB
- en: '| Jane | Engineering | admin | secret |'
  prefs: []
  type: TYPE_TB
- en: 'Here''s the policy we decided concerning the Git repository named `infrastructure-repository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| GitHub team name | Repository permissions |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Documentation | pull |'
  prefs: []
  type: TYPE_TB
- en: '| Engineering | admin |'
  prefs: []
  type: TYPE_TB
- en: Configuring GitHub
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s start by creating a `github` provider, as we used an `aws` provider
    for AWS in the previous recipes. The documentation lists the requirements: an
    API token and an organization name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the generic variables in a `variables.tf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to override those variables to fit your own in the `terraform.tfvars`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Adding users to the GitHub organization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We want to add the username `john` as a member, and `jane` as an admin, in
    a file you can name `github.tf` (feel free to split managed GitHub features in
    many smaller files as your organization grows):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: John and Jane are now part of the GitHub organization (they will receive invitations
    by e-mail).
  prefs: []
  type: TYPE_NORMAL
- en: Adding GitHub teams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s create our two teams, technical writers and engineering, with their
    respective privacy settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Add our two members to their respective teams—Jane in engineering, John in
    documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Setting Git repository access rights
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The policy we''ve set is that members of the engineering group are admins of
    the repository, while technical writers can only pull the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: You've just set the essentials to manage your GitHub organization right from
    Terraform!
  prefs: []
  type: TYPE_NORMAL
- en: External monitoring integration with StatusCake
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'External monitoring is helpful because it gives insights on how performant
    your infrastructure is, as seen from the outside, maybe from many places in the
    world. We can build our own availability monitoring systems, or we can use third-party
    services. StatusCake is a good example for us as they have a good API and a free
    service tier for us to try with Terraform. We''ll monitor two things: host latency
    and HTTP availability.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Terraform installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A StatusCake account ([https://statuscake.com](https://statuscake.com))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally, an infrastructure managed by Terraform (refer to the previous recipes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start by setting the new `statuscake` provider, as we did with AWS or GitHub,
    using a username and API key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the variables in `variables.tf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Also, don't forget to set those variables to your own values in `terraform.tfvars`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an automated ping monitoring test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s create an initial test, a simple ICMP ping to a server whose IP is `1.2.3.4`,
    every 5 minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `website_name` or `website_url` can be a reference to an existing Terraform
    resource. If our AWS instance resource is named `centos`, you can access the value
    dynamically like this, instead of a static value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'If your resource has a `count` number, you can iterate through it so all the
    available instances are automatically monitored. It works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Another useful feature is to switch the value of `paused` to `true` for planned
    downtimes, so you're not hammered with alerts you're already aware of.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an HTTPS test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A very common test we'll want to make is HTTP availability. It's really no different
    than an ICMP check;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
