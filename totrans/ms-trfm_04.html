<html><head></head><body>
<div id="_idContainer038">
<h1 class="chapter-number" id="_idParaDest-90"><a id="_idTextAnchor239"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-91"><a id="_idTextAnchor240"/><span class="koboSpan" id="kobo.2.1">Foundations of Cloud Architecture – Virtual Machines and Infrastructure-as-a-Services</span></h1>
<p><span class="koboSpan" id="kobo.3.1">This book aims to help you master Terraform, but what does it take to be a true master? </span><span class="koboSpan" id="kobo.3.2">Terraform is an </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">Infrastructure-as-Code</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">IaC</span></strong><span class="koboSpan" id="kobo.7.1">) tool that enables you to describe your cloud architecture using code. </span><span class="koboSpan" id="kobo.7.2">Without a solid understanding of the underlying architecture, you can never become a true master of Terraform. </span><span class="koboSpan" id="kobo.7.3">Therefore, I’ve included the next few chapters to provide the groundwork for ubiquitous architectural concepts across cloud platforms to lay the foundation for later chapters, when we will build sophisticated cloud architectures in three distinct cloud </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">computing paradigms:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.9.1">Virtual machines</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.10.1">Containers</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.11.1">Serverless</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.12.1">With this foundation, you will understand the necessary concepts to follow along with the solution architectures we will build in </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">later chapters.</span></span></p>
<p><span class="koboSpan" id="kobo.14.1">In this chapter, we will focus on the key concepts that are critical for understanding, architecting, and automating virtual machine-based solutions. </span><span class="koboSpan" id="kobo.14.2">First, we will lay a foundation for fundamental networking concepts such as subnets, routing, perimeter-based security, peering, </span><strong class="bold"><span class="koboSpan" id="kobo.15.1">Virtual Private Networks</span></strong><span class="koboSpan" id="kobo.16.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.17.1">VPNs</span></strong><span class="koboSpan" id="kobo.18.1">), and dedicated </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">network connections.</span></span></p>
<p><span class="koboSpan" id="kobo.20.1">Next, we’ll delve into the basic anatomy of virtual machines, including disks and network interfaces. </span><span class="koboSpan" id="kobo.20.2">We will then be considering the subtle nuances between Windows and Linux virtual machines. </span><span class="koboSpan" id="kobo.20.3">Next, we will </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">cover auto-scaling.</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">Finally, we’ll round it out by discussing how virtual machines are provisioned, covering both mutable and immutable infrastructure practices and their corresponding IaC practices </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">and tools.</span></span></p>
<p><span class="koboSpan" id="kobo.24.1">This chapter covers the </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.26.1">Understanding the key concepts </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">of networking</span></span></li>
<li><span class="koboSpan" id="kobo.28.1">Understanding the key concepts </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">of compute</span></span></li>
<li><span class="koboSpan" id="kobo.30.1">Understanding the role of virtual </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">machine images</span></span></li>
</ul>
<h1 id="_idParaDest-92"><a id="_idTextAnchor241"/><span class="koboSpan" id="kobo.32.1">Understanding the key concepts of networking</span></h1>
<p><span class="koboSpan" id="kobo.33.1">Depending </span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.34.1">on how you and your organization plan on leveraging the cloud, you will likely work with one or more of the three paradigms for provisioning infrastructure: virtual machines, containers, or serverless. </span><span class="koboSpan" id="kobo.34.2">Each paradigm has different benefits and detractors that you must consider when selecting them for your solution architecture. </span><span class="koboSpan" id="kobo.34.3">Still, it is crucial to recognize that each paradigm has its own time and place that makes it worthwhile. </span><span class="koboSpan" id="kobo.34.4">In this book, I hope to help you learn how to leverage Terraform to deploy sophisticated solutions in these paradigms on the three significant hyperscalers (at the time </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">of writing).</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">Each of these paradigms has specific concepts that transcend cloud platforms that you—as a practitioner and architect—need to understand to design and implement solutions </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">using Terraform.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">Virtual machines are a standard service on every cloud platform because most organizations would like to leverage the cloud with their existing applications with minimal change. </span><span class="koboSpan" id="kobo.38.2">Virtual machines enable these organizations to have complete control of the configuration of their environment from the operating system up. </span><span class="koboSpan" id="kobo.38.3">With this low level of control, organizations can move applications to cloud infrastructure with minimal change, yet </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">ultimate control.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">This approach is practical because virtual machines are a concept and architecture that is well-known by most IT organizations. </span><span class="koboSpan" id="kobo.40.2">Organizations looking to migrate to the cloud probably already use virtual machines in their on-premises </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">data centers.</span></span></p>
<p><span class="koboSpan" id="kobo.42.1">That means that as you automate that infrastructure in the cloud, you’ll need to understand the core concepts and common </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">architectural patterns.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">With virtual machines, the good news is that most of the anatomy is relatively similar across cloud platforms, so if you know what you’re looking for, there is a good chance you will find the corresponding service—or Terraform resource—that implements that particular aspect of the solution. </span><span class="koboSpan" id="kobo.44.2">There may be subtle differences between cloud platforms that you must learn through conducting detailed analysis and optimizing your solutions. </span><span class="koboSpan" id="kobo.44.3">Still, if you understand the basic concepts, it’ll be pretty easy to map them across the cloud platforms and get productive using Terraform </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">relatively quickly.</span></span></p>
<p><span class="koboSpan" id="kobo.46.1">In this book, we will build an end-to-end solution using virtual machines on AWS, Azure, and Google Cloud Platform. </span><span class="koboSpan" id="kobo.46.2">To do so, you must understand some critical concepts that transcend cloud platforms to help you navigate the architecture and relevant Terraform resources within the respective cloud platform’s </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">Terraform provider.</span></span><a id="_idTextAnchor242"/></p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor243"/><span class="koboSpan" id="kobo.48.1">Networking</span></h2>
<p><span class="koboSpan" id="kobo.49.1">All virtual </span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.50.1">machines live on a network and each cloud platform has a corresponding service that handles this aspect of the solution. </span><span class="koboSpan" id="kobo.50.2">A network itself is relatively simple to create. </span><span class="koboSpan" id="kobo.50.3">It only needs one primary piece of information: the network address space, a block of IP addresses that fall within a </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">contiguous range.</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">An IP address is made up of 32 bits. </span><span class="koboSpan" id="kobo.52.2">These bits are grouped into octets and translated into integers between </span><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">0</span></strong><span class="koboSpan" id="kobo.54.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.55.1">255</span></strong><span class="koboSpan" id="kobo.56.1">. </span><span class="koboSpan" id="kobo.56.2">IPv4 has four octets in a single IP address, resulting in over 4 billion addressable IP addresses. </span><span class="koboSpan" id="kobo.56.3">In IPv6, there are 16 octets and many more </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">IP addresses.</span></span></p>
<p><span class="koboSpan" id="kobo.58.1">CIDR notation is a method for representing IP address ranges as contiguous blocks. </span><span class="koboSpan" id="kobo.58.2">A CIDR block comprises an IP address starting the range and a prefix length separated by a forward slash. </span><span class="koboSpan" id="kobo.58.3">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">10.0.1.0/24</span></strong><span class="koboSpan" id="kobo.60.1"> represents a range of IP addresses starting with </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">10.0.1.0</span></strong><span class="koboSpan" id="kobo.62.1"> and extending through to </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">10.0.1.255</span></strong><span class="koboSpan" id="kobo.64.1">—256 IP addresses. </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">10.0.1.0</span></strong><span class="koboSpan" id="kobo.66.1"> is the starting IP address, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">24</span></strong><span class="koboSpan" id="kobo.68.1"> is the number of bits that should be in common. </span><span class="koboSpan" id="kobo.68.2">Since an IP address is composed of 32 bits and each decimal within the IP address represents 8 bits, 24 bits would mean that three of the four octets are shared within the range and only the last digit changes. </span><span class="koboSpan" id="kobo.68.3">Since the last digit ranges from </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">0</span></strong><span class="koboSpan" id="kobo.70.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">255</span></strong><span class="koboSpan" id="kobo.72.1">, that gives us 256 IP addresses starting with </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">10.0.1.0</span></strong><span class="koboSpan" id="kobo.74.1"> and going through </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">10.0.1.255</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.78.1">Several reserved IP address ranges exist for private networks. </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">10.0.0.0/8</span></strong><span class="koboSpan" id="kobo.80.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">172.0.0.0/12</span></strong><span class="koboSpan" id="kobo.82.1"> are the most common ranges in enterprises, while I’m sure you’ve encountered </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">192.168.0.0/16</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.84.1">at home.</span></span></p>
<p><span class="koboSpan" id="kobo.85.1">Getting familiar with CIDR notation and understanding the impact of selecting different-sized prefixes is essential. </span><span class="koboSpan" id="kobo.85.2">Usually, </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">/16</span></strong><span class="koboSpan" id="kobo.87.1"> is the largest (65,536 IP addresses) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">/28</span></strong><span class="koboSpan" id="kobo.89.1"> the smallest (16 IP addresses) prefix supported by cloud platforms—but it does vary, so you should check your cloud platform’s documentation. </span><span class="koboSpan" id="kobo.89.2">More importantly, consider your requirements and if you have an in-house networking team at your organization, by all means, consult them when settling on a range that fits for </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">your solution.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">Usually, organizations </span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.92.1">maintain a list of IP address ranges that have been allocated to different teams or applications to prevent IP address conflicts. </span><span class="koboSpan" id="kobo.92.2">This practice is critical when starting in the cloud for the first time at your organization if you already have an on-premise network. </span><span class="koboSpan" id="kobo.92.3">If you use a default—such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">10.0.0.0/16</span></strong><span class="koboSpan" id="kobo.94.1">—or always use the same address range, you could be hurt if you ever want to connect your project to other networks within </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">your organization.</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">Although it can vary by cloud platform, you would usually provision a virtual network within a specific region, as on AWS and Azure. </span><span class="koboSpan" id="kobo.96.2">However, with Google Cloud Platform, virtual networks are global and span </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">all region</span><a id="_idTextAnchor244"/><span class="koboSpan" id="kobo.98.1">s.</span></span></p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor245"/><span class="koboSpan" id="kobo.99.1">Subnets</span></h2>
<p><span class="koboSpan" id="kobo.100.1">Once you</span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.101.1"> have settled on an IP address space for your network, you will be carving it into subnets. </span><span class="koboSpan" id="kobo.101.2">Subnets allow you to segment your network for various reasons, including improved security or organizational and </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">operational efficiencies.</span></span></p>
<p><span class="koboSpan" id="kobo.103.1">From a security standpoint, subnets are very important to isolate components of your architecture to reduce the blast radius if a problem occurs in one subnet. </span><span class="koboSpan" id="kobo.103.2">By creating routing rules to control network traffic between subnets, you can increase security by cutting down the surface area for </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">an attack.</span></span></p>
<p><span class="koboSpan" id="kobo.105.1">Depending on the cloud platform, subnets might also influence the physical location of resources provisioned within such as an availability zone. </span><span class="koboSpan" id="kobo.105.2">This is the case on AWS. </span><span class="koboSpan" id="kobo.105.3">However, Azure and GCP do not have this limitation, as their subnets can contain resources that span the </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">entire regi</span><a id="_idTextAnchor246"/><span class="koboSpan" id="kobo.107.1">on.</span></span></p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor247"/><span class="koboSpan" id="kobo.108.1">Routing</span></h2>
<p><span class="koboSpan" id="kobo.109.1">Once you </span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.110.1">have segmented your virtual network using subnets, it’s crucial to establish the traffic patterns of network traffic using </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.111.1">route tables</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.113.1">Route tables </span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.114.1">allow you to direct network traffic to the correct endpoint based on different rules for different types of traffic. </span><span class="koboSpan" id="kobo.114.2">For example, there may be a delineation between internet traffic routed to an internet gateway or a NAT gateway. </span><span class="koboSpan" id="kobo.114.3">Similar network routing rules can route traffic to on-premise networks through VPN or Direct Connect connections, peered virtual networks, transit gateways, or </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">service endpo</span><a id="_idTextAnchor248"/><span class="koboSpan" id="kobo.116.1">ints.</span></span></p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor249"/><span class="koboSpan" id="kobo.117.1">Network security</span></h2>
<p><span class="koboSpan" id="kobo.118.1">Once you</span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.119.1"> have a virtual network and a set of subnets, each with its own purpose and resources, you will likely need to apply security controls to ensure that only the expected network traffic can pass between resources within the </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">various subnets.</span></span></p>
<p><span class="koboSpan" id="kobo.121.1">Most cloud platforms have some manifestation of this concept, but they may have different names. </span><span class="koboSpan" id="kobo.121.2">They may have other mechanisms for attachment—either on a subnet, virtual machine, or</span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.122.1"> virtual </span><strong class="bold"><span class="koboSpan" id="kobo.123.1">Network Interface Card</span></strong><span class="koboSpan" id="kobo.124.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.125.1">NIC</span></strong><span class="koboSpan" id="kobo.126.1">). </span><span class="koboSpan" id="kobo.126.2">They include inbound and outbound rules. </span><span class="koboSpan" id="kobo.126.3">They can also come in stateless and stateful forms and sometimes support both </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">Allow</span></strong><span class="koboSpan" id="kobo.128.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">Deny</span></strong><span class="koboSpan" id="kobo.130.1"> rules, while other times they only support </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">Allow</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.132.1"> rules.</span></span></p>
<p><span class="koboSpan" id="kobo.133.1">Azure and AWS provide a lower-level mechanism focusing primarily on the physical network layer and a higher level focusing on more of the logical application layer. </span><span class="koboSpan" id="kobo.133.2">Google Cloud Platform wraps both concepts into one structure and calls them </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">firewall rules.</span></span></p>
<p><span class="koboSpan" id="kobo.135.1">AWS has </span><strong class="bold"><span class="koboSpan" id="kobo.136.1">Network Access Control Lists</span></strong><span class="koboSpan" id="kobo.137.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.138.1">NACLs</span></strong><span class="koboSpan" id="kobo.139.1">), which attach to subnets and control the</span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.140.1"> flow of network traffic between subnets. </span><span class="koboSpan" id="kobo.140.2">As a result, they only work on network address ranges—not AWS resources such as network gateways or service endpoints. </span><span class="koboSpan" id="kobo.140.3">They are stateless, which means that, in most cases, you need the inbound and outbound rules to match for connectivity </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">to succeed.</span></span></p>
<p><span class="koboSpan" id="kobo.142.1">In contrast, AWS also has security groups, which are stateful, only support </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">Allow</span></strong><span class="koboSpan" id="kobo.144.1"> rules, and allow you to route traffic between different network address ranges and AWS resources using their unique identifiers. </span><span class="koboSpan" id="kobo.144.2">Security groups can be logically attached to a subnet or directly onto virtual machines (EC2 instances), but AWS evaluates them at the virtual machine level. </span><span class="koboSpan" id="kobo.144.3">Attaching a security group to a subnet only results in an implicit cascading attachment of that security group to all virtual machines within </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">that subnet.</span></span></p>
<p><span class="koboSpan" id="kobo.146.1">Azure similarly has two </span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.147.1">constructs for constraining network traffic: </span><strong class="bold"><span class="koboSpan" id="kobo.148.1">Network Security Groups</span></strong><span class="koboSpan" id="kobo.149.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.150.1">NSGs</span></strong><span class="koboSpan" id="kobo.151.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.152.1">Application Security Groups</span></strong><span class="koboSpan" id="kobo.153.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.154.1">ASGs</span></strong><span class="koboSpan" id="kobo.155.1">). </span><span class="koboSpan" id="kobo.155.2">NSGs are in many ways a combination of AWS’s NACLs and security groups but shed some logical attachment capabilities with a focus on the physical network layer. </span><span class="koboSpan" id="kobo.155.3">ASGs </span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.156.1">are logical and can be associated with a virtual machine through NICs. </span><span class="koboSpan" id="kobo.156.2">Just like AWS NACLs, you can think of NSGs as controlling the flow of traffic between networks, while AWS’s security groups and Azure’s ASGs both focus on controlling traffic at a finer grain—with an application-centric lens—between resources within </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">the network.</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">Google Cloud Platform has one construct: firewall rules. </span><span class="koboSpan" id="kobo.158.2">This construct is stateful but also supports </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">Allow</span></strong><span class="koboSpan" id="kobo.160.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">Deny</span></strong><span class="koboSpan" id="kobo.162.1"> rules. </span><span class="koboSpan" id="kobo.162.2">It can be attached to a virtual network or a region, or it can be </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">attached</span><a id="_idTextAnchor250"/><span class="koboSpan" id="kobo.164.1"> globally.</span></span></p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor251"/><span class="koboSpan" id="kobo.165.1">Network peering</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.166.1">Virtual network peering</span></strong><span class="koboSpan" id="kobo.167.1"> is a</span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.168.1"> networking feature offered by most</span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.169.1"> cloud platforms that allows you to connect virtual networks within the same cloud platform without additional </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">VPN-based connectivity</span></span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.172.1">To create a peering connection between two virtual networks, they must be in the same cloud platform, and there should not be any conflicts within their network address space. </span><span class="koboSpan" id="kobo.172.2">This potential quagmire is one reason why it’s essential to think through and apply proper governance around allocated network </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">address ranges.</span></span></p>
<p><span class="koboSpan" id="kobo.174.1">Peering is a capability that eliminates the need for more complex private site-to-site connections using VPN connections and is the preferred method for connecting networks withi</span><a id="_idTextAnchor252"/><span class="koboSpan" id="kobo.175.1">n </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">the cloud.</span></span></p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor253"/><span class="koboSpan" id="kobo.177.1">Service endpoints</span></h2>
<p><span class="koboSpan" id="kobo.178.1">Most </span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.179.1">cloud platforms provide services that are primarily accessed directly via the internet. </span><span class="koboSpan" id="kobo.179.2">In situations where security is paramount, avoiding transmitting data across the internet is essential. </span><span class="koboSpan" id="kobo.179.3">Service endpoints are a feature provided by cloud platforms that enable private network communication between virtual networks and specific services within the cloud environment without traversing the </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">public internet.</span></span></p>
<p><span class="koboSpan" id="kobo.181.1">While this concept and goal exists and remains the same across all cloud providers we will cover in this book, it goes by different names, has varying support across each platform’s service offerings, and may have other attachment and routing mechanisms to</span><a id="_idTextAnchor254"/><span class="koboSpan" id="kobo.182.1"> set service </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">endpoints</span></span><span class="No-Break"><span class="koboSpan" id="kobo.184.1"> up.</span></span></p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor255"/><span class="koboSpan" id="kobo.185.1">VPN and Direct Connect</span></h2>
<p><span class="koboSpan" id="kobo.186.1">When </span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.187.1">virtual network peering isn’t an option, you can always leverage traditional site-to-site VPN connectivity options to connect networks from your on-premises networks or across </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">cloud providers.</span></span></p>
<p><span class="koboSpan" id="kobo.189.1">When setting up a VPN connection, most cloud platforms require you to provide a resource representing the source network and destination </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">network configuration.</span></span></p>
<p><span class="koboSpan" id="kobo.191.1">The destination network is where you host the entry point for your VPN and where the VPN traffic traverses to gain connectivity to cloud-hosted resources. </span><span class="koboSpan" id="kobo.191.2">The source network is where you have devices that need to connect to the destination network. </span><span class="koboSpan" id="kobo.191.3">The source network is often on-premise, but it doesn’t have to be. </span><span class="koboSpan" id="kobo.191.4">After that, the most common use case is connecting networks on two different </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">cl</span><a id="_idTextAnchor256"/><span class="koboSpan" id="kobo.193.1">oud platforms.</span></span></p>
<p><span class="koboSpan" id="kobo.194.1">In this section, we learned the critical concepts of cloud networking that you will encounter whenever you provision virtual machines, no matter your target cloud platform. </span><span class="koboSpan" id="kobo.194.2">There might be some subtle changes on each platform that affect how you’ll use each and how they will affect the availability and structure of your architecture, but their function is essentially </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">the same.</span></span></p>
<p><span class="koboSpan" id="kobo.196.1">Next, we’ll look at the critical concepts of virtual machines, including basic anatomy. </span><span class="koboSpan" id="kobo.196.2">This includes disks, NICs, and the virtual machine itself, as well as operating system-specific differences between Windows and Linux and cloud-specific capabilities such </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">as auto-scaling.</span></span></p>
<h1 id="_idParaDest-100"><a id="_idTextAnchor257"/><span class="koboSpan" id="kobo.198.1">Understanding the key concepts of compute</span></h1>
<p><span class="koboSpan" id="kobo.199.1">A virtual machine is a</span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.200.1"> software emulation of a physical computer. </span><span class="koboSpan" id="kobo.200.2">Just like a regular computer, it runs an operating system and whatever applications you install on it. </span><span class="koboSpan" id="kobo.200.3">Ultimately, it does run on physical hardware. </span><span class="koboSpan" id="kobo.200.4">However, in the cloud, the </span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.201.1">cloud platform abstracts the physical hardware and the hypervisor that manages the virtual machines from </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">the user.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">Virtual machines are most commonly available on cloud platforms in two flavors: Linux and Windows, with various current and historical versions supported through marketplace offerings on the cloud </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">platform itself.</span></span></p>
<p><span class="koboSpan" id="kobo.205.1">The primary configuration attributes of a virtual machine are its size, the virtual machine image to use as its operating system disk, additional data disks, and </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">network configuration.</span></span></p>
<p><span class="koboSpan" id="kobo.207.1">Cloud platforms</span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.208.1"> use a </span><strong class="bold"><span class="koboSpan" id="kobo.209.1">Stock-Keeping Unit</span></strong><span class="koboSpan" id="kobo.210.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.211.1">SKU</span></strong><span class="koboSpan" id="kobo.212.1">) to create a standard configuration that dictates the size and hardware profile of the virtual machine. </span><span class="koboSpan" id="kobo.212.2">This pattern is typical across cloud platforms, but the SKU names follow different naming conventions. </span><span class="koboSpan" id="kobo.212.3">Cloud platforms do have a</span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.213.1"> similar organization system with sub-categories such as general purpose, compute-optimized, and memory-optimized. </span><span class="koboSpan" id="kobo.213.2">There are also those with particular hardware components </span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.214.1">such as </span><strong class="bold"><span class="koboSpan" id="kobo.215.1">Graphics Processing </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.216.1">Units</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.217.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.218.1">GPUs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.220.1">The virtual machine image is a disk image of a pre-configured operating system, which can include additional software pre-installed depending on the image’s purpose. </span><span class="koboSpan" id="kobo.220.2">The virtual machine image is an essential component in the automation of virtual machines. </span><span class="koboSpan" id="kobo.220.3">We’ll go into further d</span><a id="_idTextAnchor258"/><span class="koboSpan" id="kobo.221.1">epth on </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">this later.</span></span></p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor259"/><span class="koboSpan" id="kobo.223.1">Disks</span></h2>
<p><span class="koboSpan" id="kobo.224.1">Virtual machines </span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.225.1">can attach additional data disks to add extra storage. </span><span class="koboSpan" id="kobo.225.2">Like virtual machines, the disks can have varying sizes and performance characteristics. </span><span class="koboSpan" id="kobo.225.3">Unlike virtual machine sizes, which vary using categorical SKUs that indicate a fixed configuration type, disks use a continuous metric for sizing: </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.226.1">Gigabytes</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.227.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.228.1">GB</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.230.1">In addition to the disk size, you can also choose from several different performance classes optimized for different workload scenarios, such as general purpose, throughput optimized, and provisioned IOPS, which seeks to guarantee a reliable level </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">of performance.</span></span></p>
<p><span class="koboSpan" id="kobo.232.1">The SKU you select influences the number and class of disks you can attach to your virtual machine, with larger virtual machines supporting a large</span><a id="_idTextAnchor260"/><span class="koboSpan" id="kobo.233.1">r quantity </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">of disks.</span></span></p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor261"/><span class="koboSpan" id="kobo.235.1">Network Interface Cards (NICs)</span></h2>
<p><span class="koboSpan" id="kobo.236.1">Virtual machines</span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.237.1"> can attach NICs that logically represent a physical network interface card. </span><span class="koboSpan" id="kobo.237.2">As with disks, the size of a virtual machine can impact the number of NICs you can add and the features you </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">can enable.</span></span></p>
<p><span class="koboSpan" id="kobo.239.1">Through NIC configuration, you can either team the network interfaces together to create higher bandwidth or attach them to different subnets to connect a virtual machine. </span><span class="koboSpan" id="kobo.239.2">The latter option lets you straddle the line between t</span><a id="_idTextAnchor262"/><span class="koboSpan" id="kobo.240.1">wo </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">separate networks.</span></span></p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor263"/><span class="koboSpan" id="kobo.242.1">Linux versus Windows</span></h2>
<p><span class="koboSpan" id="kobo.243.1">Linux and Windows</span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.244.1"> virtual machines </span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.245.1">are identical anatomically in terms of virtual machine sizes, disks, and NICs. </span><span class="koboSpan" id="kobo.245.2">Still, there are a few key differences to be aware of when using Terraform and other tools to </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">manage them.</span></span></p>
<h3><span class="koboSpan" id="kobo.247.1">Authentication and remote access</span></h3>
<p><span class="koboSpan" id="kobo.248.1">Windows virtual </span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.249.1">machines usually require an administrator username and password. </span><span class="koboSpan" id="kobo.249.2">In contrast, Linux virtual machines usually require an SSH key. </span><span class="koboSpan" id="kobo.249.3">After the initial setup, you can configure Windows to support SSH access, but password-based credentials are </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">needed initially.</span></span></p>
<p><span class="koboSpan" id="kobo.251.1">This caveat also manifests in remotely accessing virtual machines using Windows and Linux. </span><span class="koboSpan" id="kobo.251.2">Windows </span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.252.1">uses </span><strong class="bold"><span class="koboSpan" id="kobo.253.1">Remote Desktop Protocol</span></strong><span class="koboSpan" id="kobo.254.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.255.1">RDP</span></strong><span class="koboSpan" id="kobo.256.1">), which requires a password-based login. </span><span class="koboSpan" id="kobo.256.2">Linux uses SSH, which can support either pas</span><a id="_idTextAnchor264"/><span class="koboSpan" id="kobo.257.1">sword or </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">key-based login.</span></span></p>
<h3><span class="koboSpan" id="kobo.259.1">Configuration scripts</span></h3>
<p><span class="koboSpan" id="kobo.260.1">Windows</span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.261.1"> supports several different types of scripting by default. </span><span class="koboSpan" id="kobo.261.2">However, the most common are batch scripting, which uses the </span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.262.1">Windows </span><strong class="bold"><span class="koboSpan" id="kobo.263.1">Command-Line Interpreter</span></strong><span class="koboSpan" id="kobo.264.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.265.1">CMD</span></strong><span class="koboSpan" id="kobo.266.1">), and </span><strong class="bold"><span class="koboSpan" id="kobo.267.1">PowerShell</span></strong><span class="koboSpan" id="kobo.268.1">. </span><span class="koboSpan" id="kobo.268.2">While Microsoft initially developed PowerShell specifically for </span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.269.1">automating administration tasks on Windows, support for PowerShell has since been added on Linux, although community adoption has not hit </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">critical mass.</span></span></p>
<p><span class="koboSpan" id="kobo.271.1">While Linux </span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.272.1">distributions vary, </span><strong class="bold"><span class="koboSpan" id="kobo.273.1">Bourne Again SHell</span></strong><span class="koboSpan" id="kobo.274.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.275.1">Bash</span></strong><span class="koboSpan" id="kobo.276.1">) is the default for most distributions. </span><span class="koboSpan" id="kobo.276.2">There are others—for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">ksh</span></strong><span class="koboSpan" id="kobo.278.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">csh</span></strong><span class="koboSpan" id="kobo.280.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">tsch</span></strong><span class="koboSpan" id="kobo.282.1">—and while their capabilities are similar to Bash, their </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">popularity varies.</span></span></p>
<p><span class="koboSpan" id="kobo.284.1">Windows has even joined the party by introducing </span><strong class="bold"><span class="koboSpan" id="kobo.285.1">Windows Subsystem for Linux</span></strong><span class="koboSpan" id="kobo.286.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.287.1">WSL</span></strong><span class="koboSpan" id="kobo.288.1">), which, when </span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.289.1">installed, can execute Bas</span><a id="_idTextAnchor265"/><span class="koboSpan" id="kobo.290.1">h scripts natively </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">on Windows.</span></span></p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor266"/><span class="koboSpan" id="kobo.292.1">Auto-scaling</span></h2>
<p><span class="koboSpan" id="kobo.293.1">One of the </span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.294.1">quintessential advantages of leveraging the cloud is the ability to add elasticity to your solutions at scale. </span><span class="koboSpan" id="kobo.294.2">That is to increase capacity when there is heavy usage of your application and decrease capacity when your application’s use </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">goes down.</span></span></p>
<p><span class="koboSpan" id="kobo.296.1">Cloud platforms provide mechanisms that make achieving this very easy. </span><span class="koboSpan" id="kobo.296.2">Although they may have different names for this capability, the anatomy of the solution remains the same. </span><span class="koboSpan" id="kobo.296.3">You simply give details on the virtual machine image that you want, how large the virtual machine should be, any hard range constraints in terms of the number of instances (such as a minimum and a maximum), and finally, you provide several parameters to control when and how fast to scale up or </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">scale down.</span></span></p>
<p><span class="koboSpan" id="kobo.298.1">This section has taught us some of the basics of how we provision virtual machines. </span><span class="koboSpan" id="kobo.298.2">These concepts manifest across different cloud platforms. </span><span class="koboSpan" id="kobo.298.3">While there may be small subtleties between the various cloud platforms, they </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">operate similarly.</span></span></p>
<p><span class="koboSpan" id="kobo.300.1">Next, we’ll look at the role that the virtual machine image plays in how we can automate </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">virtual machines.</span></span></p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor267"/><span class="koboSpan" id="kobo.302.1">Understanding the role of virtual machine images</span></h1>
<p><span class="koboSpan" id="kobo.303.1">Virtual machines </span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.304.1">need an operating system and other applications installed to serve their purpose. </span><span class="koboSpan" id="kobo.304.2">A virtual machine image is a single file containing a virtual disk with a bootable operating system installed on it. </span><span class="koboSpan" id="kobo.304.3">It’s a snapshot of a virtual machine at a particular point in time. </span><span class="koboSpan" id="kobo.304.4">This snapshot contains the state of the virtual machine, including the operating system, installed a</span><a id="_idTextAnchor268"/><span class="koboSpan" id="kobo.305.1">pplications, and </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">other settings.</span></span></p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor269"/><span class="koboSpan" id="kobo.307.1">Static virtual machines</span></h2>
<p><span class="koboSpan" id="kobo.308.1">When setting</span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.309.1"> up a single virtual machine, or even a group of them with different roles and responsibilities within a solution’s architecture, there is a process of configuration that needs to happen to get each virtual machine into the state required to perform its duties as part of </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">the solution.</span></span></p>
<p><span class="koboSpan" id="kobo.311.1">This configuration</span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.312.1"> includes the </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.314.1">Installing the </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">operating system</span></span></li>
<li><span class="koboSpan" id="kobo.316.1">Configuring the </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">operating system</span></span></li>
<li><span class="koboSpan" id="kobo.318.1">Installing software updates and </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">security patches</span></span></li>
<li><span class="koboSpan" id="kobo.320.1">Installing </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">third-party software</span></span></li>
<li><span class="koboSpan" id="kobo.322.1">Configuring </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">third-party software</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.324.1">Of course, each of these steps may change depending on the role of the virtual machine within the solution. </span><span class="koboSpan" id="kobo.324.2">The further down the order a step is, the more likely it becomes that the configuration will change, with operating system installation being the most stable and third-party software configuration having the most diversity depending on the virtual </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">machine’s role.</span></span></p>
<p><span class="koboSpan" id="kobo.326.1">For example, a simple two-tier architecture requiring a Java web application to talk to a PostgreSQL database would have two roles. </span><span class="koboSpan" id="kobo.326.2">One role installs the Java Web Application server, while another installs the PostgreSQL database. </span><span class="koboSpan" id="kobo.326.3">Both virtual machines might share the exact same operating system, configuration, and security patches in this scenario. </span><span class="koboSpan" id="kobo.326.4">Still, when it comes to third-party software, one might need Java Web Application server software, while the other might need PostgreSQL database </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">server software.</span></span></p>
<p><span class="koboSpan" id="kobo.328.1">Each role requires different configuration steps to configure the server to fulfill its purpose. </span><span class="koboSpan" id="kobo.328.2">For example, these steps might include steps such as installing software packages, setting environment variables, updating configuration files, creating user accounts, setting up permissions, running custom scripts, or any other action required to set up </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">the machine.</span></span></p>
<p><span class="koboSpan" id="kobo.330.1">When working with the cloud, you pass this configuration to the virtual machine by specifying an operating system disk image. </span><span class="koboSpan" id="kobo.330.2">The disk image that is used will determine whether the virtual machine will spin up with nothing but a clean install of Ubuntu 22.04—ready to be manually configured—or a fully working Java Web Application server that requires no manual </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">intervention whatsoever.</span></span></p>
<p><span class="koboSpan" id="kobo.332.1">Each cloud platform provides a large set of disk images that you can use to start virtual machines for various purposes. </span><span class="koboSpan" id="kobo.332.2">The most common ones are baseline images with a specific version of an operating system installed, such as Windows Server 2019, Ubuntu 22.04, or RedHat </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">Enterprise Linux.</span></span></p>
<p><span class="koboSpan" id="kobo.334.1">With so</span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.335.1"> many marketplace images providing a baseline operating system install, you can spin up a virtual machine with Ubuntu 22.04, install the Java Web Application software, configure it precisely to your specifications, and create a new virtual machine image. </span><span class="koboSpan" id="kobo.335.2">This new virtual machine image will boot up as a Java Web Application server rather than a brand new installation of Ubuntu 22.04, which means that you are that much closer to using this virtual machine to host your </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">web application.</span></span></p>
<p><span class="koboSpan" id="kobo.337.1">You can use automation technologies that manage this configuration to perform the actions you might perform manually, assuming you were starting from a clean operating system installation. </span><span class="koboSpan" id="kobo.337.2">Several automation tools focus on this problem—you might be surprised to learn that Terraform is not one of them. </span><span class="koboSpan" id="kobo.337.3">While Terraform can provide this configuration through several different techniques, that’s not its primary focus. </span><span class="koboSpan" id="kobo.337.4">Usually, Terraform should work together with another tool with this focus. </span><span class="koboSpan" id="kobo.337.5">The two of these tools should make a joint decision on how to share the responsibili</span><a id="_idTextAnchor270"/><span class="koboSpan" id="kobo.338.1">ty of deploying </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">this configuration.</span></span></p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor271"/><span class="koboSpan" id="kobo.340.1">Using configuration manager</span></h2>
<p><span class="koboSpan" id="kobo.341.1">One popular </span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.342.1">approach is to leverage Terraform to provision the virtual machines required in your solution and rely on the configuration management tool to handle the rest of the configuration on each virtual machine from the </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">operating system.</span></span></p>
<p><span class="koboSpan" id="kobo.344.1">This approach has the benefit of isolating the responsibility of configuration management</span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.345.1"> entirely to a tool that is fit to handle this task. </span><span class="koboSpan" id="kobo.345.2">Some examples of popular tools include </span><strong class="bold"><span class="koboSpan" id="kobo.346.1">Chef</span></strong><span class="koboSpan" id="kobo.347.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.348.1">Puppet</span></strong><span class="koboSpan" id="kobo.349.1">, which</span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.350.1"> use agents to apply configuration onto virtual machines—or</span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.351.1"> it could be a tool such as </span><strong class="bold"><span class="koboSpan" id="kobo.352.1">Ansible</span></strong><span class="koboSpan" id="kobo.353.1"> that requires no agent and uses SSH as the primary method to </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">apply configuration.</span></span></p>
<p><span class="koboSpan" id="kobo.355.1">Due to Ansible’s heavy reliance on SSH and Windows’s limited support for this remote access method, Ansible has not historically been an ideal candidate for managing Windows-based virtual machines in this manner. </span><span class="koboSpan" id="kobo.355.2">Tools such as Chef and Puppet have seen more robust adoption in enterprise IT environments where Windows Server was the dominant server operating system. </span><span class="koboSpan" id="kobo.355.3">However, this does appear to be changing, with additional support from Ansible and newer versions of Windows making </span><a id="_idTextAnchor272"/><span class="koboSpan" id="kobo.356.1">it easier to manage with </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">this approach.</span></span></p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor273"/><span class="koboSpan" id="kobo.358.1">Custom virtual machine images</span></h2>
<p><span class="koboSpan" id="kobo.359.1">After you</span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.360.1"> have configured your virtual machine to the point that it is ready to take on its role within the system with only some minor final configuration changes, you can capture a snapshot of the operating system disk and create a virtual machine image from it that you can use to spin up additional virtual machines. </span><span class="koboSpan" id="kobo.360.2">When you use this image, these virtual machines will already have the configuration you have set up previously, with no need to set everything </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">up again.</span></span></p>
<p><span class="koboSpan" id="kobo.362.1">This approach has the benefit of increased startup speed. </span><span class="koboSpan" id="kobo.362.2">Since you already did most of the work when you built the image, that work doesn’t have to happen every time you spin up a new virtual machine. </span><span class="koboSpan" id="kobo.362.3">Instead, you will only need to wait for the cloud platform to launch the virtual machine. </span><span class="koboSpan" id="kobo.362.4">It will have everything you need installed and ready to go without waiting for the configuration manager to set </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">everything up.</span></span></p>
<p><span class="koboSpan" id="kobo.364.1">The most common tool used to do this is</span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.365.1"> called </span><strong class="bold"><span class="koboSpan" id="kobo.366.1">Packer</span></strong><span class="koboSpan" id="kobo.367.1">. </span><span class="koboSpan" id="kobo.367.2">It’s an open source product </span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.368.1">published </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">by </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.370.1">HashiCorp</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.372.1">You can write Packer templates in JSON or HCL. </span><span class="koboSpan" id="kobo.372.2">However, you should use the latter, as it makes managing and organizing your code much easier. </span><span class="koboSpan" id="kobo.372.3">A Packer template consists of </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">three parts:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.374.1">Builders that establish connectivity to a target platform to build a </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">virtual machine</span></span></li>
<li><span class="koboSpan" id="kobo.376.1">Provisioners that provide instructions that must be executed on the virtual machine before creating </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">an image</span></span></li>
<li><span class="koboSpan" id="kobo.378.1">Post-processors that execute after the builders and provisioners and perform any last-minute operations before creating </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">the artifact</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.380.1">Packer’s provisioners include three </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">main types:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.382.1">Script execution</span></strong><span class="koboSpan" id="kobo.383.1">: Execute scripts in various shell environments supporting Windows </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">and Linux</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.385.1">File</span></strong><span class="koboSpan" id="kobo.386.1">: Upload files or directories from the local environment to the </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">virtual machine</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.388.1">Flow control</span></strong><span class="koboSpan" id="kobo.389.1">: Pause execution or trigger a W</span><a id="_idTextAnchor274"/><span class="koboSpan" id="kobo.390.1">indows restart to let settings </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">take effect</span></span></li>
</ul>
<h2 id="_idParaDest-109"><a id="_idTextAnchor275"/><span class="koboSpan" id="kobo.392.1">Build versus bake</span></h2>
<p><span class="koboSpan" id="kobo.393.1">Taking a</span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.394.1"> clean installation of the operating system and using a configuration management tool to apply the desired state on it is what I call the </span><em class="italic"><span class="koboSpan" id="kobo.395.1">build</span></em><span class="koboSpan" id="kobo.396.1"> approach. </span><span class="koboSpan" id="kobo.396.2">Its converse, the </span><em class="italic"><span class="koboSpan" id="kobo.397.1">bake</span></em><span class="koboSpan" id="kobo.398.1"> approach, uses an automation tool—such as Packer—that will launch a temporary virtual machine, set everything up, and then snap a new virtual </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">machine image.</span></span></p>
<p><span class="koboSpan" id="kobo.400.1">The build option is ideal for Day 2 Operations because it allows you to easily apply patches and manage the environment over time. </span><span class="koboSpan" id="kobo.400.2">With configuration management tools in charge, you have a live connection to your virtual machines and can update them quickly without disruption. </span><span class="koboSpan" id="kobo.400.3">In contrast, when using the bake approach, you will first need to bake a new image, then upgrade all the virtual machines to use the latest image. </span><span class="koboSpan" id="kobo.400.4">This results in downtime while you tear down the machine using the old image and spin up the machine using the new image. </span><span class="koboSpan" id="kobo.400.5">It can also be a slow process to develop the virtual machine image, as each bake can take a considerable amount of time, while the configuration management tool provides relatively near real-time feedback if there is </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">an issue.</span></span></p>
<p><span class="koboSpan" id="kobo.402.1">The bake approach truly shines when there is time sensitivity in how fast you need to spin up additional virtual machines and you don’t want to wait for the configuration manager to do a clean install of your entire solution stack on the virtual machine, as this uses up valuable time that you could use to service end user requests. </span><span class="koboSpan" id="kobo.402.2">Situations that can benefit from this include </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.404.1">Failover and recovery</span></strong><span class="koboSpan" id="kobo.405.1">: When you have identified that a previously healthy virtual machine has become unhealthy and needs to be replaced rapidly, this situation could be due to an outage or transient </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">hardware failure.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.407.1">Auto-scaling</span></strong><span class="koboSpan" id="kobo.408.1">: When you need to scale up to meet spikes in traffic for your service, it’s ideal for your new virtual machine to pick up the load as quickly as possible when a scale-up event is triggered. </span><span class="koboSpan" id="kobo.408.2">If it does not, you may need to build in additional buffer times by reducing the threshold for scaling up and increasing the threshold for scaling down. </span><span class="koboSpan" id="kobo.408.3">This approach allows the system to spin up resources earlier and spin them down more slowly, ensuring that the inherent time delay doesn’t impact your </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">end users.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.410.1">Build versus bake</span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.411.1"> is not a mutually exclusive endeavor. </span><span class="koboSpan" id="kobo.411.2">There is usually a split between the two. </span><span class="koboSpan" id="kobo.411.3">In most situations, there are pieces of configuration that you can never bake into the images. </span><span class="koboSpan" id="kobo.411.4">These fall into the </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">following categories:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.413.1">Frequency</span></strong><span class="koboSpan" id="kobo.414.1">: You should bake configurations that change into the image at a very low frequency. </span><span class="koboSpan" id="kobo.414.2">Conversely, you should include configurations that you may need to adjust at runtime in </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">the build.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.416.1">Post-provisioning values</span></strong><span class="koboSpan" id="kobo.417.1">: You should bake configurations that require values that are only available after provisioning. </span><span class="koboSpan" id="kobo.417.2">These values might include private IP addresses, DNS hostnames, or other metadata generated during provisioning that is only known at </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">the end.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.419.1">With </span><a id="_idTextAnchor276"/><span class="koboSpan" id="kobo.420.1">that, we’ve come to the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">this chapter.</span></span></p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor277"/><span class="koboSpan" id="kobo.422.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.423.1">This chapter looked at the core concepts required to understand virtual machines across multiple cloud platforms. </span><span class="koboSpan" id="kobo.423.2">In this book, we will build an end-to-end solution using virtual machine architecture for each of the three hyperscalers: AWS, Azure, and Google Cloud Platform. </span><span class="koboSpan" id="kobo.423.3">The providers for each will manifest and exercise these concepts slightly differently. </span><span class="koboSpan" id="kobo.423.4">The resources will change, but the concepts as they manifest in our architecture will be </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">relatively consistent.</span></span></p>
<p><span class="koboSpan" id="kobo.425.1">In this chapter, I have gone over common concepts across cloud platforms that are necessary to understand in order to automate solutions. </span><span class="koboSpan" id="kobo.425.2">These include cloud networking concepts like virtual networks, subnets, peering, and service endpoints, which are essential for creating and managing isolated network environments and ensuring efficient communication between resources. </span><span class="koboSpan" id="kobo.425.3">We also explored computing concepts such as virtual NICs for network connectivity and virtual disks for scalable </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">storage solutions.</span></span></p>
<p><span class="koboSpan" id="kobo.427.1">Another critical topic discussed is the build vs. </span><span class="koboSpan" id="kobo.427.2">bake dilemma, addressing how much operating system configuration should be built into a machine image versus how much should be added after the machine has been provisioned. </span><span class="koboSpan" id="kobo.427.3">This involves understanding the trade-offs between pre-configuring images (baking) to streamline deployment processes and configuring them post-deployment (building) to enhance flexibility and reduce image management complexity. </span><span class="koboSpan" id="kobo.427.4">By understanding these concepts, you will be better equipped to design and automate robust, scalable solutions across different </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">cloud platforms.</span></span></p>
<p><span class="koboSpan" id="kobo.429.1">In the next chapter, we will explore the core concepts needed for a new cloud computing </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">paradigm: </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.431.1">containers</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">.</span></span></p>
</div>
</body></html>