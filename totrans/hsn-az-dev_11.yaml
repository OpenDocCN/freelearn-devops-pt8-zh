- en: Using Azure Storage - Tables, Queues, Files, and Blobs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PaaS in Azure is not only about App Services or containers. This particular
    cloud offers much more, especially when talking about different options for storage,
    messaging solutions, or monitoring. With services such as Event Hub, Azure Storage,
    or Application Insights, we're given a complete set of cloud components that offer
    great flexibility and simplify developing complete, scalable, and easy-to-maintain
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Azure Storage solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing structured data with Azure Storage Tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing fully managed file shares with Azure Storage Files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using queues with Azure Storage Queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Azure Storage Blobs for object storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To perform the exercises in this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An Azure subscription
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio 2017
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Storage Explorer, available at [https://azure.microsoft.com/en-us/features/storage-explorer/](https://azure.microsoft.com/en-us/features/storage-explorer/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Storage Emulator, available at [https://azure.microsoft.com/en-us/downloads/](https://azure.microsoft.com/en-us/downloads/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Azure Storage in a solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most applications cannot work without a storage solution. This can be any kind
    of database—relational, document, file, or graph. Most of them require some skills
    to be able to configure and start working with them. For now, we have covered
    one storage solution available in Azure, namely Azure Cosmos DB, which is a serverless
    database, where the only thing needed was to set a correct throughput value. Of
    course, Azure offers much more in the way of storage services, of which the most
    common is Azure Storage. It is a PaaS cloud component (though some define it as serverless,
    mostly because of a lack of servers) which can be used in four different ways.
    In this chapter, we will cover all of them, so you will be familiar with their
    capabilities and features.
  prefs: []
  type: TYPE_NORMAL
- en: Different Azure Storage services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Azure Storage is consists of four different services:'
  prefs: []
  type: TYPE_NORMAL
- en: Table Storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queue Storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blob Storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They all serve different purposes and offer different capabilities and limits.
    While their names are self-explanatory, you will see that each is a completely
    different service, and though they can be used in connection with each other,
    they require a different set of skills to be able to do this efficiently, and
    you need to use best practices. Additionally, Azure Storage offers an additional
    service called disk storage, which is a feature used by virtual machines. Because
    of that, it will not be covered in this book. Nonetheless, you can find a link
    to documentation in the *Further reading *section.
  prefs: []
  type: TYPE_NORMAL
- en: Different types of storage account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Azure Storage offers three different types of storage account:'
  prefs: []
  type: TYPE_NORMAL
- en: '**General-purpose Standard**: Supporting tables, blobs, files, and queues,
    and three different types of blob: block blobs, page blobs, and append blobs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**General-purpose Premium**: Limited to blobs only, and supporting page blobs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blob storage with hot/cool access tiers**: Limited to blobs only and supporting
    block blobs and append blobs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will learn more about different kinds of blob in the next sections. The
    question, for now, is: what is the difference between the standard and premium accounts—besides
    pricing of course? You can define them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Standard: The most common choice with reasonable performance and support for
    all types of data. These accounts use magnetic disks for storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Premium: Accounts with better performance, thanks to the use of SSD disks—recommended
    for VMs and when you require quick access to data stored on them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you would like to compare performance for both types of accounts, here is
    a comparison for 128 GB disks:'
  prefs: []
  type: TYPE_NORMAL
- en: Standard: 500 I/O operations / sec, throughput 50 MB / sec, €3,78 per month
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Premium: 500 I/O operations / sec, throughput 100 MB / sec, €15,12 per month
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, as you can see, the Premium option offers roughly twice the throughput over Standard.
  prefs: []
  type: TYPE_NORMAL
- en: Securing Azure Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In general, there are two ways of securing access to your Storage Accounts:'
  prefs: []
  type: TYPE_NORMAL
- en: Azure AD with RBAC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SAS tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, blobs can be accessed publicly (of course, only if you decide
    to do so). Depending on your needs, one option or another may cover your requirements—this,
    of course, depends on the characteristics of your application. The following is
    the difference between those two methods of securing Azure Storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '**RBAC**: This method is used to secure management operations on your accounts.
    You can restrict access to specific features of a service to only a specific group
    defined in Azure AD. However, you are unable to use this method to secure a blob
    or a table (although you can do it indirectly by securing access to an SAS token).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SAS tokens**:These are long strings, which store different parameters describing
    access to a resource. They specify a service type, permissions, and the lifetime
    of a token, or restrict access to an IP address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of an SAS token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it restricts access to a `blob.txt`file stored as a blob in the`securecontainer` container.
    It defines parameters, such as service version (`sv`), expiry time (`se`), or
    the actual signature of a token (`sig`).In general, with SAS tokens, you are able
    to restrict access to either an account or a service (and thanks to that also,
    for example, to a range of entities in Table Storage).
  prefs: []
  type: TYPE_NORMAL
- en: Replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When using a cloud, you have to expect that any service can be down at anytime.
    Although Azure Storage is considered one of the most durable services (because
    many services in Azure rely on it), it is possible that it will face an outage.
    To mitigate problems related to such failures, it offers four different kinds
    of replication:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Locally-redundant storage (LRS)**: Three copies of your data within the same
    data center'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zone-redundant storage (ZRS)**: Three copies of your data within the same
    region'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Geo-redundant storage (GRS)**: Three copies of your data within the same
    data center plus three copies in another region'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Read-access geo-redundant storage (RA-GRS)**: Three copies of your data within
    the same data center plus three copies in another region with the ability to read
    from that region'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When architecting an application using Azure Storage, you have to carefully
    design its availability requirements. Depending on your expectations, a different
    model may suit you better.
  prefs: []
  type: TYPE_NORMAL
- en: When using a model that replicates data to another data center (basically GRS
    and RA-GRS), take into account the cost of transferring data between different
    regions.
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder how durable LRS is compared to other replication models. To define
    that, you have to understand how data is stored within a single data center. In
    fact, disks for Azure Storage are installed within racks, which build a bigger
    concept known as a stamp. Stamps are configured in such a way that they use different
    power lines and networks, and thanks to such a setup, it is possible to store
    copies of your data in different fault domains, ensuring that if one fails, the
    other two will still work. Microsoft states that LRS is designed to provide at
    least 99.999999999% durability. If that is not enough, you may consider other
    models.
  prefs: []
  type: TYPE_NORMAL
- en: When using RA-GRS, do not take for granted the ability to easily write to the
    secondary region if an outage occurs. It is Microsoft's responsibility to initiate
    a failover (as opposed to, for instance, Azure Cosmos DB, where it was your decision),
    so **r****ecovery time objective** (**RTO**) consists of both time for Microsoft
    to make a decision, and time to change DNS entries to point to another region.
  prefs: []
  type: TYPE_NORMAL
- en: Storing data with Azure Storage Tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start our journey with Azure Storage capabilities by learning something
    about Table Storage. If you want to store unstructured data with almost limitless
    capacity and with high demands regarding availability and durability, this service
    is for you. In this section, you will learn how to start developing applications
    using Table Storage and the best practices for storing data and achieving the
    best performance for both writing and reading it. You will also see how to efficiently
    query it, and what is important when designing services using this Azure Storage capability.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Azure Storage service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, we have to actually create an instance of Azure Storage. To
    do so, please following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to Azure Portal and click on + Create a resource.Search for `storage account`and
    click on the Create button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see a typical form, where you have to configure a new instance of
    a service. The following is an example of what I chose:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a3843f54-4e7d-423a-aa0e-b724dfe360b5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now I would like to describe some more mystique options available here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deployment model: You can select a different deployment model depending on
    your current requirements. In general, for almost every new storage account, you
    will select Resource manageras the default option. Classic mode is designed for
    legacy deployments, which use classic virtual networks. This choice also limits
    available options when it comes to selecting Account kindand some additional features
    such as Performance tier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Account kind: You have three options available here (general purpose, V1/V2,
    and blob). If you would like to use your storage account with multiple capabilities
    (tables, queues, blobs), select storage. Selecting V2 gives you the possibility
    to define an access tier (cool or hot), which is directly connected to the frequency
    of accessing data stored within an account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Secure transfer required: With Azure Storage it is possible to require a secure
    connection if this option is enabled. Turn it on for your production workloads,
    so no-one will be able to access data stored within an account using, for example,
    HTTP instead of HTTPS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Performance: It is possible to select either the Standard or Premium performance
    tier. As mentioned previously, this impacts hardware used to provision your service
    with common magnetic disks for the Standard tier and SSDs for Premium.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Virtual networks: As in many other services, Azure Storage can be provisioned
    within a virtual network, limiting access to it even more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When everything is set and ready, you can click on the Create button and wait
    a moment—your account will be created and soon you will be able to start working
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Table Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you go to the Overview blade, you will see a dashboard with basic information
    available regarding your account:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c59ccb6-4783-4420-8643-b67536590506.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, it displays the information you defined while creating it,
    such as location, performance tier, or replication type. Additionally, when you
    scroll down, you will see the Monitoring section, where you can see how the whole
    service works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7c6d840-3b9d-485f-90bd-6431d6bbc62f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this section, we are covering Table Storage, so find the Tables blade on
    the left and click on it. Initially, you should see no tables at all—of course,
    this is something we expected as this instance of a service has been just provisioned.
    Nonetheless, this is one of the methods to check what is actually stored within
    an account:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4192d265-7acd-4613-b5d8-2bb2a954734b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To create a new table, simply click on the + Tablebutton—you will be asked
    to provide a table name, which is all that is needed to get started. As you probably
    remember, I described Table Storage as the capability for storing unstructured
    data. This is the reason why there are no other options for starting with a table—you
    simply rely on the internal specification of how this service works. The following
    shows what it looks like when a new container is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e23615b-2b65-4680-b3ee-424c792f4a30.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows an `orders` table and its URL—you may wonder
    what this URL is all about. As there are multiple ways to manage and use Azure
    services, Azure Storage allows you to use its capabilities using different methods,
    such as REST, Powershell, Azure CLI, or Azure Portal. When using SDKs and reading
    their source code, you could find that they are just wrappers around simple a
    REST API. This makes this particular service superbly easy to get started and
    work with on a daily basis. We have talked a little bit about Tables basics—now
    it is time to describe their schema.
  prefs: []
  type: TYPE_NORMAL
- en: Storing data in Table Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each record in Table Storage has a row structure with multiple columns. Each
    row has the following base columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PartitionKey`: Identifier of a partition of a row'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RowKey`: The row''s identifier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Timestamp`: This column tells you when a row was recently modified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ETag`: Table Storage implements the optimistic concurrency model and uses
    ETags to control whether an entity should be modified or not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of course, you are not limited to the columns listed above—you can create any
    additional columns you want and give each a specified type. However, before we
    go any further, you have to fully understand the implications of such a design.
    Here you can find an example of entities stored within a single table:'
  prefs: []
  type: TYPE_NORMAL
- en: '2018-07-13T11:56:11.108Z'
  prefs: []
  type: TYPE_NORMAL
- en: '| `PartitionKey` | `RowKey` | `Timestamp` | `Name` | `Price` | `Created` |
    `CustomerId` | **Quantity** |'
  prefs: []
  type: TYPE_TB
- en: '| Order | 16Hbs6gs8s | 2018-07-13T11:56:11.108Z |  |  | 2018-07-13T11:36:11.108Z
    | customer-001 |  |'
  prefs: []
  type: TYPE_TB
- en: '| 16Hbs6gs8s | 1 | 2018-07-13T11:57:17.108Z | Sponge | 3.00 | 2018-07-13T11:36:11.108Z
    |  | 3 |'
  prefs: []
  type: TYPE_TB
- en: In the preceding example, you data is stored within multiple partitions and
    though a single table is used, multiple schemas still can work, so there is no
    need to use additional containers. Additionally, I used a simple pattern, which
    allows you to introduce 1:n relationship—each order has a unique `RowKey`, which
    can be used as a partition key for entities related to it (allowing for really
    easy querying of data).
  prefs: []
  type: TYPE_NORMAL
- en: PartitionKey
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Table Storage uses partitions to distribute, load, and handle requests. The
    number of partition keys within a table impacts the ability to balance them. It
    is possible to use a single partition per table, but in most cases, this is an
    invalid approach, which will lower the performance of your storage account. Partition
    keys are limited to 1 KB in size and have to be unique within a table (so once
    an entity is assigned a partition key, all others that use the same value will
    be stored in the same storage). They also have to be strings.
  prefs: []
  type: TYPE_NORMAL
- en: RowKey
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each row key is a unique identifier of a row within a partition (so you can
    have rows using the same `RowKey` column value as long they have a different `PartitionKey`).
    More importantly, each table is sorted in ascending using values of row keys.
    This requires a smart design when you need, for example, to read only a selection
    of the top rows and do not want to provide their row keys (we will cover that
    later in this chapter). Like `PartitionKey`, `RowKey` is also limited to 1 KB
    and has to be a string.
  prefs: []
  type: TYPE_NORMAL
- en: Timestamp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This column is maintained server-side and is a `DateTime` value that is changed
    each time an entity is modified. It is also internally used to provide optimistic
    concurrency, and cannot be modified. Even if you set it, the value will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: General rules for entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Table Storage has some hard limitations when it comes to storing data:'
  prefs: []
  type: TYPE_NORMAL
- en: The maximum number of columns is 255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The maximum size of an entity is 1 MB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, each entity column is created as a type string—this can be overridden
    when it is created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not possible to store null as a value—if you do not provide a column value,
    an entity will be considered as if it does not have it at all
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying data in Table Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To query data in Table Storage, you will need a simple application (it can be
    a console application) and an SDK for this service. You will also need an instance
    of Azure Storage—it can be either the one provisioned in Azure, or a local one,
    if you installed Storage Emulator.
  prefs: []
  type: TYPE_NORMAL
- en: To get started with Storage Emulator, simply search for an executable (for example, Start
    | type `Storage Emulator`) and run it. It will initially create a database for
    storing data and run in the background, so you will not have to worry about accidentally
    closing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, we have to install the `WindowsAzure.Storage` package using
    NuGet Package Manager. It has everything that is needed to start working with Azure
    Storage in .NET. Here you can find an example of code for creating a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can briefly describe what this code does:'
  prefs: []
  type: TYPE_NORMAL
- en: It parses a connection string so it can be used in the following methods
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It creates an instance of `CloudTableClient`class, which is the main class for
    working with Table Storage
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It gets a reference to a table `order`, whether it exists or not
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, it creates an `orders` table, if does not exist already
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You could also use the `Create()`method instead of `CreateIfNotExists()`, although,
    it could break if a table has been already created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to get a connection string, so depending on the storage account
    you would like to use you either:'
  prefs: []
  type: TYPE_NORMAL
- en: Have to go to Azure Portal, find your storage account, and copy a connection
    string from Access keysblade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `UseDevelopmentStorage=true`value for connecting with Storage Emulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you execute an application, a table should be created without a problem.
    Now, when we have a table, we would like to actually insert something in it. To
    do so, you will need the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here we are creating a new `TableOperation`, which accepts one argument that
    is an instance of `TableEntity`. `TableEntity` is a base class that contains all
    row properties, and has to be passed to a table (like `PartitionKey` or `RowKey`).
    Of course, instead of using `DynamicTableEntity`, you can derive from `TableEntity`and
    introduce a custom entity class.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we used the `Insert()`operation, which may not be
    the best choice for concurrent requests. In such a scenario, it is sometimes better
    to use `InsertOrReplace()`or `InsertOrMerge()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing to do is to query a table. To do so in .NET, you will need something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We just executed a basic query, which will return all rows from a table. While
    it works now, it is not the best idea to query all data within a table using such
    a query—in most cases, you will use something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding query will return all rows in a table that have an `orders` partition
    key. Such queries can be extended as you wish by generating further filter conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that to achieve the best performance, your queries should include both
    `PartitionKey` and `RowKey`. Using `PartitionKey` only leads to worse results,
    but is still acceptable. Using only `RowKey` will result in reading the whole
    partition anyway. Not using those columns will result in reading the whole table.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also check what is stored in a table using Azure Storage Explorer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3480ecc7-bd3c-4579-9a09-89352ee0fc39.png)'
  prefs: []
  type: TYPE_IMG
- en: Table API in Azure Cosmos DB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible to leverage the premium offering for Table Storage using Azure
    Cosmos DB. Using that option has the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Automatic and manual failovers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondary indexes (the ability to index against all properties inside a row).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Independent scaling across multiple regions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different consistency levels.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dedicated throughput per table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While failover can be achieved using Table Storage only, the rest of the presented
    features are available only for Azure Cosmos DB, and can be a great solution when
    you like the simplicity of this service and still want to challenge it against
    more complicated scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing fully managed file shares with Azure Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When in need of creating a file share, which can be accessed by different people,
    you often have to either buy some hardware, which will be set up and configured
    for such functionality, or use third-party solutions, which can be hard to customize,
    or expensive. With Azure Storage, you can quickly develop a solution that is almost
    limitless in terms of capacity, offers industry standard protocols, and can be
    quickly provisioned, and ready to use.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Files concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Azure Files has some basic concepts that create the whole picture of a service.
    In fact, it is designed to replace current on-premise file servers in terms of
    functionality and performance. The main difference between Azure Files and the
    "old" solution is accessibility (as you can set the access token and make the
    URL private). What is more, it is OS-agnostic, allowing you to use the very same
    file share mounted on different machines using Linux, Windows, or macOS. It, of
    course, shares other Azure Storage concepts, so you can use it with the same reliability
    and durability assurance. The main feature of Azure Files is support for the SMB
    protocol. This is a very common protocol (and a mature one, as it was designed
    in the mid-1980s) for sharing computer resources, and used also for printers,
    and other network devices. We could summarize Azure Files as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fully managed**: This is a full cloud service, where you do not have to worry
    about the OS or its configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Durability ****and resiliency**: With Azure Files you do not have to worry
    about not having access to data stored and securing your resources against power
    failures, and other outages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Common dev tools**: Accessing Azure Files is easy, thanks to the system I/O
    APIs, appropriate SDKs, or even REST APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Azure Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you go to Azure Portal and open your Azure Storage instance, you can find
    the Files blade. It is very similar to the one that will be discussed for Blob
    Storage. It displays a list of available file shares, as seen in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4d8165d-ecc6-4010-8cb5-97b5386923ba.png)'
  prefs: []
  type: TYPE_IMG
- en: From this screen, you have the ability to create a new one by clicking on the +
    File sharebutton. The important thing here is the value of the Quota field—it
    determines the maximum capacity of a file share.
  prefs: []
  type: TYPE_NORMAL
- en: The maximum value for the quota of a file share is 5,120 GB.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get information about how to connect to a file share, you can click on the
    more button on the right and select Connect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef04fe98-5092-4c54-9679-888d21ea26e5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It will display some short instructions about how it is possible to quickly
    connect from your computer to a specific file share. Here you can find an example
    of a command for Windows written in PowerShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can specify the letter of a drive using the `-Name`parameter (in the preceding
    example it is `Z`).
  prefs: []
  type: TYPE_NORMAL
- en: Mapping a drive is an operation that may require additional permissions—make
    sure you are running all these commands as an administrator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now I can compare the contents of my file share displayed in Azure portal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6487b6f-934d-4d69-b010-676d194e71a7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With my mounted disk on a virtual machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/695b1b20-a5df-42a2-b0e5-3ab4ecee9f02.png)'
  prefs: []
  type: TYPE_IMG
- en: The whole setup took only a few minutes—this is the strength of this service,
    as normally I would need many hours to set everything up and achieve the same
    level of portability and reliability. It also gives you unlimited storage capacity—nothing
    blocks you from attaching multiple Azure Files shares and storing all your files
    on them.
  prefs: []
  type: TYPE_NORMAL
- en: Blob Storage versus Azure Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In fact, both Azure Blob Storage and Azure Files have a similar purpose—you
    create them to store and share files. There are, however, some fundamental differences
    between them when it comes to use cases, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to create a common file share space for your company, you will use
    Azure Files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to have a space for files uploaded by your users via, for example,
    your website, you will use Blob Storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to have your files completely private, you will use Azure Files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to configure security on a blob or a containers level, you will
    use Blob Storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both services also have different pricing models (for example, Azure Files is
    much more expensive when it comes to paying for each GB of data).
  prefs: []
  type: TYPE_NORMAL
- en: Queues in Azure Queue Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Storage—besides being a service for storing many different kinds of data—can
    be used also as a queue. Queue Storage is another capability that allows you to
    quickly develop a solution that requires a simple queue solution, and additionally
    is able to store in a queue millions of messages without affecting performance.
    In this section, you will see how to develop applications using Queue Storage
    and what is important when using this feature. Additionally, I assume that you
    already have a storage account. If not, take a look at the **Storing data with
    Azure Storage Tables **section, where I described the process of creating an account.
  prefs: []
  type: TYPE_NORMAL
- en: Queue Storage features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In general, Queue Storage has two use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Processing messages asynchronously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exchanging communications between different services (Azure Functions, legacy
    Web roles/Worker roles)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a very simple queue solution, which can store and process messages in
    any format that are limited to 64 KB. The retention time of a message is seven
    days—after that, it is lost. The capacity of a queue is basically equal to the
    capacity of your storage account. In general, you should not worry that you will
    run out of available space. Queue Storage shares many addition features, such
    as virtual networks, SAS tokens, and many more, with other Azure Storage capabilities.
    Therefore, we will not reintroduce them in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Developing an application using Queue Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the purpose of presenting Queue Storage, I created two applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Producer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consumer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Producer will create and push messages, which will then be consumed by Consumer.
    Here you can find the code of the `Producer`app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And, of course the `Consumer` app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When you publish a message to a queue, you can retrieve it at any time—as mentioned
    previously, you have seven days to fetch it from a queue. Here you can find how
    a message looks like when stored in a queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0dba0131-21e1-425d-952a-e4c890c5919c.png)'
  prefs: []
  type: TYPE_IMG
- en: Object storage solution – Azure Storage Blobs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last capability of Azure Storage is Blob Storage. In the previous sections,
    we were using this service to store unstructured data using Table Storage, push
    messages to a queue with Queue Storage, and create file shares, thanks to File
    Storage. In the last section of this chapter, we will focus on developing solutions
    that store so-called blobs. You may wonder what exactly a blob is—well, there
    is no single definition for that. In general. blobs are files of different types,
    such as text files, images, or audio. You will see how to use them in your applications,
    how to secure them, and how you can achieve the maximum performance.
  prefs: []
  type: TYPE_NORMAL
- en: Blob Storage concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we go deeper into the service, you will have to understand the basic
    concepts of Blob Storage. Here you can find a diagram that clearly defines three
    main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91943c42-c9e8-41ea-aca9-fd880be20ff3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we have three different concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Account**: Which is basically your Storage Account and stores all data within
    a Blob Storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container**: Which is a logical entity holding an unlimited amount of blobs
    inside it. An account can have an unlimited amount of containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blob**: A file stored within a container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, there are three different types of blob:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Block blob**: Text or binary data with a maximum size of 4.7 TB. Such a blob
    is made of smaller blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Append blobs**: A more specific type of blob, which is the best for scenarios
    such as logging data, or storing events or transactional logs. They are optimized
    for append operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Page blobs**: Designed for storing VHD files used by VMs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the newest version of Storage Accounts (v2), it is possible to use the
    latest features of this service. One of the most interesting additions is access
    tiers. Now it is possible to select whether you would like to use a hot or cool tier.
    The choice depends on the frequency of accessing your data—if you would like to
    read it often, hot will be the best choice, otherwise, it is better to use the
    cool tier or a general-purpose account.
  prefs: []
  type: TYPE_NORMAL
- en: The tiers aforementioned are available when you select Blob as your storage
    account type. They are not available for general-purpose accounts.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also one more tier; Archive—designed for storing blobs that are rarely
    accessed—although it is available only on the blob level. You probably wonder
    about the differences between these tiers. Here you can find a table that defines
    their pricing:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Hot** | **Archive** | **Cool** |'
  prefs: []
  type: TYPE_TB
- en: '| First 50 TB/month | $0.0184 per GB | $0.01 per GB | $0.002 per GB |'
  prefs: []
  type: TYPE_TB
- en: '| Next 450 TB/month | $0.0177 per GB | $0.01 per GB | $0.002 per GB |'
  prefs: []
  type: TYPE_TB
- en: '| Over 500 TB/month | $0.017 per GB | $0.01 per GB | $0.002 per GB |'
  prefs: []
  type: TYPE_TB
- en: 'In terms of storage, you can see that the hottier is the most expensive and
    the rest are much cheaper, especially archive. Now let us check the price for
    10,000 read operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hot**: $0.004'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cool**: $0.01'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Archive**: $5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ouch—the difference is huge here! This is why selecting the correct tier is
    so important—you may end up with a solution that costs many, many dollars, only
    because you misused the Blob Storage tier.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting data into Blob Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we will try to actually add something to our Blob Storage. Here you can
    find a piece of code that allows you to upload a single file to a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As in the previous examples, this one looks pretty similar. You will need to
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly you have to create an instance of `CloudStorageAccount`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then you need to obtain a reference to a container, and create it if it does
    not exist
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, you have to get a reference to a blob, and upload some contents
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If I open Azure Storage Explorer, I can see that a new blob was uploaded to
    a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/984feda9-76bc-48c1-b707-84ca85263ea0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Of course, if I open the file, I will see that it contains the text that I
    uploaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c88f981d-9174-4377-ac5c-80d51ebc730c.png)'
  prefs: []
  type: TYPE_IMG
- en: Containers and permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible to select a proper access level when it comes to accessing a
    container stored within Blob Storage. If you go to Azure Portal and open your
    Azure Storage service, you can find the Blobs blade. Inside it, you can click
    on the + Containerbutton, which will open a small window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/081f7f18-611f-4311-a615-42f8d9025b0a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, besides providing a name for a container, you can select Public
    access level. Currently, you have three different options available:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Private: For no anonymous access'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blob: Anonymous access on a blob level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container: Anonymous access on a container level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can click on a container you created to see another screen, where you can
    manage it. I will use it to actually upload a file to see what other options become
    available. Here you can find what it will look in the portal when a file is uploaded
    and I click on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45bd6c11-2d52-4c9e-8842-a556438b9df2.png)'
  prefs: []
  type: TYPE_IMG
- en: Now I can see additional metadata regarding a file, manage like acquiring leases,
    or generate an SAS token.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to make a file read-only, click on the Acquire leasebutton—while
    it will still be possible to change it, such an action will require providing
    a lease ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is more, there is a URL property available, which can be used to access
    a blob directly, for example, using a browser. Here you can find how it looks
    like in my case:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://handsonazurestore.blob.core.windows.net/blob/11047_01_01.PNG`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you may wonder what the difference is between Blob and Container access.
    To find out, we will use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'I already created two different containers—one with Blob access, one with Container.
    If I execute the preceding code for a container with full public access, the following
    is what I will see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/36fd3500-e727-4b41-9f2f-6c6f26bd4c53.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let us run it for a container, which has public access for blobs only:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6135bf3-10fe-4ad2-b5ae-202df734164a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, container-level operations are unavailable when its access
    level is blob or private. Of course, if you authorize using, for instance, an
    access key, you will list all blobs within a container, even if it is private.
    Of course, it is also possible to set a container-level permission directly from
    your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Blob Storage: additional features'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the newest and coolest features of Blob Storage is the Soft deletefeature.
    It allows you to perform an operation called a soft delete. What does this mean?
    In some cases, you may want to delete a file, but have the ability to easily revert
    the deletion within a fixed time period. In Blob Storage, that option is available
    via the Soft deleteblade:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea110677-c180-478e-9e60-f086e5ce6dbf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you turn it on, any deleted blob will still be available within storage
    (but not for retrieval or modification) for a set number of days. Blob Storage also has
    two additional features, which can be used with two other Azure services:'
  prefs: []
  type: TYPE_NORMAL
- en: Azure CDN: A Content Delivery Network service for serving static content to
    your customers—we will cover this later in the book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Search: As already discussed, here you can easily set your Blob Storage
    as a data source for a search engine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So as you can see, this is a very flexible and useful Azure Storage capability, which
    can be used for file storage, as an Azure Search document store, a logs database,
    and much, much more.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned some basics regarding one of the most important
    services in Azure—Azure Storage. We developed a few solutions for Tables, Queues,
    Files, and Blobs—each enabling you to do different things, from asynchronous message
    processing to creating file shares. You also read about different redundancy models
    and how reliable and durable this particular service is. In the *Further reading*section,
    you will find plenty of additional resources, which will allow you to build even
    more skills for working with this Azure service, such as Table Storage patterns,
    performance targets, and a REST API reference. In the following chapters, you
    will learn something about data processing services, such as Azure Event Hub and Azure
    Stream Analytics.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What tiers are available during account creation when selecting Blob as an account
    type?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What must you include in a query against Table Storage to achieve the maximum
    performance?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the available redundancy models for storage accounts?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between blob and file storage?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you store binary files using Blob Storage?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How long does a message in Queue Storage live before it is removed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the maximum size of a message in Queue Storage?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the maximum size of the `PartitionKey` column value?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What concurrency model is implemented in Table Storage?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between Azure Files storage and on-premise filesystem?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Disk storage: [https://docs.microsoft.com/en-us/azure/virtual-machines/windows/about-disks-and-vhds](https://docs.microsoft.com/en-us/azure/virtual-machines/windows/about-disks-and-vhds)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SAS token reference: [https://docs.microsoft.com/en-us/azure/storage/common/storage-dotnet-shared-access-signature-part-1](https://docs.microsoft.com/en-us/azure/storage/common/storage-dotnet-shared-access-signature-part-1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ARM vs classic deployment: [https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-deployment-model](https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-deployment-model)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Table Storage data model: [https://docs.microsoft.com/en-us/rest/api/storageservices/Understanding-the-Table-Service-Data-Model](https://docs.microsoft.com/en-us/rest/api/storageservices/Understanding-the-Table-Service-Data-Model)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blob Storage pricing: [https://azure.microsoft.com/en-us/pricing/details/storage/blobs/](https://azure.microsoft.com/en-us/pricing/details/storage/blobs/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File Storage performance targets: [https://docs.microsoft.com/en-us/azure/storage/files/storage-files-scale-targets](https://docs.microsoft.com/en-us/azure/storage/files/storage-files-scale-targets)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guidelines for Table Storage: [https://docs.microsoft.com/en-us/azure/storage/tables/table-storage-design-guidelines](https://docs.microsoft.com/en-us/azure/storage/tables/table-storage-design-guidelines)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
