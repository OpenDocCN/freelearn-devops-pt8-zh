<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Working with Docker"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Working with Docker</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Docker usage overview</li><li class="listitem" style="list-style-type: disc">Choosing the right Docker base image</li><li class="listitem" style="list-style-type: disc">Optimizing the Docker image size</li><li class="listitem" style="list-style-type: disc">Versioning Docker images with tags</li><li class="listitem" style="list-style-type: disc">Deploying a Ruby-on-Rails web application in Docker</li><li class="listitem" style="list-style-type: disc">Building and using Golang applications with Docker</li><li class="listitem" style="list-style-type: disc">Networking with Docker</li><li class="listitem" style="list-style-type: disc">Creating more dynamic containers</li><li class="listitem" style="list-style-type: disc">Auto-configuring dynamic containers</li><li class="listitem" style="list-style-type: disc">Better security with unprivileged users</li><li class="listitem" style="list-style-type: disc">Orchestrating with Docker Compose</li><li class="listitem" style="list-style-type: disc">Linting a Dockerfile</li><li class="listitem" style="list-style-type: disc">Deploying a private Docker registry with S3 storage</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec95"/>Introduction</h1></div></div></div><p>In this chapter, we'll discover the best bits of using Docker in a development environment: from Docker image optimizations to versioning, security, and networking, tips on how to choose the right base Docker image and how to make them dynamic and self-configurable, and how to leverage Docker to cross-compile Go programs or deploy Ruby-on-Rails web applications. Still with a focus on developers and achieving the highest code quality possible, we'll spend some time linting our code, and finally deploy our own Docker Registry to store our own images internally—both on local storage and on AWS S3 for infinite space.</p></div></div>
<div class="section" title="Docker usage overview"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec96"/>Docker usage overview</h1></div></div></div><p>This section is an introduction to Docker for newcomers, and can be used as a refresher for others. We'll see how to quickly use Docker to achieve some tasks such as executing an Ubuntu container or networked webserver, sharing data with a container, building an image, and accessing a registry other than the default one.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec246"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need a working Docker installation.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec247"/>How to do it…</h2></div></div></div><p>We'll quickly manipulate Docker, so we're up and running with some basic usage.</p><div class="section" title="Running Bash in an Ubuntu 16.04 container"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec190"/>Running Bash in an Ubuntu 16.04 container</h3></div></div></div><p>To execute <code class="literal">/bin/bash</code> in an Ubuntu container, tag 16.04 (<code class="literal">ubuntu:16.04</code>). Our environment <a id="id976" class="indexterm"/>will be interactive (use <code class="literal">-i</code>) and we want a pseudo-terminal to be allocated (use <code class="literal">-t</code>). We want the container to be <a id="id977" class="indexterm"/>destroyed afterwards (use <code class="literal">--rm</code>):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker run -it --rm ubuntu:16.04 /bin/bash</strong></span>
<span class="strong"><strong>root@d372dba0ab90:/# hostname</strong></span>
<span class="strong"><strong>d372dba0ab90</strong></span>
</pre></div><p>We've run our first container! Now do whatever you want with it. Quitting it destroys it and its content is lost forever as we specified the <code class="literal">--rm</code> option.</p></div><div class="section" title="Running Nginx in a container"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec191"/>Running Nginx in a container</h3></div></div></div><p>Nginx is <a id="id978" class="indexterm"/>officially packaged as a Docker container. We want to access port <code class="literal">80</code> from the container on port <code class="literal">80</code> of our host using the <code class="literal">-p</code> option, with the latest Nginx version available:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker run --rm -p 80:80 nginx</strong></span>
</pre></div><p>Make some HTTP requests such as a <code class="literal">curl</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl -IL http://localhost</strong></span>
<span class="strong"><strong>HTTP/1.1 200 OK</strong></span>
<span class="strong"><strong>Server: nginx/1.11.5</strong></span>
<span class="strong"><strong>[…]</strong></span>
</pre></div><p>The logs on the Docker stdout are displaying the logs as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>172.17.0.1 - - [21/Nov/2016:21:21:15 +0000] "HEAD / HTTP/1.1" 200 0 "-" "curl/7.43.0" "-"</strong></span>
</pre></div><p>Maybe for some reason we need to launch a specific Nginx version, like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker run --rm -p 80:80 nginx:1.10</strong></span>
</pre></div><p>The <a id="id979" class="indexterm"/>HTTP headers will reflect that we're now running the current stable version:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl -IL http://localhost</strong></span>
<span class="strong"><strong>HTTP/1.1 200 OK</strong></span>
<span class="strong"><strong>Server: nginx/1.10.2</strong></span>
</pre></div></div><div class="section" title="Sharing data with a container"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec192"/>Sharing data with a container</h3></div></div></div><p>We want <a id="id980" class="indexterm"/>our own content to be displayed instead of the default Nginx page. Let's create an <code class="literal">index.html</code> file in the <code class="literal">www</code> directory, with some custom content such as the following:</p><div class="informalexample"><pre class="programlisting">&lt;html&gt;
  &lt;h1&gt;Hello from Docker!&lt;/h1&gt;
&lt;/html&gt;</pre></div><p>Nginx is serving content by default in <code class="literal">/usr/share/nginx/html</code>; let's use the <code class="literal">-v</code> option to share our own directory with the container:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker run --rm -p 80:80 -v ${PWD}/www:/usr/share/nginx/html nginx:1.10</strong></span>
</pre></div><p>Let's see our new content served:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl -L http://localhost</strong></span>
<span class="strong"><strong>&lt;html&gt;</strong></span>
<span class="strong"><strong>  &lt;h1&gt;Hello from Docker!&lt;/h1&gt;</strong></span>
<span class="strong"><strong>&lt;/html&gt;</strong></span>
</pre></div></div><div class="section" title="Building a container with utilities"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec193"/>Building a container with utilities</h3></div></div></div><p>Let's create <a id="id981" class="indexterm"/>our own Ubuntu 16.04 image with some utilities such as <code class="literal">curl</code>, <code class="literal">dig</code>, and <code class="literal">netcat</code> in it, so that whatever machine we're using, we can always have our tools at hand. To build our container, we need a file named <code class="literal">Dockerfile</code>, acting like a script, executed line by line, to build the final container. We know we want to start from an Ubuntu 16.04, then update the APT base, and finally install our utilities. Let's do just that using the <code class="literal">FROM</code> and <code class="literal">RUN</code> instructions:</p><div class="informalexample"><pre class="programlisting">FROM ubuntu:16.04
RUN apt-get -yq update
RUN apt-get install -yq dnsutils curl netcat</pre></div><p>Now build using the <code class="literal">docker build</code> command, passing it the name of the container with the <code class="literal">-t</code> option:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker build -t utils .</strong></span>
<span class="strong"><strong>Step 1 : FROM ubuntu:16.04</strong></span>
<span class="strong"><strong> ---&gt; 2fa927b5cdd3</strong></span>
<span class="strong"><strong>Step 2 : RUN apt-get update -yq</strong></span>
<span class="strong"><strong> ---&gt; Running in 0d8f8e01bde8</strong></span>
<span class="strong"><strong>[...]</strong></span>
<span class="strong"><strong>Step 3 : RUN apt-get install ruby -yq</strong></span>
<span class="strong"><strong> ---&gt; Running in 425bfb1e8ee1</strong></span>
<span class="strong"><strong>[...]</strong></span>
<span class="strong"><strong>Removing intermediate container 425bfb1e8ee1</strong></span>
<span class="strong"><strong>Successfully built c86310e48731</strong></span>
</pre></div><p>We can <a id="id982" class="indexterm"/>see each line of our <code class="literal">Dockerfile</code> is a <span class="emphasis"><em>step</em></span> in the build process, each step being a container itself (hence the different ID each time).</p><p>Let's now execute our container to make a DNS request using <code class="literal">dig</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker run -it --rm utils dig +short google.com</strong></span>
<span class="strong"><strong>172.217.5.14</strong></span>
</pre></div><p>Alternatively, we may use <code class="literal">curl</code> as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker run -it --rm utils curl -I google.com</strong></span>
<span class="strong"><strong>HTTP/1.1 302 Found</strong></span>
<span class="strong"><strong>Cache-Control: private</strong></span>
<span class="strong"><strong>Content-Type: text/html; charset=UTF-8</strong></span>
<span class="strong"><strong>Location: http://www.google.ca/?gfe_rd=cr&amp;ei=UgA1VMLPRUvF9gfJ_riACg</strong></span>
<span class="strong"><strong>Content-Length: 258</strong></span>
<span class="strong"><strong>Date: Wed, 23 Nov 2016 02:34:58 GMT</strong></span>
</pre></div></div><div class="section" title="Using a private registry"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec194"/>Using a private registry</h3></div></div></div><p>When not <a id="id983" class="indexterm"/>specifying anything else than the container name, Docker <a id="id984" class="indexterm"/>is looking for it locally, then on Docker Hub (<a class="ulink" href="https://hub.docker.com">https://hub.docker.com</a>). However, we can run our own registry or use an alternative registry such as <a class="ulink" href="https://quay.io/">https://quay.io/</a>. Here's how it works: instead of specifying only the container name, or the combo <code class="literal">username/container_name</code>, we prefix both by the DNS name of the registry, for example, <a class="ulink" href="https://quay.io/">https://quay.io/</a>. Here, we'll launch the HTTP/2 Caddy webserver hosted in the CoreOS account on the Quay.io registry:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker run -it --rm -p 80:2015 quay.io/coreos/caddy</strong></span>
<span class="strong"><strong>Activating privacy features... done.</strong></span>
<span class="strong"><strong>http://0.0.0.0:2015</strong></span>
</pre></div><p>Here's for this quick introduction on how to use Docker.</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec248"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Docker <a id="id985" class="indexterm"/>run reference: <a class="ulink" href="https://docs.docker.com/engine/reference/run/">https://docs.docker.com/engine/reference/run/</a></li><li class="listitem" style="list-style-type: disc">Dockerfile <a id="id986" class="indexterm"/>reference: <a class="ulink" href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></li><li class="listitem" style="list-style-type: disc">Quay.io <a id="id987" class="indexterm"/>alternative registry: <a class="ulink" href="https://quay.io/">https://quay.io/</a></li><li class="listitem" style="list-style-type: disc">Docker Hub: <a class="ulink" href="https://hub.docker.com/">https://hub.docker.com/</a></li><li class="listitem" style="list-style-type: disc">Docker <a id="id988" class="indexterm"/>Store: <a class="ulink" href="https://store.docker.com/">https://store.docker.com/</a></li></ul></div></div></div>
<div class="section" title="Choosing the right Docker base image"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec97"/>Choosing the right Docker base image</h1></div></div></div><p>Depending <a id="id989" class="indexterm"/>on our end goal, using the image of our favorite Linux distribution might or might not be the best solution. Starting with a full CentOS container image might be a waste of resources, while an Alpine Linux image might not contain the most complete libc for our usage. In other cases, using the image from our favorite programming language might also be a good idea, or not. Let's see this in depth and learn when to choose what source.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec249"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need a working Docker installation.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec250"/>How to do it…</h2></div></div></div><p>Most common distributions are available as a container form.</p><div class="section" title="Starting from an Ubuntu image"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec195"/>Starting from an Ubuntu image</h3></div></div></div><p>Ubuntu ships <a id="id990" class="indexterm"/>official images that are all tagged with both their release version and name: <code class="literal">ubuntu:16.04</code> is equivalent to <code class="literal">ubuntu:xenial</code>. At the time of writing, the supported Ubuntu releases are 12.04 (precise), 14.04 (trusty), 16.04 (xenial), and 16.10 (yakkety).</p><p>To start with an Ubuntu image in a Dockerfile, execute the following:</p><div class="informalexample"><pre class="programlisting">FROM ubuntu:16.04
ENTRYPOINT ["/bin/bash"]</pre></div></div><div class="section" title="Starting from a CentOS image"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec196"/>Starting from a CentOS image</h3></div></div></div><p>The CentOS <a id="id991" class="indexterm"/>team ships official container images, all tagged with versions. It's highly recommended that you stick with the <span class="emphasis"><em>rolling builds</em></span> that are continuously updated because these are tagged only with major versions such as <code class="literal">centos:7</code>. At the time of writing, the supported CentOS releases are CentOS 7, 6, and 5. If for some compliance reason we were to use a specific CentOS 7 release, specific tags such as <code class="literal">centos:7.3.1611</code>, <code class="literal">centos:7.2.1511</code>, <code class="literal">centos:7.1.1503</code>, and <code class="literal">centos:7.0.1406</code> are available.</p><p>To start <a id="id992" class="indexterm"/>with the latest CentOS 7 available, in a Dockerfile execute the following:</p><div class="informalexample"><pre class="programlisting">FROM centos:7
ENTRYPOINT ["/bin/bash"]</pre></div></div><div class="section" title="Starting from a Red Hat Enterprise Linux (RHEL) image"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec197"/>Starting from a Red Hat Enterprise Linux (RHEL) image</h3></div></div></div><p>Red Hat <a id="id993" class="indexterm"/>also ships containers for RHEL. At the time of writing, images are hosted on Red Hat's Docker registry servers (<a class="ulink" href="https://access.redhat.com/containers/">https://access.redhat.com/containers/</a>). These images aren't tagged with <a id="id994" class="indexterm"/>release versions, but directly with their name: <code class="literal">rhel7</code> for RHEL 7 and <code class="literal">rhel6</code> for RHEL 6. Similarly, subversions are also directly in the name of the image: RHEL 7.3 has the image named <code class="literal">rhel7.3</code>.</p><p>To start with the latest RHEL 7, in a Dockerfile execute the following:</p><div class="informalexample"><pre class="programlisting">FROM registry.access.redhat.com/rhel7
ENTRYPOINT ["/bin/bash"]</pre></div></div><div class="section" title="Starting from a Fedora image"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec198"/>Starting from a Fedora image</h3></div></div></div><p>Fedora is <a id="id995" class="indexterm"/>officially built for Docker and each release is simply tagged with its version number. Fedora 25 has <code class="literal">fedora:25</code>, and it goes back to <code class="literal">fedora:20</code> at the time of writing.</p><p>To start a with the latest Fedora release, use the following in a Dockerfile:</p><div class="informalexample"><pre class="programlisting">FROM fedora:latest
ENTRYPOINT ["/bin/bash"]</pre></div></div><div class="section" title="Starting from an Alpine Linux image"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec199"/>Starting from an Alpine Linux image</h3></div></div></div><p>Alpine <a id="id996" class="indexterm"/>Linux is a very popular and secure lightweight Linux distribution in the container world. It's dozens of times smaller in size than other main distributions: less than 5 MB. It became so popular that Docker (the company) is now using it as a base for all its official images—and the Alpine founder is now working at Docker. Alpine versions are found in the image tags: Alpine 3.1 is <code class="literal">alpine:3.1</code>, and similarly, Alpine 3.4 is <code class="literal">alpine:3.4</code>.</p><p>To start with the 3.4 release of Alpine Linux, use this in a Dockerfile:</p><div class="informalexample"><pre class="programlisting">FROM alpine:3.4
ENTRYPOINT ["/bin/sh"]</pre></div></div><div class="section" title="Starting from a Debian image"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec200"/>Starting from a Debian image</h3></div></div></div><p>The Debian <a id="id997" class="indexterm"/>distribution is present as well, with many different tags: we can find the usual <code class="literal">debian:stable</code>, <code class="literal">debian:unstable</code>, and <code class="literal">debian:sid</code> we're used to, and also some other tags, such as <code class="literal">debian:oldstable</code>. Release names are tagged like the corresponding versions, so the image <code class="literal">debian:8</code> is the same as <code class="literal">debian:jessie</code>. Debian ships <span class="emphasis"><em>slim</em></span> images for each release: debian:jessie-slim is 30% smaller than the main one (80 MB compared to 126 MB at the time of writing).</p><p>To start with the Debian 8 (Jessie) release, use the following in a Dockerfile:</p><div class="informalexample"><pre class="programlisting">FROM debian:jessie
ENTRYPOINT ["/bin/bash"]</pre></div></div><div class="section" title="Linux distributions container image size table"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec201"/>Linux distributions container image size table</h3></div></div></div><p>Here's a <a id="id998" class="indexterm"/>table with the current size for each referenced image:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Linux distribution image</p>
</th><th style="text-align: left" valign="bottom">
<p>Size</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Alpine 3.4</p>
</td><td style="text-align: left" valign="top">
<p>4.799 MB</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Debian 8 (slim)</p>
</td><td style="text-align: left" valign="top">
<p>80 MB</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Debian 8</p>
</td><td style="text-align: left" valign="top">
<p>123 MB</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Ubuntu 16.04</p>
</td><td style="text-align: left" valign="top">
<p>126.6 MB</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>RHEL 7.3</p>
</td><td style="text-align: left" valign="top">
<p>192.5 MB</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>CentOS 7.3 </p>
</td><td style="text-align: left" valign="top">
<p>191.8 MB</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Fedora 25</p>
</td><td style="text-align: left" valign="top">
<p>199.9 MB</p>
</td></tr></tbody></table></div><p>With this information in hand, we can now decide to go for any one of these.</p><p>That being said, many popular programming languages (Go, Node, Java, Python, Ruby, PHP, and more) are also shipping their own container images. They are all very often based on the images from the operating system container images in the preceding table. It will be interesting to use them if our product is definitely going to use the corresponding language as they often offer custom versions and features.</p></div><div class="section" title="Starting from a Node JS image"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec202"/>Starting from a Node JS image</h3></div></div></div><p>The official <a id="id999" class="indexterm"/>repository for the Node Docker image includes many tagged versions with many base images: <code class="literal">node:7</code> is based on Debian Jessie, while <code class="literal">node:7-alpine</code> is based on Alpine 3.4. <code class="literal">node:7-slim</code> will be based on the slim Debian Jessie, and there's even <code class="literal">node:7-wheezy</code> if we feel like running Node 7 on Debian Wheezy. Also available are Node 6, 4, and below.</p><p>To start <a id="id1000" class="indexterm"/>from the latest Node 7 image version, use this in a Dockerfile:</p><div class="informalexample"><pre class="programlisting">FROM node:7
ENTRYPOINT ["/bin/bash"]</pre></div><p>For the record, a <code class="literal">node:7</code> image will be around 650 MB, while <code class="literal">node:4-slim</code> will be around 205 MB.</p></div><div class="section" title="Starting from a Golang image"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec203"/>Starting from a Golang image</h3></div></div></div><p>Go is <a id="id1001" class="indexterm"/>well distributed as a Docker image. Its releases are tagged by release (such as <code class="literal">golang:1.7</code>) and with alternatives such as one based on Alpine (<code class="literal">golang:1.7-alpine</code>) or even for Windows Server (<code class="literal">golang:1.7-windowsservercore</code> and <code class="literal">golang:1.7-nanoserver</code>).</p><p>To start from the Go image, use the following in a Dockerfile:</p><div class="informalexample"><pre class="programlisting">FROM golang:1.7
ENTRYPOINT ["/bin/bash"]</pre></div><p>The main Go <code class="literal">1.7</code> image is 672 MB.</p></div><div class="section" title="Starting from a Ruby image"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec204"/>Starting from a Ruby image</h3></div></div></div><p>Ruby is <a id="id1002" class="indexterm"/>also distributed as an official Docker image: all the latest releases are found tagged like <code class="literal">ruby:2.3</code>. Alternative builds from Alpine Linux and Debian Jessie slim images are also available.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note71"/>Note</h3><p>A distinct Ruby-on-Rails Docker image used to exist, but is now deprecated in favor of the main Ruby Docker image.</p></div></div><p>To start from the Ruby <code class="literal">2.3</code> image, use the following to start a Dockerfile: </p><div class="informalexample"><pre class="programlisting">FROM ruby:2.3
ENTRYPOINT ["/bin/bash"]</pre></div><p>The main Ruby <code class="literal">2.3</code> image is 725 MB.</p></div><div class="section" title="Starting from a Python image"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec205"/>Starting from a Python image</h3></div></div></div><p>Python is <a id="id1003" class="indexterm"/>officially distributed and many of its versions are supported as tagged Docker images. We can find versions 2.7, 3.3, 3.4, 3.5, and current beta versions based on Debian Jessie or Wheezy, Alpine, and Windows Server.</p><p>To start our project using the Python <code class="literal">3.5</code> image, add the following in a Dockerfile:</p><div class="informalexample"><pre class="programlisting">FROM python:3.5
ENTRYPOINT ["/bin/bash"]</pre></div><p>The <a id="id1004" class="indexterm"/>main <code class="literal">python:3.5</code> image is around 683 MB.</p></div><div class="section" title="Starting from a Java image"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec206"/>Starting from a Java image</h3></div></div></div><p>Java <a id="id1005" class="indexterm"/>users are also getting official releases on Docker. Both OpenJDK and JRE are available, for versions 6, 7, 8, and 9, based on Debian Jessie or Alpine.</p><p>To start using the OpenJDK 9 image, use the following in a Dockerfile:</p><div class="informalexample"><pre class="programlisting">FROM openjdk:9
ENTRYPOINT ["/bin/bash"]</pre></div><p>The main <code class="literal">openjdk:9</code> image is 548 MB—one of the smallest programming language images available.</p></div><div class="section" title="Starting from a PHP image"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec207"/>Starting from a PHP image</h3></div></div></div><p>The PHP <a id="id1006" class="indexterm"/>Docker image is very popular, and available in many different flavors. It's one of the easiest ways of easily testing newer and older releases of PHP on a platform. PHP 5.6 and 7.0 (and all beta versions) are available, and each is also available with a different flavor, that is, based on Alpine (<code class="literal">php:7-alpine</code>), Debian Jessie with Apache (<code class="literal">php:7-apache</code>), or Debian Jessie with FPM (<code class="literal">php:7-fpm</code>), but if we still like FPM with Alpine, it's also ok (<code class="literal">php:7-fpm-alpine</code>).</p><p>To start using a classic PHP 7 Docker image, start with the following in a Dockerfile:</p><div class="informalexample"><pre class="programlisting">FROM php:7
ENTRYPOINT ["/bin/bash"]</pre></div><p>The main <code class="literal">php:7</code> image is 363 MB—this is the smallest programming language image available.</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec251"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Images on the Docker Hub: <a class="ulink" href="https://hub.docker.com/explore/">https://hub.docker.com/explore/</a></li><li class="listitem" style="list-style-type: disc">Red Hat Container catalog: <a class="ulink" href="https://access.redhat.com/containers">https://access.redhat.com/containers</a></li></ul></div></div></div>
<div class="section" title="Optimizing the Docker image size"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec98"/>Optimizing the Docker image size</h1></div></div></div><p>Docker images <a id="id1007" class="indexterm"/>are generated instruction by instruction from the Dockerfile. Though perfectly correct, many images are sub-optimized when we're talking about size. Let's see what we can do about it by building an Apache Docker container on Ubuntu 16.04.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec252"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need a working Docker installation.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec253"/>How to do it…</h2></div></div></div><p>Take the following <code class="literal">Dockerfile</code>, which updates the Ubuntu image, installs the <code class="literal">apache2</code> package, and then removes the <code class="literal">/var/lib/apt</code> cache folder. It's perfectly correct, and if you build it, the image size is around 260 MB:</p><div class="informalexample"><pre class="programlisting">FROM ubuntu:16.04
RUN apt-get update -y
RUN apt-get install -y apache2
RUN rm -rf /var/lib/apt
ENTRYPOINT ["/usr/sbin/apache2ctl", "-D", "FOREGROUND"]</pre></div><p>Now, each layer is added on top of the previous. So, what's written during the <code class="literal">apt-get update</code> layer is written forever, even if we remove it in the last <code class="literal">RUN</code>.</p><p>Let's rewrite this <code class="literal">Dockerfile</code> using a one-liner, to save some space:</p><div class="informalexample"><pre class="programlisting">FROM ubuntu:16.04
RUN apt-get update -y &amp;&amp; \
    apt-get install -y apache2 &amp;&amp; \
    rm -rf /var/lib/apt/
ENTRYPOINT ["/usr/sbin/apache2ctl", "-D", "FOREGROUND"]</pre></div><p>This image <a id="id1008" class="indexterm"/>is exactly the same, but is only around 220 MB. That's 15% space saved!</p><p>Replacing the <code class="literal">ubuntu:16.04</code> image with the <code class="literal">debian:stable-slim</code> image gets the same result, but with a size of 135 MB (a 48% reduction in size!):</p><div class="informalexample"><pre class="programlisting">FROM debian:stable-slim
RUN apt-get update -y &amp;&amp; \
    apt-get install -y apache2 &amp;&amp; \
    rm -rf /var/lib/apt/
ENTRYPOINT ["/usr/sbin/apache2ctl", "-D", "FOREGROUND"]</pre></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec254"/>How it works…</h2></div></div></div><p>Each layer is added to its predecessor. By combining all the related commands from download to deletion, we keep a clean state on this particular layer. Another good example is when the Dockerfile downloads a compressed archive; downloading it, uncompressing it, and then removing the archive uses a lot of added layer space when done separately. The same in one line does everything at once, so instead of having the cumulated space taken from the archive and its uncompressed content, the space taken is only from the uncompressed content alone. Often, there's a very nice gain in size!</p></div></div>
<div class="section" title="Versioning Docker images with tags"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec99"/>Versioning Docker images with tags</h1></div></div></div><p>A very <a id="id1009" class="indexterm"/>common need is to quickly identify what version of the software a Docker image is running and optionally stick to it, or to be sure to always run a stable version. This is a perfect use for the Docker tags. We'll build a Terraform container, with both a stable and an unstable tag, so multiple versions can coexist—one for production and one for testing.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note72"/>Note</h3><p>Docker <span class="emphasis"><em>tags</em></span> are not to be mistaken with Docker <span class="emphasis"><em>labels</em></span>. Labels are purely informative when tags can be requested directly to make images distinct from an operational point of view.</p></div></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec255"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need a working Docker installation.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec256"/>How to do it…</h2></div></div></div><p>Here's a simple Dockerfile to create a Terraform container (Terraform was covered earlier in this book):</p><div class="informalexample"><pre class="programlisting">FROM alpine:latest
ENV TERRAFORM_VERSION=0.7.12
VOLUME ["/data"]
WORKDIR /data
RUN apk --update --no-cache add ca-certificates openssl &amp;&amp; \
  wget -O terraform.zip "https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_amd64.zip" &amp;&amp; \
  unzip terraform.zip -d /bin &amp;&amp; \
  rm -rf terraform.zip /var/cache/apk/*
ENTRYPOINT ["/bin/terraform"]
CMD [ "--help" ]</pre></div><p>This is the current, stable, and latest version, and it's 0.7.12 as well. We'd like our users to be able to request one of the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">terraform:latest</code> (for those of our users who always want the latest version available)</li><li class="listitem" style="list-style-type: disc"><code class="literal">terraform:stable</code> (for those of our users who always want the stable version, opposed to a beta version)</li><li class="listitem" style="list-style-type: disc"><code class="literal">terraform:0.7.12</code> (for those of our users who always want a very specific version, such as for compatibility issues)</li></ul></div><p>This is easily achievable by building directly with all these different tags:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker build -t terraform:latest -t terraform:stable -t terraform:0.7.12 .</strong></span>
</pre></div><p>Now when requesting which images are available, we can see they all have the same image ID, but with different tags. This is what we wanted, since it's the same image that shares all those tags:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker images terraform</strong></span>
<span class="strong"><strong>REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE</strong></span>
<span class="strong"><strong>terraform           0.7.12              9d53a0811d63        About a minute ago   83.61 MB</strong></span>
<span class="strong"><strong>terraform           latest              9d53a0811d63        About a minute ago   83.61 MB</strong></span>
<span class="strong"><strong>terraform           stable              9d53a0811d63        About a minute ago   83.61 MB</strong></span>
</pre></div><p>Some <a id="id1010" class="indexterm"/>days later, we release a new version of the software as a Docker container for our team to test it out. This time it's an unstable, 0.8.0-rc1 version. We'd like our users to request this image as one of the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">terraform:latest</code> (it's still the latest version available, even unstable)</li><li class="listitem" style="list-style-type: disc"><code class="literal">terraform:unstable</code> (it's a release candidate, not a stable version)</li><li class="listitem" style="list-style-type: disc"><code class="literal">terraform:0.8.0-rc1</code> (it's this specific version)</li></ul></div><p>Change the <code class="literal">TERRAFORM_VERSION</code> variable in the <code class="literal">Dockerfile</code>, and build the image with the following tags:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker build -t terraform:latest -t terraform:unstable -t terraform:0.8.0-rc1 .</strong></span>
</pre></div><p>Now, if we look at the available Terraform images, we can confirm that it's the same image ID shared by the <code class="literal">latest</code>, <code class="literal">unstable</code>, and <code class="literal">0.8.0-rc1</code> tags, while our users preferring the stable version are not impacted by our changes:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker images terraform</strong></span>
<span class="strong"><strong>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</strong></span>
<span class="strong"><strong>terraform           0.8.0-rc1           44609fa7c016        18 seconds ago      86.77 MB</strong></span>
<span class="strong"><strong>terraform           latest              44609fa7c016        18 seconds ago      86.77 MB</strong></span>
<span class="strong"><strong>terraform           unstable            44609fa7c016        18 seconds ago      86.77 MB</strong></span>
<span class="strong"><strong>terraform           0.7.12              9d53a0811d63        9 minutes ago       83.61 MB</strong></span>
<span class="strong"><strong>terraform           stable              9d53a0811d63        9 minutes ago       83.61 MB</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note73"/>Note</h3><p>This leads to a very important question: as the latest tag is by default when not specifying any, should it be also used for unstable releases? This is something you have to answer according to your needs and environment.</p></div></div></div></div>
<div class="section" title="Deploying a Ruby-on-Rails web application in Docker"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec100"/>Deploying a Ruby-on-Rails web application in Docker</h1></div></div></div><p>The great <a id="id1011" class="indexterm"/>thing with Docker is that, as developers, we can ship whatever is working on this particular container on one environment (such as development or staging) and be sure it will run similarly in another environment (such as production). Deploys are less stressful, and rollbacks are easier. However, to achieve this peace of mind, we need more than a Ruby-on-Rails application, for example, we need to ship a Dockerfile containing everything to build a self-sufficient container so anyone can run it. Here's how to do it.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec257"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Docker installation</li><li class="listitem" style="list-style-type: disc">A Rails application</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec258"/>How to do it…</h2></div></div></div><p>Here are our standard requirements:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">This Rails application needs Ruby 2.3</li><li class="listitem" style="list-style-type: disc">All dependencies are handled by Bundler, and need to be installed in the container</li><li class="listitem" style="list-style-type: disc">Node 5 is also needed</li><li class="listitem" style="list-style-type: disc">We want assets to be precompiled in the image (putting them somewhere else is out of scope)</li></ul></div><p>Here's how we'll proceed. To match our main requirement, we'll start with the <code class="literal">ruby:2.3</code> image:</p><div class="informalexample"><pre class="programlisting">FROM ruby:2.3</pre></div><p>One way to enable the official Node 5 repositories is to download and execute a setup script. Let's do it:</p><div class="informalexample"><pre class="programlisting">RUN curl -sL https://deb.nodesource.com/setup_5.x | bash -</pre></div><p>Now we need to install Node 5 (<code class="literal">apt-get install nodejs</code>) and remove all the cache files:</p><div class="informalexample"><pre class="programlisting">RUN apt-get install -qy nodejs &amp;&amp; \
  rm -rf /var/lib/apt/* &amp;&amp; \
  rm -rf /var/lib/cache/* &amp;&amp; \
  rm -rf /var/lib/log/* &amp;&amp; \
  rm -rf /tmp/*</pre></div><p>The Ruby image documentation suggests using <code class="literal">/usr/src/app</code> as a destination folder for our code. Let's ensure it's created and switch to it until the rest of the process:</p><div class="informalexample"><pre class="programlisting">RUN mkdir -p /usr/src/app
WORKDIR /usr/src/app</pre></div><p>To install all the declared dependencies, we need to send both <code class="literal">Gemfile</code> and <code class="literal">Gemfile.lock</code> to the destination folder, <code class="literal">/usr/src/app</code>. We include it as a distinct step, so we can optionally customize this step later. Then we execute Bundler (without the test and <a id="id1012" class="indexterm"/>development sections if we have them). If you're a Ruby developer, customize accordingly!</p><div class="informalexample"><pre class="programlisting">COPY Gemfile /usr/src/app/
COPY Gemfile.lock /usr/src/app/
RUN bundle install --without test development --jobs 20 --retry 5</pre></div><p>It's now time to copy the application code itself to the destination folder, <code class="literal">/usr/src/app</code> (in this case, it's the current folder):</p><div class="informalexample"><pre class="programlisting">COPY . /usr/src/app</pre></div><p>The next step is to precompile the assets, with a <code class="literal">RAILS_ENV</code> set to production, but feel free to adapt, including the compilation command:</p><div class="informalexample"><pre class="programlisting">RUN RAILS_ENV=production rake assets:precompile</pre></div><p>Finally, run the Rails server on all interfaces through bundler (by default, it listens on TCP/<code class="literal">3000</code>):</p><div class="informalexample"><pre class="programlisting">CMD ["bundle", "exec", "rails", "server", "-b", "0.0.0.0"]</pre></div><p>We can now build this Dockerfile and have our complete, standalone, and fully working Ruby-on-Rails application ready on Docker.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note74"/>Note</h3><p>It is a good practice to plug the build process in CI and execute tests against running this new image!</p></div></div></div></div>
<div class="section" title="Building and using Golang applications with Docker"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec101"/>Building and using Golang applications with Docker</h1></div></div></div><p>Golang is <a id="id1013" class="indexterm"/>a great language able to create statically linked binaries for different platforms such as Linux (ELF binaries) or Mac OS (Mach-O binaries). These binaries are often very small in size, and the language is <a id="id1014" class="indexterm"/>getting increasingly popular in the microservices world because of their portability and the speed of deployment it enables: deploying a self-sufficient 10 MB Docker image on dozens of servers is just more convenient and fast than a 1.5 GB image full of libs. Golang and containers are two technologies that go perfectly well together, and shipping or managing infrastructures using Go programs is a breeze.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec259"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Docker installation</li><li class="listitem" style="list-style-type: disc">A Golang application source code</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec260"/>How to do it…</h2></div></div></div><p>Let's say our application code is checked in <code class="literal">src/hello</code>. We'd like to begin by at least compiling the program, either for the Linux platform or for the Mac operating system.</p><div class="section" title="Using the golang Docker image to cross-compile a Go program"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec208"/>Using the golang Docker image to cross-compile a Go program</h3></div></div></div><p>We can <a id="id1015" class="indexterm"/>compile our program sharing the code folder, and setting the work directory to it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker run --rm -v "${PWD}/src/hello":/usr/src/hello -w /usr/src/hello golang:1.7 go build -v</strong></span>
</pre></div><p>This way, even on a Mac OS system, we can generate a proper ELF binary:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ file src/hello/hello</strong></span>
<span class="strong"><strong>src/hello/hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not stripped</strong></span>
</pre></div><p>That said, if we explicitly want a Mac binary, we can pass the standard Go environment variables <code class="literal">GOOS</code> and <code class="literal">GOARCH</code> so even a Linux machine can build a Mac binary:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker run --rm -v "${PWD}/src/hello":/usr/src/hello -w </strong></span>
<span class="strong"><strong>/usr/src/hello -e GOOS=darwin -e GOARCH=amd64 golang:1.7 go build -v</strong></span>
</pre></div><p>Confirm we have a Mach-O executable and not an ELF binary:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ file src/hello/hello</strong></span>
<span class="strong"><strong>src/hello/hello: Mach-O 64-bit executable x86_64</strong></span>
</pre></div></div><div class="section" title="Using the golang Docker image to build and ship a Go program"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec209"/>Using the golang Docker image to build and ship a Go program</h3></div></div></div><p>Now if <a id="id1016" class="indexterm"/>we want to build our program right from a Dockerfile and generate a Docker image out of it, that would translate <a id="id1017" class="indexterm"/>like the following:</p><div class="informalexample"><pre class="programlisting">FROM golang:1.7
COPY src/hello /go/src/hello
RUN go install hello
ENTRYPOINT ["/go/bin/hello"]</pre></div><p>Just build that image and execute it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker build -t hello .</strong></span>
<span class="strong"><strong>$ docker run -it --rm hello</strong></span>
</pre></div></div><div class="section" title="Using the scratch Docker image"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec210"/>Using the scratch Docker image</h3></div></div></div><p>Now, it's a <a id="id1018" class="indexterm"/>bit of a waste of space to have a 675 MB+ image for the very often small Golang application that often is only a few MB, and it takes time to deploy on servers. Here comes the scratch image: it just doesn't exist. We start from nothing, copy the binary, and execute it. Our build process (Makefile, build process, and CI) builds the app with the <code class="literal">golang</code> image, but does not ship the compiled application with it, saving usually 95–99% of the space, depending on the size of our binary:</p><div class="informalexample"><pre class="programlisting">FROM scratch
COPY src/hello/hello /hello
ENTRYPOINT ["/hello"]</pre></div><p>This generates the smallest image imaginable. Think only a few megabytes.</p></div><div class="section" title="Using the Alpine Linux alternative for a Go program"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec211"/>Using the Alpine Linux alternative for a Go program</h3></div></div></div><p>The main <a id="id1019" class="indexterm"/>problem with the scratch image solution is the impossibility to debug it easily from inside the container, and the impossibility to rely on external libraries or dependencies such as SSL and certificates. Alpine Linux is this small image (~5 MB) that can greatly help us if we'd like to access a shell (<code class="literal">/bin/sh</code> is available) and a package manager to debug our application. This is how we'd do it:</p><div class="informalexample"><pre class="programlisting">FROM alpine:latest
RUN apk --update --no-cache add ca-certificates openssl &amp;&amp; \
    rm -rf /var/cache/apk/*
COPY src/hello/hello /bin/hello
ENTRYPOINT ["/bin/hello"]</pre></div><p>Such an image usually is only a handful of megabytes more than the application binary, but helps <a id="id1020" class="indexterm"/>greatly for debugging.</p></div></div></div>
<div class="section" title="Networking with Docker"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec102"/>Networking with Docker</h1></div></div></div><p>Docker <a id="id1021" class="indexterm"/>has some pretty nice networking options, from choosing which ports to expose to concurrently running isolated or bridged networks. It's pretty <a id="id1022" class="indexterm"/>useful to quickly and easily simulate production environments, create better architectures, and increase container exposure on the network front. We'll see different ways to expose ports, create new networks, execute Docker containers inside them, and even have multiple networks per container.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec261"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Docker installation</li><li class="listitem" style="list-style-type: disc">A sample HTTP server binary (sample code included)</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec262"/>How to do it…</h2></div></div></div><p>To make a container network port available to others, it first needs to be <span class="emphasis"><em>exposed</em></span>. Consider any service listening on a port not reachable unless properly exposed in the 3:</p><div class="informalexample"><pre class="programlisting">FROM debian:jessie-slim
COPY src/hello/hello /hello
EXPOSE 8000
ENTRYPOINT ["/hello"]</pre></div><p>This service is listening on port <code class="literal">8000</code>, and any other Docker container running on the host can access it, by default on the same network:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># curl -I http://172.17.0.2:8000/</strong></span>
<span class="strong"><strong>HTTP/1.1 200 OK</strong></span>
</pre></div><p>However, this service is not available to the host system:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl http://localhost:8000</strong></span>
<span class="strong"><strong>curl: (7) Failed to connect to localhost port 8000: Connection refused</strong></span>
</pre></div><p>To make it available to the host system, the container has to be run with an explicit port redirection. It can be option <code class="literal">-P</code> to map exposed ports randomly (the port <code class="literal">8000</code> can be mapped to 32768 on the local machine), or the other option <code class="literal">-p 8000:8000</code> to make it fixed:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker run -ti --rm -P --name hello hello </strong></span>
</pre></div><p>On <a id="id1023" class="indexterm"/>another terminal, find the port redirection:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker port hello</strong></span>
<span class="strong"><strong>8000/tcp -&gt; 0.0.0.0:32771</strong></span>
</pre></div><p>Also, try to connect to it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl -I http://localhost:32771/</strong></span>
<span class="strong"><strong>HTTP/1.1 200 OK</strong></span>
</pre></div><p>These <a id="id1024" class="indexterm"/>are the basics of networking with Docker containers.</p><div class="section" title="Docker networks"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec212"/>Docker networks</h3></div></div></div><p>Containers <a id="id1025" class="indexterm"/>can also live inside dedicated networks for added security and isolation. To create a new Docker network, just give it a name:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker network create hello_network</strong></span>
<span class="strong"><strong>d01a3784dec1ade72b813d87c1e6fff14dc1b55fdf6067d6ed8dbe42a3af96c2</strong></span>
</pre></div><p>Grab some information about this network using the <code class="literal">docker network inspect</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker network inspect hello_network -f '{{json .IPAM.Config }}'</strong></span>
<span class="strong"><strong>[{"Subnet":"172.18.0.0/16","Gateway":"172.18.0.1/16"}]</strong></span>
</pre></div><p>This is a new subnet: <code class="literal">172.18.0.0/16</code> (in this case).</p><p>To execute a container in this specific Docker network, use the <code class="literal">--network &lt;docker_network_name&gt;</code> option like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker run -it --rm --name hello --network hello_network hello</strong></span>
</pre></div><p>Confirm this container is in the 172.18.0.0/16 network space from the <code class="literal">hello_network</code> network:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker inspect --format '{{json .NetworkSettings.Networks.hello_network.IPAddress }}' hello</strong></span>
<span class="strong"><strong>"172.18.0.2"</strong></span>
</pre></div><p>This container will be protected from unauthorized access from any container not running on the correct network. Here's an example from a container running in the default network:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># curl -I --connect-timeout 5 http://172.18.0.2:8000/</strong></span>
<span class="strong"><strong>curl: (28) Connection timed out after 5003 milliseconds </strong></span>
</pre></div><p>However, connecting from a container in the same network is allowed and working as expected:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># curl -I http://hello:8000/</strong></span>
<span class="strong"><strong>HTTP/1.1 200 OK</strong></span>
</pre></div></div><div class="section" title="Connecting multiple networks for one container"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec213"/>Connecting multiple networks for one container</h3></div></div></div><p>It can <a id="id1026" class="indexterm"/>be useful to have a few specific containers available on more than one network; proxies, internal services, and other similar services can face different networking configurations. A single Docker container can connect multiple Docker networks. Take this simple HTTP service listening on port 8000 and launch it on the default bridged network:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker run -ti --rm --name hello hello</strong></span>
</pre></div><p>This service is now available to any other container on the default network:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># curl -I http://172.17.0.2:8000/</strong></span>
<span class="strong"><strong>HTTP/1.1 200 OK</strong></span>
</pre></div><p>However, we'd like it to be also available on the <span class="emphasis"><em>hello_network</em></span> Docker network. Let's connect them to the host:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker network connect hello_network hello</strong></span>
</pre></div><p>The container now has a new network interface in the <code class="literal">hello_network</code> subnet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker exec -it hello ip addr</strong></span>
<span class="strong"><strong>[...]</strong></span>
<span class="strong"><strong>116: eth0@if117: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</strong></span>
<span class="strong"><strong>    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff</strong></span>
<span class="strong"><strong>    inet 172.17.0.2/16 scope global eth0</strong></span>
<span class="strong"><strong>[...]</strong></span>
<span class="strong"><strong>118: eth1@if119: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</strong></span>
<span class="strong"><strong>    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff</strong></span>
<span class="strong"><strong>    inet 172.18.0.2/16 scope global eth1</strong></span>
<span class="strong"><strong>[...]</strong></span>
</pre></div><p>This means that it's also available to answer requests from containers on this network!</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl http://hello:8000</strong></span>
<span class="strong"><strong>Hello world</strong></span>
</pre></div><p>We'll eventually remove the link to the original network after we're done with it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker network disconnect bridge hello</strong></span>
</pre></div></div></div></div>
<div class="section" title="Creating more dynamic containers"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec103"/>Creating more dynamic containers</h1></div></div></div><p>We can <a id="id1027" class="indexterm"/>create better containers than just fixing their usage in advance and executing them. Maybe part of the command is the one to keep (like we always want the OpenVPN binary and options to be executed, no matter what), maybe everything needs to be overridden (that's the toolbox container model, such as a <code class="literal">/bin/bash</code> command by default, but any other command given in argument can otherwise be executed), or a combination of the two, for a much more dynamic container.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec263"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need a working Docker installation.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec264"/>How to do it…</h2></div></div></div><p>To have a <a id="id1028" class="indexterm"/>fixed command executed by the container, use the <code class="literal">ENTRYPOINT</code> instruction. Use an array if the command is followed by arguments to be enforced:</p><div class="informalexample"><pre class="programlisting">FROM debian:stable-slim
RUN apt-get update -y &amp;&amp; \
    apt-get install -y apache2 &amp;&amp; \
    rm -rf /var/lib/apt/
EXPOSE 80
ENTRYPOINT ["/usr/sbin/apache2ctl", "-D", "FOREGROUND"]</pre></div><p>To override the whole command at runtime, use the <code class="literal">--entrypoint</code> option:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker run -it --rm --entrypoint /bin/sh httpd</strong></span>
<span class="strong"><strong># hostname</strong></span>
<span class="strong"><strong>585dff032d21</strong></span>
</pre></div><p>To have a command that can be simply overridden with an argument, use the <code class="literal">CMD</code> instruction instead of <code class="literal">ENTRYPOINT</code>:</p><div class="informalexample"><pre class="programlisting">FROM debian:stable-slim
RUN apt-get update -y &amp;&amp; \
    apt-get install -y apache2 &amp;&amp; \
    rm -rf /var/lib/apt/
EXPOSE 80
CMD ["/usr/sbin/apache2ctl", "-D", "FOREGROUND"]</pre></div><p>To override the command, simply give another command as an argument at runtime:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker run -it --rm httpd /bin/sh</strong></span>
<span class="strong"><strong># hostname</strong></span>
<span class="strong"><strong>cb1c6a7083ad</strong></span>
</pre></div><p>We can combine both instructions to have a more dynamic container. In this case, we want to obtain a container always executing <code class="literal">/usr/sbin/apache2ctl</code>, and by default starting the daemon in foreground, otherwise overridden by any argument at container launch time:</p><div class="informalexample"><pre class="programlisting">FROM debian:stable-slim
RUN apt-get update -y &amp;&amp; \
    apt-get install -y apache2 &amp;&amp; \
    rm -rf /var/lib/apt/
EXPOSE 80
CMD ["-D", "FOREGROUND"]
ENTRYPOINT ["/usr/sbin/apache2ctl"]</pre></div><p>If this container is executed as is, nothing changes; <code class="literal">apache2ctl</code> gets executed with the <code class="literal">-D FOREGROUND</code> option.</p><p>However, it becomes a more useful container when giving it arguments, as it dynamically will <a id="id1029" class="indexterm"/>add them to the <code class="literal">apache2ctl</code> command, replacing the original command specified by the <code class="literal">CMD</code> instruction:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker run -it --rm httpd -v</strong></span>
<span class="strong"><strong>Server version: Apache/2.4.10 (Debian)</strong></span>
<span class="strong"><strong>Server built:   Sep 15 2016 20:44:43</strong></span>
</pre></div><p>We can interactively pass <code class="literal">/usr/sbin/apache2ctl</code> arguments without the need to override the entrypoint, for example, to propose alternatives Apache configuration files or options.</p></div></div>
<div class="section" title="Auto-configuring dynamic containers"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec104"/>Auto-configuring dynamic containers</h1></div></div></div><p>We can't always execute a binary to get what we want. A configuration done dynamically is a very <a id="id1030" class="indexterm"/>common situation; system paths can be dynamic, users and passwords can be auto-generated, network ports can be contextual, third-party credentials will be different in development and in production, slaves will join their masters, cluster members will find other nodes, and most other similar changing elements will need to adapt at runtime. The trick here is to combine environment variables with the use of a script as an entry point that will be executed no matter what, and behave according to the environment variables, optionally combined with a command from the Dockerfile.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec265"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need a working Docker installation.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec266"/>How to do it…</h2></div></div></div><p>Our objective is to create a temporary, dynamic SSH server in a Docker container, with credentials we can't know in advance. So, to make it work as intended, we'll want to execute this container like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker run -e USER=john -e PASSWORD=s3cur3 sshd </strong></span>
</pre></div><p>Take this simple <code class="literal">Dockerfile</code> that creates what's necessary to run the Dropbear SSH server on the Alpine Docker image:</p><div class="informalexample"><pre class="programlisting">FROM alpine:latest
RUN apk add --update openssh-sftp-server openssh-client dropbear &amp;&amp;\
    rm -rf /var/cache/apk/*
RUN mkdir /etc/dropbear &amp;&amp; touch /var/log/lastlog
COPY entrypoint.sh /
ENTRYPOINT ["/entrypoint.sh"]
CMD ["dropbear", "-RFEmwg", "-p", "22"]</pre></div><p>When built, this container will start by executing the <code class="literal">entrypoint.sh</code> script, and then the <code class="literal">dropbear</code> binary. Here's a sample <code class="literal">entrypoint.sh</code> that only does simple checks for the <code class="literal">USER</code> and <code class="literal">PASSWORD</code> environment variable, creates the required users on the container, sets <a id="id1031" class="indexterm"/>some permissions, and finally executes the <code class="literal">CMD</code> instruction from the original Dockerfile:</p><div class="informalexample"><pre class="programlisting">#!/bin/sh

# Checks for USER variable
if [ -z "$USER" ]; then
  echo &gt;&amp;2 'Please set an USER variable (ie.: -e USER=john).'
  exit 1
fi

# Checks for PASSWORD variable
if [ -z "$PASSWORD" ]; then
  echo &gt;&amp;2 'Please set a PASSWORD variable (ie.: -e PASSWORD=hackme).'
  exit 1
fi

echo "Creating user ${USER}"
adduser -D ${USER} &amp;&amp; echo "${USER}:${PASSWORD}" | chpasswd
echo "Fixing permissions for user ${USER}"
chown -R ${USER}:${USER} /home/${USER}
exec "$@"</pre></div><p>If this container is executed without any arguments, it errors out, thanks to the check from the <code class="literal">entrypoint.sh</code> script:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker run --rm ssh</strong></span>
<span class="strong"><strong>Please set an USER variable (ie.: -e USER=john).</strong></span>
</pre></div><p>To properly use this dynamically configured container, use environment variables as required:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker run --rm -h ssh-container -e USER=john -e PASSWORD=s3cur3 -p 22:22 ssh</strong></span>
<span class="strong"><strong>Creating user john</strong></span>
<span class="strong"><strong>Password for 'john' changed</strong></span>
<span class="strong"><strong>Fixing permissions for user john</strong></span>
<span class="strong"><strong>[1] Nov 29 23:02:02 Not backgrounding</strong></span>
</pre></div><p>Now try connecting to this container from another terminal or container with proper credentials:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ssh john@localhost</strong></span>
<span class="strong"><strong>[...]</strong></span>
<span class="strong"><strong>john@localhost's password:</strong></span>
<span class="strong"><strong>ssh-container:~$ hostname</strong></span>
<span class="strong"><strong>ssh-container</strong></span>
</pre></div><p>We're logged in to our SSH container!</p><p>Such a <a id="id1032" class="indexterm"/>dynamic system can be used to give temporary, controlled, and secure SSH access to someone needing, for example, shared volume storage access or similar usages. Shutting down the container just revokes everything and we're done with it.</p></div></div>
<div class="section" title="Better security with unprivileged users"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec105"/>Better security with unprivileged users</h1></div></div></div><p>By default, containers execute everything as the <code class="literal">root</code> user. Granted that containers are running <a id="id1033" class="indexterm"/>in an isolated environment, but still, a publicly facing daemon is running as root on a system, and a security breach may give an attacker access to this particular container, and maybe root shell access, giving access at least to the container's Docker overlay network. Would we like to see this issue combined with a 0-day local kernel security breach that would give the attacker access to the Docker host? Probably not. Then, maybe we should keep some of the good old practices and start by executing our daemon as a user other than root.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec267"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Docker installation</li><li class="listitem" style="list-style-type: disc">A sample HTTP server binary (sample code included)</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec268"/>How to do it…</h2></div></div></div><p>Let's take a simple HTTP server that answers on the port <code class="literal">8000</code> of the container. Executed through a container, it would look like this, as seen earlier in this book:</p><div class="informalexample"><pre class="programlisting">FROM debian:jessie-slim
COPY src/hello/hello /usr/bin/hello
RUN chmod +x /usr/bin/hello
EXPOSE 8000
ENTRYPOINT ["/usr/bin/hello"]</pre></div><p>This will work, but things aren't looking that great security-wise; our daemon is, in fact, running as the <code class="literal">root</code> user, even though it's running on an unprivileged port:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ps aux</strong></span>
<span class="strong"><strong>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</strong></span>
<span class="strong"><strong>root         1  0.6  0.2  36316  4180 ?        Ssl+ 23:30   0:00 /usr/bin/hello</strong></span>
</pre></div><p>This is suboptimal from a security point of view. Containers are real systems, so they too can <a id="id1034" class="indexterm"/>have users. Combined with the <code class="literal">USER</code> instruction in the Dockerfile, we'll be able to execute commands as an unprivileged user! Here's how an optimized Dockerfile looks, adding a normal user and group for the <code class="literal">hello</code> user, and then executing the <code class="literal">/usr/bin/hello</code> HTTP server as this new unprivileged user:</p><div class="informalexample"><pre class="programlisting">FROM debian:jessie-slim
COPY src/hello/hello /usr/bin/hello
RUN chmod +x /usr/bin/hello
RUN groupadd -r hello &amp;&amp; useradd -r -g hello hello
USER hello
EXPOSE 8000
ENTRYPOINT ["/usr/bin/hello"]</pre></div><p>Once built and running, the daemon still runs correctly, but as an unprivileged user:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ps aux</strong></span>
<span class="strong"><strong>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</strong></span>
<span class="strong"><strong>hello        1  0.0  0.2  36316  4768 ?        Ssl+ 23:33   0:00 /usr/bin/hello</strong></span>
</pre></div><p>We're now building tougher containers!</p></div></div>
<div class="section" title="Orchestrating with Docker Compose"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec106"/>Orchestrating with Docker Compose</h1></div></div></div><p>Launching <a id="id1035" class="indexterm"/>multiple containers manually can be a hassle, especially when the infrastructure goes increasingly complex. Dependencies, shared variables, and common networking can be easily handled with the orchestration tool named Docker Compose. In a simply YAML file, we can describe what services are needed to run our application (proxy, application, databases, and so on). In this section, we'll show how to create a simple LAMP docker-compose file, then we'll show how we can iterate from that to build some staging and production specific changes.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec269"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Docker installation</li><li class="listitem" style="list-style-type: disc">A working Docker Compose installation</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec270"/>How to do it…</h2></div></div></div><p>To orchestrate multiple containers together using Docker Compose, let's start with an easy WordPress example. The team at WordPress built a container that auto-configures to some extent through environment variables similar to what we saw earlier in this chapter. If we just apply the documentation shipped with the WordPress Docker container, we end up with the following <code class="literal">docker-compose.yml</code> at the root of some new directory (it can be a Git repository if needed):</p><div class="informalexample"><pre class="programlisting">version: '2'

services:
  wordpress:
    image: wordpress
    ports:
      - 8080:80
    environment:
      WORDPRESS_DB_PASSWORD: example
  mysql:
    image: mariadb
    environment:
      MYSQL_ROOT_PASSWORD: example</pre></div><p>This has <a id="id1036" class="indexterm"/>the great advantage to work out of the box; the latest WordPress and MariaDB images get downloaded, local HTTP port 80 gets redirected on port 8080 on the host, and MySQL stays isolated. The WordPress container takes one environment variable in this case—the MySQL root password, which should match the environment variable from MySQL. We'll see that many more are possible.</p><p>Executing Docker Compose will automatically create a Docker network and run the containers:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker-compose up</strong></span>
<span class="strong"><strong>[...]</strong></span>
<span class="strong"><strong>mysql_1      | 2016-12-01 20:51:14 139820361766848 [Note] mysqld (mysqld 10.1.19-MariaDB-1~jessie) starting as process 1 ...</strong></span>
<span class="strong"><strong>[...]</strong></span>
<span class="strong"><strong>mysql_1      | 2016-12-01 20:51:15 139820361766848 [Note] mysqld: ready for connections.</strong></span>
<span class="strong"><strong>[...]</strong></span>
<span class="strong"><strong>wordpress_1  | [Thu Dec 01 20:51:17.865932 2016] [mpm_prefork:notice] [pid 1] AH00163: Apache/2.4.10 (Debian) PHP/5.6.28 configured -- resuming normal operations</strong></span>
<span class="strong"><strong>wordpress_1  | [Thu Dec 01 20:51:17.865980 2016] [core:notice] [pid 1] AH00094: Command line: 'apache2 -D FOREGROUND'</strong></span>
</pre></div><p>Let's verify <a id="id1037" class="indexterm"/>we can connect to the WordPress HTTP server locally, on the redirected port <code class="literal">8080</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl -IL http://localhost:8080</strong></span>
<span class="strong"><strong>HTTP/1.1 302 Found</strong></span>
<span class="strong"><strong>[...]</strong></span>

<span class="strong"><strong>HTTP/1.1 200 OK</strong></span>
<span class="strong"><strong>[...]</strong></span>
</pre></div><p>More information can be seen using the <code class="literal">ps</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker-compose ps</strong></span>
<span class="strong"><strong>       Name                      Command               State          Ports</strong></span>
<span class="strong"><strong>-----------------------------------------------------------------------------------</strong></span>
<span class="strong"><strong>1basics_mysql_1       docker-entrypoint.sh mysqld      Up      3306/tcp</strong></span>
<span class="strong"><strong>1basics_wordpress_1   docker-entrypoint.sh apach ...   Up      0.0.0.0:8080-&gt;80/tcp</strong></span>
</pre></div><p>Let's ensure the password used for the MySQL root password is really the one provided by the <code class="literal">docker-compose.yml</code> file, using the <code class="literal">docker-compose exec</code> command, very similar to the <code class="literal">docker run</code> command (it takes <code class="literal">docker-compose.yml</code> names):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker-compose exec mysql /usr/bin/mysql -uroot -pexample</strong></span>
<span class="strong"><strong>[...]</strong></span>

<span class="strong"><strong>MariaDB [(none)]&gt; show databases;</strong></span>
<span class="strong"><strong>+--------------------+</strong></span>
<span class="strong"><strong>| Database           |</strong></span>
<span class="strong"><strong>+--------------------+</strong></span>
<span class="strong"><strong>| information_schema |</strong></span>
<span class="strong"><strong>| mysql              |</strong></span>
<span class="strong"><strong>| performance_schema |</strong></span>
<span class="strong"><strong>| wordpress          |</strong></span>
<span class="strong"><strong>+--------------------+</strong></span>
<span class="strong"><strong>4 rows in set (0.00 sec)</strong></span>
</pre></div><p>When we're done with our initial Docker Compose environment, let's destroy it; the containers <a id="id1038" class="indexterm"/>and networks will be removed:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker-compose down</strong></span>
</pre></div><div class="section" title="Extending Docker Compose"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec214"/>Extending Docker Compose</h3></div></div></div><p>Now we <a id="id1039" class="indexterm"/>know the basics, let's extend the usage a little. We're not happy with the default password and would like to use a better one, so simulate the staging environment. Let's use the overriding feature of Docker Compose for that and create a <code class="literal">docker-compose.staging.yml</code> file that will simply override the concerned values:</p><div class="informalexample"><pre class="programlisting">version: '2'
services:
  wordpress:
    image: wordpress:4.6
    environment:
      WORDPRESS_DB_PASSWORD: s3cur3
  mysql:
    environment:
      MYSQL_ROOT_PASSWORD: s3cur3</pre></div><p>The two environment variables <code class="literal">WORDPRESS_DB_PASSWORD</code> and <code class="literal">MYSQL_ROOT_PASSWORD</code> will be overridden when <code class="literal">docker-compose</code> is executed with multiple configuration files taken in order:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker-compose -f docker-compose.yml -f docker-compose.staging.yml up</strong></span>
</pre></div><p>Verify that the new password is indeed working for MySQL:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker exec -it 1basics_mysql_1 mysql -uroot -ps3cur3</strong></span>
<span class="strong"><strong>Welcome to the MariaDB monitor.  Commands end with ; or \g.</strong></span>
<span class="strong"><strong>Your MariaDB connection id is 4</strong></span>
</pre></div><p>We're very easily overriding values with simple YAML files!</p><p>Suppose that we now want to include a reverse proxy to the mix, with a slightly earlier version of the Docker image and another MySQL password, to mimic a specific situation we have in production. We can use the excellent dynamic Nginx image from <code class="literal">jwilder/nginx-proxy</code> to do this job and add a new <span class="emphasis"><em>proxy</em></span> service, sharing port <code class="literal">80</code> and the local Docker socket as read-only (to dynamically access running containers) on a <code class="literal">docker-compose.production.yml</code> file:</p><div class="informalexample"><pre class="programlisting">  proxy:
    image: jwilder/nginx-proxy
    ports:
      - "80:80"
    volumes:
      - /var/run/docker.sock:/tmp/docker.sock:ro</pre></div><p>This <code class="literal">nginx-proxy</code> container needs a variable named <code class="literal">VIRTUAL_HOST</code> to know what to answer in case of multiple virtual hosts. Let's add it as localhost (or adapt to your local hostname), along with the better password and the WordPress image version:</p><div class="informalexample"><pre class="programlisting">  wordpress:
    image: wordpress:4.5
    environment:
      WORDPRESS_DB_PASSWORD: sup3rs3cur3
      VIRTUAL_HOST: localhost</pre></div><p>Make the <a id="id1040" class="indexterm"/>password match in the MySQL section as well and we'll be done with our production environment simulation:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker-compose -f docker-compose.yml -f docker-compose.production.yml up</strong></span>
</pre></div><p>Confirm <code class="literal">nginx-proxy</code> is answering in HTTP/<code class="literal">80</code> and forwarding a proper HTTP answer from the WordPress container:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl -IL http://localhost/</strong></span>
<span class="strong"><strong>HTTP/1.1 302 Found</strong></span>
<span class="strong"><strong>Server: nginx/1.11.3</strong></span>
<span class="strong"><strong>[...]</strong></span>
<span class="strong"><strong>HTTP/1.1 200 OK</strong></span>
<span class="strong"><strong>Server: nginx/1.11.3</strong></span>
</pre></div><p>We've seen how, with only a few lines of YAML, we can easily orchestrate containers, how it can be used to handle different cases and environments, and how it can also be successfully extended. This is, however, just a small introduction to what can be done with <a id="id1041" class="indexterm"/>Docker Compose—it's quite a powerful tool!</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec271"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Nginx-proxy: <a class="ulink" href="https://github.com/jwilder/nginx-proxy">https://github.com/jwilder/nginx-proxy</a></li><li class="listitem" style="list-style-type: disc">WordPress <a id="id1042" class="indexterm"/>Docker image: <a class="ulink" href="https://hub.docker.com/_/wordpress/">https://hub.docker.com/_/wordpress/</a></li><li class="listitem" style="list-style-type: disc">The Docker <a id="id1043" class="indexterm"/>Compose documentation: <a class="ulink" href="https://docs.docker.com/compose/">https://docs.docker.com/compose/</a></li></ul></div></div></div>
<div class="section" title="Linting a Dockerfile"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec107"/>Linting a Dockerfile</h1></div></div></div><p>Like any <a id="id1044" class="indexterm"/>other language, Dockerfiles can and should be linted for updated best practices and code quality checks. Docker is no exception to the rule, and good practices are always moving, getting updates, and might also be a little different between communities. In this section, we'll start with a basic Dockerfile found earlier and end up with a fully double-checked linted file.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec272"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Docker installation</li><li class="listitem" style="list-style-type: disc">An AWS account</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec273"/>How to do it…</h2></div></div></div><p>Many different linters exist for linting Dockerfiles: Hadolint (<a class="ulink" href="http://hadolint.lukasmartinelli.ch/">http://hadolint.lukasmartinelli.ch/</a>) maybe the most used linter, while Project Atomic's <code class="literal">dockerfile_lint</code> project is perhaps the most complete one (<a class="ulink" href="https://github.com/projectatomic/dockerfile_lint">https://github.com/projectatomic/dockerfile_lint</a>). </p><p>Here's the working Dockerfile from earlier in this book:</p><div class="informalexample"><pre class="programlisting">FROM debian:stable-slim
RUN apt-get update -y \
    &amp;&amp; apt-get install -y apache2 \
    &amp;&amp; rm -rf /var/lib/apt
ENTRYPOINT ["/usr/sbin/apache2ctl"]
CMD ["-D", "FOREGROUND"]</pre></div><div class="section" title="Hadolint"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec215"/>Hadolint</h3></div></div></div><p>Let's start <a id="id1045" class="indexterm"/>working with Hadolint, as it's easy to install (prebuilt binaries and Docker images) and use. All rules are explained in Hadolint's wiki (<a class="ulink" href="https://github.com/lukasmartinelli/hadolint/wiki">https://github.com/lukasmartinelli/hadolint/wiki</a>), and usage is really simple:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ hadolint Dockerfile</strong></span>
</pre></div><p>Alternatively, use the Docker containerized version; it's probably good in CI scripts. Beware of the image size; at the time of writing, the image is 1.7 GB, while the hadolint binary is less than 20 MB:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker run --rm -i lukasmartinelli/hadolint &lt; Dockerfile</strong></span>
</pre></div><p>Linting Dockerfiles from this chapter, we'll notice different warnings. Maybe some are false positives, or maybe some rules are just not yet updated to the latest deprecation notices, such as the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ hadolint Dockerfile</strong></span>
<span class="strong"><strong>Dockerfile DL4000 Specify a maintainer of the Dockerfile</strong></span>
</pre></div><p>In fact, this Dockerfile is following Docker 1.13 recommendations, which include to no more <a id="id1046" class="indexterm"/>include a <code class="literal">maintainer</code> instruction. However, Hadolint is not yet up to date for this deprecation change, so execute the following to ignore one or more IDs, to still be cool:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ hadolint --ignore DL4000 --ignore &lt;another_ID&gt; Dockerfile</strong></span>
</pre></div></div><div class="section" title="Dockerfile_lint"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec216"/>Dockerfile_lint</h3></div></div></div><p>This project <a id="id1047" class="indexterm"/>lead by the Project <a id="id1048" class="indexterm"/>Atomic team (<a class="ulink" href="http://www.projectatomic.io/">http://www.projectatomic.io/</a>) is also proposing different checks and strong opinions on how a Dockerfile should be written. These propositions are very often good advice, though.</p><p>Execute this to launch <code class="literal">dockerfile_lint</code> from the official Docker image:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker run -it --rm -v $PWD:/root/ projectatomic/dockerfile-lint dockerfile_lint</strong></span>
</pre></div><p>A certain amount of suggestions will arise (errors, warnings, and info), each with a related reference URL to refer to.</p><p>When in doubt, it's often a good move to follow the suggestions and fix the code accordingly.</p><p>At the end of this double linting process, our Dockerfile changed a lot, as shown here:</p><div class="informalexample"><pre class="programlisting">FROM debian:stable-slim
LABEL name="apache"
LABEL maintainer="John Doe &lt;john@doe.com&gt;"
LABEL version=1.0
RUN apt-get update -y \
    &amp;&amp; apt-get install -y --no-install-recommends apache2=2.4.10-10+deb8u7 \
    &amp;&amp; apt-get clean \
    &amp;&amp; rm -rf /var/lib/apt/lists/*
EXPOSE 80
ENTRYPOINT ["/usr/sbin/apache2ctl"]
CMD ["-D", "FOREGROUND"]</pre></div><p>We added labels to identify the image, versions, and maintainer, and we fixed a proper version of the apache2 package. So no bad surprise can happen with an untested update (updating the package will need a rebuild of the image), we're cleaning the apt cache more precisely, and we're explicitly exposing a port from the container.</p><p>Overall, those changes proposed by the linters helped us a lot in building a much better and <a id="id1049" class="indexterm"/>stronger container. Their role in CI is crucial; include the linters in your Jenkins, Circle, or Travis CI jobs!</p></div></div></div>
<div class="section" title="Deploying a private Docker registry with S3 storage"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec108"/>Deploying a private Docker registry with S3 storage</h1></div></div></div><p>The Docker <a id="id1050" class="indexterm"/>registry is a central image distribution service. When we <span class="emphasis"><em>pull</em></span> or <span class="emphasis"><em>push</em></span> an image, it's from the Docker registry. It can be commercially hosted (CoreOS Quay <a class="ulink" href="https://quay.io/">https://quay.io/</a> is an example, Docker's own <a class="ulink" href="https://hub.docker.com/">https://hub.docker.com/</a> is another), or it can be self-hosted (for privacy, speed, bandwidth issues, or company policy). Docker Inc. made it simple for us to deploy it; it's extensively documented and packaged. Amongst the many deployable features, we'll start by simply deploying a single registry ready to be load-balanced, and then we'll switch its backend storage to AWS S3, so disk space will never be an issue again.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec274"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Docker installation</li><li class="listitem" style="list-style-type: disc">An AWS account with full S3 access</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec275"/>How to do it…</h2></div></div></div><p>We'll use Docker Compose to work through this recipe. Our objective is to host our own private Docker registry, initially using local storage, then an S3 bucket for infinite space. The registry will be available on <code class="literal">http://localhost:5000</code>, but feel free to use any other resolvable name or a dedicated server with a locally available name.</p><p>To begin with, we need the Docker registry v2 image: <code class="literal">registry:2</code>. We know from the documentation that port <code class="literal">5000</code> is exposed by the registry server, so we need to forward it to our host to use it locally. If we are running multiple registries behind a load balancer, it's safe to share a common secret, let's set it to <code class="literal">s3cr3t</code>.</p><p>This is what our initial <code class="literal">docker-compose.yml</code> file looks like:</p><div class="informalexample"><pre class="programlisting">version: '2'

services:
  registry:
    image: registry:2
    ports:
      - 5000:5000
    environment:
      REGISTRY_HTTP_SECRET: s3cr3t</pre></div><p>With this simple setup, we already are able to run our own local Docker registry server:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker-compose up</strong></span>
</pre></div><p>To upload an image to our private registry, the process is to simply tag the image with the local <a id="id1051" class="indexterm"/>registry URL and then push it. Execute the following to tag the <code class="literal">ubuntu:16.04</code> image with <code class="literal">localhost:5000/ubuntu</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker tag ubuntu:16.04 localhost:5000/ubuntu</strong></span>
</pre></div><p>Then, to push the image to the local registry, execute this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker push localhost:5000/ubuntu</strong></span>
</pre></div><p>This Docker image is now stored locally and can be reused without accessing the public network nor the Docker Hub or similar services.</p><div class="section" title="Using an S3 backend"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec217"/>Using an S3 backend</h3></div></div></div><p>An issue <a id="id1052" class="indexterm"/>with a highly used local Docker registry is disk space management—it's finite. The good news is that the Docker Registry handles easily an S3 backend (or Swift if we have an internal OpenStack). For the record, Google Cloud and Azure storage are also supported. To enable the S3 backend, only a few variables need to be set in the <code class="literal">docker-compose.yml</code> file: the AWS region to contact, the keys, and the bucket name.</p><div class="informalexample"><pre class="programlisting">      REGISTRY_STORAGE: s3
      REGISTRY_STORAGE_S3_REGION: us-east-1
      REGISTRY_STORAGE_S3_BUCKET: registry-iacbook
      REGISTRY_STORAGE_S3_ACCESSKEY: AKIAXXXXXXXXX
      REGISTRY_STORAGE_S3_SECRETKEY: 1234abcde#</pre></div><p>Destroy (<code class="literal">docker-compose down</code>) the previous example if you tried it, and start this updated one:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker-compose up</strong></span>
</pre></div><p>Now tag again an image locally:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker tag ubuntu:16.04 localhost:5000/ubuntu</strong></span>
</pre></div><p>Then, push the image to the local registry:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker push localhost:5000/ubuntu</strong></span>
</pre></div><p>Depending on your uplink speed, it will take more or less time for the Registry to sync the layers we push with the AWS S3 backend.</p><p>We now <a id="id1053" class="indexterm"/>have our own local registry with infinite storage!</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec276"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Docker <a id="id1054" class="indexterm"/>Registry documentation: <a class="ulink" href="https://docs.docker.com/registry/configuration/">https://docs.docker.com/registry/configuration/</a></li></ul></div></div></div></body></html>