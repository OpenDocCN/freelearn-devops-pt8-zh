- en: Developing with Cloud Run for Anthos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will discover how to leverage more sophisticated tools and
    services to deliver production-level management of the environment. Kubernetes
    is a wide and intriguing subject that is beyond the scope of this book. However,
    knowing some of the background and key elements will make the transition to this
    platform easier.
  prefs: []
  type: TYPE_NORMAL
- en: As per earlier chapters, an introduction to Cloud Run and Kubernetes will cover
    the key aspects of the technology. In that respect, working through the first
    section should act as a primer on **Google Kubernetes Engine** (**GKE**) if you
    are unfamiliar with the topic. Working with Cloud Run for Anthos provides the
    ability to utilize many of the benefits of Kubernetes. This chapter will deliver
    sufficient information to get you started. If you are already familiar with GKE,
    then feel free to skip the initial section and move on to the specifics of Cloud
    Run for Anthos.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up identity and policy management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with environment monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom networking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Establishing domains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete the hands-on exercises in this chapter, you will require a Google
    Cloud project.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code files used in this chapter in the GitHub repository for
    the book under the `ch09` sub-directory, at [https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch09](https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch09).
  prefs: []
  type: TYPE_NORMAL
- en: Identity and policy management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the identity and policy arrangement on Google Cloud is a major
    learning curve for most users. Identity Access Management is a major component
    and could easily be the focus of its own book. In short, IAM provides a policy
    on a project to provide the relevant permissions associated with roles.
  prefs: []
  type: TYPE_NORMAL
- en: On Google Cloud, administrative management operations are typically performed
    using a service account. Working with the Google Cloud catalog, the IAM roles
    are defined to address the needs of users across a wide variety of scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: IAM objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At a high level, Google Cloud uses a hierarchical structure made up of organizations,
    folders, projects, and resources to marshal access.
  prefs: []
  type: TYPE_NORMAL
- en: The organization node is the root node for Google Cloud resources and containers
    all of the projects and resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Folders are optional, used to group projects under an organization. A folder
    may contain both projects and other folders. IAM policies can be used to control
    access to the resources a folder contains.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Cloud resources are always associated with a project. Google Cloud allows
    you to track resource and quota usage, enable billing, manage permissions and
    credentials, and enable services and APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hierarchy defined in the preceding list is combined with members (that is,
    **users** or **service accounts**) and roles to constrict project access to specific
    groups based on defined access permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Members
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Member accounts are important as they provide access to the organization. Think
    of member accounts as providing domain access, that is used to determine the actions
    that can be performed when using the services available in Google Cloud. There
    are two types to consider when working with member accounts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Member roles***:* Permissions given to members through the granting of roles.
    Roles define which permissions are granted. Google Cloud provides predefined roles,
    and also the ability to create custom roles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service accounts**: These allow us to control server-to-server interaction.
    Typically used to authenticate one service to another and control the application
    actions that a service can perform, service accounts on Google are referenced
    by an email address in the `gserviceaccount.com` domain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a member account has been defined, the next step is to assign a role to
    the member. In effect, this is providing permissions to perform actions within
    the project.
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On Google Cloud, roles provide a very flexible way to give access to resources.
    Access in this context is provided as a spectrum in which the range is coarse
    (in Google Cloud terms, primitive) to fine-grained (in Google Cloud terms, custom)
    depending on the use case. The three role types are outlined in the following
    list. In most instances, a mixture of these role types will be used to deliver
    the type of access required:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Primitive**: The least granular roles that existed before the introduction
    of Cloud IAM. Defined at the project level, these offer a coarse-grained level
    of access, for example, the Owner, Editor, and Viewer roles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Predefined**: Predefined IAM roles are used to provide finer-grained access
    control than primitive roles. Each Google Cloud service incorporates predefined
    roles. These are used to map to a job function, for example, Compute Network Admin,
    Security Reviewer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom**: Bespoke roles consisting of permissions and resources defined by
    the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the preceding role types will make working with Google Cloud significantly
    easier, as each project defined will adhere to the structure we've outlined. In
    the next section, we will look at GKE and see how this can be used in conjunction
    with Cloud Run.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of Google Kubernetes Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hopefully, you have heard about Kubernetes and understand how important this
    platform is for the deployment of technical environments. As an introduction for
    those not familiar with Kubernetes, this section will give you an overview of
    the key parts.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes is an orchestration platform for containers that enables scheduling
    and maintenance to be performed in an automated fashion by the system, rather
    than manually by a user.
  prefs: []
  type: TYPE_NORMAL
- en: During the last couple of chapters on Cloud Run, we have discussed the importance
    of containers. What we haven't spoken about yet is what to do to coordinate this
    management, once you start to use it, in a more production-friendly way (that
    is, consistent and reliable).
  prefs: []
  type: TYPE_NORMAL
- en: As you might imagine, containers and Kubernetes are complementary technologies
    that establish an environment in which applications can be run at scale. The platform
    itself can be run on a range of Linux servers, including **virtual machines**
    (**VMs**), cloud instances, and even on bare metal. As an open source project,
    the pace of development is astounding, as are the quality of contributions.
  prefs: []
  type: TYPE_NORMAL
- en: To use Kubernetes on Google Cloud, we use GKE. This provides a managed environment
    for Kubernetes. To access the environment, we use a command called `kubectl`,
    also known as Kubernetes control. Provisioning and maintaining a Kubernetes cluster
    is beyond the scope of this book, but we will refer to the underlying constructs
    as we deploy our artifacts to the GKE cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the use case for a product can save effort in terms of building solutions.
    At this point, it is worth outlining the key differences between Cloud Run and
    Cloud on GKE (apart from the need for Kubernetes).
  prefs: []
  type: TYPE_NORMAL
- en: Differentiating Cloud Run from Cloud Run for Anthos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cloud Run for Anthos provides many of the benefits of Cloud Run. In the following
    table, we illustrate some of the key differences that a user of the service should
    be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Cloud Run** | **Cloud Run for Anthos** |'
  prefs: []
  type: TYPE_TB
- en: '| **Billing** | Pay per use | Provisioned cluster resource |'
  prefs: []
  type: TYPE_TB
- en: '| **Machine customization** | Memory | Memory, CPU, GPU, networking |'
  prefs: []
  type: TYPE_TB
- en: '| **URL and SSL** | Automatic HTTPS URL | Manual SSL certificates |'
  prefs: []
  type: TYPE_TB
- en: '| **Identity and Policy** | Public, invoker IAM role, CICP | Public or internal
    |'
  prefs: []
  type: TYPE_TB
- en: 'Despite the differences outlined in the preceding table, the services can actually
    be easily deployed without change via the simple deployment option. Development
    can be started on Cloud Run. Move to Cloud Run for Anthos where you need the platform
    resources associated with Kubernetes. There are also a number of features that
    are shared in common between the two:'
  prefs: []
  type: TYPE_NORMAL
- en: Autoscaling (GKE limited by the cluster in use) for any service deployed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run HTTP-based apps and services easily over TCP port `8080`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple developer experience based on containers using a manifest.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select any language, or any library that can be packaged within a container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize custom domain names without the need to configure the environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a general appreciation of GKE, we can move on to apply our
    knowledge and use Cloud Run for Anthos in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using Cloud Run for Anthos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, working with Cloud Run for Anthos provides the ability
    to utilize many of the benefits of Kubernetes. In this section, we will explore
    some of these capabilities. Let's begin by creating (that is, provisioning) a
    cluster with access to Cloud Run a GKE environment.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning GKE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cloud Run for Anthos requires a Kubernetes cluster. At a high level, Kubernetes
    provides a platform on which to manage (or *orchestrate*) containers. Outlining
    the value of Kubernetes is beyond the scope of this book, but it suffices to say
    it is something that is well worth the investment of time.
  prefs: []
  type: TYPE_NORMAL
- en: To deploy code to Cloud Run for Anthos, there is an assumption that there is
    a GKE cluster available. Cloud Run for Anthos requires some pre-existing infrastructure
    to be available prior to deployment taking place. In this section, we will spin
    up a cluster and then deploy our application to it to explore in what ways the
    process is different between Cloud Run for Anthos and Cloud Run.
  prefs: []
  type: TYPE_NORMAL
- en: The following example uses Cloud Shell to enter the command line and enable
    the services needed within a project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To provision a cluster, the **Google Cloud Console** or **Cloud SDK** (**GCloud**)
    can be used. For this example, the Cloud SDK will be used so the underlying commands
    can be seen. Many of the features accessed in this section will reference beta/alpha,
    as, at the time of writing, this is their current state. As Cloud Run uses Google
    Container Registry and Cloud Build APIs, these services will need to be enabled
    within your project. Enabling the relevant `googleapis` can be done via the Console
    or using Cloud SDK:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Enabling Cloud Run on a cluster with beta status means the general format of
    the command may change once it moves to **general availability** (**GA**) status.
    If you are using Cloud Shell to run Cloud SDK commands, note this environment
    is automatically updated on a regular basis to incorporate the latest SDK changes.
    Other environments may need to be manually updated to ensure they have installed
    the correct components revisions. Here, we are going to store the cluster name
    and zone to be used, as this information is needed by both the cluster creation
    and `build` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that it is often useful to set some local environment variables to store
    common parameters as a convenience measure. Ensuring the environment variables
    are formatted in uppercase text makes them stand out in your command-line scripts.
    To access the value of a variable, append the `$` symbol in front of the variable
    name—for example, echo `$CLUSTER_NAME` will display the name associated with the
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of Cloud Run for Anthos, the element that is additionally required
    is the Cloud Run add-on. Our first use of the environment variable will be needed
    here. To reference this, we add the `$` to the front of the variable, for example,
    `$CLUSTER_NAME`. To provision the cluster, we use the following command to initiate
    the environment on which to deploy Cloud Run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Please be aware that there are restrictions on cluster names, so do check prior
    to creation that the details used conform. The following restrictions are applied;
    that is, they must be a match of regex `(?:[a-z](?:[-a-z0-9]{0,38}[a-z0-9])?)`,
    meaning the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Only alphanumerics and `-` allowed
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Start with a letter and end with an alphanumeric
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: No longer than 40 characters
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the cluster is created, there are a number of parameters we need to supply
    to the command that will be familiar if you have used GKE previously. A standard
    cluster requires the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Machine size—compute reference indicating the type of machine to be allocated
    per node
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Cluster version—signifies the version to be allocated to the Kubernetes cluster
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Zone—the zone in which the compute resource will be created
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Addons—ancillary commands providing additional functionality
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: During the provisioning process, in the GKE Cloud Console option, there is a
    more interactive version of the command line that shows what is being performed.
    However, there is no need to use this over the command other than curiosity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the cluster provisioning process completes, it will denote the configuration
    created. As an option, we can also set the `gcloud` command defaults for the project
    at this stage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To confirm the cluster has been successfully created, use the `kubectl` command
    to interact with GKE. Kubectl is the main way to interact directly with the cluster
    created. In order to check the nodes, we need to issue the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The output from the preceding command will display information such as the name,
    status, age, and version of the Kubernetes node deployed. In this context, a Kubernetes
    cluster is essentially our defined nodes working together as a unit.
  prefs: []
  type: TYPE_NORMAL
- en: In our GKE cluster, we now have the base platform on which to deploy Cloud Run.
    In the next section, we will take some time to explore how to deploy code to this
    environment. In addition, we will look at some workflow tips to aid development
    productivity.
  prefs: []
  type: TYPE_NORMAL
- en: Custom networking on GKE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using Kubernetes on GKE, it's useful to understand that it will create
    a custom network. The key emphasis to note is that Kubernetes will utilize IP
    addressing to assist with communication across all of its resources (such as pods,
    nodes, and services, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Internal networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The smallest element in a GKE cluster is called a **pod**. A pod is used to
    run containers and there can be just one or more, depending on the patterns used
    for a given application. Pods reside within the network namespace that is used
    to segregate access across the virtual network associated with Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Pods are scheduled to a node, and are able to communicate with any other pod,
    unless specifically restricted. Communication between pods is therefore taken
    as a given, even when they are removed and recreated dynamically. However, as
    pods are meant to be ephemeral, external access requires a separate mechanism
    called a service to provide a consistent point of access. Services use a label,
    which is basically a key-value pairing to a Kubernetes resource. Such a service
    retains a consistent IP address and port such that, externally, it can be used
    to access a grouping of pods as a logical unit.
  prefs: []
  type: TYPE_NORMAL
- en: External networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For traffic outside of the cluster, the situation is managed in a different
    way. Kubernetes uses three distinct mechanisms to provide access to internal network
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: NodePort and ClusterIP provide access using an HTTP load balancer. Ingress access
    to resources requires a service to be defined for the reasons mentioned previously.
    The communication then ensures traffic is directed to the logical group labeled
    for the service.
  prefs: []
  type: TYPE_NORMAL
- en: The main thing to note is that, as long as traffic remains within a cluster,
    communication between resources is enabled and supported. If external traffic
    is required, then a service and some form of load-balanced access should be made
    available.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Cloud Run for Anthos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a cluster created, we can think about how to deploy an application.
    The main emphasis of this section is to cover the process to use in terms of deploying
    an application to the GKE cluster. Google has been very deliberate in terms of
    trying to keep the Cloud Run commands as similar as possible. As in the previous
    section, we will build a simple Node.js container and push this to GKE.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the capability of our new GKE cluster, we will deploy the `hello-node`
    Node.js application. Our `hello-node` application simply prints out a message
    to the screen, so there is no code complexity to worry about. In fact, we already
    have the code available in the repository, so let''s clone that from the existing
    Cloud Shell environment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the GitHub repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Again, the `hello-node` application doesn't do anything amazing, it just outputs
    `Hello World!` on port `8080`. It is all packaged up (that is, into a `cloudbuild.yaml`
    file and a Dockerfile) and ready for use to push an image to the container repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin the Cloud Build process, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the build process, we will be using Google Container Registry, rather than
    the Docker Registry. A registry is essentially a storage location for images that
    can be used to push and pull stored images. The benefit of using a registry is
    that it provides a centralized storage area in which to share your images.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the images stored in Container Registry are marked as private and
    require IAM permissions to access the content. Alternatively, images can also
    be marked as public, which means they can be shared outside of the project without
    requiring any additional authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Once the build process has completed successfully, the image generated will
    be stored under the current Google Cloud project and given the tag specified in
    the `cloudbuild.yaml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The important thing to observe here is the tag associated with the image, as
    this is how the artifact will be referenced when pulling the image from the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8fcbb888-a085-4a5f-a1c5-5ed05051ca0e.png)'
  prefs: []
  type: TYPE_IMG
- en: Take a look in the Google Cloud Container Registry to see the image built in
    the previous step. Selecting the image in the registry will display further details,
    including the all-important tag reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'From Container Registry, we can see the image, together with the hostname and
    level of visibility (that is, private/public) applied. The hostname provides the
    region for which the image is associated, outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gcr.io`: Currently located in the United States, but the location may change'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`us.gcr.io`: United States'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eu.gcr.io`: European Union'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`asia.gcr.io`: Asia'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When building images, it is advantageous to use a location closest to the data
    to maximize overall performance. The reason for this is that, when pulling the
    image (that is, the retrieval process), you want to minimize the distance between
    the registry source and destination host machine.
  prefs: []
  type: TYPE_NORMAL
- en: The visibility of an image is either private to the project or public (that
    is, accessible by everyone). By default, the images are set to private; however,
    the visibility can easily be changed if required.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, as the image is present in the project registry, it will also
    be accessible to the cluster created earlier. Prior to deploying the image, let''s
    take a moment to understand some of the terms used in the standard commands for
    deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SERVICE`: Represents the name to be associated with the image to be deployed.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IMAGE`: An artifact available in Container Registry to be deployed as a service.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CLUSTER-NAME`: The name associated with the cluster created earlier; that
    is, `$CLUSTER_NAME`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CLUSTER-LOCATION`: This is the zone allocated to the cluster; that is, `$ZONE`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Take note that the `IMAGE` tag must exactly match what is available in Container
    Registry (including a version number, if applied). If you are unsure of the tag
    to use, visit the Cloud Console and select the image required to see the relevant
    tag detail.
  prefs: []
  type: TYPE_NORMAL
- en: The deployed container will be displayed with a service name, a revision (that
    is, a unique reference), and a URL for serving traffic. So far, we have created
    a placeholder for the service to be run. To make the container accessible as a
    named service, we need to deploy it. In the real world, the prior activities are
    likely going to be a one-off task and can be easily automated.
  prefs: []
  type: TYPE_NORMAL
- en: 'To deploy the artifact to the GKE cluster, we use the `gcloud run deploy` command
    in the following way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the service has been deployed, there is a wealth of information suddenly
    available on the running of the application. There are two places of interest
    for information about the workloads running on GKE:'
  prefs: []
  type: TYPE_NORMAL
- en: The first is the Kubernetes Engine Workloads page, in which details of GKE deployments
    can be seen. If you are interested in the state of deployments or workloads sent
    to the cluster, this is a place to gather information. From here, it is possible
    to drill down into the various aspects of the deployment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second is Stackdriver. In the next section, we will update the application
    to see the impact this has on the data displayed and how to track information
    when things go wrong.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a base-level understanding of deployment, we can consider how
    to automate the process using the toolset available on Google Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have seen, there is a lot of work to get a Cloud Run for Anthos up and
    running in comparison with Cloud Run. What happens if we want to deploy another
    revision of the code? Do we need to go through the whole process once again? Well
    no: the deployment of the service is the only aspect that needs to be repeated.
    Taking some time to explore this in more detail will be interesting and will provide
    an understanding of what is happening when multiple revisions are available to
    the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our previous image was version 0.1, so let''s implement a small change (I added
    a `+1` to the response string) and see the impact this has on the deployment process
    and rollout to the cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, update the stored image in Container Registry using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we want to deploy the updated image in our cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first this to do is confirm that the new service has been successfully deployed
    by looking at the command output. To get the status of a Cloud Run service, the
    Cloud console will always have an updated status in the workloads page and will
    show changes as they are initiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, it is a bit of a pain having to do these actions each time we
    want to deploy something. Never fear: there is a much more practical way of deploying
    our code that lets our trusty friends, the service account and Cloud Build, manage
    all the boring bits.'
  prefs: []
  type: TYPE_NORMAL
- en: In the Cloud Build settings, amend the Cloud Run service account (Cloud Run
    Admin) and Service Accounts (Service Account User) to enabled. In the left-hand
    panel, select the Triggers option and connect to a valid repository.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, if a connection to GitHub has already been established, this will
    need to be done to successfully complete this setup.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a push trigger can be set up for specific branches or for all pushes
    to the repository. Note the type of trigger will attempt to auto-detect the configuration
    file. In the case of the author, the `cloudbuild.yaml` file is renamed `cloudbuild.github`,
    so that it is patently obvious which environment file should be used.
  prefs: []
  type: TYPE_NORMAL
- en: Select the create button and the trigger will now be active for the selected
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back with the source code, let''s amend the source code once more with another
    simple change, so we have a visible way to discern the difference in deployed
    versions. Update the highlighted line so it reflects the change shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will need to amend the `cloudbuild.github.yaml` file to refine
    our build process. The updated configuration file will look similar to that shown
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Taking a closer look at the build file outlined in the preceding code block,
    we can see the flexibility of Cloud Builds, as it allows commands to be directly
    initiated. A closer examination of the commands highlights the following activities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Build the container image**: The `build` command is essentially a standard
    `docker build` command that tags the image with the appropriate naming convention.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Push the container image to Container Registry**: Once the `docker build`
    process is complete, the image built is then pushed to Google Container Registry
    with the specified tag. Again, the standard Docker command is used to send the
    image to the repository.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deploy the container to Cloud Run**: The tagged image is deployed to the
    cluster.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A layout such as this provides a common build pattern for Docker-based environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'To initiate a build, once again, we would need to initiate the build process
    from the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: However, the preceding manual step is no longer necessary! The repository has
    now been linked directly to GitHub, so each time a branch change is detected,
    the build process will be automatically initiated. Working with Cloud Build can
    save a lot of effort for very little configuration, and is worth the investment
    in time to understand how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Having successfully built a service, in the next section we take a quick look
    at domains and how these are applied on Google Cloud when using Cloud Run.
  prefs: []
  type: TYPE_NORMAL
- en: Applying a domain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once a service has been deployed, Google Cloud provides a number of options
    to manage the associated domain name. In short, a domain name provides the ability
    to map a service IP address so that is accessible on the internet with a human-readable
    name. So, instead of accessing the IP `216.58.206.110`, we can enter `www.google.com`
    into the browser—I will leave it to you to consider which is more memorable.
  prefs: []
  type: TYPE_NORMAL
- en: Registering a domain name has become increasingly easy over the years and many
    companies provide an opportunity to purchase your own part of the internet. Once
    you have a domain name, you can actually map this to your Cloud Run service.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not wish to purchase a domain name, Google Cloud incorporates three
    external wildcard **domain name system** (**DNS**) test sites that can be associated
    with a deployed Cloud Run service, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **DNS service** | **Information** |'
  prefs: []
  type: TYPE_TB
- en: '| `nip.io` | [https://exentriquesolutions.com/](https://exentriquesolutions.com/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `xip.io` | [https://basecamp.com/](https://basecamp.com/) |'
  prefs: []
  type: TYPE_TB
- en: '| `sslip.io` | [https://github.com/sstephenson](https://github.com/sstephenson)[https://github.com/cunnie/sslip.io](https://github.com/cunnie/sslip.io)
    |'
  prefs: []
  type: TYPE_TB
- en: Alternatively, if you already own a domain, this can also be set up and used
    instead of the default domain. When you are not running a live service, having
    your own domain will likely be of little concern. However, once your product moves
    to production, having a domain looks much more professional.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default domain name used by Cloud Run for Anthos is actually `example.com`.
    When you change the domain, for example, to a test site, the service deployed
    will be registered against the selected name system, for example, `xip.io`. Changing
    the DNS setting requires the use of a config map to tell Kubernetes how the domain
    is to be configured:'
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we capture the output into environment variables.
    Doing this means we do not have to continually keep posting API requests to confirm
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the service URL, currently using `default.com`, for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the external IP of the deployed service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply a patch to the config map using the Istio Ingress IP as the external
    IP:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the service URL environment variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `gcloud sdk` and `kubectl` commands provide information in a number of formats,
    including JSON. Learning how to parse JSON is a very handy skill to acquire when
    learning to develop command-line scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have enabled a custom domain on your service. Now rather
    than displaying `default.com`, the service will be registered against the selected
    domain.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will cover the monitoring of an application and give
    some insights into the helpful information available.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting with Stackdriver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier sections have discussed many of the key details of Cloud Run. So far,
    we have provisioned a cluster on GKE, deployed our application and utilized Cloud
    Build to make us more productive. At this point, we should probably also cover
    what to do when things go wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'Google Cloud provides a lot of environmental information, especially for compute-based
    resources such as GCE and GKE. For serverless workloads, fortunately, we can also
    take advantage of many of these key data points:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, let''s continue with our `hello-node` application and introduce an
    error into the code. Access the source code for `index.js` and save the following
    erroneous entry to the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have intentionally added a code defect so that we
    can track this in Stackdriver. Once again we can run our `cloudbuild.github` to
    do all the hard work for us. However, this time the deployment task will fail!
    To see the details of the failure, we should go to the Cloud Run interface and
    investigate the existing services.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Cloud Run dashboard view, we have a green circle with a ticket mark
    present indicating the `hello-node` service has been successfully deployed and
    is operating within expected parameters. Contrast this with our latest deployment
    of the `hello-node` service that has encountered an error, as indicated by the
    red circle with an exclamation mark in the center. Furthermore, neither the GKE
    Cluster or Namespace detail is present, meaning the image has not been deployed
    to its end destination.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the application with the error to display further information on the
    Services details page, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b7ef7070-4707-4f60-939c-491a4b757528.png)'
  prefs: []
  type: TYPE_IMG
- en: Before we get into how to explore further information about the error displayed,
    we should take a moment to highlight the Cloud Run Service details page and the
    information accessible from there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever you deploy a service, there is a tremendous amount of information
    exchange taking place, much of it in the background. One of the important aspects
    of working with Google Cloud is the centralized management of resource-related
    data. Much of the information relating to services or resources deployed within
    your project will be captured in Stackdriver. Thankfully, the engineers at Google
    have taken the most common elements exposed in Stackdriver and added them to a
    handy dashboard covering METRICS, REVISION, LOGS, DETAILS, and YAML, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4681cb86-eed2-43d2-a508-b64eef0d4c5d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s explore these dashboard elements one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '**METRICS**: The metrics screen provides a range of data that is commonly used
    by an application, for example, a request count. In addition, the information
    presented can also be filtered by time period (such as 1 hour, 6 hours, 7 days,
    or 30 days). From this screen, an application state can easily be viewed and issues
    relating to the service performance can begin to be investigated. So, if you have
    an issue relating to the performance of a service, for example, such as latency
    or bottlenecking, this is the screen where the attributes of an application can
    be viewed to get a sense of what is happening.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**REVISIONS**: An overview of the revisions deployed, including environment
    variables and Cloud SQL connectivity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LOGS**: Access the logged information for the service. The detail available
    is based on the system logs, so information captured by an application will be
    available here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DETAILS**: From this page, the service connectivity and authentication information
    are shared.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**YAML**: The last tab provides an overview of the YAML associated with the
    service being viewed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that, at the time of writing this book, the dashboard capability was
    still being revised, so expect changes of a subtle (and not-so-subtle) nature
    in the feature set.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have outlined the relative capabilities of the dashboard, we can move
    on to resolving our service error.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, you will remember that we updated our application and introduced an
    error. We can see in the main dashboard of Cloud Run that our service was unsuccessful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over the course of the chapter we have started with a simple application, and
    then incorporated it into a continuous integration build process. Traditionally,
    we use logs to get insight into applications that are not operating within standard
    procedures. Given that we have handed over much of the build process to an automated
    process, it makes sense that the logs for each stage of this process are also
    available centrally:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to Stackdriver. The logs that would naturally be available locally to the
    developer are now present in a central repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Cloud Run dashboard, select the item indicating an error to once again
    go to the Service details page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From here, select the LOGS tab and take a closer look at what information has
    been captured by the logging process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that each entry in Stackdriver is timestamped, and associated with this
    is some form of command that returned a status update.
  prefs: []
  type: TYPE_NORMAL
- en: Working through the content displayed on screen, we can see that our application
    is executed with the `index.js` command node. If you are unclear why, it is because
    this relates to the start command we entered into the `package.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking further down the list, we can see reference to `/usr/src/app/index.js:5`.
    This is telling us that something interesting occurred at the fifth line in `index.js`.
    In the following line, the logs indicate something curious: `oops` has been found
    in the source file. Well, that is clearly not meant to be there, so we have found
    our typo.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have explored the logs for valuable clues to correct our application
    defect, go back to the source code and remove the typo on line five of `index.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resubmit the changed code to a branch and see the code once again automatically
    update to take account of the changes made.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, the code should be successfully working, based on the update
    made. Confirm the code is working by checking the text displayed is the same as
    that displayed in the current version of the source code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hopefully, the process on which to debug an application has been made clearer
    with this preceding example. By incorporating the development workflow earlier
    into the Cloud process, it makes the overall integration more complete. Being
    able to utilize built-in tools such as Stackdriver provides an easier path to
    increased productivity.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting the cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete the chapter, the final activity to cover is deleting the cluster.
    Removing a cluster is not a common activity; in fact, the only reason it is included
    here is to show the process. As we now know, the cluster incorporates all the
    base-level functionality associated with Kubernetes. On GKE, our cluster is managed;
    that is, you don't need to concern yourself with low-level activities such as
    node creation, TLS certification creation, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that said, in order to remove the cluster created previously, use the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Just to be clear, at the time of writing, the `cluster delete` command is in
    beta, so there may be some potential changes going forward.
  prefs: []
  type: TYPE_NORMAL
- en: Once we embark on deleting the cluster, it removes all the associated workloads,
    that is, the deployed containers. To restart, a new cluster would need to be created
    in order to deploy Cloud Run for Anthos.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the high-level concept of Kubernetes and then
    looked at how Cloud Run for Anthos can be used. If your platform of choice is
    Kubernetes, Cloud Run for Anthos is the path to follow. As we have seen, the migration
    between non-Kubernetes and Kubernetes environments requires no additional configuration
    as the delivery artifact is based on a container.
  prefs: []
  type: TYPE_NORMAL
- en: Through this chapter, we have discovered a more productive way to incorporate
    Cloud Build into our developer workflow. Utilizing the developer tools provided
    by Google is a sensible way to minimize the repetitive aspects that are integral
    to the build and deploy process.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we develop a couple of Cloud Run examples to illustrate
    some key features. Working through some example use cases will help to illustrate
    how to utilize Cloud Run in your own projects.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What type of machine customization is possible when using Cloud Run for Anthos?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are SSL certificates automatic or manual when using Cloud Run for Anthos?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What platform flag is required when deploying to Cloud Run for Anthos?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What port is used for service access when using Cloud Run for Anthos?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is a pre-provisioned cluster required for Cloud Run for Anthos? (True or False)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What addons are required for Cloud Run for Anthos?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which command is used to manage a GKE cluster from the command line?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a pod?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does GKE support external traffic?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Istio**: [https://cloud.google.com/istio/](https://cloud.google.com/istio/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cloud Run Authentication**: [https://cloud.google.com/run/docs/authenticating/overview](https://cloud.google.com/run/docs/authenticating/overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Kubernetes Engine**: [https://cloud.google.com/kubernetes-engine/](https://cloud.google.com/kubernetes-engine/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mapping Custom Domains**: [https://cloud.google.com/appengine/docs/standard/python/mapping-custom-domains](https://cloud.google.com/appengine/docs/standard/python/mapping-custom-domains)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filtering and formatting fun with gcloud, Google Cloud''s command-line interface**:
    [https://cloud.google.com/blog/products/gcp/filtering-and-formatting-fun-with](https://cloud.google.com/blog/products/gcp/filtering-and-formatting-fun-with)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JQ tutorial**: [https://stedolan.github.io/jq/tutorial/](https://stedolan.github.io/jq/tutorial/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
