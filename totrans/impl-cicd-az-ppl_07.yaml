- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Monitoring Azure Pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned about most of the building blocks that are required
    to use Azure Pipelines for CI/CD needs. By the end of this chapter, you will have
    the skills to understand the operational aspects of running build and release
    pipelines efficiently, using built-in capabilities to measure the healthiness
    of agents, ensure timely execution of jobs, and validate that applications are
    running without issues after deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding monitoring concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring pipeline tasks and their performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring pipeline agents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring application quality with monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But first, let’s cover a few of the technical requirements for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete this chapter, you will need to install the *Build Quality Checks
    by Microsoft* Marketplace extension. Similar to the previous chapter, search for
    the extension in the Visual Studio Marketplace and install it in your Azure DevOps
    organization. You can find the extension at [https://marketplace.visualstudio.com/items?itemName=mspremier.BuildQualityChecks](https://marketplace.visualstudio.com/items?itemName=mspremier.BuildQualityChecks).
    You can find the code for this chapter at [https://github.com/PacktPublishing/Implementing-CI-CD-Using-Azure-Pipelines/tree/main/ch07](https://github.com/PacktPublishing/Implementing-CI-CD-Using-Azure-Pipelines/tree/main/ch07).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered the technical requirements, let’s cover the monitoring
    concepts you should be familiar with when working with Azure Pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding monitoring concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When using Azure Pipelines, there are different key concepts to keep in mind
    when thinking about monitoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pipeline status**: This ensures that pipelines are always running and without
    issues while checking for failed builds, failed tests, or errors during deployments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code quality metrics**: This involves verifying metrics such as code coverage,
    code complexity, and code smells to identify potential performance or functionality
    issues before deploying applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security vulnerabilities**: This involves assessing and measuring security
    vulnerabilities in the application code, dependencies, or pipeline configuration.
    This helps ensure that the pipeline is secure and security risks are not introduced
    in the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource utilization**: This helps ensure that the build and release pipelines
    are not consuming high CPU or the memory of agents or executing the pipelines
    for extended periods, which diminishes their ability to run other jobs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment health**: This involves monitoring the deployed application to
    ensure it is running correctly and without connectivity, availability, or functionality
    issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Release cycle time**: This involves monitoring the release cycle time to
    ensure the application deployment time is occurring on time and any delays are
    identified and fixed as quickly as possible. The release cycle time is the duration
    it takes to release a new version of the application from its initial development
    phase to its deployment in production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These concepts are critical to minimize the **time to detect** (**TTD**), **time
    to mitigate** (**TTM**), and **time to remediate** (**TTR**) metrics, which are
    used in the industry to measure the ability to deliver applications promptly and
    fix/recover from any issues that might occur at any time.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on a few of these concepts, starting with pipeline
    tasks and their performance.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring pipeline tasks and their performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will cover two different approaches to monitoring tasks
    and performance:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the pipeline’s user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using dashboards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s dig into the user interface first.
  prefs: []
  type: TYPE_NORMAL
- en: Using the pipeline’s user interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Metrics about the **duration** of your pipeline, jobs, and tasks are available
    throughout the user interface to emphasize the importance of execution time, as
    can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Duration metrics in the pipeline summary](img/B18875_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Duration metrics in the pipeline summary
  prefs: []
  type: TYPE_NORMAL
- en: 'These duration metrics help you immediately understand the duration of the
    pipeline and all the jobs that are executed within it. You can click on each job
    and see the individual step duration to determine whether there are any tasks
    that you might need to review and improve in any way possible, as shown in the
    following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Duration metrics in jobs](img/B18875_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Duration metrics in jobs
  prefs: []
  type: TYPE_NORMAL
- en: You want to always make sure the total time of execution for a build or release
    pipeline is the smallest possible. This ensures you are shipping software faster
    and deploying faster to any environment. A time increase in your pipelines can
    indicate that an issue has been introduced by recent changes and that you should
    review each task’s execution time to determine whether the increase is expected
    and justified or whetheryou need to fix something.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also see the total execution time of all your pipelines by clicking
    the **Pipelines** option in the navigation menu and switching to the **Runs**
    tab, as shown in the following figure. Alternatively, you can use the filter options
    (highlighted in the following screenshot) to find a specific run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Elapsed time of your pipelines](img/B18875_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Elapsed time of your pipelines
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at these metrics over time can become tedious. For this purpose, Azure
    Pipelines provides an **Analytics** view for each pipeline that you can access
    by clicking on the elements highlighted as *1*, *2*, and *3* in the following
    screenshots. First, navigate to **Pipelines**. From the list of recently run pipelines,
    select **UnitTests-YAML**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – List of all pipelines](img/B18875_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – List of all pipelines
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open the **Analytics** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Accessing the pipeline’s Analytics view](img/B18875_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Accessing the pipeline’s Analytics view
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the **Analytics** view loads, as shown in the following screenshot, you
    have three different reports that provide insights into the pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Pipeline analytics reports](img/B18875_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – Pipeline analytics reports
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the reports provides different information that is aggregated over
    time and can be filtered to show the last 7, 14, 30, or 180 days. As shown in
    the preceding screenshot, the following reports are provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pipeline pass rate**: This reports the success or failure of the execution
    of the pipeline over time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test pass rate**: This reports the results of unit tests over time, with
    the ability to show all possible test result outcomes, such as passed, failed,
    and inconclusive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pipeline duration**: This reports the total pipeline duration over time and
    the top 10 steps by duration, as shown in the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Pipeline duration report](img/B18875_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – Pipeline duration report
  prefs: []
  type: TYPE_NORMAL
- en: You can use these reports to make sure your pipelines are healthy and executing
    promptly. Constant and frequent revision of these reports is recommended, say
    weekly, to ensure that nothing unexpected has been added that has a detrimental
    effect on the execution time of the pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Using dashboards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to monitor your pipelines is available through the **Dashboards**
    feature in the Azure DevOps **Overview** section of every project. You can create
    custom dashboards using several available widgets that display different data
    points that are useful at the macro level for every team member with easy and
    quick access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Azure DevOps includes three out-of-the-box widgets for Azure Pipelines:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Build history**, which adds a tile to show a histogram of builds indicating
    success or failure and a link to each of them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment status**, which adds a tile that shows a combined view of the
    deployment status and test pass rate across multiple environments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Release Pipeline Overview**, which adds a tile that allows you to view and
    track the status of a release pipeline'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows a custom dashboard named **Pipelines** that’s
    created with all the widgets that we just discussed, showing information from
    different pipelines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Custom Pipelines dashboard with widgets](img/B18875_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – Custom Pipelines dashboard with widgets
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about the widget catalog that’s included out of the box at
    [https://learn.microsoft.com/en-us/azure/devops/report/dashboards/widget-catalog](https://learn.microsoft.com/en-us/azure/devops/report/dashboards/widget-catalog)
    and you can find more widgets by searching for them in the Visual Studio Marketplace
    at [https://marketplace.visualstudio.com/search?term=widgets&target=AzureDevOps](https://marketplace.visualstudio.com/search?term=widgets&target=AzureDevOps).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Another effective way to monitor your pipelines is via the **Azure Pipelines
    Microsoft Teams app** marketplace extension, which you can find in the marketplace
    catalog; upon clicking it, you will be taken to **Microsoft App Source** store.
    This application is a Teams app and is installed in your Teams tenant, which is
    outside the scope of this book. After you have installed it, you can configure
    subscriptions to the pipelines you want to get notified on pipeline status or
    approvals.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn how to monitor pipeline agents.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring pipeline agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Azure DevOps, pipeline agents provide some general reporting capabilities.
    They can be accessed by clicking **Organization settings**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Accessing Organization settings](img/B18875_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – Accessing Organization settings
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are inside **Organization settings**, you will have access to the
    **Agent pools** option in the navigation menu under the **Pipelines** section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Agent pools](img/B18875_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – Agent pools
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through each of the available reports.
  prefs: []
  type: TYPE_NORMAL
- en: Job runs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use the **job runs report** for each agent pool, which will show a
    summary of the jobs that are being executed, including their ID, pipeline name,
    project, agent specification, when they were queued, wait time, and duration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Job reports in an agent pool](img/B18875_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – Job reports in an agent pool
  prefs: []
  type: TYPE_NORMAL
- en: One of the most relevant pieces of data in this report is **Wait time**, which
    is highlighted in the preceding screenshot. This is something to pay close attention
    to. If this number starts increasing between jobs, it can be an indicator that
    you need to purchase concurrency and add additional agents.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover how to purchase concurrency and the approaches to increase the
    number of agents later in this section. For now, let’s continue to review the
    available reports.
  prefs: []
  type: TYPE_NORMAL
- en: Agent status
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the agent pool details, you have an **Agents** tab, which gives you details
    about each agent that’s running, such as its name, availability, last run, current
    status, version, and the ability to enable/disable it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows an unavailable or **Offline** agent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – Agent pool with an offline agent](img/B18875_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 – Agent pool with an offline agent
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows an available or **Online** agent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – Agent pool with an online agent](img/B18875_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13 – Agent pool with an online agent
  prefs: []
  type: TYPE_NORMAL
- en: You must ensure that self-hosted agents are online and enabled when the agent
    pool is in use in your projects. Otherwise, pipeline jobs will be queued and never
    be executed if there are no agents available.
  prefs: []
  type: TYPE_NORMAL
- en: Pro tip
  prefs: []
  type: TYPE_NORMAL
- en: Always set up the agent to run as a service. This leverages the service manager
    of the operating system to ensure the life cycle of the agent is handled accordingly.
    It also improves the experience when auto-upgrading the agent.
  prefs: []
  type: TYPE_NORMAL
- en: Agent jobs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the previous agent status report, you also have access to the **Jobs**
    report for a specific agent, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14 – Agent jobs report](img/B18875_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.14 – Agent jobs report
  prefs: []
  type: TYPE_NORMAL
- en: This is useful if you are trying to determine whether a specific agent is acting
    erratically or is having intermittent failures when running jobs. In this case,
    an agent version upgrade might be needed, dependencies tooling installed in the
    agent might need attention, or as a last resort, the agent should be removed along
    with the infrastructure where it is running and replaced with a new one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at the most important report available for agent pools: analytics.'
  prefs: []
  type: TYPE_NORMAL
- en: Analytics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Analytics** report allows us to understand aggregated usage of the agents
    in the pool over time with histograms indicating concurrency, queued jobs, and
    running jobs, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15 – Analytics report on an Azure Pipelines agent pool](img/B18875_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.15 – Analytics report on an Azure Pipelines agent pool
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that the report includes two histograms – one for **Public hosted
    concurrency** and one for **Private hosted concurrency**. The public one refers
    to the allowance available in Azure Pipelines for public projects, which is 10
    and cannot be changed. Similarly, the private one is for private projects, for
    which you can purchase additional parallel jobs at an additional cost or take
    advantage of a self-hosted pipeline agent that’s included with every Microsoft
    Visual Studio Enterprise subscription.
  prefs: []
  type: TYPE_NORMAL
- en: This report helps us understand when there is a need for more agents when multiple
    jobs are queued.
  prefs: []
  type: TYPE_NORMAL
- en: 'The infrequent occurrence of queued jobs could be ignored, but when they start
    happening often, we must consider the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: Purchasing concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasing the available agents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s talk about purchasing concurrency first.
  prefs: []
  type: TYPE_NORMAL
- en: Purchasing concurrency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Adding concurrency to your agent pools applies to both Microsoft-hosted and
    self-hosted agents and the decision to increase it relies on your business need
    to not have wait times between job executions. This can be done by following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, set up billing at the organization level, as shown in the following
    figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.16 – Setting up billing for the Azure DevOps organization](img/B18875_07_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.16 – Setting up billing for the Azure DevOps organization
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on the **Set up billing** button will open a dialog where you can
    link your Azure DevOps organization with an Azure subscription, which is used
    to pay for services in Azure DevOps. If you have access to an Azure subscription,
    select it and click **Save**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.17 – Selecting an existing Azure subscription for billing](img/B18875_07_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.17 – Selecting an existing Azure subscription for billing
  prefs: []
  type: TYPE_NORMAL
- en: It is important to mention the Active Directory tenant you are logged in to
    is used to find Azure subscriptions you have access to and link them to the organization.
    You must be a member of **Project Collation Administrators Group** to complete
    this step.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not have an Azure subscription available, you will see a message
    similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.18 – Adding a new Azure subscription for billing](img/B18875_07_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.18 – Adding a new Azure subscription for billing
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then click on the **New Azure subscription** button to complete the
    steps for creating a new subscription and provide credit card details to be billed
    for purchases. Once billing has been configured, you will be able to purchase
    concurrency by going to the **Parallel jobs** option under **Project Settings**.
    You can increase/decrease the number of parallel jobs as needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.19 – Purchasing parallel jobs](img/B18875_07_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.19 – Purchasing parallel jobs
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to purchase concurrency, let’s talk about how to increase
    the number of available agents.
  prefs: []
  type: TYPE_NORMAL
- en: Increasing the available agents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the case of Microsoft-hosted agents, purchasing additional concurrency is
    all that is needed to immediately gain the ability to execute multiple jobs since
    there is no infrastructure to manage.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of self-hosted agents, you have some options:'
  prefs: []
  type: TYPE_NORMAL
- en: One option was discussed in the *Setting up agent pools* section in [*Chapter
    1*](B18875_01.xhtml#_idTextAnchor014), and it requires manually adding one agent
    to an agent pool.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another option is to use an **Azure virtual machine scale set** pool type,
    which is an option that becomes available when you add a new agent pool, as shown
    in the following screenshot. This type of agent pool automatically adds additional
    agents when the capacity is needed by monitoring the state of the current agents
    and the number of jobs in the queue every 5 minutes. You can configure the maximum
    number of agents and other parameters that control how each agent is handled within
    the pool:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.20 – Azure virtual machine scale set agent pool type](img/B18875_07_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.20 – Azure virtual machine scale set agent pool type
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Azure virtual machine scale set** agent pool type is very useful for
    the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: When you need more resources, such as CPU and memory, for the jobs to execute
    than the Microsoft-hosted ones and you don’t want to manage the underlying infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To simplify how the base images of these agents are maintained or the need to
    reimage the agents after every job execution, which this agent pool type will
    handle gracefully
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One last option to consider is running a **self-hosted agent** in Docker containers,
    which allows you to run within any container orchestrator, such as your own self-managed
    Kubernetes cluster or cloud-managed services such as **Azure Kubernetes Service**
    (**AKS**) and Amazon **Elastic Kubernetes Service** (**EKS**). In this case, you
    would need a custom implementation to scale the number of agents in and out based
    on the metrics available in the Azure DevOps REST API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we’ve learned how to monitor job runs, agent status, and task performance
    and increase concurrency and the number of agents, let’s learn how to use monitoring
    in our pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring application quality with monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Pipelines provides many capabilities to measure the success of your build
    and release pipelines. First, we’ll learn how to improve the success of unit test
    results by measuring code quality metrics.
  prefs: []
  type: TYPE_NORMAL
- en: Code quality metrics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Putting together a comprehensive unit tests pipeline includes analyzing every
    data point produced by the unit test runner framework and the tasks used to execute
    them in the pipeline. However, typically, there are limitations in terms of the
    metrics that are used by the task to determine failures on something other than
    the actual unit tests that are executed.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider a development team that recently added unit tests to a
    project that has been developed for years and they are simply starting to implement
    tests to automate and reduce the need for manual tests.
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, the general practice is to start with a small number of automated
    tests and work your way up to always increase that number of tests. The only way
    to enforce this within your pipelines is to continually monitor the unit test
    results and have an automated gate to evaluate this to ensure that the number
    is increased on every run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming you completed the previous chapter, the following task will accomplish
    this scenario by adding it to the end of the YAML file for the unit test build
    pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can find the complete file at https:[https://github.com/PacktPublishing/Implementing-CI-CD-Using-Azure-Pipelines/blob/main/ch07/azure-pipelines.yml](https://github.com/PacktPublishing/Implementing-CI-CD-Using-Azure-Pipelines/blob/main/ch07/azure-pipelines.yml)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break this down to understand what this task does:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `checkCoverage: true` option enables the policy that requires code coverage
    results to be present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, `coverageFailOption: ''build''` indicates the build will fail if code
    coverage is not increased when compared to the previous build.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`coverageType: ''blocks''` indicates that analysis will be done over the number
    of blocks of code. Other options include `lines`, `branches`, and `custom`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forceCoverageImprovement: true` will enforce that the value of the code coverage
    metric is always higher than that of the previous run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, `coverageUpperTreshold: ''80''` is the upper threshold for code coverage
    improvements. Typically, you will not strive for 100% code coverage as this implies
    every single line of code has a test associated with it, and in very large applications,
    this might not be realistic as it would require more development time. Once this
    value is reached, there will be no more enforcement for improvement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Adding this to the previously configured `UnitTests-YAML` pipeline and making
    no additional changes will result in a failed execution because no tests are being
    added to increase the code coverage metric:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.21 – Failing a build with quality checks](img/B18875_07_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.21 – Failing a build with quality checks
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve learned how to use code quality metrics to enhance our pipelines,
    let’s see how we can improve deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment health
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CI/CD allows you to automate every aspect of the deployment process, including
    validating the application in the target environment after it has been deployed.
    This scenario provides a mechanism to ensure that no human intervention is required
    to verify that a new version of an application is working as expected and no new
    errors or bugs have been introduced by the developers or the environment configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a simple scenario first. Here, we’ll consider the **Jenkins Artifacts**
    release pipeline that we discussed in the previous chapter, in which we deployed
    an artifact from a Jenkins job.
  prefs: []
  type: TYPE_NORMAL
- en: 'We didn’t explicitly add a step to verify that the `artifact.txt` file we expected
    was copied and made available to the agent. This can be addressed by adding a
    command-line task with a customized script, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.22 – Validating a task in a release pipeline](img/B18875_07_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.22 – Validating a task in a release pipeline
  prefs: []
  type: TYPE_NORMAL
- en: The script shown in the preceding screenshot works for an Ubuntu agent and verifies
    whether the `artifact.txt` file in the `_PacktFamily` directory exists; otherwise,
    it will print a message indicating that the file was not found and will exit with
    a return code of `1`. This will be interpreted as an error since the task is always
    expecting a return code of `0` to succeed.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at another scenario, say the deployment of a web application or Web
    API, for which you can write scripts that can issue an HTTP/HTTPS request to the
    application, wait for the response, and validate the response code and content.
  prefs: []
  type: TYPE_NORMAL
- en: 'An even better scenario would be to use a UI-automated test framework and execute
    them as part of the release pipeline after the application has been deployed,
    just like the unit tests that we explored in the previous chapter. The following
    UI automated test frameworks are a few options to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Open source**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Appium**: [https://github.com/appium/appium](https://github.com/appium/appium)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Robot** **Framework**: [https://robotframework.org/](https://robotframework.org/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Selenium**: [https://www.selenium.dev/](https://www.selenium.dev/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Third-party**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cypress**: [https://www.cypress.io/](https://www.cypress.io/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sauce** **Labs**: [https://saucelabs.com/](https://saucelabs.com/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Telerik Test** **Studio**: [https://www.telerik.com/teststudio](https://www.telerik.com/teststudio)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In more advanced scenarios, you can use **gates** in Azure Pipelines, which
    give you the ability to introduce automated points of control to evaluate conditions
    defined based on the task used. When using release pipelines, gates are available
    as pre-deployment and post-deployment conditions, but when using multi-stage pipelines
    with environments, gates are only available as post-conditions attached to the
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll explore one of these deployment gates using Azure Monitor next.
  prefs: []
  type: TYPE_NORMAL
- en: Integration with Azure Monitor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Azure Monitor** is a monitoring solution for collecting, analyzing, and responding
    to logs and metrics from cloud and on-premises environments. This can help you
    understand how your applications and services are performing and provide the ability
    to manually and programmatically respond to conditions that require attention
    to ensure said applications keep working as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: The integration capability in Azure Pipelines is provided via an `AzureMonitor`
    task, which allows you to query rules for active alerts and determine whether
    the deployment of a new version of an application has triggered new alerts.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will use a readily available template for release pipelines
    to easily configure the Azure Monitor task.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new release pipeline, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.23 – Creating a new release pipeline](img/B18875_07_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.23 – Creating a new release pipeline
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the `monitor` in the search field and clicking on the **Apply** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.24 – Creating a new release pipeline from a template](img/B18875_07_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.24 – Creating a new release pipeline from a template
  prefs: []
  type: TYPE_NORMAL
- en: 'You will end up with a stage, as shown in the following screenshot, where you
    must fill out the **App Service name**, **Resource Group name for Application
    Insights**, and **Application Insights resource** **name** fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.25 – Azure App Service deployment with continuous monitoring](img/B18875_07_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.25 – Azure App Service deployment with continuous monitoring
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important step is the `Availability_$(Release.DefinitionName)`, `FailedRequests_$(Release.DefinitionName)`,
    `ServerResponseTime_$(Release.DefinitionName),` and `ServerExceptions_$(Release.DefinitionName)`
    with some default thresholds. You can use these defaults, adjust them, or create
    new alert definitions based on what is important for your application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.26 – Application Insights Alerts](img/B18875_07_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.26 – Application Insights Alerts
  prefs: []
  type: TYPE_NORMAL
- en: 'With this stage configured, you can switch to the pipeline view and click **Post-deployment
    conditions** to configure the gates, which in this case should already have **Query
    Azure Monitor** **alerts** enabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.27 – Release pipeline post-deployment conditions in Stages](img/B18875_07_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.27 – Release pipeline post-deployment conditions in Stages
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then adjust many of the settings related to the deployment gate accordingly,
    including the required **Azure subscription** and **Resource group** name and
    particularly **The delay** **before evaluation**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.28 – The Query Azure Monitor alerts gate](img/B18875_07_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.28 – The Query Azure Monitor alerts gate
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in place, you can rely on Azure Pipelines to execute the gate after
    the deployment steps are completed to verify that the monitoring alerts have been
    configured and provide a visual indicator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.29 – Successful release with deployment gates](img/B18875_07_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.29 – Successful release with deployment gates
  prefs: []
  type: TYPE_NORMAL
- en: In a complete scenario, you would combine automated tests in this release pipeline
    to ensure that the monitoring alerts are evaluated based on the tests being executed
    against the recently deployed application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you could use third-party application performance monitoring tools
    with the corresponding available marketplace extensions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Dynatrace**: [https://marketplace.visualstudio.com/items?itemName=AlmaToolBoxCE.DynatraceIntegration](https://marketplace.visualstudio.com/items?itemName=AlmaToolBoxCE.DynatraceIntegration)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Datadog**: [https://marketplace.visualstudio.com/items?itemName=Datadog.datadog-monitors](https://marketplace.visualstudio.com/items?itemName=Datadog.datadog-monitors)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you’ve learned about deployment gates, we’ve come to the end of this
    chapter. Let’s summarize what we’ve learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about monitoring concepts to consider for your
    CI/CD projects and different ways to monitor your pipeline tasks, their performance,
    and how to build dashboards with graphical widgets to understand behavior over
    time and even integrate with a collaboration tool to get real-time notifications.
    You also learned how to monitor your job runs, task performance, and agents, when
    to purchase concurrency, and different options on how to increase the number of
    agents to ensure that pipelines execute promptly. Lastly, you learned how to measure
    quality in your pipelines by taking advantage of code quality metrics, application
    runtime checks, and application monitoring tools.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn how to deploy infrastructure automatically
    with automation using Azure Pipelines.
  prefs: []
  type: TYPE_NORMAL
