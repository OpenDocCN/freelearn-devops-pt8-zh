<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer212">
<h1 class="chapter-number" id="_idParaDest-86"><a id="_idTextAnchor086"/>7</h1>
<h1 id="_idParaDest-87"><a id="_idTextAnchor087"/>Monitoring Azure Pipelines</h1>
<p>So far, we have learned about most of the building blocks that are required to use Azure Pipelines for CI/CD needs. By the end of this chapter, you will have the skills to understand the operational aspects of running build and release pipelines efficiently, using built-in capabilities to measure the healthiness of agents, ensure timely execution of jobs, and validate that applications are running without issues <span class="No-Break">after deployment.</span></p>
<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>Understanding <span class="No-Break">monitoring concepts</span></li>
<li>Monitoring pipeline tasks and <span class="No-Break">their performance</span></li>
<li>Monitoring <span class="No-Break">pipeline agents</span></li>
<li>Measuring application quality <span class="No-Break">with monitoring</span></li>
</ul>
<p>But first, let’s cover a few of the technical requirements for <span class="No-Break">this chapter.</span></p>
<h1 id="_idParaDest-88"><a id="_idTextAnchor088"/>Technical requirements</h1>
<p>To complete this chapter, you will need to install the <em class="italic">Build Quality Checks by Microsoft</em> Marketplace extension. Similar to the previous chapter, search for the extension in the Visual Studio Marketplace and install it in your Azure DevOps organization. You can find the extension at <a href="https://marketplace.visualstudio.com/items?itemName=mspremier.BuildQualityChecks">https://marketplace.visualstudio.com/items?itemName=mspremier.BuildQualityChecks</a>. You can find the code for this chapter <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Implementing-CI-CD-Using-Azure-Pipelines/tree/main/ch07"><span class="No-Break">https://github.com/PacktPublishing/Implementing-CI-CD-Using-Azure-Pipelines/tree/main/ch07</span></a><span class="No-Break">.</span></p>
<p>Now that we have covered the technical requirements, let’s cover the monitoring concepts you should be familiar with when working with <span class="No-Break">Azure Pipelines.</span></p>
<h1 id="_idParaDest-89"><a id="_idTextAnchor089"/>Understanding monitoring concepts</h1>
<p>When using Azure Pipelines, there are different key concepts to keep in mind when thinking <span class="No-Break">about monitoring:</span></p>
<ul>
<li><strong class="bold">Pipeline status</strong>: This<a id="_idIndexMarker277"/> ensures that <a id="_idIndexMarker278"/>pipelines are always running and without issues while checking for failed builds, failed tests, or errors <span class="No-Break">during deployments.</span></li>
<li><strong class="bold">Code quality metrics</strong>: This<a id="_idIndexMarker279"/> involves verifying metrics such as code coverage, code complexity, and code smells<a id="_idIndexMarker280"/> to identify potential performance or functionality issues before <span class="No-Break">deploying applications.</span></li>
<li><strong class="bold">Security vulnerabilities</strong>: This involves assessing and measuring security vulnerabilities in the<a id="_idIndexMarker281"/> application <a id="_idIndexMarker282"/>code, dependencies, or pipeline configuration. This helps ensure that the pipeline is secure and security risks are not introduced in <span class="No-Break">the application.</span></li>
<li><strong class="bold">Resource utilization</strong>: This<a id="_idIndexMarker283"/> helps ensure that<a id="_idIndexMarker284"/> the build and release pipelines are not consuming high CPU or the memory of agents or executing the pipelines for extended periods, which diminishes their ability to run <span class="No-Break">other jobs.</span></li>
<li><strong class="bold">Deployment health</strong>: This <a id="_idIndexMarker285"/>involves<a id="_idIndexMarker286"/> monitoring the deployed application to ensure it is running correctly and without connectivity, availability, or <span class="No-Break">functionality issues.</span></li>
<li><strong class="bold">Release cycle time</strong>: This<a id="_idIndexMarker287"/> involves <a id="_idIndexMarker288"/>monitoring the release cycle time to ensure the application deployment time is occurring on time and any delays are identified and fixed as quickly as possible. The release cycle time is the duration it takes to release a new version of the application from its initial development phase to its deployment <span class="No-Break">in production.</span></li>
</ul>
<p>These concepts are critical <a id="_idIndexMarker289"/>to minimize <a id="_idIndexMarker290"/>the <strong class="bold">time to detect</strong> (<strong class="bold">TTD</strong>), <strong class="bold">time to mitigate</strong> (<strong class="bold">TTM</strong>), and <strong class="bold">time to remediate</strong> (<strong class="bold">TTR</strong>) metrics, which <a id="_idIndexMarker291"/>are used in the industry to measure the ability to deliver applications promptly and fix/recover from any issues that might occur at <span class="No-Break">any time.</span></p>
<p>In this chapter, we will focus on a few of these concepts, starting with pipeline tasks and <span class="No-Break">their performance.</span></p>
<h1 id="_idParaDest-90"><a id="_idTextAnchor090"/>Monitoring pipeline tasks and their performance</h1>
<p>In this section, we will <a id="_idIndexMarker292"/>cover two different approaches to monitoring tasks <span class="No-Break">and performance:</span></p>
<ul>
<li>Using the pipeline’s <span class="No-Break">user interface</span></li>
<li><span class="No-Break">Using dashboards</span></li>
</ul>
<p>Let’s dig into the user <span class="No-Break">interface first.</span></p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor091"/>Using the pipeline’s user interface</h2>
<p>Metrics about the <strong class="bold">duration</strong> of your <a id="_idIndexMarker293"/>pipeline, jobs, and tasks are available throughout the user interface to emphasize the importance of execution time, as can be seen in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer183">
<img alt="Figure 7.1 – Duration metrics in the pipeline summary" height="548" src="image/B18875_07_01.jpg" width="971"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Duration metrics in the pipeline summary</p>
<p>These<a id="_idIndexMarker294"/> duration metrics help you immediately understand the duration of the pipeline and all the jobs that are executed within it. You can click on each job and see the individual step duration to determine whether there are any tasks that you might need to review and improve in any way possible, as shown in the <span class="No-Break">following figure:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer184">
<img alt="Figure 7.2 – Duration metrics in jobs" height="591" src="image/B18875_07_02.jpg" width="563"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Duration metrics in jobs</p>
<p>You want to always make <a id="_idIndexMarker295"/>sure the total time of execution for a build or release pipeline is the smallest possible. This ensures you are shipping software faster and deploying faster to any environment. A time increase in your pipelines can indicate that an issue has been introduced by recent changes and that you should review each task’s execution time to determine whether the increase is expected and justified or whetheryou need to <span class="No-Break">fix something.</span></p>
<p>You can also see the total execution time of all your pipelines by clicking the <strong class="bold">Pipelines</strong> option in the navigation menu and switching to the <strong class="bold">Runs</strong> tab, as shown in the following figure. Alternatively, you can use the filter options (highlighted in the following screenshot) to find a <span class="No-Break">specific run:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer185">
<img alt="Figure 7.3 – Elapsed time of your pipelines" height="586" src="image/B18875_07_03.jpg" width="1129"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Elapsed time of your pipelines</p>
<p>Looking at these <a id="_idIndexMarker296"/>metrics over time can become tedious. For this purpose, Azure Pipelines provides an <strong class="bold">Analytics</strong> view for each pipeline that you can access by clicking on the elements highlighted as <em class="italic">1</em>, <em class="italic">2</em>, and <em class="italic">3</em> in the following screenshots. First, navigate to <strong class="bold">Pipelines</strong>. From the list of recently run pipelines, <span class="No-Break">select </span><span class="No-Break"><strong class="bold">UnitTests-YAML</strong></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer186">
<img alt="Figure 7.4 – List of all pipelines" height="477" src="image/B18875_07_04.jpg" width="1023"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – List of all pipelines</p>
<p>Next, open the <span class="No-Break"><strong class="bold">Analytics</strong></span><span class="No-Break"> tab:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer187">
<img alt="Figure 7.5 – Accessing the pipeline’s Analytics view" height="406" src="image/B18875_07_05.jpg" width="839"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – Accessing the pipeline’s Analytics view</p>
<p>Once the <strong class="bold">Analytics</strong> view <a id="_idIndexMarker297"/>loads, as shown in the following screenshot, you have three different reports that provide insights into <span class="No-Break">the pipeline:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer188">
<img alt="Figure 7.6 – Pipeline analytics reports" height="358" src="image/B18875_07_06.jpg" width="1171"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – Pipeline analytics reports</p>
<p>Each of the reports provides different information that is aggregated over time and can be filtered to show the last 7, 14, 30, or 180 days. As shown in the preceding screenshot, the following reports <span class="No-Break">are provided:</span></p>
<ul>
<li><strong class="bold">Pipeline pass rate</strong>: This reports the success or failure of the execution of the pipeline <span class="No-Break">over time</span></li>
<li><strong class="bold">Test pass rate</strong>: This reports the results of unit tests over time, with the ability to show all possible test result outcomes, such as passed, failed, <span class="No-Break">and inconclusive</span></li>
<li><strong class="bold">Pipeline duration</strong>: This <a id="_idIndexMarker298"/>reports the total pipeline duration over time and the top 10 steps by duration, as shown in the <span class="No-Break">following screenshot:</span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer189">
<img alt="Figure 7.7 – Pipeline duration report" height="915" src="image/B18875_07_07.jpg" width="1005"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7 – Pipeline duration report</p>
<p>You can use these reports to make sure your pipelines are healthy and executing promptly. Constant and frequent revision of these reports is recommended, say weekly, to ensure that nothing unexpected has been added that has a detrimental effect on the execution time of <span class="No-Break">the pipelines.</span></p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor092"/>Using dashboards</h2>
<p>Another way <a id="_idIndexMarker299"/>to monitor your pipelines is available through the <strong class="bold">Dashboards</strong> feature in the Azure DevOps <strong class="bold">Overview</strong> section of every project. You can create custom dashboards using several available widgets that display different data points that are useful at the macro level for every team member with easy and <span class="No-Break">quick access.</span></p>
<p>Azure DevOps includes three out-of-the-box widgets for <span class="No-Break">Azure Pipelines:</span></p>
<ul>
<li><strong class="bold">Build history</strong>, which adds a tile to show a histogram of builds indicating success or failure and a link to each <span class="No-Break">of them</span></li>
<li><strong class="bold">Deployment status</strong>, which adds a tile that shows a combined view of the deployment status and test pass rate across <span class="No-Break">multiple environments</span></li>
<li><strong class="bold">Release Pipeline Overview</strong>, which adds a tile that allows you to view and track the status of a <span class="No-Break">release pipeline</span></li>
</ul>
<p>The following screenshot shows a custom dashboard named <strong class="bold">Pipelines</strong> that’s created with all the widgets that we just discussed, showing information from <span class="No-Break">different pipelines:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer190">
<img alt="Figure 7.8 – Custom Pipelines dashboard with widgets" height="617" src="image/B18875_07_08.jpg" width="1122"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8 – Custom Pipelines dashboard with widgets</p>
<p>You can learn more about the widget catalog that’s included out of the box at <a href="https://learn.microsoft.com/en-us/azure/devops/report/dashboards/widget-catalog">https://learn.microsoft.com/en-us/azure/devops/report/dashboards/widget-catalog</a> and you can find more widgets by searching for them in the Visual Studio Marketplace <span class="No-Break">at </span><a href="https://marketplace.visualstudio.com/search?term=widgets&amp;target=AzureDevOps"><span class="No-Break">https://marketplace.visualstudio.com/search?term=widgets&amp;target=AzureDevOps</span></a><span class="No-Break">.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Another effective way to monitor your <a id="_idIndexMarker300"/>pipelines is via the <strong class="bold">Azure Pipelines Microsoft Teams app</strong> marketplace extension, which you can find in the marketplace catalog; upon clicking it, you will be taken to <strong class="bold">Microsoft App Source</strong> store. This application is a Teams app and is installed in your Teams tenant, which is outside the scope of this book. After you have installed it, you can configure subscriptions to the pipelines you want to get notified on pipeline status <span class="No-Break">or approvals.</span></p>
<p>Now, let’s learn how to monitor <span class="No-Break">pipeline agents.</span></p>
<h1 id="_idParaDest-93"><a id="_idTextAnchor093"/>Monitoring pipeline agents</h1>
<p>In Azure DevOps, pipeline agents<a id="_idIndexMarker301"/> provide some general reporting capabilities. They can be accessed by clicking <span class="No-Break"><strong class="bold">Organization settings</strong></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer191">
<img alt="Figure 7.9 – Accessing Organization settings" height="370" src="image/B18875_07_09.jpg" width="708"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9 – Accessing Organization settings</p>
<p>Once you are inside <strong class="bold">Organization settings</strong>, you will have access to the <strong class="bold">Agent pools</strong> option in the navigation menu under the <span class="No-Break"><strong class="bold">Pipelines</strong></span><span class="No-Break"> section:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer192">
<img alt="Figure 7.10 – Agent pools" height="367" src="image/B18875_07_10.jpg" width="995"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.10 – Agent pools</p>
<p>Let’s walk through each of the <span class="No-Break">available reports.</span></p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor094"/>Job runs</h2>
<p>You can use <a id="_idIndexMarker302"/>the <strong class="bold">job runs report</strong> for each agent pool, which will show a summary of the jobs that are being executed, including their ID, pipeline name, project, agent specification, when they were queued, wait time, <span class="No-Break">and duration:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer193">
<img alt="Figure 7.11 – Job reports in an agent pool" height="468" src="image/B18875_07_11.jpg" width="987"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.11 – Job reports in an agent pool</p>
<p>One of the most relevant pieces of data in this report is <strong class="bold">Wait time</strong>, which is highlighted in the preceding screenshot. This is something to pay close attention to. If this number starts increasing between jobs, it can be an indicator that you need to purchase concurrency and add <span class="No-Break">additional agents.</span></p>
<p>We will cover how to purchase concurrency and the approaches to increase the number of agents later in this section. For now, let’s continue to review the <span class="No-Break">available reports.</span></p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor095"/>Agent status</h2>
<p>In the agent pool <a id="_idIndexMarker303"/>details, you have an <strong class="bold">Agents</strong> tab, which gives you details about each agent that’s running, such as its name, availability, last run, current status, version, and the ability to <span class="No-Break">enable/disable it.</span></p>
<p>The following screenshot shows an unavailable or <span class="No-Break"><strong class="bold">Offline</strong></span><span class="No-Break"> agent:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer194">
<img alt="Figure 7.12 – Agent pool with an offline agent" height="217" src="image/B18875_07_12.jpg" width="793"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.12 – Agent pool with an offline agent</p>
<p>The following screenshot shows an available or <span class="No-Break"><strong class="bold">Online</strong></span><span class="No-Break"> agent:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer195">
<img alt="Figure 7.13 – Agent pool with an online agent" height="216" src="image/B18875_07_13.jpg" width="797"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.13 – Agent pool with an online agent</p>
<p>You must <a id="_idIndexMarker304"/>ensure that self-hosted agents are online and enabled when the agent pool is in use in your projects. Otherwise, pipeline jobs will be queued and never be executed if there are no <span class="No-Break">agents available.</span></p>
<p class="callout-heading">Pro tip</p>
<p class="callout">Always set up the agent to run as a service. This leverages the service manager of the operating system to ensure the life cycle of the agent is handled accordingly. It also improves the experience when auto-upgrading <span class="No-Break">the agent.</span></p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor096"/>Agent jobs</h2>
<p>From the previous <a id="_idIndexMarker305"/>agent status report, you also have access to the <strong class="bold">Jobs</strong> report for a specific agent, as shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer196">
<img alt="Figure 7.14 – Agent jobs report" height="216" src="image/B18875_07_14.jpg" width="922"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.14 – Agent jobs report</p>
<p>This is useful if <a id="_idIndexMarker306"/>you are trying to determine whether a specific agent is acting erratically or is having intermittent failures when running jobs. In this case, an agent version upgrade might be needed, dependencies tooling installed in the agent might need attention, or as a last resort, the agent should be removed along with the infrastructure where it is running and replaced with a <span class="No-Break">new one.</span></p>
<p>Now, let’s look at the most important report available for agent <span class="No-Break">pools: analytics.</span></p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor097"/>Analytics</h2>
<p>The <strong class="bold">Analytics </strong>report allows <a id="_idIndexMarker307"/>us to understand aggregated usage of the agents in the pool over time with histograms indicating concurrency, queued jobs, and running jobs, as shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer197">
<img alt="Figure 7.15 – Analytics report on an Azure Pipelines agent pool" height="687" src="image/B18875_07_15.jpg" width="848"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.15 – Analytics report on an Azure Pipelines agent pool</p>
<p>You will notice<a id="_idIndexMarker308"/> that the report includes two histograms – one for <strong class="bold">Public hosted concurrency</strong> and one for <strong class="bold">Private hosted concurrency</strong>. The public one refers to the allowance available in Azure Pipelines for public projects, which is 10 and cannot be changed. Similarly, the private one is for private projects, for which you can purchase additional parallel jobs at an additional cost or take advantage of a self-hosted pipeline agent that’s included with every Microsoft Visual Studio <span class="No-Break">Enterprise subscription.</span></p>
<p>This report helps us understand when there is a need for more agents when multiple jobs <span class="No-Break">are queued.</span></p>
<p>The infrequent occurrence of queued jobs could be ignored, but when they start happening often, we must consider the <span class="No-Break">following aspects:</span></p>
<ul>
<li><span class="No-Break">Purchasing concurrency</span></li>
<li>Increasing the <span class="No-Break">available agents</span></li>
</ul>
<p>Let’s talk about purchasing <span class="No-Break">concurrency first.</span></p>
<h3>Purchasing concurrency</h3>
<p>Adding<a id="_idIndexMarker309"/> concurrency to your agent pools applies to both Microsoft-hosted and self-hosted agents and the decision to increase it relies on your business need to not have wait times between job executions. This can be done by following <span class="No-Break">these steps:</span></p>
<ol>
<li>First, set up billing at the organization level, as shown in the <span class="No-Break">following figure:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer198">
<img alt="Figure 7.16 – Setting up billing for the Azure DevOps organization" height="479" src="image/B18875_07_16.jpg" width="851"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.16 – Setting up billing for the Azure DevOps organization</p>
<ol>
<li value="2">Clicking on the <strong class="bold">Set up billing</strong> button will open a dialog where you can link your Azure DevOps organization with an Azure subscription, which is used to pay for services in Azure DevOps. If you have access to an Azure subscription, select it and <span class="No-Break">click </span><span class="No-Break"><strong class="bold">Save</strong></span><span class="No-Break">:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer199">
<img alt="Figure 7.17 – Selecting an existing Azure subscription for billing" height="204" src="image/B18875_07_17.jpg" width="457"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.17 – Selecting an existing Azure subscription for billing</p>
<p class="list-inset">It is important to mention the Active Directory tenant you are logged in to is used to find Azure subscriptions you have access to and link them to the organization. You must be a member of <strong class="bold">Project Collation Administrators Group</strong> to complete <span class="No-Break">this step.</span></p>
<ol>
<li value="3">If you do not<a id="_idIndexMarker310"/> have an Azure subscription available, you will see a message similar to <span class="No-Break">the following:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer200">
<img alt="Figure 7.18 – Adding a new Azure subscription for billing" height="228" src="image/B18875_07_18.jpg" width="442"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.18 – Adding a new Azure subscription for billing</p>
<ol>
<li value="4">You can then click on the <strong class="bold">New Azure subscription</strong> button to complete the steps for creating a new subscription and provide credit card details to be billed for purchases. Once billing has been configured, you will be able to purchase concurrency by <a id="_idIndexMarker311"/>going to the <strong class="bold">Parallel jobs</strong> option under <strong class="bold">Project Settings</strong>. You can increase/decrease the number of parallel jobs <span class="No-Break">as needed:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer201">
<img alt="Figure 7.19 – Purchasing parallel jobs" height="650" src="image/B18875_07_19.jpg" width="845"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.19 – Purchasing parallel jobs</p>
<p>Now that we know how to purchase concurrency, let’s talk about how to increase the number of <span class="No-Break">available agents.</span></p>
<h3>Increasing the available agents</h3>
<p>In the case of<a id="_idIndexMarker312"/> Microsoft-hosted agents, purchasing additional concurrency is all that is needed to immediately gain the ability to execute multiple jobs since there is no infrastructure <span class="No-Break">to manage.</span></p>
<p>In the case of self-hosted agents, you have <span class="No-Break">some options:</span></p>
<ul>
<li>One option was discussed in the <em class="italic">Setting up agent pools</em> section in <a href="B18875_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, and it requires manually adding one agent to an <span class="No-Break">agent pool.</span></li>
<li>Another option is to use an <strong class="bold">Azure virtual machine scale set</strong> pool type, which is an option that becomes available when you add a new agent pool, as shown in the following screenshot. This type of agent pool automatically adds additional agents when the capacity is needed by monitoring the state of the current agents and the number of jobs in the queue every 5 minutes. You can configure the maximum number of agents and other parameters that control how each <a id="_idIndexMarker313"/>agent is handled within <span class="No-Break">the pool:</span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer202">
<img alt="Figure 7.20 – Azure virtual machine scale set agent pool type" height="227" src="image/B18875_07_20.jpg" width="458"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.20 – Azure virtual machine scale set agent pool type</p>
<p class="list-inset">The <strong class="bold">Azure virtual machine scale set</strong> agent pool type is very useful for the <span class="No-Break">following reasons:</span></p>
<ul>
<li>When you need more resources, such as CPU and memory, for the jobs to execute than the Microsoft-hosted ones and you don’t want to manage the <span class="No-Break">underlying infrastructure</span></li>
<li>To simplify how the base images of these agents are maintained or the need to reimage the agents after every job execution, which this agent pool type will <span class="No-Break">handle gracefully</span></li>
</ul>
<ul>
<li>One last option to consider is running <a id="_idIndexMarker314"/>a <strong class="bold">self-hosted agent</strong> in Docker containers, which allows you to run within any container orchestrator, such as your <a id="_idIndexMarker315"/>own self-managed Kubernetes <a id="_idIndexMarker316"/>cluster or cloud-managed services such as <strong class="bold">Azure Kubernetes Service</strong> (<strong class="bold">AKS</strong>) and Amazon <strong class="bold">Elastic Kubernetes Service</strong> (<strong class="bold">EKS</strong>). In this case, you would need a custom implementation to scale the<a id="_idIndexMarker317"/> number of agents in and out based on the metrics available in the Azure DevOps <span class="No-Break">REST API.</span></li>
</ul>
<p>Now that we’ve learned how to monitor job runs, agent status, and task performance and increase concurrency and the number of agents, let’s learn how to use monitoring in <span class="No-Break">our pipelines.</span></p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor098"/>Measuring application quality with monitoring</h1>
<p>Azure Pipelines provides <a id="_idIndexMarker318"/>many capabilities to measure the success of your build and release pipelines. First, we’ll learn how to improve the success of unit test results by measuring code <span class="No-Break">quality metrics.</span></p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor099"/>Code quality metrics</h2>
<p>Putting together a comprehensive <a id="_idIndexMarker319"/>unit tests pipeline includes analyzing every data point produced by the unit test runner framework and the tasks used to execute them in the pipeline. However, typically, there are limitations in terms of the metrics that are used by the task to determine failures on something other than the actual unit tests that <span class="No-Break">are executed.</span></p>
<p>For example, consider a development team that recently added unit tests to a project that has been developed for years and they are simply starting to implement tests to automate and reduce the need for <span class="No-Break">manual tests.</span></p>
<p>In this scenario, the general practice is to start with a small number of automated tests and work your way up to always increase that number of tests. The only way to enforce this within your pipelines is to continually monitor the unit test results and have an automated gate to evaluate this to ensure that the number is increased on <span class="No-Break">every run.</span></p>
<p>Assuming you completed the previous chapter, the following task will accomplish this scenario by adding it to the end of the YAML file for the unit test <span class="No-Break">build pipeline:</span></p>
<pre class="source-code">
- task: BuildQualityChecks@8
  inputs:
    checkCoverage: true
    coverageFailOption: 'build'
    coverageType: 'blocks'
    forceCoverageImprovement: true
    coverageUpperThreshold: '80'</pre> <p>You can find the <a id="_idIndexMarker320"/>complete file <span class="No-Break">at </span><span class="No-Break">https:</span><a href="https://github.com/PacktPublishing/Implementing-CI-CD-Using-Azure-Pipelines/blob/main/ch07/azure-pipelines.yml"><span class="No-Break">https://github.com/PacktPublishing/Implementing-CI-CD-Using-Azure-Pipelines/blob/main/ch07/azure-pipelines.yml</span></a></p>
<p> Let’s break this down to understand what this <span class="No-Break">task does:</span></p>
<ul>
<li>The <strong class="source-inline">checkCoverage: true</strong> option enables the policy that requires code coverage results to <span class="No-Break">be present.</span></li>
<li>Next, <strong class="source-inline">coverageFailOption: 'build'</strong> indicates the build will fail if code coverage is not increased when compared to the <span class="No-Break">previous build.</span></li>
<li><strong class="source-inline">coverageType: 'blocks'</strong> indicates that analysis will be done over the number of blocks of code. Other options include <strong class="source-inline">lines</strong>, <strong class="source-inline">branches</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">custom</strong></span><span class="No-Break">.</span></li>
<li><strong class="source-inline">forceCoverageImprovement: true</strong> will enforce that the value of the code coverage metric is always higher than that of the <span class="No-Break">previous run.</span></li>
<li>Finally, <strong class="source-inline">coverageUpperTreshold: '80'</strong> is the upper threshold for code coverage improvements. Typically, you will not strive for 100% code coverage as this implies every single line of code has a test associated with it, and in very large applications, this might not be realistic as it would require more development time. Once this value is reached, there will be no more enforcement <span class="No-Break">for improvement.</span></li>
</ul>
<p>Adding this to the previously configured <strong class="source-inline">UnitTests-YAML</strong> pipeline and making no additional changes will result in a failed execution because no tests are being added to increase the code<a id="_idIndexMarker321"/> <span class="No-Break">coverage metric:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer203">
<img alt="Figure 7.21 – Failing a build with quality checks" height="742" src="image/B18875_07_21.jpg" width="990"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.21 – Failing a build with quality checks</p>
<p>Now that we’ve learned how to use code quality metrics to enhance our pipelines, let’s see how we can <span class="No-Break">improve deployments.</span></p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor100"/>Deployment health</h2>
<p>CI/CD allows you to automate<a id="_idIndexMarker322"/> every aspect of the deployment process, including validating the application in the target environment after it has been deployed. This scenario provides a mechanism to ensure that no human intervention is required to verify that a new version of an application is working as expected and no new errors or bugs have been introduced by the developers or the <span class="No-Break">environment configuration.</span></p>
<p>Let’s look at a simple scenario first. Here, we’ll consider the <strong class="bold">Jenkins Artifacts</strong> release pipeline that we discussed in the previous chapter, in which we deployed an artifact from a <span class="No-Break">Jenkins job.</span></p>
<p>We didn’t explicitly<a id="_idIndexMarker323"/> add a step to verify that the <strong class="source-inline">artifact.txt</strong> file we expected was copied and made available to the agent. This can be addressed by adding a command-line task with a customized script, as shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer204">
<img alt="Figure 7.22 – Validating a task in a release pipeline" height="425" src="image/B18875_07_22.jpg" width="917"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.22 – Validating a task in a release pipeline</p>
<p>The script shown in the preceding screenshot works for an Ubuntu agent and verifies whether the <strong class="source-inline">artifact.txt</strong> file in the <strong class="source-inline">_PacktFamily</strong> directory exists; otherwise, it will print a message indicating that the file was not found and will exit with a return code of <strong class="source-inline">1</strong>. This will be interpreted as an error since the task is always expecting a return code of <strong class="source-inline">0</strong> <span class="No-Break">to succeed.</span></p>
<p>Let’s look at another scenario, say the deployment of a web application or Web API, for which you can write scripts that can issue an HTTP/HTTPS request to the application, wait for the response, and validate the response code <span class="No-Break">and content.</span></p>
<p>An even better scenario would be to use a UI-automated test framework and execute them as part of the release pipeline after the application has been deployed, just like the unit tests that we explored in the previous chapter. The following UI automated test frameworks are a few options <span class="No-Break">to consider:</span></p>
<ul>
<li><span class="No-Break"><strong class="bold">Open source</strong></span><span class="No-Break">:</span><ul><li><span class="No-Break"><strong class="bold">Appium</strong></span><span class="No-Break">: </span><a href="https://github.com/appium/appium"><span class="No-Break">https://github.com/appium/appium</span></a></li><li><strong class="bold">Robot </strong><span class="No-Break"><strong class="bold">Framework</strong></span><span class="No-Break">: </span><a href="https://robotframework.org/"><span class="No-Break">https://robotframework.org/</span></a></li><li><span class="No-Break"><strong class="bold">Selenium</strong></span><span class="No-Break">: </span><a href="https://www.selenium.dev/"><span class="No-Break">https://www.selenium.dev/</span></a></li></ul></li>
<li><span class="No-Break"><strong class="bold">Third-party</strong></span><span class="No-Break">:</span><ul><li><span class="No-Break"><strong class="bold">Cypress</strong></span><span class="No-Break">: </span><a href="https://www.cypress.io/"><span class="No-Break">https://www.cypress.io/</span></a></li><li><strong class="bold">Sauce </strong><span class="No-Break"><strong class="bold">Labs</strong></span><span class="No-Break">: </span><a href="https://saucelabs.com/"><span class="No-Break">https://saucelabs.com/</span></a></li><li><strong class="bold">Telerik Test </strong><span class="No-Break"><strong class="bold">Studio</strong></span><span class="No-Break">: </span><a href="https://www.telerik.com/teststudio"><span class="No-Break">https://www.telerik.com/teststudio</span></a></li></ul></li>
</ul>
<p>In more advanced scenarios, you can use <strong class="bold">gates</strong> in Azure Pipelines, which give you the ability to introduce automated points of control to evaluate conditions defined based on the task used. When using release pipelines, gates are available as pre-deployment and post-deployment conditions, but when using multi-stage pipelines with environments, gates are only available as post-conditions attached to <span class="No-Break">the environment.</span></p>
<p>We’ll explore one of these deployment gates using Azure <span class="No-Break">Monitor next.</span></p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor101"/>Integration with Azure Monitor</h2>
<p><strong class="bold">Azure Monitor</strong> is a <a id="_idIndexMarker324"/>monitoring solution for collecting, analyzing, and responding to logs and metrics from cloud and on-premises environments. This can help you understand how your applications and services are performing and provide the ability to manually and programmatically respond to conditions that require attention to ensure said applications keep working <span class="No-Break">as expected.</span></p>
<p>The integration capability in Azure Pipelines is provided via an <strong class="source-inline">AzureMonitor</strong> task, which allows you to query rules for active alerts and determine whether the deployment of a new version of an application has triggered <span class="No-Break">new alerts.</span></p>
<p>In this section, you will use a readily available template for release pipelines to easily configure the Azure <span class="No-Break">Monitor task.</span></p>
<p>To do this, perform<a id="_idIndexMarker325"/> the <span class="No-Break">following steps:</span></p>
<ol>
<li>Create a new release pipeline, as shown in the <span class="No-Break">following screenshot:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer205">
<img alt="Figure 7.23 – Creating a new release pipeline" height="404" src="image/B18875_07_23.jpg" width="600"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.23 – Creating a new release pipeline</p>
<ol>
<li value="2">Find the <strong class="bold">Azure App Service deployment with continuous monitoring</strong> template by <a id="_idIndexMarker326"/>searching for <strong class="source-inline">monitor</strong> in the search field and clicking on the <span class="No-Break"><strong class="bold">Apply</strong></span><span class="No-Break"> button:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer206">
<img alt="Figure 7.24 – Creating a new release pipeline from a template" height="198" src="image/B18875_07_24.jpg" width="622"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.24 – Creating a new release pipeline from a template</p>
<ol>
<li value="3">You will end up with a stage, as shown in the following screenshot, where you must fill out the <strong class="bold">App Service name</strong>, <strong class="bold">Resource Group name for Application Insights</strong>, and <strong class="bold">Application Insights resource </strong><span class="No-Break"><strong class="bold">name</strong></span><span class="No-Break"> fields:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer207">
<img alt="Figure 7.25 – Azure App Service deployment with continuous monitoring" height="605" src="image/B18875_07_25.jpg" width="945"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.25 – Azure App Service deployment with continuous monitoring</p>
<ol>
<li value="4">The most<a id="_idIndexMarker327"/> important step is the <strong class="bold">Configure Application Insights Alerts</strong> task, which uses the Azure CLI to create four different metrics-based alerts using an inline script: <strong class="source-inline">Availability_$(Release.DefinitionName)</strong>, <strong class="source-inline">FailedRequests_$(Release.DefinitionName)</strong>, <strong class="source-inline">ServerResponseTime_$(Release.DefinitionName),</strong> and <strong class="source-inline">ServerExceptions_$(Release.DefinitionName)</strong> with some default thresholds. You can use these defaults, adjust them, or create new alert definitions based on what is important for <span class="No-Break">your application:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer208">
<img alt="Figure 7.26 – Application Insights Alerts" height="295" src="image/B18875_07_26.jpg" width="677"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.26 – Application Insights Alerts</p>
<ol>
<li value="5">With this stage<a id="_idIndexMarker328"/> configured, you can switch to the pipeline view and click <strong class="bold">Post-deployment conditions</strong> to configure the gates, which in this case should already have <strong class="bold">Query Azure Monitor </strong><span class="No-Break"><strong class="bold">alerts</strong></span><span class="No-Break"> enabled:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer209">
<img alt="Figure 7.27 – Release pipeline post-deployment conditions in Stages" height="151" src="image/B18875_07_27.jpg" width="321"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.27 – Release pipeline post-deployment conditions in Stages</p>
<ol>
<li value="6">You can then adjust many of the settings related to the deployment gate accordingly, including the required <strong class="bold">Azure subscription</strong> and <strong class="bold">Resource group</strong> name and particularly <strong class="bold">The delay </strong><span class="No-Break"><strong class="bold">before evaluation</strong></span><span class="No-Break">:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer210">
<img alt="Figure 7.28 – The Query Azure Monitor alerts gate" height="704" src="image/B18875_07_28.jpg" width="627"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.28 – The Query Azure Monitor alerts gate</p>
<ol>
<li value="7">With this in<a id="_idIndexMarker329"/> place, you can rely on Azure Pipelines to execute the gate after the deployment steps are completed to verify that the monitoring alerts have been configured and provide a <span class="No-Break">visual indicator:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer211">
<img alt="Figure 7.29 – Successful release with deployment gates" height="335" src="image/B18875_07_29.jpg" width="907"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.29 – Successful release with deployment gates</p>
<p class="list-inset">In a complete scenario, you would combine automated tests in this release pipeline to ensure that the monitoring alerts are evaluated based on the tests being executed against the recently <span class="No-Break">deployed application.</span></p>
<ol>
<li value="8">Finally, you<a id="_idIndexMarker330"/> could use third-party application performance monitoring tools with the <a id="_idIndexMarker331"/>corresponding <a id="_idIndexMarker332"/>available <span class="No-Break">marketplace extensions:</span><ul><li><span class="No-Break"><strong class="bold">Dynatrace</strong></span><span class="No-Break">: </span><a href="https://marketplace.visualstudio.com/items?itemName=AlmaToolBoxCE.DynatraceIntegration"><span class="No-Break">https://marketplace.visualstudio.com/items?itemName=AlmaToolBoxCE.DynatraceIntegration</span></a></li><li><span class="No-Break"><strong class="bold">Datadog</strong></span><span class="No-Break">: </span><a href="https://marketplace.visualstudio.com/items?itemName=Datadog.datadog-monitors"><span class="No-Break">https://marketplace.visualstudio.com/items?itemName=Datadog.datadog-monitors</span></a></li></ul></li>
</ol>
<p>Now that you’ve learned about deployment gates, we’ve come to the end of this chapter. Let’s summarize what we’ve learned <span class="No-Break">so far.</span></p>
<h1 id="_idParaDest-102"><a id="_idTextAnchor102"/>Summary</h1>
<p>In this chapter, you learned about monitoring concepts to consider for your CI/CD projects and different ways to monitor your pipeline tasks, their performance, and how to build dashboards with graphical widgets to understand behavior over time and even integrate with a collaboration tool to get real-time notifications. You also learned how to monitor your job runs, task performance, and agents, when to purchase concurrency, and different options on how to increase the number of agents to ensure that pipelines execute promptly. Lastly, you learned how to measure quality in your pipelines by taking advantage of code quality metrics, application runtime checks, and application <span class="No-Break">monitoring tools.</span></p>
<p>In the next chapter, we are going to learn how to deploy infrastructure automatically with automation using <span class="No-Break">Azure Pipelines.</span></p>
</div>
</div></body></html>