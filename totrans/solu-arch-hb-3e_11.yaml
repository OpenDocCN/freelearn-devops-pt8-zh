- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: DevOps and Solution Architecture Framework
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DevOps 和解决方案架构框架
- en: In the previous chapter, you explored creating a cost-aware architecture and
    methods to continually optimize costs without compromising performance. Automation
    and collaboration across teams are crucial for developing robust applications
    and saving costs. This chapter will delve into DevOps, a methodology that fosters
    collaboration between development and operations teams while automating the processes
    of application deployment and monitoring.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你探索了如何创建一个关注成本的架构，并通过不断优化成本而不妥协性能。自动化和团队之间的协作对于开发强健的应用程序和节省成本至关重要。本章将深入探讨
    DevOps，一种促进开发和运维团队协作的方式，同时自动化应用程序部署和监控的过程。
- en: In traditional environments, the development team and the IT operations team
    work in silos. The development team gathers requirements from business owners
    and develops the applications. System administrators are solely responsible for
    operations and for meeting uptime requirements. These teams generally have little
    direct communication during the development life cycle, and each team rarely understands
    the processes and needs of the other team.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统环境中，开发团队和 IT 运维团队各自为政。开发团队从业务负责人那里收集需求并开发应用程序。系统管理员则单独负责操作和满足正常运行时间要求。这些团队在开发生命周期中通常很少进行直接沟通，每个团队也很少理解其他团队的流程和需求。
- en: Each team has its own tools, processes, and redundant approaches, sometimes
    resulting in conflict. For example, the development and **quality assurance**
    (**QA**) teams could test the build on a specific **operating system** (**OS**)
    patch. However, the operations team deploys the same build on a different OS version
    in the production environment, causing issues and delays in the delivery.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 每个团队都有自己的工具、流程和冗余方法，有时会导致冲突。例如，开发团队和**质量保证**（**QA**）团队可能会在特定的 **操作系统**（**OS**）补丁上测试构建。然而，运维团队将相同的构建部署到生产环境中的不同操作系统版本上，导致问题和交付延误。
- en: DevOps is a methodology that promotes collaboration and coordination between
    developers and operational teams to deliver products or services continuously.
    This approach is constructive in organizations where the teams rely on multiple
    applications, tools, technologies, platforms, databases, devices, and so on in
    the process of developing or delivering a product or service. Although there are
    different approaches to the DevOps culture, all are about achieving a common goal.
    DevOps is about delivering a product or service in the shortest amount of time
    by increasing operational efficiency through shared responsibilities.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 是一种方法论，旨在促进开发团队和运维团队之间的协作与协调，以持续交付产品或服务。这种方法在那些依赖于多个应用程序、工具、技术、平台、数据库、设备等的组织中，具有重要意义，尤其是在开发或交付产品或服务的过程中。虽然
    DevOps 文化有不同的实践方式，但其核心目标是一致的。DevOps 旨在通过共享责任来提高运营效率，从而以最短时间交付产品或服务。
- en: Security is the top priority for any application, and security incidents can
    have a severe business impact. Despite this, security is often an afterthought
    in the deployment process, treated as a separate concern handled reactively by
    specialized security teams within an organization.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是任何应用程序的首要任务，安全事件可能对业务造成严重影响。尽管如此，安全性在部署过程中往往被忽视，通常作为一个独立的问题，由组织内部的专业安全团队进行被动处理。
- en: Embedding security in the DevOps process as a crucial aspect can be achieved
    by implementing DevSecOps. DevSecOps is about integrating security early and throughout
    the software development life cycle, thus breaking down silos and fostering collaboration
    between development, operations, and security teams. DevSecOps helps deliver without
    compromising quality, reliability, stability, resilience, or security.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 将安全性嵌入到 DevOps 过程中的关键方面，可以通过实施 DevSecOps 来实现。DevSecOps 是将安全性早期且贯穿整个软件开发生命周期的一部分，从而打破信息孤岛，促进开发、运维和安全团队之间的协作。DevSecOps
    帮助在不妥协质量、可靠性、稳定性、韧性或安全性的情况下交付产品。
- en: 'In this chapter, you will learn about the following DevOps topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下 DevOps 主题：
- en: Introducing DevOps
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 DevOps
- en: Understanding the components of DevOps
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 DevOps 的组成部分
- en: Continuous integration/Continuous deployment (CI/CD)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成/持续部署（CI/CD）
- en: Introducing DevSecOps in security
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在安全领域介绍 DevSecOps
- en: Combining DevSecOps and CI/CD
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 DevSecOps 和 CI/CD 结合
- en: Implementing a CD strategy
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施 CD 策略
- en: Implementing continuous testing in the CI/CD pipeline
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 CI/CD 流水线中实施持续测试
- en: Using DevOps tools for CI/CD
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 DevOps 工具进行 CI/CD
- en: Implementing DevOps best practices
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施 DevOps 最佳实践
- en: Building DevOps and DevSecOps in the cloud
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在云中构建 DevOps 和 DevSecOps
- en: By the end of this chapter, you will have learned about the importance of DevOps
    in application deployment, testing, and security. You will also learn about the
    best practices of DevOps and DevSecOps and their different implementation tools
    and techniques.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解 DevOps 在应用部署、测试和安全中的重要性。你还将学习 DevOps 和 DevSecOps 的最佳实践以及它们的不同实施工具和技术。
- en: Introducing DevOps
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入 DevOps
- en: In a **DevOps** (short for **development and operations**) approach, the development
    and operations teams work collaboratively during the build and deployment phases
    of the software development life cycle, sharing responsibilities and providing
    continuous feedback. The software builds are tested frequently throughout the
    build phase in production-like environments, allowing the early detection of defects.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **DevOps**（即 **开发与运维**）方法中，开发与运维团队在软件开发生命周期的构建与部署阶段协作，共享责任并提供持续反馈。在构建阶段，软件构建会在类似生产环境中频繁测试，从而实现缺陷的早期发现。
- en: DevOps is a combination of culture and practices. It requires organizations
    to change their culture by breaking down the barriers between all teams in the
    product development and delivery life cycle. DevOps is not just about development
    and operations; it involves the entire organization, including management, business/application
    owners, developers, QA engineers, release managers, the operations team, and system
    administrators.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 是文化与实践的结合。它要求组织通过打破产品开发和交付生命周期中各个团队之间的壁垒来改变其文化。DevOps 不仅仅关乎开发和运维，它涉及到整个组织，包括管理层、业务/应用所有者、开发人员、QA
    工程师、发布经理、运维团队和系统管理员。
- en: Speed enables organizations to stay ahead of the competition and address customer
    requirements quickly. Good DevOps practices encourage software development engineers
    and operations professionals to work better together. This results in closer collaboration
    and communication, leading to a shorter **time to market**, reliable release,
    improved code quality, and better maintenance.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 高速度使得组织能够保持领先于竞争对手，并快速响应客户需求。良好的 DevOps 实践鼓励软件开发工程师与运维专业人员更好地合作。这导致了更加紧密的协作与沟通，从而缩短了
    **上市时间**，确保了可靠的发布，提高了代码质量，并改善了维护工作。
- en: Sometimes with DevOps, you will find that a software application’s development
    and operations are handled by a single team, where engineers work across the entire
    application life cycle. Such a team needs to develop a range of skills that are
    not limited to a single function. Application testing and security teams may also
    work more closely with the operations and development teams from the inception
    to the production launch of an application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在 DevOps 中，你会发现软件应用的开发和运维由同一个团队处理，工程师会贯穿整个应用生命周期工作。这样的团队需要培养一系列不局限于单一职能的技能。应用测试和安全团队也可能会在应用的创建到生产发布的整个过程中与开发和运维团队更紧密地合作。
- en: Developers benefit from feedback provided by the operations teams and create
    strategies for testing and deployment.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员受益于运维团队提供的反馈，并制定测试和部署策略。
- en: System administrators don’t have to implement defective or untested software
    in production environments because they participate in the *build phase*. As all
    software development and delivery life cycle stakeholders collaborate, they can
    also evaluate the tools they intend to use at each step of the process, verify
    compatibility between the devices, and determine whether any tools can be shared
    across the teams.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 系统管理员不必在生产环境中部署有缺陷或未经测试的软件，因为他们参与了 *构建阶段*。随着所有软件开发与交付生命周期的利益相关者共同协作，他们还可以在每个步骤中评估计划使用的工具，验证设备之间的兼容性，并判断是否有任何工具可以跨团队共享。
- en: DevOps is gaining popularity as the preferred operating culture, especially
    for organizations that leverage cloud or distributed computing technologies. Let’s
    learn about some of the various benefits of DevOps and why it is essential for
    your application workload.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 正在成为一种日益流行的操作文化，特别适用于那些利用云计算或分布式计算技术的组织。让我们了解一下 DevOps 的一些主要好处，以及它为何对你的应用工作负载至关重要。
- en: Understanding the benefits of DevOps
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解 DevOps 的好处
- en: The goal of DevOps is a **CI/CD** model that can be utilized to make the software
    development life cycle repeatable, reliable, stable, resilient, and secure. These
    characteristics of the model help in improving operational efficiency. To achieve
    this goal, teams must collaborate and participate in the development and delivery
    process. All technical team members should have experience with the processes
    and tools involved in the development pipeline.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 的目标是实现 **CI/CD** 模型，利用该模型使软件开发生命周期变得可重复、可靠、稳定、弹性强且安全。这些模型特性有助于提高操作效率。为了实现这一目标，团队必须在开发和交付过程中进行协作与参与。所有技术团队成员应具备开发流水线中涉及的过程和工具经验。
- en: 'A mature DevOps process provides a number of benefits, as shown in the following
    diagram:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个成熟的 DevOps 过程提供了许多好处，如下图所示：
- en: '![](img/B21336_11_01.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21336_11_01.png)'
- en: 'Figure 11.1: Benefits of DevOps'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1：DevOps 的好处
- en: 'The benefits provided by DevOps are elaborated on here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 提供的好处在这里有详细说明：
- en: '**Speed**: Releasing product features faster helps to accommodate your customers’
    changing business needs and expand your market. A DevOps model enables an organization
    to achieve results faster.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：更快地发布产品功能有助于适应客户不断变化的业务需求，并扩大市场份额。DevOps 模型使组织能够更快地取得成果。'
- en: '**Fast delivery**: DevOps processes facilitate efficiency by automating end-to-end
    pipelines, from code build to code deployment and production launch. Rapid delivery
    helps you to innovate faster. The faster release of bug fixes and features allows
    you to gain a competitive edge.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速交付**：DevOps 过程通过自动化端到端的流水线，提高效率，从代码构建到代码部署再到生产上线。快速交付帮助你更快地进行创新。更快的 bug
    修复和功能发布让你能获得竞争优势。'
- en: '**Reliability**: DevOps processes provide checks to ensure delivery quality
    and the safety of rapid application updates. DevOps practices like CI and CD embed
    automation testing and security checks for a positive end-user experience.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠性**：DevOps 过程提供检查，以确保交付质量和快速应用更新的安全性。像 CI 和 CD 这样的 DevOps 实践嵌入了自动化测试和安全检查，以确保用户体验良好。'
- en: '**Scalability**: DevOps helps to scale your infrastructure and application
    on an on-demand basis by including automation everywhere.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：DevOps 通过在各个环节中引入自动化，帮助按需扩展你的基础设施和应用。'
- en: '**Collaboration**: The DevOps model builds a culture of ownership whereby the
    teams consider their actions. The operations and dev teams work together in a
    shared responsibility model. Collaboration simplifies the process and increases
    efficiency.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协作**：DevOps 模型建立了一种所有权文化，团队考虑自己的行动。运维团队和开发团队在共享责任模型中共同工作。协作简化了过程，提高了效率。'
- en: '**Security**: In an agile environment, frequent changes require stringent security
    checks. The DevOps model automates security and compliance best practices, monitors
    them, and takes corrective action in an automated way.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：在敏捷环境中，频繁的变化需要严格的安全检查。DevOps 模型自动化了安全和合规性最佳实践，监控这些实践，并以自动化方式采取纠正措施。'
- en: Teams take full ownership of the services they deliver, often beyond the traditional
    scope of their roles, and develop thinking from a customer point of view to solve
    any issue. Let’s look at understanding the different components of DevOps processes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 团队对其交付的服务承担完全责任，通常超出传统角色的范围，并从客户角度思考，解决任何问题。让我们深入了解 DevOps 过程的不同组件。
- en: Understanding the components of DevOps
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 DevOps 的组件
- en: 'DevOps tools and automation bring together development and system operations.
    The following are the critical components of a DevOps practice:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 工具和自动化将开发与系统运维结合在一起。以下是 DevOps 实践中的关键组件：
- en: CI/CD
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI/CD
- en: Continuous monitoring and improvement
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续监控和改进
- en: Infrastructure as code
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施即代码
- en: Configuration management
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置管理
- en: A common best practice across all the elements is **automation**. Automation
    can involve scripts, templates, and other tools. In a thriving DevOps environment,
    infrastructure is managed as code. Automation enables DevOps teams to set up and
    tune test and production environments rapidly. Let’s explore more details about
    each component.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所有元素中的一个常见最佳实践是**自动化**。自动化可以包括脚本、模板和其他工具。在一个蓬勃发展的 DevOps 环境中，基础设施以代码形式进行管理。自动化使
    DevOps 团队能够快速搭建和调整测试与生产环境。让我们深入了解每个组件的更多细节。
- en: Continuous integration/Continuous deployment
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续集成/持续部署
- en: In **CI**, developers commit code frequently to a code repository. The code
    is built frequently. Each build is tested using automated unit tests and integration
    tests. In **CD**, you go further and frequently deploy your code in production.
    Builds are deployed to test environments and are tested using automated and possibly
    manual tests. Successful builds pass tests and are deployed to staging or production
    environments.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在**CI**中，开发者频繁地将代码提交到代码库。代码会频繁地进行构建。每次构建都会使用自动化单元测试和集成测试进行测试。在**CD**中，你会进一步操作，频繁地将代码部署到生产环境中。构建被部署到测试环境中，并通过自动化或手动测试进行验证。成功的构建通过测试后，会部署到预发布或生产环境中。
- en: 'The following diagram illustrates the impact of CI versus CD in the software
    development life cycle:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了CI与CD在软件开发生命周期中的影响：
- en: '![](img/B21336_11_02.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21336_11_02.png)'
- en: 'Figure 11.2: CI/CD'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2：CI/CD
- en: As shown in the preceding diagram, CI refers to the software development life
    cycle’s building and unit testing stages. Every update that is committed in the
    code repository creates an automated build and test. The CD is an essential aspect
    of CI that extends the CI process further to deploy the build in production. In
    CI/CD practices, several people work on the code. They all must use the latest
    working build for their efforts. Code repositories maintain different versions
    of the code and also make the code accessible to the team. You check out the code
    from the repository, make changes, write new code in your local copy, compile
    and test your code, and frequently commit your code back to the main repository.
    In CI/CD, software development life cycle phases such as code, build, deploy,
    and test are automated using the DevOps pipeline.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，CI指的是软件开发生命周期中的构建和单元测试阶段。每次提交到代码库的更新都会触发自动构建和测试。CD是CI的重要组成部分，它将CI过程扩展到将构建部署到生产环境中。在CI/CD实践中，多个开发者共同参与代码开发，他们都必须使用最新的工作版本进行开发。代码库保持不同版本的代码，并使团队能够访问这些代码。你从代码库中检出代码，进行更改，在本地副本中编写新代码，编译和测试代码，并频繁地将代码提交回主代码库。在CI/CD中，代码、构建、部署和测试等软件开发生命周期阶段是通过DevOps管道自动化的。
- en: CI automates most of the software release process. It creates an automated flow
    that builds, tests, and then stages the update. However, a developer must trigger
    the final deployment to a live production environment that is not automated. It
    expands upon CD by deploying all code changes to testing and/or production environments
    after the build stage. Developers will always have a tested and deployment-ready
    build if CD is implemented correctly.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: CI自动化了大部分软件发布过程。它创建了一个自动化流程，完成构建、测试和更新的准备工作。然而，开发者仍然需要触发最终的部署到实时生产环境，这一过程是不可自动化的。CD通过在构建阶段之后，将所有代码更改部署到测试和/或生产环境，进一步扩展了CI的功能。如果CD正确实施，开发者将始终拥有经过测试且准备好部署的构建版本。
- en: 'The following diagram illustrates everything related to the automation of an
    application, ranging from code commits into a code repo to the deployment pipeline.
    It shows an end-to-end flow from the build to the production environment, where
    the developer checks the code change into the code repository, which the CI server
    pulls. The CI server triggers the build to create a deployment package with new
    application binaries and corresponding dependencies. These new binaries are deployed
    in a targeted development or testing environment. Binaries also get checked into
    the artifact repository for safe version-controlled storage:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了与应用程序自动化相关的所有内容，从代码提交到代码库，再到部署管道。它展示了从构建到生产环境的端到端流程，开发者将代码更改提交到代码库，CI服务器从中拉取代码。CI服务器触发构建，生成一个包含新应用程序二进制文件和相应依赖项的部署包。这些新的二进制文件被部署到目标开发或测试环境中。二进制文件还被提交到构件库中，以进行版本控制和安全存储：
- en: '![](img/B21336_11_03.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21336_11_03.png)'
- en: 'Figure 11.3: CI/CD for DevOps'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3：CI/CD与DevOps
- en: A robust CD pipeline also automates the provisioning of infrastructure for testing
    and production environments and enables the monitoring and management of test
    and production environments. CD does not mean that every change committed by the
    developer goes into production. Instead, it means that every change is *ready*
    to go into production. When the changes are staged and tested in the stage environment,
    a manual approval process initiates and gives a green signal to deploy to production.
    Thus, in CD, deploying to production becomes a business decision and is still
    automated with tools.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 强大的CD流水线还可以自动化测试和生产环境的基础设施配置，并使测试和生产环境的监控与管理成为可能。CD并不意味着开发者提交的每个更改都进入生产环境。而是意味着每个更改都已*准备好*进入生产环境。当更改在阶段环境中进行预部署和测试时，手动审批流程会启动，并给出绿色信号进行生产部署。因此，在CD中，部署到生产环境成为了一个商业决策，且仍然是自动化的工具。
- en: Continuous monitoring and improvement
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续监控与改进
- en: Continuous monitoring helps us to understand the impact of application and infrastructure
    performance on the customer. You can learn how code changes impact users by analyzing
    data and logs. Active monitoring is essential in the era of 24/7 services and
    constant updates to applications and infrastructure.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 持续监控帮助我们理解应用程序和基础设施的性能对客户的影响。通过分析数据和日志，你可以了解代码更改如何影响用户。主动监控在24/7服务和不断更新应用程序及基础设施的时代变得至关重要。
- en: You can proactively monitor services by creating alerts and performing real-time
    analysis. You can track various metrics to monitor and improve your DevOps practice.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过创建警报并进行实时分析来主动监控服务。你可以跟踪各种指标，以监控并改进你的DevOps实践。
- en: 'Examples of DevOps-related metrics are as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与DevOps相关的指标示例：
- en: '**Change volume**: This is the number of user stories developed, the number
    of lines of new code, and the number of bugs fixed.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变更量**：这是开发的用户故事数量、新代码的行数和修复的bug数量。'
- en: '**Deployment frequency**: This indicates how often a team is deploying an application.
    This metric should generally remain stable or show an upward trend.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署频率**：这表示团队部署应用程序的频率。这个指标通常应该保持稳定或呈上升趋势。'
- en: '**Lead time from development to deployment**: The time between the beginning
    of a development cycle and the end of deployment can be used to identify inefficiencies
    in the intermediate steps of the release cycle.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从开发到部署的交付时间**：从开发周期开始到部署结束的时间可以用来识别发布周期中间步骤的低效之处。'
- en: '**Percentage of failed deployments**: The percentage of failed deployments,
    including the number of deployments that resulted in outages, should be low.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**失败部署的百分比**：失败部署的百分比，包括导致故障的部署次数，应该保持在较低水平。'
- en: This metric should be reviewed in conjunction with the change volume. Analyze
    potential points of failure if the change volume is low but the number of failed
    deployments is high.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个指标应该与变更量一起审查。如果变更量较低，但失败的部署次数较高，应分析潜在的失败点。
- en: '**Availability**: Track how many releases caused failures that possibly resulted
    in violations of **service-level agreements** (**SLAs**). What is the average
    downtime for the application?'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：跟踪导致故障的发布，可能会导致违反**服务级别协议**（**SLA**）的情况。应用程序的平均停机时间是多少？'
- en: '**Customer complaint volume**: The number of complaint tickets filed by customers
    indicates the quality of your application.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户投诉量**：客户提交的投诉工单数量表明了应用程序的质量。'
- en: '**Percentage change in user volume**: The number of new users signing up to
    use your application and the resulting increase in traffic can help you scale
    your infrastructure to match the workload.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户量变化百分比**：新用户注册使用你的应用程序的数量以及随之而来的流量增加，可以帮助你扩展基础设施以匹配工作负载。'
- en: After your deploy builds to the production environment, monitoring your application’s
    performance is essential. As we discussed automating environments, let’s explore
    **Infrastructure as code** (**IaC**) in detail.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在将部署构建到生产环境后，监控应用程序的性能至关重要。正如我们讨论的自动化环境一样，让我们详细探讨一下**基础设施即代码**（**IaC**）。
- en: Infrastructure as code
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础设施即代码
- en: Provisioning, managing, and even deprecating infrastructure is a costly activity
    in terms of human effort. Furthermore, errors can be made by repeated attempts
    to build and modify environments manually. Whether working from prior experience
    or a well-documented runbook, the tendency for a human to make a mistake is a
    statistical probability.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 提供、管理甚至废弃基础设施在人工成本上是一项昂贵的活动。此外，通过反复尝试手动构建和修改环境，可能会出现错误。无论是基于以往经验还是一本详细的运行手册，人类犯错的倾向始终是一个统计概率。
- en: We can automate the task of creating a complete environment. Task automation
    can help to complete repetitive tasks and provide significant value effortlessly.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过自动化任务来创建完整的环境。任务自动化有助于完成重复性任务，并能毫不费力地提供显著价值。
- en: With IaC, we can define our infrastructure in the form of **templates**. A single
    template may consist of a part or the entirety of an environment. More importantly,
    this template can be used repeatedly to create the same environment again.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 IaC，我们可以以 **模板** 的形式定义基础设施。一个模板可以包含部分或整个环境。更重要的是，这个模板可以反复使用，以便再次创建相同的环境。
- en: In IaC, infrastructure is spun up and managed using code. An IaC model helps
    you interact with infrastructure programmatically at scale and avoid human errors
    by automating resource configuration. That way, you can work with infrastructure
    the same way you would with code by using code-based tools. As the infrastructure
    is managed through code, the application can be deployed using a standardized
    method, and any patches and versions can be updated repeatedly without errors.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IaC 中，基础设施是通过代码进行创建和管理的。IaC 模型帮助你以编程方式与基础设施互动，并通过自动化资源配置避免人为错误。这样，你就可以像使用代码一样使用代码工具来处理基础设施。由于基础设施是通过代码管理的，应用程序可以使用标准化方法进行部署，任何补丁和版本都可以反复更新且不会出错。
- en: Some of the most popular IaC scripting tools are Ansible, Terraform, Azure Resource
    Manager, Google Cloud Deployment Manager, Chef, Puppet, AWS **Cloud Development
    Kit** (**CDK**) and AWS CloudFormation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最受欢迎的基础设施即代码（IaC）脚本工具包括 Ansible、Terraform、Azure 资源管理器、Google Cloud 部署管理器、Chef、Puppet、AWS
    **云开发工具包**（**CDK**）和 AWS CloudFormation。
- en: The following is a code sample from AWS CloudFormation, which provides IaC capability
    to automate infrastructures on the AWS cloud platform.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是来自 AWS CloudFormation 的代码示例，它提供了 IaC 功能，可以自动化 AWS 云平台上的基础设施。
- en: '[PRE0]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code creates Amazon S3 object storage with an option for the
    user to provide their choice of storage name, as shown below:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了 Amazon S3 对象存储，并为用户提供了存储名称的选项，具体如下所示：
- en: '![](img/B21336_11_04.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21336_11_04.png)'
- en: 'Figure 11.4: IaC using AWS CloudFormation'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4：使用 AWS CloudFormation 的 IaC
- en: 'After execution of the code, the Amazon S3 bucket gets created, as you can
    see in **Resources**:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 执行代码后，Amazon S3 桶会被创建，正如在**资源**中看到的：
- en: '![](img/B21336_11_05.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21336_11_05.png)'
- en: 'Figure 11.5: Automated AWS S3 object storage creation using AWS CloudFormation'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5：使用 AWS CloudFormation 自动化创建 AWS S3 对象存储
- en: 'Multiple teams can use the provided code to create any amount of Amazon S3
    storage. As data is so essential, the admin chose to add bucket `"DeletionPolicy":
    "Retain,"` which ensures storage doesn’t get deleted when infrastructure comes
    down and that data is safe.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '多个团队可以使用提供的代码创建任意数量的 Amazon S3 存储。由于数据至关重要，管理员选择添加 `"DeletionPolicy": "Retain,"`
    来确保当基础设施关闭时存储不会被删除，数据也得到了保护。'
- en: You can see how you can implement standardization, consistency, and compliance
    across organizations using IaC. Configuration management is another vital aspect
    of the DevOps process. Let’s learn more about it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到如何使用 IaC 在组织中实现标准化、一致性和合规性。配置管理是 DevOps 过程中的另一个重要方面。让我们进一步了解它。
- en: Configuration management
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置管理
- en: '**Configuration management** (**CM**) is the process of using automation to
    standardize resource configurations across your entire infrastructure and applications.
    CM tools such as Chef, Puppet, and Ansible can help you manage IaC and automate
    most system administration tasks, including provisioning, configuring, and managing
    IT resources.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**配置管理**（**CM**）是通过自动化的方式，标准化整个基础设施和应用程序的资源配置的过程。像 Chef、Puppet 和 Ansible 这样的
    CM 工具可以帮助你管理 IaC 并自动化大部分系统管理任务，包括资源的提供、配置和管理。'
- en: By automating and standardizing resource configurations across the development,
    build, test, and deployment phases, you can ensure consistency and eliminate failures
    caused by misconfiguration. CM can also increase the productivity of your operations
    by allowing you to deploy the same configuration to hundreds of servers automatically
    at the push of a button. CM can also be leveraged to deploy changes to configurations.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过自动化和标准化开发、构建、测试和部署阶段的资源配置，你可以确保一致性并消除因配置错误导致的故障。配置管理（CM）还可以通过允许你通过一键操作将相同的配置自动部署到数百台服务器，来提高运营效率。CM
    还可以用于部署配置更改。
- en: Although you can use registry settings or databases to store system configuration
    settings, a CM application allows you to maintain version control as well, in
    addition to storage. CM is also a way to track and audit configuration changes.
    If necessary, you can even maintain multiple configuration settings versions for
    various software versions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以使用注册表设置或数据库来存储系统配置设置，CM 应用程序还允许你在存储之外进行版本控制。CM 也是一种跟踪和审计配置更改的方法。如果需要，你甚至可以为不同的软件版本维护多个配置设置版本。
- en: CM tools include a controller machine that manages server nodes. For example,
    Chef requires a client agent application installed on each server to manage, and
    a master Chef application is installed on the controller machine. Puppet also
    works the same way with a centralized server. However, Ansible has a decentralized
    approach that doesn’t require installing agent software on the server nodes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: CM 工具包括一个控制机来管理服务器节点。例如，Chef 需要在每台服务器上安装客户端代理应用程序进行管理，并且在控制机上安装主 Chef 应用程序。Puppet
    也以类似方式工作，通过一个集中的服务器。然而，Ansible 采用去中心化的方法，不需要在服务器节点上安装代理软件。
- en: 'The following table shows a high-level comparison between the various popular
    configuration management tools:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下表展示了各类流行的配置管理工具之间的高层次对比：
- en: '|  | **Ansible** | **Puppet** | **Chef** |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|  | **Ansible** | **Puppet** | **Chef** |'
- en: '| **Mechanism** | Controller machine applies changes to servers using **Secure
    Shell** (**SSH**) | Master synchronizes changes to Puppet node | The Chef workstation
    looks for changes in Chef servers and pushes them to the Chef node. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| **机制** | 控制机通过**安全外壳协议**（**SSH**）将更改应用到服务器 | 主机将更改同步到 Puppet 节点 | Chef 工作站寻找
    Chef 服务器中的更改并将其推送到 Chef 节点。 |'
- en: '| **Architecture** | Any server can be the controller | Centralized control
    by the Puppet master | Centralized control by Chef server |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **架构** | 任何服务器都可以是控制机 | 由 Puppet 主机进行集中控制 | 由 Chef 服务器进行集中控制 |'
- en: '| **Script Language** | YAML | Domain-specific on Ruby | Ruby |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **脚本语言** | YAML | Ruby 中的特定领域语言 | Ruby |'
- en: '| **Scripting Terminology** | Playbook and roles | Manifests and modules |
    Recipes and cookbooks |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **脚本术语** | Playbook 和角色 | Manifests 和模块 | 配方和食谱 |'
- en: '| **Test Execution** | Sequential order | Non-sequential order | Sequential
    order |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| **测试执行** | 顺序执行 | 非顺序执行 | 顺序执行 |'
- en: Table 11.1 – Popular CM tools comparison chart
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.1 – 流行 CM 工具对比表
- en: 'CM tools provide a domain-specific language and set of features for automation.
    Some of these tools have a steep learning curve whereby the team has to learn
    the tool. AWS provides a managed platform called OpsWorks to manage Chef and Puppet
    in the cloud. It provides various attributes to manage IT infrastructure through
    automation, as shown below:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: CM 工具提供了一个特定领域的语言和一组自动化功能。其中一些工具有陡峭的学习曲线，团队需要学习如何使用这些工具。AWS 提供了一个名为 OpsWorks
    的托管平台，用于在云中管理 Chef 和 Puppet。它提供了多种属性来通过自动化管理 IT 基础设施，如下所示：
- en: '![](img/B21336_11_06.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21336_11_06.png)'
- en: 'Figure 11.6: AWS OpsWorks service capabilities for managed Chef and Puppet'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11.6: AWS OpsWorks 服务在管理 Chef 和 Puppet 中的功能'
- en: Security has become a priority for any organization, so complete security automation
    is the need of the hour. Organizations are moving to tight security implementations
    and monitoring to avoid human error, using the DevOps process popularly known
    as **DevSecOps**. In the next section, let’s explore **DevSecOps** (short for
    **development, security, and operations**).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性已经成为任何组织的优先事项，因此完全的安全自动化是当务之急。组织正在转向严格的安全实施和监控，以避免人为错误，采用被广泛称为**DevSecOps**的
    DevOps 流程。在下一节中，让我们一起探讨 **DevSecOps**（即 **开发、安全和运营** 的缩写）。
- en: Introducing DevSecOps for Security
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入 DevSecOps 以增强安全性
- en: We are now more focused on security than ever. In many situations, security
    is the only way to win customer trust. DevSecOps is about the automation of security
    and the implementation of security at scale. The development team constantly makes
    changes, and the DevOps team publishes them in production (changes are often customer-facing).
    DevSecOps ensures application security in the overall process.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在比以往任何时候都更加关注安全。在许多情况下，安全是赢得客户信任的唯一途径。DevSecOps 旨在实现安全的自动化，并大规模地实施安全。开发团队不断进行更改，DevOps
    团队将这些更改发布到生产环境中（这些更改通常面向客户）。DevSecOps 确保在整个过程中应用程序的安全性。
- en: DevSecOps is not there to audit code or CI/CD artifacts. Organizations should
    implement DevSecOps to enable speed and agility, but not at the expense of validating
    security which slows down the development and deployment process. The power of
    automation is in increasing product feature launch agility while implementing
    the required security measures. A DevSecOps approach results in built-in security;
    security is not applied only as an afterthought. DevOps is about adding efficiency
    to speed up the product launch life cycle, while DevSecOps validates all building
    blocks without slowing the life cycle.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: DevSecOps 不是用来审计代码或 CI/CD 工件的。组织应该实施 DevSecOps 以提高速度和敏捷性，但前提是不能以牺牲安全性为代价，因为安全验证会拖慢开发和部署过程。自动化的力量在于提高产品功能发布的敏捷性，同时实施所需的安全措施。DevSecOps
    方法带来了内建的安全性；安全性不是事后才加上的。DevOps 旨在提高效率，以加速产品发布生命周期，而 DevSecOps 则验证所有构建模块，而不会拖慢生命周期。
- en: To institute a DevSecOps approach in your organization, start with a solid DevOps
    foundation across the development environment, as security is everyone’s responsibility.
    It would be best to embed security in the architecture design from inception to
    create collaboration between development and security teams. Automate continuous
    security testing and build it into the CI/CD pipeline to avoid any security gaps.
    To keep track of any security breach, extend monitoring to include security and
    compliance by monitoring for drift from the design state in real time. Monitoring
    should enable alerting, automated remediation, and removal of non-compliant resources.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要在组织中建立 DevSecOps 方法，首先要在开发环境中建立一个坚实的 DevOps 基础，因为安全是每个人的责任。从一开始就将安全嵌入架构设计中，以便在开发和安全团队之间创造协作关系，是最理想的做法。自动化持续的安全测试，并将其纳入
    CI/CD 管道，以避免任何安全漏洞。为了跟踪任何安全漏洞，要扩展监控，实时监控设计状态的漂移，确保包括安全和合规性。监控应能够启用警报、自动修复和移除不合规的资源。
- en: Codifying everything is an essential requirement that opens up infinite possibilities.
    DevSecOps aims to keep the pace of innovation, which should meet the pace of security
    automation. A scalable infrastructure needs scalable security, requiring automatic
    incident response remediation to implement continuous compliance and validation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对一切进行编码是打开无限可能的关键要求。DevSecOps 的目标是保持创新的步伐，而这种步伐应当与安全自动化的步伐相匹配。可扩展的基础设施需要可扩展的安全性，这需要自动化事件响应修复来实施持续的合规性和验证。
- en: Combining DevSecOps and CI/CD
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合 DevSecOps 和 CI/CD
- en: A DevSecOps practice must be embedded with every CI/CD pipeline step. DevSecOps
    ensures the security of the CI/CD pipeline by managing the proper access and roles
    assigned to each server and making sure the build servers, such as Jenkins, are
    hardened to be protected from any security glitch. In addition to that, we need
    to ensure that all artifacts are validated, and code analysis is in place.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: DevSecOps 实践必须嵌入每个 CI/CD 管道步骤。DevSecOps 通过管理每台服务器分配的适当访问权限和角色来确保 CI/CD 管道的安全，并确保构建服务器（如
    Jenkins）已加固，能防止任何安全漏洞。此外，我们还需要确保所有工件都经过验证，并且代码分析已经到位。
- en: It’s advisable to be ready for incident response by automating continuous compliance
    validation and incident response remediation. For instance, if an organization
    needs to comply with the Payment Card Industry Data Security Standard (PCI-DSS),
    continuous compliance validation would involve setting up automated tools and
    processes to constantly check that the handling, processing, and storage of credit
    card information meet PCI-DSS requirements.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 建议通过自动化持续的合规性验证和事件响应修复来为事件响应做好准备。例如，如果一个组织需要遵守支付卡行业数据安全标准（PCI-DSS），那么持续的合规性验证就包括设置自动化工具和流程，以不断检查信用卡信息的处理、存储和传输是否符合
    PCI-DSS 要求。
- en: 'The following diagram provides us with multiple stages to test security boundaries
    and catch security issues and ensure compliance with policies as early as possible:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下图为我们提供了多个阶段，用于测试安全边界、捕获安全问题，并尽早确保符合政策：
- en: '![](img/B21336_11_07.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21336_11_07.png)'
- en: 'Figure 11.7: DevSecOps and CI/CD'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7：DevSecOps与CI/CD
- en: 'At each integration point, you can identify different issues, as illustrated
    in the preceding diagram:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个集成点，你可以识别不同的问题，如前面的图示所示：
- en: In the **Code** phase, scan all code to ensure no secret or access key is hardcoded
    between code lines.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**代码**阶段，扫描所有代码，确保没有硬编码的秘密或访问密钥在代码行之间。
- en: During the **Build** phase, include all security artifacts, such as the encryption
    key and access token management, and tag them for easy identification.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**构建**阶段，包含所有安全工件，例如加密密钥和访问令牌管理，并为它们添加标签以便于识别。
- en: During the **Test** phase, scan the configuration to make sure all security
    standards are met by test security.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**测试**阶段，扫描配置以确保所有安全标准都已通过测试安全检查。
- en: In the **Deploy** and **Provision** phases, ensure all security components are
    registered. Perform a checksum to ensure no changes in the build files. A checksum
    is a technique used to determine the authenticity of received files. Operating
    systems provide a `checksum` command to validate the file and ensure no changes
    are made during file transfer.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**部署**和**配置**阶段，确保所有安全组件已注册。执行校验和以确保构建文件没有变化。校验和是一种用于确定接收文件的真实性的技术。操作系统提供了`checksum`命令来验证文件，并确保在文件传输过程中没有任何变化。
- en: Monitor all security standards during the **Monitor** phase. Perform continuous
    audits and validation in an automated way.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**监控**阶段，监控所有安全标准。执行持续审计和自动化验证。
- en: You can integrate multiple tools into DevSecOps pipelines to identify security
    vulnerabilities at various stages and aggregate the vulnerability findings.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将多个工具集成到DevSecOps管道中，以在不同阶段识别安全漏洞，并聚合漏洞发现结果。
- en: '**Application security testing** (**AST**), which involves using tools to automate
    the testing, analysis, and reporting of security vulnerabilities, is a critical
    component of application development. AST can be broken down into the following
    four categories to scan security vulnerabilities in software applications:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用安全测试**（**AST**），即使用工具自动化测试、分析和报告安全漏洞，是应用开发的关键组成部分。AST可以分为以下四个类别，用于扫描软件应用中的安全漏洞：'
- en: '**Software composite analysis** (**SCA**): SCA evaluates the open-source software’s
    security, license compliance, and code quality in a codebase. SCA attempts to
    detect publicly disclosed vulnerabilities contained within a project’s dependencies.
    Popular SCA tools are OWASP Dependency-Check, Synopsys’ Black Duck, WhiteSource,
    Synk, and GitLab.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件组成分析**（**SCA**）：SCA评估代码库中开源软件的安全性、许可证合规性和代码质量。SCA尝试检测项目依赖项中包含的公开披露的漏洞。常见的SCA工具包括OWASP
    Dependency-Check、Synopsys的Black Duck、WhiteSource、Synk和GitLab。'
- en: '**Static application security testing** (**SAST**): SAST involves scanning
    an application’s code prior to compilation. These tools provide developers with
    immediate feedback during the coding process, allowing for the early correction
    of issues before the code build phase. As a white-box testing method, SAST analyzes
    the source code to identify vulnerabilities that could make applications prone
    to attacks. Its key advantage is its integration early in the DevOps cycle, during
    the coding stage, as it doesn’t require a functioning application or code execution.
    Popular SAST tools include SonarQube, PHPStan, Coverity, Synk, Appknox, Klocwork,
    CodeScan, and Checkmarx.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态应用安全测试**（**SAST**）：SAST涉及在编译之前扫描应用程序的代码。这些工具为开发人员提供即时反馈，使他们在编码过程中能够尽早发现问题，并在代码构建阶段之前进行修正。作为一种白盒测试方法，SAST分析源代码，以识别可能导致应用程序受到攻击的漏洞。其主要优势在于它可以在DevOps周期的早期阶段，即编码阶段进行集成，因为它不需要一个功能完整的应用程序或代码执行。常见的SAST工具包括SonarQube、PHPStan、Coverity、Synk、Appknox、Klocwork、CodeScan和Checkmarx。'
- en: '**Dynamic application security testing** (**DAST**): DAST identifies security
    vulnerabilities by mimicking external attacks on an application while it is running.
    It assesses the application from the outside, probing exposed interfaces for vulnerabilities.
    Known as black-box security testing or a web application vulnerability scanner,
    DAST tools include OWASP ZAP, Netsparker, Detectify Deep Scan, StackHawk, Appknox,
    HCL AppScan, GitLab, and Checkmarx.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态应用安全测试**（**DAST**）：DAST通过模拟外部攻击来识别应用中的安全漏洞，测试正在运行的应用。它从外部评估应用，探查暴露的接口是否存在漏洞。DAST也被称为黑盒安全测试或Web应用漏洞扫描器，DAST工具包括OWASP
    ZAP、Netsparker、Detectify Deep Scan、StackHawk、Appknox、HCL AppScan、GitLab和Checkmarx。'
- en: '**Interactive application security testing** (**IAST**): IAST examines code
    for security vulnerabilities while the application is actively being tested or
    used, thus reporting issues in real time without causing delays in the CI/CD pipeline.
    IAST tools are typically implemented in QA environments alongside automated functional
    tests. Notable IAST tools are GitLab, Veracode, CxSAST, Burp Suite, Acunetix,
    Netsparker, InsightAppSec, and HCL AppScan.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互动应用安全测试**（**IAST**）：IAST在应用被积极测试或使用时检查代码中的安全漏洞，从而实时报告问题而不会导致CI/CD管道的延迟。IAST工具通常在QA环境中与自动化功能测试一起实施。著名的IAST工具包括GitLab、Veracode、CxSAST、Burp
    Suite、Acunetix、Netsparker、InsightAppSec和HCL AppScan。'
- en: You will learn about integrating some of the above tools in the DevOps pipeline
    later in the chapter, under the *Building DevOps and DevSecOps in the cloud* section.
    DevSecOps CI/CD confirms that the code is validated against the corporate security
    policy.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你将会在本章的*构建云中的DevOps和DevSecOps*部分了解如何将上述一些工具集成到DevOps管道中。DevSecOps CI/CD确保代码符合公司安全政策。
- en: It helps to avoid any infrastructure and application failure in later deployment
    due to different security configurations. DevSecOps maintains agility and ensures
    security at scale without affecting DevOps’ pace of innovation. Let’s learn about
    the CD strategy in the DevOps pipeline.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 它有助于避免由于不同的安全配置导致后续部署中的基础设施和应用失败。DevSecOps保持敏捷性，并确保在不影响DevOps创新步伐的情况下确保安全。让我们了解DevOps管道中的CD策略。
- en: Implementing a CD strategy
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施CD策略
- en: 'CD provides seamless migration of the existing version of an application to
    the new version. Some of the most popular techniques to implement through CD are
    as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: CD提供无缝的应用版本迁移。通过CD实现的一些最受欢迎的技术如下：
- en: '**In-place deployment**: Update application on a current server'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原地部署**：在当前服务器上更新应用'
- en: '**Rolling deployment**: Gradually roll out the new version in the existing
    fleet of servers'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滚动部署**：逐步在现有服务器集群中推出新版本'
- en: '**Blue-green deployment**: Gradually replace the existing server with the new
    server'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蓝绿部署**：逐步将现有服务器替换为新服务器'
- en: '**Red-black deployment**: Instant cutover to the new server from the existing
    server'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**红黑部署**：从现有服务器即时切换到新服务器'
- en: '**Immutable deployment**: Stand up a new set of servers altogether'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变部署**：完全搭建一套新的服务器'
- en: Let’s explore each option in more detail.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探讨每个选项。
- en: In-place deployment
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原地部署
- en: In-place deployment is a method of rolling out a new application version on
    an existing fleet of servers. The update is done in one deployment action, requiring
    some downtime. Hardly any infrastructure changes are needed for this update. There
    is also no need to update existing **Domain Name System** (**DNS**) records. The
    deployment process itself is relatively quick. If the deployment fails, redeployment
    is the only option for restoration.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 原地部署是一种在现有服务器集群上推出新版本应用的方法。更新是在一次部署操作中完成的，需要一些停机时间。此更新几乎不需要任何基础设施的变更，也无需更新现有的**域名系统**（**DNS**）记录。部署过程本身相对较快。如果部署失败，恢复的唯一选择是重新部署。
- en: As a simple explanation, you are replacing the existing application version
    (v1) on the application infrastructure with the new version (v2). In-place updates
    are low-cost and fast to deploy.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，你是将应用基础设施上现有的应用版本（v1）替换为新版本（v2）。原地更新成本低，且部署速度快。
- en: Rolling deployment
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滚动部署
- en: With a rolling deployment, the server fleet is divided into groups, so it doesn’t
    need to be updated simultaneously. The deployment process runs old and new software
    versions on the same server fleet but with different subgroups. A rolling deployment
    approach helps to achieve zero downtime. If a new version deployment fails, then
    only a subset of servers is impacted from the entire fleet, and the risk is minimal
    because half of the fleet will still be up and running. A rolling deployment helps
    to achieve zero downtime; however, deployment time is little more than in-place
    deployment.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用滚动部署，服务器群分成多个组，因此不需要同时更新。部署过程在同一服务器群上同时运行旧版和新版软件，但是在不同的子组中。滚动部署方法有助于实现零停机时间。如果新版本部署失败，那么只有整个群中的一部分服务器受到影响，风险很小，因为仍有一半的群会继续运行。滚动部署有助于实现零停机时间；然而，与原地部署相比，部署时间略长一些。
- en: A rolling deployment not only helps achieve zero downtime, enhancing the user
    experience, but it is also cost-neutral in terms of additional resource allocation.
    Unlike blue-green deployments that require doubling the environment for a period,
    rolling deployments update existing resources one by one, avoiding the need for
    extra infrastructure. While the deployment time might be slightly longer compared
    to in-place deployments, this method doesn’t incur extra costs from provisioning
    additional resources, making it an efficient strategy for continuous delivery
    without impacting your budget. Let’s learn about blue-green deployment now.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动部署不仅有助于实现零停机时间，提升用户体验，而且在额外资源分配方面成本中性。与需要在一段时间内加倍环境的蓝绿部署不同，滚动部署逐个更新现有资源，避免了额外基础设施的需求。虽然与原地部署相比，部署时间可能稍长，但此方法不会因提供额外资源而产生额外成本，是在不影响预算的情况下进行持续交付的高效策略。现在让我们来学习一下蓝绿部署。
- en: Blue-green deployment
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 蓝绿部署
- en: The idea behind blue-green deployment is that your blue environment is your
    existing production environment carrying live traffic. In parallel, you provide
    a green environment, which is identical to the blue environment, other than having
    the new version of your code. When it’s time to deploy, you route production traffic
    from the blue to the green environment. If you encounter any issues with the green
    environment, you can roll it back by reverting traffic to the original blue environment.
    DNS cutover and swapping auto-scaling groups are the two most common methods to
    re-route traffic in blue-green deployment.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝绿部署的理念是，您的蓝色环境是承载实时流量的现有生产环境。同时，您提供一个绿色环境，与蓝色环境相同，除了代码的新版本。在部署时，您将生产流量从蓝色环境路由到绿色环境。如果绿色环境遇到任何问题，您可以通过将流量恢复到原始蓝色环境来回滚。DNS
    切换和交换自动扩展组是蓝绿部署中重新路由流量的两种常见方法。
- en: Using auto-scaling policies, you can gradually replace existing instances with
    instances hosting the new version of your application as your application scales
    out. This option is best used for minor releases and small code changes. Another
    option is to leverage DNS routing to perform sophisticated load balancing between
    different versions of our application.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自动扩展策略，您可以逐步将现有实例替换为托管新版本应用程序的实例，以满足应用程序扩展的需求。此选项最适合用于小版本发布和小代码更改。另一种选项是利用
    DNS 路由在不同版本的应用程序之间执行复杂的负载均衡。
- en: 'As illustrated in the following diagram, after creating a production environment
    that hosts the new version of our application, you can use the DNS route to shift
    a small portion of traffic to the new environment:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，创建托管新版本应用程序的生产环境后，您可以使用 DNS 路由将一小部分流量转移到新环境：
- en: '![](img/B21336_11_08.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21336_11_08.png)'
- en: 'Figure 11.8: Blue-green deployment DNS gradual cutover'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8：蓝绿部署 DNS 逐步切换
- en: Test the green environment with a fraction of production traffic, called **canary
    analysis**. If the environment has functional issues, you can immediately tell
    and switch traffic back before impacting your users significantly. Continue to
    gradually shift traffic, testing the ability of the green environment to handle
    the load. Monitor the green environment to detect issues, providing an opportunity
    to change traffic back, thus limiting the blast radius. Finally, decommission
    the blue environment and release the resources when all the metrics are correct.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用生产流量的一部分来测试绿色环境，这称为**金丝雀分析**。如果环境存在功能性问题，你可以立即发现并在对用户产生重大影响之前切换流量回去。继续逐步转移流量，测试绿色环境的负载处理能力。监控绿色环境以发现问题，提供将流量切换回去的机会，从而限制影响范围。最后，当所有指标正常时，停用蓝色环境并释放资源。
- en: Blue-green deployment helps to achieve zero downtime and provides easy rollback.
    You can customize the time to deploy as per your needs. However, these zero downtimes
    do come with a cost consideration as this approach requires maintaining two identical
    production environments, one active (blue) and one idle (green). The need to duplicate
    the environment means higher operational costs due to the additional resources
    required. However, this cost is often justified by the value it adds in terms
    of risk mitigation and uninterrupted user experience.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝绿部署有助于实现零停机时间，并提供便捷的回滚功能。你可以根据需要定制部署时间。然而，这些零停机时间是有成本考量的，因为这种方法需要维持两个相同的生产环境，一个是活动的（蓝色），一个是空闲的（绿色）。环境的重复意味着由于额外资源的需求，运营成本更高。然而，这种成本通常通过它在风险缓解和用户体验持续性方面带来的价值来证明是合理的。
- en: Red-black deployment
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 红黑部署
- en: Before standing up a new version of a system in red-black deployment, perform
    canary testing. The canary replaces around 1% of its existing production system
    with the latest version of the application and monitors the newest version for
    errors. The system is deemed ready for deployment if the canary clears this initial
    test. A new system version stands up alongside the old version in preparation
    for the switchover. The initial capacity of the new system is set manually by
    examining how many instances are currently running in production and setting this
    number as the desired capacity for the new auto-scaling group. Once the new system
    is up and running, both systems are red. The current version is the only version
    accepting traffic.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在红黑部署中上线新版本之前，需要进行金丝雀测试。金丝雀将现有生产系统的约1%替换为最新版本的应用程序，并监控该版本的错误。如果金丝雀测试通过，则认为系统准备好进行部署。新的系统版本与旧版本并排部署，为切换做准备。新系统的初始容量是手动设置的，方法是查看当前在生产环境中运行的实例数量，并将这个数字设为新自动扩展组的目标容量。新系统上线后，两个系统都处于红色状态，当前版本是唯一接受流量的版本。
- en: The system is then cut over from the existing version to the new version using
    the DNS service. At this point, the old version is regarded as black; it is still
    running but is not receiving any traffic. If any issues are detected with the
    new version, reverting becomes as simple as pointing the DNS server back to the
    old version’s load balancer.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过DNS服务将系统从现有版本切换到新版本。此时，旧版本被视为黑色；它仍在运行，但不再接收任何流量。如果检测到新版本有问题，恢复操作就像将DNS服务器指向旧版本的负载均衡器一样简单。
- en: Red-black deployment is also known as **dark launch** and is slightly different
    from blue-green deployment. In red-black deployment, you do a sudden DNS cutover
    from the old version to the new version, while in blue-green deployment, the DNS
    gradually increases traffic to the new version. Blue-green deployments and dark
    launches can be combined to deploy both versions of software side by side. Two
    separate code paths are used, but only one is activated. A feature flag activates
    the other code path. This deployment can be used as a beta test where you can
    explicitly enable the new features.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 红黑部署也被称为**暗启动**，它与蓝绿部署略有不同。在红黑部署中，你通过DNS切换将流量从旧版本直接切换到新版本，而在蓝绿部署中，DNS会逐步将流量转移到新版本。蓝绿部署和暗启动可以结合使用，使两种软件版本并行部署。使用两个独立的代码路径，但只有一个被激活。功能开关激活另一个代码路径。这种部署方式可以作为Beta测试，在测试中明确启用新功能。
- en: Red-black deployment, similar to blue-green deployment, involves running two
    identical environments to ensure zero downtime and facilitate easy rollbacks.
    The cost implications are primarily associated with the need to double resources
    during the deployment phase. You’ll have a “red” environment (the current live
    version) and a “black” environment (the new version). Both environments must be
    fully operational, which effectively doubles the resource requirements—including
    compute, storage, and network resources—during the transition period. While this
    approach significantly reduces deployment risks and provides a seamless user experience,
    the duplicated environment leads to increased costs. However, since the additional
    resources are only needed for the duration of the deployment window, this cost
    is temporary and can be considered an investment in stability and reliability.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 红黑部署，类似于蓝绿部署，通过运行两个相同的环境来确保零停机并促进轻松回滚。成本主要与部署阶段需要翻倍资源相关。你将拥有一个“红色”环境（当前的在线版本）和一个“黑色”环境（新版本）。这两个环境必须完全正常运行，这实际上将资源需求翻倍——包括计算、存储和网络资源——在过渡期间。尽管这种方法大大减少了部署风险，并提供了无缝的用户体验，但重复的环境会导致成本增加。然而，由于额外的资源仅在部署窗口期间需要，这种成本是暂时的，可以视为对稳定性和可靠性的投资。
- en: Immutable deployment
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变部署
- en: An immutable or disposable upgrade is more straightforward if your application
    has unknown dependencies. An older application infrastructure that has been patched
    and re-patched over time becomes increasingly difficult to upgrade. This type
    of upgrade technique is more common in an immutable infrastructure.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序具有未知的依赖关系，不可变或一次性升级会更加直接。随着时间的推移，经过多次修补和更新的旧应用基础设施变得越来越难以升级。这种升级技术在不可变基础设施中更为常见。
- en: During the new release, a new server instance set is rolled out by terminating
    older instances. For disposable upgrades, you can set up a cloned environment
    with deployment services such as Chef, Puppet, Ansible, and Terraform or use them
    combined with an auto-scaling configuration to manage the updates.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在新版本发布期间，通过终止旧实例来推出一组新的服务器实例。对于一次性升级，你可以设置一个克隆环境，使用Chef、Puppet、Ansible和Terraform等部署服务，或者将它们与自动扩展配置结合使用来管理更新。
- en: In addition to downtime, you must consider the cost while designing your deployment
    strategy. Consider the number of instances you need to replace and your deployment
    frequency to determine the cost. Use the approach that best fits, taking your
    budget and downtime into consideration.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 除了停机时间外，在设计部署策略时，还必须考虑成本。考虑你需要替换的实例数量以及部署频率，以确定成本。根据预算和停机时间，选择最合适的方法。
- en: In this section, you learned about various CD strategies that help make your
    application release more efficient and hassle-free. Let’s see the best practices
    for choosing the right deployment type.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了各种CD策略，它们有助于使应用发布更高效、无忧。接下来，我们来看选择正确部署类型的最佳实践。
- en: Best practices for choosing the right deployment strategy
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择正确部署策略的最佳实践
- en: 'Choosing the right deployment strategy is crucial for successful application
    updates and a seamless user experience. Here are the best practices for choosing
    among the various deployment strategies:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的部署策略对成功的应用更新和无缝的用户体验至关重要。以下是选择不同部署策略的最佳实践：
- en: '**In-place deployment**: In-place deployment is ideal for scenarios where simplicity
    is key and the application is relatively small or has a limited user base. For
    instance, updating a company’s internal tool with a small team fits this approach
    well. It involves updating the application on the current server, but it’s important
    to note that it can cause downtime. This strategy is not the best fit for large-scale
    or high-availability applications. A notable example would be updating a small-scale
    web service overnight with low user traffic. It’s crucial to have a rollback strategy
    in case the update fails to restore the previous version and minimize disruption
    quickly.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**就地部署**：就地部署适用于简单性至关重要且应用程序相对较小或用户群体有限的场景。例如，使用小团队更新公司内部工具非常适合这种方法。它涉及在当前服务器上更新应用程序，但需要注意的是，这可能会导致停机时间。对于大规模或高可用性的应用程序，这种策略并不适合。一个显著的例子是，晚上更新一个小规模的网页服务，用户流量较低。在更新失败时，恢复到先前版本并快速最小化干扰的回滚策略至关重要。'
- en: '**Rolling deployment**: Rolling deployment is suitable for applications that
    need minimal downtime but don’t require additional resources. This approach updates
    the application gradually across the existing fleet of servers. An example would
    be deploying an update to an e-commerce website’s servers in stages, ensuring
    that only a portion of users experience any potential issues at a time. However,
    this method is unsuitable for applications that cannot simultaneously handle different
    versions. Continuous monitoring of application performance during the deployment
    is key to addressing issues as they arise.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滚动部署**：滚动部署适用于需要最小停机时间，但不需要额外资源的应用程序。这种方法会在现有的服务器集群中逐步更新应用程序。例如，可以分阶段将更新部署到电子商务网站的服务器，确保只有一部分用户在任何时候遇到潜在问题。然而，这种方法不适用于无法同时处理不同版本的应用程序。部署过程中对应用程序性能的持续监控是解决问题的关键。'
- en: '**Blue-green deployment**: Blue-green deployment is best for critical applications
    where zero downtime is essential. A financial services company might use this
    strategy to update its customer-facing application. Once the green environment
    is thoroughly tested and ready, traffic is switched from blue to green. This method
    requires double the resources but offers a seamless user experience and quick
    rollback capability. It’s crucial to ensure that load balancing and DNS switching
    mechanisms are robust and reliable.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蓝绿部署**：蓝绿部署最适用于对零停机时间要求极高的关键应用程序。金融服务公司可能会使用此策略更新其面向客户的应用程序。一旦绿色环境经过彻底测试并准备就绪，流量就会从蓝色环境切换到绿色环境。这种方法需要双倍的资源，但提供无缝的用户体验和快速回滚能力。确保负载均衡和
    DNS 切换机制的稳健性和可靠性至关重要。'
- en: '**Red-black deployment**: Red-black deployment is similar to blue-green but
    focuses on a faster cutover to the new version. It is particularly effective for
    quickly releasing new versions and is often used in containerized environments.
    For example, a media streaming service might deploy a new version of its platform
    using this strategy, ensuring immediate availability of new features to all users.
    While it offers rapid release and immediate switching, thorough testing of the
    new version is crucial as rollback involves reverting to the old environment.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**红黑部署**：红黑部署类似于蓝绿部署，但更注重快速切换到新版本。它特别适用于快速发布新版本，常用于容器化环境中。例如，一个媒体流服务可能会使用此策略部署平台的新版本，确保所有用户能够立即使用新功能。尽管它提供了快速发布和即时切换的优势，但新版本的充分测试至关重要，因为回滚涉及恢复到旧环境。'
- en: '**Immutable deployment**: Immutable deployment ensures consistency and reliability,
    especially in cloud environments. Each deployment involves setting up new servers,
    guaranteeing a predictable and stable state. This approach could benefit an application
    with complex dependencies, as it avoids the “configuration drift” seen in long-lived
    environments. This strategy requires efficient management of infrastructure resources,
    as it involves provisioning new servers and decommissioning old ones with each
    release.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变部署**：不可变部署确保了云环境中的一致性和可靠性。每次部署都涉及设置新的服务器，保证可预测和稳定的状态。这种方法对具有复杂依赖关系的应用程序尤其有利，因为它避免了长期存在的环境中出现的“配置漂移”问题。此策略要求高效管理基础设施资源，因为每次发布都涉及为新服务器配置和淘汰旧服务器。'
- en: In each of these strategies, it’s important to assess factors like the application’s
    complexity, scale, user base, and the impact of potential downtime.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些策略中，评估应用程序的复杂性、规模、用户群体以及潜在停机的影响非常重要。
- en: Additionally, resource availability, infrastructure costs, and the application’s
    criticality should guide the deployment strategy choice. Regularly updating and
    refining the deployment approach in line with technological and organizational
    changes is also key to maintaining an effective deployment process.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，资源的可用性、基础设施成本以及应用程序的关键性应引导部署策略的选择。定期根据技术和组织变化更新和优化部署方法也是保持有效部署过程的关键。
- en: You need to perform application testing at every step for high-quality delivery,
    which often requires significant effort. A DevOps pipeline can help you automate
    the testing process and increase the quality and frequency of feature releases.
    Let’s learn more about continuous testing in the CI/CD pipeline.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在每一步进行应用程序测试，以确保高质量交付，这通常需要大量的工作。DevOps 管道可以帮助你自动化测试流程，提高功能发布的质量和频率。让我们深入了解
    CI/CD 管道中的持续测试。
- en: Implementing continuous testing in the CI/CD pipeline
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在CI/CD流水线中实施持续测试
- en: DevOps is key for continually changing business scenarios based on customer
    feedback, demand for new features, or shifts in market trends. A robust CI/CD
    pipeline ensures further features/feedback are incorporated in less time, and
    customers can use the new features faster.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps对于基于客户反馈、对新功能的需求或市场趋势变化的持续业务场景至关重要。一个强大的CI/CD流水线确保可以在更短时间内加入更多功能/反馈，客户也可以更快地使用新功能。
- en: With frequent code check-ins, having a good testing strategy baked into your
    CI/CD pipeline ensures you close that feedback loop with quality. Continuous testing
    is essential in balancing the CI/CD pipeline. While adding software features rapidly
    is good, ensuring that the features adhere to good quality standards is achieved
    by continuous testing.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通过频繁的代码提交，在CI/CD流水线中内置一个良好的测试策略可以确保你以高质量完成反馈闭环。持续测试对于平衡CI/CD流水线至关重要。虽然快速添加软件功能是好事，但通过持续测试确保功能符合良好的质量标准。
- en: Unit tests form the most significant amount of your testing strategy. They typically
    run on the developer’s machine and are the fastest and cheapest. A general rule
    of thumb is to incorporate 70% of your testing efforts in unit testing. Bugs caught
    at this stage can quickly be fixed with fewer complexities.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试构成了测试策略中最重要的部分。它们通常在开发人员的机器上运行，是最快且最便宜的。一个通用的经验法则是将70%的测试工作量集中在单元测试上。在这个阶段捕获的Bug可以快速修复，且复杂性较低。
- en: The developer often performs unit tests, and once the code is ready, it is deployed
    for integration and system testing. These tests require their own environments
    and sometimes separate testing teams, which makes the testing process costlier.
    Once the team ensures that all intended features work as expected, the operations
    team needs to run performance and compliance tests. These tests need production-like
    environments and are costly. Also, **user acceptance testing** (**UAT**) needs
    a replica of production-like environments, causing more expense.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员通常会执行单元测试，一旦代码准备好，就会进行集成和系统测试。这些测试需要独立的环境，有时还需要单独的测试团队，这使得测试过程变得更加昂贵。一旦团队确认所有预期功能按预期工作，运营团队需要进行性能和合规性测试。这些测试需要类似生产环境的环境，且费用较高。此外，**用户验收测试**（**UAT**）也需要类似生产的环境，这会导致更多的开销。
- en: 'As illustrated in the following diagram, developers perform unit tests to test
    code changes/new features in the development phase. Testing is usually done on
    a developer’s machine after coding is complete. It is also recommended to run
    static code analysis on the code changes and do code coverage, adherence to coding
    guidelines, and so on. Smaller unit tests with no dependencies run faster. Therefore,
    the developer can find out quickly if the test has failed:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，开发人员在开发阶段执行单元测试，以测试代码更改/新功能。测试通常在开发人员的机器上完成，完成编码后进行。还建议对代码更改进行静态代码分析，并进行代码覆盖率、遵循编码规范等检查。没有依赖项的小型单元测试运行得更快。因此，开发人员可以迅速发现测试是否失败：
- en: '![A picture containing text, screenshot, font, line  Description automatically
    generated](img/B21336_11_09.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、字体、线条的图片  描述自动生成](img/B21336_11_09.png)'
- en: 'Figure 11.9: Continuous testing in CI/CD'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9：CI/CD中的持续测试
- en: The **build phase** is the first test for integration between different components
    and individual components. The build phase is also an excellent time to test if
    the code committed by a developer breaks any existing features and to perform
    regression testing.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建阶段**是不同组件和单个组件之间集成的第一次测试。构建阶段也是测试开发人员提交的代码是否破坏任何现有功能并进行回归测试的绝佳时机。'
- en: A **staging environment** is a mirror of the production environment. An end-to-end
    system test is performed at this stage (the UI, backend logic, and API are tested
    extensively). Performance testing tests the application performance under a particular
    workload. Performance tests include load tests and stress tests. UAT is also performed
    at this stage in readiness for production deployment. Compliance testing is done
    to test for industry-specific regulatory compliance.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**预发布环境**是生产环境的镜像。在这个阶段进行端到端的系统测试（UI、后台逻辑和API会进行广泛的测试）。性能测试在特定的工作负载下测试应用程序的性能。性能测试包括负载测试和压力测试。UAT也会在此阶段进行，为生产部署做好准备。合规性测试用于测试行业特定的法规合规性。'
- en: For example, let’s assume you are integrating continuous testing into the CI/CD
    pipeline for a video personalization feature in an online streaming platform.
    When your development team commits their code changes, the CI tool, such as Jenkins,
    automatically initiates the build process and conducts a series of automated tests.
    These include unit tests to validate individual components of the personalization
    feature, integration tests to ensure compatibility with existing system components,
    and UI tests to confirm user interaction flows smoothly. Performance tests are
    particularly critical in this scenario to verify that the new feature does not
    degrade the streaming experience. If any issues arise during these tests, the
    pipeline is halted, allowing developers to make necessary corrections, thus ensuring
    that only thoroughly vetted code progresses to the next stages. After passing
    automated testing, the feature advances to a staging environment, mimicking production,
    for further testing and validation. This additional layer of scrutiny ensures
    the feature performs well under various scenarios and user behaviors through user
    acceptance testing before deployment.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你正在将持续测试集成到在线流媒体平台的视频个性化功能的CI/CD管道中。当你的开发团队提交代码更改时，CI工具（例如Jenkins）会自动启动构建过程并进行一系列自动化测试。这些测试包括单元测试，用于验证个性化功能的各个组件，集成测试，确保与现有系统组件的兼容性，以及UI测试，以确认用户交互流程顺畅。在这种情况下，性能测试尤为关键，用于验证新功能不会降低流媒体体验。如果在这些测试过程中出现任何问题，管道会被暂停，允许开发人员进行必要的修正，从而确保只有经过彻底审核的代码才会进入下一个阶段。在通过自动化测试后，功能会进入模拟生产环境的预发布环境，进行进一步的测试和验证。这一额外的审查层确保功能能够在各种场景和用户行为下良好表现，并通过用户验收测试后再部署。
- en: A/B testing
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A/B测试
- en: Often, in software development, which feature’s implementation will be most
    successful in the real world needs to be clarified. An entire computer science
    discipline—**human/computer interaction** (**HCI**)—is devoted to answering this
    question. While UI experts have several guidelines to help design suitable interfaces,
    the best choice of design often can only be determined by giving it to users and
    seeing whether they can use the design to complete a given task.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，经常需要明确哪个功能的实现最有可能在现实世界中成功。整个计算机科学学科——**人机交互**（**HCI**）——致力于回答这个问题。虽然UI专家有多种指南帮助设计合适的界面，但最好的设计选择往往只能通过将其交给用户并观察他们是否能使用该设计完成特定任务来确定。
- en: A strategy such as A/B testing or canary analysis tests the new application
    version in the production phase. In A/B testing, the new application version is
    deployed to a small percentage of production servers and tested for user feedback.
    Gradually, depending on how well the users receive the new application, the deployment
    is increased to span all production servers.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 像A/B测试或金丝雀分析这样的策略会在生产阶段测试新版本的应用。在A/B测试中，新版本的应用会部署到少部分生产服务器上并进行用户反馈测试。随着用户对新应用的接受度逐步增加，部署会逐渐扩展到所有生产服务器。
- en: 'As shown in the following diagram, A/B testing is a methodology in which two
    or more versions of features are given to different sets of users. Detailed metrics
    on the usage of each implementation are gathered, and UI engineers examine this
    data to determine which implementation should be adopted going forward:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，A/B测试是一种方法论，将功能的两个或多个版本分别提供给不同的用户群体。收集关于每个实现的详细使用数据，UI工程师会分析这些数据，以决定接下来应该采用哪个实现：
- en: '![](img/B21336_11_10.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21336_11_10.png)'
- en: 'Figure 11.10: Split users by feature experiment using A/B testing'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10：通过A/B测试进行的特性实验用户拆分
- en: 'The preceding diagram represents an A/B testing scenario where different versions
    of a web application are being tested simultaneously to evaluate their performance,
    user engagement, or other defined metrics. Here’s how the A/B testing process
    is depicted in this architecture:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表展示了一个A/B测试场景，其中同时测试多个版本的Web应用，以评估其性能、用户参与度或其他定义的指标。以下是该架构中A/B测试过程的描述：
- en: '**Traffic distribution**: The application load balancer plays a crucial role
    by directing incoming user traffic to different versions of the web application.
    In this scenario, the majority of the traffic (90%) is routed to the stable production
    version (V1.1), while the new versions under test, V1.2 and V1.3, receive a smaller
    fraction of the traffic, 7% and 3% respectively.'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Web server fleet**: Each version of the application runs on a separate set
    of web servers or instances, ensuring that changes in one version do not affect
    the others. This isolation is essential for obtaining accurate test results. The
    version receiving the most traffic serves as the control group, while the other
    versions with changes or new features are the test groups.'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Database**: All versions of the application interact with the same backend
    database. This is common in A/B tests where the underlying data remains consistent
    across different user experiences. However, care must be taken to ensure database
    schemas and interactions are compatible across all versions to prevent errors
    or inconsistencies in data handling.'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You need to make sure that throughout the A/B test, performance metrics are
    continuously monitored to assess how each version of the application performs
    in real-world conditions. This includes evaluating response times, error rates,
    and resource utilization, among other factors. After a significant amount of data
    has been collected, the results are analyzed to determine which version of the
    application performs best based on the testing criteria. Decisions can then be
    made on whether to fully roll out a new version, make further modifications, or
    roll back changes based on the insights gained from the A/B test.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Using DevOps tools for CI/CD
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To build a CI/CD pipeline, a developer requires various tools. These include
    a code editor, a source repository, a build server, a deployment tool, and orchestrating
    an overall CI pipeline. Let’s explore some popular technology choices of developer
    tools for DevOps, both in the cloud and on-premises.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Code editor
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DevOps is a hands-on coding role where you often need to write a script to automate
    the environment. You can use the **Ace editor** or the **cloud-based AWS Cloud9
    integrated development environment** (**IDE**). Ace provides syntax highlighting
    and other features that are valuable for developers. Cloud9 is integrated with
    the AWS platform, making it easy for developers to create serverless applications,
    and work with AWS services. It also supports collaborative coding and is equipped
    with essential tools for popular programming languages.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: You can use a web-based code editor on your local computer or install a code
    editor on your local server that connects to the application environments—such
    as dev, test, and prod—to interact. In an environment, you store your project’s
    files and run the tools to develop your apps. You can save these files locally
    on the instance or server or clone a remote code repository into your environment.
    The AWS Cloud9 IDE is a cloud-native IDE provided as a managed service.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: The Ace editor lets you write code quickly and easily. It’s a web-based code
    editor but provides performance similar to popular desktop-based code editors
    such as Eclipse, Vim, **Visual Studio Code** (**VS Code**), and so on. It has
    standard IDE features such as live syntax and matching parentheses highlighting,
    auto-indentation and completion, toggling between tabs, integration with version
    control tools, and multiple cursor selections. It works with large files, having
    hundreds of thousands of lines without typing lag. It has built-in support for
    all popular coding languages and debugging tools, and you can also install your
    tools. For a desktop-based IDE, VS Code and Eclipse are other popular code editor
    options that DevOps engineers can choose.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Source code management
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are multiple choices available for your source code repository. You can
    set up, run, and manage your Git server, where you will be responsible for everything.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: You can choose to use a hosting service such as GitHub or Bitbucket. If you
    are looking for a cloud solution, **AWS CodeCommit** offers a secure, highly scalable,
    and managed source control system to host private Git repositories.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: You need to set up authentication and authorization for your code repository
    to provide access to authorized team members for code to read or write. You can
    apply data encryption in transit and at rest. When you push into the code repository
    (`git push`), it encrypts and stores the data. When you pull from the code repository
    (`git pull`), it decrypts the data and then sends it back to the caller. The user
    must be authenticated with the proper access level to the code repository. Data
    can be encrypted in transit by transmitting through encrypted network connections
    using HTTPS or SSH protocols.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: CI server
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A CI server is also known as a **build server**. With teams working on multiple
    branches, merging back into the main branch is complicated. CI, in this scenario,
    plays a key role. CI server hooks provide a way to trigger the build based on
    the event when code is committed to the repository. Hooks, incorporated in almost
    every version control system, refer to custom scripts triggered by specified necessary
    actions in a repository. Hooks can run either on the client side or the server
    side.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Pull requests are common for developers to notify and review each other’s work
    before it is merged into common code branches. A CI server provides a web interface
    to review changes before adding them to the final project. If there are any problems
    with the proposed changes, the source code can be sent back to the developer to
    tweak as per the organization’s coding requirements.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following diagram, server-side hooks in combination with the
    CI server are used to increase the velocity of integration:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing text, font, screenshot  Description automatically generated](img/B21336_11_11.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.11: Automation of CI'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: As illustrated in the preceding diagram, using `post-receive`, you can direct
    new branches to trigger tests on a CI server to verify that the new build integrates
    correctly and that all units function correctly. The developer is notified of
    test failures and then knows to merge their branch with the mainline only after
    fixing the problems. The developer can build from their branch, test the changes
    there, and get feedback on how well their changes work before deciding whether
    to merge their branch into the mainline.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Running integration and unit tests significantly reduces resistance when merging
    that branch into the mainline. Hooks can also be customized to test merges into
    the mainline and block any merges that don’t pass. Integration is best accomplished
    with a CI server.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Jenkins is the most popular choice for building the CI server. As illustrated
    in the following diagram, you can host the Jenkins cluster in the AWS **Elastic
    Compute Cloud** (**EC2**) server’s fleet and auto-scale as per build load:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing diagram, text, screenshot, line  Description automatically
    generated](img/B21336_11_12.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.12: Auto-scaling of Jenkins CI servers'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: The **Jenkins Controller** offload builds to the agent node instance in the
    case of overload. When the load goes down, the **Jenkins Controller** automatically
    terminates agent instances.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: However, you have to maintain security and patch the server by yourself. For
    native cloud options and managed services, you can use managed code-build services
    such as AWS CodeBuild, eliminating the need for server administration and significantly
    reducing costs with a **pay-as-you-go** model—the service scales as per your demand.
    Your team is empowered to focus on pushing code and lets a service build all the
    artifacts.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: While a CI server helps you build the correct version of code from a source
    code repository by collaborating across team members of the development team,
    code deployment helps the team get code ready for testing and release for end-user
    consumption. Let’s learn about code deployment in more detail.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Code deployment
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once your build is ready, you can deploy the Jenkins server or choose AWS CodeDeploy
    as a cloud-native managed service. You can use other popular tools, such as Chef
    or Puppet, to create a deployment script. The options for specifying a deployment
    configuration are as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建完成，你可以部署 Jenkins 服务器，或者选择 AWS CodeDeploy 作为云原生托管服务。你也可以使用其他流行的工具，如 Chef
    或 Puppet，来创建部署脚本。指定部署配置的选项如下：
- en: '**OneAtATime**: Only a single instance in a deployment group at a time installs
    a new deployment. Suppose a deployment on a given instance fails. In that case,
    the deployment script will halt the deployment and return an error response detailing
    the number of successful versus the number of failed installations.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OneAtATime**：在任何时候，部署组中的只有一个实例会安装新的部署。如果某个实例上的部署失败，则部署脚本会停止部署并返回一个错误响应，详细说明成功与失败安装的数量。'
- en: '**HalfAtATime**: Half of the instances in the deployment group install a new
    deployment. The deployment succeeds if half of the instances successfully install
    the revision. HalfAtATime is a good option for production/test environments where
    half of the instances are updated to a new revision, and the other half remain
    available in production at an older revision.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HalfAtATime**：部署组中的一半实例安装新的部署。如果一半实例成功安装该版本，则部署成功。HalfAtATime 是生产/测试环境中的一个良好选择，适用于一半实例更新为新版本，另一半则保持在旧版本中可用。'
- en: '**AllAtOnce**: Each instance installs the latest revision available whenever
    it next polls the deployment service. This option is best used for development
    and test deployments as it has the potential to install a non-functioning deployment
    on every instance in a deployment group.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AllAtOnce**：每个实例在下次轮询部署服务时，都会安装最新的版本。此选项最适用于开发和测试部署，因为它有可能在部署组中的每个实例上安装一个无法正常工作的版本。'
- en: '**Custom**: You can use this command to create a custom deployment configuration
    specifying a fixed number of healthy hosts that must exist in a deployment group
    at any given time. This option is a more flexible implementation of the OneAtATime
    option. It allows for the possibility that a deployment may fail on one or two
    instances that have become corrupt or are improperly configured.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Custom**：你可以使用此命令创建自定义部署配置，指定在任何给定时刻必须在部署组中存在的健康主机的固定数量。这个选项是 OneAtATime
    选项的更灵活实现。它允许在某些实例因损坏或配置不当而导致部署失败的情况下进行部署。'
- en: 'The following diagram illustrates life cycle events during deployment:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了部署过程中的生命周期事件：
- en: '![](img/B21336_11_13.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21336_11_13.png)'
- en: 'Figure 11.13: Deployment life cycle events'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.13：部署生命周期事件
- en: 'The deployment agent runs through a series of steps to execute a deployment.
    These steps are called life cycle events. In the preceding diagram, the steps
    shown in lighter boxes can be controlled by human intervention; however, the steps
    shown in darker boxes are automated and controlled by a deployment agent. Let’s
    go into some detail for each of these steps:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 部署代理会按步骤执行部署。这些步骤称为生命周期事件。在前面的图示中，浅色框中的步骤可以通过人工干预进行控制；而深色框中的步骤是自动化的，由部署代理控制。让我们详细了解每个步骤：
- en: '**ApplicationStop**: To trigger a deployment, the first requirement is to stop
    the application server so that traffic stops serving while files are copied. Examples
    of software application servers are Tomcat, JBoss, or WebSphere servers.'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**ApplicationStop**：触发部署的首个要求是停止应用服务器，以便在复制文件时停止处理流量。软件应用服务器的例子包括 Tomcat、JBoss
    或 WebSphere 服务器。'
- en: '**DownloadBundle**: After stopping the application server, the deployment agent
    starts downloading a pre-built deployment bundle from an artifactory such as JFrog
    Artifactory. The artifactory stores the application binary, which can be deployed
    and tested for application before the new version launch.'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**DownloadBundle**：在停止应用服务器后，部署代理开始从工件库（如 JFrog Artifactory）下载预构建的部署包。工件库存储应用程序二进制文件，可以在新版本发布前进行部署和测试。'
- en: '**BeforeInstall**: The deployment agent triggers pre-install steps such as
    creating a backup of the current version and any required configuration update
    via a script.'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**BeforeInstall**：部署代理会触发安装前的步骤，例如通过脚本创建当前版本的备份并进行任何必要的配置更新。'
- en: '**Install**: In this step, deployment agents start the installation—for example,
    running an Ant or Maven script to install a Java application.'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Install**：在此步骤中，部署代理开始安装过程——例如，运行 Ant 或 Maven 脚本来安装 Java 应用程序。'
- en: '**AfterInstall**: The deployment agent triggers this step after completing
    your application installation. It may include updating post-installation configuration,
    such as local memory settings and log parameters.'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**ApplicationStart**: In this step, the agent starts the application and notifies
    the success or failure operations team.'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**ValidateService**: The validation step fires after everything else is done,
    allowing you to check the app quickly. It includes steps such as performing automated
    sanity tests and integration tests to verify if the new version of the application
    has been installed correctly. The agent also sends a notification to the team
    when testing is successful.'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have learned about various code deployment strategies and steps as independent
    components. However, you must stitch all the DevOps steps together to set up an
    automated CI/CD pipeline. Let’s learn more about the code pipeline, which can
    help you build an end-to-end CI/CD pipeline.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Code pipeline
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code pipeline is about orchestrating everything together to achieve CD.
    The entire software release process is fully automated in CD, including building
    and deploying to the production release. Over some time, with experiments, you
    can set up a mature CI/CD pipeline. The path to the production launch is automated,
    thus enabling the rapid deployment of features and immediate customer feedback.
    You can use cloud-native managed services such as AWS CodePipeline to orchestrate
    the overall code pipeline or use the Jenkins server.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'The code pipeline enables you to add actions to stages in your CI/CD pipeline.
    Each action can be associated with a provider that executes the action. The code
    pipeline action categories and examples of providers are as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '**Source**: Your application code needs to be stored in a central repository
    with version control called **source code repositories**. Some popular code repositories
    are AWS CodeCommit, Bitbucket, GitHub, **Concurrent Versions System** (**CVS**),
    **Subversion** (**SVN**), and so on.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build**: The build tool pulls code from the source code repository and creates
    an application binary package. Some of the popular build tools are AWS CodeBuild,
    Jenkins, Solano CI, and so on. Once the build is completed, you can store binaries
    in an artifactory such as JFrog.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deploy**: The deployment tool helps you to deploy application binaries on
    the server. Some popular deployment tools are AWS Elastic Beanstalk, AWS CodeDeploy,
    Chef, Puppet, Jenkins, and so on.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test**: Automated testing tools help you to complete and perform post-deployment
    validation. Some popular test-validating tools are Jenkins, BlazeMeter, Ghost
    Inspector, etc.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Invoke**: You can use an events-based script to invoke activities such as
    backup and alert. Any scripting language, such as a shell script, PowerShell,
    and Python, can be used to invoke various customized activities.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Approval**: Approval is an essential step in CD. You can either ask for manual
    approval by an automated email trigger, or approval can be automated from tools.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, you learned about various DevOps tools to manage the **software
    development life cycle** (**SDLC**), such as a code editor, a repository, and
    build, test, and deployment tools. The other tools you need to integrate into
    DevOps pipelines are continuous logging, continuous monitoring, and operation
    handling, which you learned in *Chapter 9*, *Operational Excellence Considerations*.
    As of now, you have learned about various DevOps techniques for each SDLC phase.
    Let’s learn more about best practices and anti-patterns.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Implementing DevOps best practices
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While building a CI/CD pipeline, consider your need to create a project and
    add team members to it. The project dashboard provides visibility to the code
    flow through the deployment pipeline, monitors the build, triggers alerts, and
    tracks application activities. The following diagram illustrates a well-defined
    DevOps pipeline:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing text, screenshot, diagram, line  Description automatically
    generated](img/B21336_11_14.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.14: CI/CD workflow best practice'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following points while designing the pipeline:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '**The number of stages**: Stages could be development, integration, system,
    user acceptance, and production. Some organizations also include dev, alpha, beta,
    and release stages.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Types of tests in each stage**: Each stage can have multiple types of tests,
    such as unit tests, integration tests, system tests, UATs, smoke tests, load tests,
    and A/B tests at the production stage.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The sequence of a test**: Test cases can be run in parallel or need to be
    in sequence.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring and reporting**: Monitor system defects and failures and send
    notifications as failures occur.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infrastructure provisioning**: Methods to provision infrastructure for each
    stage.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rollback**: Define the rollback strategy to fall back to the previous version
    if required.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having a system that requires manual intervention where it’s avoidable slows
    down your process. So, automating your process using CD will accelerate it.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Another common anti-pattern is keeping configuration values for a build inside
    the code or even having developers use different tools in their build processes,
    leading to inconsistent builds between developers. It takes lots of time and effort
    to troubleshoot why particular builds work in one environment rather than in others.
    To overcome this, it is better to store build configurations outside of code.
    Externalizing these configurations to tools that keep them consistent between
    builds enables better automation and allows your process to scale much more quickly.
    Not using a CD process can lead to last-minute, middle-of-the-night rushes to
    get a build to work. Design your CD process to *fail fast* to reduce the likelihood
    of any last-minute surprises.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'Externalizing environment-specific configurations is crucial for maintaining
    consistency and scalability across builds. Some tools and services that facilitate
    this abstraction include:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 外部化特定环境的配置对于在各个构建中保持一致性和可扩展性至关重要。一些促进这种抽象的工具和服务包括：
- en: '**AWS Systems Manager Parameter Store**: Provides secure, hierarchical storage
    for configuration data management and secrets management. You can store data such
    as passwords, database strings, and license codes as parameter values.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS Systems Manager Parameter Store**：为配置数据管理和机密管理提供安全的分层存储。你可以将密码、数据库连接字符串、许可证代码等数据作为参数值进行存储。'
- en: '**ConfigMaps and Secrets in Kubernetes**: Kubernetes objects that allow you
    to separate configuration artifacts from image content to keep containerized applications
    portable.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes中的ConfigMaps和Secrets**：Kubernetes对象，允许你将配置文件与镜像内容分离，从而保持容器化应用的可移植性。'
- en: '**Docker Swarm secrets**: Used to manage sensitive data with Docker containers,
    offering a way to securely transmit and store secrets within the Swarm cluster.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Swarm secrets**：用于管理与Docker容器相关的敏感数据，提供在Swarm集群中安全传输和存储机密的方式。'
- en: '**Consul by HashiCorp**: A service networking solution to automate network
    configurations with distributed key-value stores.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HashiCorp的Consul**：一种服务网络解决方案，用于通过分布式键值存储自动化网络配置。'
- en: By using these tools, you can manage your configurations and secrets outside
    of your application code and templates, making it easier to manage and rotate
    them securely without redeploying or changing the application.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这些工具，你可以将配置和机密管理与应用代码和模板分开，使得在不重新部署或更改应用的情况下更轻松地管理和轮换它们，确保其安全。
- en: 'To effectively gauge the impact of CI/CD within your DevOps framework, monitoring
    **key performance indicators** (**KPIs**) is essential. Key CI/CD KPIs include:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效评估CI/CD在DevOps框架中的影响，监控**关键绩效指标**（**KPIs**）是必不可少的。关键的CI/CD KPI包括：
- en: Deployment frequency, which signals how often updates reach production, reflecting
    the agility of your release process
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署频率，它表示更新到达生产环境的频率，反映了发布过程的敏捷性
- en: Lead time for changes, which shows the duration from code commitment to live
    deployment, with shorter spans indicating a more efficient development cycle
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更的交付时间，它显示从代码提交到实时部署的持续时间，较短的周期表明更高效的开发周期
- en: Change failure rate, which identifies the proportion of deployments causing
    failures, with a lower rate denoting better deployment stability
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更失败率，它识别导致故障的部署比例，较低的比例表示更好的部署稳定性
- en: '**Mean time to recovery** (**MTTR**), which measures the average recovery duration
    from a failure, with quicker recoveries exemplifying a team’s effective incident
    management'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平均恢复时间**（**MTTR**），它衡量从故障恢复的平均时间，较快的恢复时间体现了团队在事件管理上的高效性'
- en: Automated test pass rate, which highlights the reliability of your code through
    the success rate of automated tests in each CI/CD cycle
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化测试通过率，它通过每个CI/CD周期中的自动化测试成功率突出代码的可靠性
- en: The twelve-factor methodology can be used to apply architecture best practices
    at each step of application development, as recommended by The Twelve-Factor App
    ([https://12factor.net/](https://12factor.net/)), which enterprises adopt for
    the end-to-end development and delivery of web applications. This applies to all
    coding platforms regardless of programming languages. Nowadays, most applications
    are built as web apps and utilize a cloud platform. Let’s learn how to build end-to-end
    DevOps and security automation in the cloud.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 十二因素方法论可以在应用开发的每个阶段应用架构最佳实践，正如The Twelve-Factor App（[https://12factor.net/](https://12factor.net/)）推荐的那样，企业在进行Web应用的端到端开发和交付时采用该方法。这适用于所有编码平台，无论编程语言如何。如今，大多数应用程序都作为Web应用构建，并利用云平台。让我们来学习如何在云中构建端到端的DevOps和安全自动化。
- en: Building DevOps and DevSecOps in the cloud
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在云中构建DevOps和DevSecOps
- en: As you have learned in previous sections, building a CI/CD pipeline requires
    multiple tools, and adding security automation on top of that increases the complexity.
    Integrating a range of tools and consolidating the results of vulnerability assessments
    from the ground up can be a complex task. A public cloud provider like AWS offers
    the adaptability required to construct DevSecOps pipelines. This includes the
    straightforward integration of both cloud-native and third-party tools, as well
    as the capability to aggregate security findings effectively.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'DevSecOps pipeline architecture covers CI/CD practices, including SCA, SAST,
    and DAST tools:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '**Software composition analysis** (**SCA**) tools analyze open-source components
    in your application to identify known vulnerabilities, licensing issues, and outdated
    libraries. They can automate the process of checking for updates and security
    patches, making it easier to manage your application’s dependencies.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SAST** tools are designed to analyze source code or compiled versions of
    code to detect security vulnerabilities. They can identify issues such as input
    validation errors, insecure dependencies, and potential backdoors without executing
    the code.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DAST** tools assess running applications for vulnerabilities. Unlike SAST
    tools that analyze static code, DAST tools interact with the application from
    the outside, performing black-box testing to detect issues such as SQL injection,
    cross-site scripting, and authentication problems.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Integrating these tools into a CI/CD pipeline allows for continuous and automated
    security testing, enabling teams to detect and resolve security issues promptly
    and improve the overall security posture of their applications. The following
    diagram visualizes the concepts of security automation in the pipeline:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21336_11_15.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.15: DevSecOps CI/CD pipeline architecture in the AWS cloud'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows that the CI/CD pipeline gets triggered when a developer
    commits the code in GitHub. An event gets generated to start the AWS CodePipeline
    using AWS CloudWatch. AWS CodePipeline orchestrates the CI/CD pipeline, including
    code commit, build, and deployment. AWS CodeBuild compiles the build and then
    uploads the resulting artifacts to AWS CodeArtifact. For initiating the scanning
    process, AWS CodeBuild fetches authentication details, including tokens for scanning
    tools, from the AWS Parameter Store.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Once the deployment is successfully completed, CodeBuild initiates DAST. If
    this process uncovers any vulnerabilities, CodeBuild triggers a Lambda function.
    This function then proceeds to log the security findings in AWS Security Hub.
    Suppose DAST finds no security issues. In that case, the build can advance for
    approval, and the pipeline notifies the approver for action to push the build
    into the production AWS ECS environment. During the CI/CD pipeline run, AWS CloudWatch
    monitors all the changes and sends email notifications to DevOps and the dev team
    through SNS notifications.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: AWS CloudTrail tracks any critical changes, such as pipeline updates, deletions,
    and creation, and sends notifications to the DevOps team for audit purposes. Further,
    AWS Config tracks all the configuration changes.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: In DevSecOps, securing the CI/CD pipeline is achieved through AWS **Identity
    and Access Management** (**IAM**) roles, which restricts access strictly to the
    necessary resources. Encryption and **Secure Sockets Layer** (**SSL**) are employed
    to protect pipeline data both at rest and in transit. Sensitive details like API
    tokens and passwords are securely stored in the AWS Parameter Store.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Centralizing security findings in AWS Security Hub facilitates the automation
    of remediation processes. Depending on the nature of the security issue, a Lambda
    function can be triggered to perform the required remedial actions. For instance,
    if an SSH port is inadvertently exposed, the system can automatically restrict
    server access from the internet. This automation relieves the burden on DevOps
    and security teams, allowing them to address vulnerabilities from a single tool,
    rather than managing multiple dashboards.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Addressing security threats early in the application development life cycle
    can significantly reduce the cost of making changes to the application. Automating
    this process can further expedite the delivery of these changes, making a DevSecOps
    pipeline an essential component for successful application development.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: DevOps integrates culture, practices, and tools to merge application development
    with operations, enabling rapid delivery of new application features. DevSecOps
    extends this by weaving security into the DevOps process, ensuring that secure
    and compliant application changes are delivered swiftly and operations are consistently
    automated. This integration is key to maintaining a secure, efficient, and resilient
    application development environment.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned about the key components of a strong DevOps
    practice along with its benefits, CI/CD, and continuous monitoring and improvement.
    The agility of CI/CD can be achieved only by applying automation everywhere. To
    automate, you learned about IaC and configuration management. You also looked
    at various automation tools such as Chef, Puppet, and Ansible to automate configuration
    management.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'As security is the priority, you learned about DevSecOps, which is DevOps in
    security. CD is one of the critical aspects of DevOps. You learned about various
    deployment strategies: rolling, blue-green, and red-black. Testing is another
    aspect of ensuring the quality of your product. You learned about the concept
    of continuous testing in DevOps and how A/B testing can help improve the product
    by taking direct feedback from a customer in the live environment.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: You have learned about the stages in a CI/CD pipeline. You have learned about
    the tools and services you can use and the best practices you can follow for a
    robust CI/CD pipeline. You have learned how individual services work and discussed
    how to integrate services to build a sophisticated solution.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Until this point, you have learned about various aspects of solution architecture.
    As every organization has lots of data, they put great effort into getting insight
    into their data. In the next chapter, you will learn about collecting, processing,
    and consuming data to get a more in-depth insight.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Leave a review!
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below to get a free eBook of your choice.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
