- en: New Features from Puppet 4 and 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a complete overview of the Puppet DSL and its concepts, it
    is time to look at the newest Puppet features, which were introduced with Puppet
    version 4\. The parser, which compiles the catalog, was basically rewritten from
    scratch for better performance. The milestone release also added some missing
    functionality and coding principles.
  prefs: []
  type: TYPE_NORMAL
- en: Puppet 4 and newer versions do not only offer new functionality, but break with
    old practices and remove some functionality that is not considered best practice
    anymore. This necessitates that any existing manifest code needs proper testing,
    and potentially needs lots of changes to be compatible with Puppet 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within this chapter, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading to Puppet 4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Puppet type system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning lambdas and functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Puppet 4 functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging the new template engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling multiline with HEREDOC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Puppet 5 server metrics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breaking old practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upgrading to Puppet 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's first look at how users of the older Puppet 3 series can approach the
    update.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of upgrading your Puppet master machine, consider setting up a new server
    in parallel and migrating the service carefully. This has some advantages. For
    example, rolling back in case of problems is quite easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new Puppet 4 and later versions can be installed in several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Puppet Labs repositories, which will remove older Puppet packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method means a hard cut without testing in advance, which is not recommended.
    The update to Puppet 4 and later versions should only take place after in-depth
    testing of your Puppet manifest code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing as the Ruby gem extension or from tarball
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This approach requires a separate Ruby installation, which is not available
    on most modern Linux distributions. For Puppet 4, Ruby 2.1 is required. For Puppet
    5, Ruby 2.4 is needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update to Puppet 3.8, enable and migrate to the environment path settings, and
    enable the future parser only on a special testing environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The latter solution is the smartest and most backward compatible one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With Puppet 4 and later and the **All-in-One** (**AIO**) packaging from Puppet
    Labs, paths to Puppet configuration, modules, environments, and SSL certificates
    will change.
  prefs: []
  type: TYPE_NORMAL
- en: Puppet 4 and 5 stores its configuration (`puppet.conf`) in `/etc/puppetlabs/puppet`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hiera config will be located in `/etc/puppetlabs/hiera/hiera.yaml`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Puppet CA and certificates can be found at `/etc/puppetlabs/puppet/ssl`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Puppet Code (environments and modules) are looked up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: in `/etc/puppetlabs/code/environments/`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using Puppet 3.8 and environment directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The new parser was introduced in Puppet 3.5 alongside the old parser. To make
    use of the new language features, a special configuration item needed to be set
    explicitly. This allowed early adopters and people interested in the new technology
    to test the parser and check for code incompatibilities in an early stage.
  prefs: []
  type: TYPE_NORMAL
- en: On Puppet 3.x, the new parser was subject to change without further notice.
    Therefore, it is recommended to upgrade to the latest 3.x release.
  prefs: []
  type: TYPE_NORMAL
- en: 'With directory environments, it is possible to specify environment specific
    settings within an `environment.conf` configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Next, all your Puppet code needs to be put into the newly created environment
    path, including node classification.
  prefs: []
  type: TYPE_NORMAL
- en: 'On each of the different node types, it is now possible to manually run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Check both master and agent output and log files for any errors or unwanted
    changes and adapt your Puppet code if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: The Puppet 4 and 5 master
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure that your agents are prepared for operations with a Puppet 4 master.
    See the notes about agents in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Spinning up a new Puppet master is another approach. The following process assumes
    that the Puppet CA has been created using the DNS alt names setting in the `puppet.conf`
    file. If DNS alt names have been configured, it is required to completely recreate
    the Puppet CA.
  prefs: []
  type: TYPE_NORMAL
- en: Puppet CA needs to know about the **Common Name** (**CN**) of the Puppet master
    `fqdn`. It is possible to provide DNS alternative names, for which the CA will
    also be valid.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, Puppet uses the master `fqdn` for the common name. But if you provide
    the configuration attribute `dns_alt_names` prior to generating the CA, this configuration
    option will be added to the CA.
  prefs: []
  type: TYPE_NORMAL
- en: It is highly recommended to configure `dns_alt_names`. Having this enabled allows
    you to scale up to multiple compile masters and add an additional Puppet master
    for the migration process.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out whether DNS alt names have been added, you can use the `puppet
    cert` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will print all certificates. Check for the certificate of your
    Puppet master. For example, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following steps will guide you through the Puppet 4 setup. On a Debian
    7 based system, add the PC1 Puppet Labs repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Do not start the Puppet server process yet! It is required to run the new Puppet
    4 or 5 master as CA master, which needs the CA and certificates from the Puppet
    3 master copied over to the new Puppet 4 master.
  prefs: []
  type: TYPE_NORMAL
- en: As of this writing, the Puppet 5 Java-based master package requires Java 8 from
    backports for Debian 8\. Besides this, PuppetDB 5 now needs PostgreSQL 9.6, whereas
    PuppetDB for Puppet 4 must be used along with PostgreSQL 9.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the next step, all Puppet agents need a change on the `puppet.conf`
    file. You will need to provide different settings for `ca_server` and `server`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `ini_setting` resource type is available through the `puppetlabs-inifile`
    module from the Forge.
  prefs: []
  type: TYPE_NORMAL
- en: Now, place all your Puppet code on the new Puppet 4 master into an environment
    (`/etc/puppetlabs/code/environments/development/{manifests,modules}`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Test your code for Puppet 4 errors by running the following command on each
    of your nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Change your Puppet code to fix potential errors. Once no errors and no unwanted
    configuration changes occur on the Puppet 4 master and agents, your code is Puppet
    4 compatible.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach to verify your Puppet code being fully functional on Puppet
    4 and 5 is to compare catalogs. There are several solutions available. The most
    common ones are `puppetlabs-catalog_diff`, `zack-catalog`, and `octocatalog-diff`.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Puppet agent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is important to make sure that your existing agents are prepared to operate
    with a master that is already at version 4\. Check the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: All agents should use the latest version of Puppet 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The agent configuration should specify `stringify_facts = false`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The latter step prepares you for the agent update, because Puppet 4 will always
    behave the same as that and refrain from converting all fact values to the string
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Do make sure that you update to Puppet Server 2.1 or later. Passenger-based
    masters and Puppet Server 2.0 are not compatible with Puppet 3 agents.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Puppet online documentation contains many helpful details about this update
    path: [http://docs.puppetlabs.com/puppetserver/latest/compatibility_with_puppet_agent.html](http://docs.puppetlabs.com/puppetserver/latest/compatibility_with_puppet_agent.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Testing Puppet DSL code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another approach for verifying whether the existing Puppet code will work on
    Puppet 4 is unit and integration testing using `rspec-puppet` and `beaker`. This
    procedure is not within the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Whether you started fresh with Puppet 4 or used one of the preceding procedures
    to migrate your Puppet 3 infrastructure, it is now time to discover the benefits
    of the new version.
  prefs: []
  type: TYPE_NORMAL
- en: Using the type system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Older Puppet versions supported a small set of data types only: `Bool`, `String`,
    `Array`, and `Hash`. The Puppet DSL had almost no functionality to check for consistent
    variable types. Consider the following scenario.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A parameterized class enables other users of your code base to change the behavior
    and output of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This class definition checks whether the `server` parameter has been set to
    true. However, in this example, the class was not protected from wrong data usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this class declaration, the server parameter has been given a string instead
    of a bool value. Since the `false` string is not empty, the if `$server` condition
    actually passes. This is not what the user will expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within Puppet 3, it was recommended to add parameter validation using several
    functions from the `stdlib` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With one parameter only, this seems to be a good way. But what if you have many
    parameters? How do we deal with complex data types as hashes?
  prefs: []
  type: TYPE_NORMAL
- en: This is where the type system comes into play. The type system knows about many
    generic data types and follows patterns that are also used in many other modern
    programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Puppet differentiates between core data types and abstract data types. Core
    data types are the real data types, the ones which are mostly used in Puppet Code:'
  prefs: []
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integer, float, and numeric
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regexp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Undef
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the given example, the `server` parameter should be checked to always contain
    a bool value. The code can be simplified to the following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If the parameter is not given a Boolean value, Puppet will throw an error,
    explaining which parameter has a non-matching data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The error displayed is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `Numeric`, `Float`, and `Integer` data types have some more interesting
    aspects when it comes to variables and their type.
  prefs: []
  type: TYPE_NORMAL
- en: Puppet will automatically recognize `Integers`, consisting of numbers (either
    with or without the minus sign) and not having a decimal point.
  prefs: []
  type: TYPE_NORMAL
- en: '`Floats` are recognized by the decimal point. When doing arithmetic algebra
    on a combination of an `Integer` and a `Float`, the result will always be a `Float`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Floats` between `-1` and `1` must be written with a leading `0` digit prior
    to the decimal point; otherwise, Puppet will throw an error.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides this, Puppet has support for the decimal, octal, and hexadecimal notation,
    as known from C-like languages:'
  prefs: []
  type: TYPE_NORMAL
- en: A nonzero decimal must not start with a `0`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Octal values must start with a leading `0`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hexadecimal values have `0x` as the prefix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Puppet will automatically convert numbers into strings during the interpolation:
    `("Value of number: ${number}")`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Puppet will not convert strings to numbers. To make this happen, you can simply
    add 0 to a string to convert:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Default` data type is a little special. It does not directly refer to
    a data type, but can be used in selectors and case statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Abstract data types are constructs that are useful for a more sophisticated
    or permissive Type checking:'
  prefs: []
  type: TYPE_NORMAL
- en: Scalar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enum
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuple
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Struct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catalog entry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Assume that a parameter will only accept strings from a limited set. Only checking
    for being of type `String` is not sufficient. In this scenario, the `Enum` type
    is useful; a list of valid values are specified for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If the listen parameter is not set to one of the listed elements, Puppet will
    throw an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following error is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, it is difficult to use specific data types, because the parameter
    might be set to an `undef` value. Think of a `userlist` parameter that might be
    empty (`undef`) or set to an arbitrary array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the `Optional` type is for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, using a wrong data type will lead to a Puppet error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The error displayed is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we used a data type composition. This means that data
    types can have more information for type checking.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we want to set the `ssh` service port in our class. Normally,
    ssh should run on a privileged port between 1 and 1023\. In this case, we can
    restrict the integer data type to only allow numbers between 1 and 1023 by passing
    additional information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As always, providing a wrong parameter will lead to an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding line of code gives the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Complex hashes that use multiple data types that are very complicated to describe
    using the new type system.
  prefs: []
  type: TYPE_NORMAL
- en: When using the `Hash` type, it is only possible to check for a hash in general,
    or for a hash with keys of a specific type. You can optionally verify the minimum
    and maximum number of elements in the hash.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example provides a working hash type check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Notably, the `home` entry for user `jones` is missing the leading slash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code, gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding notation, the data type is valid. Yet there are errors inside
    the hash map.
  prefs: []
  type: TYPE_NORMAL
- en: 'Checking content of `Arrays` or `Hashes` requires the use of another abstract
    data type: `Tuple` (used for `Arrays`) or `Struct` (used for `Hashes`).'
  prefs: []
  type: TYPE_NORMAL
- en: However, the `Struct` data type will work only when the key names are from a
    known limited set, which is not the case in the given example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this special case, we have two possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Extend the `hash` data type to know about the hash internal structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrap the `type` data into a define, which makes use of all keys using the key
    function (from `stdlib`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first solution is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the error message is hard to understand when the data types are not
    matching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The second solution gives a smarter hint on which data might be wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This defined type is then employed from within the users class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: With the wrong submitted data in the hash, you will receive the following
  prefs: []
  type: TYPE_NORMAL
- en: 'error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The error message is pointing to the home parameter of the user `jones`, which
    is given in the hash. The correct hash is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code produces the expected result as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Next to the existing data types, Puppet offers the possibility to also build
    data types based on existing ones.
  prefs: []
  type: TYPE_NORMAL
- en: Within the last example we were matching a regular expression to identify an
    absolute path, but sometimes regular expressions might become very complex and
    hard to understand. This is where the type declaration comes into place.
  prefs: []
  type: TYPE_NORMAL
- en: A type declaration must be part of a module, use the module namespace as a prefix,
    and must be placed into the types directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The Windows and Unix path types have proper regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: The type system becomes handy when you want to validate a very specific data
    type. Think about a firewall module where you want to check for IPv4 or IPv6 addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the same pattern same as the `absolutepath` data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The preceding manifest uses the `each` function, another part of the Puppet
    4 language. The next section explores it in greater detail.
  prefs: []
  type: TYPE_NORMAL
- en: Learning lambdas and functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions have long been an essential part of Puppet. Due to the new type system,
    a complete new set of functions have become possible functions with different
    behavior based on parameter data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand functions, we first have to take a look at lambdas, which are
    introduced in Puppet 4\. Lambdas represent a snippet of Puppet code, which can
    be used in functions. Syntactically, lambdas consist of an optional type and at
    least one variable with optional defaults set, enclosed in pipe signs (`|`), followed
    by Puppet code inside a block of curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Lambdas are typically used on functions. The preceding example uses the `each`
    function on the `$packages` variable, iterating over its contents, setting the
    lambda variable `$package` within each iteration to the values `htop`, `less`,
    and `vim`, respectively. The Puppet code block uses the lambda variable inside
    a resource type declaration afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: The Puppet code in curly braces has to ensure that no duplicate resource declaration
    occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Since Puppet now knows about data types, you can interact and work with variables,
    and the data inside, in a far more elegant way.
  prefs: []
  type: TYPE_NORMAL
- en: 'in functions for arrays and hashes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Puppet 4 comes with a whole set of built-in functions for arrays and hashes:
    each'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: slice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: filter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: reduce
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: with
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have already seen the `each` function in action. Prior to Puppet 4, one
    needed to wrap the desired Puppet resource types into `define` and declare the
    `define` type using an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'With this concept, the action (create the `symlink`) was put into a define
    type and was no longer directly visible in the manifest. The new iteration approach
    keeps the action in the same location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Did you recognize that, this time, we used another approach of using a function?
    In the first example, we used the Puppet 3 style function calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Puppet 4 also supports the postfix notation, where the function is appended
    to its parameter using a dot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Puppet 4 supports both ways of using a function. This allows you to keep adhering
    to your code style and make use of the new functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run though the other functions for arrays and hashes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `slice` function allows you to split up and group an array or a hash. It
    needs an additional parameter (integer), defining how many objects should be grouped
    together:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will produce the following output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: When using the slice functions on a hash, one receives the keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (according to the amount of grouped keys) and accordingly,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the sub hash:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return the following output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `filter` function can be used to filter out specific entries inside an array
    or hash.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When used on an array, all elements are passed to the code block and the code
    block evaluates whether the entry does match. This is very useful if you want
    to filter out items of an array (for example, packages which should be installed):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return the following output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The behavior on hashes is different. When using hashes, one has to provide
    two lambda variables: `key` and `value`. You might want to only add users that
    have a specific `gid` set:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return only the users from the `admin` gid:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Creating Puppet 4 functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Puppet 3 functions API has some limitations and is missing features. The
    new function API in Puppet 4 improves upon that substantially.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the limitations of the old functions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The functions had no automatic type checking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These functions had to have a unique name due to a flat namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These functions were not private and, hence, could be used anywhere
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The documentation could not be retrieved without running the Ruby code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running on Puppet 3 requires functions to be in a module in the `lib/puppet/parser/functions`
    directory. Therefore, people referred to these functions as **parser functions**,
    but this name is misleading. Functions are unrelated to the Puppet parser.
  prefs: []
  type: TYPE_NORMAL
- en: In Puppet 4, functions have to be put into a module in path `lib/puppet/functions`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how you create a function that will return the hostname of the Puppet
    master:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Using `dispatch` adds type checking for attributes. Depending on desired functionality,
    one might have multiple `dispatch` blocks (checking for different data types).
    Each `dispatch` can refer to another defined Ruby method inside the function.
    This reference is possible by using the same names for `dispatch` and the Ruby
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example code should get additional functionality; depending on
    the type of argument, the function should either return the hostname of the local
    system, or use DNS to get the hostname from an IPv4 address or the `ipaddress`
    for a given hostname:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning of the file, we have to load some Ruby modules to allow the
    DNS name resolution and to find the local hostname.
  prefs: []
  type: TYPE_NORMAL
- en: The first two `dispatch` sections check for the data type of the parameter value
    and set a unique symbol. The last `dispatch` section does not check for data types,
    which matches when no parameter was given.
  prefs: []
  type: TYPE_NORMAL
- en: Each defined Ruby method uses the name of the according `dispatch` and executes
    Ruby code depending on the parameter type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the resolver function can be used from inside the Puppet manifest code
    in three different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'When declaring this class, the following output will show up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: With Puppet 3 functions, it was impossible to have two functions of the same
    name. One always had to check whether duplicate functions appeared when making
    use of a new module.
  prefs: []
  type: TYPE_NORMAL
- en: The Puppet 4 functions now offer the possibility of using namespacing just the
    same as classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s migrate our function into the class namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In the example, the code needs to be in `resolver/lib/puppet/functions/resolver/resolve.rb`,
    which corresponds to `function name: ''resolver::resolve''`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions with namespaces are invoked as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Leveraging the new template engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 6](60cec52e-6b29-4028-bc15-3b5685598e6b.xhtml), *The Puppet Beginners
    Advanced Parts*, we introduced templates and the ERB template engine. In Puppet
    4, an alternative was added: the EPP template engine. The major differences between
    the template engines are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In ERB templates, you cannot specify a variable in Puppet syntax (`$variable_name`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ERB templates will not accept parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In EPP templates, you will use the Puppet DSL syntax instead of Ruby syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The EPP template engine requires scoped variables from modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The manifest defines the following local variable: `<%= $motd::local_variable
    %>`. The EPP templates also have a unique extension: they can take typed parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make use of this, a template has to start with a parameter declaration block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'These parameters are not as variables from Puppet manifests. Instead, one must
    pass parameters using the `epp` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: A template without parameters should only be used when the template is used
    exclusively by one module, so that it is safe to rely on the availability of Puppet
    variables to customize the content.
  prefs: []
  type: TYPE_NORMAL
- en: Using the EPP template function with parameters is recommended when a template
    is used from several places. By declaring the parameters at the beginning, it
    is especially clear what data the template requires.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a specific difference between the template engines when iterating
    over arrays and hashes. The ERB syntax uses Ruby code with unscoped, local variables,
    whereas the EPP syntax requires specifying Puppet DSL code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The inline ERB function was also supplemented with inline EPP. Using the inline
    EPP, one can specify a small snippet of EPP code to get evaluated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Prior to Puppet 4, it was inconvenient to pass more than a small code snippet.
    With Puppet 4 and the HEREDOC support, complex templates in combination with `inline_epp`
    are easier and better readable.
  prefs: []
  type: TYPE_NORMAL
- en: Handling multiline with HEREDOC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing multiline file fragments in Puppet mostly resulted in code that was
    hard to read, mostly due to indentation. With Puppet 4, the `heredoc` style was
    added. It is now possible to specify a `heredoc` tag and marker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The `heredoc` tag starts with an `@` sign followed by arbitrary string enclosed
    in parenthesis. The `heredoc` marker is the string given in the tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'If variables are required inside the `heredoc` document, the variable interpolation
    can be enabled by putting the tag string in double quotes. Variables inside the
    `heredoc` are written the same as Puppet DSL variables: a dollar sign followed
    by the scope and the variable name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Normally, `heredoc` does not handle escape sequences. Escape sequences need
    to be enabled explicitly. As of Puppet 4.2, `heredoc` has the following escape
    sequences available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*` `\n` Newline'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` `\r` Carriage return'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` `\t` Tab'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` `\s` Space'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` `\$` Literal dollar sign (preventing interpolation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` `\u` Unicode character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\L` Nothing (ignore line breaks in source code)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enabled escape sequences have to be placed behind the string of the `heredoc`
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In the example, the text always starts in the first column, which makes it hard
    to read and stands out from the code around it, which will usually be indented
    by some amount of whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to strip indentation by placing whitespaces and a pipe sign
    in front of the `heredoc` marker. The pipe sign will indicate the first character
    of each line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now `heredoc` and `inline_epp` can be easily combined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Declaring this class will give the following result in the `motd` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: When using `heredoc` in combination with `inline_epp`, you want to take care
    to not quote the `heredoc` start tag. Otherwise, the variable substitution will
    take place prior to the `inline_epp` function call.
  prefs: []
  type: TYPE_NORMAL
- en: Using Puppet 5 server metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Puppetserver Version 5 the former Puppet Enterprise only metrics system
    has been ported to Puppet Open Source.
  prefs: []
  type: TYPE_NORMAL
- en: The metrics system allows you to read internal information like compile times,
    status of file serving and function runtimes from a JMX console or to push the
    data to a graphite system.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the metrics system is straightforward by editing the puppet server
    `metrics.conf` file located at `/etc/puppetlabs/puppetserver/conf.d/metrics.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three important settings. At the `metrics.server-id` one can specify
    an ID which is later used in the Grafana dashboard. The `metrics.registry.puppetserver.reporters.graphite.enabled`
    value must be set to true and the `metrics.reporters.graphite` hash must mention
    the graphite hostname and port and the update interval setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to restart the `puppetserver` process after doing changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For automated setup one wants to use the `puppetlabs-hocon` module which is
    able to set all desired values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The setup of praphite is beyond the scope of this book. There is a puppet module
    available for evaluation purpose ([http://github.com/tuxmea/puppet-grafanadash](http://github.com/tuxmea/puppet-grafanadash)).
  prefs: []
  type: TYPE_NORMAL
- en: This module installs and configures elasticsearch, graphite, and grafana on
    a CentOS 7 system.
  prefs: []
  type: TYPE_NORMAL
- en: 'You only need to include the `grfanadash::dev` class on a node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Afterwards you can access graphite on `http://graphite.example.com` and grafana
    at `http://graphite.example-com:10000`. Within the grafana dashboard one can load
    the `.json` file from module examples folder.
  prefs: []
  type: TYPE_NORMAL
- en: Please be aware that it might take up to 10 minutes prior values will show up
    in grafana.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking old practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When Puppet Labs decided to work on the parser and on the new features, they
    also decided to remove some features that had already been deprecated for a couple
    of releases.
  prefs: []
  type: TYPE_NORMAL
- en: Converting node inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Node inheritance has been considered good practice during older Puppet releases.
    To avoid too much code on the node level, a generic, nonexistent host was created
    (`basenode`) and the real nodes inherited from `basenode`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This node classification is no longer supported by Puppet 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'As of 2012, the roles and profiles pattern became increasingly popular, bringing
    new methods on how to allow smart node classification. From a technical point
    of view, roles and profiles are Puppet classes. The profile module wraps technical
    modules and adapts their usage to the existing infrastructure by providing data
    such as `ntp` servers and `ssh` configuration options. The role module describes
    system business use cases and makes use of the declared profiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The final chapter will describe the roles and profiles pattern in some more
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with bool algebra on Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A minor change with a huge impact is the change of empty string comparison.
    Prior to Puppet 4, one could test for either an unset variable or a variable containing
    an empty string by checking for the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ssh` class behaved similarly ($server evaluates to true) when used within
    the following different declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Disabling the server section in the `ssh` class could be achieved by the following
    class declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The behavior of the last example (empty string) changed in Puppet 4\. The empty
    string now equals a true value in Boolean context, just as in Ruby. If your code
    makes use of this way of variable checking, you need to add the check for empty
    string to retain the same behavior with Puppet 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Using strict variable naming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Variables sometimes look the same as constants and exhibit the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Variables cannot be declared again
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the scope of one node, most variables are static (`hostname`, `fqdn`, and
    so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, developers prefer to write the variables in capital letters due to
    the previously mentioned items, to make them look the same as Ruby constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Puppet 4, variable names must not start with a capital letter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Declaring this class will now produce the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Learning the new reference syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Due to the type system and due to the reason that Puppet 4 now takes everything
    as an expression, one has to name references on other declared resources properly.
    References now have some strict regulations:'
  prefs: []
  type: TYPE_NORMAL
- en: No whitespace between reference type and opening bracket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reference title (used without quotes) must not be spelled with a capital
    letter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following will produce errors on Puppet 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting with Puppet 4, references have to be written in the following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Our example needs to be changed to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Cleaning hyphens in names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many modules (even on the module Forge) have used the hyphen in the
  prefs: []
  type: TYPE_NORMAL
- en: 'module name. The hyphen is now no longer a string character, but a mathematical
    operator (subtraction). In consequence, hyphens are now strictly forbidden in
    the following descriptors:'
  prefs: []
  type: TYPE_NORMAL
- en: The module name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any class name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Names of defined types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using modules with hyphens, the hyphen needs to be removed or replaced
    with a string character (for example, the underscore).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is possible with older versions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the new style is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: No Ruby DSL anymore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some people used the possibility to put `.rb` files as manifests inside modules.
    These `.rb` files contained Ruby code and were mostly needed for working with
    data. Puppet 4 now has data types that make this obsolete.
  prefs: []
  type: TYPE_NORMAL
- en: The support for these Ruby manifests has been removed in Puppet 4.
  prefs: []
  type: TYPE_NORMAL
- en: Relative class name resolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With Puppet 3 and older, it was required to specify absolute class names in
    case that a local class name was identical to another module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the scope of the `application::` namespace, Puppet 3 would search this
    namespace for a `mysql` class to be included. Effectively, the `application::mysql`
    class would include itself. However, this was not what we intended to do. We were
    looking for the `mysql` module instead. As a workaround, everybody was encouraged
    to specify the absolute path to the `mysql` module class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: This relative name resolution no longer applies in Puppet 4\. The original example
    works now.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with different data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because Puppet 3 was not aware of the different data types
  prefs: []
  type: TYPE_NORMAL
- en: (mostly everything was dealt with as being of type string), it was possible
    to combine several different data types.
  prefs: []
  type: TYPE_NORMAL
- en: Puppet 4 is now very strict when it comes to combining different data types.
    The easiest example is dealing with float and integer; when adding a float and
    an integer, the result will be of type float.
  prefs: []
  type: TYPE_NORMAL
- en: 'Combining actions on different data types, such as string and bool, will now
    result in an error. The following code will work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, the following code will not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'You will receive the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Review the comparison of different Facter variables carefully. Some Facter variables,
    such as `operatingsystemmajrelease`, return data of the type string; whereas `processorcount`
    returns an integer value.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Upgrading to Puppet 3 should be done in a step-by-step procedure where your
    existing code will be evaluated using Puppet 3.8 and the new parser.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the type system, it is now possible to deal with data in a far more
    elegant way directly in your Puppet DSL code. The new functions API allows you
    to immediately recognize to which module a function belongs by using namespaces.
    Similar functions can now be combined within a single file by making use of the
    `dispatch` method and data types, allowing a form of function overloading.
  prefs: []
  type: TYPE_NORMAL
- en: The new EPP templates offer better understanding of variable sources by using
    the Puppet syntax for variable references. Passing parameters to templates will
    allow you to make use of modules in a more flexible way.
  prefs: []
  type: TYPE_NORMAL
- en: Combining EPP templates and the HEREDOC syntax will allow you to keep template
    code and data directly visible inside your classes.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapter, you will learn about Hiera and how it can help you
    bring order to a scalable Puppet code base.
  prefs: []
  type: TYPE_NORMAL
