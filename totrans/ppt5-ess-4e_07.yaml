- en: New Features from Puppet 4 and 5
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Puppet 4 和 5 的新特性
- en: Now that we have a complete overview of the Puppet DSL and its concepts, it
    is time to look at the newest Puppet features, which were introduced with Puppet
    version 4\. The parser, which compiles the catalog, was basically rewritten from
    scratch for better performance. The milestone release also added some missing
    functionality and coding principles.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对 Puppet DSL 及其概念有了全面了解，接下来是时候看看 Puppet 4 版本引入的新特性了。解析器（编译目录的工具）为了更好的性能，几乎是从零开始重写的。这个里程碑版本还增加了一些缺失的功能和编码原则。
- en: Puppet 4 and newer versions do not only offer new functionality, but break with
    old practices and remove some functionality that is not considered best practice
    anymore. This necessitates that any existing manifest code needs proper testing,
    and potentially needs lots of changes to be compatible with Puppet 4.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 4 及更高版本不仅提供了新功能，还打破了旧的做法，移除了一些不再被认为是最佳实践的功能。这要求现有的 manifest 代码需要进行适当的测试，并且可能需要进行大量修改以兼容
    Puppet 4。
- en: 'Within this chapter, the following topics will be covered:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Upgrading to Puppet 4
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级到 Puppet 4
- en: Using the Puppet type system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Puppet 类型系统
- en: Learning lambdas and functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 Lambda 函数和常规函数
- en: Creating Puppet 4 functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Puppet 4 函数
- en: Leveraging the new template engine
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用新的模板引擎
- en: Handling multiline with HEREDOC
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HEREDOC 处理多行文本
- en: Puppet 5 server metrics
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet 5 服务器指标
- en: Breaking old practices
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打破旧有的做法
- en: Upgrading to Puppet 4
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 升级到 Puppet 4
- en: Let's first look at how users of the older Puppet 3 series can approach the
    update.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们看看 Puppet 3 版本的用户如何进行更新。
- en: Instead of upgrading your Puppet master machine, consider setting up a new server
    in parallel and migrating the service carefully. This has some advantages. For
    example, rolling back in case of problems is quite easy.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与其升级 Puppet 主机，不如并行设置一台新服务器，并仔细迁移服务。这有一些优点，例如，如果遇到问题，可以轻松回滚。
- en: 'The new Puppet 4 and later versions can be installed in several ways:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 Puppet 4 及更高版本可以通过多种方式进行安装：
- en: Using the Puppet Labs repositories, which will remove older Puppet packages
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Puppet Labs 的软件仓库，它们将移除旧的 Puppet 包。
- en: This method means a hard cut without testing in advance, which is not recommended.
    The update to Puppet 4 and later versions should only take place after in-depth
    testing of your Puppet manifest code
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种方法意味着没有提前进行测试的强制切换，不推荐使用。在对 Puppet manifest 代码进行深入测试后，才应升级到 Puppet 4 及更高版本。
- en: Installing as the Ruby gem extension or from tarball
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 Ruby gem 扩展或从 tarball 安装
- en: This approach requires a separate Ruby installation, which is not available
    on most modern Linux distributions. For Puppet 4, Ruby 2.1 is required. For Puppet
    5, Ruby 2.4 is needed
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种方法需要单独安装 Ruby，但大多数现代 Linux 发行版并没有提供 Ruby。对于 Puppet 4，要求 Ruby 2.1；对于 Puppet
    5，需要 Ruby 2.4。
- en: Update to Puppet 3.8, enable and migrate to the environment path settings, and
    enable the future parser only on a special testing environment
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新到 Puppet 3.8，启用并迁移到环境路径设置，并且仅在特定的测试环境中启用未来解析器。
- en: The latter solution is the smartest and most backward compatible one
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后者的解决方案是最智能的，也是最具向后兼容性的。
- en: With Puppet 4 and later and the **All-in-One** (**AIO**) packaging from Puppet
    Labs, paths to Puppet configuration, modules, environments, and SSL certificates
    will change.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Puppet 4 及更高版本，以及 Puppet Labs 提供的 **All-in-One** (**AIO**) 打包方式，Puppet 配置、模块、环境和
    SSL 证书的路径将会发生变化。
- en: Puppet 4 and 5 stores its configuration (`puppet.conf`) in `/etc/puppetlabs/puppet`
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet 4 和 5 将其配置文件（`puppet.conf`）存储在 `/etc/puppetlabs/puppet` 目录下。
- en: Hiera config will be located in `/etc/puppetlabs/hiera/hiera.yaml`
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hiera 配置文件位于 `/etc/puppetlabs/hiera/hiera.yaml`。
- en: Puppet CA and certificates can be found at `/etc/puppetlabs/puppet/ssl`
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet CA 和证书可以在 `/etc/puppetlabs/puppet/ssl` 中找到。
- en: Puppet Code (environments and modules) are looked up
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找 Puppet 代码（环境和模块）
- en: in `/etc/puppetlabs/code/environments/`
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 安装到 `/etc/puppetlabs/code/environments/` 中
- en: Using Puppet 3.8 and environment directories
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Puppet 3.8 和环境目录
- en: The new parser was introduced in Puppet 3.5 alongside the old parser. To make
    use of the new language features, a special configuration item needed to be set
    explicitly. This allowed early adopters and people interested in the new technology
    to test the parser and check for code incompatibilities in an early stage.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 新的解析器在 Puppet 3.5 中与旧的解析器一同引入。为了使用新的语言特性，需要显式设置一个特殊的配置项。这使得早期用户和对新技术感兴趣的人可以在早期阶段测试解析器并检查代码的不兼容问题。
- en: On Puppet 3.x, the new parser was subject to change without further notice.
    Therefore, it is recommended to upgrade to the latest 3.x release.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puppet 3.x 上，新的解析器可能会在没有进一步通知的情况下发生变化。因此，建议升级到最新的 3.x 版本。
- en: 'With directory environments, it is possible to specify environment specific
    settings within an `environment.conf` configuration file:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用目录环境，可以在 `environment.conf` 配置文件中指定特定环境的设置：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, all your Puppet code needs to be put into the newly created environment
    path, including node classification.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你的所有 Puppet 代码需要放入新创建的环境路径中，包括节点分类。
- en: 'On each of the different node types, it is now possible to manually run:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在每种不同的节点类型上，可以手动运行：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Check both master and agent output and log files for any errors or unwanted
    changes and adapt your Puppet code if necessary.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 检查主机和代理的输出及日志文件，查看是否有错误或不需要的更改，并根据需要调整你的 Puppet 代码。
- en: The Puppet 4 and 5 master
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Puppet 4 和 5 主机
- en: Make sure that your agents are prepared for operations with a Puppet 4 master.
    See the notes about agents in the following section.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的代理准备好与 Puppet 4 主机一起操作。有关代理的说明，请参见以下部分。
- en: Spinning up a new Puppet master is another approach. The following process assumes
    that the Puppet CA has been created using the DNS alt names setting in the `puppet.conf`
    file. If DNS alt names have been configured, it is required to completely recreate
    the Puppet CA.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个新的 Puppet 主机是另一种方法。以下过程假设已经使用 `puppet.conf` 文件中的 DNS 替代名称设置创建了 Puppet CA。如果已配置了
    DNS 替代名称，则需要完全重新创建 Puppet CA。
- en: Puppet CA needs to know about the **Common Name** (**CN**) of the Puppet master
    `fqdn`. It is possible to provide DNS alternative names, for which the CA will
    also be valid.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet CA 需要了解 Puppet 主机 `fqdn` 的**通用名称**（**CN**）。可以提供 DNS 替代名称，CA 也将对其有效。
- en: Normally, Puppet uses the master `fqdn` for the common name. But if you provide
    the configuration attribute `dns_alt_names` prior to generating the CA, this configuration
    option will be added to the CA.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Puppet 使用主机的 `fqdn` 作为通用名称。但如果你在生成 CA 之前提供了配置属性 `dns_alt_names`，此配置选项将被添加到
    CA 中。
- en: It is highly recommended to configure `dns_alt_names`. Having this enabled allows
    you to scale up to multiple compile masters and add an additional Puppet master
    for the migration process.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议配置 `dns_alt_names`。启用此选项后，你可以扩展到多个编译主机，并为迁移过程添加额外的 Puppet 主机。
- en: 'To find out whether DNS alt names have been added, you can use the `puppet
    cert` command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 若要查找是否已添加 DNS 替代名称，可以使用 `puppet cert` 命令：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This command will print all certificates. Check for the certificate of your
    Puppet master. For example, consider the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将打印所有证书。检查你 Puppet 主机的证书。例如，考虑以下内容：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following steps will guide you through the Puppet 4 setup. On a Debian
    7 based system, add the PC1 Puppet Labs repository:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导你完成 Puppet 4 的设置。在基于 Debian 7 的系统上，添加 PC1 Puppet Labs 仓库：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Do not start the Puppet server process yet! It is required to run the new Puppet
    4 or 5 master as CA master, which needs the CA and certificates from the Puppet
    3 master copied over to the new Puppet 4 master.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 还不要启动 Puppet 服务器进程！需要将新的 Puppet 4 或 5 主机作为 CA 主机运行，这需要将 Puppet 3 主机的 CA 和证书复制到新的
    Puppet 4 主机。
- en: As of this writing, the Puppet 5 Java-based master package requires Java 8 from
    backports for Debian 8\. Besides this, PuppetDB 5 now needs PostgreSQL 9.6, whereas
    PuppetDB for Puppet 4 must be used along with PostgreSQL 9.4.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，基于 Java 的 Puppet 5 主机包需要来自 Debian 8 的 Java 8 回溯包。除此之外，PuppetDB 5 现在需要 PostgreSQL
    9.6，而 Puppet 4 的 PuppetDB 必须与 PostgreSQL 9.4 一起使用。
- en: 'Within the next step, all Puppet agents need a change on the `puppet.conf`
    file. You will need to provide different settings for `ca_server` and `server`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，所有 Puppet 代理都需要修改 `puppet.conf` 文件。你需要为 `ca_server` 和 `server` 提供不同的设置：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `ini_setting` resource type is available through the `puppetlabs-inifile`
    module from the Forge.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`ini_setting` 资源类型可通过 Forge 上的 `puppetlabs-inifile` 模块使用。'
- en: Now, place all your Puppet code on the new Puppet 4 master into an environment
    (`/etc/puppetlabs/code/environments/development/{manifests,modules}`).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将你的所有 Puppet 代码放到新的 Puppet 4 主机上的一个环境中（`/etc/puppetlabs/code/environments/development/{manifests,modules}`）。
- en: 'Test your code for Puppet 4 errors by running the following command on each
    of your nodes:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在每个节点上运行以下命令来测试你的 Puppet 4 错误：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Change your Puppet code to fix potential errors. Once no errors and no unwanted
    configuration changes occur on the Puppet 4 master and agents, your code is Puppet
    4 compatible.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 更改你的 Puppet 代码以修复潜在的错误。一旦在 Puppet 4 主节点和代理上没有错误，也没有不希望的配置更改，你的代码就是与 Puppet 4
    兼容的。
- en: Another approach to verify your Puppet code being fully functional on Puppet
    4 and 5 is to compare catalogs. There are several solutions available. The most
    common ones are `puppetlabs-catalog_diff`, `zack-catalog`, and `octocatalog-diff`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种验证你的 Puppet 代码在 Puppet 4 和 5 上完全正常工作的方式是比较目录。现在有几种解决方案可用。最常见的有 `puppetlabs-catalog_diff`、`zack-catalog`
    和 `octocatalog-diff`。
- en: Updating the Puppet agent
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新 Puppet 代理
- en: 'It is important to make sure that your existing agents are prepared to operate
    with a master that is already at version 4\. Check the following aspects:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 确保现有的代理已准备好与已经是版本 4 的主节点一起操作非常重要。请检查以下方面：
- en: All agents should use the latest version of Puppet 3
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有代理应该使用最新版本的 Puppet 3
- en: The agent configuration should specify `stringify_facts = false`
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理配置应指定 `stringify_facts = false`
- en: The latter step prepares you for the agent update, because Puppet 4 will always
    behave the same as that and refrain from converting all fact values to the string
    type.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 后续步骤为代理更新做好准备，因为 Puppet 4 始终会表现得像这样，并且避免将所有事实值转换为字符串类型。
- en: Do make sure that you update to Puppet Server 2.1 or later. Passenger-based
    masters and Puppet Server 2.0 are not compatible with Puppet 3 agents.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保你更新到 Puppet Server 2.1 或更高版本。基于 Passenger 的主节点和 Puppet Server 2.0 与 Puppet
    3 代理不兼容。
- en: 'The Puppet online documentation contains many helpful details about this update
    path: [http://docs.puppetlabs.com/puppetserver/latest/compatibility_with_puppet_agent.html](http://docs.puppetlabs.com/puppetserver/latest/compatibility_with_puppet_agent.html).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 在线文档包含了许多关于此更新路径的有用细节：[http://docs.puppetlabs.com/puppetserver/latest/compatibility_with_puppet_agent.html](http://docs.puppetlabs.com/puppetserver/latest/compatibility_with_puppet_agent.html)。
- en: Testing Puppet DSL code
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 Puppet DSL 代码
- en: Another approach for verifying whether the existing Puppet code will work on
    Puppet 4 is unit and integration testing using `rspec-puppet` and `beaker`. This
    procedure is not within the scope of this book.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种验证现有 Puppet 代码是否能在 Puppet 4 上运行的方法是使用 `rspec-puppet` 和 `beaker` 进行单元和集成测试。此过程不在本书的范围内。
- en: Whether you started fresh with Puppet 4 or used one of the preceding procedures
    to migrate your Puppet 3 infrastructure, it is now time to discover the benefits
    of the new version.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是全新开始使用 Puppet 4，还是使用上述程序之一迁移 Puppet 3 基础设施，现在是时候发现新版本的好处了。
- en: Using the type system
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型系统
- en: 'Older Puppet versions supported a small set of data types only: `Bool`, `String`,
    `Array`, and `Hash`. The Puppet DSL had almost no functionality to check for consistent
    variable types. Consider the following scenario.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版本的 Puppet 只支持一小部分数据类型：`Bool`、`String`、`Array` 和 `Hash`。Puppet DSL 几乎没有检查一致变量类型的功能。请考虑以下场景。
- en: 'A parameterized class enables other users of your code base to change the behavior
    and output of the class:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 带参数的类使代码库中的其他用户能够更改类的行为和输出：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This class definition checks whether the `server` parameter has been set to
    true. However, in this example, the class was not protected from wrong data usage:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类定义检查是否已将 `server` 参数设置为 true。然而，在这个示例中，类并未防止错误数据的使用：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this class declaration, the server parameter has been given a string instead
    of a bool value. Since the `false` string is not empty, the if `$server` condition
    actually passes. This is not what the user will expect.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类声明中，`server` 参数被赋予了一个字符串而不是布尔值。由于 `false` 字符串不为空，因此 if `$server` 条件实际上会通过。这不是用户预期的结果。
- en: 'Within Puppet 3, it was recommended to add parameter validation using several
    functions from the `stdlib` module:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puppet 3 中，推荐使用 `stdlib` 模块中的多个函数来添加参数验证：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With one parameter only, this seems to be a good way. But what if you have many
    parameters? How do we deal with complex data types as hashes?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用一个参数时，这似乎是一个不错的方法。但如果你有多个参数呢？我们如何处理像哈希表这样的复杂数据类型？
- en: This is where the type system comes into play. The type system knows about many
    generic data types and follows patterns that are also used in many other modern
    programming languages.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是类型系统发挥作用的地方。类型系统了解许多通用数据类型，并遵循许多现代编程语言中也使用的模式。
- en: 'Puppet differentiates between core data types and abstract data types. Core
    data types are the real data types, the ones which are mostly used in Puppet Code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet区分核心数据类型和抽象数据类型。核心数据类型是真正的数据类型，是Puppet代码中最常用的类型：
- en: String
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Integer, float, and numeric
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整型、浮动型和数字型
- en: Boolean
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值
- en: Array
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Hash
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希
- en: Regexp
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式
- en: Undef
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未定义
- en: Default
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认
- en: 'In the given example, the `server` parameter should be checked to always contain
    a bool value. The code can be simplified to the following pattern:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的示例中，`server`参数应始终检查是否包含布尔值。代码可以简化为以下模式：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If the parameter is not given a Boolean value, Puppet will throw an error,
    explaining which parameter has a non-matching data type:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未给定布尔值参数，Puppet将抛出错误，并说明哪个参数的数据类型不匹配：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The error displayed is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的错误如下：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `Numeric`, `Float`, and `Integer` data types have some more interesting
    aspects when it comes to variables and their type.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`Numeric`、`Float`和`Integer`数据类型在变量及其类型方面有一些更有趣的方面。'
- en: Puppet will automatically recognize `Integers`, consisting of numbers (either
    with or without the minus sign) and not having a decimal point.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet会自动识别由数字（无论是否带有负号）组成且没有小数点的`Integers`。
- en: '`Floats` are recognized by the decimal point. When doing arithmetic algebra
    on a combination of an `Integer` and a `Float`, the result will always be a `Float`.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Floats`通过小数点来识别。当对`Integer`和`Float`的组合进行算术运算时，结果将始终是`Float`。'
- en: '`Floats` between `-1` and `1` must be written with a leading `0` digit prior
    to the decimal point; otherwise, Puppet will throw an error.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Floats`在`-1`和`1`之间的数值必须在小数点前写上`0`数字，否则，Puppet会抛出错误。'
- en: 'Besides this, Puppet has support for the decimal, octal, and hexadecimal notation,
    as known from C-like languages:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Puppet还支持十进制、八进制和十六进制表示法，类似于C语言等语言的表示法：
- en: A nonzero decimal must not start with a `0`
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非零十进制数不能以`0`开头
- en: Octal values must start with a leading `0`
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 八进制值必须以前导`0`开始
- en: Hexadecimal values have `0x` as the prefix
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十六进制值的前缀是`0x`
- en: 'Puppet will automatically convert numbers into strings during the interpolation:
    `("Value of number: ${number}")`.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 'Puppet会在插值过程中自动将数字转换为字符串：`("Value of number: ${number}")`。'
- en: 'Puppet will not convert strings to numbers. To make this happen, you can simply
    add 0 to a string to convert:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet不会将字符串转换为数字。要实现这一点，你可以简单地在字符串上加上0来转换：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `Default` data type is a little special. It does not directly refer to
    a data type, but can be used in selectors and case statements:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`Default`数据类型有些特殊。它并不直接指代一个数据类型，但可以在选择器和案例语句中使用：'
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Abstract data types are constructs that are useful for a more sophisticated
    or permissive Type checking:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象数据类型是有助于更复杂或宽松的类型检查的构造：
- en: Scalar
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标量
- en: Collection
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合
- en: Variant
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变体
- en: Data
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据
- en: Pattern
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式
- en: Enum
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: Tuple
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组
- en: Struct
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体
- en: Optional
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Optional
- en: Catalog entry
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录条目
- en: Type
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型
- en: Any
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任意
- en: Callable
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可调用
- en: 'Assume that a parameter will only accept strings from a limited set. Only checking
    for being of type `String` is not sufficient. In this scenario, the `Enum` type
    is useful; a list of valid values are specified for it:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个参数只接受来自有限集合的字符串。仅检查是否为`String`类型是不足够的。在这种情况下，`Enum`类型很有用；可以为其指定一系列有效值：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If the listen parameter is not set to one of the listed elements, Puppet will
    throw an error:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`listen`参数未设置为列出元素之一，Puppet将抛出错误：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following error is displayed:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 显示以下错误：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Sometimes, it is difficult to use specific data types, because the parameter
    might be set to an `undef` value. Think of a `userlist` parameter that might be
    empty (`undef`) or set to an arbitrary array of strings.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，使用特定数据类型比较困难，因为参数可能被设置为`undef`值。考虑一个可能为空（`undef`）或设置为任意字符串数组的`userlist`参数。
- en: 'This is what the `Optional` type is for:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`Optional`类型的作用：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Again, using a wrong data type will lead to a Puppet error:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，使用错误的数据类型会导致Puppet错误：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The error displayed is as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的错误如下：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the previous example, we used a data type composition. This means that data
    types can have more information for type checking.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了数据类型组合。这意味着数据类型可以拥有更多的类型检查信息。
- en: 'Let''s assume that we want to set the `ssh` service port in our class. Normally,
    ssh should run on a privileged port between 1 and 1023\. In this case, we can
    restrict the integer data type to only allow numbers between 1 and 1023 by passing
    additional information:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在类中设置 `ssh` 服务端口。通常，ssh 应该运行在 1 到 1023 之间的特权端口上。在这种情况下，我们可以通过传递额外信息，将整数数据类型限制为只允许
    1 到 1023 之间的数字：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As always, providing a wrong parameter will lead to an error:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，提供错误的参数会导致错误：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding line of code gives the following error:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码行给出了以下错误：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Complex hashes that use multiple data types that are very complicated to describe
    using the new type system.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多种数据类型的复杂哈希，在新类型系统下非常难以描述。
- en: When using the `Hash` type, it is only possible to check for a hash in general,
    or for a hash with keys of a specific type. You can optionally verify the minimum
    and maximum number of elements in the hash.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Hash` 类型时，只能检查一般的哈希，或检查具有特定类型键的哈希。你可以选择性地验证哈希中的最小和最大元素数量。
- en: 'The following example provides a working hash type check:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例提供了一个有效的哈希类型检查：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Notably, the `home` entry for user `jones` is missing the leading slash:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，用户 `jones` 的 `home` 条目缺少前导斜杠：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Running the preceding code, gives us the following output:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码，将会得到以下输出：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With the preceding notation, the data type is valid. Yet there are errors inside
    the hash map.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述符号，数据类型是有效的，但哈希图内部存在错误。
- en: 'Checking content of `Arrays` or `Hashes` requires the use of another abstract
    data type: `Tuple` (used for `Arrays`) or `Struct` (used for `Hashes`).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 `Arrays` 或 `Hashes` 的内容需要使用另一种抽象数据类型：`Tuple`（用于 `Arrays`）或 `Struct`（用于 `Hashes`）。
- en: However, the `Struct` data type will work only when the key names are from a
    known limited set, which is not the case in the given example.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Struct` 数据类型只会在键名来自已知有限集时工作，这在给定的示例中并不适用。
- en: 'In this special case, we have two possibilities:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特殊情况下，我们有两个可能的选择：
- en: Extend the `hash` data type to know about the hash internal structure
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展 `hash` 数据类型以了解哈希的内部结构
- en: Wrap the `type` data into a define, which makes use of all keys using the key
    function (from `stdlib`)
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `type` 数据包装成一个定义，使用所有键并利用键函数（来自 `stdlib`）
- en: 'The first solution is as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个解决方案如下：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'However, the error message is hard to understand when the data types are not
    matching:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当数据类型不匹配时，错误信息很难理解：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The second solution gives a smarter hint on which data might be wrong:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个解决方案给出了一个更聪明的提示，指示哪些数据可能是错误的：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This defined type is then employed from within the users class:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 该定义类型随后会在用户类中使用：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With the wrong submitted data in the hash, you will receive the following
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在哈希中提交了错误的数据，你将收到以下信息：
- en: 'error message:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The error message is pointing to the home parameter of the user `jones`, which
    is given in the hash. The correct hash is as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息指向用户 `jones` 的 home 参数，该参数在哈希中给出。正确的哈希如下：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The preceding code produces the expected result as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码产生了预期的结果，如下所示：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Next to the existing data types, Puppet offers the possibility to also build
    data types based on existing ones.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 除了现有的数据类型，Puppet 还提供了基于现有数据类型构建新数据类型的可能性。
- en: Within the last example we were matching a regular expression to identify an
    absolute path, but sometimes regular expressions might become very complex and
    hard to understand. This is where the type declaration comes into place.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个示例中，我们使用正则表达式来匹配绝对路径，但有时正则表达式可能变得非常复杂且难以理解。这时，类型声明就派上了用场。
- en: A type declaration must be part of a module, use the module namespace as a prefix,
    and must be placed into the types directory.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 类型声明必须是模块的一部分，使用模块命名空间作为前缀，并且必须放置在类型目录中。
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The Windows and Unix path types have proper regular expressions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 和 Unix 路径类型具有适当的正则表达式。
- en: The type system becomes handy when you want to validate a very specific data
    type. Think about a firewall module where you want to check for IPv4 or IPv6 addresses.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要验证一个非常特定的数据类型时，类型系统非常有用。想想防火墙模块，你可能需要检查IPv4或IPv6地址。
- en: 'We can use the same pattern same as the `absolutepath` data type:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用与 `absolutepath` 数据类型相同的模式：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The preceding manifest uses the `each` function, another part of the Puppet
    4 language. The next section explores it in greater detail.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 上述清单使用了 `each` 函数，这是 Puppet 4 语言的另一个部分。下一节将更详细地探讨它。
- en: Learning lambdas and functions
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习 lambda 表达式和函数
- en: Functions have long been an essential part of Puppet. Due to the new type system,
    a complete new set of functions have become possible functions with different
    behavior based on parameter data types.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 函数长期以来一直是 Puppet 的一个重要组成部分。由于新的类型系统，基于参数数据类型的不同行为，现已可以实现全新的函数集。
- en: 'To understand functions, we first have to take a look at lambdas, which are
    introduced in Puppet 4\. Lambdas represent a snippet of Puppet code, which can
    be used in functions. Syntactically, lambdas consist of an optional type and at
    least one variable with optional defaults set, enclosed in pipe signs (`|`), followed
    by Puppet code inside a block of curly braces:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解函数，首先我们必须了解 Lambdas，它们是在 Puppet 4 中引入的。Lambdas 代表一段 Puppet 代码片段，可以在函数中使用。从语法上讲，Lambdas
    由一个可选类型和至少一个变量组成，可选的默认值，变量被管道符号（`|`）括起来，后跟一段大括号内的 Puppet 代码：
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Lambdas are typically used on functions. The preceding example uses the `each`
    function on the `$packages` variable, iterating over its contents, setting the
    lambda variable `$package` within each iteration to the values `htop`, `less`,
    and `vim`, respectively. The Puppet code block uses the lambda variable inside
    a resource type declaration afterwards.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 通常用于函数。前面的示例在 `$packages` 变量上使用了 `each` 函数，遍历其内容，在每次迭代中，将 lambda 变量 `$package`
    设置为 `htop`、`less` 和 `vim`，分别对应。Puppet 代码块随后在资源类型声明中使用 lambda 变量。
- en: The Puppet code in curly braces has to ensure that no duplicate resource declaration
    occurs.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 括号中的 Puppet 代码必须确保不会发生重复的资源声明。
- en: Since Puppet now knows about data types, you can interact and work with variables,
    and the data inside, in a far more elegant way.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Puppet 现在了解数据类型，你可以以更优雅的方式与变量及其内部数据进行交互和操作。
- en: 'in functions for arrays and hashes:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 用于数组和哈希的函数：
- en: 'Puppet 4 comes with a whole set of built-in functions for arrays and hashes:
    each'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet 4 提供了一整套内建的数组和哈希函数：each
- en: slice
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: slice
- en: filter
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: filter
- en: map
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: map
- en: reduce
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: reduce
- en: with
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与
- en: 'We have already seen the `each` function in action. Prior to Puppet 4, one
    needed to wrap the desired Puppet resource types into `define` and declare the
    `define` type using an array:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 `each` 函数的实际应用。在 Puppet 4 之前，必须将所需的 Puppet 资源类型包装在 `define` 中，并使用数组声明
    `define` 类型：
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'With this concept, the action (create the `symlink`) was put into a define
    type and was no longer directly visible in the manifest. The new iteration approach
    keeps the action in the same location:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个概念，动作（创建 `symlink`）被放入一个定义类型中，不再直接出现在清单中。新的迭代方法保持了动作的位置：
- en: '[PRE38]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Did you recognize that, this time, we used another approach of using a function?
    In the first example, we used the Puppet 3 style function calls:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到，这次我们使用了另一种通过函数的方式？在第一个示例中，我们使用了 Puppet 3 风格的函数调用：
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Puppet 4 also supports the postfix notation, where the function is appended
    to its parameter using a dot:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 4 还支持后缀表示法，其中函数通过点（`.`）附加到其参数上：
- en: '[PRE40]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Puppet 4 supports both ways of using a function. This allows you to keep adhering
    to your code style and make use of the new functionality.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 4 支持使用函数的两种方式。这使你可以继续遵循自己的编码风格，并利用新功能。
- en: 'Let''s run though the other functions for arrays and hashes:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下其他用于数组和哈希的函数：
- en: 'The `slice` function allows you to split up and group an array or a hash. It
    needs an additional parameter (integer), defining how many objects should be grouped
    together:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slice` 函数允许你拆分和分组一个数组或哈希。它需要一个额外的参数（整数），用于定义要分组的对象数量：'
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This code will produce the following output:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码将产生以下输出：
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: When using the slice functions on a hash, one receives the keys
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对哈希使用 slice 函数时，会得到键
- en: (according to the amount of grouped keys) and accordingly,
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （根据分组的键数量）并相应地，
- en: 'the sub hash:'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 子哈希：
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This will return the following output:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将返回以下输出：
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `filter` function can be used to filter out specific entries inside an array
    or hash.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter` 函数可以用来过滤数组或哈希中的特定条目。'
- en: 'When used on an array, all elements are passed to the code block and the code
    block evaluates whether the entry does match. This is very useful if you want
    to filter out items of an array (for example, packages which should be installed):'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对数组使用时，所有元素都会传递到代码块中，代码块会判断该项是否匹配。如果你想筛选出数组中的某些项（例如，应该安装的包），这非常有用：
- en: '[PRE45]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This will return the following output:'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将返回以下输出：
- en: '[PRE46]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The behavior on hashes is different. When using hashes, one has to provide
    two lambda variables: `key` and `value`. You might want to only add users that
    have a specific `gid` set:'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希的行为有所不同。在使用哈希时，必须提供两个lambda变量：`key`和`value`。你可能只想添加具有特定`gid`设置的用户：
- en: '[PRE47]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This will return only the users from the `admin` gid:'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将只返回`admin` gid下的用户：
- en: '[PRE48]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Creating Puppet 4 functions
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Puppet 4函数
- en: The Puppet 3 functions API has some limitations and is missing features. The
    new function API in Puppet 4 improves upon that substantially.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 3函数API存在一些限制，并且缺少一些功能。Puppet 4中的新函数API在这一点上有了显著改进。
- en: 'Some of the limitations of the old functions are as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版函数的部分限制如下：
- en: The functions had no automatic type checking
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些函数没有自动类型检查。
- en: These functions had to have a unique name due to a flat namespace
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于平坦的命名空间，这些函数必须具有唯一的名称。
- en: These functions were not private and, hence, could be used anywhere
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些函数不是私有的，因此可以在任何地方使用。
- en: The documentation could not be retrieved without running the Ruby code
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不运行Ruby代码，无法获取文档。
- en: Running on Puppet 3 requires functions to be in a module in the `lib/puppet/parser/functions`
    directory. Therefore, people referred to these functions as **parser functions**,
    but this name is misleading. Functions are unrelated to the Puppet parser.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在Puppet 3中，函数必须位于`lib/puppet/parser/functions`目录中的模块中。因此，人们称这些函数为**解析器函数**，但这个名称是误导性的。函数与Puppet解析器无关。
- en: In Puppet 4, functions have to be put into a module in path `lib/puppet/functions`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在Puppet 4中，函数必须放在路径`lib/puppet/functions`中的模块中。
- en: 'This is how you create a function that will return the hostname of the Puppet
    master:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建一个返回Puppet主机名的函数的方式：
- en: '[PRE49]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Using `dispatch` adds type checking for attributes. Depending on desired functionality,
    one might have multiple `dispatch` blocks (checking for different data types).
    Each `dispatch` can refer to another defined Ruby method inside the function.
    This reference is possible by using the same names for `dispatch` and the Ruby
    method.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dispatch`可以对属性进行类型检查。根据所需的功能，可能会有多个`dispatch`块（检查不同的数据类型）。每个`dispatch`可以引用函数内部的另一个已定义的Ruby方法。通过为`dispatch`和Ruby方法使用相同的名称，可以实现这种引用。
- en: 'The following example code should get additional functionality; depending on
    the type of argument, the function should either return the hostname of the local
    system, or use DNS to get the hostname from an IPv4 address or the `ipaddress`
    for a given hostname:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码应增加附加功能；根据参数类型，函数应该返回本地系统的主机名，或使用DNS根据IPv4地址或给定主机名的`ipaddress`获取主机名：
- en: '[PRE50]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: At the beginning of the file, we have to load some Ruby modules to allow the
    DNS name resolution and to find the local hostname.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件的开头，我们需要加载一些Ruby模块，以允许DNS名称解析并找到本地主机名。
- en: The first two `dispatch` sections check for the data type of the parameter value
    and set a unique symbol. The last `dispatch` section does not check for data types,
    which matches when no parameter was given.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个`dispatch`部分检查参数值的数据类型并设置唯一的符号。最后一个`dispatch`部分不检查数据类型，这与没有提供参数时相符。
- en: Each defined Ruby method uses the name of the according `dispatch` and executes
    Ruby code depending on the parameter type.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 每个已定义的Ruby方法使用相应的`dispatch`名称，并根据参数类型执行Ruby代码。
- en: 'Now, the resolver function can be used from inside the Puppet manifest code
    in three different ways:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，解析器函数可以通过三种不同的方式在Puppet清单代码中使用：
- en: '[PRE51]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'When declaring this class, the following output will show up:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 声明此类时，以下输出将会显示：
- en: '[PRE52]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: With Puppet 3 functions, it was impossible to have two functions of the same
    name. One always had to check whether duplicate functions appeared when making
    use of a new module.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在Puppet 3的函数中，无法有两个相同名称的函数。在使用新模块时，必须检查是否出现了重复的函数。
- en: The Puppet 4 functions now offer the possibility of using namespacing just the
    same as classes.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 4函数现在提供了与类相同的命名空间功能。
- en: 'Let''s migrate our function into the class namespace:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将函数迁移到类命名空间中：
- en: '[PRE53]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the example, the code needs to be in `resolver/lib/puppet/functions/resolver/resolve.rb`,
    which corresponds to `function name: ''resolver::resolve''`.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '在示例中，代码需要位于`resolver/lib/puppet/functions/resolver/resolve.rb`，对应于`function
    name: ''resolver::resolve''`。'
- en: 'Functions with namespaces are invoked as usual:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 带命名空间的函数按常规方式调用：
- en: '[PRE54]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Leveraging the new template engine
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用新的模板引擎
- en: 'In [Chapter 6](60cec52e-6b29-4028-bc15-3b5685598e6b.xhtml), *The Puppet Beginners
    Advanced Parts*, we introduced templates and the ERB template engine. In Puppet
    4, an alternative was added: the EPP template engine. The major differences between
    the template engines are as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第六章](60cec52e-6b29-4028-bc15-3b5685598e6b.xhtml)，*《Puppet 初学者进阶部分》*中，我们介绍了模板和
    ERB 模板引擎。在 Puppet 4 中，增加了一个替代方案：EPP 模板引擎。模板引擎之间的主要区别如下：
- en: In ERB templates, you cannot specify a variable in Puppet syntax (`$variable_name`)
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 ERB 模板中，不能使用 Puppet 语法指定变量（`$variable_name`）
- en: ERB templates will not accept parameters
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ERB 模板不接受参数
- en: In EPP templates, you will use the Puppet DSL syntax instead of Ruby syntax
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 EPP 模板中，你将使用 Puppet DSL 语法，而不是 Ruby 语法
- en: 'The EPP template engine requires scoped variables from modules:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: EPP 模板引擎需要模块中的作用域变量：
- en: '[PRE55]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The manifest defines the following local variable: `<%= $motd::local_variable
    %>`. The EPP templates also have a unique extension: they can take typed parameters.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 清单定义了以下局部变量：`<%= $motd::local_variable %>`。EPP 模板还具有一个独特的扩展：它们可以接受类型化参数。
- en: 'To make use of this, a template has to start with a parameter declaration block:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用此功能，模板必须以参数声明块开始：
- en: '[PRE56]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'These parameters are not as variables from Puppet manifests. Instead, one must
    pass parameters using the `epp` function:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数与 Puppet 清单中的变量不同。相反，必须使用 `epp` 函数传递参数：
- en: '[PRE57]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: A template without parameters should only be used when the template is used
    exclusively by one module, so that it is safe to rely on the availability of Puppet
    variables to customize the content.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 没有参数的模板应该仅在模板仅由一个模块使用时使用，这样可以安全地依赖 Puppet 变量来定制内容。
- en: Using the EPP template function with parameters is recommended when a template
    is used from several places. By declaring the parameters at the beginning, it
    is especially clear what data the template requires.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当模板从多个地方使用时，推荐使用带参数的 EPP 模板函数。通过在开始时声明参数，特别清楚模板需要哪些数据。
- en: 'There is a specific difference between the template engines when iterating
    over arrays and hashes. The ERB syntax uses Ruby code with unscoped, local variables,
    whereas the EPP syntax requires specifying Puppet DSL code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在遍历数组和哈希时，模板引擎之间有一个具体的区别。ERB 语法使用 Ruby 代码和不受限的局部变量，而 EPP 语法则需要指定 Puppet DSL
    代码：
- en: '[PRE58]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The inline ERB function was also supplemented with inline EPP. Using the inline
    EPP, one can specify a small snippet of EPP code to get evaluated:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 内联 ERB 函数也通过内联 EPP 进行了补充。使用内联 EPP，可以指定一小段 EPP 代码进行求值：
- en: '[PRE59]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Prior to Puppet 4, it was inconvenient to pass more than a small code snippet.
    With Puppet 4 and the HEREDOC support, complex templates in combination with `inline_epp`
    are easier and better readable.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puppet 4 之前，传递多于一个小代码片段比较不方便。随着 Puppet 4 和 HEREDOC 支持的发布，结合 `inline_epp`，复杂模板变得更加容易且可读性更好。
- en: Handling multiline with HEREDOC
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 HEREDOC 处理多行
- en: 'Writing multiline file fragments in Puppet mostly resulted in code that was
    hard to read, mostly due to indentation. With Puppet 4, the `heredoc` style was
    added. It is now possible to specify a `heredoc` tag and marker:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puppet 中编写多行文件片段大多导致代码难以阅读，主要是因为缩进问题。随着 Puppet 4 的发布，增加了 `heredoc` 风格。现在可以指定一个
    `heredoc` 标签和标记：
- en: '[PRE60]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `heredoc` tag starts with an `@` sign followed by arbitrary string enclosed
    in parenthesis. The `heredoc` marker is the string given in the tag.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`heredoc` 标签以 `@` 符号开始，后跟括号中包含的任意字符串。`heredoc` 标记即为标签中给定的字符串。'
- en: 'If variables are required inside the `heredoc` document, the variable interpolation
    can be enabled by putting the tag string in double quotes. Variables inside the
    `heredoc` are written the same as Puppet DSL variables: a dollar sign followed
    by the scope and the variable name:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 `heredoc` 文档中需要变量，可以通过将标签字符串放入双引号来启用变量插值。`heredoc` 中的变量与 Puppet DSL 变量书写方式相同：一个美元符号，后跟作用域和变量名：
- en: '[PRE61]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Normally, `heredoc` does not handle escape sequences. Escape sequences need
    to be enabled explicitly. As of Puppet 4.2, `heredoc` has the following escape
    sequences available:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`heredoc` 不处理转义序列。转义序列需要显式启用。从 Puppet 4.2 开始，`heredoc` 提供了以下转义序列：
- en: '`*` `\n` Newline'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*` `\n` 换行符'
- en: '`*` `\r` Carriage return'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*` `\r` 回车符'
- en: '`*` `\t` Tab'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*` `\t` 制表符'
- en: '`*` `\s` Space'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*` `\s` 空格'
- en: '`*` `\$` Literal dollar sign (preventing interpolation)'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*` `\$` 字面量美元符号（防止插值）'
- en: '`*` `\u` Unicode character'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*` `\u` Unicode 字符'
- en: '`\L` Nothing (ignore line breaks in source code)'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\L` 什么都不做（忽略源代码中的换行符）'
- en: 'Enabled escape sequences have to be placed behind the string of the `heredoc`
    tag:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 启用的转义序列必须放在`heredoc`标签字符串的后面：
- en: '[PRE62]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In the example, the text always starts in the first column, which makes it hard
    to read and stands out from the code around it, which will usually be indented
    by some amount of whitespace.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，文本总是从第一列开始，这使得它很难阅读，并且与周围的代码（通常会有一些空白缩进）显得格格不入。
- en: 'It is possible to strip indentation by placing whitespaces and a pipe sign
    in front of the `heredoc` marker. The pipe sign will indicate the first character
    of each line:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在`heredoc`标记前放置空格和管道符号来去除缩进。管道符号将指示每行的第一个字符：
- en: '[PRE63]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now `heredoc` and `inline_epp` can be easily combined:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以轻松地将`heredoc`和`inline_epp`结合使用：
- en: '[PRE64]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Declaring this class will give the following result in the `motd` file:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 声明此类会在`motd`文件中生成以下结果：
- en: '[PRE65]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: When using `heredoc` in combination with `inline_epp`, you want to take care
    to not quote the `heredoc` start tag. Otherwise, the variable substitution will
    take place prior to the `inline_epp` function call.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`heredoc`和`inline_epp`组合时，你需要小心不要引用`heredoc`起始标签。否则，变量替换会发生在`inline_epp`函数调用之前。
- en: Using Puppet 5 server metrics
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Puppet 5服务器度量
- en: With Puppetserver Version 5 the former Puppet Enterprise only metrics system
    has been ported to Puppet Open Source.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在Puppetserver 5版本中，之前Puppet Enterprise的度量系统已被移植到Puppet Open Source中。
- en: The metrics system allows you to read internal information like compile times,
    status of file serving and function runtimes from a JMX console or to push the
    data to a graphite system.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 度量系统允许你从JMX控制台读取内部信息，如编译时间、文件服务状态和函数运行时，或者将数据推送到graphite系统。
- en: Enabling the metrics system is straightforward by editing the puppet server
    `metrics.conf` file located at `/etc/puppetlabs/puppetserver/conf.d/metrics.conf`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 启用度量系统非常简单，只需编辑位于`/etc/puppetlabs/puppetserver/conf.d/metrics.conf`的puppet服务器`metrics.conf`文件。
- en: 'There are three important settings. At the `metrics.server-id` one can specify
    an ID which is later used in the Grafana dashboard. The `metrics.registry.puppetserver.reporters.graphite.enabled`
    value must be set to true and the `metrics.reporters.graphite` hash must mention
    the graphite hostname and port and the update interval setting:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个重要的设置。在`metrics.server-id`中，可以指定一个ID，该ID稍后会在Grafana仪表板中使用。`metrics.registry.puppetserver.reporters.graphite.enabled`值必须设置为true，同时`metrics.reporters.graphite`哈希值必须包含graphite的主机名和端口，以及更新间隔设置：
- en: '[PRE66]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Don't forget to restart the `puppetserver` process after doing changes.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在做完更改后，别忘了重新启动`puppetserver`进程。
- en: 'For automated setup one wants to use the `puppetlabs-hocon` module which is
    able to set all desired values:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 对于自动化设置，应该使用`puppetlabs-hocon`模块，它能够设置所有所需的值：
- en: '[PRE67]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The setup of praphite is beyond the scope of this book. There is a puppet module
    available for evaluation purpose ([http://github.com/tuxmea/puppet-grafanadash](http://github.com/tuxmea/puppet-grafanadash)).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不涉及graphite的设置。可以使用一个Puppet模块进行评估目的（[http://github.com/tuxmea/puppet-grafanadash](http://github.com/tuxmea/puppet-grafanadash)）。
- en: This module installs and configures elasticsearch, graphite, and grafana on
    a CentOS 7 system.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块会在CentOS 7系统上安装并配置elasticsearch、graphite和grafana。
- en: 'You only need to include the `grfanadash::dev` class on a node:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要在节点上包含`grfanadash::dev`类：
- en: '[PRE68]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Afterwards you can access graphite on `http://graphite.example.com` and grafana
    at `http://graphite.example-com:10000`. Within the grafana dashboard one can load
    the `.json` file from module examples folder.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你可以通过`http://graphite.example.com`访问graphite，通过`http://graphite.example-com:10000`访问grafana。在grafana仪表板中，可以从模块示例文件夹加载`.json`文件。
- en: Please be aware that it might take up to 10 minutes prior values will show up
    in grafana.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，可能需要最多10分钟，之前的值才能出现在grafana中。
- en: Breaking old practices
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打破旧有的做法
- en: When Puppet Labs decided to work on the parser and on the new features, they
    also decided to remove some features that had already been deprecated for a couple
    of releases.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当Puppet Labs决定对解析器和新特性进行改进时，他们也决定移除一些已经在多个版本中弃用的功能。
- en: Converting node inheritance
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换节点继承
- en: 'Node inheritance has been considered good practice during older Puppet releases.
    To avoid too much code on the node level, a generic, nonexistent host was created
    (`basenode`) and the real nodes inherited from `basenode`:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧版本的Puppet中，节点继承被视为一种良好的实践。为了避免在节点级别上写太多代码，创建了一个通用的、虚拟的主机（`basenode`），而真实的节点继承自`basenode`：
- en: '[PRE69]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This node classification is no longer supported by Puppet 4.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 4不再支持此节点分类。
- en: 'As of 2012, the roles and profiles pattern became increasingly popular, bringing
    new methods on how to allow smart node classification. From a technical point
    of view, roles and profiles are Puppet classes. The profile module wraps technical
    modules and adapts their usage to the existing infrastructure by providing data
    such as `ntp` servers and `ssh` configuration options. The role module describes
    system business use cases and makes use of the declared profiles:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 从 2012 年开始，角色和配置模式变得越来越流行，带来了新的方法来实现智能节点分类。从技术角度看，角色和配置是 Puppet 类。配置模块封装了技术模块，并通过提供如
    `ntp` 服务器和 `ssh` 配置选项等数据，来将它们的使用适应现有的基础设施。角色模块描述了系统的业务用例，并使用已声明的配置：
- en: '[PRE70]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The final chapter will describe the roles and profiles pattern in some more
    detail.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一章将更详细地描述角色和配置模式。
- en: Dealing with bool algebra on Strings
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理字符串上的布尔代数
- en: 'A minor change with a huge impact is the change of empty string comparison.
    Prior to Puppet 4, one could test for either an unset variable or a variable containing
    an empty string by checking for the variable:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 一个影响巨大的小变动是空字符串比较的变化。在 Puppet 4 之前，可以通过检查变量来测试未设置的变量或包含空字符串的变量：
- en: '[PRE71]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The `ssh` class behaved similarly ($server evaluates to true) when used within
    the following different declarations:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下不同的声明中，`ssh` 类的行为类似（$server 评估为 true）：
- en: '[PRE72]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Disabling the server section in the `ssh` class could be achieved by the following
    class declarations:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用 `ssh` 类中的服务器部分可以通过以下类声明实现：
- en: '[PRE73]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The behavior of the last example (empty string) changed in Puppet 4\. The empty
    string now equals a true value in Boolean context, just as in Ruby. If your code
    makes use of this way of variable checking, you need to add the check for empty
    string to retain the same behavior with Puppet 4:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个示例（空字符串）的行为在 Puppet 4 中发生了变化。空字符串现在在布尔上下文中等于 true，就像在 Ruby 中一样。如果你的代码使用了这种变量检查方式，你需要添加空字符串检查，以保持与
    Puppet 4 一致的行为：
- en: '[PRE74]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Using strict variable naming
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用严格的变量命名
- en: 'Variables sometimes look the same as constants and exhibit the following features:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 变量有时看起来与常量相同，并展示以下特性：
- en: Variables cannot be declared again
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量不能再次声明
- en: In the scope of one node, most variables are static (`hostname`, `fqdn`, and
    so on)
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个节点的作用域内，大多数变量是静态的（`hostname`、`fqdn` 等等）
- en: Sometimes, developers prefer to write the variables in capital letters due to
    the previously mentioned items, to make them look the same as Ruby constants.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，开发者更喜欢使用大写字母书写变量，这是出于之前提到的原因，使它们看起来与 Ruby 常量相同。
- en: 'With Puppet 4, variable names must not start with a capital letter:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puppet 4 中，变量名不能以大写字母开头：
- en: '[PRE75]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Declaring this class will now produce the following error message:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 声明此类将产生以下错误信息：
- en: '[PRE76]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Learning the new reference syntax
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习新的引用语法
- en: 'Due to the type system and due to the reason that Puppet 4 now takes everything
    as an expression, one has to name references on other declared resources properly.
    References now have some strict regulations:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类型系统以及 Puppet 4 现在将一切视为表达式，因此必须正确命名对其他声明资源的引用。引用现在有一些严格的规定：
- en: No whitespace between reference type and opening bracket
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用类型和开括号之间不能有空格
- en: The reference title (used without quotes) must not be spelled with a capital
    letter
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用标题（不带引号使用）不得以大写字母拼写
- en: 'The following will produce errors on Puppet 4:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容将在 Puppet 4 中产生错误：
- en: '[PRE77]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Starting with Puppet 4, references have to be written in the following pattern:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Puppet 4 开始，引用必须按照以下模式编写：
- en: '[PRE78]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Our example needs to be changed to:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例需要更改为：
- en: '[PRE79]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Cleaning hyphens in names
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理名称中的连字符
- en: Many modules (even on the module Forge) have used the hyphen in the
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 许多模块（即使是在模块 Forge 上）都使用了连字符
- en: 'module name. The hyphen is now no longer a string character, but a mathematical
    operator (subtraction). In consequence, hyphens are now strictly forbidden in
    the following descriptors:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 模块名称。连字符现在不再是字符串字符，而是数学运算符（减法）。因此，现在严格禁止在以下描述符中使用连字符：
- en: The module name
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块名称
- en: Any class name
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何类名
- en: Names of defined types
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已定义类型的名称
- en: When using modules with hyphens, the hyphen needs to be removed or replaced
    with a string character (for example, the underscore).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有连字符的模块时，需要删除连字符或将其替换为字符串字符（例如下划线）。
- en: 'This is possible with older versions, as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这在旧版本中是可行的，如下所示：
- en: '[PRE80]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, the new style is as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，新风格如下：
- en: '[PRE81]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: No Ruby DSL anymore
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不再使用 Ruby DSL
- en: Some people used the possibility to put `.rb` files as manifests inside modules.
    These `.rb` files contained Ruby code and were mostly needed for working with
    data. Puppet 4 now has data types that make this obsolete.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 一些人利用了将 `.rb` 文件作为模块中的清单文件的可能性。这些 `.rb` 文件包含 Ruby 代码，主要用于处理数据。Puppet 4 现在有了数据类型，使得这一做法变得过时。
- en: The support for these Ruby manifests has been removed in Puppet 4.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 4 移除了对这些 Ruby 清单的支持。
- en: Relative class name resolution
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相对类名解析
- en: 'With Puppet 3 and older, it was required to specify absolute class names in
    case that a local class name was identical to another module:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puppet 3 及更早版本中，如果本地类名与另一个模块相同，必须指定绝对类名：
- en: '[PRE82]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Within the scope of the `application::` namespace, Puppet 3 would search this
    namespace for a `mysql` class to be included. Effectively, the `application::mysql`
    class would include itself. However, this was not what we intended to do. We were
    looking for the `mysql` module instead. As a workaround, everybody was encouraged
    to specify the absolute path to the `mysql` module class:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `application::` 命名空间的范围内，Puppet 3 会在该命名空间中搜索 `mysql` 类进行包含。实际上，`application::mysql`
    类会将自身包含进去。然而，这并不是我们想要的效果。我们其实是想找 `mysql` 模块。作为变通方法，大家都被鼓励指定 `mysql` 模块类的绝对路径：
- en: '[PRE83]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This relative name resolution no longer applies in Puppet 4\. The original example
    works now.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这种相对名称解析在 Puppet 4 中不再适用。原始示例现在可以正常工作。
- en: Dealing with different data types
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理不同数据类型
- en: Because Puppet 3 was not aware of the different data types
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Puppet 3 并不知道不同的数据类型
- en: (mostly everything was dealt with as being of type string), it was possible
    to combine several different data types.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: （大多数情况下，一切都被视为字符串类型），所以可以将多个不同的数据类型组合在一起。
- en: Puppet 4 is now very strict when it comes to combining different data types.
    The easiest example is dealing with float and integer; when adding a float and
    an integer, the result will be of type float.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 4 现在对组合不同数据类型非常严格。最简单的例子是处理浮动类型和整数类型；当将浮动数与整数相加时，结果将是浮动数类型。
- en: 'Combining actions on different data types, such as string and bool, will now
    result in an error. The following code will work:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 对不同数据类型（如字符串和布尔值）进行操作将导致错误。以下代码将正常工作：
- en: '[PRE84]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'On the other hand, the following code will not work:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，以下代码将无法工作：
- en: '[PRE85]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'You will receive the following error message:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 您将收到以下错误消息：
- en: '[PRE86]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Review the comparison of different Facter variables carefully. Some Facter variables,
    such as `operatingsystemmajrelease`, return data of the type string; whereas `processorcount`
    returns an integer value.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细检查不同 Facter 变量的比较。某些 Facter 变量，如 `operatingsystemmajrelease`，返回字符串类型的数据；而
    `processorcount` 返回整数值。
- en: Summary
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Upgrading to Puppet 3 should be done in a step-by-step procedure where your
    existing code will be evaluated using Puppet 3.8 and the new parser.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 升级到 Puppet 3 应按逐步程序进行，在此过程中，您的现有代码将使用 Puppet 3.8 和新的解析器进行评估。
- en: Thanks to the type system, it is now possible to deal with data in a far more
    elegant way directly in your Puppet DSL code. The new functions API allows you
    to immediately recognize to which module a function belongs by using namespaces.
    Similar functions can now be combined within a single file by making use of the
    `dispatch` method and data types, allowing a form of function overloading.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了类型系统，现在可以在 Puppet DSL 代码中以更加优雅的方式处理数据。新的函数 API 允许您通过使用命名空间，立即识别一个函数属于哪个模块。通过使用
    `dispatch` 方法和数据类型，类似的函数现在可以在一个文件内结合使用，从而实现函数重载。
- en: The new EPP templates offer better understanding of variable sources by using
    the Puppet syntax for variable references. Passing parameters to templates will
    allow you to make use of modules in a more flexible way.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 EPP 模板通过使用 Puppet 语法进行变量引用，提供了更好的变量来源理解。将参数传递给模板将允许您以更灵活的方式使用模块。
- en: Combining EPP templates and the HEREDOC syntax will allow you to keep template
    code and data directly visible inside your classes.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 结合 EPP 模板和 HEREDOC 语法，将允许您将模板代码和数据直接显示在类内。
- en: In the upcoming chapter, you will learn about Hiera and how it can help you
    bring order to a scalable Puppet code base.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，您将了解 Hiera 以及它如何帮助您为可扩展的 Puppet 代码库带来秩序。
