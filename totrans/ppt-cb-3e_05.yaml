- en: Chapter 5. Users and Virtual Resources
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章 用户与虚拟资源
- en: '*"Nothing is a problem, until it''s a problem."*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“没有问题，直到它成为问题。”*'
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将介绍以下配方：
- en: Using virtual resources
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用虚拟资源
- en: Managing users with virtual resources
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用虚拟资源管理用户
- en: Managing users' SSH access
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理用户的SSH访问
- en: Managing users' customization files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理用户的自定义文件
- en: Using exported resources
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用导出的资源
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: Users can be a real pain. I don't mean the people, though doubtless that's sometimes
    true. But keeping UNIX user accounts and file permissions in sync across a network
    of machines, some of them running different operating systems, can be very challenging
    without some kind of centralized configuration management.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可能会非常麻烦。我不是说那些人，尽管这有时确实是事实。但如果没有某种集中的配置管理，保持UNIX用户账户和文件权限在一网络中同步，尤其是当网络中有些机器运行不同操作系统时，会非常具有挑战性。
- en: Each new developer who joins the organization needs an account on every machine,
    along with `sudo` privileges and group memberships, and needs their SSH key authorized
    for a bunch of different accounts. The system administrator who has to take care
    of this manually will be at the job all day, while the system administrator who
    uses Puppet will be done in minutes, and head out for an early lunch.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新加入组织的开发者都需要在每台机器上拥有一个账户，且需要`sudo`权限和组成员资格，并且需要将他们的SSH密钥授权给多个不同的账户。需要手动处理这些事务的系统管理员将整天忙碌，而使用Puppet的系统管理员只需几分钟就能完成工作，并去享受早午餐。
- en: In this chapter, we'll look at some handy patterns and techniques to manage
    users and their associated resources. Users are also one of the most common applications
    for virtual resources, so we'll find out all about those. In the final section,
    we'll introduce exported resources, which are related to virtual resources.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍一些管理用户及其相关资源的实用模式和技巧。用户也是虚拟资源的最常见应用之一，所以我们将详细探讨这些内容。在最后一节中，我们将介绍与虚拟资源相关的导出资源。
- en: Using virtual resources
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用虚拟资源
- en: Virtual resources in Puppet might seem complicated and confusing but, in fact,
    they're very simple. They're exactly like regular resources, but they don't actually
    take effect until they're realized (in the sense of "made real"); whereas a regular
    resource can only be declared once per node (so two classes can't declare the
    same resource, for example). A virtual resource can be realized as many times
    as you like.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet中的虚拟资源看起来可能复杂且令人困惑，但实际上它们非常简单。它们和普通资源完全一样，但在实现（"使其成为现实"的意义上）之前，它们并不会生效；而普通资源每个节点只能声明一次（例如，两个类不能声明相同的资源）。虚拟资源则可以被实现多次，任你所愿。
- en: This comes in handy when you need to move applications and services between
    machines. If two applications that use the same resource end up sharing a machine,
    they would cause a conflict unless you make the resource virtual.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要在机器之间迁移应用程序和服务时，这非常有用。如果两个使用相同资源的应用程序最终共享一台机器，除非你将该资源虚拟化，否则它们会导致冲突。
- en: To clarify this, let's look at a typical situation where virtual resources might
    come in handy.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地说明这一点，让我们来看一个典型的场景，在这个场景中，虚拟资源可能会派上用场。
- en: 'You are responsible for two popular web applications: WordPress and Drupal.
    Both are web apps running on Apache, so they both require the Apache package to
    be installed. The definition for WordPress might look something like the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你负责两个流行的Web应用程序：WordPress和Drupal。它们都是运行在Apache上的Web应用程序，因此都需要安装Apache软件包。WordPress的定义可能类似于以下内容：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The definition for Drupal might look like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal的定义可能如下所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'All is well until you need to consolidate both apps onto a single server:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一切顺利，直到你需要将两个应用程序整合到同一台服务器上：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now Puppet will complain because you tried to define two resources with the
    same name: `httpd`.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Puppet会抱怨，因为你试图定义两个同名的资源：`httpd`。
- en: '![Using virtual resources](img/B03643_05_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![使用虚拟资源](img/B03643_05_01.jpg)'
- en: You could remove the duplicate Apache package definition from one of the classes,
    but then nodes without the class including Apache would fail. You can get around
    this problem by putting the Apache package in its own class and then using `include
    apache` everywhere it's needed; Puppet doesn't mind you including the same class
    multiple times. In reality, putting Apache in its own class solves most problems
    but, in general, this method has the disadvantage that every potentially conflicting
    resource must have its own class.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从其中一个类中删除重复的 Apache 包定义，但没有包含 Apache 的节点将会失败。你可以通过将 Apache 包放入它自己的类中，并在需要的地方使用`include
    apache`来避免这个问题；Puppet 不介意你多次包含同一个类。实际上，将 Apache 放入它自己的类中解决了大多数问题，但总的来说，这种方法的缺点是每个可能冲突的资源都必须有自己的类。
- en: 'Virtual resources can be used to solve this problem. A virtual resource is
    just like a normal resource, except that it starts with an `@` character:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟资源可以用来解决这个问题。虚拟资源就像一个普通的资源，只是它以`@`字符开头：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can think of it as being like a placeholder resource; you want to define
    it but you aren't sure you are going to use it yet. Puppet will read and remember
    virtual resource definitions, but won't actually create the resource until you
    realize the resource.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将它视为一个占位符资源；你想定义它，但不确定是否会使用它。Puppet 会读取并记住虚拟资源的定义，但直到你调用`realize`，它才会真正创建该资源。
- en: 'To create the resource, use the `realize` function:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建资源，使用`realize`函数：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can call `realize` as many times as you want on the resource and it won't
    result in a conflict. So virtual resources are the way to go when several different
    classes all require the same resource, and they may need to coexist on the same
    node.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在资源上调用`realize`任意多次，它不会导致冲突。因此，当多个不同的类都需要相同的资源，并且它们可能需要在同一个节点上共存时，虚拟资源是一个不错的选择。
- en: How to do it...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Here''s how to build the example using virtual resources:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用虚拟资源构建示例的方法：
- en: 'Create the virtual module with the following contents:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含以下内容的虚拟模块：
- en: '[PRE5]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create the Drupal module with the following contents:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含以下内容的 Drupal 模块：
- en: '[PRE6]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create the WordPress module with the following contents:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含以下内容的 WordPress 模块：
- en: '[PRE7]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Modify your `site.pp` file as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改你的`site.pp`文件如下：
- en: '[PRE8]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run Puppet:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Puppet：
- en: '[PRE9]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'You define the package and service as virtual resources in one place: the `virtual`
    class. All nodes can include this class and you can put all your virtual services
    and packages in it. None of the packages will actually be installed on a node
    or services started until you call `realize`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你将包和服务定义为虚拟资源，放在一个地方：`virtual`类。所有节点都可以包含这个类，你可以将所有虚拟服务和包放在其中。在你调用`realize`之前，任何包都不会真正安装在节点上，服务也不会启动：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Every class that needs the Apache package can call `realize` on this virtual
    resource:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每个需要 Apache 包的类都可以在此虚拟资源上调用`realize`：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Puppet knows, because you made the resource virtual, that you intended to have
    multiple references to the same package, and didn't just accidentally create two
    resources with the same name. So it does the right thing.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 知道，因为你将资源设为虚拟，它知道你打算多次引用相同的包，而不是无意中创建两个同名的资源。因此，它会做出正确的处理。
- en: There's more...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'To realize virtual resources, you can also use the collection *spaceship* syntax:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现虚拟资源，你也可以使用集合*spaceship*语法：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The advantage of this syntax is that you''re not restricted to the resource
    name; you could also use a tag, for example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法的优势在于你不局限于资源名称；你也可以使用标签，例如：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Alternatively, you can just specify all instances of the resource type, by
    leaving the query section blank:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以通过将查询部分留空，直接指定资源类型的所有实例：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Managing users with virtual resources
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用虚拟资源管理用户
- en: 'Users are a great example of a resource that may need to be realized by multiple
    classes. Consider the following situation. To simplify administration of a large
    number of machines, you defined classes for two kinds of users: `developers` and
    `sysadmins`. All machines need to include `sysadmins`, but only some machines
    need `developers`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 用户是一个很好的例子，它可能需要被多个类实现。考虑以下情况。为了简化大量机器的管理，你为两类用户定义了类：`developers`（开发者）和`sysadmins`（系统管理员）。所有机器都需要包括`sysadmins`，但只有部分机器需要`developers`：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: However, some users may be members of both groups. If each group simply declares
    its members as regular `user` resources, this will lead to a conflict when a node
    includes both `developers` and `sysadmins`, as in the `webserver` example.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一些用户可能同时是多个组的成员。如果每个组只是将其成员声明为常规的`user`资源，这会在节点同时包含`developers`和`sysadmins`类时导致冲突，正如在`webserver`示例中所见。
- en: To avoid this conflict, a common pattern is to make all users virtual resources,
    defined in a single class `user::virtual` that every machine includes, and then
    realizing the users where they are needed. This way, there will be no conflict
    if a user is a member of multiple groups.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种冲突，一种常见的做法是将所有用户设为虚拟资源，并在一个单独的`user::virtual`类中定义，该类会被每台机器包含，然后根据需要在需要的地方实现这些用户。这样，如果一个用户是多个组的成员，就不会产生冲突。
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'Follow these steps to create a `user::virtual` class:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建`user::virtual`类：
- en: 'Create the file `modules/user/manifests/virtual.pp` with the following contents:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文件`modules/user/manifests/virtual.pp`，并包含以下内容：
- en: '[PRE16]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create the file `modules/user/manifests/developers.pp` with the following contents:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文件`modules/user/manifests/developers.pp`，并包含以下内容：
- en: '[PRE17]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create the file `modules/user/manifests/sysadmins.pp` with the following contents:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文件`modules/user/manifests/sysadmins.pp`，并包含以下内容：
- en: '[PRE18]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Modify your `nodes.pp` file as follows:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改你的`nodes.pp`文件如下：
- en: '[PRE19]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run Puppet:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Puppet：
- en: '[PRE20]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'When we include the `user::virtual` class, all the users are declared as virtual
    resources (because we included the `@` symbol):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们包含`user::virtual`类时，所有用户都会被声明为虚拟资源（因为我们包括了`@`符号）：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That is to say, the resources exist in Puppet's catalog; they can be referred
    to by and linked with other resources, and they are in every respect identical
    to regular resources, except that Puppet doesn't actually create the corresponding
    users on the machine.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，这些资源存在于Puppet的目录中；它们可以被其他资源引用和链接，并且在各方面与常规资源完全相同，只是Puppet并不会实际在机器上创建相应的用户。
- en: 'In order for that to happen, we need to call `realize` on the virtual resources.
    When we include the `user::sysadmins` class, we get the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这种情况发生，我们需要在虚拟资源上调用`realize`。当我们包含`user::sysadmins`类时，会得到以下代码：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Calling `realize` on a virtual resource tells Puppet, "I''d like to use that
    resource now". This is what it does, as we can see from the run output:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟资源上调用`realize`告诉Puppet，“我现在想使用这个资源”。正如我们从运行输出中看到的那样，这正是它所做的：
- en: '[PRE23]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: However, Theresa is in both the `developers` and `sysadmins` classes! Won't
    that mean we end up calling `realize` twice on the same resource?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Theresa同时属于`developers`和`sysadmins`两个类！这是不是意味着我们会在同一资源上调用`realize`两次？
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Yes, it does, and that's fine. You're explicitly allowed to realize resources
    multiple times, and there will be no conflict. So long as some class, somewhere,
    calls `realize` on Theresa's account, it will be created. Unrealized resources
    are simply discarded during catalog compilation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，确实如此，而且没问题。你被明确允许多次实现资源，而且不会产生冲突。只要某个类的某处调用了`realize`，Theresa的账户就会被创建。未实现的资源在目录编译时会被丢弃。
- en: There's more...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: When you use this pattern to manage your own users, every node should include
    the `user::virtual` class, as a part of your basic housekeeping configuration.
    This class will declare all users (as virtual) in your organization or site. This
    should also include any users who exist only to run applications or services (such
    as `Apache`, `www-data`, or `deploy`, for example). Then, you can realize them
    as needed on individual nodes or in specific classes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用这种模式来管理自己的用户时，每个节点都应该包含`user::virtual`类，作为你基本配置的一部分。这个类会声明你组织或站点中的所有用户（作为虚拟资源）。这也应该包括那些仅用于运行应用程序或服务的用户（例如`Apache`、`www-data`或`deploy`等）。然后，你可以根据需要在各个节点或特定类中实现这些用户。
- en: For production use, you'll probably also want to specify a UID and GID for each
    user or group, so that these numeric identifiers are synchronized across your
    network. You can do this using the `uid` and `gid` parameters for the `user` resource.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产环境使用，你可能还需要为每个用户或组指定UID和GID，以确保这些数字标识符在整个网络中同步。你可以通过`user`资源的`uid`和`gid`参数来实现这一点。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you don't specify a user's UID, for example, you'll just get whatever is
    the next ID number available on a given machine, so the same user on different
    machines will have a different UID. This can lead to permission problems when
    using shared storage, or moving files between machines.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有指定用户的 UID，例如，你将只获得给定机器上下一个可用的 ID 号码，因此同一个用户在不同机器上的 UID 会不同。这可能会导致在使用共享存储或在机器之间移动文件时出现权限问题。
- en: A common pattern when defining users as virtual resources is to assign tags
    to the users based on their assigned roles within your organization. You can then
    use the `collector` syntax instead of `realize` to collect users with specific
    tags applied.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在将用户定义为虚拟资源时，一种常见的做法是根据用户在组织中的角色为他们分配标签。然后，你可以使用 `collector` 语法代替 `realize`
    来收集具有特定标签的用户。
- en: 'For example, see the following code snippet:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，参见以下代码片段：
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the previous example, only users `thomas` and `theresa` would be included.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，只有用户 `thomas` 和 `theresa` 会被包括在内。
- en: See also
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Using virtual resources* recipe in this chapter
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *使用虚拟资源* 配方
- en: The *Managing users' customization files* recipe in this chapter
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *管理用户自定义文件* 配方
- en: Managing users' SSH access
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理用户的 SSH 访问
- en: A sensible approach to access control for servers is to use named user accounts
    with passphrase-protected SSH keys, rather than having users share an account
    with a widely known password. Puppet makes this easy to manage thanks to the built-in
    `ssh_authorized_key` type.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一种合理的服务器访问控制方法是使用带有密码保护的 SSH 密钥的命名用户帐户，而不是让用户共享一个具有广泛已知密码的帐户。Puppet 通过内置的 `ssh_authorized_key`
    类型，使得管理变得非常简单。
- en: To combine this with virtual users, as described in the previous section, you
    can create a `define`, which includes both the `user` and `ssh_authorized_key`
    resources. This will also come in handy when adding customization files and other
    resources to each user.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如上一节所述，为了将其与虚拟用户结合使用，你可以创建一个 `define`，该定义包含 `user` 和 `ssh_authorized_key` 资源。这在为每个用户添加自定义文件和其他资源时也会非常有用。
- en: How to do it...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to extend your virtual users'' class to include SSH access:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤扩展你的虚拟用户类以包含 SSH 访问：
- en: 'Create a new module `ssh_user` to contain our `ssh_user` definition. Create
    the `modules/ssh_user/manifests/init.pp` file as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的模块 `ssh_user` 来包含我们的 `ssh_user` 定义。创建 `modules/ssh_user/manifests/init.pp`
    文件如下：
- en: '[PRE26]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Modify your `modules/user/manifests/virtual.pp` file, comment out the previous
    definition for user `thomas`, and replace it with the following:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改你的 `modules/user/manifests/virtual.pp` 文件，注释掉之前为用户 `thomas` 定义的部分，并用以下内容替换：
- en: '[PRE27]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Modify your `modules/user/manifests/sysadmins.pp` file as follows:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改你的 `modules/user/manifests/sysadmins.pp` 文件如下：
- en: '[PRE28]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Modify your `site.pp` file as follows:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改你的 `site.pp` 文件如下：
- en: '[PRE29]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Run Puppet:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Puppet：
- en: '[PRE30]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'For each user in our `user::virtual` class, we need to create:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的 `user::virtual` 类中的每个用户，我们需要创建：
- en: The user account itself
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户帐户本身
- en: The user's home directory and `.ssh` directory
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户的主目录和 `.ssh` 目录
- en: The user's `.ssh/authorized_keys` file
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户的 `.ssh/authorized_keys` 文件
- en: 'We could declare separate resources to implement all of these for each user,
    but it''s much easier to create a definition instead, which wraps them into a
    single resource. By creating a new module for our definition, we can refer to
    `ssh_user` from anywhere (in any scope):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为每个用户声明单独的资源来实现所有这些功能，但更简单的做法是创建一个定义，将它们包装成一个单独的资源。通过为我们的定义创建一个新模块，我们可以在任何地方（任何作用域内）引用
    `ssh_user`：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After we create the user, we can then create the home directory; we need the
    user first so that when we assign ownership, we can use the username, `owner =>
    $name`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用户后，我们可以创建主目录；我们需要先有用户，这样在分配所有权时就可以使用用户名，`owner => $name`：
- en: '[PRE32]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Tip
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Puppet can create the users' home directory using the `managehome` attribute
    to the user resource. Relying on this mechanism is problematic in practice, as
    it does not account for users that were created outside of Puppet without home
    directories.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 可以通过向用户资源添加 `managehome` 属性来创建用户的主目录。依赖于此机制在实践中存在问题，因为它没有考虑到在 Puppet
    之外创建的没有主目录的用户。
- en: 'Next, we need to ensure that the `.ssh` directory exists within the home directory
    of the user. We require the home directory, `File["/home/${name}"]`, since that
    needs to exist before we create this subdirectory. This implies that the user
    already exists because the home directory required the user:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保在用户的主目录中存在`.ssh`目录。我们需要主目录，`File["/home/${name}"]`，因为在创建该子目录之前，这个主目录需要先存在。这意味着用户已经存在，因为主目录需要用户：
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, we create the `ssh_authorized_key` resource, again requiring the containing
    folder (`File["/home/${name}/.ssh"]`). We use the `$key` and `$keytype` variables
    to assign the key and type parameters to the `ssh_authorized_key` type as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了`ssh_authorized_key`资源，再次要求包含该文件夹（`File["/home/${name}/.ssh"]`）。我们使用`$key`和`$keytype`变量为`ssh_authorized_key`类型分配密钥和类型参数，如下所示：
- en: '[PRE34]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We passed the `$key` and `$keytype` variables when we defined the `ssh_user`
    resource for `thomas`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为`thomas`定义`ssh_user`资源时，我们传递了`$key`和`$keytype`变量：
- en: '[PRE35]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Tip
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The value for `key`, in the preceding code snippet, is the ssh key's public
    key value; it is usually stored in an `id_rsa.pub` file.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码片段中的`key`值是ssh密钥的公钥值；它通常存储在`id_rsa.pub`文件中。
- en: 'Now, with everything defined, we just need to call `realize` on `thomas` for
    all these resources to take effect:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一切都定义好了，我们只需要在`thomas`上调用`realize`，让所有这些资源生效：
- en: '[PRE36]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Notice that this time the virtual resource we''re realizing is not simply the
    `user` resource, as before, but the `ssh_user` defined type we created, which
    includes the user and the related resources needed to set up the SSH access:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这次我们实现的虚拟资源不仅仅是像之前那样的`user`资源，而是我们创建的`ssh_user`定义类型，它包括了用户和设置SSH访问所需的相关资源：
- en: '[PRE37]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There's more...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: Of course, you can add whatever resources you like to the `ssh_user` definition
    to have Puppet automatically create them for new users. We'll see an example of
    this in the next recipe, *Managing users' customization files*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以向`ssh_user`定义中添加任何资源，让Puppet为新用户自动创建这些资源。在下一个例子中，我们会看到如何做，*管理用户的自定义文件*。
- en: Managing users' customization files
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理用户的自定义文件
- en: Users tend to customize their shell environments, terminal colors, aliases,
    and so forth. This is usually achieved by a number of **dotfiles** in their home
    directory, for example, `.bash_profile` or `.vimrc`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 用户倾向于定制他们的shell环境、终端颜色、别名等。这通常通过在他们的主目录中放置多个**dotfiles**来实现，例如`.bash_profile`或`.vimrc`。
- en: You can use Puppet to synchronize and update each user's dotfiles across a number
    of machines by extending the virtual user setup we developed throughout this chapter.
    We'll start a new module, `admin_user` and use the file types, `recurse` attribute
    to copy files into each user's home directory.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过扩展我们在本章中开发的虚拟用户设置，使用Puppet来同步和更新每个用户的dotfiles到多台机器上。我们将启动一个新模块`admin_user`，并使用文件类型的`recurse`属性将文件复制到每个用户的主目录中。
- en: How to do it...
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here''s what you need to do:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的事情如下：
- en: 'Create the `admin_user` defined type (`define admin_user`) in the `modules/admin_user/manifests/init.pp`
    file as follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`modules/admin_user/manifests/init.pp`文件中创建`admin_user`定义类型（`define admin_user`），如下所示：
- en: '[PRE38]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Modify the file `modules/user/manifests/sysadmins.pp` as follows:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`modules/user/manifests/sysadmins.pp`文件，如下所示：
- en: '[PRE39]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Alter the definition of `thomas` in `modules/user/manifests/virtual.pp` as
    follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`modules/user/manifests/virtual.pp`中的`thomas`定义，如下所示：
- en: '[PRE40]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create a subdirectory in the `admin_user` module for the file of user `thomas`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`admin_user`模块中为用户`thomas`的文件创建一个子目录：
- en: '[PRE41]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create dotfiles for the user `thomas` in the directory you just created:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为用户`thomas`创建dotfiles，放在你刚刚创建的目录中：
- en: '[PRE42]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Make sure your `site.pp` file reads as follows:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的`site.pp`文件如下所示：
- en: '[PRE43]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Run Puppet:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Puppet：
- en: '[PRE44]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How it works...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We created a new `admin_user` definition, which defines the home directory
    recursively if `$dotfiles` is not `false` (the default value):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的`admin_user`定义，它会递归地定义主目录，如果`$dotfiles`值不是`false`（默认值）的话：
- en: '[PRE45]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We created a directory to hold the user''s dotfiles within the `admin_user`
    module; all the files within that directory will be copied into the user''s home
    directory, as shown in the puppet run output in the following command line:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`admin_user`模块中创建了一个目录来存放用户的dotfiles；该目录中的所有文件都会被复制到用户的主目录中，如下所示在Puppet运行输出中的命令行：
- en: '[PRE46]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Using the `recurse` option allows us to add as many dotfiles as we wish for
    each user without having to modify the definition of the user.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`recurse`选项允许我们为每个用户添加任意多的dotfiles，而不必修改用户的定义。
- en: There's more...
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: We could specify that the `source` attribute of the home directory is a directory
    where users can place their own dotfiles. This way, each user could modify their
    own dotfiles and have them transferred to all the nodes in the network without
    our involvement.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定主目录的`source`属性为用户可以放置自己点文件（dotfiles）的目录。这样，每个用户可以修改自己的点文件，并将其传输到网络中所有节点，而无需我们参与其中。
- en: See also
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Managing users with virtual resources* recipe in this chapter
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*管理虚拟资源的用户*配方
- en: Using exported resources
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用导出资源
- en: All our recipes up to this point have dealt with a single machine. It is possible
    with Puppet to have resources from one node affect another node. This interaction
    is managed with **exported resources**. Exported resources are just like any resource
    you might define for a node but instead of applying to the node on which they
    were created, they are exported for use by all nodes in the environment. Exported
    resources can be thought of as virtual resources that go one step further and
    exist beyond the node on which they were defined.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的所有配方都处理的是单台机器。使用 Puppet，可以使一个节点的资源影响另一个节点。此交互由**导出资源**进行管理。导出资源就像您为节点定义的任何资源，但它们不是应用于创建它们的节点，而是导出供环境中所有节点使用。导出资源可以被看作是虚拟资源，超越了节点所在的范畴，存在于节点之外。
- en: There are two actions with exported resources. When an exported resource is
    created, it is said to be defined. When all the exported resources are harvested,
    they are said to be collected. Defining exported resources is similar to virtual
    resources; the resource in question has two `@` symbols prepended. For example,
    to define a file resource as external, use `@@file`. Collecting resources is done
    with the space ship operator, `<<| |>>`; this is thought to look like a spaceship.
    To collect the exported file resource (`@@file`), you would use `File <<| |>>`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 导出资源有两个操作。当一个导出资源被创建时，它被称为已定义。当所有导出资源被收集时，它们被称为已收集。定义导出资源类似于虚拟资源；相关资源的前面会加上两个`@`符号。例如，要将文件资源定义为外部资源，使用`@@file`。收集资源是通过飞船操作符`<<|
    |>>`来完成的；这被认为看起来像一艘飞船。要收集导出的文件资源（`@@file`），可以使用`File <<| |>>`。
- en: There are many examples that use exported resources; the most common one involves
    SSH host keys. Using exported resources, it is possible to have every machine
    that is running Puppet share their SSH host keys with the other connected nodes.
    The idea here is that each machine exports its own host key and then collects
    all the keys from the other machines. In our example, we will create two classes;
    first, a class that exports the SSH host key from every node. We will include
    this class in our base class. The second class will be a collector class, which
    collects the SSH host keys. We will apply this class to our Jumpboxes or SSH login
    servers.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多使用导出资源的示例；最常见的一个是涉及 SSH 主机密钥。使用导出资源，可以让所有运行 Puppet 的机器与其他连接的节点共享其 SSH 主机密钥。这里的想法是，每台机器导出自己的主机密钥，然后收集其他机器的所有密钥。在我们的示例中，我们将创建两个类；首先是一个从每个节点导出
    SSH 主机密钥的类。我们将把这个类包含在我们的基类中。第二个类是一个收集类，它收集 SSH 主机密钥。我们将把这个类应用到我们的跳板机或 SSH 登录服务器上。
- en: Note
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Jumpboxes are machines that have special firewall rules to allow them to log
    in to different locations.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 跳板机（Jumpboxes）是具有特殊防火墙规则的机器，允许它们登录到不同的位置。
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To use exported resources, you will need to enable storeconfigs on your Puppet
    masters. It is possible to use exported resources with a masterless (decentralized)
    deployment; however, we will assume you are using a centralized model for this
    example. In [Chapter 2](ch02.html "Chapter 2. Puppet Infrastructure"), *Puppet
    Infrastructure*, we configured puppetdb using the puppetdb module from the forge.
    It is possible to use other backends if you desire; however, all of these except
    puppetdb are deprecated. More information is available at the following link:
    [http://projects.puppetlabs.com/projects/puppet/wiki/Using_Stored_Configuration](http://projects.puppetlabs.com/projects/puppet/wiki/Using_Stored_Configuration).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用导出资源，您需要在 Puppet 主节点上启用 storeconfigs。可以在无主（去中心化）部署中使用导出资源；然而，我们假设您在本示例中使用的是集中式模型。在[第2章](ch02.html
    "第2章 Puppet基础架构")，*Puppet基础架构*中，我们使用 forge 中的 puppetdb 模块配置了 puppetdb。如果需要，也可以使用其他后端；但这些除
    puppetdb 外都已被弃用。更多信息请访问以下链接：[http://projects.puppetlabs.com/projects/puppet/wiki/Using_Stored_Configuration](http://projects.puppetlabs.com/projects/puppet/wiki/Using_Stored_Configuration)。
- en: Ensure your Puppet masters are configured to use puppetdb as a storeconfigs
    container.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的 Puppet 主节点配置为使用 puppetdb 作为 storeconfigs 容器。
- en: How to do it...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We'll create an `ssh_host` class to export the `ssh` keys of a host and ensure
    that it is included in our base class.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个 `ssh_host` 类来导出主机的 `ssh` 密钥，并确保它包含在我们的基础类中。
- en: 'Create the first class, `base::ssh_host`, which we will include in our base
    class:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第一个类，`base::ssh_host`，我们将在我们的基础类中包含它：
- en: '[PRE47]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Remember to include this class from inside the base class definition:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记得从基础类定义内部包含这个类：
- en: '[PRE48]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Create a definition for `jumpbox`, either in a class or within the node definition
    for `jumpbox`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `jumpbox` 创建一个定义，可以在类中或 `jumpbox` 的节点定义中：
- en: '[PRE49]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now run Puppet on a few nodes to create the exported resources. In my case,
    I ran Puppet on my Puppet server and my second example node (`node2`). Finally,
    run Puppet on `jumpbox` to verify that the SSH host keys for our other nodes are
    collected:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在几个节点上运行 Puppet，以创建导出的资源。在我的例子中，我在 Puppet 服务器和我的第二个示例节点（`node2`）上运行了 Puppet。最后，在
    `jumpbox` 上运行 Puppet，验证其他节点的 SSH 主机密钥是否已收集：
- en: '[PRE50]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We created an `sshkey` resource for the node using the facter facts `fqdn`,
    `hostname`, `ipaddress`, and `sshdsakey`. We use the `fqdn` as the title for our
    exported resource because each exported resource must have a unique name. We can
    assume the `fqdn` of a node will be unique within our organization (although sometimes
    they may not be; Puppet can be good at finding out such things when you least
    expect it). We then go on to define aliases by which our node may be known. We
    use the hostname variable for one alias and the main IP address of the machine
    as the other. If you had other naming conventions for your nodes, you could include
    other aliases here. We assume that hosts are using DSA keys, so we use the `sshdsakey`
    variable in our definition. In a large installation, you would wrap this definition
    in tests to ensure the DSA keys existed. You would also use the RSA keys if they
    existed as well.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为节点创建了一个 `sshkey` 资源，使用了 facter 提供的 `fqdn`、`hostname`、`ipaddress` 和 `sshdsakey`
    事实。我们使用 `fqdn` 作为导出资源的标题，因为每个导出资源必须有唯一的名称。我们可以假设一个节点的 `fqdn` 在我们的组织中是唯一的（尽管有时它们可能不是；Puppet
    在最不经意时也能找到这种情况）。然后我们继续定义节点可能被识别的别名。我们使用主机名变量作为一个别名，机器的主 IP 地址作为另一个别名。如果您有其他节点命名约定，可以在这里添加其他别名。我们假设主机使用
    DSA 密钥，因此我们在定义中使用了 `sshdsakey` 变量。在大型安装中，您会将此定义包装在测试中，以确保 DSA 密钥存在。如果存在 RSA 密钥，您也可以使用它们。
- en: With the `sshkey` resource defined and exported, we then created a `jumpbox`
    node definition. In this definition, we used the spaceship syntax `Sshkey <<|
    |>>` to collect all defined exported `sshkey` resources.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 定义并导出 `sshkey` 资源后，我们接着创建了一个 `jumpbox` 节点定义。在这个定义中，我们使用了航天飞机语法 `Sshkey <<| |>>`
    来收集所有定义的导出 `sshkey` 资源。
- en: There's more...
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'When defining the exported resources, you can add tag attributes to the resource
    to create subsets of exported resources. For example, if you had a development
    and production area of your network, you could create different groups of `sshkey`
    resources for each area as shown in the following code snippet:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义导出资源时，您可以为资源添加标签属性，以创建导出资源的子集。例如，如果您的网络中有开发和生产区域，您可以为每个区域创建不同的 `sshkey` 资源组，如以下代码片段所示：
- en: '[PRE51]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You could then modify `jumpbox` to only collect resources for production, for
    example, as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以修改 `jumpbox`，例如，只收集生产环境的资源，如下所示：
- en: '[PRE52]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Two important things to remember when working with exported resources: first,
    every resource must have a unique name across your installation. Using the `fqdn`
    domain name within the title is usually enough to keep your definitions unique.
    Second, any resource can be made virtual. Even defined types that you created
    may be exported. Exported resources can be used to achieve some fairly complex
    configurations that automatically adjust when machines change.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 处理导出资源时需要记住的两件重要事情：首先，每个资源在您的安装中必须有唯一的名称。在标题中使用 `fqdn` 域名通常足以保持定义的唯一性。其次，任何资源都可以是虚拟的。即使是您创建的定义类型也可以被导出。导出的资源可以用来实现一些复杂的配置，这些配置会在机器发生变化时自动调整。
- en: Note
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One word of caution when working with an extremely large number of nodes (more
    than 5,000) is that exported resources can take a long time to collect and apply,
    particularly if each exported resource creates a file.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理大量节点（超过 5,000 个）时，需要特别注意的是，导出的资源可能需要很长时间才能收集和应用，尤其是当每个导出的资源都会创建一个文件时。
