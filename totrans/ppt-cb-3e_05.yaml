- en: Chapter 5. Users and Virtual Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*"Nothing is a problem, until it''s a problem."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using virtual resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing users with virtual resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing users' SSH access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing users' customization files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using exported resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Users can be a real pain. I don't mean the people, though doubtless that's sometimes
    true. But keeping UNIX user accounts and file permissions in sync across a network
    of machines, some of them running different operating systems, can be very challenging
    without some kind of centralized configuration management.
  prefs: []
  type: TYPE_NORMAL
- en: Each new developer who joins the organization needs an account on every machine,
    along with `sudo` privileges and group memberships, and needs their SSH key authorized
    for a bunch of different accounts. The system administrator who has to take care
    of this manually will be at the job all day, while the system administrator who
    uses Puppet will be done in minutes, and head out for an early lunch.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll look at some handy patterns and techniques to manage
    users and their associated resources. Users are also one of the most common applications
    for virtual resources, so we'll find out all about those. In the final section,
    we'll introduce exported resources, which are related to virtual resources.
  prefs: []
  type: TYPE_NORMAL
- en: Using virtual resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Virtual resources in Puppet might seem complicated and confusing but, in fact,
    they're very simple. They're exactly like regular resources, but they don't actually
    take effect until they're realized (in the sense of "made real"); whereas a regular
    resource can only be declared once per node (so two classes can't declare the
    same resource, for example). A virtual resource can be realized as many times
    as you like.
  prefs: []
  type: TYPE_NORMAL
- en: This comes in handy when you need to move applications and services between
    machines. If two applications that use the same resource end up sharing a machine,
    they would cause a conflict unless you make the resource virtual.
  prefs: []
  type: TYPE_NORMAL
- en: To clarify this, let's look at a typical situation where virtual resources might
    come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are responsible for two popular web applications: WordPress and Drupal.
    Both are web apps running on Apache, so they both require the Apache package to
    be installed. The definition for WordPress might look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition for Drupal might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'All is well until you need to consolidate both apps onto a single server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now Puppet will complain because you tried to define two resources with the
    same name: `httpd`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using virtual resources](img/B03643_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You could remove the duplicate Apache package definition from one of the classes,
    but then nodes without the class including Apache would fail. You can get around
    this problem by putting the Apache package in its own class and then using `include
    apache` everywhere it's needed; Puppet doesn't mind you including the same class
    multiple times. In reality, putting Apache in its own class solves most problems
    but, in general, this method has the disadvantage that every potentially conflicting
    resource must have its own class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Virtual resources can be used to solve this problem. A virtual resource is
    just like a normal resource, except that it starts with an `@` character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can think of it as being like a placeholder resource; you want to define
    it but you aren't sure you are going to use it yet. Puppet will read and remember
    virtual resource definitions, but won't actually create the resource until you
    realize the resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the resource, use the `realize` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can call `realize` as many times as you want on the resource and it won't
    result in a conflict. So virtual resources are the way to go when several different
    classes all require the same resource, and they may need to coexist on the same
    node.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s how to build the example using virtual resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the virtual module with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the Drupal module with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the WordPress module with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify your `site.pp` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run Puppet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You define the package and service as virtual resources in one place: the `virtual`
    class. All nodes can include this class and you can put all your virtual services
    and packages in it. None of the packages will actually be installed on a node
    or services started until you call `realize`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Every class that needs the Apache package can call `realize` on this virtual
    resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Puppet knows, because you made the resource virtual, that you intended to have
    multiple references to the same package, and didn't just accidentally create two
    resources with the same name. So it does the right thing.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To realize virtual resources, you can also use the collection *spaceship* syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The advantage of this syntax is that you''re not restricted to the resource
    name; you could also use a tag, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can just specify all instances of the resource type, by
    leaving the query section blank:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Managing users with virtual resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Users are a great example of a resource that may need to be realized by multiple
    classes. Consider the following situation. To simplify administration of a large
    number of machines, you defined classes for two kinds of users: `developers` and
    `sysadmins`. All machines need to include `sysadmins`, but only some machines
    need `developers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: However, some users may be members of both groups. If each group simply declares
    its members as regular `user` resources, this will lead to a conflict when a node
    includes both `developers` and `sysadmins`, as in the `webserver` example.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this conflict, a common pattern is to make all users virtual resources,
    defined in a single class `user::virtual` that every machine includes, and then
    realizing the users where they are needed. This way, there will be no conflict
    if a user is a member of multiple groups.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a `user::virtual` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the file `modules/user/manifests/virtual.pp` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the file `modules/user/manifests/developers.pp` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the file `modules/user/manifests/sysadmins.pp` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify your `nodes.pp` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run Puppet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we include the `user::virtual` class, all the users are declared as virtual
    resources (because we included the `@` symbol):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: That is to say, the resources exist in Puppet's catalog; they can be referred
    to by and linked with other resources, and they are in every respect identical
    to regular resources, except that Puppet doesn't actually create the corresponding
    users on the machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for that to happen, we need to call `realize` on the virtual resources.
    When we include the `user::sysadmins` class, we get the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling `realize` on a virtual resource tells Puppet, "I''d like to use that
    resource now". This is what it does, as we can see from the run output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: However, Theresa is in both the `developers` and `sysadmins` classes! Won't
    that mean we end up calling `realize` twice on the same resource?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Yes, it does, and that's fine. You're explicitly allowed to realize resources
    multiple times, and there will be no conflict. So long as some class, somewhere,
    calls `realize` on Theresa's account, it will be created. Unrealized resources
    are simply discarded during catalog compilation.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you use this pattern to manage your own users, every node should include
    the `user::virtual` class, as a part of your basic housekeeping configuration.
    This class will declare all users (as virtual) in your organization or site. This
    should also include any users who exist only to run applications or services (such
    as `Apache`, `www-data`, or `deploy`, for example). Then, you can realize them
    as needed on individual nodes or in specific classes.
  prefs: []
  type: TYPE_NORMAL
- en: For production use, you'll probably also want to specify a UID and GID for each
    user or group, so that these numeric identifiers are synchronized across your
    network. You can do this using the `uid` and `gid` parameters for the `user` resource.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you don't specify a user's UID, for example, you'll just get whatever is
    the next ID number available on a given machine, so the same user on different
    machines will have a different UID. This can lead to permission problems when
    using shared storage, or moving files between machines.
  prefs: []
  type: TYPE_NORMAL
- en: A common pattern when defining users as virtual resources is to assign tags
    to the users based on their assigned roles within your organization. You can then
    use the `collector` syntax instead of `realize` to collect users with specific
    tags applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, see the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, only users `thomas` and `theresa` would be included.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using virtual resources* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Managing users' customization files* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing users' SSH access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A sensible approach to access control for servers is to use named user accounts
    with passphrase-protected SSH keys, rather than having users share an account
    with a widely known password. Puppet makes this easy to manage thanks to the built-in
    `ssh_authorized_key` type.
  prefs: []
  type: TYPE_NORMAL
- en: To combine this with virtual users, as described in the previous section, you
    can create a `define`, which includes both the `user` and `ssh_authorized_key`
    resources. This will also come in handy when adding customization files and other
    resources to each user.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to extend your virtual users'' class to include SSH access:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new module `ssh_user` to contain our `ssh_user` definition. Create
    the `modules/ssh_user/manifests/init.pp` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify your `modules/user/manifests/virtual.pp` file, comment out the previous
    definition for user `thomas`, and replace it with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify your `modules/user/manifests/sysadmins.pp` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify your `site.pp` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run Puppet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For each user in our `user::virtual` class, we need to create:'
  prefs: []
  type: TYPE_NORMAL
- en: The user account itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user's home directory and `.ssh` directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user's `.ssh/authorized_keys` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We could declare separate resources to implement all of these for each user,
    but it''s much easier to create a definition instead, which wraps them into a
    single resource. By creating a new module for our definition, we can refer to
    `ssh_user` from anywhere (in any scope):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'After we create the user, we can then create the home directory; we need the
    user first so that when we assign ownership, we can use the username, `owner =>
    $name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Puppet can create the users' home directory using the `managehome` attribute
    to the user resource. Relying on this mechanism is problematic in practice, as
    it does not account for users that were created outside of Puppet without home
    directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to ensure that the `.ssh` directory exists within the home directory
    of the user. We require the home directory, `File["/home/${name}"]`, since that
    needs to exist before we create this subdirectory. This implies that the user
    already exists because the home directory required the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create the `ssh_authorized_key` resource, again requiring the containing
    folder (`File["/home/${name}/.ssh"]`). We use the `$key` and `$keytype` variables
    to assign the key and type parameters to the `ssh_authorized_key` type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We passed the `$key` and `$keytype` variables when we defined the `ssh_user`
    resource for `thomas`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The value for `key`, in the preceding code snippet, is the ssh key's public
    key value; it is usually stored in an `id_rsa.pub` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, with everything defined, we just need to call `realize` on `thomas` for
    all these resources to take effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that this time the virtual resource we''re realizing is not simply the
    `user` resource, as before, but the `ssh_user` defined type we created, which
    includes the user and the related resources needed to set up the SSH access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of course, you can add whatever resources you like to the `ssh_user` definition
    to have Puppet automatically create them for new users. We'll see an example of
    this in the next recipe, *Managing users' customization files*.
  prefs: []
  type: TYPE_NORMAL
- en: Managing users' customization files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Users tend to customize their shell environments, terminal colors, aliases,
    and so forth. This is usually achieved by a number of **dotfiles** in their home
    directory, for example, `.bash_profile` or `.vimrc`.
  prefs: []
  type: TYPE_NORMAL
- en: You can use Puppet to synchronize and update each user's dotfiles across a number
    of machines by extending the virtual user setup we developed throughout this chapter.
    We'll start a new module, `admin_user` and use the file types, `recurse` attribute
    to copy files into each user's home directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s what you need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `admin_user` defined type (`define admin_user`) in the `modules/admin_user/manifests/init.pp`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the file `modules/user/manifests/sysadmins.pp` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alter the definition of `thomas` in `modules/user/manifests/virtual.pp` as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a subdirectory in the `admin_user` module for the file of user `thomas`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create dotfiles for the user `thomas` in the directory you just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make sure your `site.pp` file reads as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run Puppet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We created a new `admin_user` definition, which defines the home directory
    recursively if `$dotfiles` is not `false` (the default value):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We created a directory to hold the user''s dotfiles within the `admin_user`
    module; all the files within that directory will be copied into the user''s home
    directory, as shown in the puppet run output in the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Using the `recurse` option allows us to add as many dotfiles as we wish for
    each user without having to modify the definition of the user.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We could specify that the `source` attribute of the home directory is a directory
    where users can place their own dotfiles. This way, each user could modify their
    own dotfiles and have them transferred to all the nodes in the network without
    our involvement.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Managing users with virtual resources* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using exported resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All our recipes up to this point have dealt with a single machine. It is possible
    with Puppet to have resources from one node affect another node. This interaction
    is managed with **exported resources**. Exported resources are just like any resource
    you might define for a node but instead of applying to the node on which they
    were created, they are exported for use by all nodes in the environment. Exported
    resources can be thought of as virtual resources that go one step further and
    exist beyond the node on which they were defined.
  prefs: []
  type: TYPE_NORMAL
- en: There are two actions with exported resources. When an exported resource is
    created, it is said to be defined. When all the exported resources are harvested,
    they are said to be collected. Defining exported resources is similar to virtual
    resources; the resource in question has two `@` symbols prepended. For example,
    to define a file resource as external, use `@@file`. Collecting resources is done
    with the space ship operator, `<<| |>>`; this is thought to look like a spaceship.
    To collect the exported file resource (`@@file`), you would use `File <<| |>>`.
  prefs: []
  type: TYPE_NORMAL
- en: There are many examples that use exported resources; the most common one involves
    SSH host keys. Using exported resources, it is possible to have every machine
    that is running Puppet share their SSH host keys with the other connected nodes.
    The idea here is that each machine exports its own host key and then collects
    all the keys from the other machines. In our example, we will create two classes;
    first, a class that exports the SSH host key from every node. We will include
    this class in our base class. The second class will be a collector class, which
    collects the SSH host keys. We will apply this class to our Jumpboxes or SSH login
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Jumpboxes are machines that have special firewall rules to allow them to log
    in to different locations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use exported resources, you will need to enable storeconfigs on your Puppet
    masters. It is possible to use exported resources with a masterless (decentralized)
    deployment; however, we will assume you are using a centralized model for this
    example. In [Chapter 2](ch02.html "Chapter 2. Puppet Infrastructure"), *Puppet
    Infrastructure*, we configured puppetdb using the puppetdb module from the forge.
    It is possible to use other backends if you desire; however, all of these except
    puppetdb are deprecated. More information is available at the following link:
    [http://projects.puppetlabs.com/projects/puppet/wiki/Using_Stored_Configuration](http://projects.puppetlabs.com/projects/puppet/wiki/Using_Stored_Configuration).'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure your Puppet masters are configured to use puppetdb as a storeconfigs
    container.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll create an `ssh_host` class to export the `ssh` keys of a host and ensure
    that it is included in our base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the first class, `base::ssh_host`, which we will include in our base
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remember to include this class from inside the base class definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a definition for `jumpbox`, either in a class or within the node definition
    for `jumpbox`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now run Puppet on a few nodes to create the exported resources. In my case,
    I ran Puppet on my Puppet server and my second example node (`node2`). Finally,
    run Puppet on `jumpbox` to verify that the SSH host keys for our other nodes are
    collected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created an `sshkey` resource for the node using the facter facts `fqdn`,
    `hostname`, `ipaddress`, and `sshdsakey`. We use the `fqdn` as the title for our
    exported resource because each exported resource must have a unique name. We can
    assume the `fqdn` of a node will be unique within our organization (although sometimes
    they may not be; Puppet can be good at finding out such things when you least
    expect it). We then go on to define aliases by which our node may be known. We
    use the hostname variable for one alias and the main IP address of the machine
    as the other. If you had other naming conventions for your nodes, you could include
    other aliases here. We assume that hosts are using DSA keys, so we use the `sshdsakey`
    variable in our definition. In a large installation, you would wrap this definition
    in tests to ensure the DSA keys existed. You would also use the RSA keys if they
    existed as well.
  prefs: []
  type: TYPE_NORMAL
- en: With the `sshkey` resource defined and exported, we then created a `jumpbox`
    node definition. In this definition, we used the spaceship syntax `Sshkey <<|
    |>>` to collect all defined exported `sshkey` resources.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When defining the exported resources, you can add tag attributes to the resource
    to create subsets of exported resources. For example, if you had a development
    and production area of your network, you could create different groups of `sshkey`
    resources for each area as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You could then modify `jumpbox` to only collect resources for production, for
    example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Two important things to remember when working with exported resources: first,
    every resource must have a unique name across your installation. Using the `fqdn`
    domain name within the title is usually enough to keep your definitions unique.
    Second, any resource can be made virtual. Even defined types that you created
    may be exported. Exported resources can be used to achieve some fairly complex
    configurations that automatically adjust when machines change.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One word of caution when working with an extremely large number of nodes (more
    than 5,000) is that exported resources can take a long time to collect and apply,
    particularly if each exported resource creates a file.
  prefs: []
  type: TYPE_NORMAL
