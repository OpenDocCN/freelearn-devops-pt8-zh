<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer092">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 class="chapterTitle" id="_idParaDest-120"><span class="koboSpan" id="kobo.2.1">Solution Architecture Design Patterns</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">Have you ever wondered how large enterprises design scalable systems? </span><span class="koboSpan" id="kobo.3.2">Before starting application development, solutions architects work across organizations and weigh multiple options to develop architecture designs to handle their business needs.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4.1">There are multiple ways to design a solution. </span><span class="koboSpan" id="kobo.4.2">A solutions architect needs to take the right approach based on user requirements and the architecture constraints of cost, performance, scalability, and availability. </span><span class="koboSpan" id="kobo.4.3">In this chapter, you will learn about various solution architecture patterns, reference architectures, and how to apply them in real-world scenarios.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5.1">In the previous chapters, you learned about the principles of solution architecture design. </span><span class="koboSpan" id="kobo.5.2">This chapter is exciting and essential as you can apply your learning to various architectural design patterns. </span><span class="koboSpan" id="kobo.5.3">In this chapter, you will gain an understanding of some of the significant solution architecture patterns, such as layered, event-driven, microservice, loosely coupled, service-oriented, and RESTful architectures.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6.1">You will learn about the advantages of various architectural designs and look at examples demonstrating when to utilize them. </span><span class="koboSpan" id="kobo.6.2">You will also gain an understanding of architecture design anti-patterns in addition to the following architecture design patterns:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.7.1">Building an n-tier layered architecture</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.8.1">Creating a multi-tenant SaaS-based architecture</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.9.1">Understanding service-oriented architecture</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.10.1">RESTful web service architecture </span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.11.1">Building a cache-based architecture</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.12.1">Model-View-Controller</span></strong><span class="koboSpan" id="kobo.13.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.14.1">MVC</span></strong><span class="koboSpan" id="kobo.15.1">) architecture </span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.16.1">Building </span><strong class="keyWord"><span class="koboSpan" id="kobo.17.1">Domain-Driven Design</span></strong><span class="koboSpan" id="kobo.18.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.19.1">DDD</span></strong><span class="koboSpan" id="kobo.20.1">)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.21.1">Understanding the circuit breaker pattern</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.22.1">Implementing the bulkhead pattern</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.23.1">Creating a floating IP pattern</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.24.1">Deploying an application with a container</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.25.1">Database handling in application architecture</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.26.1">Clean Architecture </span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.27.1">Avoiding anti-patterns in solution architecture</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.28.1">By the end of the chapter, you will know how to optimize your solution architecture design and apply best practices, making this chapter the center point and core of your learning.</span></p>
<h1 class="heading-1" id="_idParaDest-121"><span class="koboSpan" id="kobo.29.1">Building an n-tier layered architecture</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.30.1">In </span><em class="italic"><span class="koboSpan" id="kobo.31.1">n</span></em><span class="koboSpan" id="kobo.32.1">-tier architecture (also </span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.33.1">known as </span><strong class="keyWord"><span class="koboSpan" id="kobo.34.1">multitier architecture</span></strong><span class="koboSpan" id="kobo.35.1">), you need to apply loosely coupled design principles and attributes of scalability </span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.36.1">and elasticity. </span><span class="koboSpan" id="kobo.36.2">In n-tier architecture, you divide your product functions into multiple layers, such as presentation, business, database, and services, so that each layer can be implemented and scaled independently.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.37.1">With n-tier architecture, adopting new technologies and making development more efficient is easy. </span><span class="koboSpan" id="kobo.37.2">This layered architecture provides the flexibility to add new features in each layer without disturbing the features of other layers. </span><span class="koboSpan" id="kobo.37.3">In terms of security, you can keep each layer secure and isolated from the others, so if one layer gets compromised, the other layers won’t be impacted. </span><span class="koboSpan" id="kobo.37.4">Application troubleshooting and management also become manageable as you can quickly pinpoint where an issue is coming from and which part of the application needs to be troubleshot.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.38.1">The most common architecture </span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.39.1">in multilayer design is </span><strong class="keyWord"><span class="koboSpan" id="kobo.40.1">three-tier architecture</span></strong><span class="koboSpan" id="kobo.41.1">, so let’s learn more about it. </span><span class="koboSpan" id="kobo.41.2">The following diagram shows an AWS example architecture that allows you to interact with a web application from the browser and perform the required functions, for example, ordering your favorite T-shirt or reading a blog and leaving a comment:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.42.1"><img alt="" role="presentation" src="../Images/B21336_04_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.43.1">Figure 4.1: Three-tier website architecture</span></p>
<p class="normal"><span class="koboSpan" id="kobo.44.1">In the </span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.45.1">preceding architecture, you have the following three layers:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.46.1">Web Layer</span></strong><span class="koboSpan" id="kobo.47.1">: The web layer is the user-facing part of the application. </span><span class="koboSpan" id="kobo.47.2">End users interact with the web layer to collect or provide information.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.48.1">Application Layer</span></strong><span class="koboSpan" id="kobo.49.1">: The application layer mainly contains business logic and acts upon information received from the web layer.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.50.1">Database Layer</span></strong><span class="koboSpan" id="kobo.51.1">: All kinds of user data and application data are stored in the database layer.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.52.1">Let’s take a look at these layers in more detail.</span></p>
<h2 class="heading-2" id="_idParaDest-122"><span class="koboSpan" id="kobo.53.1">The web layer</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.54.1">The web </span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.55.1">layer is also known as the </span><strong class="keyWord"><span class="koboSpan" id="kobo.56.1">presentation tier</span></strong><span class="koboSpan" id="kobo.57.1">. </span><span class="koboSpan" id="kobo.57.2">The web </span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.58.1">layer provides a user interface that helps the end </span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.59.1">user to interact with the application. </span><span class="koboSpan" id="kobo.59.2">The web layer is your user interface (in this case, the website page), where the user enters information or browses it. </span><span class="koboSpan" id="kobo.59.3">Web developers may build a presentation tier user interface in technologies </span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.60.1">such as HTML, CSS, Angular, React, </span><strong class="keyWord"><span class="koboSpan" id="kobo.61.1">JavaServer Pages</span></strong><span class="koboSpan" id="kobo.62.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.63.1">JSP</span></strong><span class="koboSpan" id="kobo.64.1">), and </span><strong class="keyWord"><span class="koboSpan" id="kobo.65.1">Active Server Pages</span></strong><span class="koboSpan" id="kobo.66.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.67.1">ASP</span></strong><span class="koboSpan" id="kobo.68.1">). </span><span class="koboSpan" id="kobo.68.2">This tier collects the information from the </span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.69.1">user and passes it to the application layer.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.70.1">The web layer is user-facing, so organizations spend most of their time improving the user experience. </span><span class="koboSpan" id="kobo.70.2">Many </span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.71.1">organizations have dedicated </span><strong class="keyWord"><span class="koboSpan" id="kobo.72.1">User Experience</span></strong><span class="koboSpan" id="kobo.73.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.74.1">UX</span></strong><span class="koboSpan" id="kobo.75.1">) teams researching various areas to understand how users interact with applications.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.76.1">Also, the solutions architect must ensure the architecture design includes UX input and page load performance. </span><span class="koboSpan" id="kobo.76.2">There should be a seamless information flow between the web and application layers to return the correct information to users within the expected timeframe, such as user login, profile loading, etc.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.77.1">Let’s look at the application layer.</span></p>
<h2 class="heading-2" id="_idParaDest-123"><span class="koboSpan" id="kobo.78.1">The application layer</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.79.1">The application layer is also </span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.80.1">known as the </span><strong class="keyWord"><span class="koboSpan" id="kobo.81.1">logic tier</span></strong><span class="koboSpan" id="kobo.82.1">, as this is the core of the product where all </span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.83.1">the business logic resides. </span><span class="koboSpan" id="kobo.83.2">The presentation tier collects the information from the user and passes it to the logic tier to process it and get a result. </span><span class="koboSpan" id="kobo.83.3">For example, on an e-commerce website such as Amazon, users can enter a date range on the website’s order page to find their order summary. </span><span class="koboSpan" id="kobo.83.4">In return, the web </span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.84.1">layer passes the data range information to the application layer. </span><span class="koboSpan" id="kobo.84.2">The application layer processes the user input to perform business logic, such as the count of orders, the sum of amounts, and the number of items purchased. </span><span class="koboSpan" id="kobo.84.3">This returns information to the web layer to render it for the user.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.85.1">Generally, in a three-tier architecture, all algorithms and complex logic live in the application tier, including creating a recommendation engine or showing personalized pages to the user as per their browsing history. </span><span class="koboSpan" id="kobo.85.2">You may add layers such as a domain layer, data access layer, or presentation layer to make a four- or five-tier architecture. </span><span class="koboSpan" id="kobo.85.3">Developers may choose to implement this layer in a server-side programming language, for example, C++, Java, .NET, or Node.js. </span><span class="koboSpan" id="kobo.85.4">The application layer is the center of system design and requires most of the design effort. </span><span class="koboSpan" id="kobo.85.5">Most of the application features depend on logic built at the application layer. </span><span class="koboSpan" id="kobo.85.6">The application layer performs logic on the data stored in the database layer. </span><span class="koboSpan" id="kobo.85.7">Let’s look at the database layer in more detail.</span></p>
<h2 class="heading-2" id="_idParaDest-124"><span class="koboSpan" id="kobo.86.1">The database layer</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.87.1">The database layer, also </span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.88.1">known as the </span><strong class="keyWord"><span class="koboSpan" id="kobo.89.1">data tier</span></strong><span class="koboSpan" id="kobo.90.1">, stores all the information related to user profiles </span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.91.1">and transactions. </span><span class="koboSpan" id="kobo.91.2">Essentially, it contains any data that needs to persist in being stored in the data tier. </span><span class="koboSpan" id="kobo.91.3">This information </span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.92.1">is sent back to the application layer for logic processing, and then, eventually, is rendered to the user in the web layer. </span><span class="koboSpan" id="kobo.92.2">For example, suppose the user is logged in to a website with their ID and password. </span><span class="koboSpan" id="kobo.92.3">In that case, the application layer verifies the user credentials with information stored in the database. </span><span class="koboSpan" id="kobo.92.4">If the credentials match the stored information, the user is allowed to log in and access the authorized area of the website.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.93.1">The architect may choose to build a data tier in relational databases, for example, PostgreSQL, MariaDB, Oracle Database, MySQL, Microsoft SQL Server, Amazon Aurora, or Amazon RDS. </span><span class="koboSpan" id="kobo.93.2">The architect may add a NoSQL database such as Amazon DynamoDB, MongoDB, or Apache Cassandra.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.94.1">The data tier is used to store transaction information and hold user session information and application configuration. </span><span class="koboSpan" id="kobo.94.2">An architect may consider adding caching databases such as Memcached and Redis to meet performance needs. </span><span class="koboSpan" id="kobo.94.3">You will learn more about various databases in </span><em class="chapterRef"><span class="koboSpan" id="kobo.95.1">Chapter 12</span></em><span class="koboSpan" id="kobo.96.1">, </span><em class="italic"><span class="koboSpan" id="kobo.97.1">Data Engineering for Solution Architecture</span></em><span class="koboSpan" id="kobo.98.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.99.1">The data tier needs special attention in terms of security. </span><span class="koboSpan" id="kobo.99.2">You must protect user information by applying data encryption at rest and in transit. </span><span class="koboSpan" id="kobo.99.3">In the </span><em class="italic"><span class="koboSpan" id="kobo.100.1">n</span></em><span class="koboSpan" id="kobo.101.1">-tier layered architecture diagram, you will notice that each layer has its own auto-scaling configuration, which means it can be scaled independently. </span><span class="koboSpan" id="kobo.101.2">Also, each layer has a network boundary, which means having access to one layer doesn’t allow access to other layers. </span><span class="koboSpan" id="kobo.101.3">You will learn more about security considerations in </span><em class="chapterRef"><span class="koboSpan" id="kobo.102.1">Chapter 7</span></em><span class="koboSpan" id="kobo.103.1">, </span><em class="italic"><span class="koboSpan" id="kobo.104.1">Security Considerations</span></em><span class="koboSpan" id="kobo.105.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.106.1">The architect needs to decide on the number of tiers based on application complexity and user requirements. </span><span class="koboSpan" id="kobo.106.2">For example, you might add additional tiers, such as a data access layer for database access logic, and keep the data storage layer for the database engine. </span><span class="koboSpan" id="kobo.106.3">You can add more layers to reduce complexity by defining logical separation, which can help increase the application’s general maintainability and the ability to scale and achieve performance.</span></p>
<h1 class="heading-1" id="_idParaDest-125"><span class="koboSpan" id="kobo.107.1">Creating a multi-tenant SaaS-based architecture</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.108.1">In the </span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.109.1">previous section, you learned about multitier architecture, also called a </span><strong class="keyWord"><span class="koboSpan" id="kobo.110.1">single tenancy</span></strong><span class="koboSpan" id="kobo.111.1">, when built for a single organization. </span><span class="koboSpan" id="kobo.111.2">Multi-tenant architecture </span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.112.1">is becoming more popular as organizations welcome the digital revolution while keeping the overall application and operational cost low.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.113.1">The </span><strong class="keyWord"><span class="koboSpan" id="kobo.114.1">Software-as-a-Service</span></strong><span class="koboSpan" id="kobo.115.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.116.1">SaaS</span></strong><span class="koboSpan" id="kobo.117.1">) model </span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.118.1">is constructed upon a multi-tenant architecture, where an instance of the software and the accompanying infrastructure caters to numerous customers. </span><span class="koboSpan" id="kobo.118.2">Within this framework, each customer utilizes the application and database in a shared manner. </span><span class="koboSpan" id="kobo.118.3">With each tenant being isolated by their unique configuration, identity, and data, they remain invisible to each other while sharing the same product.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.119.1">As multi-tenant SaaS providers are responsible for everything from the hardware to the software, SaaS-based products offload an organization’s responsibilities to the application’s maintenance and updates, as the SaaS provider takes care of this.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.120.1">Each organizations those are buyer of SaaS product consider as tenant. </span><span class="koboSpan" id="kobo.120.2">These tenants can customize their user interface using a configuration without code changes. </span><span class="koboSpan" id="kobo.120.3">As multiple customers share a common infrastructure, they benefit from scale, which further lowers the cost. </span><span class="koboSpan" id="kobo.120.4">Some of the most popular SaaS providers are Salesforce CRM, Jira Software, Slack, Google Workspace, and Amazon Connect.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.121.1">As shown in the following architecture diagram, two organizations (tenants) use the same software and infrastructure. </span><span class="koboSpan" id="kobo.121.2">The SaaS vendor provides access to the application layer by allocating a unique tenant ID to each organization:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.122.1"><img alt="" role="presentation" src="../Images/B21336_04_02.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.123.1">Figure 4.2: Multi-tenant SaaS architecture</span></p>
<p class="normal"><span class="koboSpan" id="kobo.124.1">The </span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.125.1">preceding architecture design shows that the presentation layer provides a user interface, and the application layer holds the business logic. </span><span class="koboSpan" id="kobo.125.2">At the data access layer, each tenant will have data-level isolation with one of the following methods:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.126.1">Database-Level Isolation</span></strong><span class="koboSpan" id="kobo.127.1">: In this model, each tenant has its database associated </span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.128.1">with its tenant ID. </span><span class="koboSpan" id="kobo.128.2">When each tenant queries data from the user interface, they are redirected to their database. </span><span class="koboSpan" id="kobo.128.3">This model is required if the customer doesn’t want a single shared database for compliance and security reasons.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.129.1">Table-Level Isolation</span></strong><span class="koboSpan" id="kobo.130.1">: This isolation level can be achieved by providing a separate </span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.131.1">table for each tenant. </span><span class="koboSpan" id="kobo.131.2">In this model, tables need to be uniquely assigned to each tenant, for example, with the tenant ID prefix. </span><span class="koboSpan" id="kobo.131.3">When each tenant queries data from the user interface, they are redirected to their tables as per their unique identifier.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.132.1">Row-Level Isolation</span></strong><span class="koboSpan" id="kobo.133.1">: All </span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.134.1">tenants share the same table in a database in this isolation level. </span><span class="koboSpan" id="kobo.134.2">There is an additional column in a table where a unique tenant ID is stored against each row. </span><span class="koboSpan" id="kobo.134.3">When an individual tenant wants to access their data from the user interface, the application’s data access layer formulates a query based on the tenant ID to the shared table. </span><span class="koboSpan" id="kobo.134.4">Each tenant gets a row that belongs to their users only.</span></li>
</ul>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.135.1">For enterprise customers, a careful assessment should be carried out to understand whether a SaaS solution fits them based on their unique features’ requirements. </span><span class="koboSpan" id="kobo.135.2">This is because, often, a SaaS model has limited customization capabilities.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.136.1">The selection of isolation approaches is based on considerations around the organization’s compliance, security, cost, and tenant contractual requirements.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.137.1">It’s important </span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.138.1">to find the cost value proposition if many users need to subscribe. </span><span class="koboSpan" id="kobo.138.2">The cost comparison should be calculated based on the total cost of ownership when making a </span><em class="italic"><span class="koboSpan" id="kobo.139.1">build versus buy</span></em><span class="koboSpan" id="kobo.140.1"> decision. </span><span class="koboSpan" id="kobo.140.2">This is because building software is not the primary business of most organizations, so the SaaS model is becoming highly popular as organizations can focus on their business and let the experts handle the IT side of it.</span></p>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.141.1">Service-oriented architecture</span></strong><span class="koboSpan" id="kobo.142.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.143.1">SOA</span></strong><span class="koboSpan" id="kobo.144.1">) is a popular approach for designing and building applications, especially when organizations have unique, customized requirements. </span><span class="koboSpan" id="kobo.144.2">Let’s learn more about it.</span></p>
<h1 class="heading-1" id="_idParaDest-126"><span class="koboSpan" id="kobo.145.1">Understanding service-oriented architecture</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.146.1">In </span><strong class="keyWord"><span class="koboSpan" id="kobo.147.1">SOA</span></strong><span class="koboSpan" id="kobo.148.1"> patterns, different application components interact using a communication protocol </span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.149.1">over the network. </span><span class="koboSpan" id="kobo.149.2">Each service provides end-to-end functionality, for example, </span><em class="italic"><span class="koboSpan" id="kobo.150.1">fetching an order history</span></em><span class="koboSpan" id="kobo.151.1">. </span><span class="koboSpan" id="kobo.151.2">SOA is widely adopted by large systems to integrate business processes, for example, taking your payment service from the main application and putting it as a separate solution.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.152.1">In a general sense, SOAs take monolithic applications and spread some of those operations into individual </span><em class="italic"><span class="koboSpan" id="kobo.153.1">services</span></em><span class="koboSpan" id="kobo.154.1"> that operate independently. </span><span class="koboSpan" id="kobo.154.2">The goal of using an SOA is to loosen the coupling of your application’s services. </span><span class="koboSpan" id="kobo.154.3">Sometimes, an SOA includes splitting services apart from one another and splitting resources into separate instances of that service. </span><span class="koboSpan" id="kobo.154.4">For example, while some choose to store their company’s data in a single database split by tables, an SOA would consider modularizing the application by function into separate databases altogether. </span><span class="koboSpan" id="kobo.154.5">This allows you to scale and manage throughput based on the individual needs of tables for each database.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.155.1">SOA has multiple benefits, for example, the parallelization of development, deployment, and operation. </span><span class="koboSpan" id="kobo.155.2">It decouples the service so that you can optimize and scale each service individually.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.156.1">However, it also requires more robust governance to ensure work performed by each service’s team </span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.157.1">meets the same standard. </span><span class="koboSpan" id="kobo.157.2">With SOA, the solution could become complex enough to increase the overhead to balance that, so you need to choose tools and implement automation for service monitoring, deployment, and scaling.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.158.1">There </span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.159.1">are multiple ways to implement SOA.</span></p>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.160.1">Simple Object Access Protocol</span></strong><span class="koboSpan" id="kobo.161.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.162.1">SOAP</span></strong><span class="koboSpan" id="kobo.163.1">) was initially the most popular messaging protocol, but it </span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.164.1">is heavyweight as it relies entirely on XML for data interchange. </span><strong class="keyWord"><span class="koboSpan" id="kobo.165.1">Representational State Transfer</span></strong><span class="koboSpan" id="kobo.166.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.167.1">REST</span></strong><span class="koboSpan" id="kobo.168.1">) architecture is becoming more popular as developers need to build more lightweight mobile and web applications. </span><span class="koboSpan" id="kobo.168.2">As of the time of writing, SOAP architecture is considered legacy architecture, so in this edition of the book, we will focus on learning REST architecture.</span></p>
<h2 class="heading-2" id="_idParaDest-127"><span class="koboSpan" id="kobo.169.1">RESTful web service architecture</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.170.1">A </span><strong class="keyWord"><span class="koboSpan" id="kobo.171.1">REST</span></strong><span class="koboSpan" id="kobo.172.1"> or RESTful </span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.173.1">web service offers better performance due to its lightweight architecture. </span><span class="koboSpan" id="kobo.173.2">It allows different messaging formats, such as JSON, plaintext, HTML, and XML, compared to SOAP, which only allows XML. </span><span class="koboSpan" id="kobo.173.3">REST is an architecture style that defines the standard for loosely coupled application design </span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.174.1">using the HTTP protocol for data transmission.</span></p>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.175.1">JavaScript Object Notation</span></strong><span class="koboSpan" id="kobo.176.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.177.1">JSON</span></strong><span class="koboSpan" id="kobo.178.1">) is a more accessible format for data exchange in REST architecture. </span><span class="koboSpan" id="kobo.178.2">JSON is also lightweight and language-independent. </span><span class="koboSpan" id="kobo.178.3">It contains a simple key-value pair that makes it compatible with data structures defined in most programming languages.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.179.1">RESTful web services, also </span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.180.1">known as REST web services, establish a framework with specific rules to design web services. </span><span class="koboSpan" id="kobo.180.2">They are aimed at ensuring compatibility between various computer systems connected through the internet. </span><span class="koboSpan" id="kobo.180.3">With RESTful web services, systems can communicate by accessing and modifying text-based data on the web using a consistent and predefined set of operations that don’t rely on past interactions or states. </span><span class="koboSpan" id="kobo.180.4">Here are some fundamental principles of RESTful web service architecture, along with an illustration of the principles of RESTful web service architecture using the example of an e-commerce website:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.181.1">Stateless</span></strong><span class="koboSpan" id="kobo.182.1">: Every request from the client to the server must contain all the information </span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.183.1">the server needs to understand and process. </span><span class="koboSpan" id="kobo.183.2">Every request made by a client includes all the </span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.184.1">necessary information to fulfill that request, and there is no need to maintain any session-related information on the server; instead, it is entirely managed on the client side. </span><span class="koboSpan" id="kobo.184.2">Taking the example of an e-commerce website, each request from a client, like viewing a product or adding it to the cart, must contain all the information needed for processing. </span><span class="koboSpan" id="kobo.184.3">If a user wants to view their cart, the request must include the user’s ID or any other relevant details so the server can identify and respond with the appropriate card details.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.185.1">Client-server architecture</span></strong><span class="koboSpan" id="kobo.186.1">: In this design, there are two distinct parts, the client </span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.187.1">and the server, which communicate with each other through a network. </span><span class="koboSpan" id="kobo.187.2">The client is </span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.188.1">responsible for managing the user interface and interacting with the user, and the server is responsible for the backend and data processing. </span><span class="koboSpan" id="kobo.188.2">They can evolve separately without affecting each other. </span><span class="koboSpan" id="kobo.188.3">The client (browser or app) manages user interaction, like selecting products, while the server handles data retrieval, cart management, and checkout processing. </span><span class="koboSpan" id="kobo.188.4">They interact through HTTP requests and responses.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.189.1">Uniform interface</span></strong><span class="koboSpan" id="kobo.190.1">: REST uses a uniform interface, simplifying and decoupling </span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.191.1">the architecture. </span><span class="koboSpan" id="kobo.191.2">For RESTful APIs, interactions are facilitated through a set of standard </span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.192.1">HTTP methods that correspond to </span><strong class="keyWord"><span class="koboSpan" id="kobo.193.1">CRUD</span></strong><span class="koboSpan" id="kobo.194.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.195.1">Create, Read, Update, Delete</span></strong><span class="koboSpan" id="kobo.196.1">) operations. </span><span class="koboSpan" id="kobo.196.2">These methods include:</span><ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.197.1">GET</span></strong><span class="koboSpan" id="kobo.198.1">: This </span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.199.1">method is used to retrieve </span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.200.1">data from the server. </span><span class="koboSpan" id="kobo.200.2">For example, when a user wants to view a list of products on example.com, their browser sends a GET request to the server. </span><span class="koboSpan" id="kobo.200.3">The URL might look like </span><code class="inlineCode"><span class="koboSpan" id="kobo.201.1">https://example.com/api/products</span></code><span class="koboSpan" id="kobo.202.1">, and the server responds with the list of products in a structured format like JSON or XML.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.203.1">POST</span></strong><span class="koboSpan" id="kobo.204.1">: This </span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.205.1">method is used to create a </span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.206.1">new resource on the server. </span><span class="koboSpan" id="kobo.206.2">Suppose a user wants to add a new product to their shopping cart on </span><code class="inlineCode"><span class="koboSpan" id="kobo.207.1">example.com</span></code><span class="koboSpan" id="kobo.208.1">. </span><span class="koboSpan" id="kobo.208.2">They might fill out a form with the product details and click </span><strong class="screenText"><span class="koboSpan" id="kobo.209.1">Add to Cart</span></strong><span class="koboSpan" id="kobo.210.1">. </span><span class="koboSpan" id="kobo.210.2">This action would trigger a POST request to </span><code class="inlineCode"><span class="koboSpan" id="kobo.211.1">https://example.com/api/cart</span></code><span class="koboSpan" id="kobo.212.1">, including the product details in the request body. </span><span class="koboSpan" id="kobo.212.2">The server then processes this data and adds the new product to the user’s cart.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.213.1">PUT</span></strong><span class="koboSpan" id="kobo.214.1">: This </span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.215.1">method is used to update </span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.216.1">an existing resource on the server. </span><span class="koboSpan" id="kobo.216.2">If the user wants to update the quantity of a product in their cart, a PUT request would be sent to a specific URL like </span><code class="inlineCode"><span class="koboSpan" id="kobo.217.1">https://example.com/api/cart/{productId}</span></code><span class="koboSpan" id="kobo.218.1">. </span><span class="koboSpan" id="kobo.218.2">The request body would include the updated quantity, and the server would update the corresponding item in the user’s cart.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.219.1">DELETE</span></strong><span class="koboSpan" id="kobo.220.1">: This </span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.221.1">method is used to remove </span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.222.1">a resource from the server. </span><span class="koboSpan" id="kobo.222.2">For instance, if the user decides to remove a product from their cart, their browser would send a DELETE request to a URL like </span><code class="inlineCode"><span class="koboSpan" id="kobo.223.1">https://example.com/api/cart/{productId}</span></code><span class="koboSpan" id="kobo.224.1">. </span><span class="koboSpan" id="kobo.224.2">The server would then remove the specified product from the cart.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.225.1">By adhering </span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.226.1">to these standard methods, APIs provide a consistent way for developers to interact with web services, enabling them to perform basic operations on resources without needing to understand the underlying implementation details.</span></p>
</li>
</ul>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.227.1">Resource-based</span></strong><span class="koboSpan" id="kobo.228.1">: In REST, everything is considered a resource, and a specific URL can </span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.229.1">access each resource. </span><span class="koboSpan" id="kobo.229.2">Resources are the key abstractions in REST, and a resource can represent a single object or a collection of objects. </span><span class="koboSpan" id="kobo.229.3">Resources like products, users, orders, and cart items are all identified by URLs. </span><span class="koboSpan" id="kobo.229.4">For example, a specific product could be accessed at </span><code class="inlineCode"><span class="koboSpan" id="kobo.230.1">www.amazon.com/products/{product_id}</span></code><span class="koboSpan" id="kobo.231.1">.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.232.1">Representation of resources</span></strong><span class="koboSpan" id="kobo.233.1">: Resources can have different representations, such as JSON, XML, HTML, etc. </span><span class="koboSpan" id="kobo.233.2">Clients interact with resources </span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.234.1">by obtaining representations of them and manipulating these representations. </span><span class="koboSpan" id="kobo.234.2">When a client holds a representation of a resource, it has enough information to modify the resource on the server. </span><span class="koboSpan" id="kobo.234.3">The same product resource might be rendered differently for a web browser than a mobile app.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.235.1">Layered system</span></strong><span class="koboSpan" id="kobo.236.1">: The architecture allows for an intermediate layer (such as a load </span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.237.1">balancer or a cache layer) to be introduced without affecting how the client interacts with the server. </span><span class="koboSpan" id="kobo.237.2">Each layer can provide a specific set of functionalities, improving the scalability and maintainability of the system. </span><span class="koboSpan" id="kobo.237.3">An e-commerce website can have various layers, like load balancers, caching layers, or authentication layers. </span><span class="koboSpan" id="kobo.237.4">The client does not need to know about these layers. </span><span class="koboSpan" id="kobo.237.5">A request to view a product might pass through a cache layer to improve response time without the client’s awareness.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.238.1">Code on demand</span></strong><span class="koboSpan" id="kobo.239.1">: Servers can provide executable code to the client to be executed </span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.240.1">in the client’s context. </span><span class="koboSpan" id="kobo.240.2">This allows for part of the application logic to be shifted to the client. </span><span class="koboSpan" id="kobo.240.3">An e-commerce website could send JavaScript code to the client’s browser to execute certain functionalities like client-side validation or enhance interactivity within the user’s browsing experience.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.241.1">The RESTful architectural style uses standard HTTP methods, and by adhering to these principles, RESTful web services aim to be simple, scalable, and maintainable. </span><span class="koboSpan" id="kobo.241.2">Many modern web APIs are developed following the RESTful principles, using standard conventions to perform CRUD operations on resources. </span><span class="koboSpan" id="kobo.241.3">Let’s learn about a reference architecture based on RESTful architecture.</span></p>
<h2 class="heading-2" id="_idParaDest-128"><span class="koboSpan" id="kobo.242.1">Building a RESTful-architecture-based e-commerce website</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.243.1">An </span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.244.1">e-commerce website such as </span><a href="http://www.amazon.com"><span class="url"><span class="koboSpan" id="kobo.245.1">www.amazon.com</span></span></a><span class="koboSpan" id="kobo.246.1"> has users worldwide and a </span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.247.1">vast catalog with millions of products. </span><span class="koboSpan" id="kobo.247.2">Each product has multiple images, reviews, and videos. </span><span class="koboSpan" id="kobo.247.3">Maintaining such an extensive catalog for a global user base is a very challenging task.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.248.1">This reference architecture in AWS follows RESTful principles. </span><span class="koboSpan" id="kobo.248.2">The services are operating as independently as possible from each other:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.249.1"><img alt="" role="presentation" src="../Images/B21336_04_03.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.250.1">Figure 4.3: RESTful architecture for an e-commerce website </span></p>
<p class="normal"><span class="koboSpan" id="kobo.251.1">As </span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.252.1">shown in the preceding architecture diagram, we can take note of the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.253.1">When a </span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.254.1">user types a website address into the browser, the user request reaches out to the DNS server to load the website. </span><span class="koboSpan" id="kobo.254.2">The DNS requests for the website are routed by Amazon Route 53 to the server where the web applications are being hosted.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.255.1">The user base is global, and users continue browsing for products to purchase as the website has an extensive product catalog with static images and videos. </span><span class="koboSpan" id="kobo.255.2">A content distribution network like Amazon CloudFront caches and delivers static assets to users.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.256.1">The catalog contents, such as static product images and videos, and other application data, such as log files, are stored in Amazon S3.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.257.1">Users will browse the website from multiple devices; for example, they will add items to a cart from their mobile and then make a payment on a desktop. </span><span class="koboSpan" id="kobo.257.2">A persistent session store, such as DynamoDB, is required to handle user sessions. </span><span class="koboSpan" id="kobo.257.3">DynamoDB is a NoSQL database where you don’t need to provide a fixed schema, so it is a great storage option for product catalogs and attributes.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.258.1">Amazon ElastiCache is used as a caching layer for the product to reduce read and </span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.259.1">write operations on the database to provide high performance and reduce latency.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.260.1">A convenient search feature is vital for product sales and business success. </span><span class="koboSpan" id="kobo.260.2">Amazon </span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.261.1">CloudSearch helps to build scalable search capability by loading the product catalog from DynamoDB. </span><span class="koboSpan" id="kobo.261.2">You can also use Amazon Kendra for an AI-powered search engine. </span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.262.1">A recommendation can encourage users to buy additional products based on browsing history and past purchases. </span><span class="koboSpan" id="kobo.262.2">A separate recommendation service can consume the log data stored on Amazon S3 and provide potential product recommendations to the user.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.263.1">The e-commerce application can also have multiple layers and components that require frequent deployment. </span><span class="koboSpan" id="kobo.263.2">AWS Elastic Beanstalk handles the auto-provisioning of the infrastructure, deploys the application, handles the load by applying auto-scaling, and monitors the application.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.264.1">You learned about RESTful architecture in this section. </span><span class="koboSpan" id="kobo.264.2">Let’s learn more about the critical aspect of cache-based architecture design.</span></p>
<h1 class="heading-1" id="_idParaDest-129"><span class="koboSpan" id="kobo.265.1">Building a cache-based architecture</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.266.1">Caching involves temporarily storing data or files in an intermediate location positioned between </span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.267.1">the requester and the permanent storage. </span><span class="koboSpan" id="kobo.267.2">This practice is aimed at speeding up future requests and minimizing network bandwidth usage. </span><span class="koboSpan" id="kobo.267.3">Caching increases application speed and lowers cost. </span><span class="koboSpan" id="kobo.267.4">It allows you to reuse previously retrieved data. </span><span class="koboSpan" id="kobo.267.5">To increase application performance, caching can be applied at various layers of the architecture, such as the web layer, application layer, data layer, and network layer.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.268.1">Typically, the server’s </span><strong class="keyWord"><span class="koboSpan" id="kobo.269.1">random-access memory</span></strong><span class="koboSpan" id="kobo.270.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.271.1">RAM</span></strong><span class="koboSpan" id="kobo.272.1">) and in-memory cache engines are utilized to support application caching. </span><span class="koboSpan" id="kobo.272.2">However, if caching is coupled to a local server, then the cache will not persist data in case of a server crash. </span><span class="koboSpan" id="kobo.272.3">Most applications are in a distributed environment, so it’s better to have a dedicated caching layer that should be independent of the application life cycle. </span><span class="koboSpan" id="kobo.272.4">If you apply horizontal scaling to your application, all servers should be able to access the centralized caching layer to achieve the best performance.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.273.1">The following </span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.274.1">diagram depicts the mechanism of caching in various layers of solution architecture:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.275.1"><img alt="" role="presentation" src="../Images/B21336_04_04.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.276.1">Figure 4.4: Caching at the architecture layers</span></p>
<p class="normal"><span class="koboSpan" id="kobo.277.1">As shown in the preceding diagram, the following are the caching mechanisms at each layer of the architecture:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.278.1">Client-side caching</span></strong><span class="koboSpan" id="kobo.279.1">: Client-side caching is applied to user devices such as mobile and desktop. </span><span class="koboSpan" id="kobo.279.2">Client-side caching caches the previously visited web content </span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.280.1">to respond faster to a subsequent request. </span><span class="koboSpan" id="kobo.280.2">Each browser has its own caching mechanism. </span><span class="koboSpan" id="kobo.280.3">HTTP caching makes the application faster by caching content in the local browser. </span><span class="koboSpan" id="kobo.280.4">The cache-control HTTP header defines browser caching policies for client requests and server responses. </span><span class="koboSpan" id="kobo.280.5">These policies define where </span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.281.1">the content should be cached and how long it will persist, known as the </span><strong class="keyWord"><span class="koboSpan" id="kobo.282.1">time to live</span></strong><span class="koboSpan" id="kobo.283.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.284.1">TTL</span></strong><span class="koboSpan" id="kobo.285.1">). </span><span class="koboSpan" id="kobo.285.2">Cookies are another method used to store information on the client’s machine to respond to the browser faster.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.286.1">Internet DNS cache</span></strong><span class="koboSpan" id="kobo.287.1">: When </span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.288.1">a user types the website </span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.289.1">address over the Internet, the </span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.290.1">public </span><strong class="keyWord"><span class="koboSpan" id="kobo.291.1">Domain Name System</span></strong><span class="koboSpan" id="kobo.292.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.293.1">DNS</span></strong><span class="koboSpan" id="kobo.294.1">) server looks up the IP address. </span><span class="koboSpan" id="kobo.294.2">Caching this DNS resolution information will reduce the website’s load time. </span><span class="koboSpan" id="kobo.294.3">DNS information can be cached to a local server or browser after the first request, and any further requests to that website will be faster.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.295.1">Web content caching</span></strong><span class="koboSpan" id="kobo.296.1">: Much of the request involves retrieving web content such </span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.297.1">as images, videos, and HTML pages. </span><span class="koboSpan" id="kobo.297.2">Caching these assets near the user’s location can provide a much faster response for a page load. </span><span class="koboSpan" id="kobo.297.3">This also eliminates disk read and </span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.298.1">server load time. </span><span class="koboSpan" id="kobo.298.2">A </span><strong class="keyWord"><span class="koboSpan" id="kobo.299.1">content distribution network</span></strong><span class="koboSpan" id="kobo.300.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.301.1">CDN</span></strong><span class="koboSpan" id="kobo.302.1">) provides a network of edge locations where static content, such as high-resolution images and videos, can be cached. </span><span class="koboSpan" id="kobo.302.2">It’s beneficial for reading heavy applications such as games, blogs, e-commerce product catalog pages, and more. </span><span class="koboSpan" id="kobo.302.3">The user session contains lots of information regarding user preference and their state. </span><span class="koboSpan" id="kobo.302.4">It provides a great user experience by storing the user’s session in its own key-value store for quick user response.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.303.1">Application caching</span></strong><span class="koboSpan" id="kobo.304.1">: At the application layer, caching can be applied to store the </span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.305.1">result of a complex repeated request to avoid business logic calculations and database hits. </span><span class="koboSpan" id="kobo.305.2">Overall, it improves application performance and reduces the load on the database and infrastructure.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.306.1">Database caching</span></strong><span class="koboSpan" id="kobo.307.1">: Application performance highly depends upon the speed and </span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.308.1">throughput provided by the database. </span><span class="koboSpan" id="kobo.308.2">Database caching increases database throughput significantly and lowers data retrieval latency. </span><span class="koboSpan" id="kobo.308.3">A database cache can be applied in front of any relational or non-relational database. </span><span class="koboSpan" id="kobo.308.4">Some database providers integrate caching, while applications handle local caching.</span></li>
</ul>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.309.1">Redis</span></strong><span class="koboSpan" id="kobo.310.1"> and </span><strong class="keyWord"><span class="koboSpan" id="kobo.311.1">Memcached</span></strong><span class="koboSpan" id="kobo.312.1"> are the </span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.313.1">most popular caching engines. </span><span class="koboSpan" id="kobo.313.2">While Memcached is </span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.314.1">faster (it is suitable for low-structure data and stores data in a key-value format), Redis is a more persistent caching engine and is capable of handling complex data structures required for an application such as a gaming leaderboard; you will learn more details in the </span><em class="italic"><span class="koboSpan" id="kobo.315.1">Memcached versus Redis</span></em><span class="koboSpan" id="kobo.316.1"> section in this chapter. </span><span class="koboSpan" id="kobo.316.2">Let’s learn about a few more caching design patterns.</span></p>
<h2 class="heading-2" id="_idParaDest-130"><span class="koboSpan" id="kobo.317.1">Cache distribution pattern in a three-tier web architecture</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.318.1">Conventional web hosting architecture follows a common three-tier web application model, which </span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.319.1">divides the architecture </span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.320.1">into presentation, application, and persistence layers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.321.1">As shown in the following AWS architecture diagram, caching is applied at the web, application, and database layers:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.322.1"><img alt="" role="presentation" src="../Images/B21336_04_05.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.323.1">Figure 4.5: Cache distribution pattern architecture</span></p>
<p class="normal"><span class="koboSpan" id="kobo.324.1">In caching patterns, your goal is to try to hit the backend as little as possible. </span><span class="koboSpan" id="kobo.324.2">You can write an application where you can cache images, JavaScript, or even full pages to provide a </span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.325.1">better experience for your </span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.326.1">users. </span><span class="koboSpan" id="kobo.326.2">In the diagram above, caching is strategically implemented across various layers of the architecture:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.327.1">Amazon Route 53 plays a role in caching DNS-to-IP mappings, simplifying domain management.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.328.1">Amazon S3 serves as the storage location for static content, including high-resolution images and videos.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.329.1">Amazon CloudFront offers edge caching for high-traffic content, utilizing cache-control headers to determine update frequency from the origin.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.330.1">Amazon DynamoDB is used for session stores, helping web applications manage user sessions through caching.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.331.1">Elastic Load Balancing evenly distributes traffic among web server Auto Scaling groups.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.332.1">Amazon ElastiCache offers caching services for the application, effectively reducing the load on the database tier.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.333.1">Typically, static content is cached, but there are scenarios where caching dynamic or unique content can improve application performance. </span><span class="koboSpan" id="kobo.333.2">The decision depends on specific usage patterns and demands.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.334.1">Let’s take a look at a more specific pattern.</span></p>
<h2 class="heading-2" id="_idParaDest-131"><span class="koboSpan" id="kobo.335.1">Rename distribution pattern</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.336.1">When using a </span><strong class="keyWord"><span class="koboSpan" id="kobo.337.1">CDN</span></strong><span class="koboSpan" id="kobo.338.1"> such as Amazon CloudFront, you store frequently used data in an edge location </span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.339.1">near the user for fast </span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.340.1">performance. </span><span class="koboSpan" id="kobo.340.2">Often, you set up the TTL in the CDN for your data, which means the edge location will not query back to the server for updated data until the TTL expires. </span><span class="koboSpan" id="kobo.340.3">TTL is when an object is stored in a caching system before it’s deleted or refreshed. </span><span class="koboSpan" id="kobo.340.4">You may have situations where you need to update CDN cached content immediately, for example, if you need to correct the wrong product description.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.341.1">You can’t wait for the file’s TTL to expire in such a situation. </span><span class="koboSpan" id="kobo.341.2">The rename distribution pattern helps you update the cache as soon as new changes are published so the user can get updated information immediately. </span><span class="koboSpan" id="kobo.341.3">The following diagram shows this pattern with AWS:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.342.1"><img alt="" role="presentation" src="../Images/B21336_04_06.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.343.1">Figure 4.6: Rename distribution pattern architecture</span></p>
<p class="normal"><span class="koboSpan" id="kobo.344.1">As shown in the preceding diagram, using the rename distribution pattern with the cache distribution pattern helps to solve the update issue. </span><span class="koboSpan" id="kobo.344.2">With this pattern, instead of overwriting </span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.345.1">the file in the origin server and waiting for the TTL in CloudFront to expire, the server uploads the updated file </span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.346.1">with a new filename and then updates the web page with the new URL. </span><span class="koboSpan" id="kobo.346.2">When the user requests original content, CloudFront has to fetch it from the origin and can’t serve the obsolete file that’s already cached.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.347.1">However, you can invalidate the old file immediately, but that will cost more, so it’s better to put a new version of the file for the CDN to pick immediately. </span><span class="koboSpan" id="kobo.347.2">Again, you must update the URL in the application to pick up a new file, adding some overhead compared to the invalidation option. </span><span class="koboSpan" id="kobo.347.3">It would be best to decide based on your business requirements and budget.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.348.1">You can use the proxy cache server to use something other than a CDN for a user base distributed across the country. </span><span class="koboSpan" id="kobo.348.2">Let’s learn more about it in the next section.</span></p>
<h2 class="heading-2" id="_idParaDest-132"><span class="koboSpan" id="kobo.349.1">Cache proxy pattern</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.350.1">You can increase your application performance significantly by adding a cache layer. </span><span class="koboSpan" id="kobo.350.2">In a cache </span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.351.1">proxy pattern, static or dynamic </span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.352.1">content is cached upstream of the web app server. </span><span class="koboSpan" id="kobo.352.2">As shown in the following architectural diagram, you have a caching layer in front of the web application cluster:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.353.1"><img alt="" role="presentation" src="../Images/B21336_04_07.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.354.1">Figure 4.7: Cache proxy pattern architecture</span></p>
<p class="normal"><span class="koboSpan" id="kobo.355.1">In the </span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.356.1">preceding diagram, for high-performance delivery, cache content </span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.357.1">is delivered by the cache server. </span><span class="koboSpan" id="kobo.357.2">A few </span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.358.1">benefits of cache proxy patterns are as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.359.1">Cache proxy patterns help you to deliver content using the cache, which means no modification is needed at the web server or application server level.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.360.1">They reduce the load of content generation for dynamic content.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.361.1">You can set up a cache at the browser level, such as in HTTP headers, URLs, cookies, and more. </span><span class="koboSpan" id="kobo.361.2">Alternatively, you can cache information in the cache layer if you don’t want to store it at the browser level.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.362.1">In the cache proxy pattern, you must maintain multiple copies of the cache to avoid a single point of failure. </span><span class="koboSpan" id="kobo.362.2">Sometimes, you may want to serve your static content from both the server and CDN, each requiring a different approach. </span><span class="koboSpan" id="kobo.362.3">Let’s dive deep into this hybrid situation in the next section.</span></p>
<h2 class="heading-2" id="_idParaDest-133"><span class="koboSpan" id="kobo.363.1">Rewrite proxy pattern</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.364.1">Sometimes, you want to change the access destinations of static website content, such as images </span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.365.1">and videos, but you don’t want to change the existing systems. </span><span class="koboSpan" id="kobo.365.2">You can achieve this by providing a proxy server using rewrite proxy patterns. </span><span class="koboSpan" id="kobo.365.3">To change </span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.366.1">the destination of static content to other storage, such as a content service or internet storage, you can use a proxy server in front of the web server fleet. </span><span class="koboSpan" id="kobo.366.2">As shown in the following architecture diagram, you have a proxy server in front of your application layer, which helps to change the content delivery destination without modifying the actual application:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.367.1"><img alt="A picture containing text, screenshot, diagram, line  Description automatically generated" src="../Images/B21336_04_08.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.368.1">Figure 4.8: Rewrite proxy pattern architecture</span></p>
<p class="normal"><span class="koboSpan" id="kobo.369.1">As shown in the preceding diagram, place the proxy server in front of the currently running system </span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.370.1">to rewrite the </span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.371.1">proxy pattern. </span><span class="koboSpan" id="kobo.371.2">You can construct a proxy server using software such as </span><strong class="keyWord"><span class="koboSpan" id="kobo.372.1">Apache</span></strong><span class="koboSpan" id="kobo.373.1"> or </span><strong class="keyWord"><span class="koboSpan" id="kobo.374.1">NGINX</span></strong><span class="koboSpan" id="kobo.375.1">. </span><span class="koboSpan" id="kobo.375.2">The following are the steps to build a rewrite proxy pattern, using AWS as the example:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.376.1">Put a running proxy server on an EC2 instance, which can overwrite the content between the </span><strong class="keyWord"><span class="koboSpan" id="kobo.377.1">load balancer</span></strong><span class="koboSpan" id="kobo.378.1"> and the storage service, such as </span><strong class="keyWord"><span class="koboSpan" id="kobo.379.1">Amazon S3</span></strong><span class="koboSpan" id="kobo.380.1">, which stores the static content.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.381.1">Add to the </span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.382.1">proxy server rules for overwriting URLs within the content. </span><span class="koboSpan" id="kobo.382.2">These rules will help </span><strong class="keyWord"><span class="koboSpan" id="kobo.383.1">Elastic Load Balancing</span></strong><span class="koboSpan" id="kobo.384.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.385.1">ELB</span></strong><span class="koboSpan" id="kobo.386.1">) to point to a new location, as shown in the preceding diagram, which redirects the proxy server rule from </span><code class="inlineCode"><span class="koboSpan" id="kobo.387.1">https://cdn/test.jpg to /test.jpg</span></code><span class="koboSpan" id="kobo.388.1">. </span><span class="koboSpan" id="kobo.388.2">ELB is a service provided by AWS that automatically distributes incoming application traffic across multiple targets, such as Amazon EC2 servers, containers, and IP addresses.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.389.1">As required, apply auto-scaling to the proxy servers by configuring minimum and maximum proxy server amounts as per the application load.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.390.1">In this building a </span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.391.1">cache-based architecture section, you learned </span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.392.1">how to handle caching for static content distribution over the network. </span><span class="koboSpan" id="kobo.392.2">However, caching at the application layer is very important for improving application performance for the overall user experience. </span><span class="koboSpan" id="kobo.392.3">Let’s learn more about the app caching pattern to handle the dynamic user data delivery performance.</span></p>
<h2 class="heading-2" id="_idParaDest-134"><span class="koboSpan" id="kobo.393.1">App caching pattern</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.394.1">When it comes to applying caching to applications, you want to add a cache engine layer between </span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.395.1">your application servers and the database. </span><span class="koboSpan" id="kobo.395.2">The app caching pattern allows you to reduce the load on the database as the </span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.396.1">most frequent query is served from the caching layer. </span><span class="koboSpan" id="kobo.396.2">The </span><em class="italic"><span class="koboSpan" id="kobo.397.1">app caching pattern</span></em><span class="koboSpan" id="kobo.398.1"> improves overall application and database performance. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.399.1">As shown in the following diagram, you can see the caching layer applied between the application layer and the database layer in AWS:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.400.1"><img alt="A picture containing text, screenshot, diagram, number  Description automatically generated" src="../Images/B21336_04_09.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.401.1">Figure 4.9: App caching pattern architecture</span></p>
<p class="normal"><span class="koboSpan" id="kobo.402.1">As shown in the preceding diagram, you can use either </span><strong class="keyWord"><span class="koboSpan" id="kobo.403.1">lazy caching</span></strong><span class="koboSpan" id="kobo.404.1"> or </span><strong class="keyWord"><span class="koboSpan" id="kobo.405.1">write-through</span></strong><span class="koboSpan" id="kobo.406.1"> based on your data access pattern. </span><span class="koboSpan" id="kobo.406.2">In lazy caching, the cache engine checks whether the data is in the </span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.407.1">cache and, if not, gets it from the database and keeps it in </span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.408.1">the cache to serve future requests. </span><span class="koboSpan" id="kobo.408.2">Lazy </span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.409.1">caching is also called the </span><strong class="keyWord"><span class="koboSpan" id="kobo.410.1">cache aside pattern</span></strong><span class="koboSpan" id="kobo.411.1">. </span><span class="koboSpan" id="kobo.411.2">In the </span><strong class="keyWord"><span class="koboSpan" id="kobo.412.1">write-through</span></strong><span class="koboSpan" id="kobo.413.1"> method, data is written in the cache and in the data store at the same time. </span><span class="koboSpan" id="kobo.413.2">If the data gets lost from the cache, it can get it again from the database.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.414.1">Choose lazy caching when you have a read-heavy application with acceptable stale data and choose write-through caching when dealing with write-heavy operations requiring immediate data consistency. </span><span class="koboSpan" id="kobo.414.2">For example, you can use lazy caching in a product catalog in an e-commerce website where product details are read frequently but updated less often. </span><span class="koboSpan" id="kobo.414.3">When a user accesses a product detail that is not in the cache, it’s fetched from the database and stored in the cache for subsequent access, reducing database load. </span><span class="koboSpan" id="kobo.414.4">You might want to use write-through for a user review section on an e-commerce website, where user-generated reviews are instantly displayed on the product page. </span><span class="koboSpan" id="kobo.414.5">When a user submits a review, it’s written to both the cache and the database simultaneously, ensuring that any subsequent read requests fetch the most current data.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.415.1">Let’s learn more about the popular caching engines </span><em class="italic"><span class="koboSpan" id="kobo.416.1">Redis</span></em><span class="koboSpan" id="kobo.417.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.418.1">Memcached</span></em><span class="koboSpan" id="kobo.419.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-135"><span class="koboSpan" id="kobo.420.1">Memcached versus Redis</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.421.1">Redis and Memcached are two popular caching engines used in application design. </span><span class="koboSpan" id="kobo.421.2">The Redis cache </span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.422.1">engine is often required for more complex </span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.423.1">application caching needs, such as creating a </span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.424.1">leaderboard for a game. </span><span class="koboSpan" id="kobo.424.2">However, Memcached is </span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.425.1">more high-performing and helps handle heavy application loads. </span><span class="koboSpan" id="kobo.425.2">Each caching engine has its pros and cons. </span><span class="koboSpan" id="kobo.425.3">Let’s take a look at the significant differences between them, which will help you to make a decision about which to use:</span></p>
<table class="table-container" id="table001-1">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.426.1">Memcached</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.427.1">Redis</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.428.1">Offers multithreading</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.429.1">Single-threaded</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.430.1">Able to use more CPU cores for faster processing</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.431.1">Unable to utilize multi-core processor, which results in comparatively slow performance</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.432.1">Supports key-value style data</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.433.1">Supports complex and advanced data structures</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.434.1">Lacks data persistence; loses the data stored in cache memory in the event of a crash</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.435.1">Data can persist using built-in read replicas with failover</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.436.1">Easy maintenance</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.437.1">More complexity is involved owing to the need to maintain the cluster</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.438.1">Good to cache flat strings such as flat HTML pages, serialized JSON, and more</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.439.1">Good to create a cache for a gaming leaderboard, a live voting app, and more</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.440.1">Table 4.1 – Memcached versus Redis comparison</span></p>
<p class="normal"><span class="koboSpan" id="kobo.441.1">If you need to decide which engine to use, base it on a use case that can justify using Redis or Memcached. </span><span class="koboSpan" id="kobo.441.2">Memcached is simple and has lower maintenance, and it is typically preferred when your cache doesn’t need the advanced features that Redis offers. </span><span class="koboSpan" id="kobo.441.3">However, Redis is the best solution if you need the advantage of data persistence, advanced data types, or any of the other features listed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.442.1">When implementing caching, it’s essential to understand the validity of data that needs to be cached. </span><span class="koboSpan" id="kobo.442.2">If the </span><strong class="keyWord"><span class="koboSpan" id="kobo.443.1">cache hit</span></strong><span class="koboSpan" id="kobo.444.1"> rate is </span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.445.1">high, the data is available in the cache when required. </span><span class="koboSpan" id="kobo.445.2">For a higher cache hit ratio, offload the database by reducing direct queries, improving </span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.446.1">the overall application performance. </span><span class="koboSpan" id="kobo.446.2">A </span><strong class="keyWord"><span class="koboSpan" id="kobo.447.1">cache miss</span></strong><span class="koboSpan" id="kobo.448.1"> occurs </span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.449.1">when data is not present in the cache, which increases </span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.450.1">the load in the database. </span><span class="koboSpan" id="kobo.450.2">The cache is not a large </span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.451.1">data store, so you need to set the TTL and evict the </span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.452.1">cache as per your application needs.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.453.1">As you have seen in this section, applying caches has multiple benefits, including application performance improvement, the ability to provide predictable performance, and the reduction in database cost.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.454.1">Let’s learn about some more application-based architecture that demonstrates the principle of loose coupling and constraint handling, MVC architecture.</span></p>
<h1 class="heading-1" id="_idParaDest-136"><span class="koboSpan" id="kobo.455.1">Model-View-Controller (MVC) architecture</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.456.1">MVC is one of the most popular design patterns for developing software applications. </span><span class="koboSpan" id="kobo.456.2">It separates </span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.457.1">an application into three interconnected components: Model, View, and Controller. </span><span class="koboSpan" id="kobo.457.2">This separation enables more modular development, easier testing, and excellent maintainability. </span><span class="koboSpan" id="kobo.457.3">Let’s explore these components in detail:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.458.1">Model</span></strong><span class="koboSpan" id="kobo.459.1">: The Model </span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.460.1">represents the internal state of the application, along with the rules, logic, and data that govern and manipulate that state. </span><span class="koboSpan" id="kobo.460.2">The model does not depend on the View or Controller, meaning changes to the UI or business logic do not affect the data handling. </span><span class="koboSpan" id="kobo.460.3">It ensures that the application’s data remains consistent across different parts of the </span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.461.1">application. </span><span class="koboSpan" id="kobo.461.2">Its responsibilities include:</span><ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.462.1">Managing data</span></strong><span class="koboSpan" id="kobo.463.1">: It contains all the data-related logic. </span><span class="koboSpan" id="kobo.463.2">Whether it’s retrieving data from a database or an API, the model handles it.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.464.1">Implementing business rules</span></strong><span class="koboSpan" id="kobo.465.1">: Implements business logic, such as calculations or data transformations.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.466.1">Notifying of changes</span></strong><span class="koboSpan" id="kobo.467.1">: Informs associated Views and Controllers when the data has changed so they can update themselves accordingly.</span></li>
</ul>
</li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.468.1">View</span></strong><span class="koboSpan" id="kobo.469.1">: The View </span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.470.1">is the visual representation of the Model’s data. </span><span class="koboSpan" id="kobo.470.2">It defines exactly how the application’s data is presented to the user. </span><span class="koboSpan" id="kobo.470.3">The View automatically updates when the underlying Model data changes, ensuring the user always sees the most current data. </span><span class="koboSpan" id="kobo.470.4">Multiple Views can be created from the same Model data, allowing different representations (e.g., tables, charts, detailed views). </span><span class="koboSpan" id="kobo.470.5">Its </span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.471.1">responsibilities include:</span><ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.472.1">Displaying data</span></strong><span class="koboSpan" id="kobo.473.1">: Takes the data from the model and presents it in a format that’s easy to understand.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.474.1">Handling the user interface</span></strong><span class="koboSpan" id="kobo.475.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.476.1">UI</span></strong><span class="koboSpan" id="kobo.477.1">): Handles all the UI logic of the application, such as user input fields, buttons, display screens, etc.</span></li>
</ul>
</li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.478.1">Controller</span></strong><span class="koboSpan" id="kobo.479.1">: The Controller </span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.480.1">mediates between the Model and the View. </span><span class="koboSpan" id="kobo.480.2">It takes user inputs from the View, processes them (with potential updates to the Model), and returns the output display to the View. </span><span class="koboSpan" id="kobo.480.3">The controller ensures that the View and the Model are always in sync with each other. </span><span class="koboSpan" id="kobo.480.4">It acts as a centralized handler for all user interactions, making the management </span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.481.1">of those interactions more systematic and organized. </span><span class="koboSpan" id="kobo.481.2">Its responsibilities include:</span><ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.482.1">Handling user input</span></strong><span class="koboSpan" id="kobo.483.1">: Takes and interprets user commands, translating them into actions to be performed by the model</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.484.1">Updating the Model</span></strong><span class="koboSpan" id="kobo.485.1">: Modifies the data in the Model by sending commands to it</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.486.1">Updating the View</span></strong><span class="koboSpan" id="kobo.487.1">: Changes what is presented in the View based on user input and Model changes</span></li>
</ul>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.488.1">The </span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.489.1">following are the key advantages of applying the MVC pattern:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.490.1">Separation of concerns</span></strong><span class="koboSpan" id="kobo.491.1">: By isolating the application’s data, user interface, and control logic, MVC promotes modular development.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.492.1">Reusability</span></strong><span class="koboSpan" id="kobo.493.1">: Components can be reused across different parts of an application or even different applications.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.494.1">Maintainability</span></strong><span class="koboSpan" id="kobo.495.1">: It makes updating, testing, and debugging different parts of the application easier.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.496.1">Flexibility</span></strong><span class="koboSpan" id="kobo.497.1">: Enables developers to change one part of the system without affecting others, such as changing the UI without altering the underlying data processing.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.498.1">MVC is a </span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.499.1">powerful architectural pattern that offers robust data management, user interface, and business logic management. </span><span class="koboSpan" id="kobo.499.2">It’s widely used in various application development environments, from web development frameworks to desktop applications, to create scalable and maintainable software. </span><span class="koboSpan" id="kobo.499.3">By following the principles of MVC, application architects can create organized, efficient, and flexible applications that are easier to update and maintain. </span><span class="koboSpan" id="kobo.499.4">Let’s consider an example to understand MVC better.</span></p>
<h2 class="heading-2" id="_idParaDest-137"><span class="koboSpan" id="kobo.500.1">Applying MVC to design an online bookstore </span></h2>
<p class="normal"><span class="koboSpan" id="kobo.501.1">When designing an online bookstore, for example, the MVC architecture efficiently handles </span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.502.1">complex interactions between book data, user interface, and user inputs, leading </span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.503.1">to a more robust and scalable system. </span><span class="koboSpan" id="kobo.503.2">Let’s look at the details of each module:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.504.1">Model</span></strong><span class="koboSpan" id="kobo.505.1">: Managing the data related to books, authors, categories, customer reviews, etc. </span><span class="koboSpan" id="kobo.505.2">Examples of operations are:</span><ul>
<li class="bulletList"><span class="koboSpan" id="kobo.506.1">Retrieving details of a specific book</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.507.1">Updating the inventory after a purchase</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.508.1">Adding a new book to the catalog</span></li>
</ul>
</li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.509.1">View</span></strong><span class="koboSpan" id="kobo.510.1">: Displaying information to the user in a readable and interactive format. </span><span class="koboSpan" id="kobo.510.2">Examples of Views are:</span><ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.511.1">Book listing page</span></strong><span class="koboSpan" id="kobo.512.1">: Displays a list of books with their titles, covers, and prices</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.513.1">Book detail page</span></strong><span class="koboSpan" id="kobo.514.1">: Shows detailed information about a specific book, including author, description, reviews, etc.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.515.1">Shopping cart page</span></strong><span class="koboSpan" id="kobo.516.1">: Allows users to view, add, or remove items from their shopping cart</span></li>
</ul>
</li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.517.1">Controller</span></strong><span class="koboSpan" id="kobo.518.1">: Handling user interaction, updating the model as needed, and updating the View to reflect changes. </span><span class="koboSpan" id="kobo.518.2">Examples of actions are:</span><ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.519.1">Searching for a book</span></strong><span class="koboSpan" id="kobo.520.1">: The user enters a search term. </span><span class="koboSpan" id="kobo.520.2">The Controller queries the model for matching books and updates the View to display the results.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.521.1">Adding to cart</span></strong><span class="koboSpan" id="kobo.522.1">: The user clicks </span><strong class="screenText"><span class="koboSpan" id="kobo.523.1">Add to Cart</span></strong><span class="koboSpan" id="kobo.524.1">, the Controller updates the model to reflect the new item in the cart, and the View is updated to show the new cart status.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.525.1">Checkout</span></strong><span class="koboSpan" id="kobo.526.1">: The user decides to purchase. </span><span class="koboSpan" id="kobo.526.2">The Controller processes the transaction, updates the model (including inventory), and redirects to a confirmation View.</span></li>
</ul>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.527.1">The MVC </span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.528.1">pattern provides a clean separation of concerns, making extending, maintaining, and testing </span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.529.1">applications easier.</span></p>
<h1 class="heading-1" id="_idParaDest-138"><span class="koboSpan" id="kobo.530.1">Building Domain-Driven Design (DDD)</span></h1>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.531.1">Domain-Driven Design</span></strong><span class="koboSpan" id="kobo.532.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.533.1">DDD</span></strong><span class="koboSpan" id="kobo.534.1">) is a methodology and set of practices aimed at understanding </span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.535.1">and solving complexity at the heart of software. </span><span class="koboSpan" id="kobo.535.2">This approach is used to design and model software based on the “domain,” or the business’s core logic and key concepts. </span><span class="koboSpan" id="kobo.535.3">Using a common language and dividing the system into clear contexts, DDD promotes a deep understanding of the problem space and leads to a design that accurately reflects the underlying business needs. </span><span class="koboSpan" id="kobo.535.4">It’s particularly valuable in complex domains, where aligning the software closely with the real-world concepts it represents is vital.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.536.1">Let’s delve into DDD using a concrete example and use case. </span><span class="koboSpan" id="kobo.536.2">For this, we’ll consider the domain of a </span><strong class="keyWord"><span class="koboSpan" id="kobo.537.1">Healthcare Management System</span></strong><span class="koboSpan" id="kobo.538.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.539.1">HMS</span></strong><span class="koboSpan" id="kobo.540.1">). </span><span class="koboSpan" id="kobo.540.2">Imagine we’re developing a system that manages patient records, appointments, medical treatments, billing, etc. </span><span class="koboSpan" id="kobo.540.3">for a healthcare provider. </span><span class="koboSpan" id="kobo.540.4">Here’s how we could apply DDD concepts to this domain:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.541.1">Domain</span></strong><span class="koboSpan" id="kobo.542.1">: A “domain” refers to a specific problem area the software intends to address. </span><span class="koboSpan" id="kobo.542.2">The </span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.543.1">application logic revolves around the sphere of knowledge and activity. </span><span class="koboSpan" id="kobo.543.2">Understanding the domain is essential for creating a system that truly meets the needs of the business. </span><span class="koboSpan" id="kobo.543.3">For HMS, the domain will be</span><strong class="keyWord"> </strong><span class="koboSpan" id="kobo.544.1">healthcare management, focusing on patients, medical staff, appointments, treatments, and billing.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.545.1">Ubiquitous Language</span></strong><span class="koboSpan" id="kobo.546.1">: Ubiquitous Language is a shared language between developers </span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.547.1">and non-technical stakeholders that describes the domain. </span><span class="koboSpan" id="kobo.547.2">This common language ensures that all team members understand the key terms and concepts in the same way, reducing misunderstandings and promoting clear communication for the HMS, creating a shared language that both medical professionals and developers understand, for example, </span><strong class="keyWord"><span class="koboSpan" id="kobo.548.1">Patient</span></strong><span class="koboSpan" id="kobo.549.1">, </span><strong class="keyWord"><span class="koboSpan" id="kobo.550.1">Appointment</span></strong><span class="koboSpan" id="kobo.551.1">, </span><strong class="keyWord"><span class="koboSpan" id="kobo.552.1">Treatment</span></strong><span class="koboSpan" id="kobo.553.1">, </span><strong class="keyWord"><span class="koboSpan" id="kobo.554.1">Medical Staff</span></strong><span class="koboSpan" id="kobo.555.1">, etc.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.556.1">Bounded contexts</span></strong><span class="koboSpan" id="kobo.557.1">: In DDD, the application is divided into different bounded </span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.558.1">contexts, each representing a specific responsibility or functionality within the overall domain. </span><span class="koboSpan" id="kobo.558.2">A bounded context encapsulates all the terms, definitions, and logic for that specific part of the domain, and it is explicit about what is inside and outside its boundaries. </span><span class="koboSpan" id="kobo.558.3">For example, the </span><strong class="keyWord"><span class="koboSpan" id="kobo.559.1">Patient Management</span></strong><span class="koboSpan" id="kobo.560.1"> bounded context handles patient records, personal information, medical history, etc. </span><span class="koboSpan" id="kobo.560.2">An </span><strong class="keyWord"><span class="koboSpan" id="kobo.561.1">Appointment Scheduling</span></strong><span class="koboSpan" id="kobo.562.1"> bounded context includes managing appointments, scheduling, cancellations, rescheduling, etc., and the </span><strong class="keyWord"><span class="koboSpan" id="kobo.563.1">Billing</span></strong><span class="koboSpan" id="kobo.564.1"> bounded context includes processing payments, insurance, invoices, etc.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.565.1">Entities</span></strong><span class="koboSpan" id="kobo.566.1">: These </span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.567.1">objects have a distinct identity that runs through time and different states, for example, patients (with a unique ID) and medical staff (with unique credentials).</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.568.1">Value objects</span></strong><span class="koboSpan" id="kobo.569.1">: Objects </span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.570.1">that describe characteristics of a thing but have no conceptual identity. </span><span class="koboSpan" id="kobo.570.2">They are immutable and can be easily replaced. </span><span class="koboSpan" id="kobo.570.3">For example, </span><strong class="keyWord"><span class="koboSpan" id="kobo.571.1">Address</span></strong><span class="koboSpan" id="kobo.572.1">, </span><strong class="keyWord"><span class="koboSpan" id="kobo.573.1">Date of Birth</span></strong><span class="koboSpan" id="kobo.574.1">, and </span><strong class="keyWord"><span class="koboSpan" id="kobo.575.1">Medical History</span></strong><span class="koboSpan" id="kobo.576.1"> (as these don’t have individual identities).</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.577.1">Aggregates</span></strong><span class="koboSpan" id="kobo.578.1">: An </span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.579.1">aggregate is a cluster of associated objects treated as a single unit for data changes. </span><span class="koboSpan" id="kobo.579.2">One entity within the aggregate is the root, and external references are restricted to this root to ensure integrity. </span><span class="koboSpan" id="kobo.579.3">For example, in an online healthcare management system, a medical appointment can be modeled as an aggregate. </span><span class="koboSpan" id="kobo.579.4">The aggregate might include entities and value objects like </span><strong class="keyWord"><span class="koboSpan" id="kobo.580.1">Patient</span></strong><span class="koboSpan" id="kobo.581.1"> (who the appointment is for), </span><strong class="keyWord"><span class="koboSpan" id="kobo.582.1">Medical Staff</span></strong><span class="koboSpan" id="kobo.583.1"> (who will attend the patient), </span><strong class="keyWord"><span class="koboSpan" id="kobo.584.1">Treatment Room</span></strong><span class="koboSpan" id="kobo.585.1"> (where the appointment will take place), and </span><strong class="keyWord"><span class="koboSpan" id="kobo.586.1">Time Slot</span></strong><span class="koboSpan" id="kobo.587.1"> (when the appointment is scheduled). </span><span class="koboSpan" id="kobo.587.2">Here, the </span><strong class="keyWord"><span class="koboSpan" id="kobo.588.1">Appointment</span></strong><span class="koboSpan" id="kobo.589.1"> entity would be the aggregate root. </span><span class="koboSpan" id="kobo.589.2">Any changes to the </span><strong class="keyWord"><span class="koboSpan" id="kobo.590.1">Patient</span></strong><span class="koboSpan" id="kobo.591.1">, </span><strong class="keyWord"><span class="koboSpan" id="kobo.592.1">Medical Staff</span></strong><span class="koboSpan" id="kobo.593.1">,</span><strong class="keyWord"><span class="koboSpan" id="kobo.594.1"> Treatment Room</span></strong><span class="koboSpan" id="kobo.595.1">, or </span><strong class="keyWord"><span class="koboSpan" id="kobo.596.1">Time Slot</span></strong><span class="koboSpan" id="kobo.597.1"> related to a specific appointment would be </span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.598.1">made through the Appointment entity. </span><span class="koboSpan" id="kobo.598.2">This ensures that the appointment aggregate maintains consistency and enforces all business rules related to medical appointments.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.599.1">Repositories</span></strong><span class="koboSpan" id="kobo.600.1">: Repositories are used to retrieve aggregates from the underlying </span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.601.1">persistence layer. </span><span class="koboSpan" id="kobo.601.2">They provide an abstraction allowing the rest of the application to interact with the data store in a way consistent with the domain model. </span><span class="koboSpan" id="kobo.601.3">For example, the </span><strong class="keyWord"><span class="koboSpan" id="kobo.602.1">Patient</span></strong><span class="koboSpan" id="kobo.603.1"> repository is used to fetch and manage Patient entities, and the Appointment repository is used to retrieve and store Appointment aggregates.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.604.1">Factories</span></strong><span class="koboSpan" id="kobo.605.1">: Factories are responsible for encapsulating the logic of creating complex </span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.606.1">objects and aggregates. </span><span class="koboSpan" id="kobo.606.2">They ensure that an object or aggregate is created in a consistent and valid state. </span><span class="koboSpan" id="kobo.606.3">For example, the </span><strong class="keyWord"><span class="koboSpan" id="kobo.607.1">Patient</span></strong><span class="koboSpan" id="kobo.608.1"> factory is used to create a new </span><strong class="keyWord"><span class="koboSpan" id="kobo.609.1">Patient</span></strong><span class="koboSpan" id="kobo.610.1"> entity with a valid initial state, and the </span><strong class="keyWord"><span class="koboSpan" id="kobo.611.1">Appointment</span></strong><span class="koboSpan" id="kobo.612.1"> factory is used to create a new </span><strong class="keyWord"><span class="koboSpan" id="kobo.613.1">Appointment</span></strong><span class="koboSpan" id="kobo.614.1"> aggregate with the required details.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.615.1">Services</span></strong><span class="koboSpan" id="kobo.616.1">: When an operation doesn’t logically belong to a value object or entity, it can </span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.617.1">be defined as a service. </span><span class="koboSpan" id="kobo.617.2">Services are part of the domain model and contain business logic that operates on the domain’s concepts. </span><span class="koboSpan" id="kobo.617.3">For example, in the </span><strong class="keyWord"><span class="koboSpan" id="kobo.618.1">Billing</span></strong><span class="koboSpan" id="kobo.619.1"> context, the billing service contains operations like calculating total charges, applying insurance discounts, generating invoices, etc.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.620.1">Domain events</span></strong><span class="koboSpan" id="kobo.621.1">: Domain events capture the fact that something significant has happened </span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.622.1">within the domain. </span><span class="koboSpan" id="kobo.622.2">They can trigger other activities within the system or in other systems. </span><span class="koboSpan" id="kobo.622.3">For example, an appointment scheduled event triggered when a new appointment is scheduled may notify relevant staff members and a payment processed event occurs after successful payment, which might initiate a receipt generation process.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.623.1">Anti-corruption layer</span></strong><span class="koboSpan" id="kobo.624.1">: This layer translates between different parts of the system </span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.625.1">that use different languages or models. </span><span class="koboSpan" id="kobo.625.2">It ensures that each model’s integrity is maintained, and inconsistencies are handled.</span><strong class="keyWord"> </strong><span class="koboSpan" id="kobo.626.1">If the Billing system must interact with an external third-party payment gateway, an anti-corruption layer could translate between the domain model in the Billing context and the model used by the external system.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.627.1">In this HMS, DDD ensures that complex domain logic is carefully modeled and organized. </span><span class="koboSpan" id="kobo.627.2">It encourages collaboration between healthcare professionals (domain experts) and developers to create a shared understanding and language.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.628.1">The system’s design closely aligns with real-world healthcare operations by defining clear bounded contexts, entities, aggregates, and other DDD concepts. </span><span class="koboSpan" id="kobo.628.2">This alignment ensures </span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.629.1">that the software provides a robust and flexible solution tailored to the specific needs of the healthcare domain.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.630.1">This example shows how DDD can be an essential tool in crafting complex, well-structured systems by focusing on the core domain and facilitating collaboration between different stakeholders.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.631.1">Dependency handling is an important aspect when working in complex systems. </span><span class="koboSpan" id="kobo.631.2">Let’s learn about how to handle dependency between different services via a circuit breaker to make sure an error in one service does not bring the entire system down.</span></p>
<h1 class="heading-1" id="_idParaDest-139"><span class="koboSpan" id="kobo.632.1">Understanding the circuit breaker pattern</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.633.1">It’s common for a distributed system to make a call to other downstream services, and the call could fail or hang without a response. </span><span class="koboSpan" id="kobo.633.2">You will often see code that retries the failed call </span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.634.1">several times. </span><span class="koboSpan" id="kobo.634.2">The problem with a remote service is that it could take minutes or even hours to correct, and an immediate retry might end up in another failure. </span><span class="koboSpan" id="kobo.634.3">As a result, end users wait longer to get an error response while your code retries several times. </span><span class="koboSpan" id="kobo.634.4">This retry function would consume the threads and potentially induce a cascading failure.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.635.1">The circuit breaker pattern is about understanding the health of downstream dependencies. </span><span class="koboSpan" id="kobo.635.2">It detects when those dependencies are unhealthy and implements logic to gracefully fail requests until it detects that they are healthy again. </span><span class="koboSpan" id="kobo.635.3">The circuit breaker can be implemented using a persistence layer to monitor healthy and unhealthy requests over the past request interval.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.636.1">If a defined percentage of requests observe an unhealthy behavior over the past interval or a total count of exceptions, regardless of percentage, the circuit is marked as open. </span><span class="koboSpan" id="kobo.636.2">In such a situation, all requests throw exceptions rather than integrate with the dependency for a defined timeout period. </span><span class="koboSpan" id="kobo.636.3">Once the timeout period has subsided, a small percentage of requests try integrating with the downstream dependency to detect when the health has returned. </span><span class="koboSpan" id="kobo.636.4">Once a sufficient percentage of requests are healthy again over an interval, or no errors are observed, the circuit closes again, and all the requests are </span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.637.1">allowed to thoroughly integrate as they usually would.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.638.1">The implementation decisions involve the state machine tracking/sharing the healthy/unhealthy request counts. </span><span class="koboSpan" id="kobo.638.2">The states of services can be maintained in DynamoDB, Redis/Memcached, or another low-latency persistence store. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.639.1">Let’s next turn to the bulkhead architectural pattern, which helps to reduce dependency between services and mitigate the situation in the case of a service getting an error. </span></p>
<h1 class="heading-1" id="_idParaDest-140"><span class="koboSpan" id="kobo.640.1">Implementing the bulkhead pattern</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.641.1">Bulkheads are structural partitions used in ships to create individual watertight sections. </span><span class="koboSpan" id="kobo.641.2">The primary </span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.642.1">purpose is to contain the consequences of any breach in the ship’s hull, thereby preventing water from spreading throughout the vessel in the event of damage. </span><span class="koboSpan" id="kobo.642.2">This design serves as a crucial safety measure, aiming to minimize the risk of the entire ship sinking if one area is compromised.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.643.1">The same concept is helpful to limit the scope of failure in the architecture of large systems where you want to partition your system to decouple dependencies between services. </span><span class="koboSpan" id="kobo.643.2">The idea is that one failure should not cause the entire system to fail, as shown in the following diagram:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.644.1"><img alt="A picture containing screenshot, rectangle, text  Description automatically generated" src="../Images/B21336_04_10.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.645.1">Figure 4.10: Bulkhead pattern</span></p>
<p class="normal"><span class="koboSpan" id="kobo.646.1">In the bulkhead pattern, it’s better to isolate the element of the application into the pool for service, which has a high dependency; so, if one fails, others continue to serve upstream services. </span><strong class="screenText"><span class="koboSpan" id="kobo.647.1">Service 3</span></strong><span class="koboSpan" id="kobo.648.1"> is partitioned into two pools from a single service in the preceding diagram. </span><span class="koboSpan" id="kobo.648.2">Here, if </span><strong class="screenText"><span class="koboSpan" id="kobo.649.1">Service 3</span></strong><span class="koboSpan" id="kobo.650.1"> fails, then the impact of either </span><strong class="screenText"><span class="koboSpan" id="kobo.651.1">Service 1</span></strong><span class="koboSpan" id="kobo.652.1"> or </span><strong class="screenText"><span class="koboSpan" id="kobo.653.1">Service 2</span></strong><span class="koboSpan" id="kobo.654.1"> depends on their dependency on the pool, but the entire system does not go down. </span><span class="koboSpan" id="kobo.654.2">The following </span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.655.1">are the significant points to consider when introducing the bulkhead pattern in your design, especially for the shared service model:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.656.1">Save part of the ship, which means your application should not shut down due to the failure of one service.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.657.1">Decide whether less efficient use of resources is okay. </span><span class="koboSpan" id="kobo.657.2">Performance issues in one partition should be fine for the overall application.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.658.1">Pick a useful granularity. </span><span class="koboSpan" id="kobo.658.2">Make sure to make the service pools manageable; make sure they can handle the application load.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.659.1">Monitor each service partition performance and adhere to the SLA. </span><span class="koboSpan" id="kobo.659.2">Ensure all moving parts are working together and test the overall application when one service pool is down.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.660.1">You should define a service partition for each business or technical requirement. </span><span class="koboSpan" id="kobo.660.2">It would be best if you used this pattern to prevent the application from cascading failure and isolating critical consumers from the standard consumer.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.661.1">Often, legacy </span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.662.1">application servers have a configuration with hardcoded </span><strong class="keyWord"><span class="koboSpan" id="kobo.663.1">Internet Protocol</span></strong><span class="koboSpan" id="kobo.664.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.665.1">IP</span></strong><span class="koboSpan" id="kobo.666.1">) addresses or </span><strong class="keyWord"><span class="koboSpan" id="kobo.667.1">Domain Name System</span></strong><span class="koboSpan" id="kobo.668.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.669.1">DNS</span></strong><span class="koboSpan" id="kobo.670.1">) names. </span><span class="koboSpan" id="kobo.670.2">Making any </span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.671.1">server change for modernization and upgrade requires changing and revalidating the application. </span><span class="koboSpan" id="kobo.671.2">In these cases, you want to keep the server address the same. </span><span class="koboSpan" id="kobo.671.3">In the next section, let’s learn how to handle such a situation with a floating IP.</span></p>
<h1 class="heading-1" id="_idParaDest-141"><span class="koboSpan" id="kobo.672.1">Creating a floating IP pattern</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.673.1">Commonly, monolithic applications have many dependencies on the server where they are deployed. </span><span class="koboSpan" id="kobo.673.2">Application configuration and code often have hardcoded parameters based on the </span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.674.1">server’s DNS name and IP address. </span><span class="koboSpan" id="kobo.674.2">Hardcoded IP configuration creates challenges if you want to bring up a new server in case of an issue with the original server. </span><span class="koboSpan" id="kobo.674.3">Additionally, you don’t want to bring down the entire application for the upgrade, which may cause significant downtime.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.675.1">To handle such a situation, you need to create a new server keeping the same server IP address and DNS name. </span><span class="koboSpan" id="kobo.675.2">This can be achieved by moving the network interface from a problematic instance to the new server. </span><span class="koboSpan" id="kobo.675.3">The network interface is generally based on a </span><strong class="keyWord"><span class="koboSpan" id="kobo.676.1">Network Interface Card</span></strong><span class="koboSpan" id="kobo.677.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.678.1">NIC</span></strong><span class="koboSpan" id="kobo.679.1">), which facilitates communication between servers over a network. </span><span class="koboSpan" id="kobo.679.2">It can </span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.680.1">be in the form of hardware or software. </span><span class="koboSpan" id="kobo.680.2">Moving the network interface means that now your new server assumes the identity of the old server. </span><span class="koboSpan" id="kobo.680.3">Your application can live with the same DNS and IP address. </span><span class="koboSpan" id="kobo.680.4">It also allows easy rollback by moving the network interface to the original instance.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.681.1">The public </span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.682.1">cloud (for example, AWS) made it easy by providing an </span><strong class="keyWord"><span class="koboSpan" id="kobo.683.1">Elastic IP</span></strong><span class="koboSpan" id="kobo.684.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.685.1">EIP</span></strong><span class="koboSpan" id="kobo.686.1">) and </span><strong class="keyWord"><span class="koboSpan" id="kobo.687.1">Elastic Network Interface</span></strong><span class="koboSpan" id="kobo.688.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.689.1">ENI</span></strong><span class="koboSpan" id="kobo.690.1">). </span><span class="koboSpan" id="kobo.690.2">If your instance fails and you need to push traffic </span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.691.1">to another instance with the same public IP address, then you can move the EIP address from one server to another, as shown in the following architecture diagram:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.692.1"><img alt="A picture containing text, screenshot, diagram, line  Description automatically generated" src="../Images/B21336_04_11.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.693.1">Figure 4.11: Floating IP and interface pattern</span></p>
<p class="normal"><span class="koboSpan" id="kobo.694.1">Since you are </span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.695.1">moving EIP, the DNS may not need to be updated. </span><span class="koboSpan" id="kobo.695.2">EIP can move your server’s public IP across instances. </span><span class="koboSpan" id="kobo.695.3">If you need to move public and private IP addresses, use a more flexible approach, such as ENI, as shown on the right of the preceding diagram. </span><span class="koboSpan" id="kobo.695.4">ENI can move across instances, and you can use the same public and private address for traffic routing or application upgrades.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.696.1">So far, you have learned about multiple architecture patterns where applications are deployed in the virtual machine. </span><span class="koboSpan" id="kobo.696.2">However, you may need help to utilize the virtual machine in many cases. </span><span class="koboSpan" id="kobo.696.3">To optimize your utilization further, you can deploy your application in </span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.697.1">containers. </span><span class="koboSpan" id="kobo.697.2">Containers are most suitable for microservice deployment. </span><span class="koboSpan" id="kobo.697.3">Let’s learn more about container-based deployment in the next section.</span></p>
<h1 class="heading-1" id="_idParaDest-142"><span class="koboSpan" id="kobo.698.1">Deploying an application with a container</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.699.1">As many programming languages are invented, and technologies evolve, this creates new challenges. </span><span class="koboSpan" id="kobo.699.2">Different application stacks require different hardware and software deployment environments. </span><span class="koboSpan" id="kobo.699.3">Often, there is a need to run applications across different platforms and </span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.700.1">migrate from one platform to another. </span><span class="koboSpan" id="kobo.700.2">Solutions require something that can run anything everywhere and is consistent, lightweight, and portable.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.701.1">Just as shipping containers standardize the transport of freight goods, software containers standardize the transport of applications. </span><span class="koboSpan" id="kobo.701.2">Docker creates a container that includes everything a software application would need to run its files, such as filesystem structure, daemons, libraries, and application dependencies.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.702.1">Containers provide isolation for software within its respective development and staging environments. </span><span class="koboSpan" id="kobo.702.2">This isolation is essential because it prevents conflicts from arising when multiple teams are running various software applications on the same underlying infrastructure.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.703.1">VMs are isolated at the operating system level, and containers isolate at the kernel level. </span><span class="koboSpan" id="kobo.703.2">This isolation allows several applications to run on a single-host operating system and yet still have their filesystem, storage, RAM, libraries, and, mostly, their own </span><em class="italic"><span class="koboSpan" id="kobo.704.1">view</span></em><span class="koboSpan" id="kobo.705.1"> of the system:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.706.1"><img alt="A picture containing text, screenshot, font, number  Description automatically generated" src="../Images/B21336_04_12.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.707.1">Figure 4.12: Virtual machines and containers for application deployment</span></p>
<p class="normal"><span class="koboSpan" id="kobo.708.1">As shown in the preceding diagram, containers deploy multiple applications in a single virtual machine. </span><span class="koboSpan" id="kobo.708.2">Each application has its runtime environment, so you can run many individual applications while keeping the same number of servers. </span><span class="koboSpan" id="kobo.708.3">Containers share a machine’s operating system kernel. </span><span class="koboSpan" id="kobo.708.4">They offer advantages like quick startup times and efficient use </span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.709.1">of computing resources such as RAM. </span><span class="koboSpan" id="kobo.709.2">Container images are built using layers from the filesystem, and they can share common files. </span><span class="koboSpan" id="kobo.709.3">This shared resource approach reduces disk usage and speeds up the process of downloading container images.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.710.1">Let’s look at why containers are becoming more popular, along with their benefits.</span></p>
<h2 class="heading-2" id="_idParaDest-143"><span class="koboSpan" id="kobo.711.1">The benefit of containers</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.712.1">These </span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.713.1">questions are often asked when it comes to containers:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.714.1">Why do we need containers when we have instances?</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.715.1">Don’t instances already provide us with isolation from the underlying hardware?</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.716.1">While the preceding questions are valid, several benefits accrue from using a system such as </span><strong class="keyWord"><span class="koboSpan" id="kobo.717.1">Docker</span></strong><span class="koboSpan" id="kobo.718.1">. </span><span class="koboSpan" id="kobo.718.2">One of the key benefits of Docker is that it allows you to fully utilize your virtual machine resources by hosting multiple applications (on distinct ports) in the same instance.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.719.1">Docker uses </span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.720.1">certain features of the Linux kernel, namely kernel namespaces and groups, to achieve complete isolation between each Docker process, as indicated in the following architecture diagram:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.721.1"><img alt="A screenshot of a computer  Description automatically generated with low confidence" src="../Images/B21336_04_13.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.722.1">Figure 4.13: Container layer in application infrastructure</span></p>
<p class="normal"><span class="koboSpan" id="kobo.723.1">As shown in the preceding diagram, it’s possible to run two or more applications that require different versions of the Java runtime on the same machine, as each Docker container has its version of Java and the associated libraries installed. </span><span class="koboSpan" id="kobo.723.2">In turn, the container layer in the application infrastructure makes it easier to decompose your applications into microservices that can run side by side on the same instance. </span><span class="koboSpan" id="kobo.723.3">Containers have the following benefits:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.724.1">Portable runtime application environment</span></strong><span class="koboSpan" id="kobo.725.1">: Containers provide platform-independent capabilities, where you build your application once and deploy it anywhere regardless of the underlying operating system.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.726.1">Faster development and deployment cycles</span></strong><span class="koboSpan" id="kobo.727.1">: Modify the application and run it anywhere with a quick boot time, typically within seconds.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.728.1">Package dependencies and application in a single artifact</span></strong><span class="koboSpan" id="kobo.729.1">: Package the code, library, and dependencies together to run the application in any operating system.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.730.1">Run different application versions</span></strong><span class="koboSpan" id="kobo.731.1">: Applications with different dependencies run simultaneously in a single server.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.732.1">Everything can be automated</span></strong><span class="koboSpan" id="kobo.733.1">: Container management and deployment are done through scripting, which helps to reduce cost and the risk of human error.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.734.1">Better resource utilization</span></strong><span class="koboSpan" id="kobo.735.1">: Containers provide efficient scaling and high availability, and multiple copies of the same microservice container can be deployed across servers for your application.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.736.1">Easy to manage the security aspect</span></strong><span class="koboSpan" id="kobo.737.1">: Containers are platform-specific rather than application-specific.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.738.1">Container </span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.739.1">deployment is becoming very popular due to its benefits. </span><span class="koboSpan" id="kobo.739.2">There are multiple ways to orchestrate containers. </span><span class="koboSpan" id="kobo.739.3">Let’s look at container deployment in more detail next.</span></p>
<h2 class="heading-2" id="_idParaDest-144"><span class="koboSpan" id="kobo.740.1">Container deployment</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.741.1">Complex applications with multiple microservices can be quickly deployed using container deployment. </span><span class="koboSpan" id="kobo.741.2">The container makes building and deploying the application more manageable </span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.742.1">as the environment is the same. </span><span class="koboSpan" id="kobo.742.2">Build the container in development mode, push it to test, and then release it to production. </span><span class="koboSpan" id="kobo.742.3">For hybrid cloud environments, container deployment is very useful. </span><span class="koboSpan" id="kobo.742.4">Containers make it easier to keep environments consistent across microservices. </span><span class="koboSpan" id="kobo.742.5">As microservices aren’t always very resource-consuming, they can be placed together in a single instance to reduce cost.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.743.1">Sometimes, customers have short workflows that require a temporary environment setup. </span><span class="koboSpan" id="kobo.743.2">Those environments may be queue systems or continuous integration jobs, which don’t always utilize server resources efficiently. </span><span class="koboSpan" id="kobo.743.3">Container orchestration services such as Docker and Kubernetes can be a workaround, allowing them to push and pop containers onto the instance.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.744.1">Docker’s lightweight container virtualization platform provides tools to manage your applications. </span><span class="koboSpan" id="kobo.744.2">Its standalone application can be installed on any computer to run containers. </span><span class="koboSpan" id="kobo.744.3">Kubernetes is a container orchestration service that works with Docker and another container platform. </span><span class="koboSpan" id="kobo.744.4">Kubernetes allows automated container provisioning and diligently handles security, networking, and scaling aspects.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.745.1">Containers help </span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.746.1">the enterprise to create more cloud-native workloads, and public cloud providers such as AWS extend services to manage Docker containers and Kubernetes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.747.1">The following </span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.748.1">diagram shows Docker’s container management using Amazon </span><strong class="keyWord"><span class="koboSpan" id="kobo.749.1">Elastic Container Service</span></strong><span class="koboSpan" id="kobo.750.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.751.1">ECS</span></strong><span class="koboSpan" id="kobo.752.1">), providing a fully managed elastic service to automate the scaling and orchestration of Docker containers:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.753.1"><img alt="A diagram of a load balancer  Description automatically generated with low confidence" src="../Images/B21336_04_14.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.754.1">Figure 4.14: Container deployment architecture</span></p>
<p class="normal"><span class="koboSpan" id="kobo.755.1">In the preceding diagram, multiple containers are deployed in a single Amazon EC2 virtual machine managed through Amazon ECS, which facilitates the agent communication service and cluster management. </span><span class="koboSpan" id="kobo.755.2">All user requests are distributed using a load balancer among the </span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.756.1">containers. </span><span class="koboSpan" id="kobo.756.2">Similarly, AWS provides Amazon </span><strong class="keyWord"><span class="koboSpan" id="kobo.757.1">Elastic Kubernetes Service</span></strong><span class="koboSpan" id="kobo.758.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.759.1">EKS</span></strong><span class="koboSpan" id="kobo.760.1">) to manage containers using Kubernetes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.761.1">Containers are </span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.762.1">a broad topic, and as a solutions architect, you must be familiar with all the available options. </span><span class="koboSpan" id="kobo.762.2">This section provides an overview of containers. </span><span class="koboSpan" id="kobo.762.3">However, you will need to dive further if you utilize containers for your microservice deployment. </span><span class="koboSpan" id="kobo.762.4">Let’s look at container-based architecture in the next section.</span></p>
<h2 class="heading-2" id="_idParaDest-145"><span class="koboSpan" id="kobo.763.1">Building container-based architecture</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.764.1">As you learned in the previous section, containerization helps create environments for repeatable and scalable applications. </span><span class="koboSpan" id="kobo.764.2">To start container adoption, you need to identify a pilot workload </span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.765.1">managed through container orchestration. </span><span class="koboSpan" id="kobo.765.2">You can take existing microservice components and deploy them in containers. </span><span class="koboSpan" id="kobo.765.3">After identifying gaps and operational needs, you can define a migration strategy to move your workload to containers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.766.1">Container migrations can be challenging if your applications are not originally designed to operate in a containerized environment. </span><span class="koboSpan" id="kobo.766.2">This is because many applications typically store files locally and rely on stateful sessions. </span><span class="koboSpan" id="kobo.766.3">When migrating to containers, it’s essential to address these specific requirements and ensure that your applications can function smoothly within the container environment.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.767.1">For container platforms, you can make choices; you can choose Docker, OpenShift, Kubernetes, and so on. </span><span class="koboSpan" id="kobo.767.2">However, Kubernetes is becoming an increasingly popular open-source container orchestrator. </span><span class="koboSpan" id="kobo.767.3">Public cloud vendors like AWS provide a platform to manage containers, such as Amazon ECS for Docker and Amazon EKS for Kubernetes. </span><span class="koboSpan" id="kobo.767.4">These cloud services provide a control plane to choose various compute options to select self-managed nodes, managed nodes, or serverless options with AWS Fargate. </span><span class="koboSpan" id="kobo.767.5">The control plane serves as the central management interface, allowing for the orchestration and operational oversight of containerized applications and their resources. </span><span class="koboSpan" id="kobo.767.6">If you are utilizing Amazon EKS for deploying a microservices-based application, for example, the Kubernetes control plane, managed by AWS, takes care of orchestrating container deployments, managing state, and maintaining desired configurations. </span><span class="koboSpan" id="kobo.767.7">This setup allows you to focus on application development rather than managing infrastructure.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.768.1">The following architecture diagram shows running a stateful service on Amazon EKS in your programming languages of choice, such as Java or .NET. </span><span class="koboSpan" id="kobo.768.2">Given the architecture, you can manage the session state in a Redis database.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.769.1"><img alt="A picture containing text, screenshot, diagram, display  Description automatically generated" src="../Images/B21336_04_15.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.770.1">Figure 4.15: Deploying a stateful application on a container</span></p>
<p class="normal"><span class="koboSpan" id="kobo.771.1">As you can </span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.772.1">see in the preceding diagram, the container-based architecture comprises several key components:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.773.1">An </span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.774.1">Amazon </span><strong class="keyWord"><span class="koboSpan" id="kobo.775.1">Virtual Private Cloud</span></strong><span class="koboSpan" id="kobo.776.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.777.1">VPC</span></strong><span class="koboSpan" id="kobo.778.1">) with specific subnets:</span><ul>
<li class="bulletList"><span class="koboSpan" id="kobo.779.1">Public subnet: Hosts the load balancer</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.780.1">Private subnets: Used for deploying the application and database</span></li>
</ul>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.781.1">An Application Load Balancer, responsible for providing access to the website </span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.782.1">hosted within the containers.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.783.1">An Amazon </span><strong class="keyWord"><span class="koboSpan" id="kobo.784.1">Elastic Kubernetes Service</span></strong><span class="koboSpan" id="kobo.785.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.786.1">EKS</span></strong><span class="koboSpan" id="kobo.787.1">) cluster featuring a managed node group within Kubernetes. </span><span class="koboSpan" id="kobo.787.2">These nodes are responsible for running multiple application containers.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.788.1">An Amazon ElastiCache Redis database, utilized to store user session state.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.789.1">This architecture allows for the scalability of the application by storing user sessions in a Redis database. </span><span class="koboSpan" id="kobo.789.2">However, please note that implementing this solution may require modifications to the application code, which may not be feasible in certain scenarios.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.790.1">Now, you have </span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.791.1">learned about various architecture patterns focusing on application development. </span><span class="koboSpan" id="kobo.791.2">Data is an integral part of any architectural design, and most of the architecture revolves around collecting, storing, and processing data visualization. </span><span class="koboSpan" id="kobo.791.3">In the next section, let’s learn more about handling data in application architecture.</span></p>
<h1 class="heading-1" id="_idParaDest-146"><span class="koboSpan" id="kobo.792.1">Database handling in application architecture</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.793.1">Data is always central to any application development, and scaling data has always been challenging. </span><span class="koboSpan" id="kobo.793.2">Handling </span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.794.1">data efficiently improves application latency and performance. </span><span class="koboSpan" id="kobo.794.2">In the earlier section </span><em class="italic"><span class="koboSpan" id="kobo.795.1">Building a cache-based architecture</span></em><span class="koboSpan" id="kobo.796.1">, you learned how to handle frequently queried data by putting a cache in front of your database under the app caching pattern. </span><span class="koboSpan" id="kobo.796.2">You can put either a Memcached or Redis cache in front of your database, reducing the many hits on the database and improving database latency.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.797.1">In application deployment, as your application’s user base grows, you need to handle more data with your relational database. </span><span class="koboSpan" id="kobo.797.2">You need to add more storage or vertically scale the database server by adding more memory and CPU power. </span><span class="koboSpan" id="kobo.797.3">Often, horizontal scaling is more complex when it comes to scaling relational databases. </span><span class="koboSpan" id="kobo.797.4">If your application is read-heavy, you can achieve horizontal scaling by creating a read replica. </span><span class="koboSpan" id="kobo.797.5">Route all read requests to database read replicas while keeping the master database node to serve write and update requests. </span><span class="koboSpan" id="kobo.797.6">As a read replica has asynchronous replication, it can add some lag time. </span><span class="koboSpan" id="kobo.797.7">You should choose the read replica option if your application can tolerate some milliseconds of latency. </span><span class="koboSpan" id="kobo.797.8">You can use read replicas to offload reporting.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.798.1">You can use database sharding to create a multi-master for your relational database and inject the concept of horizontal scaling. </span><span class="koboSpan" id="kobo.798.2">The sharding technique is used to improve writing performance with multiple database servers. </span><span class="koboSpan" id="kobo.798.3">The database is structured and segmented into identical sections, with appropriate table columns serving as keys for distributing the writing processes. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.799.1">As demonstrated in the following architecture diagram, the customer database can be divided into multiple shards:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.800.1"><img alt="A picture containing text, screenshot, diagram, line  Description automatically generated" src="../Images/B21336_04_16.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.801.1">Figure 4.16: Relational database sharding</span></p>
<p class="normal"><span class="koboSpan" id="kobo.802.1">As shown in the preceding diagram, without </span><em class="italic"><span class="koboSpan" id="kobo.803.1">shards</span></em><span class="koboSpan" id="kobo.804.1">, all data resides in one partition, for example, the first names of all users being in one single database. </span><span class="koboSpan" id="kobo.804.2">With sharding, data is split into large </span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.805.1">chunks called shards. </span><span class="koboSpan" id="kobo.805.2">For example, all users’ first names beginning with </span><strong class="keyWord"><span class="koboSpan" id="kobo.806.1">A to I</span></strong><span class="koboSpan" id="kobo.807.1"> are in one database, </span><strong class="screenText"><span class="koboSpan" id="kobo.808.1">J to R</span></strong><span class="koboSpan" id="kobo.809.1"> in another, and </span><strong class="screenText"><span class="koboSpan" id="kobo.810.1">S to Z</span></strong><span class="koboSpan" id="kobo.811.1"> in a third database. </span><span class="koboSpan" id="kobo.811.2">In many circumstances, sharding gives you higher performance and better operating efficiency.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.812.1">Utilizing Amazon RDS for sharding backend databases involves installing sharding software, such as MySQL, along with a Spider storage engine on an Amazon EC2 instance. </span><span class="koboSpan" id="kobo.812.2">Subsequently, you can begin by setting up multiple RDS databases and employing them as backend databases for sharding.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.813.1">However, what if your master database instance goes down? </span><span class="koboSpan" id="kobo.813.2">In that case, you need to maintain high availability for your database. </span><span class="koboSpan" id="kobo.813.3">Let’s take a closer look at the high-availability database pattern.</span></p>
<h2 class="heading-2" id="_idParaDest-147"><span class="koboSpan" id="kobo.814.1">High-availability database pattern</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.815.1">For the high availability of your application, it is critical to keep your database up and running all the time. </span><span class="koboSpan" id="kobo.815.2">As horizontal scaling is not a straightforward option in the relational </span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.816.1">database, it creates </span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.817.1">additional challenges. </span><span class="koboSpan" id="kobo.817.2">To achieve high database availability, you can have a standby replica of the master database instance, as shown in the following diagram:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.818.1"><img alt="A picture containing text, screenshot, line, diagram  Description automatically generated" src="../Images/B21336_04_17.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.819.1">Figure 4.17: High-availability database pattern</span></p>
<p class="normal"><span class="koboSpan" id="kobo.820.1">As shown in the preceding diagram, your application server switches over to the standby instance if the primary instance goes down. </span><span class="koboSpan" id="kobo.820.2">A read replica takes the load off the primary instance to handle latency. </span><span class="koboSpan" id="kobo.820.3">The primary and standby are located in different </span><strong class="keyWord"><span class="koboSpan" id="kobo.821.1">availability zones</span></strong><span class="koboSpan" id="kobo.822.1">, so your application will still be up even when an entire availability zone is down. </span><span class="koboSpan" id="kobo.822.2">This architecture also helps to achieve zero downtime, which may be caused during the database maintenance window. </span><span class="koboSpan" id="kobo.822.3">When a primary instance is down for maintenance, the application can fail over to a secondary standby instance and continue serving user requests.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.823.1">For disaster recovery, you will want to define the database backup and archival strategy, depending on </span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.824.1">your application’s </span><strong class="keyWord"><span class="koboSpan" id="kobo.825.1">recovery point objective</span></strong><span class="koboSpan" id="kobo.826.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.827.1">RPO</span></strong><span class="koboSpan" id="kobo.828.1">) of how frequently you want to take backups. </span><span class="koboSpan" id="kobo.828.2">You will learn about RPOs and RTOs in depth in </span><em class="chapterRef"><span class="koboSpan" id="kobo.829.1">Chapter 8</span></em><span class="koboSpan" id="kobo.830.1">, </span><em class="italic"><span class="koboSpan" id="kobo.831.1">Architectural Reliability Considerations</span></em><span class="koboSpan" id="kobo.832.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.833.1">If your RPO is 30 minutes, it means your organization can only tolerate 30 minutes’ worth of data loss. </span><span class="koboSpan" id="kobo.833.2">In that case, you should take a backup every half an hour. </span><span class="koboSpan" id="kobo.833.3">While storing the backup, you need to determine how long the data can be stored for customer query purposes. </span><span class="koboSpan" id="kobo.833.4">You can store data for six months as an active backup and then in an archival store as per the compliance requirement.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.834.1">Consider </span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.835.1">how quickly you need to access your backup and determine the type of network connection </span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.836.1">needed to meet your backup and recovery requirements as per the company’s </span><strong class="keyWord"><span class="koboSpan" id="kobo.837.1">recovery time objective</span></strong><span class="koboSpan" id="kobo.838.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.839.1">RTO</span></strong><span class="koboSpan" id="kobo.840.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.841.1">For example, if your company’s RTO is 60 minutes, it means you should have enough network bandwidth to retrieve and restore your backup within an hour. </span><span class="koboSpan" id="kobo.841.2">Also, define whether you are backing up snapshots of complete systems or volumes attached to systems.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.842.1">You may also need to classify your data, for example, if it has customer-sensitive information such as email, addresses, personally identifiable information, and more. </span><span class="koboSpan" id="kobo.842.2">It would be best if you defined the data encryption strategy accordingly. </span><span class="koboSpan" id="kobo.842.3">You will learn more about data security in </span><em class="chapterRef"><span class="koboSpan" id="kobo.843.1">Chapter 7</span></em><span class="koboSpan" id="kobo.844.1">, </span><em class="italic"><span class="koboSpan" id="kobo.845.1">Security Considerations</span></em><span class="koboSpan" id="kobo.846.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.847.1">Depending on your application’s growth and complexity, consider migrating from an RDBMS to a NoSQL database. </span><span class="koboSpan" id="kobo.847.2">NoSQL can provide greater scalability, management, performance, and reliability than most relational databases. </span><span class="koboSpan" id="kobo.847.3">However, the process of migrating to NoSQL from an RDBMS can be time-consuming and labor-intensive.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.848.1">There is a lot of data to process in any application, for example, clickstream data, application log data, rating and review data, social media data, and more. </span><span class="koboSpan" id="kobo.848.2">Analyzing these datasets and getting insight can help you to grow your organization exponentially. </span><em class="chapterRef"><span class="koboSpan" id="kobo.849.1">Chapter 12</span></em><span class="koboSpan" id="kobo.850.1">, </span><em class="italic"><span class="koboSpan" id="kobo.851.1">Data Engineering for Solution Architecture</span></em><span class="koboSpan" id="kobo.852.1">, will teach you more about these use cases and patterns. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.853.1">Now, let’s learn about building a maintainable system using Clean Architecture.</span></p>
<h1 class="heading-1" id="_idParaDest-148"><span class="koboSpan" id="kobo.854.1">Clean Architecture</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.855.1">Clean Architecture, also </span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.856.1">known as Hexagonal Architecture or Ports and Adapters, is an architectural </span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.857.1">pattern used in designing business applications. </span><span class="koboSpan" id="kobo.857.2">Robert C. </span><span class="koboSpan" id="kobo.857.3">Martin proposed it and it emphasizes the separation of concerns, maintainability, and testability. </span><span class="koboSpan" id="kobo.857.4">Clean Architecture aims to create a flexible, adaptable, and maintainable system over time.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.858.1">Clean Architecture divides your application into five key components; let’s understand them through </span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.859.1">the example of an online bookstore:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><strong class="keyWord"><span class="koboSpan" id="kobo.860.1">Entities (innermost layer)</span></strong><span class="koboSpan" id="kobo.861.1">: Entities are the business objects that encapsulate the core business rules. </span><span class="koboSpan" id="kobo.861.2">They are independent of any specific technology, database, or framework. </span><span class="koboSpan" id="kobo.861.3">Entities represent the “things” in the system and what they can do. </span><span class="koboSpan" id="kobo.861.4">In an online bookstore, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.862.1">Book</span></code><span class="koboSpan" id="kobo.863.1"> entity might have properties like title, author, price, and methods to check availability or apply discounts.</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.864.1">Use cases</span></strong><span class="koboSpan" id="kobo.865.1">: Use cases contain the application-specific rules and define how the entities interact to fulfill specific scenarios or user stories. </span><span class="koboSpan" id="kobo.865.2">They coordinate the flow of data and actions between entities and external interfaces. </span><span class="koboSpan" id="kobo.865.3">They are also technology-agnostic, focusing only on business logic. </span><span class="koboSpan" id="kobo.865.4">The checkout use case might involve validating the shopping cart, applying discounts, calculating shipping, and processing payment, for example.</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.866.1">Interfaces (ports)</span></strong><span class="koboSpan" id="kobo.867.1">: Interfaces define contracts for how different layers of the system interact with each other. </span><span class="koboSpan" id="kobo.867.2">They create a boundary that separates the inner layers (entities and use cases) from the outer layers (adapters, frameworks, and drivers). </span><span class="koboSpan" id="kobo.867.3">This separation enables flexibility and maintainability. </span><span class="koboSpan" id="kobo.867.4">There might be an interface for payment processing that defines methods like processing payments and refunds.</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.868.1">Adapters</span></strong><span class="koboSpan" id="kobo.869.1">: Adapters implement the interfaces and translate between the inner and outer layers. </span><span class="koboSpan" id="kobo.869.2">They allow the application to interact with external components like databases, APIs, or third-party libraries. </span><span class="koboSpan" id="kobo.869.3">Adapters allow the core logic to remain isolated from technological changes or external dependencies. </span><span class="koboSpan" id="kobo.869.4">A database adapter might implement a data access interface to handle interaction with a specific database technology.</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.870.1">Frameworks and drivers (outermost layer)</span></strong><span class="koboSpan" id="kobo.871.1">: This layer comprises all the technical details and tools used to build the application. </span><span class="koboSpan" id="kobo.871.2">It includes web servers, databases, UI frameworks, third-party libraries, etc. </span><span class="koboSpan" id="kobo.871.3">This layer interacts with the adapters to connect the core application to the outside world. </span><span class="koboSpan" id="kobo.871.4">This could include implementing a RESTful API using a specific web framework, setting up a connection to an SQL database, or integrating with a third-party payment gateway.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.872.1">In Clean Architecture, each layer is independent of the others, allowing changes in one layer without affecting the others. </span><span class="koboSpan" id="kobo.872.2">You can switch databases, change the UI framework, or modify business logic without causing ripple effects throughout the system. </span><span class="koboSpan" id="kobo.872.3">Since your architecture has well-defined interfaces, it’s easier to create mocks or stubs for testing. </span><span class="koboSpan" id="kobo.872.4">Core business logic can be tested independently from databases, UI, or other external dependencies.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.873.1">While using Clean Architecture, make sure to avoid over-engineering. </span><span class="koboSpan" id="kobo.873.2">For simple or small projects, the complexity and overhead of Clean Architecture might need to be revised. </span><span class="koboSpan" id="kobo.873.3">It requires careful consideration of whether the benefits outweigh the increased complexity and development time.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.874.1">Clean Architecture </span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.875.1">provides a robust and flexible foundation for developing software that can adapt to changing technologies and requirements. </span><span class="koboSpan" id="kobo.875.2">Focusing on separating concerns and clear boundaries between layers promotes maintainability, scalability, and testability. </span><span class="koboSpan" id="kobo.875.3">It’s a robust pattern that can serve well in complex systems but must be applied with an understanding of the needs and context of the specific project to avoid unnecessary complexity.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.876.1">Now, you have learned about various architectural patterns and best practices. </span><span class="koboSpan" id="kobo.876.2">Let’s learn about key anti-patterns that you should be careful of when designing application architecture.</span></p>
<h1 class="heading-1" id="_idParaDest-149"><span class="koboSpan" id="kobo.877.1">Avoiding anti-patterns in solution architecture</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.878.1">In this chapter, you have learned about a different way of designing solution architecture with various design patterns. </span><span class="koboSpan" id="kobo.878.2">Often, teams can drift away from best practices </span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.879.1">due to timeline pressure or the unavailability of resources. </span><span class="koboSpan" id="kobo.879.2">It is advised to try and avoid the following architecture design anti-patterns. </span><span class="koboSpan" id="kobo.879.3">An anti-pattern serves as an example of a poorly designed system:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.880.1">In an anti-pattern, scaling is handled reactively and manually. </span><span class="koboSpan" id="kobo.880.2">When application servers reach their maximum capacity and have no more resources available, users face disruptions in accessing the application. </span><span class="koboSpan" id="kobo.880.3">It’s only when users start reporting issues that the administrator becomes aware of the problem. </span><span class="koboSpan" id="kobo.880.4">The admin then initiates the process of launching a new server instance to alleviate the load on existing servers. </span><span class="koboSpan" id="kobo.880.5">However, there’s a drawback to this approach as there’s typically a delay of a few minutes between the instance launches and its actual availability. </span><span class="koboSpan" id="kobo.880.6">During this intervening period, users experience service interruptions and are unable to access the application. </span><span class="koboSpan" id="kobo.880.7">You should take a proactive approach and use auto-scaling to add processing power when servers reach a certain threshold, like 60% CPU or 60% memory utilization.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.881.1">With anti-patterns, automation is missing. </span><span class="koboSpan" id="kobo.881.2">When application servers crash, the admin manually launches and configures the new server and notifies the users manually. </span><span class="koboSpan" id="kobo.881.3">Automating the detection of unhealthy resources and launching replacement resources can streamline operations. </span><span class="koboSpan" id="kobo.881.4">Furthermore, it’s possible to implement automated notifications when such resource changes occur.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.882.1">With anti-patterns, the server is kept for a long time with hardcoded IP addresses, which prevents flexibility. </span><span class="koboSpan" id="kobo.882.2">Over time, server configurations can become inconsistent, leading to the inefficient allocation of resources, with some resources running when they are not needed. </span><span class="koboSpan" id="kobo.882.3">It would help if you kept all </span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.883.1">of the servers identical and had the ability to switch to a new IP address. </span><span class="koboSpan" id="kobo.883.2">You should automatically terminate any unused resources.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.884.1">With anti-patterns, an application is built monolithically, where all layers of the architecture, including web, application, and data layers, are tightly coupled and server-dependent. </span><span class="koboSpan" id="kobo.884.2">If one server crashes, it brings down the entire application. </span><span class="koboSpan" id="kobo.884.3">Keep the application and web layers independent by adding a load balancer in between. </span><span class="koboSpan" id="kobo.884.4">In the event that one of the application servers becomes unavailable, the load balancer automatically redirects all traffic to the remaining healthy servers.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.885.1">With anti-patterns, the application is server-bound, and the servers communicate directly with each other. </span><span class="koboSpan" id="kobo.885.2">User authentication and sessions are stored in the server locally, and all static files are served from the local server. </span><span class="koboSpan" id="kobo.885.3">You should create a service-oriented RESTful architecture, where the services talk to each other using a standard protocol such as HTTP. </span><span class="koboSpan" id="kobo.885.4">User authentication and sessions should be stored in low-latency distributed storage to scale the application horizontally. </span><span class="koboSpan" id="kobo.885.5">The static asset should be stored in centralized object storage decoupled from the server.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.886.1">With anti-patterns, a single database is used for all kinds of needs. </span><span class="koboSpan" id="kobo.886.2">You use a relational database for all needs, which introduces performance and latency issues. </span><span class="koboSpan" id="kobo.886.3">You should use the right storage for the right need, such as the following:</span><ul>
<li class="bulletList"><span class="koboSpan" id="kobo.887.1">NoSQL to store the user session</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.888.1">Cache data storage for low-latency data availability</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.889.1">Data warehouse for reporting needs</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.890.1">Relational database for transactional data</span></li>
</ul>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.891.1">With anti-patterns, you will find a single point of failure by having a single database instance to serve the application. </span><span class="koboSpan" id="kobo.891.2">Whenever feasible, remove single points of failure from your architecture. </span><span class="koboSpan" id="kobo.891.3">Establish a secondary server (standby) and replicate the data. </span><span class="koboSpan" id="kobo.891.4">In the event of a primary database server failure, the secondary server can take over the workload.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.892.1">With </span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.893.1">anti-patterns, static content such as high-resolution images and videos are served directly from the server without caching. </span><span class="koboSpan" id="kobo.893.2">It would be best if you considered using a CDN to cache heavy content near the user location, which helps to improve page latency and reduce page load time.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.894.1">With anti-patterns, you can find security loopholes that open server access without a fine-grained security policy. </span><span class="koboSpan" id="kobo.894.2">You should always apply the principle of least privilege, which means starting with no access and only giving access to the required user group.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.895.1">The preceding points provide some of the most common anti-patterns. </span><span class="koboSpan" id="kobo.895.2">Throughout this book, you will learn the best practices for avoiding them in solution design.</span></p>
<h1 class="heading-1" id="_idParaDest-150"><span class="koboSpan" id="kobo.896.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.897.1">This chapter delved into constructing robust and scalable software architectures through various architectural paradigms. </span><span class="koboSpan" id="kobo.897.2">It began with exploring n-tier layered architecture, dissecting the essential components comprising the web, application, and database layers. </span><span class="koboSpan" id="kobo.897.3">The discussion transitioned into the intricate world of multi-tenant </span><strong class="keyWord"><span class="koboSpan" id="kobo.898.1">Software-as-a-Service</span></strong><span class="koboSpan" id="kobo.899.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.900.1">SaaS</span></strong><span class="koboSpan" id="kobo.901.1">) architecture, delving into the complexities and benefits of accommodating diverse user bases within a unified framework.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.902.1">As for web services, the chapter dove into the RESTful architectural style, elucidating its principles and applications. </span><span class="koboSpan" id="kobo.902.2">This was followed by a journey through constructing a RESTful e-commerce architecture, offering practical insights into real-world implementation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.903.1">Cache-based architectures were then discussed, with a comprehensive exploration of cache distribution, proxy patterns such as cache proxy and rewrite proxy, and efficient caching strategies like app caching. </span><span class="koboSpan" id="kobo.903.2">A comparative study of Memcached and Redis shed light on selecting the optimal caching solution.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.904.1">The significance of architectural patterns was underscored by exploring the </span><strong class="keyWord"><span class="koboSpan" id="kobo.905.1">Model-View-Controller</span></strong><span class="koboSpan" id="kobo.906.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.907.1">MVC</span></strong><span class="koboSpan" id="kobo.908.1">) approach and </span><strong class="keyWord"><span class="koboSpan" id="kobo.909.1">Domain-Driven Design</span></strong><span class="koboSpan" id="kobo.910.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.911.1">DDD</span></strong><span class="koboSpan" id="kobo.912.1">) methodology, empowering architects to create structured, adaptable, and maintainable systems.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.913.1">Architectural resilience was covered through an in-depth section on the circuit breaker pattern and on implementing the bulkhead pattern for enhanced system stability. </span><span class="koboSpan" id="kobo.913.2">Coverage of the floating IP pattern further enriched your toolkit for achieving high availability.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.914.1">The chapter delved into containerization, unearthing the manifold benefits of containers and providing a roadmap for effective container deployment. </span><span class="koboSpan" id="kobo.914.2">Database handling strategies were examined within application architecture, looking at high-availability patterns to ensure data integrity and continuous operation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.915.1">The chapter concluded by spotlighting the Clean Architecture principles and imparting strategies for avoiding detrimental anti-patterns in solution architecture.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.916.1">By embarking on this architectural expedition, you have gained profound insights into the intricacies of building resilient, scalable, and future-ready software systems, and you are now armed with the knowledge needed to navigate the dynamic landscape of modern technology.</span></p>
<h1 class="heading-1" id="_idParaDest-151"><span class="koboSpan" id="kobo.917.1">Leave a review!</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.918.1">Enjoying this book? </span><span class="koboSpan" id="kobo.918.2">Help readers like you by leaving an Amazon review. </span><span class="koboSpan" id="kobo.918.3">Scan the QR code below to get a free eBook of your choice.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.919.1"><img alt="" role="presentation" src="../Images/Image.png"/></span></p>
</div>
</body></html>