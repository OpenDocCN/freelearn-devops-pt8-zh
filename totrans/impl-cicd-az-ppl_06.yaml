- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integrating Testing, Security Tasks, and Other Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have learned the basics of build and release pipelines, it is time
    to understand how Azure Pipelines can be extended with other tools, to perform
    additional tasks and be able to include additional capabilities beyond those built
    into the tool. By the end of this chapter, you will have the skills to go beyond
    the basics and be able to include tasks to increase the quality of the code produced
    in builds, detect vulnerabilities before deploying, and use source code from another
    repository and inclusive artifacts from other locations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Azure DevOps extensibility model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Including automated tests for your build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasing code quality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating with Jenkins for artifacts and release pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete this chapter, you will need certain extensions. Let’s understand
    the **Azure Devops extensibility model** first and how you can access them. You
    will find the code for this chapter in the GitHub repository at [https://github.com/PacktPublishing/Implementing-CI-CD-Using-Azure-Pipelines/tree/main/ch06](https://github.com/PacktPublishing/Implementing-CI-CD-Using-Azure-Pipelines/tree/main/ch06).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Azure DevOps extensibility model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Azure DevOps and its sub-services provide several features that are included
    by default, but you can customize and extend your experience using extensions
    that can be developed using standard technologies such as HTML, JavaScript, and
    CSS.
  prefs: []
  type: TYPE_NORMAL
- en: There is a very flexible model behind all sub-services that you can augment
    using **extensions** published by individuals and well-known third-party organizations
    available in the marketplace. You have the option to create your own and publish
    them as well if you don’t find what you need.
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of an extension is to make it easier to encapsulate reusable tasks,
    use external tools, and even enhance the look and feel of Azure DevOps. For Azure
    Pipelines, you will find extensions that do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Make complex and repetitive tasks easier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use common **Infrastructure as Code** (**IaC**) tools easily, such as Terraform
    or Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrate with SaaS products to improve code quality and security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Facilitate deployment tasks to cloud providers such as Azure and Amazon Web
    Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can access Visual Studio Marketplace for Azure DevOps at [https://marketplace.visualstudio.com/azuredevops](https://marketplace.visualstudio.com/azuredevops).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows what this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Visual Studio Marketplace for Azure DevOps](img/B18875_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Visual Studio Marketplace for Azure DevOps
  prefs: []
  type: TYPE_NORMAL
- en: Each marketplace extension listing indicates the name of the extension, who
    published it, whether the publisher is verified, its rating, number of installations,
    and price. Some are provided for free, while others might require you to pay a
    fee for them. You can find these extensions by name, category, or tag to make
    it easier to find what you are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a code quality assessment tool, SonarQube
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Search the marketplace for SonarQube and click on the listing to see its details.
    Alternatively, go to [https://marketplace.visualstudio.com/items?itemName=SonarSource.sonarqube](https://marketplace.visualstudio.com/items?itemName=SonarSource.sonarqube).
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Visual Studio Marketplace listing for the SonarQube extension](img/B18875_06_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Visual Studio Marketplace listing for the SonarQube extension
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have found the extension you want, simply click on the **Get it free**
    or **Get** button. You will be able to select the Azure DevOps organization to
    install it in, just in case you have more than one, as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Installing the SonarQube extension from the marketplace](img/B18875_06_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Installing the SonarQube extension from the marketplace
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have reviewed the permissions and terms of service and selected the
    organization to install in, click the **Install** button. It typically takes just
    a few seconds to install the extension, after which you have the option to proceed
    to the Azure DevOps organization or go back to the marketplace to find more extensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 6.4 – The SonarQube extension has been installed](img/B18875_06_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – The SonarQube extension has been installed
  prefs: []
  type: TYPE_NORMAL
- en: You will find the code for this chapter at [https://github.com/PacktPublishing/Implementing-CI-CD-Using-Azure-Pipelines/tree/main/ch06](https://github.com/PacktPublishing/Implementing-CI-CD-Using-Azure-Pipelines/tree/main/ch06).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have all the technical requirements in place, let’s see how we can
    add some automated test runs to your build pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Including automated tests for your build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All modern applications require some sort of validation to ensure they are working
    correctly, regardless of the number of developers working on the code at the same
    time. This is where **automated tests**, which are executed right after the application
    is built, can validate that there is no loss of quality or bugs are introduced
    with the changes made.
  prefs: []
  type: TYPE_NORMAL
- en: There are many types of tests, such as **unit tests**, **integration tests**,
    and **load tests**, that can be executed against an application. There are also
    many automated testing frameworks available, depending on the programming language
    used to build the application and the preferences of the teams working on it.
  prefs: []
  type: TYPE_NORMAL
- en: Why is automated testing important?
  prefs: []
  type: TYPE_NORMAL
- en: Automated tests allow you to reduce the chance of releasing bugs in your applications
    by detecting them in the early stages of the development cycle, all while reducing
    the amount of time dedicated by testing teams to perform the verifications and
    avoiding human hours in repetitive tasks that could be used to develop more features
    and capabilities in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn how to integrate the execution of unit tests
    into your build pipeline using the **NUnit test framework** and a sample C#.NET
    application created in .NET Core 6.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will assume you’re using a Visual Studio solution where you have a `CalculusService`
    Class Library project. The test projects are included. The following is the example
    code of this class in the Class Library project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following corresponding unit test is defined in a separate test project.
    Make sure you have a reference to the `Nunit`, `NUnit3TestAdapter`, and `NUnit.Analyzers`
    NuGet packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You will need to use a YAML pipeline, as shown in the following code snippet,
    to build and execute the automated tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The most important section of this pipeline is the last step, which uses the
    `VSTest@2` task. This is a generic and out-of-the-box task available in Azure
    Pipelines for running unit and functional tests that support several test frameworks
    that take advantage of Visual Studio’s Test Explorer. It’s also important to set
    the `codeCoverageEnabled` property to `true` so that you can collect data that
    indicates how much of the code in the application is being tested.
  prefs: []
  type: TYPE_NORMAL
- en: Pro tip
  prefs: []
  type: TYPE_NORMAL
- en: When configuring the `VSTest` task and using the `testAssemblyVer2` attribute,
    ensure that you provide a list of patterns to specifically find the test assemblies
    to execute tests in. Otherwise, you will find yourself with cryptic errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'With unit tests executed and code coverage enabled, you will see the results
    in the **Summary** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Test and coverage results in the Summary window](img/B18875_06_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – Test and coverage results in the Summary window
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefit of using this task is that it provides support for automatically
    publishing test results and UI reporting built into Azure Pipelines, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – The test results included in the Azure Pipelines run](img/B18875_06_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – The test results included in the Azure Pipelines run
  prefs: []
  type: TYPE_NORMAL
- en: The `VSTest@2` task also supports more advanced scenarios such as executing
    tests in parallel across multiple agents, which is useful when you have many tests
    to run, or executing UI tests, which require additional configuration in the agent
    that will be executing the test.
  prefs: []
  type: TYPE_NORMAL
- en: If your application is built using other programming languages, you must use
    the corresponding test runner and ensure the results are published in any of the
    formats supported by the `PublishTestResults@2` task to be able to import them
    and include them in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve learned about running tests in an automated way, let’s learn
    how to increase the quality of your code.
  prefs: []
  type: TYPE_NORMAL
- en: Increasing code quality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typically, developers are too busy to focus on the quality of their code and
    end up taking advantage of different automated tools to make sure they are producing
    the best and most secure application possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two important areas in this space to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Static application security testing**: This allows you to detect vulnerabilities
    in your code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Software composition analysis**: This allows you to detect vulnerabilities
    in references to external packages and libraries used in your code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why use tools to improve code quality?
  prefs: []
  type: TYPE_NORMAL
- en: Developers and testers can only do so much with the time they have available
    to meet timelines and work on application features. Introducing these tools early
    allows them to detect bugs and vulnerabilities that could otherwise be costly
    when the application is released to end users.
  prefs: []
  type: TYPE_NORMAL
- en: There are many well-known third-party tools you can use to scan and assess your
    code quality. In this chapter, we will use **SonarQube** as it is one of the most
    popular and easy to use. It allows developers to ensure they are producing clean
    code by identifying bugs and security vulnerabilities, as well as detecting common
    anti-maintainability patterns and duplicate code, among other things.
  prefs: []
  type: TYPE_NORMAL
- en: It comes in different pricing tiers, starting with the free Community Edition,
    which will be used for the examples in this chapter. If you want to get more programming
    language support in the tool or advanced vulnerability detection, you need one
    of the paid tiers.
  prefs: []
  type: TYPE_NORMAL
- en: Checkmarx, Veracode, OWASP, WhiteSource, and HP Fortify are among many others
    available. It is beyond the scope of this book to compare these tools, but you
    can certainly find plenty of comparisons online.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to set up SonarQube analysis on your code:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure a SonarQube project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a service connection to SonarQube in Azure DevOps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an Azure pipeline to analyze your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll walk through these steps in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a SonarQube project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In your SonarQube instance, proceed to create a project from the wizard by
    selecting the **From Azure DevOps** option, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Creating a project in SonarQube using the From Azure DevOps
    option](img/B18875_06_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – Creating a project in SonarQube using the From Azure DevOps option
  prefs: []
  type: TYPE_NORMAL
- en: 'If this is the first time you are setting up a connection to Azure DevOps,
    SonarQube will prompt you for **Configuration name**, **Azure DevOps URL**, and
    **Personal Access Token** details so that it can configure the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Create a configuration](img/B18875_06_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – Create a configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, select the Azure DevOps project to configure in the SonarQube side by
    selecting it from the available list and clicking on the **Set up selected** **repository**
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Selecting an Azure DevOps project in SonarQube](img/B18875_06_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – Selecting an Azure DevOps project in SonarQube
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve done this, you are ready to proceed with the configuration in the
    Azure DevOps and pipeline side.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a service connection to SonarQube in Azure DevOps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is to create a **service connection** to the SonarQube instance.
    This will allow Azure Pipelines to use the SonarQube extension and communicate
    with the SonarQube instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create and manage service connections by choosing the `Sonar` should
    list the SonarQube option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – The SonarQube service connection option](img/B18875_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – The SonarQube service connection option
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to provide details in the **Server Url**, **Token**, **Service
    connection name**, and **Description (optional)** boxes. Don’t forget to check
    the **Grant access permission to all pipelines** option, unless you want to manage
    access to the service connection separately for each pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – Service connection details for SonarQube](img/B18875_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – Service connection details for SonarQube
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Service connections are an easy and centralized way to define the credentials
    needed to communicate with a service outside of Azure DevOps, removing the need
    to enter credentials everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Azure Pipeline to analyze your code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step is to include two tasks available that are in the SonarQube extension
    in your build pipeline. Let’s look at the following pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `SonarQubePrepare` task is needed to provide the context necessary to perform
    the analysis, for which the service connection, scanner mode, and project key
    in SonarQube must be provided. This task must be placed before any compilation
    tasks are executed.
  prefs: []
  type: TYPE_NORMAL
- en: The `SonarQubeAnalyze` task is responsible for performing the security scan
    and must be placed after all tasks that compile code. It will use the information
    collected since the execution of the `SonarQubePrepare` task to perform all necessary
    data collection and analysis for the security scan. This task will fail the pipeline
    if it does not pass the conditions defined in the SonarQube project.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing SonarQube analysis results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The results of the security scan will be available in the SonarQube portal.
    Depending on the nature of your project, you will get different quality indicators
    and recommendations to improve your code, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – SonarQube analysis results](img/B18875_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – SonarQube analysis results
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to use the `SonarQubePublish` task to include a brief summary
    and link to the full report in your Azure Pipeline summary. However, this is only
    available for paid tiers of SonarQube.
  prefs: []
  type: TYPE_NORMAL
- en: SonarQube will provide you with insights regarding bugs, vulnerabilities, security
    hotspots, duplication of code, and many other issues that might be present in
    code, helping the developers solve these by finding them and providing instructions
    on how to best fix them.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating this type of tool into your pipelines provides a fast feedback loop
    for developers to fix and mitigate risks in the applications early in the development
    process and avoid costly mistakes if those were deployed to a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Pipelines can also be used to orchestrate the deployment of **artifacts**
    created in other systems, such as the popular CI/CD tool **Jenkins**. We’ll look
    at this in detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with Jenkins for artifacts and release pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will walk through a simple setup demonstrating how to connect
    Azure Pipelines and Jenkins so that you can download an artifact generated in
    Jenkins and deploy it via release pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: A **Jenkins Job** is like an Azure Pipeline, an automated set of steps that
    executes actions and can produce artifacts or perform deployments. Let’s learn
    how to create a simple Jenkins job.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Jenkins job that produces an artifact
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This scenario assumes that we have a project called `PacktFamily` in a Jenkins
    server, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – A Jenkins instance with a PackFamily project](img/B18875_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 – A Jenkins instance with a PackFamily project
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration for the Jenkins job is very simple in this scenario, solely
    to demonstrate the ability the download an artifact on the Azure Pipelines side.
    The following figure shows the build steps for producing `artifact.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14 – The build step in a Jenkins job for creating the artifact](img/B18875_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 – The build step in a Jenkins job for creating the artifact
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the post-build actions for `artifact.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15 – Post-build action publishing the Jenkins artifact](img/B18875_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.15 – Post-build action publishing the Jenkins artifact
  prefs: []
  type: TYPE_NORMAL
- en: 'The execution of the Jenkins job will yield a single artifact that can be downloaded
    by Azure Pipelines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16 – Jenkins job results and artifacts](img/B18875_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.16 – Jenkins job results and artifacts
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a Jenkins job, let’s learn how to integrate Azure Pipelines
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a service connection to Jenkins in Azure DevOps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This process is similar to what we discussed in the *Creating a service connection
    to SonarQube in Azure DevOps* section. In Azure DevOps’ project settings, click
    on the `Jenkins` and click **Next**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17 – The New service connection dialogue](img/B18875_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.17 – The New service connection dialogue
  prefs: []
  type: TYPE_NORMAL
- en: 'Provide the **Server URL**, **Username**, **Password**, and **Service connection
    name** details. Don’t forget to check the **Grant access permission to all pipelines**
    box if needed. Finally, click the **Verify and save** button to proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.18 – The New Jenkins service connection dialog](img/B18875_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.18 – The New Jenkins service connection dialog
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can proceed to create a pipeline that will use the artifact.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a release pipeline to use Jenkins artifacts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, it is time to configure a release pipeline. You can follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to **Project** | **Pipelines** | **Releases** and click **New release
    pipeline**. You will have the option to select a template, as shown in the following
    screenshot. We will start with an **empty job**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.19 – Selecting a template for a release pipeline](img/B18875_06_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.19 – Selecting a template for a release pipeline
  prefs: []
  type: TYPE_NORMAL
- en: 'By clicking on the **Add an artifact** widget and then the **Jenkins** option,
    you will be able to use the previously created service connection to pick the
    project in Jenkins from where you will use artifacts. Just pick the service connection
    that matches the name you created in the previous step and then the corresponding
    **Source (****job)** option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.20 – Adding a Jenkins artifact to a release pipeline](img/B18875_06_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.20 – Adding a Jenkins artifact to a release pipeline
  prefs: []
  type: TYPE_NORMAL
- en: You have the option to change the **Source alias** detail, which will be used
    as the directory where you can download artifacts once the pipeline executes.
    This is important when you have multiple artifacts from potentially different
    sources, to avoid any files from being overwritten when the pipeline executes.
    In this case, the default value will work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we’ve done this, we can add steps to the **Deploy** stage to verify and
    even print out the content of the artifact. Clicking on the **1 job, 0 task**
    option in the **Deploy** stage will allow us to customize the pipeline. For this
    scenario, we will use a Linux agent. Clicking on the **Agent job** option, as
    shown in the following screenshot, gives us access to the **Agent selection**
    section. Now, we can select **Azure Pipelines** from the **Agent pool** dropdown
    and **ubuntu latest** from the **Agent Specification** dropdown within the **Agent**
    **selection** section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.21 – Selecting an agent in the Deploy stage](img/B18875_06_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.21 – Selecting an agent in the Deploy stage
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve done this, click on the **+** button on the right-hand side of
    the **Agent Job** section to look up the **Command line** task to add it. This
    task can execute a custom script in the agent and will switch to the appropriate
    underlying process, depending on the operating system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.22 – The command-line task to list the contents of the artifact](img/B18875_06_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.22 – The command-line task to list the contents of the artifact
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the script we used to show the contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This script will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: List the contents of the current directory, which should be where the agent
    is running the current pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move into the directory where the Jenkins artifacts were downloaded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List the contents of the current directory, which should be where the Jenkins
    artifacts were downloaded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print a label indicating the contents of the file that will be displayed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print the contents of the `artifact.txt` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you’ve saved the pipeline and created a release to execute it, you should
    be able to see that it effectively downloads the artifacts from Jenkins and lists
    the contents of the file, as shown in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.23 – The logs of the pipeline downloading Jenkins artifacts](img/B18875_06_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.23 – The logs of the pipeline downloading Jenkins artifacts
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The **Azure Pipelines** option in the **Agent selection** section provides access
    to Microsoft-hosted agents. These are managed by the Azure DevOps platform without
    you needing to manage the underlying infrastructure. Several operating systems
    are supported and different versions also include different tools already installed
    in them to facilitate building and deploying applications. You also have the option
    to purchase parallel jobs capacity so that you can run multiple jobs at the same
    time. If needed, you can also install any required software in these agents during
    the pipeline’s execution. Just remember that these will increase the execution
    time.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we’ve completed this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the extensibility model of Azure DevOps and
    how the marketplace of extensions makes it extremely easy to find additional features
    to include in your build and release pipelines with ease. This will speed up your
    ability to create build and release pipelines and integrate them with other tools.
    We also learned how to increase the quality of our applications by integrating
    automated tests and security scans to alert developers in case something breaks
    or introduces a vulnerability, which will reduce the amount of time needed to
    find bugs, fix them, and reduce security risks before you deploy your applications
    to the final production environments. Then, we learned how to integrate Azure
    Pipelines to download artifacts from another CI/CD tool and use it for deployment,
    which can be useful in hybrid setups where not all teams are using the same CI/CD
    tools. Finally, we learned about the flexibility of the Microsoft-hosted agents
    that are available in Azure Pipelines. This allows you to implement your CI/CD
    needs without having to manage the infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about monitoring Azure DevOps Pipelines,
    an important task that will ensure everything is working correctly and that if
    things go wrong, we get the visibility needed to fix them promptly.
  prefs: []
  type: TYPE_NORMAL
