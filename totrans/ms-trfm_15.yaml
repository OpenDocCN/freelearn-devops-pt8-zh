- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Go Serverless on Google Cloud – Building Solutions with Google Cloud Functions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Google Cloud上实现无服务器计算 – 使用Google Cloud Functions构建解决方案
- en: We are almost there! In this chapter, we will build the last of the nine solutions
    we’ll build in this book. We are about to close the door on Google Cloud—but only
    after we take the final step of transitioning our application to serverless architecture
    as we did on AWS and Azure. In the previous two chapters, we worked hard to implement
    our solution on Google Cloud using virtual machines and then containers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快要完成了！在本章中，我们将构建本书中将要构建的九个解决方案中的最后一个。我们即将关闭Google Cloud的大门——但只有在我们完成将应用程序迁移到无服务器架构的最后一步之后，就像我们在AWS和Azure上所做的那样。在前两章中，我们努力使用虚拟机和容器在Google
    Cloud上实现了解决方案。
- en: We’ve taken time to make some comparisons between how things work across all
    three cloud platforms to help us understand the subtle and sometimes not-so-subtle
    differences between them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们花时间对比了三大云平台之间的工作方式，帮助我们理解它们之间的微妙差异，有时候甚至是那些不那么微妙的差异。
- en: We’ve noticed that while our Terraform code has been changing pretty consistently
    between cloud platforms, our application code and the operating system configuration—either
    in Packer or Docker—haven’t. As we take our final step with Google Cloud, we’ll
    be going through a similar process to the one we went through when we transitioned
    our application to AWS Lambda and Azure Functions. We’ll have to completely refactor
    the application code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到，虽然我们的Terraform代码在不同的云平台之间发生了持续变化，但我们的应用程序代码和操作系统配置——无论是在Packer还是Docker中——并没有发生变化。当我们完成在Google
    Cloud上的最后一步时，我们将经历与当初将应用程序迁移到AWS Lambda和Azure Functions时类似的过程。我们将不得不完全重构应用程序代码。
- en: 'The chapter covers the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Laying the foundation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 奠定基础
- en: Designing the solution
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计解决方案
- en: Building the solution
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建解决方案
- en: Automating the deployment
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化部署
- en: Laying the foundation
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 奠定基础
- en: Our skilled team had just finished putting the finishing touches on the final
    ConfigMap in our Kubernetes configuration when they received a not-so-surprising
    telephone call. Keyser seems to have had yet another epiphany, this time while
    hanging out with Larry Page.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经验丰富的团队刚刚完成了Kubernetes配置中最后一个ConfigMap的最终调整，接到了一通不那么意外的电话。看起来Keyser似乎又有了灵感，这次是在与Larry
    Page一起闲逛时。
- en: While walking through Larry’s private terminal at San Jose International Airport
    to his personal Boeing 767 waiting for them, Keyser and Larry were discussing
    Keyser’s new venture. Larry mentioned in passing, *“Keyser, why are you even investing
    in infrastructure? These days, everybody is going serverless. Focus on your platform.
    Let Google Cloud focus on how to* *scale it.”*
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在走过Larry的私人终端，前往他等待的个人波音767时，Keyser和Larry讨论了Keyser的新业务。Larry顺便提到，*“Keyser，你为什么要投资基础设施呢？现在大家都在做无服务器计算。专注于你的平台，让Google
    Cloud专注于如何* *扩展它。”*
- en: '*“Eureka!”* exclaimed Keyser, as he tossed a few warm cashews into his mouth
    before elaborating. *“Oh man, Larry, you’re so right! I need to get my team on
    this right away! What was I thinking? We don’t have time for the plumbing; we
    need to move fast to stay ahead of* *the competition!”*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*“尤里卡！”* Keyser大叫道，嘴里塞了一些温暖的腰果后接着说道，*“哦天啊，Larry，你说得太对了！我需要立即让我的团队着手这个！我当时在想什么呢？我们没有时间做管道工作；我们需要快速行动，保持领先于*
    *竞争对手！”*'
- en: Back at headquarters, the team is adapting to this exciting yet sudden change
    in direction. Now, thanks to Keyser’s bold new strategy, they’re gearing up to
    dive deep into serverless computing. This shift will require more than just repackaging
    the application—they’ll have to completely refactor the code!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 回到总部，团队正在适应这个激动人心却又突如其来的方向变化。现在，得益于Keyser大胆的新战略，他们正准备深入探索无服务器计算。这一转变不仅仅需要重新包装应用程序——他们必须完全重构代码！
- en: Designing the solution
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计解决方案
- en: 'In this section, we will look at the overall design of our solution given the
    shift from virtual machine- and container-based architectures toward serverless
    architectures. As we saw in previous transformations, serverless at its core has
    the quintessential objective of eliminating heavy infrastructure from the stack.
    Therefore, we will be looking for ways to shed any Google Cloud services that
    require significant fixed costs, such as **virtual machines** or **Kubernetes
    clusters**, and replace them with serverless options. This change in our operational
    context and our technology landscape will likely require us to rethink some things
    about our solution, including its design, implementation, and deployment strategy:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将考虑解决方案的整体设计，考虑到从虚拟机和基于容器的架构转向无服务器架构的变化。正如我们在之前的转型中所见，无服务器的核心目标是从堆栈中去除繁重的基础设施。因此，我们将寻找替代方案，剔除任何需要显著固定成本的Google
    Cloud服务，例如**虚拟机**或**Kubernetes集群**，并用无服务器选项替代。我们操作环境和技术架构的这种变化可能会让我们重新思考解决方案的一些方面，包括其设计、实现和部署策略：
- en: '![Figure 15.1 – The logical architecture for the autonomous vehicle platform](img/B21183_15_1.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.1 – 自动驾驶平台的逻辑架构](img/B21183_15_1.jpg)'
- en: Figure 15.1 – The logical architecture for the autonomous vehicle platform
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.1 – 自动驾驶平台的逻辑架构
- en: 'While our application’s architecture doesn’t change significantly, we will
    use different Google Cloud services to host it. In this case, we’ll be using Google
    Cloud Storage to host the application’s frontend, and we’ll be using Google Cloud
    Functions to host the application’s backend, as illustrated in *Figure 15**.2*:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们应用的架构没有发生显著变化，但我们将使用不同的Google Cloud服务来托管它。在这种情况下，我们将使用Google Cloud Storage来托管应用的前端，并使用Google
    Cloud Functions来托管应用的后端，如*图15.2*所示：
- en: '![Figure 15.2 – The source control structure of our repository](img/B21183_15_2.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.2 – 我们仓库的源代码控制结构](img/B21183_15_2.jpg)'
- en: Figure 15.2 – The source control structure of our repository
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.2 – 我们仓库的源代码控制结构
- en: 'In this solution, we’ll have four parts of our code base: Terraform code that
    provisions the environment, GitHub Actions code that executes the deployment process,
    and the two code bases for our application’s frontend and backend.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个解决方案中，我们将有四部分代码库：用于配置环境的Terraform代码、执行部署过程的GitHub Actions代码，以及应用前端和后端的两部分代码库。
- en: Cloud architecture
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 云架构
- en: In [*Chapter 13*](B21183_13.xhtml#_idTextAnchor569), our cloud-hosting solution
    was a set of dedicated virtual machines, and in [*Chapter 14*](B21183_14.xhtml#_idTextAnchor605),
    it was a set of shared virtual machines within our Kubernetes cluster’s node pool.
    Using virtual machines has the most sunk cost, whether they are standalone virtual
    machines or part of a Kubernetes node pool.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第13章*](B21183_13.xhtml#_idTextAnchor569)中，我们的云托管解决方案是一组专用的虚拟机，而在[*第14章*](B21183_14.xhtml#_idTextAnchor605)中，它是我们Kubernetes集群节点池中的一组共享虚拟机。使用虚拟机会产生最大程度的沉没成本，无论它们是独立的虚拟机还是Kubernetes节点池的一部分。
- en: 'In [*Chapter 14*](B21183_14.xhtml#_idTextAnchor605), our entire solution was
    executed on containers that allowed the frontend and the backend to coexist as
    a set of containers on the same virtual machine. This saved some money, but we
    still needed servers to host the workload. In this chapter, we have a new objective:
    take advantage of the power of the cloud by leveraging cloud-native services that
    abstract the underlying infrastructure from us and allow us to truly pay for only
    what we use. Google Cloud’s serverless offerings will be crucial to us in this
    endeavor.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第14章*](B21183_14.xhtml#_idTextAnchor605)中，我们的整个解决方案是在容器上执行的，这些容器使前端和后端能够作为一组容器共存在同一虚拟机上。这节省了一些费用，但我们仍然需要服务器来托管工作负载。在这一章中，我们有一个新的目标：通过利用云原生服务来发挥云计算的优势，这些服务将底层基础设施从我们身上抽象出来，让我们真正只为我们使用的部分付费。Google
    Cloud的无服务器服务将在这个过程中对我们至关重要。
- en: Frontend
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前端
- en: In previous chapters, we hosted our frontend on public-facing servers that return
    the HTML and JavaScript that composed our web application, and we still required
    a cloud-hosted solution to host the files and respond to requests.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们将前端托管在面向公众的服务器上，这些服务器返回组成我们Web应用的HTML和JavaScript，我们仍然需要一个云托管的解决方案来托管文件并响应请求。
- en: However, due to the nature of the web application running within the end user’s
    browser, we really don’t need to use cloud-hosted virtual machines to host what
    are essentially flat files. We can use simple cloud storage to host the frontend
    as a static website and rely on the cloud platform to shoulder the burden of returning
    the web content.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于网页应用在最终用户的浏览器中运行的特性，我们实际上不需要使用云托管的虚拟机来托管本质上是平面文件的内容。我们可以使用简单的云存储来托管前端作为静态网站，并依赖云平台来承担返回网页内容的工作。
- en: 'We can use the Google Cloud Storage service on Google Cloud. This service allows
    us to host static web content that is internet accessible. As we did on AWS and
    Azure in previous chapters, most of this functionality is achieved by adding a
    **Storage bucket** and enabling it to host web content. However, unlike how we
    handled this on AWS and Azure, we need to add our own load balancer to ensure
    our web application functions properly, as illustrated in *Figure 15**.3*:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Google Cloud 上使用 Google Cloud Storage 服务。该服务允许我们托管可以通过互联网访问的静态网页内容。正如我们在前几章中对
    AWS 和 Azure 所做的那样，所有这些功能通过添加一个**存储桶**并启用其托管网页内容来实现。然而，与我们在 AWS 和 Azure 上处理的方式不同，我们需要添加自己的负载均衡器，以确保我们的网页应用正常运行，正如*图
    15.3*所示：
- en: '![Figure 15.3 – Google Cloud Storage handles web page requests while Google
    Cloud Functions handles REST API requests](img/B21183_15_3..jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.3 – Google Cloud Storage 处理网页请求，而 Google Cloud Functions 处理 REST API
    请求](img/B21183_15_3..jpg)'
- en: Figure 15.3 – Google Cloud Storage handles web page requests while Google Cloud
    Functions handles REST API requests
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.3 – Google Cloud Storage 处理网页请求，而 Google Cloud Functions 处理 REST API 请求
- en: As we saw on other platforms, we will gain a huge advantage because Google Cloud
    Storage has absolutely no sunk costs. When you create a Google Cloud Storage bucket,
    it costs you absolutely zero dollars ($0) per month. Like other serverless offerings,
    it uses a set of microtransactions to measure your activity and charge you for
    precisely what you use. In Google Cloud Storage, this can be a bit complicated
    as there are several measurements that incur costs.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在其他平台上看到的，我们将获得巨大的优势，因为 Google Cloud Storage 完全没有沉没成本。当你创建一个 Google Cloud
    Storage 存储桶时，每月的费用为零美元（$0）。像其他无服务器服务一样，它通过一系列微交易来衡量你的活动，并按你实际使用的量收费。在 Google Cloud
    Storage 中，这可能有些复杂，因为有几个衡量指标会产生费用。
- en: '*Table 15.1* shows all the costs you will run into when using Google Cloud
    Storage to host your static websites:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 15.1* 显示了你在使用 Google Cloud Storage 托管静态网站时可能遇到的所有费用：'
- en: '| **Metric** | **Unit** | **Scale** | **Price** |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **度量** | **单位** | **规模** | **价格** |'
- en: '| Storage | GBs | 1,000 | $0.023 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 存储 | GB | 1,000 | $0.023 |'
- en: '| Write Transactions | Transactions | 1,000 | $0.01 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 写入事务 | 事务 | 1,000 | $0.01 |'
- en: '| Read Transactions | Transactions | 1,000 | $0.0004 |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 读取事务 | 事务 | 1,000 | $0.0004 |'
- en: Table 15.1 – Google Cloud Storage micro-transactional pricing
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15.1 – Google Cloud Storage 微交易定价
- en: Note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The prices listed are, at the time of writing, for Google Cloud’s West US 2
    region. Prices may have changed by the time you are reading this, so it’s best
    to check the latest prices for the most accurate cost estimation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文撰写时，所列出的价格适用于 Google Cloud 的西部美国 2 区域。到你阅读本文时，价格可能已经发生变化，因此最好查看最新价格以获取最准确的成本估算。
- en: I included these prices to make a point. We can host a static website on a three-node
    Kubernetes cluster for approximately $300 a month, or we can host a static website
    on Google Cloud Storage for less than $0.01 a month on the most rock-solid storage
    tier that Google Cloud has to offer. Which approach would you choose?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我列出这些价格是为了强调一个观点。我们可以在一个三节点的 Kubernetes 集群上托管一个静态网站，每月大约需要 $300，或者我们可以在 Google
    Cloud Storage 上托管一个静态网站，每月费用不到 $0.01，并且使用的是 Google Cloud 提供的最稳定的存储层。你会选择哪种方式？
- en: Backend
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后端
- en: 'Like our frontend, in previous chapters, our backend was also hosted on virtual
    machines in two different ways: dedicated virtual machines and shared virtual
    machines within the node pool on our Kubernetes cluster.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的前端一样，在前几章中，我们的后端也托管在虚拟机上，采用两种不同的方式：专用虚拟机和在 Kubernetes 集群节点池中的共享虚拟机。
- en: Unlike our frontend, our backend doesn’t have the option of running entirely
    client-side inside the end user’s web browser. In the backend, we have custom
    code that needs to run on a server. Therefore, we need to find a solution to host
    these components without all the overhead of a fleet of virtual machines. On Google
    Cloud, we can use Google Cloud Functions to accomplish this. Google Cloud Functions
    is a managed service that allows you to deploy your code without paying the sunk
    costs for any of the underlying virtual machines. Like Google Cloud Storage, it
    has its own micro-transactional pricing model that charges you for precisely what
    you use.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的前端不同，我们的后端不能完全在最终用户的 Web 浏览器内以客户端方式运行。在后端，我们有需要在服务器上运行的自定义代码。因此，我们需要找到一种解决方案来托管这些组件，而不需要使用一整套虚拟机带来的额外开销。在
    Google Cloud 上，我们可以使用 Google Cloud Functions 来实现这一点。Google Cloud Functions 是一种托管服务，允许你部署代码而无需支付任何基础虚拟机的沉没成本。像
    Google Cloud Storage 一样，它有自己的微交易定价模型，根据你实际使用的量收费。
- en: '*Table 15.2* shows what costs that you will incur when deploying your code
    to Google Cloud Functions:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 15.2* 显示了将代码部署到 Google Cloud Functions 时可能产生的费用：'
- en: '| **Metric** | **Unit** | **Scale** | **Price** |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **指标** | **单位** | **规模** | **价格** |'
- en: '| Compute | GHz/s | 1 | $0.00001 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 计算 | GHz/s | 1 | $0.00001 |'
- en: '| Memory | GB/s | 1 | $0.0000025 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 内存 | GB/s | 1 | $0.0000025 |'
- en: '| Total Executions | Transactions | 1,000,000 | $0.40 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 总执行次数 | 交易 | 1,000,000 | $0.40 |'
- en: Table 15.2 – Google Cloud Functions microtransactions pricing
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15.2 – Google Cloud Functions 微交易定价
- en: The first thing that you’ll probably notice is that, like Google Cloud Storage,
    these prices are extremely small but they measure a very small amount of activity
    on the platform.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能首先注意到的是，像 Google Cloud Storage 一样，这些价格非常低，但它们衡量的是平台上非常小的一部分活动。
- en: 'For example, the **compute** and **memory** metrics have units that correspond
    to that resource’s unit of measure per second. For compute metrics, it’s measured
    in GHz per second, and for memory metrics, it’s measured in GB per second. These
    units of measurement give you the flexibility to adjust the amount of compute
    and memory resources your cloud functions have access to when they are executed.
    Given that it measures at a *per second* interval, you don’t have to be running
    your Google Cloud Functions very long to rack up quite a few of these. *Figure
    15**.4* shows Google Cloud Functions deploying the application code to Google
    Cloud Storage:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，**计算**和**内存**指标的单位对应于该资源每秒的度量单位。计算指标的单位是每秒 GHz，内存指标的单位是每秒 GB。这些度量单位使你能够在执行时灵活调整云函数可以访问的计算和内存资源量。由于它是以*每秒*为间隔进行度量的，因此你无需长时间运行
    Google Cloud Functions，就能产生相当多的费用。*图 15.4* 展示了 Google Cloud Functions 将应用程序代码部署到
    Google Cloud Storage：
- en: '![Figure 15.4 – Google Cloud Functions runs the application code which is deployed
    to Google Cloud Storage](img/B21183_15_4..jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.4 – Google Cloud Functions 运行应用程序代码，该代码被部署到 Google Cloud Storage](img/B21183_15_4..jpg)'
- en: Figure 15.4 – Google Cloud Functions runs the application code which is deployed
    to Google Cloud Storage
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.4 – Google Cloud Functions 运行应用程序代码，该代码被部署到 Google Cloud Storage
- en: Previously, our ASP.NET REST API was set up using a traditional ASP.NET project
    that used Controllers to implement the REST API endpoints. However, when transitioning
    to Google Cloud Functions, this solution structure is incompatible with the Google
    Cloud Functions framework. In order to be able to host our REST API as Google
    Cloud Functions, we need to conform to the framework that Cloud Functions dictates.
    This means that the ASP.NET controller classes will need to be refactored to conform
    to this standard. In the next section, we’ll delve into the code that makes this
    possible.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们的 ASP.NET REST API 是通过传统的 ASP.NET 项目设置的，该项目使用控制器实现 REST API 端点。然而，在过渡到
    Google Cloud Functions 时，这种解决方案结构与 Google Cloud Functions 框架不兼容。为了能够将我们的 REST
    API 托管为 Google Cloud Functions，我们需要遵循 Cloud Functions 所规定的框架。这意味着，ASP.NET 控制器类需要重构以符合这一标准。在下一节中，我们将深入探讨实现这一点的代码。
- en: Deployment architecture
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署架构
- en: Now that we have a good idea of what our cloud architecture for our solution
    on Google Cloud will look like, we need to devise a plan for provisioning our
    environments and deploying our code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对在 Google Cloud 上的解决方案的云架构有了清晰的了解，我们需要制定一个计划来配置环境并部署代码。
- en: 'In [*Chapter 12*](B21183_12.xhtml#_idTextAnchor543), when we deployed our application
    to virtual machines, we baked our compiled application code into a virtual machine
    image using Packer:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第12章*](B21183_12.xhtml#_idTextAnchor543)中，当我们将应用程序部署到虚拟机时，我们使用Packer将编译后的应用程序代码打包成虚拟机镜像：
- en: '![Figure 15.5 – The deployment process for virtual machines using Packer-built
    virtual machine images](img/B21183_15_5..jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图15.5 – 使用Packer构建的虚拟机镜像进行虚拟机部署过程](img/B21183_15_5..jpg)'
- en: Figure 15.5 – The deployment process for virtual machines using Packer-built
    virtual machine images
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5 – 使用Packer构建的虚拟机镜像进行虚拟机部署过程
- en: 'Similarly, in [*Chapter 13*](B21183_13.xhtml#_idTextAnchor569), when we deployed
    our application to containers on our Kubernetes cluster, we baked our application
    code into container images using Docker:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在[*第13章*](B21183_13.xhtml#_idTextAnchor569)中，当我们将应用程序部署到Kubernetes集群上的容器时，我们使用Docker将应用程序代码打包成容器镜像：
- en: '![Figure 15.6 – The deployment process for Kubernetes using Docker-built container
    images](img/B21183_15_6..jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图15.6 – 使用Docker构建的容器镜像进行Kubernetes部署过程](img/B21183_15_6..jpg)'
- en: Figure 15.6 – The deployment process for Kubernetes using Docker-built container
    images
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.6 – 使用Docker构建的容器镜像进行Kubernetes部署过程
- en: With serverless, this completely changes because Google Cloud’s serverless offerings
    abstract away the operating system. This means that all we are responsible for
    is producing a compatible deployment package.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用无服务器架构时，情况完全改变，因为Google Cloud的无服务器服务抽象化了操作系统。这意味着我们需要负责的仅仅是生成兼容的部署包。
- en: Creating the deployment package
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建部署包
- en: 'As discussed in the previous section, we have two components of our application:
    the frontend and the backend. Each has a different deployment target. For the
    frontend, we are going to be deploying as a static website, while the backend
    is going to be deployed as a Google Cloud function. Since both are .NET projects,
    we will be using both .NET and Google Cloud Platform-specific tools in order to
    create deployment packages and deploy them to their target Google Cloud services.
    The following diagram shows the process we go through to provision our environment,
    package our application code, and deploy it to the target environment in Google
    Cloud:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，我们的应用程序有两个组件：前端和后端。它们有不同的部署目标。对于前端，我们将作为静态网站进行部署，而后端将作为Google Cloud函数进行部署。由于这两者都是.NET项目，我们将使用.NET和Google
    Cloud平台特定的工具来创建部署包并将其部署到目标Google Cloud服务。下图展示了我们为配置环境、打包应用程序代码并将其部署到Google Cloud目标环境的整个过程：
- en: '![Figure 15.7 – The deployment pipeline to build our .NET application code
    for deployment to Google Cloud](img/B21183_15_7..jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图15.7 – 构建我们的.NET应用程序代码并部署到Google Cloud的部署管道](img/B21183_15_7..jpg)'
- en: Figure 15.7 – The deployment pipeline to build our .NET application code for
    deployment to Google Cloud
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.7 – 构建我们的.NET应用程序代码并部署到Google Cloud的部署管道
- en: 'For the frontend, this means enabling the feature to deploy our ASP.NET Blazor
    web application as WebAssembly. This will allow the frontend to be hosted as a
    static website that can run completely client-side without any server-side rendering.
    This is only possible because of the way we have designed our frontend web application,
    which uses HTML, CSS, and JavaScript to interact with server-side REST APIs. It’s
    important to note that ASP.NET Blazor supports both hosting options, but we specifically
    chose to go down the client-side-only path and eliminate any dependency on server-side
    page rendering. As a result, when we use the .NET CLI to publish our ASP.NET Blazor
    project, it will emit a folder containing static web content. Then, using a Google
    Cloud CLI, we can upload the contents of this folder to our Google Cloud Storage
    bucket to complete the deployment, as shown in *Figure 15**.8*:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前端，这意味着启用将我们的ASP.NET Blazor Web应用程序部署为WebAssembly的功能。这将允许前端作为静态网站托管，完全在客户端运行，而无需任何服务器端渲染。之所以能够实现这一点，是因为我们设计前端Web应用程序的方式，它使用HTML、CSS和JavaScript与服务器端REST
    API进行交互。需要注意的是，ASP.NET Blazor支持两种托管选项，但我们特别选择了仅客户端路径，并消除了对服务器端页面渲染的任何依赖。因此，当我们使用.NET
    CLI发布我们的ASP.NET Blazor项目时，它将生成一个包含静态Web内容的文件夹。然后，使用Google Cloud CLI，我们可以将该文件夹的内容上传到我们的Google
    Cloud Storage桶中以完成部署，如*图15.8*所示：
- en: '![Figure 15.8 – The deployment process for Google Cloud Functions using custom-built
    deployment packages](img/B21183_15_8..jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图15.8 – 使用自定义构建的部署包进行Google Cloud Functions部署过程](img/B21183_15_8..jpg)'
- en: Figure 15.8 – The deployment process for Google Cloud Functions using custom-built
    deployment packages
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.8 – 使用自定义构建部署包部署Google Cloud Functions的过程
- en: 'For the backend, unlike on AWS and Azure, the application code on Google Cloud
    shouldn’t be compiled as it needs to be processed by Google Cloud Functions. This
    means the actual source code files need to be uploaded as opposed to the compiled
    artifacts, as we have done previously. Therefore, we must zip the source code
    folder into a ZIP archive. Another major difference is that the Terraform provider
    for Google Cloud requires this zip archive to be uploaded by Terraform:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于后端，与AWS和Azure不同，Google Cloud上的应用代码不应该被编译，因为它需要由Google Cloud Functions处理。这意味着需要上传实际的源代码文件，而不是以前我们做过的已编译的构件。因此，我们必须将源代码文件夹压缩为ZIP归档文件。另一个主要的不同之处在于，Google
    Cloud的Terraform提供程序要求此ZIP归档文件由Terraform上传：
- en: '![Figure 15.9 – The GitFlow process to create new versioned artifacts](img/B21183_15_9..jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图15.9 – GitFlow流程创建新的版本化构件](img/B21183_15_9..jpg)'
- en: Figure 15.9 – The GitFlow process to create new versioned artifacts
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.9 – GitFlow流程创建新的版本化构件
- en: 'This process will integrate nicely with the GitFlow process discussed in [*Chapter
    6*](B21183_06.xhtml#_idTextAnchor330). With each new feature we develop, we’ll
    open a new feature branch, and when we’re ready to integrate our updates with
    the main body of work, we’ll submit a pull request:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程将与[*第6章*](B21183_06.xhtml#_idTextAnchor330)中讨论的GitFlow流程很好地结合。在我们开发每一个新特性时，我们将打开一个新的特性分支，当我们准备好将更新合并到主要工作中时，我们将提交一个拉取请求：
- en: '![Figure 15.10 – GitFlow process to create new versioned artifacts](img/B21183_15_10..jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图15.10 – GitFlow流程创建新的版本化构件](img/B21183_15_10..jpg)'
- en: Figure 15.10 – GitFlow process to create new versioned artifacts
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.10 – GitFlow流程创建新的版本化构件
- en: This pull request will trigger GitHub Actions that run built-in quality checks
    on our application code and run a `terraform plan` to evaluate the impact on our
    long-lived environments. We can do any number of tests before the code is merged,
    which is good to verify that our updates–both to the application code and to the
    infrastructure code– won’t negatively impact our target environment. Once our
    pull request is approved and merged, it will trigger additional GitHub Actions
    that will apply the changes to the target environment.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个拉取请求将触发GitHub Actions，运行内置的质量检查，检查我们的应用代码，并运行`terraform plan`来评估对我们长期运行环境的影响。在代码合并之前，我们可以进行任意数量的测试，这有助于验证我们的更新——无论是应用代码还是基础设施代码——都不会对目标环境产生负面影响。一旦我们的拉取请求被批准并合并，它将触发额外的GitHub
    Actions，应用更改到目标环境。
- en: Now that we have a solid plan for implementing both the cloud architecture using
    Google Cloud Platform and the deployment architecture using GitHub Actions, let’s
    start building! In the next section, we’ll break down the **HashiCorp Configuration
    Language** (**HCL**) code that we use to implement Terraform, and we’ll look at
    the application code changes we need to make to get our application up and running
    using Google Cloud Functions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个完善的计划，来实现使用Google Cloud Platform的云架构和使用GitHub Actions的部署架构，让我们开始构建吧！在下一节中，我们将分解我们用来实现Terraform的**HashiCorp配置语言**（**HCL**）代码，并查看我们需要对应用代码进行的更改，以便通过Google
    Cloud Functions使我们的应用程序上线。
- en: Building the solution
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建解决方案
- en: Now that we have a solid design for our solution, we can begin building it.
    As we discussed in the previous section, because we’ll be using Google Cloud’s
    serverless offerings such as Google Cloud Storage and Google Cloud Functions to
    host our application, we will need to make some changes to our application code.
    This is something that we have never had to do in *Chapters 13* and *14*, as we
    were able to deploy our application to the cloud by packaging it in either a virtual
    machine image (using Packer) or in a container image (using Docker). Therefore,
    in order to build our solution, we need to write some Terraform and make updates
    to our application code in C#.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个坚实的解决方案设计，我们可以开始构建它。正如我们在前一节中讨论的，因为我们将使用Google Cloud的无服务器服务（如Google
    Cloud Storage和Google Cloud Functions）来托管我们的应用，因此我们需要对应用代码做一些更改。这是我们在*第13章*和*第14章*中从未遇到过的事情，因为我们曾通过将应用打包成虚拟机镜像（使用Packer）或容器镜像（使用Docker）来部署我们的应用到云中。因此，为了构建我们的解决方案，我们需要编写一些Terraform代码，并对我们的应用代码进行C#更新。
- en: Terraform
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Terraform
- en: 'As we discussed in our design, our solution comprises two application components:
    the frontend and the backend. Each has its own application codebase that needs
    to be deployed. Unlike previous chapters, where we also had operating system configuration,
    now that we are using serverless offerings, this is no longer our responsibility
    as the platform takes care of it for us:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在设计中讨论的那样，我们的解决方案包括两个应用组件：前端和后端。每个组件都有自己的应用代码库需要部署。不同于之前的章节，我们不再需要操作系统配置，因为现在我们正在使用无服务器服务，平台会替我们处理这部分：
- en: '![Figure 15.11 – A Google Cloud Functions resource structure](img/B21183_15_11..jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.11 – 谷歌云函数资源结构](img/B21183_15_11..jpg)'
- en: Figure 15.11 – A Google Cloud Functions resource structure
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.11 – 谷歌云函数资源结构
- en: Much of the Terraform setup is very similar to what we have done in previous
    chapters so we will only focus on new resources needed for our solution. You can
    check the full source code for this book, which is available on GitHub, if you
    want to work with the complete solution.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分的 Terraform 设置与之前的章节非常相似，因此我们只关注解决方案所需的新资源。如果您希望使用完整的解决方案，请查看本书的完整源代码，这些代码可以在
    GitHub 上找到。
- en: Frontend
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前端
- en: As we saw in previous chapters, when working with Google Cloud, we need to activate
    the required Google APIs to provision resources to our new project. For the frontend,
    we will mainly use Google Cloud Storage, but we also need a `compute.googleapis.com`
    API.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的章节中看到的，在使用谷歌云时，我们需要激活所需的谷歌 API 来为新项目提供资源。对于前端，我们主要将使用谷歌云存储，但我们还需要 `compute.googleapis.com`
    API。
- en: 'First, we need to provision a Google Cloud Storage bucket to which we can deploy
    our frontend. However, we need to configure our Google Cloud Storage bucket differently
    using an optional block called `website` to enable the static websites feature:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为前端部署一个谷歌云存储桶。但是，我们需要使用一个名为 `website` 的可选块来不同配置我们的谷歌云存储桶，以启用静态网站功能：
- en: '[PRE0]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To allow anonymous internet traffic to access the content stored within the
    bucket, we need to set up a binding with the Identity and Access Management service.
    This will grant `allUsers` access to view objects within the storage bucket:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许匿名的互联网流量访问存储桶中存储的内容，我们需要与身份和访问管理服务设置绑定。这将授予 `allUsers` 访问权限以查看存储桶内的对象：
- en: '[PRE1]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In previous chapters, we’ve set up Google Cloud Load Balancing, which establishes
    a load balancer as the frontend and allows you to configure many different types
    of backends:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们已经设置了谷歌云负载均衡，该负载均衡器作为前端并允许配置多种不同类型的后端：
- en: '![Figure 15.12 – Google Cloud Load Balancing routes traffic to the Frontend
    hosted on Google Cloud Storage](img/B21183_15_12..jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.12 – 谷歌云负载均衡将流量路由到托管在谷歌云存储上的前端](img/B21183_15_12..jpg)'
- en: Figure 15.12 – Google Cloud Load Balancing routes traffic to the Frontend hosted
    on Google Cloud Storage
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.12 – 谷歌云负载均衡将流量路由到托管在谷歌云存储上的前端
- en: 'In this case, the backend for the load balancer becomes extremely simple; it’s
    just a Google Cloud Storage bucket:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，负载均衡器的后端变得非常简单；它只是一个谷歌云存储桶：
- en: '[PRE2]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The Google Cloud Storage bucket needs to be set up as the backend for the load
    balancer, which will allow traffic to be routed to the appropriate location.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌云存储桶需要设置为负载均衡器的后端，这将允许流量路由到适当的位置。
- en: Backend
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后端
- en: Our Backend will be hosted on Google Cloud Functions, so we need to enable `logging.googleapis.com`
    to allow Google Cloud Functions’ telemetry to be accessible from the Google Cloud
    console.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的后端将托管在谷歌云函数上，因此我们需要启用 `logging.googleapis.com`，以便从谷歌云控制台访问谷歌云函数的遥测数据。
- en: As we discussed in the previous section, Google Cloud Functions requires our
    source code to be uploaded, not compiled artifacts; this is because of the way
    Google Cloud Functions handles the packaging of our application on our behalf.
    As a result, this creates a dependency on `cloudbuild.googleapis.com`, which Google
    Cloud Functions uses to create a packaged artifact based on the source code we
    upload.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节讨论的那样，谷歌云函数要求我们上传源代码，而不是编译后的工件；这是由于谷歌云函数处理我们应用程序包装的方式所造成的。因此，这创建了对 `cloudbuild.googleapis.com`
    的依赖，谷歌云函数使用它来基于我们上传的源代码创建打包工件。
- en: For our Google Cloud Functions to execute, we need two additional Google APIs,
    the Cloud Run API (i.e., `run.googleapis.com`) and the Cloud Functions API (i.e.,
    `cloudfunctions.googleapis.com`). Google Cloud Functions is a layer built onto
    the Cloud Run API that provides an additional layer of abstraction and additional
    capabilities to create event-driven workflows, while the Cloud Run API provides
    a foundational service to run stateless containers that are invocable via HTTP
    requests.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的 Google Cloud Functions 执行，我们需要两个额外的 Google API：Cloud Run API（即 `run.googleapis.com`）和
    Cloud Functions API（即 `cloudfunctions.googleapis.com`）。Google Cloud Functions
    是建立在 Cloud Run API 之上的一层，提供了额外的抽象层和更多功能来创建事件驱动的工作流，而 Cloud Run API 提供了一个基础服务来运行无状态容器，这些容器可以通过
    HTTP 请求进行调用。
- en: 'Google Cloud Functions have a rather simple deployment model. Like AWS Lambda,
    you must declare a resource for the function itself. The resource has two main
    configuration components—the build and service configurations—as shown here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cloud Functions 拥有相对简单的部署模型。像 AWS Lambda 一样，您必须声明一个资源来为函数本身提供支持。该资源有两个主要的配置组件——构建配置和服务配置——如下所示：
- en: '[PRE3]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The build configuration controls the type of execution runtime (e.g., Python,
    Java, or .NET), the entry point in the application code, and the location in storage
    where the application code can be found:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 构建配置控制执行运行时的类型（例如，Python、Java 或 .NET）、应用程序代码中的入口点，以及可以找到应用程序代码的存储位置：
- en: '[PRE4]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The service configuration controls how many resources the cloud function has
    access to when invoked. Consequently, this configuration is also the primary driver
    of costs:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 服务配置控制云函数在被调用时可以访问多少资源。因此，这个配置也是成本的主要驱动因素：
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The service configuration block also allows you to set environment variables
    that can be used to pass non-sensitive configuration settings to the cloud function:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 服务配置块还允许你设置环境变量，供云函数用来传递非敏感的配置设置：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Secrets management
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 密钥管理
- en: As we saw in previous chapters, we can only provision secrets using Google Cloud
    Secrets Manager once we have enabled the `secretmanager.googleapis.com` API.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前几章看到的，我们只有在启用了 `secretmanager.googleapis.com` API 后，才能使用 Google Cloud
    Secrets Manager 配置密钥。
- en: 'First, we need to define the secret with a unique secret identifier that we
    can use to look up the secret’s value from our application code. If we are building
    multi-region deployments, we can also set the regions to which we want this secret
    replicated:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定义一个带有唯一密钥标识符的密钥，以便我们可以从应用代码中查找密钥的值。如果我们正在构建多区域部署，我们还可以设置希望将此密钥复制到的区域：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As we saw with the `aws` provider in earlier chapters, the secret is just a
    placeholder, a unique way to look up our secret’s value. We need to create versions
    of our secret to store the actual secret value:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面章节中看到的 `aws` 提供程序，密钥只是一个占位符，一种查找密钥值的独特方式。我们需要创建密钥的版本来存储实际的密钥值：
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After provisioning the secret and a version of our secret, we can access it
    from our Google Cloud Functions. There are two methods for injecting our secrets
    into our cloud function; the first is using environment variables:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置好密钥和密钥版本后，我们可以从 Google Cloud Functions 中访问它。注入密钥到云函数中有两种方法；第一种是使用环境变量：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code demonstrates how we can add a secret to the service configuration
    block of our cloud function to inject our secrets stored in the Google Secret
    Manager device using the secret’s identifier.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码演示了我们如何将一个密钥添加到云函数的服务配置块中，利用密钥的标识符将存储在 Google Secret Manager 中的密钥注入到云函数中。
- en: 'The second approach is probably more secure as it avoids exposing the secret
    within the process’ environment:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法可能更安全，因为它避免了将密钥暴露在进程的环境中：
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code shows how to set a mount point within the filesystem and
    drop the secret’s value there using the secret’s identifier.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码演示了如何在文件系统中设置挂载点，并使用密钥的标识符将密钥值存放在那里。
- en: Application code
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序代码
- en: 'Google Cloud Functions are inherently event-based. Each cloud function is triggered
    by a different type of event from a wide variety of Google Cloud services. For
    the purposes of this book, we’ll focus on the HTTP trigger only, but if you are
    interested, I’d recommend you go check out all the other options that Google Cloud
    Functions has—it’s quite extensive:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cloud Functions 天生是基于事件的。每个云函数都由来自多种 Google Cloud 服务的不同类型事件触发。为了本书的目的，我们将仅关注
    HTTP 触发器，但如果你有兴趣，我建议你查看 Google Cloud Functions 提供的所有其他选项——它们非常广泛：
- en: '![Figure 15.13 – ASP.NET MVC controller class anatomy](img/B21183_15_13..jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.13 – ASP.NET MVC 控制器类结构](img/B21183_15_13..jpg)'
- en: Figure 15.13 – ASP.NET MVC controller class anatomy
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.13 – ASP.NET MVC 控制器类结构
- en: In a traditional ASP.NET REST API solution, you have controller classes that
    embody a specific route and then methods that implement different operations at
    that route. The controller class needs to be decorated with an `ApiController`
    attribute informing the ASP.NET runtime that this class should be used to process
    incoming web requests at the route specified in the `Route` attribute.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的 ASP.NET REST API 解决方案中，你会有控制器类，它代表一个特定的路由，然后方法在该路由上实现不同的操作。控制器类需要用 `ApiController`
    属性修饰，以告知 ASP.NET 运行时该类应该用于处理指定 `Route` 属性中路由的传入 Web 请求。
- en: Each method is decorated with an attribute that denotes which HTTP verb the
    method should respond to. In the preceding example, we use `HttpGet`, but there
    are corresponding attributes for each of the supported HTTP Verbs. The method
    can take strongly typed parameters that can either be part of the route, the Query
    String, or the request body. The method returns `IActionResult` by default, which
    allows us to return different data structures depending on the outcome of the
    request.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法都用一个属性修饰，表示该方法应该响应哪种 HTTP 动词。在前面的示例中，我们使用 `HttpGet`，但也有对应的属性用于每个支持的 HTTP
    动词。方法可以接收强类型参数，这些参数可以是路由的一部分、查询字符串的一部分或请求体的一部分。方法默认返回 `IActionResult`，这使我们能够根据请求的结果返回不同的数据结构。
- en: 'In order to implement a REST API using Azure Functions, we need to implement
    a class using the Azure Function SDK. This requires us to slightly adjust how
    we implement both our class and our method. We will employ different class and
    method attributes in order to achieve a similar outcome, defining an endpoint
    that responds to web requests at a specific route:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 Azure Functions 实现一个 REST API，我们需要使用 Azure Function SDK 来实现一个类。这要求我们稍微调整实现类和方法的方式。我们将采用不同的类和方法属性，以便实现类似的结果，定义一个端点，在特定路由下响应
    Web 请求：
- en: '![Figure 15.14 – Google Cloud Functions class anatomy](img/B21183_15_14..jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.14 – Google Cloud Functions 类结构](img/B21183_15_14..jpg)'
- en: Figure 15.14 – Google Cloud Functions class anatomy
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.14 – Google Cloud Functions 类结构
- en: Google Cloud Functions has a very simple method for integrating with the underlying
    cloud service that drives the runtime. The only requirement is to implement the
    `IHttpFunction` interface. This interface has a single requirement to implement
    a method called `HandleAsync` that takes an `HttpContext` object as its only parameter.
    There is no return object. Therefore, the only way we have to respond to the client
    is by writing to the response object that is accessible from the `HttpContext`
    object.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cloud Functions 有一个非常简单的集成底层云服务驱动运行时的方法。唯一的要求是实现 `IHttpFunction` 接口。该接口只有一个要求，即实现一个名为
    `HandleAsync` 的方法，该方法以 `HttpContext` 对象作为唯一参数。没有返回对象。因此，我们唯一能响应客户端的方式是通过向可以从 `HttpContext`
    对象访问的响应对象写入数据。
- en: As we can see, the cloud architecture radically simplifies, but one trade-off
    is that our backend code needs to be adapted to the Google Cloud Functions framework.
    This will require development and testing efforts in order to transform our code
    base into this new hosting model. This stands in stark contrast to what we explored
    in previous chapters, where we hosted on virtual machines or containerized and
    hosted on a Kubernetes cluster. While conforming to the Google Cloud Functions
    model does take work, its benefits are twofold. First, it allows us to take advantage
    of near-zero sunk cost, and second, it allows us to fully abstract the underlying
    infrastructure from us and let Google Cloud Platform take care of scalability
    and high availability. This allows us to focus more on the functionality of our
    solutions rather than the plumbing of managing the underlying infrastructure.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，云架构大大简化了，但一个权衡是我们的后端代码需要适应 Google Cloud Functions 框架。这将需要开发和测试工作，以便将我们的代码库转变为这种新的托管模型。这与我们在前几章中探索的内容形成鲜明对比，前几章我们是在虚拟机上托管，或将应用容器化并托管在
    Kubernetes 集群上。虽然遵循 Google Cloud Functions 模型确实需要付出一些努力，但它的好处是双重的。首先，它让我们能够利用几乎为零的沉没成本；其次，它使我们能够完全抽象掉底层基础设施，由
    Google Cloud Platform 负责可扩展性和高可用性。这使我们可以更多地专注于解决方案的功能性，而不是管理底层基础设施的繁杂工作。
- en: Now that we have implemented Terraform to provision our solution and made changes
    to our application code to conform it to the Google Cloud Functions framework,
    in the next section, we’ll dive into YAML and Bash and implement the GitHub Actions
    workflows.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经实现了Terraform来配置我们的解决方案，并修改了应用程序代码以使其符合Google Cloud Functions框架。在下一节中，我们将深入探讨YAML和Bash，并实现GitHub
    Actions工作流。
- en: Automating the deployment
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化部署
- en: As we discussed in the previous section, serverless offerings such as Google
    Cloud Functions and Google Cloud Storage abstract away the operating system configuration.
    Therefore, when we deploy, we only need an application package that is compatible
    with the target platform. In this section, we’ll create an automation pipeline
    using GitHub Actions that will provision our application to its new serverless
    home in Google Cloud.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中讨论的那样，像Google Cloud Functions和Google Cloud Storage这样的无服务器产品抽象了操作系统配置。因此，当我们进行部署时，只需要一个与目标平台兼容的应用程序包。在本节中，我们将使用GitHub
    Actions创建一个自动化管道，将我们的应用程序部署到Google Cloud的全新无服务器环境中。
- en: Terraform
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Terraform
- en: 'The first thing that we need to do is to provision our environment to Google
    Cloud. This is going to be extremely similar to the way we did this in the previous
    chapters. In [*Chapter 13*](B21183_13.xhtml#_idTextAnchor569), we needed to ensure
    that our virtual machine images were built and available before we executed Terraform
    because the Terraform code base referenced the virtual machine images when it
    provisioned the virtual machines. This means that with our virtual machine architecture,
    application deployment happens before Terraform provisions the environment, as
    shown in *Figure 15**.15*:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是将我们的环境配置到Google Cloud。这将与我们在前几章中做的非常相似。在[*第13章*](B21183_13.xhtml#_idTextAnchor569)中，我们需要确保在执行Terraform之前，我们的虚拟机镜像已经构建并可用，因为Terraform代码基在配置虚拟机时引用了这些虚拟机镜像。这意味着，采用虚拟机架构时，应用程序部署发生在Terraform配置环境之前，如*图15.15*所示：
- en: '![Figure 15.15 – Packer-produced virtual machine images are a prerequisite
    for Terraform](img/B21183_15_15..jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图15.15 – Packer生成的虚拟机镜像是Terraform的先决条件](img/B21183_15_15..jpg)'
- en: Figure 15.15 – Packer-produced virtual machine images are a prerequisite for
    Terraform
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.15 – Packer生成的虚拟机镜像是Terraform的先决条件
- en: 'In [*Chapter 14*](B21183_14.xhtml#_idTextAnchor605), we provisioned our Kubernetes
    cluster using **Google Kubernetes Engine** (**GKE**) without such a prerequisite.
    In fact, the application deployment occurred after the Kubernetes cluster was
    online. This means that with container-based architecture, application deployment
    happens after Terraform provisions the environment:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第14章*](B21183_14.xhtml#_idTextAnchor605)中，我们使用**Google Kubernetes Engine**
    (**GKE**)来配置我们的Kubernetes集群，且没有这样的先决条件。实际上，应用程序部署是在Kubernetes集群上线后进行的。这意味着，采用基于容器的架构时，应用程序部署是在Terraform配置环境后进行的：
- en: '![Figure 15.16 – Docker-produced container images are provisioned to Kubernetes
    after Terraform executes](img/B21183_15_16..jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图15.16 – Docker生成的容器镜像在Terraform执行后被配置到Kubernetes](img/B21183_15_16..jpg)'
- en: Figure 15.16 – Docker-produced container images are provisioned to Kubernetes
    after Terraform executes
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.16 – Docker生成的容器镜像在Terraform执行后被配置到Kubernetes
- en: 'When using Google Cloud’s serverless offerings, the deployment process is split.
    While both the frontend and backend of our application need a deployment package
    to be created, the way they are deployed is different. For the frontend, like
    on other platforms, we simply generate static web content. However, for the backend,
    due to Google Cloud Functions’ unique approach to packaging and deployment, we
    need to generate a ZIP archive with the application’s source code itself. These
    artifacts share a similar purpose to Docker images in that they are a target service-compatible
    way of packaging our application for deployment, as shown in *Figure 15**.17*:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Google Cloud的无服务器产品时，部署过程被拆分。虽然我们的应用程序的前端和后端都需要创建部署包，但它们的部署方式是不同的。对于前端，像在其他平台一样，我们只是生成静态网页内容。然而，针对后端，由于Google
    Cloud Functions在打包和部署方面的独特方法，我们需要生成一个包含应用程序源代码的ZIP归档文件。这些工件与Docker镜像的用途相似，它们是符合目标服务的应用程序打包方式，以便部署，如*图15.17*所示：
- en: '![Figure 15.17 – The ZIP archive with the source code acts as the deployment
    artifacts that are provisioned to Google Cloud when Terraform executes](img/B21183_15_17..jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图15.17 – 带有源代码的ZIP归档作为部署工件，当Terraform执行时，会被配置到Google Cloud](img/B21183_15_17..jpg)'
- en: Figure 15.17 – The ZIP archive with the source code acts as the deployment artifacts
    that are provisioned to Google Cloud when Terraform executes
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.17 – 包含源代码的 ZIP 存档作为部署文件，在 Terraform 执行时被部署到 Google Cloud
- en: As you can see, the backend deployment looks very similar to the approach used
    with the virtual-machine-based architecture. The Terraform code references the
    packaged artifact and is responsible for deploying it to the Google Cloud Functions
    that it provisions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，后端部署与基于虚拟机架构的方法非常相似。Terraform 代码引用打包好的部署文件，并负责将其部署到它所配置的 Google Cloud Functions
    中。
- en: Deployment
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署
- en: Now that Terraform has provisioned the Google Cloud infrastructure we need for
    our serverless solution, we need to take the final step of deploying both deployment
    artifacts to the appropriate locations in Google Cloud.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 既然 Terraform 已经为我们的无服务器解决方案配置好了所需的 Google Cloud 基础设施，接下来我们需要完成最后一步，将部署文件部署到
    Google Cloud 的适当位置。
- en: We will use .NET and Google Cloud custom tools to produce the artifacts and
    deploy the frontend. However, the backend will be provisioned by Terraform.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 .NET 和 Google Cloud 自定义工具生成部署文件并部署前端。然而，后端将由 Terraform 配置。
- en: Frontend
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前端
- en: 'As we saw in other chapters, our .NET application code needs to follow a continuous
    integration process where the code is built and tested using automated unit testing
    and other built-in quality controls. Nothing changes there, except that we need
    to add some special handling to the deployment artifact that these processes produce
    to ensure it is available to our GitHub Actions job that deploys the workload
    to the appropriate location:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在其他章节中所见，我们的 .NET 应用程序代码需要遵循持续集成过程，在该过程中代码会通过自动化单元测试和其他内建的质量控制进行构建和测试。这里没有变化，唯一的不同是我们需要对这些流程生成的部署文件进行一些特别处理，以确保它能够供负责将工作负载部署到适当位置的
    GitHub Actions 作业使用：
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We need to ensure that we authenticate with Google Cloud and target the right
    Google Cloud project with the right Google Cloud Storage bucket. The Google Cloud
    command-line tool that we are using is called `gsutil`. It can be configured to
    obtain credentials in several ways, but it is probably the safest to specify the
    path to a Google Cloud credentials file. We can use the GitHub Actions secret
    to generate a file that we then reference when we call `gsutil`. Once done, we
    can execute `gsutil` to recursively upload all the files within the staging directory.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保与 Google Cloud 进行身份验证，并将目标设置为正确的 Google Cloud 项目以及正确的 Google Cloud Storage
    存储桶。我们使用的 Google Cloud 命令行工具叫做 `gsutil`。它可以通过多种方式进行配置以获取凭证，但最安全的做法是指定 Google Cloud
    凭证文件的路径。我们可以使用 GitHub Actions 密钥生成一个文件，然后在调用 `gsutil` 时引用该文件。完成后，我们可以执行 `gsutil`
    来递归上传暂存目录中的所有文件。
- en: Backend
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后端
- en: 'In order to deploy the Google Cloud function, we need to modify our Terraform
    to provision a location for the zip archive to be uploaded to and specify the
    ZIP archive containing the source code of our application code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了部署 Google Cloud function，我们需要修改我们的 Terraform 配置，以便为要上传的 ZIP 存档指定位置，并指定包含应用程序源代码的
    ZIP 存档：
- en: '[PRE12]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After the Google Cloud Storage bucket has been provisioned, we must upload
    the deployment package:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Google Cloud Storage 存储桶配置完成后，我们必须上传部署包：
- en: '[PRE13]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding code will reference the `deployment.zip` file in Terraform’s root
    directory and upload it to the Google Cloud Storage bucket.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将引用 Terraform 根目录中的 `deployment.zip` 文件，并将其上传到 Google Cloud Storage 存储桶。
- en: That’s it! Now, our application has been fully deployed to Google Cloud Functions!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在，我们的应用程序已经完全部署到 Google Cloud Functions！
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we designed, built, and automated the deployment of a complete
    end-to-end solution using serverless architecture using Google Cloud Functions.
    To accomplish this, we finally had to make some major changes to our application
    code to conform to the requirements of the serverless runtime. When adopting serverless
    offerings, one must make this distinct and considerable decision, as it tightly
    couples your application code with the target cloud platform.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们设计、构建并自动化了一个完整的端到端解决方案，使用了基于 Google Cloud Functions 的无服务器架构。为了实现这一目标，我们最终不得不对应用程序代码进行一些重大更改，以符合无服务器运行时的要求。在采用无服务器产品时，必须做出这个明确且重要的决定，因为它将你的应用程序代码与目标云平台紧密耦合。
- en: As we conclude this chapter and this Google Cloud-centric narrative, we have
    successfully implemented cloud architectures on three different cloud platforms—**Amazon
    Web Services** (**AWS**), Microsoft Azure, and Google Cloud Platform.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章以及以 Google Cloud 为中心的叙述时，我们已经成功地在三个不同的云平台上实现了云架构——**亚马逊 Web 服务**（**AWS**）、微软
    Azure 和 Google Cloud Platform。
- en: Throughout our journey with our enigmatic CEO, Keyser Söze, we saw many similarities
    that cross from one cloud platform to another, but we also saw distinct differences
    between the cloud platforms, spanning from small naming convention differences,
    design and implementation variations up to large structural changes within the
    entire taxonomy of the cloud platforms. In addition to exploring these three cloud
    platforms, we witnessed the journey that many organizations face when navigating
    their journey to the cloud—whether to stick with what they know or to leap into
    new capabilities and service offerings that pose challenges due to the learning
    curve while also granting potential opportunities to streamline operations and
    better take advantage of the economies of scale that the public cloud has to offer.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在与神秘的 CEO Keyser Söze 一起的旅程中，我们看到许多从一个云平台到另一个云平台的相似之处，但我们也看到各云平台之间的显著差异，从小的命名约定差异、设计和实现变动，到整个云平台分类法中的大规模结构性变化。除了探索这三个云平台外，我们还见证了许多组织在云迁移过程中所面临的挑战——是坚持使用他们熟悉的技术，还是跳入新功能和服务，这些新服务虽然面临学习曲线带来的挑战，但也为简化运营并更好地利用公共云的规模经济提供了潜在的机会。
- en: In the next chapter, we’ll switch gears and look at the distinct challenges
    when we aren’t starting from scratch but trying to adapt existing environments
    and architectures to bring them into an infrastructure-as-code world.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将转换话题，探讨当我们不是从零开始，而是尝试将现有环境和架构适配到基础设施即代码（Infrastructure-as-Code）世界时所面临的独特挑战。
- en: 'Part 6: Day 2 Operations and Beyond'
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6部分：第2天操作及以后
- en: In this part, we explore the challenges and common pitfalls when working with
    existing environments using Terraform, either importing existing environments
    that were provisioned initially outside of Terraform or managing environments
    long-term with Terraform.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中，我们将探讨使用 Terraform 时，操作现有环境时的挑战和常见陷阱，既包括导入最初通过 Terraform 之外的方式创建的现有环境，也包括使用
    Terraform 长期管理环境。
- en: 'This part has the following chapters:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 16*](B21183_16.xhtml#_idTextAnchor665), *Already Provisioned? Strategies
    for Importing Existing Environments*'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第16章*](B21183_16.xhtml#_idTextAnchor665)，*已经部署？导入现有环境的策略*'
- en: '[*Chapter 17*](B21183_17.xhtml#_idTextAnchor700), *Managing Production Environments
    with Terraform*'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第17章*](B21183_17.xhtml#_idTextAnchor700)，*使用 Terraform 管理生产环境*'
- en: '[*Chapter 18*](B21183_18.xhtml#_idTextAnchor740), *Looking Ahead – Certification,
    Emerging Trends, and Next Steps*'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第18章*](B21183_18.xhtml#_idTextAnchor740)，*展望未来——认证、 emerging trends 和下一步*'
