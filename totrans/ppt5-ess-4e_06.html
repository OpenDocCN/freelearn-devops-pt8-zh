<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">The Puppet Beginners Advanced Parts</h1>
                </header>
            
            <article>
                
<p>After our in-depth discussions on both the manifest structure elements (class and define) and encompassing structure (modules), you are in a great position to write manifests for all of your agents. Make sure that you get Forge modules that will allow them to do your work for you. Then go ahead and add site-specific modules that implement Forge modules to your needs. Finally, you will have composite classes for the <kbd>node</kbd> blocks to be used, or rather, included.</p>
<p>These concepts are quite a bit to take in. It's now time to decelerate a bit, lean back, and tackle simpler code structures and ideas. You are about to learn some techniques that you are not going to need every day. They can make difficult scenarios much easier, though. So, it might be a good idea to come back to this chapter again after you have spent some time in the field. You might find that some of your designs can be simplified with these tools.</p>
<p>Specifically, these are the techniques that will be presented:</p>
<ul>
<li>Building dynamic configuration files</li>
<li>Managing file snippets</li>
<li>Using virtual resources</li>
<li>Cross-node configuration with exported resources</li>
<li>Setting defaults for resource parameters</li>
<li>Avoiding antipatterns</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building dynamic configuration files</h1>
                </header>
            
            <article>
                
<p>In the introduction, I stated that the techniques that you are now learning are not frequently required. That was true, except for this one topic. Templates are actually a cornerstone of configuration management with Puppet.</p>
<p>Templates are an alternative way to manage configuration files, or any files really. You have synchronized files from the master to an agent that handled some Apache configuration settings. These are not templates, technically. They are merely static files that have been prepared and are ready for carbon copying.</p>
<p>These static files suffice in many situations, but sometimes, you will want the master to manage very specific configuration values for each agent. These values can be quite individual. For example, an Apache server usually requires a <kbd>MaxClients</kbd> setting. Appropriate values depend on many aspects, including hardware specifications and characteristics of the web application that is being run. It would be impractical to prepare all possible choices as distinct files in the module.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning the template syntax</h1>
                </header>
            
            <article>
                
<p>Templates make short work of such scenarios. With Puppet 4 EPP (embedded Puppet) templates were introduced. The older ERB (embedded Ruby) templates are still available and fully functional. If you know your way around PHP or JSP, you will quickly get the hang of EPP or ERB Puppet templates. The following EPP template will produce <kbd>Hello,world!</kbd> three times:</p>
<pre>&lt;% [1,2,3].each  |$p| { %&gt; 
Hello, world! 
&lt;% } %&gt; </pre>
<p>The following ERB template does the same:</p>
<pre>&lt;% (1 .. 3).each  do %&gt; 
Hello, world! 
&lt;% end %&gt; </pre>
<p>This template will also produce lots of empty lines, because the text between the <kbd>&lt;%</kbd> and <kbd>%&gt;</kbd> tags gets removed from the output but the final line breaks do not. To make the EPP engine do just that, change the closing tag to <kbd>-%&gt;</kbd>:</p>
<pre>&lt;% [1,2,3].each |$p| { -%&gt; 
Hello, world! 
&lt;% } -%&gt; </pre>
<p>This example is not very helpful for configuration files, of course. To include dynamic values in the output, enclose Ruby expressions in a <kbd>&lt;%=tag</kbd> pair:</p>
<pre>&lt;% [1,2,3].each  |$index|  { -%&gt; 
Hello, world #&lt;%= $index %&gt; ! 
&lt;% } -%&gt; </pre>
<p>Now, the iterator value is part of each line of the output. You can also use member variables that are prefixed with the <kbd>$</kbd> sign and use the full namespace to the variable.</p>
<p>These variables are populated with the values from the Puppet manifest variables:</p>
<pre>&lt;IfModule mpm_worker_module&gt; 
ServerLimit         &lt;%= $apache::apache_server_limit %&gt; 
StartServers        &lt;%= $apache::apache_start_servers %&gt; 
MaxClients          &lt;%= $apache::apache_max_clients %&gt; 
&lt;/IfModule&gt; 
&lt;% $apache::apache_ports.each  |$port| { -%&gt; 
Listen &lt;%= $port %&gt; 
NameVirtualHost *:&lt;%= $port %&gt; 
&lt;% } -%&gt; </pre>
<p>Variables that are used in a template must be defined in the same scope or scopes from which the template is used. The next section explains how this works.</p>
<p>In Puppet 3.x, variable values are mostly strings, arrays, or hashes. To write efficient templates, it is helpful to occasionally glance at the methods available for the respective Ruby classes. In Puppet 4, variables have more diverse values.</p>
<p>There are several ways to use Puppet variables in ERB templates:</p>
<ul>
<li>Prefixing the variable with the <kbd>@</kbd> sign: This means that the variable is global, or it was defined in the same class where the template is used. This works with Puppet 2.7, Puppet 3, and Puppet 4</li>
<li>Using the <kbd>scope.lookupvar('variablewithscopename')</kbd> function: This allows you to refer to any variable in any class of the module. Please do not look up variables in other modules; it will build an invisible dependency on the other module. The syntax works with Puppet 2, Puppet 3, and Puppet 4</li>
<li>Using <kbd>scope['variablewithscope']</kbd>: In Puppet 3, the scope hash can be used directly. The behavior is similar to <kbd>scope.lookupvar</kbd>. This will work with Puppet 3 and Puppet 4</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using templates in practice</h1>
                </header>
            
            <article>
                
<p class="mce-root">Templates have their own place in modules. You can place them freely in the <kbd>templates/</kbd> subtree of the module. The <kbd>epp</kbd> function locates them using a simple descriptor: <kbd>epp('cacti/apache/cacti.conf.epp')</kbd></p>
<p>This expression evaluates the content of the template found in <kbd>modules/cacti/templates/apache/cacti.conf.epp</kbd>. The first path element (without a leading slash) is the module name. The rest of the path gets translated to the <kbd>templates/</kbd> tree in the module. The function is commonly used to generate the value of a <kbd>file</kbd> resource's <kbd>content</kbd> property:</p>
<pre>file { '/etc/apache2/conf.d/cacti.conf':  
  content =&gt; epp('cacti/apache/cacti.conf.epp'),  
}  </pre>
<p>Many templates expect some variables to be defined in their scope. The easiest way to make sure that this happens is to wrap the respective <kbd>file</kbd> resource in a parameterized container. Files that are <strong>singletons</strong> with a well-known name, such as <kbd>/etc/ssh/sshd_config</kbd>, should be managed through a parameterized class. Configuration items that can inhabit multiple files, such as <kbd>/etc/logrotate.d/*</kbd>Â or <kbd>/etc/apache2/conf.d/*</kbd>, are well suited to being wrapped in defined types:</p>
<pre>define logrotate::conf(<br/>  String $pattern,<br/>  Integer $max_days=7,<br/>  Array $options=[]<br/>) {<br/>  file { "/etc/logrotate.d/$name": <br/>    ensure  =&gt; file,<br/>    mode    =&gt; '0644', <br/>    content =&gt; epp('logrotate/config-snippet.epp',<br/>      {<br/>        'pattern'  =&gt; $pattern,<br/>        'max_days' =&gt; $max_days,<br/>        'options'  =&gt; $options,<br/>      },) <br/>  }<br/>}</pre>
<p>There is one main difference between EPP templates in classes compared to EPP templates in defines. EPP templates in classes can directly use the class variables with the namespace. A defined resource type does not have a fixed namespace. Therefore, it is required to add a mapping hash to the <kbd>epp</kbd> function, where we specify the variable inside the template and the corresponding variable inside the define.</p>
<p>Afterwards, one can use the variables directly inside the template (<kbd>$pattern, $max_days, $options</kbd>).</p>
<p>For a quick and dirty string transformation of your data, you can also use the <kbd>inline_epp</kbd> function in your manifest. This is often found on the right-hand side of a variable assignment:</p>
<pre>$comma_seperated_list = inline_epp('&lt;%= $my_class::my_array * "," %&gt;') </pre>
<p>This example assumes that the <kbd>$my_array</kbd> Puppet variable in the <kbd>my_class</kbd> class holds an array value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Avoiding performance bottlenecks from templates</h1>
                </header>
            
            <article>
                
<p>When using templates, both through the <kbd>epp</kbd> and <kbd>inline_epp</kbd> functions, be aware that each invocation implies a performance penalty for your Puppet master. During the compilation of the catalog, Puppet must initialize the EPP engine for any template it encounters. The EPP evaluation happens in an individual environment that is derived from the respective scope of the <kbd>epp</kbd> function invocation.</p>
<p>It is, therefore, not even important how complex your templates are. If your manifest requires frequent expansion of a very short template, it generates an enormous overhead for each initialization. Especially in the case of an easy <kbd>inline_epp</kbd> function, such as the one mentioned previously, it can be worthwhile to invest some more effort into creating a parser function instead, as seen in <a href="3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>Combining Classes, Configuration Files, and Extensions into Modules</em>. A function can perform variable value transformation without incurring the cumulative penalty.</p>
<p>On the bright side, using templates is quite economic for the agent, who receives the whole textual file content right inside the catalog. There is no need to make an additional call to the master and retrieve file metadata. On a high-latency network, this can be a noticeable saving.</p>
<p>There is no silver bullet here. Don't let the performance implications deter you from turning specific configuration files into templates. Template-based solutions will often make your module more maintainable, which will usually offset performance implications; hardware is constantly getting cheaper, after all. Just don't be wasteful with frequent (and simple) expansions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing file snippets</h1>
                </header>
            
            <article>
                
<p>The next technique that we are going to discuss helps you solve conflicts in your manifests and build some elegant solutions in special situations. This mostly refers to configuration files where one is either not able to manage the whole file or where a file is constructed from different subclasses.</p>
<p>Puppet offers several ways to accomplish this:</p>
<ul>
<li>Single line</li>
<li>Single entry in a section</li>
<li>Building from multiple snippets</li>
<li>Other resource types</li>
</ul>
<p>How do you deal with a configuration file, where a user may add additional content? What we have seen so far is management of complete configuration files, where changes will get reset. But think about the users <kbd>.bashrc</kbd> file, where the system administrator wants to ensure that the user is making use of a specific proxy.</p>
<div class="packt_tip">Normally, one can specify this globally in a <kbd>/etc/profile.d/</kbd> snippet. This is more meant to be a showcase.</div>
<p>Puppet has a specific resource type which is able to manage a single line entry in a configuration file: the <kbd>file_line</kbd> resource type. This resource type is not a core resource type but is delivered by <kbd>stdlib</kbd> module.</p>
<pre>file_line { 'user admin proxy': 
  ensure   =&gt; present, 
  path     =&gt; '/home/admin/.bashrc', 
  line     =&gt; 'export <br/>  http_proxy=http://proxy.domain.com:3127', 
} </pre>
<p>In the previous example, the line will be added at the bottom of the file, if it is missing. If the line is already available, Puppet will not change the file.</p>
<p>Please remember that the <kbd>file_line</kbd> resource type expects that the file is already present on the system. If one is unsure about this, it is best practice to also manage the existence of the file without specifying content or source:</p>
<pre>file { '/home/admin/.bashrc': 
  ensure =&gt; file, 
  owner  =&gt; 'admin', 
  group  =&gt; 'admin', 
  mode   =&gt; '0644', 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Single entry in a section</h1>
                </header>
            
            <article>
                
<p>But what if one needs to configure a line within a configuration file which consists of sections? In this case, it is not a good idea to add the line at the bottom of the file.</p>
<p>This is where the <kbd>ini_setting</kbd> resource type will be helpful. This resource type is not part of Puppet core, but is shipped with <kbd>puppetlabs-inifile</kbd> module.</p>
<pre>ini_setting { 'puppet agent report': 
  ensure  =&gt; present, 
  path    =&gt; '/etc/puppetlabs/puppet/puppet.conf', 
  section =&gt; 'agent', 
  setting =&gt; 'report', 
  value   =&gt; 'true', 
} </pre>
<p>The previous example will check whether the agent section has an entry report <kbd>= true</kbd> and add it if it is missing. If the whole section is not yet there, it will also add the section. If the whole file is missing, the <kbd>ini_setting</kbd> resource type will also create the file.</p>
<p>Normally, the <kbd>ini_setting</kbd> assumes that section names are put into brackets and that the <kbd>=</kbd> sign is used as a setting-value separator.</p>
<p>The resource type allows the adoption of <kbd>section_prefix</kbd> and <kbd>section_suffix</kbd> and <kbd>key_value_separator</kbd>.</p>
<pre>ini_setting { 'ssh config host default':<br/>  ensure              =&gt; present,<br/>  path                =&gt; '/etc/ssh/ssh_config',<br/>  section             =&gt; 'Host *',<br/>  section_prefix      =&gt; '',<br/>  section_suffix      =&gt; '',<br/>  key_value_separator =&gt; ' ',<br/>  setting             =&gt; 'HashKnownHosts',<br/>  value               =&gt; 'true',<br/>}</pre>
<p>This will produce the following output:</p>
<pre>Host * 
HashKnownHosts true </pre>
<p>But managing all single entries in <kbd>ssh_config</kbd> file is very ineffective, as one must provide all single entries within single recourse type declarations. In this specific case, it is feasible to build the configuration file from snippets.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building from multiple snippets</h1>
                </header>
            
            <article>
                
<p>There is one main difference between building a file from snippets compared to the <kbd>file_line</kbd> and <kbd>ini_setting</kbd> resource type. The latter two just manage single entries in a file, whereas managing a file from snippets manages the complete configuration file.</p>
<p>This is very useful if one does not know beforehand how many entries are needed. For example, dynamically scaling haproxy backends or adding backup entries for a database server where the number of databases is yet unknown.</p>
<p>The most common solution for file snippets is theÂ <kbd>puppetlabs-concat</kbd> module. The <kbd>concat</kbd> module needs at least one <kbd>no-noop</kbd> run, as it must manage the <kbd>concat</kbd> script on the nodes. This script is needed to build the final configuration file.</p>
<p>First, it is required to mention to <kbd>concat</kbd> which file it is about to manage:</p>
<pre>concat { 'ssh config':<br/>  ensure =&gt; present,<br/>  path   =&gt; '/etc/ssh/ssh_config',<br/>}</pre>
<p>This prepares <kbd>concat</kbd> to be able to build the file from <kbd>concat_fragments</kbd>. All fragments should be put into a specific order:</p>
<pre>concat::fragment { 'ssh_config header':<br/>  target  =&gt; 'ssh config',<br/>  content =&gt; "# Managed by Pupept\n",<br/>  order   =&gt; '01',<br/>}<br/>concat::fragment { 'default host':<br/>  target =&gt; 'ssh config',</pre>
<pre>   source =&gt; <br/>'puppet:///modules/&lt;modulename&gt;/ssh_config_default host',<br/>   order =&gt; '10',<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using virtual resources</h1>
                </header>
            
            <article>
                
<p>The next technique that we are going to discuss helps you solve conflicts in your manifests and build some elegant solutions in special situations.</p>
<p>Remember the uniqueness constraint that was introduced in <a href="8a22dc0e-3fe2-4153-b60e-935b7e6d9f94.xhtml"><span class="ChapterrefPACKT">Chapter 1</span></a>, <em>Writing Your First Manifests,</em>Â any resource must be declared at most once in a manifest. There cannot be two classes or defined type instances that declare the same <kbd>file</kbd>, <kbd>package</kbd>, or any other type of resource. Each resource must have a unique type/name combination. This applies to instances of defined types as well as native resources.</p>
<p>This can pose issues when multiple modules need a common resource, such as an installed package, or perhaps even independent settings in the same configuration file. A component class for such resources, as introduced in <a href="daf11a18-5de2-4c3c-9880-e9a242ffb35b.xhtml"><span class="ChapterrefPACKT">Chapter 4</span></a>, <em>Combining Resources in Classes and Defined Types</em>, will resolve basic conflicts of this kind. It can be included an arbitrary number of times in the same manifest.</p>
<p>This can be impractical when the number of shared resources is fairly large. Imagine that you find yourself in a situation where a large number of different Puppet nodes require software from a significant set of <kbd>yum</kbd> repositories. Puppet will happily manage the repository configuration on the agents through its <kbd>yumrepo</kbd> type. However, you don't actually want all these repositories configured on every last machine they do incur maintenance overhead, after all. It would, instead, be desirable for each node to automatically receive the configuration for all repositories it requires for its packages, but not more.</p>
<p>When solving this using component classes, you would wrap each repository in a distinct class. The class names should closely resemble (and most likely contain) the name of the respective repositories:</p>
<pre>class yumrepos::team_ninja_stable {<br/>  yumrepo { 'team_ninja_stable': <br/>    ensure =&gt; present, <br/>    ... <br/>  }<br/>}</pre>
<p>Package resources that rely on one or more such repositories will need to be accompanied by appropriate <kbd>include</kbd> statements:</p>
<pre>include yumrepos::team_ninja_stable<br/>include yumrepos::team_wizard_experimental<br/>package { 'doombunnies': <br/>  ensure  =&gt; installed, <br/>  require =&gt; [<br/>    Class['yumrepos::team_ninja_stable'], <br/>    Class['yumrepos::team_wizard_experimental']<br/>  ],<br/>}</pre>
<p>This is possible, but it is less than ideal. Puppet does offer an alternative way to avoid duplicate resource declarations in the form of virtual resources. It allows you to add a resource declaration to your manifest without adding the resource to the actual catalog. The virtual resource must be <strong>realized</strong> or <strong>collected</strong> for this purpose. As with class inclusion, this realization of virtual resources can happen arbitrarily in the same manifest.</p>
<p>Our previous example can, therefore, use a simpler structure with just one class to declare all the <kbd>yum</kbd> repositories as virtual resources with tag parameter set:</p>
<pre>class yumrepos::all { <br/>  @yumrepo { 'tem_ninja_stable':<br/>    ensure =&gt; present,<br/>    tag    =&gt; 'stable',<br/>  }<br/>  @yumrepo { 'team_wizard_experimantel':<br/>    ensure =&gt; present,<br/>    tag    =&gt; 'experimental',<br/>  }<br/>} </pre>
<p>The <kbd>@</kbd> prefix marks the <kbd>yumrepo</kbd> resources as virtual. This class can be safely included by all nodes. It will not affect the catalog until the resources are realized:</p>
<pre>realize(Yumrepo['team_ninja_stable'])<br/>realize(Yumrepo['team_wizard_experimental'])<br/>package { 'doombunnies': <br/>  ensure  =&gt; installed, <br/>  require =&gt; [ <br/>    Yumrepo['team_ninja_stable'], <br/>    Yumrepo['team_wizard_experimental'], <br/>  ], <br/>}  </pre>
<p>The <kbd>realize</kbd> function converts the referenced virtual resources to real ones, which get added to the catalog. Granted, this is not much better than the previous code that relied on the component classes. The virtual resources do make the intent clearer, at least. Realizing them is less ambiguous than some <kbd>include</kbd> statements; a class can contain many resources and even more <kbd>include</kbd> statements.</p>
<div class="packt_infobox">This <kbd>define</kbd> structure is actually possible with component classes as well. The class names can be passed as a parameter or from a central data structure. The <kbd>include</kbd> function will accept variable values for class names.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Realizing resources more flexibly using collectors</h1>
                </header>
            
            <article>
                
<p>Instead of invoking the <kbd>realize</kbd> function, you can also rely on a different syntactic construct, which is the <kbd>collector</kbd>:</p>
<pre>Yumrepo&lt;| title == 'team_ninja_stable' |&gt;<strong> </strong></pre>
<p>This is more flexible than the function call at the cost of a slight performance penalty. It can be used as a reference to the realized resource(s) in certain contexts. For example, you can add ordering constraints with the chaining operator:</p>
<pre>Yumrepo&lt;| title == 'team_ninja_stable' |&gt; -&gt; Class['...']<strong> </strong></pre>
<p>It is even possible to change values of resource attributes during collection. There is a whole section dedicated to such overrides later in this chapter.</p>
<p>As the collector is based on an expression, you can conveniently realize a whole range of resources. This can be quite dynamic sometimes, you will create virtual resources that are already being realized by a rather indiscriminate collector. Let's look at a common example:</p>
<pre>User&lt;| |&gt;<strong> </strong></pre>
<p>With no expression, the collection encompasses all virtual resources of the given type. This allows you to collect them all, without worrying about their explicit titles or attributes. This might seem redundant, because then it makes no sense to declare the resources as virtual in the first place. However, keep in mind that the collector might appear in some select manifests only, while the virtual resources can be safely added to all your nodes.</p>
<p>To be a little more selective, it can be useful to group virtual resources based on their <strong>tags</strong>. We haven't discussed tags yet. Each resource is tagged with several identifiers. Each tag is just a simple string. You can tag a resource manually by defining the <kbd>tag</kbd> metaparameter:</p>
<pre>file { '/etc/sysctl.conf': 
  ensure =&gt; file, 
  tag    =&gt; 'security', 
} </pre>
<p>The named tag is then added to the resource. Puppet implicitly tags all resources with the name of the declaring class, the containing module, and a range of other useful meta information. For example, if your user module divides the <kbd>user</kbd> resources into classes such as <kbd>administrators</kbd>, <kbd>developers</kbd>, <kbd>qa</kbd>, and other roles, you can make certain nodes or classes select all users of a given role with a collection based on the class name tag:</p>
<pre>User&lt;| tag == 'developers' |&gt;<strong> </strong></pre>
<p>Note that the tags actually form an array. The <kbd>==</kbd> comparison will look for the presence of the <kbd>developers</kbd> element in the <kbd>tag</kbd> array in this context. Have a look at another example to make this more clear:</p>
<pre>@user { 'felix':  
  ensure =&gt; present,  
  groups =&gt; [ 'power', 'sys' ],  
} 
User&lt;| groups == 'sys' |&gt; </pre>
<p>This way, you can collect all users who are members of the <kbd>sys</kbd> group.</p>
<p>If you prefer function calls over the more cryptic collector syntax, you can keep using the <kbd>realize</kbd> function alongside collectors. This works without issues. Remember that each resource can be realized multiple times, even in both ways, simultaneously.</p>
<p>If you are wondering, the manifest for a given agent can only realize virtual resources that are declared inside this same agent's manifest. Virtual resources do not leak into other manifests. Consequently, there can be no deliberate transfer of resources from one manifest to another, either. However, there is yet another concept that allows such an exchange; this is described in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cross-node configuration with exported resources</h1>
                </header>
            
            <article>
                
<p>Puppet is commonly used to configure whole clusters of servers or HPC workers. Any configuration management system makes this task very efficient in comparison to manual care. Manifests can be shared between similar nodes. Configuration items that require individual customization per node are modeled individually. The whole process is very natural and direct.</p>
<p>On the other hand, there are certain configuration tasks that do not lend themselves well to the paradigm of the central definition of all states. For example, a cluster setup might include the sharing of a generated key or registering IP addresses of peer nodes as they become available. An automatic setup should include an exchange of such shared information. Puppet can help out with this as well.</p>
<p>This is a very good fit. It saves a metalayer, because you don't need to implement the setup of an information exchange system in Puppet. The sharing is secure, relying on Puppet's authentication and encryption infrastructure. There is logging and central control over the deployment of the shared configuration. Puppet retains its role as the central source for all system details; it serves as a hub for a secure exchange of information.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exporting and collecting resources</h1>
                </header>
            
            <article>
                
<p>Puppet approaches the problem of sharing configuration information among multiple agent nodes by way of exported resources. The concept is simple. The manifest of <strong>node A</strong> can contain one or more resources that are purely virtual and not for realization in the manifest of this <strong>node A</strong>. Other nodes, such as <strong>B</strong> and <strong>C</strong>, can import some or all of these resources. Then, the resources become part of the catalogs of these remote nodes.</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/b0d63641-0c9a-4bd2-8308-29e622d732d8.png"/></div>
<p>The syntax to import and export resources is very similar to that of virtual<br/>
resources. An exported resource is declared by prepending the resource type<br/>
name with two <kbd>@</kbd> characters:</p>
<pre>@@file { 'my-app-psk':  
  ensure  =&gt; file, 
  path    =&gt; '/etc/my-app/psk',  
  content =&gt; 'nwNFgzsn9n3sDfnFANfoinaAEF',  
  tag     =&gt; 'cluster02',  
}<strong> </strong></pre>
<p>The importing manifests collect these resources using an expression, which is again similar to the collection of virtual resources, but with double-angled<br/>
brackets, <kbd>&lt;</kbd> and <kbd>&gt;</kbd>:</p>
<pre>File &lt;&lt;| tag == 'cluster02' |&gt;&gt;<strong> </strong></pre>
<p>Tags are a very common way to take fine-grained control over the distribution of such exported resources.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring the master to store exported resources</h1>
                </header>
            
            <article>
                
<p>The only recommendable way to enable support for exported resources is PuppetDB. It is a REST API that stores different kinds of data that the Puppet master deals with during regular operation in a PostgreSQL database. This includes catalog requests from agents (including their valuable facts), reports from catalog applications, and exported resources.</p>
<p><a href="7cafeeab-0e5c-4848-9eb0-1bae38ed3525.xhtml"><span class="ChapterrefPACKT">Chapter 2</span></a>, <em>Puppet Server and Agents</em>, detailed a manual installation of the master. Let's add the PuppetDB with more style through Puppet! On the Forge, you will find a convenient module that will make this easy:</p>
<pre><strong>puppet module install puppetlabs-puppetdb</strong>  </pre>
<p>On the master node, the setup now becomes a one-line invocation:</p>
<pre><strong>puppet apply -e 'include puppetdb, puppetdb::master::config'</strong></pre>
<p>As our test master uses a nonstandard SSL certificate that is named <kbd>master.example.net</kbd> (instead of its FQDN), it must be configured for <kbd>puppetdb</kbd> as well:</p>
<pre>include puppetdb <br/>class { âpuppetdb::master::configâ: 
         puppetdb_server =&gt; 'master.example.net', 
      } </pre>
<p>The ensuing catalog run is quite impressive. Puppet installs the PostgreSQL backend, the Jetty server, and the actual PuppetDB package, and it configures everything and starts the services up all in one go. After applying this short manifest, you have added a complex piece of infrastructure to your Puppet setup. You can now use exported resources for a variety of helpful tasks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exporting SSH host keys</h1>
                </header>
            
            <article>
                
<p>For homegrown interactions between clustered machines, SSH can be an invaluable tool. File transfer and the remote execution of arbitrary commands is easily possible thanks to the ubiquitous <kbd>sshd</kbd> service. For security reasons, each host generates a unique key in order to identify itself. Of course, such public key authentication systems can only really work with a trust network, or the presharing of public keys.</p>
<p>Puppet can do the latter quite nicely:</p>
<pre>@@sshkey { $::facts['networking']['fqdn']: <br/>  host_aliases =&gt; $::facts['networking']['hostname'], <br/>  key          =&gt; $::facts['sshecdsakey'], <br/>  tag          =&gt; 'san-nyc' <br/>}  </pre>
<p>Interested nodes collect keys with the known pattern:</p>
<pre>Sshkey&lt;&lt;| tag == 'san-nyc' |&gt;&gt;<strong> </strong></pre>
<p>Now, SSH servers can be authenticated through the respective keys that Puppet safely stores in its database. As always, the Puppet master is the fulcrum of security.</p>
<div class="packt_tip">As a matter of fact, some <kbd>ssh</kbd> modules from the Puppet Forge will use this kind of construct to do this work for you.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing hosts files locally</h1>
                </header>
            
            <article>
                
<p>Many sites can rely on a local DNS infrastructure. Resolving names to local IP addresses is easy with such setups. However, small networks, or sites that consist of many independent clusters with little shared infrastructure, will have to rely on names in <kbd>/etc/hosts</kbd> instead.</p>
<p>You can maintain a central hosts file per network cell, or you can make<br/>
Puppet maintain each entry in each hosts file separately. The latter approach has some advantages:</p>
<ul>
<li>Changes are automatically distributed through the Puppet agent network</li>
<li>Puppet copes with unmanaged lines in the hosts files</li>
</ul>
<p>A manually maintained registry is prone to becoming outdated every once in a while. It will also obliterate local additions in any hosts files on the agent machines.</p>
<p>The manifest implementation of the superior approach with exported resources is very similar to the <kbd>sshkey</kbd> example from the previous section:</p>
<pre>@@host { $::facts['networking']['fqdn']:<br/>  ip           =&gt; $::facts['networking']['ipaddress'],<br/>  host_aliases =&gt; [ $::facts['networking']['hostname'] ],<br/>  tag          =&gt; 'nyc-site',<br/>}</pre>
<p>This is the same principle, only now, each node exports its <kbd>$ipaddress</kbd> fact value alongside its name and not a public key. The import also works the same way:</p>
<pre>Host&lt;&lt;| tag == 'nyc-site' |&gt;&gt; </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Automating custom configuration items</h1>
                </header>
            
            <article>
                
<p>Do you remember the Cacti module that you created during the previous chapter? It makes it very simple to configure all monitored devices in the manifest of the Cacti server. However, as this is possible, wouldn't it be even better if each node in your network was registered automatically with Cacti? It's simple: make the devices export their respective <kbd>cacti_device</kbd> resources for the server to collect:</p>
<pre>@@cacti_device { $::facts['networking']['fqdn']: <br/>  ensure =&gt; present, <br/>  ip     =&gt; $::facts['networking']['ipaddress'], <br/>  tag    =&gt; 'nyc-site', <br/>} </pre>
<p>The Cacti server, apart from including the <kbd>cacti</kbd> class, just needs to collect the devices now:</p>
<pre>Cacti_device&lt;&lt;| tag == 'nyc-site' |&gt;&gt;<strong> </strong></pre>
<p>If one Cacti server handles all your machines, you can just omit the <kbd>tag</kbd> comparison:</p>
<pre>Cacti_device&lt;&lt;| |&gt;&gt;<strong> </strong></pre>
<p>Once the module supports other Cacti resources, you can handle them in the same way. Let's look at an example from another popular monitoring solution.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Simplifying the configuration of Nagios</h1>
                </header>
            
            <article>
                
<p>Puppet comes with support to manage the complete configuration of <strong>Nagios</strong> (and compatible versions of <strong>Icinga</strong>). Each configuration section can be represented by a distinct Puppet resource with types such as <kbd>nagios_host</kbd> or <kbd>nagios_service</kbd>.</p>
<p>There is an endeavour to remove this support from core Puppet. This does not mean that support will be discontinued, however. It will just move to yet another excellent Puppet module.</p>
<p>Each of your machines can export their individual <kbd>nagios_host</kbd> resources alongside their <kbd>host</kbd> and <kbd>cacti_device</kbd> resources. However, thanks to the diverse Nagios support, you can do even better.</p>
<p>Assuming that you have a module or class to wrap SSH handling (you are using a Forge module for the actual management, of course), you can handle monitoring from inside your own SSH server class. By adding the export to this class, you make sure that nodes that include the class (and only these nodes) will also get monitoring:</p>
<pre>class site::ssh { <br/>  # ...actual SSH management... <br/>  @@nagios_service { "${::facts['networking']['fqdn']}-<br/>  ssh": <br/>  use       =&gt; 'ssh_template', <br/>  host_name =&gt; $::facts['networking']['fqdn'], <br/>  } <br/>}  </pre>
<p>You probably know the drill by now, but let's repeat the mantra once more:</p>
<pre>Nagios_service&lt;&lt;| |&gt;&gt; </pre>
<p>With this collection, the Nagios host configures itself with all services that the agent manifests create.</p>
<div class="packt_tip">For large Nagios configurations, you might want to consider reimplementing the Nagios types yourself, using simple defines that build the configuration from templates. The native types can be slower than the <kbd>file</kbd> resources in this case, because they have to parse the whole Nagios configuration on each run. The <kbd>file</kbd> resources can be much cheaper, as they rely on content-agnostic checksums.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Maintaining your central firewall</h1>
                </header>
            
            <article>
                
<p>Speaking of useful features that are not part of the core of Puppet, you can manage the rules of your <kbd>iptables</kbd> firewall, of course. You need the <kbd>puppetlabs-firewall</kbd> module to make the appropriate types available. Then, each machine can (among other useful things) export its own required port forwarding to the firewall machines:</p>
<pre>@@firewall { "150 forward port 443 to ${::facts['networking']['hostname']}": <br/>  proto       =&gt; 'tcp', <br/>  dport       =&gt; '443', <br/>  destination =&gt; $public_ip_address, <br/>  jump        =&gt; 'DNAT', <br/>  todest      =&gt; $::facts['networking']['ipaddress'], <br/>  tag         =&gt; 'segment03', <br/>}</pre>
<div class="packt_infobox">The <kbd>$public_ip_address</kbd> value is not a Facter fact, of course. Your node will have to be configured with the appropriate information. You can refer toÂ <a href="b38488ca-86a7-4ecf-9a69-16938576d852.xhtml">Chapter 7</a>, <em>New Features from Puppet 4 and 5</em>, for a good way to do this.</div>
<p>The title of a firewall rule resource conventionally begins with a three-digit index for ordering purposes. The firewall machines collect all these rules naturally:</p>
<pre>Firewall&lt;&lt;| tag == 'segment03' |&gt;&gt;<strong> </strong></pre>
<p>As you can see, the possibilities for modeling distributed systems through exported Puppet resources are manifold. The simple pattern that we've iterated for several resource types suffices for a wide range of use cases. Combined with defined resource types, it allows you to flexibly enable your manifests to work together in order to form complex cluster setups with relatively little effort. The larger your clusters, the more work Puppet lifts from you through exports and collections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Removing obsolete exports</h1>
                </header>
            
            <article>
                
<p>When a node manifest stops exporting any resource, that resource's record is removed from PuppetDB once the node's catalog is compiled. This usually happens when the agent checks in with the master.</p>
<p>However, if you take an agent out of commission permanently, this will never happen. That's why you will need to remove those exports from the DB manually. Otherwise, other nodes will keep importing the old resources.</p>
<p>To clean such records from PuppetDB, use the <kbd>puppet node deactivate</kbd> command on the master server:</p>
<pre><strong>puppet node deactivate vax793.example.net</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting defaults for resource parameters</h1>
                </header>
            
            <article>
                
<p>Both exported and virtual resources are declared once, and are then collected in different contexts. The syntax is very similar, as are the concepts.</p>
<p>Sometimes, a central definition of a resource cannot be safely realized on all of your nodes, though; for example, consider the set of all your <kbd>user</kbd> resources. You will most likely wish to manage the user ID that is assigned to each account in order to make them consistent across your networks.</p>
<div class="packt_tip">This is often solved through LDAP or similar directories, but that is not possible for some sites.</div>
<p>Even if all accounts on almost all machines will be able to use their designated ID, there are likely to be some exceptions. On a few older machines, some IDs are probably being used for other purposes already, which cannot be changed easily. On such machines, creating users with these IDs will fail.</p>
<div class="packt_tip">The accounts can be created if duplicate IDs are allowed, but that is not a solution to this problem duplicates are usually not desirable.</div>
<p>Fortunately, Puppet has a convenient way to express such exceptions. To give the nonstandard UID, <kbd>2066</kbd>, to the user, <kbd>felix</kbd>, realize the resource with an attribute value specification:</p>
<pre>User&lt;| title == 'felix' |&gt; { 
  uid =&gt; '2066' 
} </pre>
<p>You can pass any property, parameter, or metaparameter that applies to the<br/>
resource type in question. A value that you specify this way is final and cannot be overridden again.</p>
<p>This language feature is more powerful than the preceding example lets on. This is because the override is not limited to virtual and exported resources. You can override any resource from anywhere in your manifest. This allows for some remarkable constructs and shortcuts.</p>
<p>Consider, for example, the Cacti module that you created during the previous chapter. It declares a <kbd>package</kbd> resource in order to make sure that the software is installed. To that end, it specifies <kbd>ensure =&gt; installed</kbd>. If any user of your module needs Puppet to keep their packages up to date, this is not adequate though. The clean solution for this case is to add some parameters to the module's classes which allow the user to choose the <kbd>ensure</kbd> property value for the package and other resources. However, this is not really practical. Complex modules can manage hundreds of properties, and exposing them all through parameters would form a horribly confusing interface.</p>
<p>The override syntax can provide a simple and elegant workaround here. The manifest that achieves the desired result is very straightforward:</p>
<pre><strong>include cacti 
Package&lt;| title == 'cacti' |&gt; { ensure =&gt; 'latest' } </strong></pre>
<p>For all its simplicity, this manifest will be hard to decipher for collaborators who are not familiar with the collector/override syntax. This is not the only problem with overrides. You cannot override the same attribute multiple times. This is actually a good thing, because any rules that resolve such conflicting overrides make it extremely difficult to predict the actual semantics of a manifest that contains multiple overrides of this kind.</p>
<p>Relying on this override syntax too much will make your manifests prone to conflicts. Combining the wrong classes will make the compiler stop creating the catalog. Even if you manage to avoid all conflicts, the manifests will become rather chaotic. It can be difficult to locate all active overrides for a given node. The resulting behavior of any class or define becomes hard to predict.</p>
<p>All things considered, it's safest to use overrides very sparingly.</p>
<div class="packt_infobox">The collectors are especially dangerous when used without a selector expression:</div>
<pre>Package&lt;| |&gt; { before =&gt; Exec['send-software-list'] }<strong> </strong></pre>
<div class="packt_infobox">Not only will it realize all virtual resources of the given type. It will also force surprising attribute values on both virtual and regular resources of the same type.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Saving redundancy using resource defaults</h1>
                </header>
            
            <article>
                
<p>The final language construct that this chapter introduces can save you quite<br/>
some typing, or rather, it saves you from copying and pasting. Writing a long, repetitive manifest is not what costs you lots of time, of course. However, a briefer manifest is often more readable, and hence, more maintainable. You achieve this by defining resource defaults; attribute values that are used for resources that don't choose their own:</p>
<pre>Mysql_grant { <br/>  options    =&gt; ['GRANT'], <br/>  privileges =&gt; ['ALL'], <br/>  tables     =&gt; '*.*', <br/>} <br/>mysql_grant { 'root': <br/>  ensure =&gt; 'present', <br/>  user   =&gt; 'root@localhost', <br/>}<br/>mysql_grant { 'apache': <br/>  ensure =&gt; 'present', <br/>  user   =&gt; 'apache@10.0.1.%', <br/>  tables =&gt; 'application.*', <br/>}<br/>mysql_grant { 'wordpress': <br/>  ensure =&gt; 'present', <br/>  user   =&gt; 'wordpress@10.0.5.1', <br/>  tables =&gt; 'wordpress.*', <br/>}<br/>mysql_grant { 'backup':<br/>  ensure     =&gt; 'present',<br/>  user       =&gt; 'backup@localhost',<br/>  privileges =&gt; [ 'SELECT', 'LOCK TABLE' ],<br/>} </pre>
<p>By default, each grant should apply to all databases and comprise all privileges. This allows you to define each actual <kbd>mysql_grant</kbd> resource quite sparsely. Otherwise, you will have to specify the <kbd>privileges</kbd> property for all resources. The <kbd>options</kbd> attribute will be especially repetitive, because they are identical for all grants in this example.</p>
<p>Note that the ensure property is repetitive as well, but it was not included. It is considered good practice to exempt this attribute from resource defaults.</p>
<div class="packt_infobox">The <kbd>mysql_grant</kbd> resource type is not available in core Puppet. It's part of the <kbd>puppetlabs-mysql</kbd> module on the Forge.</div>
<p>Despite the convenience that this approach offers, it should not be used at each apparent opportunity. It has some downsides that you should keep in mind:</p>
<ul>
<li>The defaults can be surprising if they apply to resources that are declared at a lexical distance from the defaults' definition (such as several screens further down the manifest file)</li>
<li>The defaults transcend the inclusion of classes and instantiation of defines</li>
</ul>
<p>These two aspects form a dangerous combination. Defaults from a composite class can affect very distant parts of a manifest:</p>
<pre>class webserver {  
  File { owner =&gt; 'www-data' }  
  include apache, nginx, firewall, logging_client  
  file {  
    ...  
  } 
} </pre>
<p>Files declared in the <kbd>webserver</kbd> class should belong to a default user. However, this default takes effect recursively in the included classes as well. The <kbd>owner</kbd> attribute is a property: a resource that defines no value, for it just ignores its current state. A value that is specified in the manifest will be enforced by the agent. Often, you do not care about the owner of a managed file:</p>
<pre>file { '/etc/motd': content =&gt; '...' } </pre>
<p>However, because of the default <kbd>owner</kbd> attribute, Puppet will now mandate that this file belongs to <kbd>www-data</kbd>. To avoid this, you will have to unset the default by overwriting it with <kbd>undef</kbd>, which is Puppet's analog to the <kbd>nil</kbd> value:</p>
<pre>File { owner =&gt; undef } </pre>
<p>This can also be done in individual resources:</p>
<pre>file { '/etc/motd': content =&gt; '...', owner =&gt; undef } </pre>
<p>However, doing this constantly is hardly feasible. The latter option is especially unattractive, because it leads to more complexity in the manifest code, instead of simplifying it. After all, not defining a default <kbd>owner</kbd> attribute will be the cleaner way here.</p>
<div class="packt_infobox">The semantics that make defaults take effect in so many manifest areas is known as <strong>dynamic scoping</strong>. It used to apply to variable values as well and is generally considered harmful. One of the most decisive changes in Puppet 3.0 was the removal of dynamic variable scoping, in fact. Resource defaults still use it, but it is expected that this will change in a future release as well.</div>
<p>Resource defaults should be used with consideration and care. For some properties, such as <kbd>file mode</kbd>, <kbd>owner</kbd>, and <kbd>group</kbd>, they should usually be avoided.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Avoiding antipatterns</h1>
                </header>
            
            <article>
                
<p>Speaking of things to avoid, there is a language feature that we will only address in order to advise great caution. Puppet comes with a function called <kbd>defined</kbd>, which allows you to query the compiler about resources that have been declared in the manifest:</p>
<pre>if defined(File['/etc/motd']) { 
  notify { 'This machine has a MotD': } 
} </pre>
<p>The problem with the concept is that it cannot ever be reliable. Even if the resource appears in the manifest, the compiler might encounter it later than the <kbd>if</kbd> condition. This is potentially very problematic, because some modules will try to make themselves portable through this construct:</p>
<pre>if ! defined(Package['apache2']) {  
  package { 'apache2':  
    ensure =&gt; 'installed'  
  }  
}  </pre>
<p>The module author supposes that this resource definition will be skipped if<br/>
the manifest declares <kbd>Package['apache2']</kbd> somewhere else. As explained, this method will only be effective if the block is evaluated late enough during the compiler run. The conflict can still occur if the compiler encounters the other declaration after this one.</p>
<p>The manifest's behavior becomes outright unpredictable if a manifest contains multiple occurrences of the same query:</p>
<pre>class cacti { <br/>  if !defined(Package['apache2']) { <br/>    package { 'apache2': ensure =&gt; 'present' } <br/>  }<br/>}<br/>class postfixadmin { <br/>  if !defined(Package['apache2'] { <br/>    package { 'apache2': ensure =&gt; 'latest' } <br/>  }<br/>}</pre>
<p>The first block that is seen wins. This can even shift if unrelated parts of the manifest are restructured. You cannot predict whether a given manifest will use <kbd>ensure=&gt;latest</kbd> for the <kbd>apache2</kbd> package or just use <kbd>installed</kbd>. The results become even more bizarre if such a block wants a resource removed through <kbd>ensure=&gt;absent</kbd>, while the other does not.</p>
<p>The <kbd>defined</kbd> function has long been considered harmful, but there is no adequate alternative yet. The <kbd>ensure_resource</kbd> function from the <kbd>stdlib</kbd> module tries to make the scenario less problematic:</p>
<pre>ensure_resource('package', 'apache2', { ensure =&gt; 'installed' }) </pre>
<p>By relying on this function instead of the preceding antipattern based around the <kbd>defined</kbd> function, you will avoid the unpredictable behavior of conflicting declarations. Instead, this will cause the compiler to fail when the declarations are passed to <kbd>ensure_resource</kbd>. This is still not a clean practice, though. Failed compilation is not a desirable alternative either.</p>
<p>Both functions should be avoided in favor of clean module structures with non-ambiguous resource declarations. More details on how to ensure reusable, composable, and stackable classes will be provided in <a href="0a0cf4b0-23fa-48fd-abf9-77ed851bb581.xhtml"><span class="ChapterrefPACKT">Chapter 9</span></a>, <em>Puppet Roles and Profiles.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>A template is a frequent occurrence and is one of the best ways for Puppet to manage dynamic file content. Evaluating each template requires extra effort from the compiler, but the gain in flexibility is usually worth it. Variables in templates have to be declared using the Puppet variable syntax with full namespace, or by prodding a hash with variable inside templates and classes.</p>
<p>The concept of virtual resources is much less ubiquitous. Virtual resources allow you to flexibly add certain entities to a node's catalog. The collector syntax that is used for this can also be used to override attribute values, which works for non-virtual resources as well.</p>
<p>Once PuppetDB is installed and configured, you can also export resources so that other node manifests can receive their configuration information. This allows you to model distributed systems quite elegantly.</p>
<p>The resource defaults are just a syntactic shortcut that help keep your manifest concise. They have to be used with care, though. Some language features, such as the <kbd>defined</kbd> function (and its module-based successor, which is the <kbd>ensure_resource</kbd> function), should be avoided if possible.</p>
<p><a href="b38488ca-86a7-4ecf-9a69-16938576d852.xhtml">Chapter 7ï»¿</a>, <em>New Features from Puppet 4 and 5</em>, gives you an overview and introduction to the roles and profiles pattern, which is best practice for combining upstream modules with platform implementations.</p>


            </article>

            
        </section>
    </body></html>