- en: Chapter 7. Mastering modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 掌握模块
- en: '|   | *There are no big problems, there are just a lot of little problems.*
    |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *没有大问题，只有很多小问题。* |   |'
- en: '|   | --*Henry Ford* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*亨利·福特* |'
- en: 'In this chapter you''ll learn about Puppet Forge, the public repository for
    Puppet modules, and you''ll see how to install and use third-party modules from
    Puppet Forge, using the `r10k` module management tool. You''ll see examples of
    how to use three important Forge modules: `puppetlabs/apache`, `puppetlabs/mysql`,
    and `puppet/archive`. You''ll be introduced to some useful functions provided
    by `puppetlabs/stdlib`, the Puppet standard library. Finally, working through
    a complete example, you''ll learn how to develop your own Puppet module from scratch,
    how to add appropriate metadata for your module, and how to upload it to Puppet
    Forge.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解 Puppet Forge，这是 Puppet 模块的公共仓库，你将学习如何使用 `r10k` 模块管理工具安装和使用来自 Puppet
    Forge 的第三方模块。你将看到如何使用三个重要的 Forge 模块的示例：`puppetlabs/apache`、`puppetlabs/mysql`
    和 `puppet/archive`。你还将了解 `puppetlabs/stdlib` 提供的一些有用功能，这是 Puppet 的标准库。最后，通过一个完整的示例，你将学习如何从零开始开发自己的
    Puppet 模块，如何为模块添加适当的元数据，以及如何将其上传到 Puppet Forge。
- en: '![Mastering modules](img/8880_07_01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![掌握模块](img/8880_07_01.jpg)'
- en: Using Puppet Forge modules
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Puppet Forge 模块
- en: Although you could write your own manifests for everything you want to manage,
    you can save yourself a lot of time and effort by using public Puppet modules
    wherever possible. A **module** in Puppet is a self-contained unit of shareable,
    reusable code, usually designed to manage one particular service or piece of software,
    such as the Apache web server.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以为你想要管理的所有内容编写自己的清单，但通过尽可能使用公共 Puppet 模块，你可以节省大量的时间和精力。在 Puppet 中，**模块**
    是一个自包含的可共享、可重用的代码单元，通常设计用来管理某一特定服务或软件，例如 Apache Web 服务器。
- en: What is the Puppet Forge?
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 Puppet Forge？
- en: 'The **Puppet Forge** is a public repository of Puppet modules, many of them
    officially supported and maintained by Puppet and all of which you can download
    and use. You can browse the Forge at the following URL:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**Puppet Forge** 是一个公共的 Puppet 模块仓库，其中许多模块由 Puppet 官方支持并维护，所有这些模块都可以下载和使用。你可以通过以下网址浏览
    Forge：'
- en: '[https://forge.puppet.com/](https://forge.puppet.com/)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://forge.puppet.com/](https://forge.puppet.com/)'
- en: 'One of the advantages of using a well-established tool like Puppet is that
    there are a large number of mature public modules available, which cover the most
    common software you''re likely to need. For example, here is a small selection
    of the things you can manage with public modules from Puppet Forge:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像 Puppet 这样的成熟工具的一个优势是，存在大量成熟的公共模块，涵盖了你可能需要的大多数常见软件。例如，以下是你可以使用 Puppet Forge
    中的公共模块管理的一小部分内容：
- en: MySQL/PostgreSQL/SQL Server
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL/PostgreSQL/SQL Server
- en: Apache/Nginx
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache/Nginx
- en: Java/Tomcat/PHP/Ruby/Rails
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java/Tomcat/PHP/Ruby/Rails
- en: HAProxy
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HAProxy
- en: Amazon AWS
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amazon AWS
- en: Docker
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Jenkins
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins
- en: Elasticsearch/Redis/Cassandra
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Elasticsearch/Redis/Cassandra
- en: Git repos
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 仓库
- en: Firewalls (via iptables)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防火墙（通过 iptables）
- en: Finding the module you need
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找你需要的模块
- en: The Puppet Forge home page has a search bar at the top. Type what you're looking
    for into this box, and the website will show you all the modules which match your
    search keywords. Often, there will be more than one result, so how do you decide
    which module to use?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet Forge 首页顶部有一个搜索框。在此框中输入你要查找的内容，网站会显示所有与你搜索关键词匹配的模块。通常会有多个结果，那么你该如何决定使用哪个模块呢？
- en: 'The best choice is a **Puppet Supported** module, if one is available. These
    are officially supported and maintained by Puppet, and you can be confident that
    supported modules will work with a wide range of operating systems and Puppet
    versions. Supported modules are indicated by a yellow **SUPPORTED** flag in search
    results, or you can browse the list of all supported modules at the following
    URL:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的选择是 **Puppet 支持的** 模块，如果有的话。这些模块由 Puppet 官方支持和维护，你可以确信，支持的模块将与广泛的操作系统和 Puppet
    版本兼容。支持的模块在搜索结果中会显示黄色的 **SUPPORTED** 标志，或者你可以通过以下网址浏览所有支持模块的列表：
- en: '[https://forge.puppet.com/modules?endorsements=supported](https://forge.puppet.com/modules?endorsements=supported)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://forge.puppet.com/modules?endorsements=supported](https://forge.puppet.com/modules?endorsements=supported)'
- en: 'The next best option is a **Puppet Approved** module. While not officially
    supported, these modules are recommended by Puppet and have been checked to make
    sure they follow best practices and meet certain quality standards. Approved modules
    are indicated by a green **APPROVED** flag in search results, or you can browse
    the list of all approved modules at the following URL:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个最佳选择是**Puppet 认证**模块。虽然这些模块没有官方支持，但它们是 Puppet 推荐的，并且已经过检查，确保遵循最佳实践并符合一定的质量标准。认证模块在搜索结果中会显示绿色的**认证通过（APPROVED）**标志，或者你可以通过以下链接浏览所有认证模块的列表：
- en: '[https://forge.puppet.com/modules?endorsements=approved](https://forge.puppet.com/modules?endorsements=approved)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://forge.puppet.com/modules?endorsements=approved](https://forge.puppet.com/modules?endorsements=approved)'
- en: Assuming that a Puppet-Supported or Puppet-Approved module is not available,
    another useful way to choose modules is by looking at the number of downloads.
    Selecting the **Most Downloads** tab on the Puppet Forge search results page will
    sort the results by downloads, with the most popular modules first. The most-downloaded
    modules are not necessarily the best, of course, but they're usually a good place
    to start.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 假设没有 Puppet 支持或 Puppet 认证的模块，另一种选择模块的有用方法是查看下载数量。在 Puppet Forge 搜索结果页面上选择**最多下载**标签，将根据下载量对结果进行排序，最受欢迎的模块排在前面。当然，下载量最多的模块不一定是最好的，但它们通常是一个不错的起点。
- en: It's also worth checking the latest release date for modules. If the module
    you're looking at hasn't been updated in over a year, it may be better to go with
    a more actively-maintained module, if one is available. Clicking on the **Latest
    release** tab will sort search results by the most recently updated.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 检查模块的最新发布日期也是值得的。如果你正在查看的模块一年多没有更新，最好选择一个维护更活跃的模块（如果有的话）。点击**最新发布**标签将按最新更新的顺序对搜索结果进行排序。
- en: You can also filter search results by operating system support and Puppet version
    compatibility; this can be very useful for finding a module that works with your
    system.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过操作系统支持和 Puppet 版本兼容性来过滤搜索结果；这对于找到与您的系统兼容的模块非常有用。
- en: Having chosen the module you want, it's time to add it to your Puppet infrastructure.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 选择好你想要的模块后，就可以将其添加到你的 Puppet 基础架构中了。
- en: Using r10k
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 r10k
- en: In the past, many people used to download Puppet Forge modules directly and
    check a copy of them into their codebase, effectively forking the module repo
    (and some still do this). There are many drawbacks to this approach. One is that
    your codebase becomes cluttered with code that is not yours, and this can make
    it difficult to search for the code you want. Another is that it's difficult to
    test your code with different versions of public modules, without creating your
    own Git branches, redownloading the modules, and so on. You also won't get future
    bug fixes and improvements from the Puppet Forge modules unless you manually update
    your copies. In many cases, you will need to make small changes or fixes to the
    modules to use them in your environment, and your version of the module will then
    diverge from the upstream version, storing up maintenance problems for the future.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，许多人习惯直接下载 Puppet Forge 模块，并将其复制到他们的代码库中，实际上是分叉了模块的仓库（至今仍有人这么做）。这种方法有很多缺点。其中一个缺点是，你的代码库中会充斥着不是你写的代码，这会让你很难找到你需要的代码。另一个问题是，测试你的代码与不同版本的公共模块兼容时很困难，你需要创建自己的
    Git 分支、重新下载模块等等。你也无法获得 Puppet Forge 模块的未来错误修复和改进，除非你手动更新你的副本。在很多情况下，你需要对模块做一些小的更改或修复，以便在你的环境中使用，这样你的模块版本就会与上游版本产生差异，未来会积累维护问题。
- en: A much better approach to module management, therefore, is to use the `r10k`
    tool, which eliminates these problems. Instead of downloading the modules you
    need directly and adding them to your codebase, `r10k` installs your required
    modules on each Puppet-managed node, using a special text file called a **Puppetfile**.
    `r10k` will manage the contents of your `modules/` directory, based entirely on
    the Puppetfile metadata. The module code is never checked into your codebase,
    but always downloaded from the Puppet Forge when requested. So you can stay up
    to date with the latest releases if you want, or pin each module to a specified
    version which you know works with your manifest.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个更好的模块管理方法是使用 `r10k` 工具，它可以解决这些问题。`r10k` 不直接下载所需的模块并将其添加到代码库中，而是通过一个名为 **Puppetfile**
    的特殊文本文件，在每个 Puppet 管理的节点上安装所需的模块。`r10k` 会完全根据 Puppetfile 中的元数据来管理 `modules/` 目录的内容。模块代码从不直接被检查到代码库中，而是在需要时从
    Puppet Forge 下载。因此，如果你愿意，你可以保持模块的最新版本，或者将每个模块固定在一个已知与清单兼容的特定版本。
- en: '`r10k` is the de facto standard module manager for Puppet deployments, and
    we''ll be using it to manage modules throughout the rest of this book.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`r10k` 是 Puppet 部署的事实标准模块管理工具，在本书的后续内容中，我们将使用它来管理模块。'
- en: 'In this example, we''ll use `r10k` to install the `puppetlabs/stdlib` module.
    The Puppetfile in the example repo contains a list of all the modules we''ll use
    in this book. Here it is (we''ll look more closely at the syntax in a moment):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用 `r10k` 安装 `puppetlabs/stdlib` 模块。示例仓库中的 Puppetfile 列出了本书中将使用的所有模块。它如下所示（稍后我们会详细分析语法）：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Follow these steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'Run the following commands to clear out your `modules/` directory, if there''s
    anything in it (make sure you have backed up anything here you want to keep):'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来清空 `modules/` 目录中的内容（确保你已经备份了想要保留的任何内容）：
- en: '[PRE1]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Run the following command to have `r10k` process the example Puppetfile here
    and install your requested modules:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令，让 `r10k` 处理这里的示例 Puppetfile 并安装你所请求的模块：
- en: '[PRE2]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`r10k` downloads all the modules listed in the Puppetfile into the `modules/`
    directory. All modules in this directory will be automatically loaded by Puppet
    and available for use in your manifests. To test that the `stdlib` module is correctly
    installed, run the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`r10k` 会将 Puppetfile 中列出的所有模块下载到 `modules/` 目录中。该目录中的所有模块会被 Puppet 自动加载，并可在你的清单中使用。为了测试
    `stdlib` 模块是否正确安装，运行以下命令：'
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `upcase` function, which converts its string argument to uppercase, is part
    of the `stdlib` module. If this doesn't work, then `stdlib` has not been properly
    installed. As in previous examples, we're using the `--environment pbg` switch
    to tell Puppet to look for code, modules, and data in the `/etc/puppetlabs/code/environments/pbg`
    directory.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`upcase` 函数将其字符串参数转换为大写字母，是 `stdlib` 模块的一部分。如果此功能无法正常工作，说明 `stdlib` 模块未正确安装。如前面的示例所示，我们使用
    `--environment pbg` 开关告诉 Puppet 在 `/etc/puppetlabs/code/environments/pbg` 目录中查找代码、模块和数据。'
- en: Understanding the Puppetfile
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Puppetfile
- en: 'The example Puppetfile begins with the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 Puppetfile 以以下内容开始：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `forge` statement specifies the repository where modules should be retrieved
    from.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`forge` 语句指定了模块应从哪个仓库获取。'
- en: 'There follows a group of lines beginning with `mod`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着会出现一组以 `mod` 开头的行：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `mod` statement specifies the name of the module (`puppetlabs/stdlib`) and
    the specific version of the module to install (`4.17.0`).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`mod` 语句指定了模块的名称（`puppetlabs/stdlib`）以及要安装的模块的具体版本（`4.17.0`）。'
- en: Managing dependencies with generate-puppetfile
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `generate-puppetfile` 管理依赖关系
- en: '`r10k` does not automatically manage dependencies between modules. For example,
    the `puppetlabs/apache` module depends on having both `puppetlabs/stdlib` and
    `puppetlabs/concat` installed. `r10k` will not automatically install these for
    you unless you specify them, so you also need to include them in your Puppetfile.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`r10k` 不会自动管理模块之间的依赖关系。例如，`puppetlabs/apache` 模块依赖于安装 `puppetlabs/stdlib` 和
    `puppetlabs/concat`。除非你指定它们，`r10k` 不会自动为你安装这些模块，因此你还需要将它们添加到 Puppetfile 中。'
- en: However, you can use the `generate-puppetfile` tool to find out what dependencies
    you need so that you can add them to your Puppetfile.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以使用 `generate-puppetfile` 工具来找出所需的依赖关系，然后将它们添加到你的 Puppetfile 中。
- en: 'Run the following command to install the `generate-puppetfile` gem:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来安装 `generate-puppetfile` gem：
- en: '[PRE6]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run the following command to generate the Puppetfile for a list of specified
    modules (list all the modules you need on the command line, separated by spaces):'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令生成指定模块列表的 Puppetfile（在命令行中列出所有需要的模块，模块之间用空格分隔）：
- en: '[PRE7]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Run the following command to generate a list of updated versions and dependencies
    for an existing Puppetfile:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令生成现有 Puppetfile 的更新版本和依赖项列表：
- en: '[PRE8]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is an extremely useful tool both for finding dependencies you need to specify
    in your Puppetfile and for keeping your Puppetfile up to date with the latest
    versions of all the modules you use.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常有用的工具，既可以用来查找你需要在 Puppetfile 中指定的依赖项，也可以帮助你保持 Puppetfile 与所使用的所有模块的最新版本同步。
- en: Using modules in your manifests
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在清单中使用模块
- en: Now that we know how to find and install public Puppet modules, let's see how
    to use them. We'll work through a few examples, using the `puppetlabs/mysql` module
    to set up a MySQL server and database, using the `puppetlabs/apache` module to
    set up an Apache website, and using `puppet/archive` to download and unpack a
    compressed archive. After you've tried out these examples, you should feel quite
    confident in your ability to find an appropriate Puppet module, add it to your
    `Puppetfile`, and deploy it with `r10k`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何查找和安装公共 Puppet 模块，接下来看看如何使用它们。我们将通过几个示例来演示，使用 `puppetlabs/mysql` 模块来设置
    MySQL 服务器和数据库，使用 `puppetlabs/apache` 模块来设置 Apache 网站，以及使用 `puppet/archive` 下载并解压一个压缩包。完成这些示例后，你应该会对如何找到合适的
    Puppet 模块、将其添加到 `Puppetfile` 中并通过 `r10k` 部署感到非常有信心。
- en: Using puppetlabs/mysql
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 puppetlabs/mysql
- en: 'Follow these steps to run the `puppetlabs/mysql` example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤运行 `puppetlabs/mysql` 示例：
- en: 'If you''ve previously followed the steps in the *Using r10k* section, the required
    module will already be installed. If not, run the following commands to install
    it:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你之前已经按照 *使用 r10k* 部分的步骤操作，那么所需的模块应该已经安装。如果没有，请运行以下命令安装它：
- en: '[PRE9]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run the following command to apply the manifest:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令应用清单：
- en: '[PRE10]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s take a look at the example manifest (`module_mysql.pp`). The first part
    installs the MySQL server itself, by including the class `mysql::server`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下示例清单（`module_mysql.pp`）。第一部分通过包含 `mysql::server` 类来安装 MySQL 服务器：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `mysql::server` class accepts a number of parameters, most of which we
    needn''t worry about for now, but we would like to set a couple of them for this
    example. Although you can set the values for class parameters directly in your
    Puppet manifest code, just as you would for resource attributes, I''ll show you
    a better way to do it: using Hiera''s automatic parameter lookup mechanism.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`mysql::server` 类接受多个参数，其中大多数我们暂时不需要关注，但我们希望在此示例中设置其中几个。虽然你可以像设置资源属性一样直接在 Puppet
    清单代码中为类参数设置值，但我将展示一种更好的方法：使用 Hiera 的自动参数查找机制。'
- en: Tip
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We mentioned briefly in [Chapter 6](ch06.html "Chapter 6. Managing data with
    Hiera"), *Managing data with Hiera*, that Hiera can supply values for class and
    module parameters, but how does it work, exactly? When you include a class `x`
    which takes a parameter `y`, Puppet automatically searches Hiera for any keys
    matching the name `x::y`. If it finds one, it uses that value for the parameter.
    Just as with any other Hiera data, you can use the hierarchy to set different
    values for different nodes, roles, or operating systems.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第6章](ch06.html "第6章 管理 Hiera 数据")中简要提到过，*使用 Hiera 管理数据*，Hiera 可以为类和模块参数提供值，但它到底是如何工作的呢？当你包含一个类
    `x` 并传入一个参数 `y` 时，Puppet 会自动在 Hiera 中搜索任何与 `x::y` 名称匹配的键。如果找到了，它就会使用该值作为参数的值。就像其他
    Hiera 数据一样，你可以通过层次结构为不同的节点、角色或操作系统设置不同的值。
- en: 'In this example, our parameters are set in the example Hiera data file (`/etc/puppetlabs/code/environments/pbg/data/common.yaml`):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们的参数设置在示例 Hiera 数据文件（`/etc/puppetlabs/code/environments/pbg/data/common.yaml`）中：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `root_password` parameter, as you'd expect, sets the password for the MySQL
    `root` user. We also enable `remove_default_accounts`, which is a security feature.
    MySQL ships with various default user accounts for testing purposes, which should
    be turned off in production. This parameter disables these default accounts.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`root_password` 参数，如你所料，用来设置 MySQL `root` 用户的密码。我们还启用了 `remove_default_accounts`，这是一个安全特性。MySQL
    默认带有各种用于测试的用户账户，在生产环境中应当关闭。此参数禁用了这些默认账户。'
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that although we've specified the password in plain text for the purposes
    of clarity, in your production manifests, this should be encrypted, just as with
    any other credentials or secret data (see [Chapter 6](ch06.html "Chapter 6. Managing
    data with Hiera"), *Managing data with Hiera*).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管为了清晰起见我们在此明文指定了密码，但在生产环境的清单中，这些密码应该被加密，就像任何其他凭证或机密数据一样（参见 [第6章](ch06.html
    "第6章：使用 Hiera 管理数据")，*使用 Hiera 管理数据*）。
- en: 'Next comes a resource declaration:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是资源声明：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As you can see, this looks just like the built-in resources we''ve used before,
    such as the `file` and `package` resources. In effect, the `mysql` module has
    added a new resource type to Puppet: `mysql::db`. This resource models a specific
    MySQL database: `cat_pictures` in our example.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这看起来和我们之前使用的内置资源一样，比如 `file` 和 `package` 资源。实际上，`mysql` 模块为 Puppet 添加了一个新的资源类型：`mysql::db`。这个资源表示一个特定的
    MySQL 数据库：在我们的例子中是 `cat_pictures`。
- en: 'The title of the resource is the name of the database, in this case, `cat_pictures`.
    There follows a list of attributes. The `user`, `password`, and `host` attributes
    specify that the user `greebo` should be allowed to connect to the database from
    `localhost` using the password `tabby`. The `grant` attribute specifies the MySQL
    privileges that the user should have: `SELECT` and `UPDATE` on the database.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 资源的标题是数据库的名称，在本例中是 `cat_pictures`。接下来是属性列表。`user`、`password` 和 `host` 属性指定用户
    `greebo` 应该被允许从 `localhost` 使用密码 `tabby` 连接到数据库。`grant` 属性指定用户应该具有的 MySQL 权限：对数据库的
    `SELECT` 和 `UPDATE` 权限。
- en: 'When this manifest is applied, Puppet will create the `cat_pictures` database
    and set up the `greebo` user account to access it. This is a very common pattern
    for Puppet manifests which manage an application: usually, the application needs
    some sort of database to store its state, and user credentials to access it. The
    `mysql` module lets you configure this very easily.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用此清单时，Puppet 将创建 `cat_pictures` 数据库并设置 `greebo` 用户账户以便访问它。这是管理应用程序的 Puppet
    清单中非常常见的模式：通常，应用程序需要某种数据库来存储其状态，并且需要用户凭据来访问它。`mysql` 模块让你非常容易地配置这一点。
- en: 'So we can now see the general principles of using a Puppet Forge module:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到使用 Puppet Forge 模块的一般原则：
- en: We add the module and its dependencies to our `Puppetfile` and deploy it using
    `r10k`
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将模块及其依赖项添加到我们的 `Puppetfile` 中，并使用 `r10k` 部署它。
- en: We `include` the class in our manifest, supplying any required parameters as
    Hiera data
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在清单中`include`该类，并提供任何需要的参数作为 Hiera 数据。
- en: Optionally, we add one or more resource declarations of a custom resource type
    defined by the module (in this case, a MySQL database)
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地，我们添加一个或多个由模块定义的自定义资源类型的资源声明（在本例中是 MySQL 数据库）。
- en: Almost all Puppet modules work in a similar way. In the next section, we'll
    look at some key modules which you're likely to need in the course of managing
    servers with Puppet.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的 Puppet 模块都以类似的方式工作。在接下来的章节中，我们将介绍一些关键模块，这些模块在使用 Puppet 管理服务器时，你很可能会用到。
- en: Using puppetlabs/apache
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 puppetlabs/apache
- en: Most applications have a web interface of some kind, which usually requires
    a web server, and the venerable Apache remains a popular choice. The `puppetlabs/apache`
    module not only installs and configures Apache, but also allows you to manage
    virtual hosts (individual websites, such as the frontend for your application).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序都有某种类型的 Web 界面，通常需要一个 Web 服务器，而久负盛名的 Apache 仍然是一个流行的选择。`puppetlabs/apache`
    模块不仅安装和配置 Apache，还允许你管理虚拟主机（各个网站，例如应用程序的前端）。
- en: 'Here''s an example manifest which uses the `apache` module to create a simple
    virtual host serving an image file (`module_apache.pp`):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例清单，它使用 `apache` 模块来创建一个简单的虚拟主机来服务一个图像文件（`module_apache.pp`）：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Follow these steps to apply the manifest:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤应用清单：
- en: 'If you''ve previously followed the steps in the *Using r10k* section, the required
    module will already be installed. If not, run the following commands to install
    it:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你之前已经按照 *使用 r10k* 章节的步骤操作，所需的模块应该已经安装。如果没有，请运行以下命令进行安装：
- en: '[PRE15]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Run the following command to apply the manifest:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来应用清单：
- en: '[PRE16]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To test the new website, point your browser to (for Vagrant users; if you're
    not using the Vagrant box, browse to port `80` on the server you're managing with
    Puppet) `http://localhost:8080/`
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试新的网站，请将浏览器指向（对于 Vagrant 用户；如果你没有使用 Vagrant box，请浏览你用 Puppet 管理的服务器上的 `80`
    端口）`http://localhost:8080/`
- en: 'You should see a picture of a happy cat:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一只快乐猫的图片：
- en: '![Using puppetlabs/apache](img/8880_07_02.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![使用 puppetlabs/apache](img/8880_07_02.jpg)'
- en: Let's go through the manifest and see how it works in detail.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细查看清单，了解它是如何工作的。
- en: 'It starts with the `include` declaration which actually installs Apache on
    the server (`module_apache.pp`):'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它从 `include` 声明开始，实际上在服务器上安装了 Apache（`module_apache.pp`）：
- en: '[PRE17]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There are many parameters you could set for the `apache` class, but in this
    example, we only need to set one, and as with the other examples, we set it using
    Hiera data in the example Hiera file:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以为 `apache` 类设置许多参数，但在本示例中，我们只需要设置一个，像其他示例一样，我们通过示例 Hiera 文件中的 Hiera 数据来设置它：
- en: '[PRE18]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This disables the default **Apache 2 Test Page** virtual host.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将禁用默认的 **Apache 2 测试页面** 虚拟主机。
- en: Next comes a resource declaration for an `apache::vhost` resource, which creates
    an Apache virtual host or website.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是一个 `apache::vhost` 资源的声明，它创建了一个 Apache 虚拟主机或网站。
- en: '[PRE19]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The title of the resource is the domain name which the virtual host will respond
    to (`cat-pictures.com`). The `port` tells Apache which port to listen on for requests.
    The `docroot` identifies the pathname of the directory where Apache will find
    the website files on the server. Finally, the `docroot_owner` and `docroot_group`
    attributes specify the user and group which should own the `docroot/` directory.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 资源的标题是虚拟主机响应的域名（`cat-pictures.com`）。`port` 告诉 Apache 听哪个端口上的请求。`docroot` 指定
    Apache 在服务器上查找网站文件的目录路径。最后，`docroot_owner` 和 `docroot_group` 属性指定应该拥有 `docroot/`
    目录的用户和组。
- en: Finally, we create an `index.html` file to add some content to the website,
    in this case, an image of a happy cat.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个 `index.html` 文件，为网站添加一些内容，在这种情况下是一个快乐猫咪的图片。
- en: '[PRE20]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that port `80` on the Vagrant box is mapped to port `8080` on your local
    machine, so browsing to `http://localhost:8080` is the equivalent of browsing
    directly to port `80` on the Vagrant box. If for some reason you need to change
    this port mapping, edit your `Vagrantfile` (in the Puppet Beginner''s Guide repo)
    and look for the following line:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Vagrant 虚拟机中的端口 `80` 映射到本地机器上的端口 `8080`，因此浏览 `http://localhost:8080` 相当于直接访问
    Vagrant 虚拟机上的端口 `80`。如果由于某些原因需要更改此端口映射，请编辑您的 `Vagrantfile`（在 Puppet 初学者指南仓库中），并查找以下行：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Change these settings as required and run the following command on your local
    machine in the PBG repo directory:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需要更改这些设置，并在本地机器的 PBG 仓库目录中运行以下命令：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Using puppet/archive
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 puppet/archive
- en: While installing software from packages is a common task, you'll also occasionally
    need to install software from archive files, such as a tarball (a `.tar.gz` file)
    or ZIP file. The `puppet/archive` module is a great help for this, as it provides
    an easy way to download archive files from the Internet, and it can also unpack
    them for you.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从软件包安装软件是常见的任务，但有时你也需要从归档文件中安装软件，例如 tarball（`.tar.gz` 文件）或 ZIP 文件。`puppet/archive`
    模块在这方面非常有帮助，因为它提供了一种简单的方法来从互联网下载归档文件，并且还可以为你解压这些文件。
- en: 'In the following example, we''ll use the `puppet/archive` module to download
    and unpack the latest version of the popular WordPress blogging software. Follow
    these steps to apply the manifest:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将使用 `puppet/archive` 模块来下载并解压流行的 WordPress 博客软件的最新版本。按照以下步骤应用清单：
- en: 'If you''ve previously followed the steps in the *Using r10k* section, the required
    module will already be installed. If not, run the following commands to install
    it:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你之前已经按照 *使用 r10k* 部分中的步骤操作，所需的模块应该已经安装。如果没有，请运行以下命令来安装它：
- en: '[PRE23]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run the following command to apply the manifest:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以应用清单：
- en: '[PRE24]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Unlike the previous modules in this chapter, there''s nothing to install with
    `archive`, so we don''t need to include the class itself. All you need to do is
    declare an `archive` resource. Let''s look at the example in detail to see how
    it works (`module_archive.pp`):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章之前的模块不同，`archive` 不需要安装任何东西，因此我们不需要包含该类。你只需要声明一个 `archive` 资源。让我们详细看看这个示例，了解它是如何工作的（`module_archive.pp`）：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The title gives the path to where you want the archive file to be downloaded
    (`/tmp/wordpress.tar.gz`). Assuming you don't need to keep the archive file after
    it's been unpacked, it's usually a good idea to put it in `/tmp`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标题给出了你希望归档文件下载到的位置（`/tmp/wordpress.tar.gz`）。假设你在解压后不需要保留归档文件，通常最好将其放在 `/tmp`
    中。
- en: The `extract` attribute determines whether or not Puppet should unpack the archive;
    this should usually be set to `true`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`extract` 属性决定 Puppet 是否应该解压归档文件；通常情况下，这应该设置为 `true`。'
- en: The `extract_path` attribute specifies where to unpack the contents of the archive.
    In this case, it makes sense to extract it to a subdirectory of `/var/www/`, but
    this will vary depending on the nature of the archive. If the archive file contains
    software which will be compiled and installed, for example, it may be a good idea
    to unpack it in `/tmp/`, so that the files will be automatically cleaned up after
    the next reboot.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`extract_path`属性指定了解压归档内容的位置。在本例中，将其解压到`/var/www/`的子目录是有意义的，但根据归档的性质，这个路径会有所不同。例如，如果归档文件包含需要编译和安装的软件，最好将其解压到`/tmp/`，这样在下次重启后，文件会被自动清理。'
- en: The `source` attribute tells Puppet where to download the archive from, usually
    (as in this example) a web URL.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`source`属性告诉Puppet从哪里下载归档文件，通常（如本例所示）是一个网页URL。'
- en: The `creates` attribute works exactly the same way as `creates` on an `exec`
    resource, which we looked at in [Chapter 4](ch04.html "Chapter 4. Understanding
    Puppet resources"), *Understanding Puppet resources*. It specifies a file which
    unpacking the archive will create. If this file exists, Puppet knows the archive
    has already been unpacked, so it does not need to unpack it again.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`creates`属性的作用与`exec`资源中的`creates`完全相同，我们在[第4章](ch04.html "第4章。理解Puppet资源")，*理解Puppet资源*中有详细讲解。它指定了一个文件，这个文件会在解压归档文件时创建。如果这个文件已经存在，Puppet就知道归档文件已经被解压，因此不需要再次解压。'
- en: The `cleanup` attribute tells Puppet whether or not to delete the archive file
    once it has been unpacked. Usually, this will be set to `true`, unless you need
    to keep the archive around or unless you don't need to unpack it in the first
    place.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cleanup`属性告诉Puppet是否在解压完归档文件后删除该文件。通常，这会设置为`true`，除非你需要保留归档文件，或者你根本不需要解压它。'
- en: Tip
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Once the file has been deleted by `cleanup`, Puppet won't redownload the archive
    file `/tmp/wordpress.tar.gz` the next time you apply the manifest, even though
    it has `ensure => present`. The `creates` clause tells Puppet that the archive
    has already been downloaded and extracted.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件被`cleanup`删除，Puppet在下次应用清单时不会重新下载归档文件`/tmp/wordpress.tar.gz`，即使它的`ensure
    => present`。`creates`子句告诉Puppet这个归档文件已经下载并解压过。
- en: Exploring the standard library
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索标准库
- en: One of the oldest-established Puppet Forge modules is `puppetlabs/stdlib`, the
    official Puppet standard library. We looked at this briefly earlier in the chapter
    when we used it as an example of installing a module with `r10k`, but let's look
    more closely now and see what the standard library provides and where you might
    use it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`puppetlabs/stdlib`是最古老的Puppet Forge模块之一，也是官方的Puppet标准库。我们在本章前面简要地看过它，当时用它作为使用`r10k`安装模块的示例，但现在让我们更仔细地看看它提供了什么功能，以及你可以在哪里使用它。'
- en: Rather than managing some specific software or file format, the standard library
    aims to provide a set of functions and resources which could be useful in any
    piece of Puppet code. Consequently, well-written Forge modules use the facilities
    of the standard library rather than implementing their own utility functions which
    do the same thing.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库的目标并不是管理某些特定的软件或文件格式，而是提供一组可以在任何Puppet代码中使用的功能和资源。因此，编写良好的Forge模块会利用标准库的功能，而不是自己实现相同功能的工具函数。
- en: 'You should do the same in your own Puppet code: when you need a particular
    piece of functionality, check the standard library first to see if it solves your
    problem rather than implementing it yourself.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在自己的Puppet代码中做到这一点：当你需要某个特定功能时，先检查标准库，看看它是否能解决你的问题，而不是自己实现。
- en: 'Before trying the examples in this section, make sure the `stdlib` module is
    installed by following these steps: If you''ve previously followed the steps in
    the *Using r10k* section, the required module will already be installed. If not,
    run the following commands to install it:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试本节中的示例之前，请确保按照以下步骤安装`stdlib`模块：如果你之前按照*使用r10k*一节的步骤操作过，所需的模块已经安装。如果没有，请运行以下命令来安装它：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Safely installing packages with ensure_packages
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全安装软件包与ensure_packages
- en: 'As you know, you can install a package using the `package` resource, like this
    (`package.pp`):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，你可以使用`package`资源来安装软件包，像这样（`package.pp`）：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'But what happens if you also install the same package in another class in a
    different part of your manifest? Puppet will refuse to run, with an error like
    this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在清单的另一个类中安装了相同的软件包，会发生什么呢？Puppet会拒绝运行，并出现类似这样的错误：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If both of your classes really require the package, then you have a problem.
    You could create a class which simply declares the package, and then include that
    in both classes, but that is a lot of overhead for a single package. Worse, if
    the duplicate declaration is in a third-party module, it may not be possible,
    or advisable, to change that code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的两个类都确实需要这个包，那么你就会遇到问题。你可以创建一个简单声明包的类，然后将它包含在这两个类中，但对于一个包来说，这会带来很大的开销。更糟糕的是，如果重复声明存在于第三方模块中，可能无法，也不建议修改该代码。
- en: 'What we need is a way to declare a package which will not cause a conflict
    if that package is also declared somewhere else. The standard library provides
    this facility in the `ensure_packages()` function. Call `ensure_packages()` with
    an array of package names, and they will be installed if they are not already
    declared elsewhere (`package_ensure.pp`):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是一种声明包的方法，如果该包也在其他地方声明，则不会导致冲突。标准库在`ensure_packages()`函数中提供了这一功能。调用`ensure_packages()`并传入一个包名数组，如果这些包尚未在其他地方声明，它们将被安装（`package_ensure.pp`）：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To apply this example, run the following command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用这个示例，请运行以下命令：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can try all the remaining examples in this chapter in the same way. Make
    sure you supply the `--environment=pbg` switch to `puppet apply`, as the necessary
    modules are only installed in the `pbg` environment.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以相同的方式尝试本章中的所有剩余示例。确保将`--environment=pbg`开关传递给`puppet apply`，因为所需的模块仅在`pbg`环境中安装。
- en: 'If you need to pass additional attributes to the `package` resource, you can
    supply them in a hash as the second argument to `ensure_packages()`, like this
    (`package_ensure_params.pp`):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要向`package`资源传递额外的属性，可以将它们作为第二个参数通过哈希传递给`ensure_packages()`，像这样（`package_ensure_params.pp`）：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Why is this better than using the `package` resource directly? When you declare
    the same `package` resource in more than one place, Puppet will give an error
    message and refuse to run. If the package is declared by `ensure_packages()`,
    however, Puppet will run successfully.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这比直接使用`package`资源更好？当你在多个地方声明相同的`package`资源时，Puppet会给出错误消息并拒绝执行。然而，如果该包是通过`ensure_packages()`声明的，Puppet将成功执行。
- en: Since it provides a safe way to install packages without resource conflicts,
    you should always use `ensure_packages()` instead of the built-in `package` resource.
    It is certainly essential if you're writing modules for public release, but I
    recommend you use it in all your code. We'll use it to manage packages throughout
    the rest of this book.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它提供了一种安全的方式来安装包而不会发生资源冲突，你应该始终使用`ensure_packages()`，而不是内置的`package`资源。如果你正在编写公开发布的模块，这肯定是必不可少的，但我建议你在所有代码中都使用它。我们将在本书的其余部分使用它来管理包。
- en: Modifying files in place with file_line
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`file_line`就地修改文件
- en: 'Often, when managing configuration with Puppet, we would like to change or
    add a particular line to a file, without incurring the overhead of managing the
    whole file with Puppet. Sometimes it may not be possible to manage the whole file
    in any case, as another Puppet class or another application may be managing it.
    We could write an `exec` resource to modify the file for us, but the standard
    library provides a resource type for exactly this purpose: `file_line`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在使用Puppet管理配置时，我们希望改变或添加文件中的某一行，而不必承担用Puppet管理整个文件的开销。有时候，管理整个文件本来就不可行，因为另一个Puppet类或另一个应用程序可能已经在管理它。我们可以编写一个`exec`资源来修改文件，但标准库提供了一个正是为此目的而设计的资源类型：`file_line`。
- en: 'Here''s an example of using the `file_line` resource to add a single line to
    a system config file (`file_line.pp`):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`file_line`资源向系统配置文件添加一行的示例（`file_line.pp`）：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If there is a possibility that some other Puppet class or application may need
    to modify the target file, use `file_line` instead of managing the file directly.
    This ensures that your class won't conflict with any other attempts to control
    the file.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有可能某个其他Puppet类或应用程序需要修改目标文件，请使用`file_line`，而不是直接管理文件。这可以确保你的类不会与任何其他试图控制文件的操作发生冲突。
- en: 'You can also use `file_line` to find and modify an existing line, using the
    `match` attribute (`file_line_match.pp`):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`file_line`查找并修改现有行，使用`match`属性（`file_line_match.pp`）：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The value of `match` is a regular expression, and if Puppet finds a line in
    the file which matches this expression, it will replace it with the value of `line`.
    (If you need to potentially change multiple lines, set the `multiple` attribute
    to `true` or Puppet will complain when more than one line matches the expression.)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`match` 的值是一个正则表达式，如果 Puppet 在文件中找到匹配此表达式的行，它将用 `line` 的值替换该行。（如果你需要更改多行，请将
    `multiple` 属性设置为 `true`，否则当多行匹配表达式时，Puppet 会报错。）'
- en: 'You can also use `file_line` to delete a line in a file if it is present (`file_line_absent.pp`):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `file_line` 来删除文件中的某一行，如果该行存在的话（`file_line_absent.pp`）：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that when using `ensure => absent`, you also need to set the `match_for_absence`
    attribute to `true` if you want Puppet to actually delete matching lines.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当使用 `ensure => absent` 时，如果希望 Puppet 实际删除匹配的行，还需要将 `match_for_absence` 属性设置为
    `true`。
- en: Introducing some other useful functions
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍其他一些有用的函数
- en: 'The `grep()` function will search an array for a regular expression and return
    all matching elements (`grep.pp`):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep()` 函数将在数组中搜索正则表达式，并返回所有匹配的元素（`grep.pp`）：'
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `member()` and `has_key()` functions return `true` if a given value is
    in the specified array or hash, respectively (`member_has_key.pp`):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`member()` 和 `has_key()` 函数如果给定的值分别在指定的数组或哈希中，则返回 `true`（`member_has_key.pp`）：'
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `empty()` function returns `true` if its argument is an empty string, array,
    or hash (`empty.pp`):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`empty()` 函数在其参数为空字符串、数组或哈希时返回 `true`（`empty.pp`）：'
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `join()` function joins together the elements of a supplied array into
    a string, using a given separator character or string (`join.pp`):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`join()` 函数将提供的数组元素连接成一个字符串，使用指定的分隔符字符或字符串（`join.pp`）：'
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `pick()` function is a neat way to provide a default value when a variable
    happens to be empty. It takes any number of arguments and returns the first argument
    which is not undefined or empty (`pick.pp`):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`pick()` 函数是一个很好的方式，当变量为空时提供默认值。它接受任意数量的参数，并返回第一个非未定义或非空的参数（`pick.pp`）：'
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Sometimes you need to parse structured data in your Puppet code which comes
    from an outside source. If that data is in YAML format, you can use the `loadyaml()`
    function to read and parse it into a native Puppet data structure (`loadyaml.pp`):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要解析来自外部源的结构化数据。如果数据是 YAML 格式的，可以使用 `loadyaml()` 函数将其读取并解析为本地 Puppet 数据结构（`loadyaml.pp`）：
- en: '[PRE40]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `dirname()` function is very useful if you have a string path to a file
    or directory and you want to reference its parent directory, for example to declare
    it as a Puppet resource (`dirname.pp`):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`dirname()` 函数非常有用，如果你有一个指向文件或目录的路径字符串，并且你想引用它的父目录，例如将其声明为 Puppet 资源（`dirname.pp`）：'
- en: '[PRE41]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The pry debugger
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pry 调试器
- en: 'When a Puppet manifest doesn''t do quite what you expect, troubleshooting the
    problem can be difficult. Printing out the values of variables and data structures
    with `notice()` can help as can running `puppet apply -d` to see detailed debug
    output, but if all else fails, you can use the standard library''s `pry()` method
    to enter an interactive debugger session (`pry.pp`):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Puppet 清单没有按预期工作时，故障排除可能会很困难。使用 `notice()` 打印变量和数据结构的值可能有帮助，或者运行 `puppet apply
    -d` 查看详细的调试输出，但如果这些方法都失败了，你可以使用标准库的 `pry()` 方法进入交互式调试会话（`pry.pp`）：
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'With the `pry` gem installed in Puppet''s context, you can call `pry()` at
    any point in your code. When you apply the manifest, Puppet will start an interactive
    Pry shell at the point where the `pry()` function is called. You can then run
    the `catalog` command to inspect Puppet''s catalog, which contains all the resources
    currently declared in your manifest:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puppet 的上下文中安装了 `pry` gem 后，你可以在代码的任何位置调用 `pry()`。当你应用清单时，Puppet 会在调用 `pry()`
    函数的地方启动一个交互式 Pry shell。你可以运行 `catalog` 命令来检查 Puppet 的目录，该目录包含当前在清单中声明的所有资源：
- en: '[PRE43]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Once you've finished inspecting the catalog, type `exit` to quit the debugger
    and continue applying your Puppet manifest.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 完成目录检查后，键入 `exit` 退出调试器并继续应用 Puppet 清单。
- en: Writing your own modules
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写你自己的模块
- en: As we've seen, a Puppet module is a way of grouping together a set of related
    code and resources that performs some particular task, like managing the Apache
    web server or dealing with archive files. But how do you actually create a module?
    In this section, we'll develop a module of our own to manage the NTP service,
    familiar to most system administrators as the easiest way to keep server clocks
    synchronized with the Internet time standard. (Of course, it's not necessary to
    write your own module for this because a perfectly good one exists on Puppet Forge.
    But we'll do so anyway, for learning purposes.)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Creating a repo for your module
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we're going to use our new module alongside others that we've installed from
    Puppet Forge, then we should create a new Git repo just for our module. Then we
    can add its details to our Puppetfile and have `r10k` install it for us.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''ve already worked through [Chapter 3](ch03.html "Chapter 3. Managing
    your Puppet code with Git"), *Managing your Puppet code with Git*, you''ll have
    created a GitHub account. If not, go to that chapter and follow the instructions
    in the *Creating a GitHub account and project* section before continuing:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Log in to your GitHub account and click on the **Start a project** button.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Create a new repository** screen, enter a suitable name for your repo
    (I'm using `pbg_ntp` for the Puppet Beginner's Guide's NTP module).
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **Initialize this repository with a README** box.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Create repository**.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: GitHub will take you to the project page for the new repository. Click on the
    **Clone or download** button. If you're using GitHub with an SSH key, as we discussed
    in [Chapter 3](ch03.html "Chapter 3. Managing your Puppet code with Git"), *Managing
    your Puppet code with Git*, copy the **Clone with SSH** link. Otherwise, click
    on **Use HTTP**S and copy the **Clone with HTTPS** link.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On your own computer, or wherever you develop Puppet code, run the following
    command to clone the new repo (use the GitHub URL you copied in the previous step
    instead of this one):'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: When the clone operation completes successfully, you're ready to get started
    with creating your new module.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Writing the module code
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you'll see if you look inside the Puppet Forge modules you've already installed,
    modules have a standard directory structure. This is so that Puppet can automatically
    find the manifest files, templates, and other components within the module. Although
    complex modules have many subdirectories, the only ones we will be concerned with
    in this example are manifests and files. In this section, we'll create the necessary
    subdirectories, write the code to manage NTP, and add a config file which the
    code will install.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All the code and files for this module are available in the GitHub repo at
    the following URL:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/bitfield/pbg_ntp](https://github.com/bitfield/pbg_ntp)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following commands to create the `manifests` and `files` subdirectories:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Create the file `manifests/init.pp` with the following contents:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create the file `files/ntp.conf` with the following contents:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Run the following commands to add, commit, and push your changes to GitHub
    (you''ll need to enter your GitHub username and password if you''re not using
    an SSH key):'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Notice that the `source` attribute for the `ntp.conf` file looks like the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We haven''t seen this kind of file source before, and it''s generally only
    used within module code. The `puppet://` prefix indicates that the file comes
    from within the Puppet repo, and the path `/modules/pbg_ntp/` tells Puppet to
    look within the `pbg_ntp` module for it. Although the `ntp.conf` file is actually
    in the directory `modules/pbg_ntp/files/`, we don''t need to specify the `files`
    part: that''s assumed, because this is a `file` resource. (It''s not just you:
    this confuses everybody).'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Rather than installing the `ntp` package via a `package` resource, we use `ensure_packages()`
    from the standard library, as described earlier in this chapter.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Creating and validating the module metadata
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every Puppet module should have a file in its top-level directory named `metadata.json`,
    which contains helpful information about the module that can be used by module
    management tools, including Puppet Forge.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the file `metadata.json` with the following contents (use your own name
    and GitHub URLs):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Most of these are fairly self-explanatory. `tags` is an array of strings which
    will help people find your module if it is listed on Puppet Forge, and it's usual
    to tag your module with the name of the software or service it manages (in this
    case, `ntp`).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: If your module relies on other Puppet modules, which is very likely (for example,
    this module relies on `puppetlabs/stdlib` for the `ensure_packages()` function)
    you use the `dependencies` metadata to record this. You should list each module
    used by your module along with the earliest and latest versions of that module
    which will work with your module. (If the currently-released version works, specify
    the next major release as the latest version. For example, if your module works
    with `stdlib` version 4.17.0 and that's the latest version available, specify
    5.0.0 as the highest compatible version.)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `operatingsystem_support` metadata lets you specify which operating
    systems and versions your module works with. This is very helpful for people searching
    for a Puppet module which will work with their operating system. If you know your
    module works with Ubuntu 16.04, as the example module does, you can list that
    in the `operatingsystem_support` section. The more operating systems your module
    can support, the better, so if possible, test your module on other operating systems
    and list them in the metadata once you know they work.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For full details on module metadata and how to use it, see the Puppet documentation:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.puppet.com/puppet/latest/reference/modules_metadata.html](https://docs.puppet.com/puppet/latest/reference/modules_metadata.html)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: It's important to get the metadata for your module right, and there's a little
    tool that can help you with this, called `metadata-json-lint`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following commands to install `metadata-json-lint` and check your metadata:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If `metadata-json-lint` produces no output, your metadata is valid and you can
    go on to the next steps. If you see error messages, fix the problem before continuing.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following commands to add, commit, and push your metadata file to GitHub:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Tagging your module
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like when you use third-party Puppet Forge modules, it's important to be
    able to specify in your Puppetfile the exact version of your module to be installed.
    You can do this by using Git tags to attach a version tag to a specific commit
    in your module repo. As you develop the module further and make new releases,
    you can add a new tag for each release.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first release of your module, which according to the metadata is version
    0.1.1, run the following commands to create and push the release tag:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Installing your module
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use `r10k` to install our new module, just as we did with the Puppet
    Forge modules, with one small difference. Since our module isn't on the Puppet
    Forge (yet), just specifying the name of the module in our Puppetfile isn't enough;
    we need to supply the Git URL so that `r10k` can clone the module from GitHub.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `mod` statement to your Puppetfile (using your GitHub URL
    instead of mine):'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Because the module also requires `puppetlabs/stdlib`, add this `mod` statement
    too:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now install the module in the normal way with `r10k`:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`r10k` can install a module from any Git repo you have access to; all you have
    to do is add the `:git` and `:tag` parameters to the `mod` statement in your Puppetfile.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Applying your module
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you''ve created, uploaded, and installed your module, we can use it
    in a manifest:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: If you're using the Vagrant box or a recent version of Ubuntu, your server will
    most likely be running NTP already, so the only change you'll see Puppet apply
    will be the `ntp.conf` file. Nonetheless, it confirms that your module works.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: More complex modules
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of course, the module we've developed is a very trivial example. However, it
    demonstrates the essential requirements of a Puppet module. As you become a more
    advanced Puppet coder, you will be creating and maintaining much more complicated
    modules, similar to those you download and use from Puppet Forge.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Real-world modules often feature one or more of the following components:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Multiple manifest files and subdirectories
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters (which may be supplied directly or looked up from Hiera data)
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom facts and custom resource types and providers
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example code showing how to use the module
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specs and tests which developers can use to validate their changes
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies on other modules (which must be declared in the module metadata)
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for multiple operating systems
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find more detailed information about modules and advanced features
    of modules in the Puppet documentation:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.puppet.com/puppet/latest/reference/modules_fundamentals.html](https://docs.puppet.com/puppet/latest/reference/modules_fundamentals.html)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Uploading modules to Puppet Forge
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s very easy to upload a module to the Puppet Forge: all you need to do
    is sign up for an account, use the `puppet module build` command to create an
    archive file of your module, and upload it via the Puppet Forge website.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Before deciding to write a module in the first place, though, you should check
    whether there is already a module on the Puppet Forge which does what you need.
    There are over 4,500 modules available at the time of writing, so it's quite likely
    that you'll be able to use an existing Puppet Forge module instead of writing
    your own. Contributing a new module when there is already one available just makes
    it more difficult for users to choose which module they should use. For example,
    there are currently 150 modules which manage the Nginx web server. Surely this
    is at least 149 too many, so only submit a new module if you've made sure that
    there are no similar modules already on the Puppet Forge.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: If there is a module which covers the software you want to manage, but it doesn't
    support your operating system or version, consider improving this module instead
    of starting a new one. Contact the module author to see whether and how you can
    help improve their module and extend support to your operating system. Similarly,
    if you find bugs in a module or want to make improvements to it, open an issue
    (if there is an issue tracker associated with the module), fork the GitHub repo
    (if it's versioned on GitHub), or contact the author to find out how you can help.
    The vast majority of Puppet Forge modules are written and maintained by volunteers,
    so your support and contributions benefit the entire Puppet community.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: If you don't want to fork or contribute to an existing module, consider writing
    a small wrapper module which extends or overrides the existing module, rather
    than creating a new module from scratch.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: If you do decide to write and publish your own module, use facilities from the
    standard library wherever possible, such as `ensure_packages()`. This will give
    your module the best chance of being compatible with other Forge modules.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to contribute more to the Puppet module community, consider joining
    the Vox Pupuli group, which maintains over a hundred open source Puppet modules:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[https://voxpupuli.org/](https://voxpupuli.org/)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've gained an understanding of Puppet modules, including
    an introduction to the Puppet Forge module repository. We've seen how to search
    for the modules we need and how to evaluate the results, including **Puppet Approved**
    and **Puppet Supported** modules, operating system support, and download count.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve looked at using the `r10k` tool to download and manage Puppet modules
    in your infrastructure and how to specify the modules and versions you need in
    your Puppetfile. We''ve worked through detailed examples of using three important
    Forge modules: `puppetlabs/apache`, `puppetlabs/mysql`, and `puppet/archive`.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了如何使用`r10k`工具下载和管理基础设施中的Puppet模块，并且如何在Puppetfile中指定所需的模块和版本。我们通过详细的示例展示了如何使用三个重要的Forge模块：`puppetlabs/apache`、`puppetlabs/mysql`和`puppet/archive`。
- en: Introducing the standard library for Puppet, we've covered the use of `ensure_packages()`
    to avoid package conflicts between modules, the `file_line` resource, which provides
    line-level editing for config files, and a host of useful functions for manipulating
    data, as well as looking at the Pry debugger.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 引入Puppet标准库后，我们介绍了如何使用`ensure_packages()`避免模块之间的包冲突，`file_line`资源（用于对配置文件进行行级编辑），以及一系列用于数据操作的有用函数，同时还介绍了Pry调试器。
- en: To fully understand how modules work, we've developed a simple module from scratch
    to manage the NTP service, hosted in its own Git repository and managed via a
    Puppetfile and `r10k`. We've seen what metadata modules require and how to create
    it and validate it using `metadata-json-lint`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分理解模块的工作原理，我们从零开始开发了一个简单的模块来管理NTP服务，该模块托管在自己的Git仓库中，并通过Puppetfile和`r10k`进行管理。我们了解了模块所需的元数据，以及如何使用`metadata-json-lint`创建和验证这些元数据。
- en: Finally, we've looked at some of the features of more sophisticated modules,
    discussed uploading modules to the Puppet Forge, and outlined some considerations
    to bear in mind when you're deciding whether to start a new module or extend and
    improve an existing one.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了一些更复杂模块的特性，讨论了将模块上传到Puppet Forge，并概述了在决定是开始一个新模块还是扩展和改进现有模块时需要考虑的事项。
- en: In the next chapter, we'll look at how to organize your Puppet code into classes,
    how to pass parameters to your classes, how to create defined resource types,
    and how to structure your manifests using roles, profiles, and how to include
    classes on a node using Hiera data.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何将Puppet代码组织为类，如何将参数传递给类，如何创建定义的资源类型，以及如何使用角色、配置文件来结构化清单，并且如何使用Hiera数据在节点上包含类。
