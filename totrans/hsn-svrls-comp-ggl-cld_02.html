<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Introducing App Engine</h1>
                </header>
            
            <article>
                
<p class="mce-root">In<span> this first chapter, we will discuss the main properties of <strong>Google App Engine </strong>(<strong>GAE</strong>) and its <strong>Platform-as-a-Service </strong></span><span>(<strong>PaaS</strong>)</span><span> approach. <span>Available since 2008, GAE provides a serverless environment in which to deploy HTTP/web-based applications. </span></span></p>
<p class="mce-root">Throughout this chapter, we will explore GAE's framework and structure to see how highly scalable applications are made possible on this platform. As part of this, we will consider how to integrate standard web primitives such as traffic splitting and API management on GAE. By the end of this chapter, you should have a solid foundation to help you build web-based applications using GAE quickly.</p>
<p>In a nutshell, we will cover the following topics in this chapter:</p>
<ul>
<li>Introducing GAE</li>
<li>Understanding the GAE framework</li>
<li>Defining App Engine components</li>
<li>Understanding GAE's features</li>
</ul>
<p> </p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing GAE</h1>
                </header>
            
            <article>
                
<p class="mce-root">When it comes to software engineering innovation, it is clear that Google has a rich history. This innovation has been evident across many successful projects, including several billion-user products brought to market, such as Google Search, Android, and YouTube. Google Cloud and its vibrant ecosystem of services provide tools built to serve these critical projects, and now you can host your application on the same platform.</p>
<p class="mce-root">GAE is designed to host web-based applications and elegantly handle request/response communications. Understanding how to achieve this on Google Cloud will be central to building consistent and efficient applications that can delight end users with their responsiveness.</p>
<p class="mce-root">Before delving into the details of GAE, let's spend some time discussing the rationale behind the application platform. For the following paragraphs, we will outline the main elements of GAE, which will provide us with sufficient knowledge to make intelligent decisions around what types of application would benefit from being run on GAE and, conversely, what applications would not.</p>
<p class="mce-root">To begin our journey, let's commence by answering the following questions to build a shared understanding of what the GAE application platform provides:</p>
<ul>
<li>Why go serverless with App Engine?</li>
<li>What is the underlying App Engine framework?</li>
<li>How does App Engine handle auto-scaling?</li>
<li>Who is the target audience?</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Why go serverless with App Engine?</h1>
                </header>
            
            <article>
                
<p class="mce-root">Making a service available on the internet requires a lot of thought to minimize the potential for system compromise and associated security risks. All application traffic to App Engine is propagated via the <strong>Google Front End</strong> (<strong>GFE</strong>) service<strong> </strong>to mitigate access protocol compromise.</p>
<p class="mce-root">GFE provides a <strong>Transport Layer Security</strong> (<strong>TLS</strong>) termination for all GAE-registered routed web traffic. Acting as a protection layer, GFE is capable of performing several essential security services for a Google Cloud project. From a security perspective, it provides the public IP hosting of a public DNS name and <strong>Denial of Service</strong> (<strong>DoS</strong>) protection. Besides, GFE can also be used by internal services as a scalable reverse proxy.</p>
<p class="mce-root"/>
<p class="mce-root">When working on Google Cloud, a term commonly mentioned is <strong>security in depth</strong>. An approach such as this provides multiple concurrent safeguards for your environment that work against bad actors wishing to misuse your service. Many of these security safeguards are built into the platform, so no additional effort is required on the part of the developer.</p>
<p class="mce-root">GAE provides a fully managed application platform that enables developers to only concern themselves with building their application. Concerns regarding the management of lower-level infrastructures, such as compute and storage, are automatically managed by the service. In this respect, serverless solutions such as GAE offer the ability to devote focus to the development process and leave operational matters to the provider of the service.</p>
<p class="mce-root">GAE enables developers to take advantage of a simplified serverless environment that addresses hosting the web application and API services on Google Cloud. By providing a significantly simplified environment, the intent is to increase the adoption of the cloud platform by bringing more developers to the cloud. In most instances, when a developer uses such a system, they can immediately see the vast potential for efficiency to be gained by working within an environment such as this.</p>
<p class="mce-root">In the following diagram, we outline a logical view of the typical workflow of an environment based on GAE. From the illustration, we can see that all external communication is performed using the HTTP(S) protocol and is routed via <strong>Cloud Load Balancer</strong> (provided by GFE). In this scenario, the frontend device exposes a single service name that encapsulates the application resource deployed. The service enables GAE to direct traffic received to multiple backend resource components dynamically. GAE maintains responsibility for establishing which role these components performed and ensures that each of them remains distinct for the purposes of identification:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-810 image-border" src="assets/62472f4f-4ed1-4e78-9ddf-577df7beaedd.png" style=""/></div>
<p>Backend service communication use the HTTP/HTTPS protocol, which means that GAE assumes an internet-based environment (that is, it assumes that you have access to a public-facing internet connection). Application request processing is performed by the default instance that's deployed, and this instance is subject to autoscaling based on system workload thresholds.</p>
<p>Taking the described approach enables workloads to be seamlessly load balanced across application instances, again without any additional configuration needed from the developer. Standard workload operational activities such as TLS termination and DNS resolution require no further user configuration. The addition of these activities provides a significant benefit to the developer. Application workloads being subject to isolated instances means the application is also capable of massive scale without any substantive work.</p>
<p>In addition to standard protection, the addition of GFE also provides seamless compatibility with secure delivery protocols such as gRPC (<a href="https://grpc.io/blog/principles/">https://grpc.io/blog/principles/</a>). The gRPC protocol uses the RPC framework to provide layer isolation when forwarding requests for the service. Also, communication remains encrypted by default to avoid the nuisance of communication eavesdropping or device compromise when performing inter-service communication.</p>
<p>The more recent adoption by the industry has seen broader adoption of gRPC developing more extensive compatibility across a range of services. The RPC security protocol is used extensively at Google, for example, to secure API access. When working with communication protocols across the internet, many standards exist. Having all service-related traffic routed through GFE means an incredibly flexible and scalable frontend is available without any additional work.</p>
<p>There are two versions of the App Engine available:</p>
<ul>
<li>App Engine Standard</li>
<li>App Engine Flex</li>
</ul>
<p>Both versions share many commonalities, and the majority of what's outlined in this chapter will apply to both <span>equally</span>. However, there are some key attributes to call out when thinking about the two environments, highlighted in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-811 image-border" src="assets/051341f0-b1c1-417c-aa79-4a6a5eabcef8.png" style=""/></div>
<p class="mce-root">One of the main things to call out in the preceding diagram is that App Engine Standard scales down to zero. However, an App Engine Flex environment scales down to a minimum of one instance. Therefore, if your primary consideration is cost, use App Engine Standard. Being able to scale down to zero provides a real advantage over the App Engine Flex environment, which will always have a cost associated with it.</p>
<p class="mce-root">The ability of GAE Standard to scale to zero is due to the use of a sandbox environment. Using a dedicated sandbox provides quicker responses, that is, quicker start-up times and auto-scaling responses. Having deployment time measured in seconds may also be an advantage that appeals when considering the level of flexibility that may be required by different application growth patterns.</p>
<p class="mce-root">Unlike the standard environment, GAE Flex uses <strong>Google Compute Engine</strong> (<strong>GCE</strong>), more specifically <strong>Managed Instance Groups</strong> (<strong>MIGs</strong>), to enable auto-scaling. An overhead of one compute instance is always present for GAE Flex when working within this environment. Resultant costs also need to factor in how many compute resources GAE Flex requires. Maintaining an application in this environment will also mean a slower initialization time (that is, cold boot) due to the requirement to spin up a GCE instance plus a container environment for any flexible-based deployed application.</p>
<p class="mce-root"/>
<p class="mce-root">There are further differences evident in the application environments. However, the preceding characteristics are the ones that commonly impact decision making when starting to build an application on GAE. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Who is the target audience?</h1>
                </header>
            
            <article>
                
<p><span>Working on the GAE fully managed serverless application platform removes many of the historical constraints associated with building internet-scale applications. Using this new paradigm, developers can focus on building sophisticated web applications and APIs without needing to learn about backend services and low-level networking or infrastructure.</span></p>
<p><span>Building serverless applications means that agile code is quickly deployed to the cloud. Web apps (for examples, see the following list) are most definitely the sweet spot for this type of solution:</span></p>
<ul>
<li><span>Web applications</span></li>
<li><span>Mobile backends</span></li>
<li><span>HTTP APIs</span></li>
<li><strong>Line of Business Applications</strong> (<span><strong>LOB</strong>) applications</span></li>
</ul>
<p><span>If that sounds like an area that your workload would benefit from, then you are the target audience. Working in an environment where it is not necessary to concern yourself with creating or maintaining infrastructure is highly desirable to most developers. GAE is built on this premise and provides an excellent experience for developers to develop and deploy without reference to underlying technologies.</span></p>
<p><span>Having outlined the differences in the environments provided for App Engine, we can start to explore what makes this such a fascinating product.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the App Engine framework</h1>
                </header>
            
            <article>
                
<p>Exploring the general architecture of App Engine brings to light how much of the underlying framework has been put in place to deliver integrated workflows for web application development.</p>
<p>Google has bundled many internal services to minimize the effort needed by developers to make their applications cloud-native. Added to that is the innate ability of the GAE service to automatically scale without any additional actions required on the part of the service creator.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Creating a web application on this platform can be as simple as deploying your code to the App Engine environment. However, behind the scenes, there are several activities taking place to ensure that the application is deployed successfully, the infrastructure is provisioned, and the whole thing is ultimately able to scale intelligently. So, what is happening in the underlying App Engine framework is illustrated in the following diagram, in which we introduce the optional components supporting App Engine:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-812 image-border" src="assets/8178a4b2-baa4-4d46-b868-896662e807b2.png" style=""/></div>
<p><span>Examining GAE from a broader perspective shows that there are many high-level components used to establish the fully managed application platform. Of course, being a serverless environment, there is no real need for you to understand what is happening behind the scenes.</span></p>
<p><span>Having a conceptual understanding of what is occurring on any platform is useful during the development process. No matter how much a service tries to abstract information from you, it is immeasurably easier to resolve technical issues when you have some understanding of how the various components integrate.</span></p>
<p><span>In addition to the standard environment, GAE Flex supports custom container runtime environments. Custom containers are deployed on GCE and enable the developer to build their environments. In doing this, a higher level of customization was suddenly available and significantly broadened the appeal of GAE to a broader audience. The ubiquity of containers has made the introduction of the GAE Flex environment a compelling option where greater control is required.</span></p>
<p><span>There are, however, some performance and cost implications to using GAE Flex over the standard environment. Understanding these constraints is crucial for the application developer and they are clearly outlined in the specification for GAE. Having clarity regarding the various advantages and disadvantages of design considerations will help address any concerns and make the selection of the most appropriate environment easier. For more details on the differences, refer to the</span> <em><span>Runtime languages supported</span></em><span> section of this chapter.</span></p>
<p><span>In addition to the GAE environment outlined previously, some other essential constituent components are working in the background. A service layer adds to the compute function of GAE and provides the ability to store, queue, cache, and perform authenticated communication with the Google Cloud API. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">App Engine components</h1>
                </header>
            
            <article>
                
<p><span>Over the next couple of sub-sections, we will explore the main points related to these service layer </span>components.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Task queues</h1>
                </header>
            
            <article>
                
<p>Systems remain responsive through the use of additional decoupling algorithms that manage the flow of information. GAE uses message queues to maintain a sub-second response rate for web traffic. Long-lived processing is handed off to the task queue system to free up the request/response cycle.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>At a more granular level, task queues use two approaches to manage the asynchronous processing of information associated with a web request/response cycle:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Service dispatch</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><span>Push Queue (HTTP reque</span><span>st)</span></p>
</td>
<td>
<p>Dispatch requests.</p>
<p>Guaranteed task execution.</p>
<p>Use case: En-queue a short-lived task that can be fulfilled over time or in a situation that involves a time-specific action, similar to a diarized event task execution.</p>
</td>
</tr>
<tr>
<td>
<p><span>Pull Queue (Request handler)</span></p>
</td>
<td>
<p>Lease mechanism.</p>
<p>Provides additional flexibility beyond dispatch requests.</p>
<p>Provides a lifecycle for tasks.</p>
<p>Use case: Batch processing that can be used to achieve an outcome at once, without needing to process information one item at a time.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Task queues provide a dispatch mechanism that is isolated from the web traffic transaction. In this service, we segregate the processing element of information related to the web request to minimize the time to complete between request and response. Adding a task queue provides the HTTP request/response cycle with the ability to maintain a high level of efficiency.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Memcache</h1>
                </header>
            
            <article>
                
<p><span>A vital feature of the GAE environment is the inclusion of memcache. Memcache is abstracted from persistent storage to provide a buffer for fast data access. Adding a low-latency data tier for applications establishes a consistent mechanism for repeatable access requests. Memcache provides a convenient data access tier based on the memory-resident (in-memory) temporary storage of transient data.</span></p>
<p><span>There are two levels of the memcache service defined for the service layer:</span></p>
<ul>
<li><span><strong>A shared memcache</strong>: This is the default setting for GAE. S</span>hared memcache provides a default access mode. In most situations, there is no requirement to change the cache level applied to your application as the default will suffice for the majority of work to be performed.</li>
</ul>
<ul>
<li><span><strong>A dedicated memcache</strong>: This is an advanced setting used to reserve a dedicated application memory pool.</span></li>
</ul>
<p class="mce-root"/>
<p><span>A dedicated memcache service provides additional scope for getting greater efficiency in an application. As a cache represents a quick data retrieval mechanism to access temporary data, if data access is central to an application, it may well be useful to investigate this option.</span></p>
<div class="packt_infobox"><span>Be aware that this latter option is a paid offering, unlike the default cache setting. However, this option guarantees the reservation of a larger memory footprint for applications that might require high-frequency data access.</span></div>
<p>When working with an application primarily used in read mode, on the data to be consumed, it is beneficial to keep both memcache and the data storage in sync. Read mode is perhaps the most common use case that most GAE developers will encounter and, for this type of scenario, GAE is more than capable of meeting most of the application demands faced.</p>
<p>More sophisticated use cases exist, such as database modes requiring both read and write synchronization. Between the cache layer and backend database, there needs to be consideration of how to manage the cache layer and Datastore integration. For situations where interaction with the Datastore is a priority, Cloud NDB caching provides a configuration for more advanced requirements. An element of the investigation will be beneficial in this use case to optimize the data management and refreshing of data. In this situation, the underlying system will only be able to provide limited optimizations, and further efficiencies will need additional design as part of the iterative application development life cycle.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data storage</h1>
                </header>
            
            <article>
                
<p>GAE has multiple options for data storage, including schemaless and relational database storage. Backend data storage, such as Datastore/Firestore or Cloud SQL, enables developers to deliver consistent access across a wide range of use cases that integrate seamlessly with GAE.</p>
<p>The following table provides a high-level overview of the mapping between schemaless and relational databases:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Cloud SQL (relational)</strong></p>
</td>
<td>
<p><strong>Cloud Datastore (schemaless)</strong></p>
</td>
</tr>
<tr>
<td>
<p>Table</p>
</td>
<td>
<p>Kind</p>
</td>
</tr>
<tr>
<td>
<p>Row</p>
</td>
<td>
<p>Entity</p>
</td>
</tr>
<tr>
<td>
<p>Column</p>
</td>
<td>
<p>Property</p>
</td>
</tr>
<tr>
<td>
<p>Primary key</p>
</td>
<td>
<p>Key</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p class="mce-root"/>
<p>App Engine provides multiple options to give developers the ability to work with backend storage that suits the purpose of the application. In most instances, it is also essential to consider how to store information within the Datastore selected. As with any development, it is also crucial to understand the underlying data and how it will be accessed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cloud Datastore</h1>
                </header>
            
            <article>
                
<p><span>Cloud Datastore will be a standard component for any GAE development performed. As per the rest of the application platform, very little understanding of database management is required upfront. Datastore, as a managed schemaless (NoSQL) document database, will be sufficient in most instances.</span></p>
<p><span>The following high-level points are most pertinent to using Datastore with GAE:</span></p>
<ul>
<li><span>Datastore is a NoSQL schemaless database.</span></li>
<li><span>App Engine API access.</span></li>
<li><span>Designed to auto-scale to massive datasets (that is, low-latency reads/writes).</span></li>
<li><span>Stores information concerning the handling of requests.</span></li>
<li><span>All queries are served by previous build indexes.</span></li>
</ul>
<p><span>As a core component of App Engine, Cloud Datastore caters to high performance, application development, and automatic scaling. Once the Datastore has initialized, it is ready for data. Working with data persisted in Cloud</span> Datastore i<span>s very easy as no upfront work is required to attach the data to the backend. However, this may be potentially off-putting if you are from a relational database background.</span></p>
<p><span>When creating a database, it is worth considering how to index information to ensure that access remains performant regardless of the use. There are many good references on building suitable mechanisms for accessing data, for example, how to create fundamental indexes and composite indexes. Becoming familiar with this will provide ongoing benefits should issues arise, for example, performance latency with an application hosted on GAE.</span></p>
<div class="packt_infobox">It is essential to consider how the information within Datastore will be stored. In the instance where your Datastore is not central to your application, the data management question will not be relevant when creating a data-centric application. Datastore performance degradation resulting from an inefficient data layout requires consideration of how the data representation may save the significant effort of refactoring at a later stage.</div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>At this point, knowing that schemaless databases are a good match for most App Engine requirements and that Cloud Datastore is a document database, provide a massive clue to their use cases. Going beyond the initial conditions of storing document data (for example, entities and kinds) is where putting some thought into the proper access methods will yield benefits as the application increases in complexity.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cloud SQL</h1>
                </header>
            
            <article>
                
<p class="mce-root">When working with Cloud SQL, there are two products currently available on Google Cloud, that is, MySQL and Postgres. Both options provide managed relational databases used in conjunction with GAE. To clarify, <em>managed</em> in this context means the service provider is responsible for the maintenance of backups and updates without requiring user interaction.</p>
<p class="mce-root">Cloud SQL provides a relational model that supports transactions. If you have a relational requirement for your application deployed to App Engine, then consider using Cloud SQL. Working with multiple database types can be confusing, so, before development activities begin, aim to be clear as to how the Datastore selected is to be used. A key priority is to ensure that the design is representative of how the application uses information.</p>
<p class="mce-root">Attempting to make Datastore into an <strong>Online Transactional Processing</strong> (<strong>OLTP</strong>) backend is an unnecessary task. Similarly, trying to utilize schemaless data in a Cloud SQL database without a relevant schema or normalization will not result in optimal performance.</p>
<p class="mce-root">While it is vital to invest time to define the correct normalization for the schema to be applied, this requirement may change over time. Working with data is never as simple as uploading content and then forgetting about it, so pay particular attention to this part of your application development life cycle to generate the most benefit.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling auto-scaling on App Engine</h1>
                </header>
            
            <article>
                
<p>In this section, we look at how App Engine handles autoscaling. In most instances, GAE will handle any workload using its distributed architecture. Of course, if you have more advanced requirements, then it is worth the effort to understand how GAE performs instance auto-scaling.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Within GAE, instance scaling definitions are within the configuration files. Two configuration items are specifically relevant and outlined here (that is, scaling type and instance class):</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td style="width: 9.39335%">
<p><strong>Scaling type</strong></p>
</td>
<td style="width: 10%">
<p><strong>Instance class</strong></p>
</td>
<td style="width: 86.3014%">
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td style="width: 9.39335%">
<p>Manual</p>
</td>
<td style="width: 10%">
<p>Resident</p>
</td>
<td style="width: 86.3014%">
<p>Several upfront instances are available. Amending the number of instances would require manual intervention by the system administrator.</p>
</td>
</tr>
<tr>
<td style="width: 9.39335%">
<p>Auto-scaling</p>
</td>
<td style="width: 10%">
<p>Dynamic</p>
</td>
<td style="width: 86.3014%">
<p>In response to telemetry data (for example, response latency, and request rate) gathered from the system, autoscaling decides whether it should increase/decrease the number of instances.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p><span>When thinking about auto-scaling a service, it is imperative to consider how to design your application to take advantage of the constituent components. Here are some considerations concerning building a scalable solution:</span></p>
<ul>
<li><span>Load testing is essential to establish the best performance design for your application. In most instances, working with real-world traffic provides the best scenario for testing system bottlenecks.</span></li>
<li><span>Google Cloud imposes quota limits on all projects, so be mindful of this when creating an application. Quota limits apply to API calls as well as compute-based resources.</span></li>
<li><span>In most instances, a single task queue will be sufficient. However, GAE does provide the ability to shard task queues when long-lived tasks require higher processing throughput.</span></li>
</ul>
<p>In the next section, we move away from the general architecture of App Engine to discuss the specifics of implementation. As part of this discussion, there will be an overview of the languages supported.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining App Engine components</h1>
                </header>
            
            <article>
                
<p>The objective of this section is to describe the details of GAE. <span>The nature of the GAE application platform is to provide a serverless application environment that is capable of supporting multiple language runtimes. Runtime support requires that there are two versions of App Engine in existence. A critical difference between these environments relates to the language runtimes supported.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Runtime languages supported</h1>
                </header>
            
            <article>
                
<p>Historically, the GAE runtime only supported a limited number of languages, but this has expanded <span>over time</span> to provide a broader range. A limitation on runtime languages was one of the most common criticisms of the original version of GAE when it was released over a decade ago. This situation has improved significantly in the intervening years, and today an expanded range of runtimes are now supported, including the following:</p>
<ul>
<li>Python 2.7/3.7</li>
<li>Java, Node.js 8/10</li>
<li>PHP 5.5/7.2</li>
<li>Go 1.9/1.11/1.12</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">App Engine – Standard</h1>
                </header>
            
            <article>
                
<p>In this environment, a sandbox wrapper provides application isolation and constrains access to specific external resources. Depending on the runtime selected, security measures enforce the sandbox environment, for example, the application of access control lists, and the replacement of language libraries.</p>
<p>In the following diagram, GAE Standard uses a sandbox environment, supporting 0-N instances within a single availability zone:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-813 image-border" src="assets/114bc77d-1b57-46fd-98fa-e8a4acc2c26f.png" style=""/></div>
<p>When working with applications that require a runtime language such as Python, Java, Node.js, or Go, GAE Standard is the optimal choice. GAE Standard works within a sandbox environment and ensures instances can scale down to zero. Scaling to zero means a meager cost is incurred with this type of situation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">App Engine – Flexible</h1>
                </header>
            
            <article>
                
<p>In the GAE Flex environment, a container resides on a GCE instance. While in certain respects, this provides the same service access as GAE Standard, there are some disadvantages associated with moving from the sandbox to GCE, specifically instance warm-up speed and cost.</p>
<p>In the following diagram, GAE Flex uses a container environment for the creation of resources to support 1-N instances within a regional MIG:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-814 image-border" src="assets/12d4e5df-e5dd-4bcb-9d77-753a22f2c6c4.png" style=""/></div>
<p><span>The container residing on GCE is based on a Docker image and provides an alternative to the sandbox environment mentioned earlier. Using GAE Flex requires some compromise on both speed and cost. The speed sacrifice is attributed to initiating the container through the Cloud Build process necessary to deploy the code into the GAE environment. As at least one instance needs to be active at any point in time, this means this type of situation will always incur some degree of cost.</span></p>
<p><span>Although GAE hides the build process from you, the associated lead time for building a custom runtime versus the sandbox approach is not insignificant. On completion of the build process, the image is posted to Google Cloud Build and is ready for deployment within the</span> application. So, what are the main characteristics of GAE? The following sections will cover the main attributes of GAE.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding App Engine features</h1>
                </header>
            
            <article>
                
<p>Throughout the next few sub-sections, we will describe some of the critical facets of GAE, starting with application versioning.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Application versioning</h1>
                </header>
            
            <article>
                
<p>GAE uses a configuration file to manage application versions to deploy. The configuration file for the runtime selected, for example, <kbd>app.yaml</kbd> for Python deployments, contains the version ID associated with your application. In addition to the version, an application default denotes the primary instance to the system.</p>
<p>Each application version deployed will maintain its distinct URL so that the developer can view multiple versions at the same time. Similarly, releases can be upgraded or rolled back depending on the deployment scheme selected. As new code deploys, a unique index is applied to the configuration code to ensure that each application revision can successfully distinguish between the old and new version deployed.</p>
<p>In the following diagram, three versions of the application have deployed on GAE. However, traffic will only be routed to the default version, unless otherwise stated by the application administrator:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-815 image-border" src="assets/abc0772f-ae13-4e04-abb0-1f53625c95d7.png" style=""/></div>
<p>The approach taken by GAE means that deployments are straightforward to manage as the administrator of the system can make updates at the touch of a button. Similarly, they can also perform more complex deployments via the console without losing access to previous revisions of the application.</p>
<p>In addition to the built-<span>in</span> tools, App Engine supports source version control. Working with code stored in version control happens in much the same way as using local files. Deciding where system code access resolves is up to the developer; for example, they may choose to have code deployed using Cloud Source Repositories.</p>
<p>If you are unfamiliar with Google Cloud Source Repositories, it is essentially a Git repository directly associated with the project environment. If you are familiar with Git, then you will be able to get up and running using Google Source Repositories quickly. From here, it is entirely possible to mirror code from external sources such as Bitbucket, GitLab, or GitHub.</p>
<p><span>For more uncomplicated use cases, deploying from a local file may be satisfactory for most instances. However, moving to a more consistent approach can help with the management of code across a</span> project. Once the application successfully deploys, a decision on how to manage the traffic flow to this new deployment is the next step in the process. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Traffic splitting</h1>
                </header>
            
            <article>
                
<p><span>Traffic splitting provides a useful way to move between versions. GAE offers several options to make this process easier. Also, you don't need to keep track of the application version that is currently deployed.</span></p>
<p><span>The options available for GAE traffic splitting are these:</span></p>
<ul>
<li><span><strong>IP traffic</strong>: Using the source IP to determine which instance to serve responses from</span></li>
<li><span><strong>Cookie splitting</strong>: Applying session affinity to the web transaction based on a cookie named <kbd>GOOGAPPUID</kbd> with a value between 0-999</span></li>
<li><span><strong>Random</strong>: Using a randomization algorithm to serve content found with the preceding options</span></li>
</ul>
<p><span>In the following diagram, traffic routed to GAE is split between two instances. In this case, a 50% split is evident based on IP addresses:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-816 image-border" src="assets/fa602bf0-8014-40f4-9a0f-0a4a17a9f3a1.png" style=""/></div>
<p class="mce-root"/>
<p>The command to deploy ensures that a simple process is available that enables moving from one version to another. As a fully managed application platform, the onus is on App Engine to simplify how the application will be deployed based on defined traffic splitting preferences observed.</p>
<p>In an instance where a new deployment takes place, it is possible to tell App Engine how much of the traffic should be sent to the updated application deployment. A technique such as this is useful, for example, to perform A/B testing against two different deployed versions. Using this capability enables many different deployment and testing approaches to become available when looking to deploy a new release. Should there be an issue with the code that is implemented, there are numerous tools available to assist with this investigation. One such tool is Stackdriver, and we will be looking at the product more closely in the next section.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Monitoring, logging, and diagnostics</h1>
                </header>
            
            <article>
                
<p>Stackdriver is the default monitoring solution for Google Cloud. When observing information relating to GAE, in Stackdriver, the resource type <kbd>gae_app</kbd> can be used to filter information specifically associated with the environment data. In the following diagram, we see traffic to the project is managed by GCE, and it is this that is responsible for connectivity to other services such as <strong>Task Queues</strong>, <strong>Memcache</strong>, and <strong>Stackdriver</strong>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-817 image-border" src="assets/b70aa098-ad19-44df-b4ed-6b505fbb4cb3.png" style=""/></div>
<p><span>Stackdriver logging is available as standard for any GAE environment, providing the ability to see what operations are being performed in your application in real time. Logs generated via the application are available to interrogate as required. This logging process does not require any additional configuration and is available for all the application-related logs that are made available. For reference, when using records with GAE, it is essential to note the following data sources available in Stackdriver:</span></p>
<ul>
<li><strong>Request logs</strong>: These <span><span>provide the default information associated with requests made to the application. The resource for this log is named <kbd>request_log</kbd>. You can observe this in the <span class="packt_screen">Stackdriver Logs Viewer</span> under the <kbd>appengine.googleapis.com/request_log</kbd> filter.</span></span></li>
<li><strong>App logs</strong>:<span> These provide additional application information supplemental to the request log.</span></li>
<li><strong>Third-party logs</strong>:<span> These are application-specific and in addition to the preceding logs. There may be package-specific information sent to the system logs. Where present, there will be an entry available via the API accessible via the <span class="packt_screen">Logs Viewer</span>.</span></li>
</ul>
<p><span>Stackdriver Trace also doesn't require any additional instrumentation to work with App Engine. Working with this solution is automatically enabled to allow the monitoring of application trace data. The data is incorporated into the default GAE settings and will be accessible within the Stackdriver environment.</span></p>
<p>When working with App Engine Flex environments, logs use either Google Cloud Client Libraries or <kbd>stdout</kbd>/<kbd>stderr</kbd> to capture application-related information and push it to the centralized Stackdriver logging system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered a high-level introduction into the fully managed application platform App Engine. Working in this environment illustrates many of the usual infrastructure tasks related to development are performed automatically without recourse to the developer.</p>
<p>In general, GAE deployment is a fully managed activity that requires very little interaction to build, host, or execute code. The environment typically consists of a load balancer, a compute tier, and a services layer, all working in tandem to provide an integrated application platform. GAE provides a low-effort development environment built to do much of the heavy lifting for developers.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Now we have a general understanding of the App Engine environment. The next chapter will focus on introducing code samples to flesh out our experience and skill level.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What type of service dispatch is supported by task queues?</li>
<li>What are the two levels of service supported by memcache?</li>
<li>What type of database is Cloud Datastore?</li>
<li>Name a runtime language supported by GAE.</li>
<li>What forms of traffic-splitting algorithms are supported on GAE?</li>
<li>What is the purpose of GFE in relation to GAE?</li>
<li>Name the three types of scaling supported by GAE.</li>
<li>What mechanism is used to isolate long-lived workloads for efficiency purposes from the HTTP request/response life cycle?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li><span><strong>Choosing an App Engine environment</strong>:</span> <a href="https://cloud.google.com/appengine/docs/the-appengine-environments">https://cloud.google.com/appengine/docs/the-appengine-environments</a></li>
<li><span><strong>gRPC</strong>:</span> <a href="https://grpc.io/blog/principles/">https://grpc.io/blog/principles/</a></li>
<li><strong>NDB Caching</strong>: <a href="https://cloud.google.com/appengine/docs/standard/python/ndb/cache">https://cloud.google.com/appengine/docs/standard/python/ndb/cache</a></li>
<li><strong>Datastore and Firestore modes</strong>: <a href="https://cloud.google.com/datastore/docs/firestore-or-datastore">https://cloud.google.com/datastore/docs/firestore-or-datastore</a></li>
<li><strong>Cloud Source Repositories and App Engine</strong>: <a href="https://cloud.google.com/source-repositories/docs/quickstart-deploying-from-source-repositories-to-app-engine">https://cloud.google.com/source-repositories/docs/quickstart-deploying-from-source-repositories-to-app-engine</a></li>
</ul>


            </article>

            
        </section>
    </body></html>