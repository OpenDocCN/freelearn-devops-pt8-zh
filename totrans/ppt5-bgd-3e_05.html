<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Variables, expressions, and facts"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Variables, expressions, and facts</h1></div></div></div><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><span class="emphasis"><em>It is impossible to begin to learn that which one thinks one already knows.</em></span></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<span class="attribution"><span class="emphasis"><em>Epictetus</em></span></span></td></tr></table></div><p>In this chapter, you will learn about Puppet variables and data types, expressions, and conditional statements. You will also learn how Puppet manifests can get data about the node using Facter, find out which are the most important standard facts, and see how to create your own external facts. Finally, you will use Puppet's <code class="literal">each</code> function to iterate over arrays and hashes, including Facter data.</p><div class="mediaobject"><img src="graphics/B08880_05_01.jpg" alt="Variables, expressions, and facts"/></div><div class="section" title="Introducing variables"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec22"/>Introducing variables</h1></div></div></div><p>A <span class="strong"><strong>variable</strong></span> in <a id="id175" class="indexterm"/>Puppet is simply a way of giving a name to a particular value, which we could then use wherever we would use the literal value (<code class="literal">variable_string.pp</code>):</p><div class="informalexample"><pre class="programlisting">$php_package = 'php7.0-cli'

package { $php_package:
  ensure =&gt; installed,
}</pre></div><p>The dollar sign (<code class="literal">$</code>) tells Puppet that what follows is a variable name. Variable names must begin with a lowercase letter or an underscore, though the rest of the name can also contain uppercase letters or numbers.</p><p>A variable can contain different types of data; one such type is a <span class="strong"><strong>String</strong></span> (like <code class="literal">php7.0-cli</code>), but Puppet variables can also contain <span class="strong"><strong>Number</strong></span> or <span class="strong"><strong>Boolean</strong></span> values (<code class="literal">true</code> or <code class="literal">false</code>). Here are a few examples (<code class="literal">variable_simple.pp</code>):</p><div class="informalexample"><pre class="programlisting">$my_name = 'Zaphod Beeblebrox'
$answer = 42
$scheduled_for_demolition = true</pre></div><div class="section" title="Using Booleans"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec60"/>Using Booleans</h2></div></div></div><p>Strings and numbers are <a id="id176" class="indexterm"/>straightforward, but Puppet also has a special data type <a id="id177" class="indexterm"/>to represent true or false values, which we call <span class="strong"><strong>Boolean</strong></span> values, after the logician George Boole. We have already encountered some Boolean values in Puppet resource attributes (<code class="literal">service.pp</code>):</p><div class="informalexample"><pre class="programlisting">service { 'sshd':
  ensure =&gt; running,
  enable =&gt; true,
}</pre></div><p>The only allowed values for Boolean variables are the literal values <code class="literal">true</code> and <code class="literal">false</code>, but Boolean variables can also hold the values of conditional expressions (expressions whose value is <code class="literal">true</code> or <code class="literal">false</code>), which we'll explore later in this chapter.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip22"/>Tip</h3><p>You might be wondering what type the value <code class="literal">running</code> is in the previous example. It's actually a string, but a special, unquoted kind of string called a <span class="strong"><strong>bare word</strong></span>. Although <a id="id178" class="indexterm"/>it would be exactly the same to Puppet if you used a normal quoted string <code class="literal">'running'</code> here, it's considered good style to use bare words for attribute values which can only be one of a small number of words (for example, the <code class="literal">ensure</code> attribute on services can only take the values <code class="literal">running</code> or <code class="literal">stopped</code>). By <a id="id179" class="indexterm"/>contrast, <code class="literal">true</code> is not a bare word but a Boolean value, and it is not interchangeable with the string <code class="literal">'true'</code>. Always use the unquoted literal values <code class="literal">true</code> or <code class="literal">false</code> for Boolean values.</p></div></div></div><div class="section" title="Interpolating variables in strings"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec61"/>Interpolating variables in strings</h2></div></div></div><p>It's no good being <a id="id180" class="indexterm"/>able to store something in a variable if you can't get it out again, and one of the most common ways to use a variable's value is to <span class="strong"><strong>interpolate</strong></span> it in a string. When you do this, Puppet inserts the current value of the variable into the contents of the string, replacing the name of the variable. String interpolation looks like this (<code class="literal">string_interpolation.pp</code>):</p><div class="informalexample"><pre class="programlisting">$my_name = 'John'
notice("Hello, ${my_name}! It's great to meet you!")</pre></div><p>When you apply this manifest, the following output is printed:</p><div class="informalexample"><pre class="programlisting">Notice: Scope(Class[main]): Hello, John! It's great to meet you!</pre></div><p>To interpolate (that is, to insert the value of) a variable in a string, prefix its name with a <code class="literal">$</code> character and surround it with curly braces (<code class="literal">{}</code>). This tells Puppet to replace the variable's name with its value in the string.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip23"/>Tip</h3><p>We sneaked a new Puppet function, <code class="literal">notice()</code>, into the previous example. It has no effect on the system, but it prints out the value of its argument. This can be very useful for troubleshooting problems or finding out what the value of a variable is at a given point in your manifest.</p></div></div></div><div class="section" title="Creating arrays"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec62"/>Creating arrays</h2></div></div></div><p>A variable can also hold <a id="id181" class="indexterm"/>more than one value. An <span class="strong"><strong>Array</strong></span> is an ordered <a id="id182" class="indexterm"/>sequence of values, each of which can be of any type. The following example creates an array of <span class="strong"><strong>Integer</strong></span> values (<code class="literal">variable_array.pp</code>):</p><div class="informalexample"><pre class="programlisting">$heights = [193, 120, 181, 164, 172]

$first_height = $heights[0]</pre></div><p>You can refer to any individual element of an array by giving its index number in square brackets, where the first element is index <code class="literal">[0]</code>, the second is <code class="literal">[1]</code>, and so on. (If you find this confusing, you're not alone, but it may help to think of the index as representing an offset from the beginning of the array. Naturally, then, the offset of the first element is 0.)</p></div><div class="section" title="Declaring arrays of resources"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec63"/>Declaring arrays of resources</h2></div></div></div><p>You already know that in <a id="id183" class="indexterm"/>Puppet resource declarations, the <a id="id184" class="indexterm"/>title of the resource is usually a string, such as the path to a file or the name of a package. You might as well ask, "What happens if you supply an array of strings as the title of a resource instead of a single string? Does Puppet create multiple resources, one for each element in the array?" Let's try an experiment where we do exactly that with an array of package names and see what happens (<code class="literal">resource_array.pp</code>):</p><div class="informalexample"><pre class="programlisting">$dependencies = [
  'php7.0-cgi',
  'php7.0-cli',
  'php7.0-common',
  'php7.0-gd',
  'php7.0-json',
  'php7.0-mcrypt',
  'php7.0-mysql',
  'php7.0-soap',
]

package { $dependencies:
  ensure =&gt; installed,
}</pre></div><p>If our intuition is right, applying the previous manifest should give us a package resource for each package listed in the <code class="literal">$dependencies</code> array, and each one should be installed. Here's what happens when the manifest is applied:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo apt-get update</strong></span>
<span class="strong"><strong>sudo puppet apply /examples/resource_array.pp</strong></span>
Notice: Compiled catalog for ubuntu-xenial in environment production in 0.68 seconds
Notice: /Stage[main]/Main/Package[php7.0-cgi]/ensure: created
Notice: /Stage[main]/Main/Package[php7.0-cli]/ensure: created
Notice: /Stage[main]/Main/Package[php7.0-common]/ensure: created
Notice: /Stage[main]/Main/Package[php7.0-gd]/ensure: created
Notice: /Stage[main]/Main/Package[php7.0-json]/ensure: created
Notice: /Stage[main]/Main/Package[php7.0-mcrypt]/ensure: created
Notice: /Stage[main]/Main/Package[php7.0-mysql]/ensure: created
Notice: /Stage[main]/Main/Package[php7.0-soap]/ensure: created
Notice: Applied catalog in 56.98 seconds</pre></div><p>Giving an array of strings as the title of a resource results in Puppet creating multiple resources, all identical except for the title. You can do this not just with packages, but also with files, users, or, in fact, any type of resource. We'll see some more sophisticated ways of creating resources <a id="id185" class="indexterm"/>from data in <a class="link" href="ch06.html" title="Chapter 6. Managing data with Hiera">Chapter 6</a>, <span class="emphasis"><em>Managing data with Hiera</em></span>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip24"/>Tip</h3><p>Why did we run <code class="literal">sudo apt-get update</code> before applying the manifest? This is the Ubuntu command to update the system's local package catalog from the upstream servers. It's <a id="id186" class="indexterm"/>always a good idea to run this before installing any package to make sure you're installing the latest version. In your production Puppet code, of course, you can run this via an <code class="literal">exec</code> resource.</p></div></div></div><div class="section" title="Understanding hashes"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec64"/>Understanding hashes</h2></div></div></div><p>A <span class="strong"><strong>hash</strong></span>, also known as <a id="id187" class="indexterm"/>a dictionary in some programming languages, is like an array, but <a id="id188" class="indexterm"/>instead of just being a sequence of values, each value has a name (<code class="literal">variable_hash.pp</code>):</p><div class="informalexample"><pre class="programlisting">$heights = {
  'john'    =&gt; 193,
  'rabiah'  =&gt; 120,
  'abigail' =&gt; 181,
  'melina'  =&gt; 164,
  'sumiko'  =&gt; 172,
}

notice("John's height is ${heights['john']}cm.")</pre></div><p>The name for each value is known as the <span class="strong"><strong>key</strong></span>. In the previous example, the keys of this hash are <code class="literal">john</code>, <code class="literal">rabiah</code>, <code class="literal">abigail</code>, <code class="literal">melina</code>, and <code class="literal">sumiko</code>. To look up the value of a given key, you put the key in square brackets after the hash name: <code class="literal">$heights['john']</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip25"/>Tip</h3><p>
<span class="strong"><strong>Puppet style note</strong></span>
</p><p>Did you spot the trailing comma on the last hash key-value pair and the last element of the array in the previous example? Although the comma isn't strictly required, it's good style to add one. The reason is that it's very common to want to add another item to an array or hash, and if your last item already has a trailing comma, you won't have to remember to add one when extending the list.</p></div></div></div><div class="section" title="Setting resource attributes from a hash"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec65"/>Setting resource attributes from a hash</h2></div></div></div><p>You might have <a id="id189" class="indexterm"/>noticed that a hash looks a lot like the attributes of a resource: it's a one-to-one mapping between names and values. Wouldn't it be <a id="id190" class="indexterm"/>convenient if, when declaring resources, we could just specify a hash containing all the attributes and their values? As it happens, you can do just that (<code class="literal">hash_attributes.pp</code>):</p><div class="informalexample"><pre class="programlisting">$attributes = {
  'owner' =&gt; 'ubuntu',
  'group' =&gt; 'ubuntu',
  'mode'  =&gt; '0644',
}

file { '/tmp/test':
  ensure =&gt; present,
  *      =&gt; $attributes,
}</pre></div><p>The <code class="literal">*</code> character, cheerfully <a id="id191" class="indexterm"/>named the <span class="strong"><strong>attribute splat operator</strong></span>, tells Puppet to treat the specified hash as a list of attribute-value pairs to <a id="id192" class="indexterm"/>apply to the resource. This is exactly equivalent to specifying the same attributes directly, as in the following example:</p><div class="informalexample"><pre class="programlisting">file { '/tmp/test':
  ensure =&gt; present,
  owner  =&gt; 'vagrant',
  group  =&gt; 'vagrant',
  mode   =&gt; '0644',
}</pre></div></div></div></div>
<div class="section" title="Introducing expressions"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec23"/>Introducing expressions</h1></div></div></div><p>Variables are not the <a id="id193" class="indexterm"/>only things in Puppet that have a value. Expressions also have a value. The simplest expressions are just literal values:</p><div class="informalexample"><pre class="programlisting">42
true
'Oh no, not again.'</pre></div><p>You can combine numeric values with arithmetic operators, such as <code class="literal">+</code>, <code class="literal">-</code>, <code class="literal">*</code>, and <code class="literal">/</code>, to create <span class="strong"><strong>arithmetic </strong></span>
<a id="id194" class="indexterm"/>
<span class="strong"><strong>expressions</strong></span>, which have a numeric value, and you can use these to have Puppet do calculations (<code class="literal">expression_numeric.pp</code>):</p><div class="informalexample"><pre class="programlisting">$value = (17 * 8) + (12 / 4) - 1
notice($value)</pre></div><p>The most useful expressions, though, are which that evaluate to <code class="literal">true</code> or <code class="literal">false</code>, known as <span class="strong"><strong>Boolean expressions</strong></span>. The <a id="id195" class="indexterm"/>following is a set of examples of Boolean expressions, all of which evaluate to <code class="literal">true</code> (<code class="literal">expression_boolean.pp</code>):</p><div class="informalexample"><pre class="programlisting">notice(9 &lt; 10)
notice(11 &gt; 10)
notice(10 &gt;= 10)
notice(10 &lt;= 10)
notice('foo' == 'foo')
notice('foo' in 'foobar')
notice('foo' in ['foo', 'bar'])
notice('foo' in { 'foo' =&gt; 'bar' })
notice('foo' =~ /oo/)
notice('foo' =~ String)
notice(1 != 2)</pre></div><div class="section" title="Meeting Puppet's comparison operators"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec66"/>Meeting Puppet's comparison operators</h2></div></div></div><p>All the operators in the <a id="id196" class="indexterm"/>Boolean expressions shown in the previous example are known as <span class="strong"><strong>comparison operators</strong></span>, because they compare two <a id="id197" class="indexterm"/>values. The result is either <code class="literal">true</code> or <code class="literal">false</code>. These are the comparison operators Puppet provides:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">==</code> and <code class="literal">!=</code> (equal, not equal)</li><li class="listitem" style="list-style-type: disc"><code class="literal">&gt;</code>, <code class="literal">&gt;=</code>, <code class="literal">&lt;</code>, and <code class="literal">&lt;=</code> (greater than, greater than or equal to, less than, less than or equal to)</li><li class="listitem" style="list-style-type: disc"><code class="literal">A in B</code> (<code class="literal">A</code> is a substring of <code class="literal">B</code>, <code class="literal">A</code> is an element of the array <code class="literal">B</code>, or <code class="literal">A</code> is a key of the hash <code class="literal">B</code>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">A =~ B</code> (<code class="literal">A</code> is matched by the regular expression <code class="literal">B</code>, or <code class="literal">A</code> is a value of data type <code class="literal">B</code>. For example, the expression <code class="literal">'hello' =~ String</code> is <code class="literal">true</code>, because the value <code class="literal">'hello'</code> is of type String.)</li></ul></div></div><div class="section" title="Introducing regular expressions"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec67"/>Introducing regular expressions</h2></div></div></div><p>The <code class="literal">=~</code> operator <a id="id198" class="indexterm"/>tries to match a given value against a <span class="strong"><strong>regular expression</strong></span>. A regular expression (<span class="emphasis"><em>regular</em></span> in the sense of constituting a pattern or a rule) is a special <a id="id199" class="indexterm"/>kind of expression which specifies a set of strings. For example, the regular expression <code class="literal">/a+/</code> describes the set of all strings that contain one or more consecutive <code class="literal">a</code>s: <code class="literal">a</code>, <code class="literal">aa</code>, <code class="literal">aaa</code>, and so on, as well as all strings which contain such a sequence among other characters. The slash characters <code class="literal">//</code> delimit a regular expression in Puppet.</p><p>When we say a regular expression <span class="strong"><strong>matches</strong></span> a value, we mean the value is one of the set of strings specified by the regular expression. The regular expression <code class="literal">/a+/</code> would match the string <code class="literal">aaa</code> or the string <code class="literal">Aaaaargh!</code>, for example.</p><p>The following example shows some regular expressions that match the string <code class="literal">foo</code> (<code class="literal">regex.pp</code>):</p><div class="informalexample"><pre class="programlisting">$candidate = 'foo'
notice($candidate =~ /foo/) # literal
notice($candidate =~ /f/)   # substring
notice($candidate =~ /f.*/) # f followed by zero or more characters
notice($candidate =~ /f.o/) # f, any character, o
notice($candidate =~ /fo+/) # f followed by one or more 'o's
notice($candidate =~ /[fgh]oo/) # f, g, or h followed by 'oo'</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip26"/>Tip</h3><p>Regular expressions <a id="id200" class="indexterm"/>are more-or-less a standard language for <a id="id201" class="indexterm"/>expressing string patterns. It's a complicated and powerful language, which really deserves a book of its own (and there are several), but suffice it to say for now that Puppet's regular expression syntax is the same as that used in the Ruby language. You can read more about it in the Ruby documentation at:</p><p>
<a class="ulink" href="http://ruby-doc.org/core/Regexp.html">http://ruby-doc.org/core/Regexp.html</a>
</p></div></div></div><div class="section" title="Using conditional expressions"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec68"/>Using conditional expressions</h2></div></div></div><p>Boolean <a id="id202" class="indexterm"/>expressions, like those in the previous example, are useful because we can use them to make choices in the Puppet manifest. We can <a id="id203" class="indexterm"/>apply certain resources only if a given condition is met, or we can assign an attribute one value or another, depending on whether some expression is true. An expression used in this way is called a <span class="strong"><strong>conditional expression</strong></span>.</p></div><div class="section" title="Making decisions with if statements"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec69"/>Making decisions with if statements</h2></div></div></div><p>The most <a id="id204" class="indexterm"/>common use of a conditional expression is in an <code class="literal">if</code> statement. The following example shows how to use <code class="literal">if</code> to decide whether to apply a resource (<code class="literal">if.pp</code>):</p><div class="informalexample"><pre class="programlisting">$install_perl = true
if $install_perl {
  package { 'perl':
    ensure =&gt; installed,
  }
} else {
  package { 'perl':
    ensure =&gt; absent,
  }
}</pre></div><p>You can see that the value of the Boolean variable <code class="literal">$install_perl</code> governs whether or not the <code class="literal">perl</code> package is installed. If <code class="literal">$install_perl</code> is <code class="literal">true</code>, Puppet will apply the following resource:</p><div class="informalexample"><pre class="programlisting">  package { 'perl':
    ensure =&gt; installed,
  }</pre></div><p>If, on the other hand, <code class="literal">$install_perl</code> is <code class="literal">false</code>, the resource applied will be:</p><div class="informalexample"><pre class="programlisting">  package { 'perl':
    ensure =&gt; absent,
  }</pre></div><p>You can use <code class="literal">if</code> <a id="id205" class="indexterm"/>statements to control the application of any number of resources or, indeed, any part of your Puppet manifest. You can leave out the <code class="literal">else</code> clause if you like; in that case, when the value of the conditional expression is <code class="literal">false</code>, Puppet will do nothing.</p></div><div class="section" title="Choosing options with case statements"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec70"/>Choosing options with case statements</h2></div></div></div><p>The <code class="literal">if</code> statement <a id="id206" class="indexterm"/>allows you to take a yes/no decision <a id="id207" class="indexterm"/>based on the value of a Boolean expression. But if you need to make a choice among more than two options, you can use a <code class="literal">case</code> statement instead (<code class="literal">case.pp</code>):</p><div class="informalexample"><pre class="programlisting">$webserver = 'nginx'
case $webserver {
  'nginx': {
    notice("Looks like you're using Nginx! Good choice!")
  }
  'apache': {
    notice("Ah, you're an Apache fan, eh?")
  }
  'IIS': {
    notice('Well, somebody has to.')
  }
  default: {
    notice("I'm not sure which webserver you're using!")
  }
}</pre></div><p>In a <code class="literal">case</code> statement, Puppet compares the value of the expression to each of the cases listed in order. If it finds a match, the corresponding resources are applied. The special case called <code class="literal">default</code> always <a id="id208" class="indexterm"/>matches, and you can use it to make sure that Puppet will do the right thing even if none of the other cases match.</p></div></div>
<div class="section" title="Finding out facts"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec24"/>Finding out facts</h1></div></div></div><p>It's very common for <a id="id209" class="indexterm"/>Puppet manifests to need to know something about the system they're running on, for example, its hostname, IP address, or operating system version. Puppet's built-in mechanism for getting system information is called <span class="strong"><strong>Facter</strong></span>, and each piece of information provided by Facter is known as a <span class="strong"><strong>fact</strong></span>.</p><div class="section" title="Using the facts hash"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec71"/>Using the facts hash</h2></div></div></div><p>You can access <a id="id210" class="indexterm"/>Facter facts in your manifest using the <span class="strong"><strong>facts hash</strong></span>. This is a Puppet <a id="id211" class="indexterm"/>variable called <code class="literal">$facts</code> which is available everywhere in the manifest, and to get a particular fact, you supply the name of the fact you want as the key (<code class="literal">facts_hash.pp</code>):</p><div class="informalexample"><pre class="programlisting">notice($facts['kernel'])</pre></div><p>On the Vagrant box, or any Linux system, this will return the value <code class="literal">Linux</code>.</p><p>In older versions of Puppet, each fact was a distinct global variable, like this:</p><div class="informalexample"><pre class="programlisting">notice($::kernel)</pre></div><p>You will still see this style of fact reference in some Puppet code, though it is now deprecated and will eventually stop working, so you should always use the $facts hash instead.</p></div><div class="section" title="Running the facter command"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec72"/>Running the facter command</h2></div></div></div><p>You can <a id="id212" class="indexterm"/>also use the <code class="literal">facter</code> command to see the value of particular facts, or <a id="id213" class="indexterm"/>just see what facts are available. For example, running <code class="literal">facter os</code> on the command line will show you the hash of available OS-related facts:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>facter os</strong></span>
{
  architecture =&gt; "amd64",
  distro =&gt; {
    codename =&gt; "xenial",
    description =&gt; "Ubuntu 16.04 LTS",
    id =&gt; "Ubuntu",
    release =&gt; {
      full =&gt; "16.04",
      major =&gt; "16.04"
    }
  },
  family =&gt; "Debian",
  hardware =&gt; "x86_64",
  name =&gt; "Ubuntu",
  release =&gt; {
    full =&gt; "16.04",
    major =&gt; "16.04"
  },
  selinux =&gt; {
    enabled =&gt; false
  }
}</pre></div><p>You can also use the <code class="literal">puppet facts</code> command to see what facts will be available to Puppet manifests. This will <a id="id214" class="indexterm"/>also include any custom facts defined by <a id="id215" class="indexterm"/>third-party Puppet modules (see <a class="link" href="ch07.html" title="Chapter 7. Mastering modules">Chapter 7</a>, <span class="emphasis"><em>Mastering modules</em></span>, for more information about this).</p></div><div class="section" title="Accessing hashes of facts"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec73"/>Accessing hashes of facts</h2></div></div></div><p>As in the <a id="id216" class="indexterm"/>previous example, many facts actually return a hash of <a id="id217" class="indexterm"/>values, rather than a single value. The value of the <code class="literal">$facts['os']</code> fact is a hash with the keys <code class="literal">architecture</code>, <code class="literal">distro</code>, <code class="literal">family</code>, <code class="literal">hardware</code>, <code class="literal">name</code>, <code class="literal">release</code>, and <code class="literal">selinux</code>. Some of those are also hashes; it's hashes all the way down!</p><p>As you know, to access a particular value in a hash, you specify the key name in square brackets. To access a value inside a hash, you add another key name in square brackets after the first, as in the following example (<code class="literal">facts_architecture.pp</code>):</p><div class="informalexample"><pre class="programlisting">notice($facts['os']['architecture'])</pre></div><p>You can keep on appending more keys to get more and more specific information (<code class="literal">facts_distro_codename.pp</code>):</p><div class="informalexample"><pre class="programlisting">notice($facts['os']['distro']['codename'])</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>
<span class="strong"><strong>Key fact</strong></span>
</p><p>The operating system major release is a very handy fact and one you'll probably use often:</p><div class="informalexample"><pre class="programlisting">$facts['os']['release']['major']</pre></div></div></div></div><div class="section" title="Referencing facts in expressions"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec74"/>Referencing facts in expressions</h2></div></div></div><p>Just as with <a id="id218" class="indexterm"/>ordinary variables or values, you can use facts in <a id="id219" class="indexterm"/>expressions, including conditional expressions (<code class="literal">fact_if.pp</code>):</p><div class="informalexample"><pre class="programlisting">if $facts['os']['selinux']['enabled'] {
  notice('SELinux is enabled')
} else {
  notice('SELinux is disabled')
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip27"/>Tip</h3><p>Although conditional expressions based on facts can be useful, an even better way of making decisions based on facts in your manifests is to use Hiera, which we'll cover in the next chapter. For example, if you find yourself writing an <code class="literal">if</code> or <code class="literal">case</code> statement which chooses different resources depending on the operating system version, consider using a Hiera query instead.</p></div></div></div><div class="section" title="Using memory facts"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec75"/>Using memory facts</h2></div></div></div><p>Another useful set of <a id="id220" class="indexterm"/>facts is that relating to the <span class="strong"><strong>system memory</strong></span>. You can find out the total physical memory available, and the amount of memory currently used, as well as the same figures for swap memory.</p><p>One common use for <a id="id221" class="indexterm"/>this is to configure applications dynamically based on the amount of system memory. For example, the MySQL parameter <code class="literal">innodb_buffer_pool_size</code> specifies the amount of memory allocated to database query cache and indexes, and it should generally be set as high as possible ("<span class="emphasis"><em>as large a value as practical, leaving enough memory for other processes on the node to run without excessive paging</em></span>", according to the documentation). So you might decide to set this to three-quarters of total memory (for example), using a fact and an arithmetic expression, as in the following snippet (<code class="literal">fact_memory.pp</code>):</p><div class="informalexample"><pre class="programlisting">$buffer_pool = $facts['memory']['system']['total_bytes'] * 3/4
notice("innodb_buffer_pool_size=${buffer_pool}")</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>
<span class="strong"><strong>Key fact</strong></span>
</p><p>The total system memory fact will help you calculate configuration parameters which vary as a fraction of memory:</p><div class="informalexample"><pre class="programlisting">$facts['memory']['system']['total_bytes']</pre></div></div></div></div><div class="section" title="Discovering networking facts"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec76"/>Discovering networking facts</h2></div></div></div><p>Most applications use <a id="id222" class="indexterm"/>the network, so you'll find Facter's network-related <a id="id223" class="indexterm"/>facts very useful for anything to do with network configuration. The most commonly used facts are the system hostname, fully <a id="id224" class="indexterm"/>qualified domain name (FQDN), and IP address (<code class="literal">fact_networking.pp</code>):</p><div class="informalexample"><pre class="programlisting">notice("My hostname is ${facts['hostname']}")
notice("My FQDN is ${facts['fqdn']}")
notice("My IP is ${facts['networking']['ip']}")</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>
<span class="strong"><strong>Key fact</strong></span>
</p><p>The system hostname is something you'll need to refer to often in your manifests:</p><div class="informalexample"><pre class="programlisting">$facts['hostname']</pre></div></div></div></div><div class="section" title="Providing external facts"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec77"/>Providing external facts</h2></div></div></div><p>While the built-in facts <a id="id225" class="indexterm"/>available to Puppet provide a lot of important information, you can make the <code class="literal">$facts</code> hash even more useful by extending it with <a id="id226" class="indexterm"/>your own facts, known as <span class="strong"><strong>external facts</strong></span>. For example, if nodes are located in different cloud providers, each of which requires a slightly different networking setup, you could create a custom fact called <code class="literal">cloud</code> to document this. You can then use this fact in manifests to make decisions.</p><p>Puppet looks for external facts in the <code class="literal">/opt/puppetlabs/facter/facts.d/</code> directory. Try creating a file in that directory called <code class="literal">facts.txt</code> with the following contents (<code class="literal">fact_external.txt</code>):</p><div class="informalexample"><pre class="programlisting">cloud=aws</pre></div><p>A quick way to do this is to run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo cp /examples/fact_external.txt /opt/puppetlabs/facter/facts.d</strong></span>
</pre></div><p>The <code class="literal">cloud</code> fact is now available in your manifests. You can check that the fact is working by running the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo facter cloud</strong></span>
aws</pre></div><p>To use the fact in your manifest, query the <code class="literal">$facts</code> hash just as you would for a built-in fact (<code class="literal">fact_cloud.pp</code>):</p><div class="informalexample"><pre class="programlisting">case $facts['cloud'] {
  'aws': {
    notice('This is an AWS cloud node ')
  }
  'gcp': {
    notice('This is a Google cloud node')
  }
  default: {
    notice("I'm not sure which cloud I'm in!")
  }
}</pre></div><p>You can put as many facts in a single text file as you like, or you can have each fact in a separate file: it doesn't make any difference. Puppet will read all the files in the <code class="literal">facts.d/</code> directory and extract all the <code class="literal">key=value</code> pairs from each one.</p><p>Text files work well for <a id="id227" class="indexterm"/>simple facts (those that return a single value). If <a id="id228" class="indexterm"/>your external facts need to return structured data (arrays or hashes, for example), you can use a YAML or JSON file instead to do this. We'll be learning more about YAML in the next chapter, but for now, if you need to build structured external facts, consult the Puppet documentation for details.</p><p>It's common to set up external facts like this at build time, perhaps as part of an automated bootstrap script (see <a class="link" href="ch12.html" title="Chapter 12. Putting it all together">Chapter 12</a>, <span class="emphasis"><em>Putting it all together</em></span>, for more about the bootstrap process).</p></div><div class="section" title="Creating executable facts"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec78"/>Creating executable facts</h2></div></div></div><p>External facts are not <a id="id229" class="indexterm"/>limited to static text files. They can also be the <a id="id230" class="indexterm"/>output of scripts or programs. For example, you could write a script that calls a web service to get some data, and the result would be the value of the fact. These are known as <span class="strong"><strong>executable facts</strong></span>.</p><p>Executable facts live in the same directory as other external facts (<code class="literal">/opt/puppetlabs/facter/facts.d/)</code>, but they are distinguished by having the execute bit set on their files (recall that files on Unix-like systems each have a set of bits indicating their read, write, and execute permissions) and they also can't be named with <code class="literal">.txt</code>, <code class="literal">.yaml</code>, or <code class="literal">.json</code> extensions. Let's build an executable fact which simply returns the current date, as an example:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Run the following command to copy the executable fact example into the external fact directory:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo cp /examples/date.sh /opt/puppetlabs/facter/facts.d</strong></span>
</pre></div></li><li class="listitem">Set the execute bit on the file with the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo chmod a+x /opt/puppetlabs/facter/facts.d/date.sh</strong></span>
</pre></div></li><li class="listitem">Now test the fact:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo facter date</strong></span>
2017-04-12</pre></div></li></ol></div><p>Here is the script which generates this output (<code class="literal">date.sh</code>):</p><div class="informalexample"><pre class="programlisting">#!/bin/bash
echo "date=`date +%F`"</pre></div><p>Note that the script has to output <code class="literal">date=</code> before the actual date value. This is because Facter expects executable facts to output a list of <code class="literal">key=value</code> pairs (just one such pair, in this case). The <code class="literal">key</code> is the <a id="id231" class="indexterm"/>name of the fact (<code class="literal">date</code>), and the <code class="literal">value</code> is whatever is returned by <code class="literal">`date +%F`</code> (the current date in ISO 8601 format). You should use ISO 8601 format (<code class="literal">YYYY-MM-DD</code>) whenever you need to represent dates, by the way, because it's not only the international standard date format, but it is also unambiguous and sorts alphabetically.</p><p>As you can see, executable <a id="id232" class="indexterm"/>facts are quite powerful because they can return any information which can be generated by a program (the program could make network requests or database queries, for example). However, you should use executable facts with care, as Puppet has to evaluate <span class="emphasis"><em>all</em></span> external facts on the node every time it runs, which means running every script in <code class="literal">/opt/puppetlabs/facter/facts.d</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip28"/>Tip</h3><p>If you don't need the information from an executable fact to be regenerated every time Puppet runs, consider running the script from a cron job at longer intervals and having it write output to a static text file in the facts directory instead.</p></div></div></div></div>
<div class="section" title="Iterating over arrays"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec25"/>Iterating over arrays</h1></div></div></div><p>Iteration (doing something <a id="id233" class="indexterm"/>repeatedly) is a useful technique in your Puppet manifests to avoid lots of duplicated code. For example, consider the following manifest, which creates several files with identical properties (<code class="literal">iteration_simple.pp</code>):</p><div class="informalexample"><pre class="programlisting">file { '/usr/local/bin/task1':
  content =&gt; "echo I am task1\n",
  mode    =&gt; '0755',
}

file { '/usr/local/bin/task2':
  content =&gt; "echo I am task2\n",
  mode    =&gt; '0755',
}

file { '/usr/local/bin/task3':
  content =&gt; "echo I am task3\n",
  mode    =&gt; '0755',
}</pre></div><p>You can see that each of these resources is identical, except for the task number: <code class="literal">task1</code>, <code class="literal">task2</code>, and <code class="literal">task3</code>. Clearly, this is a lot of typing and should you later decide to change the properties of these scripts (for example, moving them to a different directory), you'll have to find and change each <a id="id234" class="indexterm"/>one in the manifest. For three resources, this is already annoying, but for thirty or a hundred resources it's completely impractical. We need a better solution.</p><div class="section" title="Using the each function"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec79"/>Using the each function</h2></div></div></div><p>Puppet provides the <code class="literal">each</code> <a id="id235" class="indexterm"/>function to help with just this kind of situation. The <a id="id236" class="indexterm"/>
<code class="literal">each</code> function takes an array and applies a block of Puppet code to each element of the array. Here's the same example we saw previously, only this time using an array and the <code class="literal">each</code> function (<code class="literal">iteration_each.pp</code>):</p><div class="informalexample"><pre class="programlisting">$tasks = ['task1', 'task2', 'task3']
$tasks.each | $task | {
  file { "/usr/local/bin/${task}":
    content =&gt; "echo I am ${task}\n",
    mode    =&gt; '0755',
  }
}</pre></div><p>Now this looks more like a computer program! We have a <span class="strong"><strong>loop</strong></span>, created by the <code class="literal">each</code> function. The loop goes round and round, creating a new <code class="literal">file</code> resource for each element of the <code class="literal">$tasks</code> array. Let's look at a schematic version of an <code class="literal">each</code> loop:</p><div class="informalexample"><pre class="programlisting">ARRAY.each | ELEMENT | {
  BLOCK
}</pre></div><p>The following list describes the components of the <code class="literal">each</code> loop:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ARRAY</code> can be any Puppet array variable or literal value (it could even be a call to Hiera that returns an array). In the previous example, we used <code class="literal">$tasks</code> as the array.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ELEMENT</code> is the name of a variable which will hold, each time round the loop, the value of the current element in the array. In the previous example, we decided to name this variable <code class="literal">$task</code>, although we could have called it anything.</li><li class="listitem" style="list-style-type: disc"><code class="literal">BLOCK</code> is a section of <a id="id237" class="indexterm"/>Puppet code. This could consist of a <a id="id238" class="indexterm"/>function call, resource declarations, include statements, conditional statements: anything which you can put in a Puppet manifest, you can also put inside a loop block. In the previous example, the only thing in the block was the <code class="literal">file</code> resource, which creates <code class="literal">/usr/local/bin/$task</code>.</li></ul></div></div><div class="section" title="Iterating over hashes"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec80"/>Iterating over hashes</h2></div></div></div><p>The <code class="literal">each</code> function <a id="id239" class="indexterm"/>works not only on arrays, but also on hashes. When iterating over a hash, the loop takes two <code class="literal">ELEMENT</code> parameters: the first is the hash key, and the second is the value. The following example shows how to use <code class="literal">each</code> to iterate over a hash resulting from a Facter query (<code class="literal">iteration_hash.pp</code>):</p><div class="informalexample"><pre class="programlisting">$nics = $facts['networking']['interfaces']
$nics.each | String $interface, Hash $attributes | {
  notice("Interface ${interface} has IP ${attributes['ip']}")
}</pre></div><p>The list of interfaces returned by <code class="literal">$facts['networking']['interfaces']</code> is a hash, where the key is the name of the interface (for example, <code class="literal">lo0</code> for the local loopback interfaces) and the value is a hash of the interface's attributes (including the IP address, netmask, and so on). Applying the manifest in the previous example gives this result (on my Vagrant box):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo puppet apply /examples/iteration_hash.pp</strong></span>
Notice: Scope(Class[main]): Interface enp0s3 has IP 10.0.2.15
Notice: Scope(Class[main]): Interface lo has IP 127.0.0.1</pre></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec26"/>Summary</h1></div></div></div><p>In this chapter, we've gained an understanding of how Puppet's variable and data type system works, including the basic data types: Strings, Numbers, Booleans, Arrays, and Hashes. We've seen how to interpolate variables in strings and how to quickly create sets of similar resources using an array of resource names. We've learned how to set common attributes for resources using a hash of attribute-value pairs and the attribute splat operator.</p><p>We've seen how to use variables and values in expressions, including arithmetic expressions, and explored the range of Puppet's comparison operators to generate Boolean expressions. We've used conditional expressions to build <code class="literal">if…else</code> and <code class="literal">case</code> statements and had a brief introduction to regular expressions.</p><p>We've learned how Puppet's Facter subsystem supplies information about the node via the facts hash and how to use facts in our own manifests and in expressions. We've pointed out some key facts, including the operating system release, the system memory capacity, and the system hostname. We've seen how to create custom external facts, such as a <code class="literal">cloud</code> fact, and how to dynamically generate fact information using executable facts.</p><p>Finally, we've learned about iteration in Puppet using the <code class="literal">each</code> function and how to create multiple resources based on data from arrays or hashes, including Facter queries.</p><p>In the next chapter, we'll stay with the topic of data and explore Puppet's powerful Hiera database. We'll see what problems Hiera solves, look at how to set up and query Hiera, how to write data sources, how to create Puppet resources directly from Hiera data, and also how to use Hiera encryption to manage secret data.</p></div></body></html>