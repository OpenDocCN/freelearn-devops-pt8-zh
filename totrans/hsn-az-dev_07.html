<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Serverless and Azure Functions</h1>
                </header>
            
            <article>
                
<p>Azure Functions are the main product of <span>serverless architecture</span> in Azure. They allow for executing small pieces of code within fully managed runtime, so we don't have to care about performance and scalability. They are open source, open for extensions, and built on top of App Services, so they provide a similar experience to WebJobs. Microsoft pays much attention to developing new features for Azure Functions and, with great support from the community, it's one of the best tools for quickly developing both simple and serious applications.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Understanding Azure Functions</li>
<li>Configuring local environment for developing Azure Functions</li>
<li>Creating a function</li>
<li>Azure Functions features</li>
<li>Workflow in Azure Functions—Durable Functions</li>
<li>Integrating functions with other services</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To start using Azure Functions and to perform the exercises in this chapter, you will need the following:</p>
<ul>
<li>Visual Studio 2017 with Azure workload installed</li>
<li>Azure Functions and the WebJobs tools extension for Visual Studio</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding Azure Functions</h1>
                </header>
            
            <article>
                
<p>Azure Functions are a part of so-called serverless components that are available in the Azure cloud. Before you start learning about this particular service, you will have to understand what serverless really means. While, initially, you may think that this concept implies no servers at all, you will quickly <span>re-evaluate</span> your way of thinking (as, we are still quite far away from not using any kind of machine for our applications and workloads).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Being "serverless"</h1>
                </header>
            
            <article>
                
<p>You can easily find many different articles describing the term serverless—to be honest, I would like to avoid promoting a one and only correct definition, as this topic is currently so fuzzy, it is hard to find the best description. My goal, however, is to give you some hints and best practices, which will let you understand it in a way that makes the most sense to you.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Responsibilities of cloud vendors</h1>
                </header>
            
            <article>
                
<p>We will start with the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/b73380e1-ea4f-4fd8-a1e2-1d08c371de11.png" style="width:35.58em;height:13.83em;" width="832" height="323"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In the preceding screenshot, you can see the comparison of two of the most popular cloud models with <span>serverless architecture </span>regarding vendor responsibility. I compared them using five different fields:</p>
<ul>
<li><strong>Data center</strong>: DC infrastructure, security, maintenance, and staff</li>
<li><strong>Network security</strong>: Implementing correct and secure solutions regarding the network (firewalls, pen-tests, and anti-DDoS solutions)</li>
<li><strong>Operating systems</strong>: Updates, maintenance, and configuration</li>
<li><strong>Dev tools</strong>: Developing and delivering multiple features for programmers and administrators (such as extensions to IDE, management portal, and appropriate tools for managing services) </li>
<li><strong>Application host</strong>: The specific runtime that hosts and runs our application (such as App Service Plan)</li>
</ul>
<p>As you can see, the only difference (at least when using the described characteristics) is the application host. When it comes to serverless components, the only thing that you deliver to your solution is your code (or some kind of configuration, which is needed to set up a service)—the rest is delivered and handled by your cloud vendor. Of course, this is not the only way to define this idea.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Pricing model</h1>
                </header>
            
            <article>
                
<p>One of the most popular features of serverless services and architectures is the possibility to pay for the number of executions and used computing power. This pricing model is the exact opposite of the most common prepaid model, where you pay a fixed price depending on a set of configured fields such as the number of used VMs or the size of a cluster. Here, you can find a table describing pricing for Azure Functions:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<thead>
<tr>
<th>
<p>Meter</p>
</th>
<th>
<p>Price</p>
</th>
<th>
<p>Free grant (per month)</p>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<p>Execution time</p>
</td>
<td>
<p><span class="price-data">€0.000014</span>/GB/s</p>
</td>
<td>
<p>400.000 GB/s</p>
</td>
</tr>
<tr>
<td>
<p>Total executions</p>
</td>
<td>
<p><span class="price-data">€0.169</span><span> </span>per million executions</p>
</td>
<td>
<p>1 million executions</p>
</td>
</tr>
</tbody>
</table>
<p>Now, you may wonder how can you understand this so that you can calculate the estimated cost of your solution. There are two things you have to understand to make your calculation correct:</p>
<ul>
<li><strong>Execution</strong>: This is a single function execution, which lasts <em>N</em> seconds</li>
<li><strong>Consumption</strong>: This defines how many resources (CPU and memory) your function consumes within a fixed time</li>
</ul>
<p>Now, if you compare the preceding terms with the table, you will see that they differ slightly. This is because Azure Functions, pricing does not <span>directly </span>define the price for consumption but, rather, uses execution time. </p>
<div class="packt_infobox">You have probably noticed the f<span>ree grant</span><strong> </strong>column in the pricing table. Remember that it applies only to the consumption model—it will not work for the prepaid one. </div>
<p>Now, let's assume that you have estimated the following:</p>
<ul>
<li>You will need 10 million executions of your function per month</li>
<li>Each execution lasts ~80 ms</li>
<li>You are using 145 MB of memory per execution</li>
</ul>
<p>To calculate the whole price for using Azure Functions, you can use the following formula:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="Images/ae3ecd9e-6a48-47ed-8717-1bd3a0b92e39.png" style="width:23.83em;height:1.67em;" width="3430" height="240"/></p>
<p>In the previous formula, the following is applicable:</p>
<ul>
<li><strong>Rc</strong>: Resource consumption defined as a product of memory consumed and execution time (in GB/s)</li>
<li><strong>Te:</strong> Total executions number (in millions)</li>
</ul>
<p>Now, if you enter the correct values and calculate the formula, you will get the following result:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="Images/f1a9cc0a-d1c1-43f9-a24b-4c7d10ed2fed.png" style="width:26.67em;height:2.50em;" width="4380" height="410"/></p>
<p class="mce-root"/>
<p>This will give you the following cost: 5.19 EUR. However, you may find the previous formula a bit confusing—why did I use <em>256 </em>(instead of 128)<strong> </strong>as the amount of memory consumed and<em> 1 Ms</em><strong> </strong>(instead of 800 Ks)<strong> </strong>as the execution time? Well, there is one important thing to remember when using the consumption plan: the minimum execution time is 100 ms and when it comes to resources consumption, it is always <strong>rounded up </strong>to the nearest 128 MBs.</p>
<div class="packt_tip">In fact, when it comes to function execution, you cannot go under 100 ms and 128 MBs of used memory. This is very important when calculating possible cost optimization as, often, you should not aim at optimizing functions and rather focus on overall algorithm changes (such as batching or better serialization methods). </div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Azure Functions concepts</h1>
                </header>
            
            <article>
                
<p>Now that you are a bit familiar with what <span>serverless architecture </span>is, we can start learning something else about Azure Functions. To proceed, you will need to understand the difference between the following topics:</p>
<ul>
<li>Function apps</li>
<li>Functions</li>
<li>Triggers and bindings</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Function app</h1>
                </header>
            
            <article>
                
<p>The logical container for multiple functions is called a function app. A function app can host one or more functions, which will share configuration, settings, and runtime version. It is possible to run functions using multiple languages using the same function app.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Here, you can see what a single function app looks like, with several individual functions hosted within it:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/8abe2854-700b-4e08-b6dd-a0db7530a46c.png" style="width:15.25em;height:49.58em;" width="247" height="803"/></p>
<p>If you have the requirement to use both pricing plans (consumption and App Service), you will have to have two different functions apps, as a single one does not support such a scenario.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Functions</h1>
                </header>
            
            <article>
                
<p>A single executable part of Azure Functions that hosts your code is called a <strong>function</strong>. Each function can execute code written in different supported languages (one can use C#, while another can leverage Python features). The currently supported languages are as follows:</p>
<ul>
<li>C#</li>
<li>JavaScript</li>
<li>F#</li>
</ul>
<p>In the second version of runtime (v2), Java should also be available to use.</p>
<div class="packt_infobox">Please note that, at the time of writing this book, the v1 version is the only one that supports production workloads.</div>
<p>There is also the possibility of using a set of other languages (such as Powershell, PHP, or Batch), but they are in experimental mode and are not to be used in production. Here, you can find an example function with some boilerplate code:</p>
<pre>[FunctionName("QueueTrigger")]<br/>public static void Run(<br/>  [QueueTrigger("myqueue-items")] string myQueueItem, <br/>  TraceWriter log)<br/>{<br/>  log.Info($"C# function processed: {myQueueItem}");<br/>}</pre>
<div class="packt_infobox">Note that the previous code was generated using Visual Studio—the boilerplate generated in Azure Portal looks a little bit different.</div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>As you can see, a function consists of the following components:</p>
<ul>
<li><strong>Function decorator</strong>:<kbd> [FunctionName]</kbd>, which allows the runtime to find a function, and delivers the required metadata</li>
<li><strong>Trigger</strong>: <kbd>[QueueTrigger]</kbd>—each function requires a trigger to be configured correctly</li>
<li><strong>Additional bindings</strong>: <kbd>TraceWriter</kbd>, which will be injected during runtime</li>
<li><strong>Function code: </strong>The actual logic that will be executed each time the function is called</li>
</ul>
<p>Of course, some parts of a function will differ depending on the features you use—in the previous example, we used a trigger for Azure Storage Queue, but there are also other possibilities (such as HTTP request, Azure Service Bus, or Azure CosmosDB); additionally, you can use other bindings and provide custom code each time. We will cover all of these topics in the following sections of this chapter.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Triggers and bindings</h1>
                </header>
            
            <article>
                
<p>The power of Azure Functions comes when you consider all possible integrations, which can be used seamlessly and without much additional effort. In fact, the list of available triggers and bindings are quite impressive:</p>
<ul>
<li>Azure Storage</li>
<li>Azure CosmosDB</li>
<li>Azure Event Grid</li>
<li>Azure Event Hub</li>
<li>HTTP</li>
<li>Microsoft Graph</li>
<li>Azure Mobile Apps</li>
<li>Azure Notification Hub</li>
<li>Azure Service Bus</li>
<li>Timer</li>
<li>Twilio</li>
<li>SendGrid</li>
</ul>
<p>Additionally, you have access to some experimental triggers and bindings, which may not be officially supported, but can be used in your application if you decide to do so (such as external files and external tables).</p>
<div class="packt_infobox">Remember that some experimental triggers and bindings will never reach GA status as there are specific recommendations (such as using Azure Logic Apps), which should be followed in most cases.</div>
<p>Of course, it is possible to introduce custom triggers and bindings since Azure Functions provides a full SDK, which can be used to extend runtime. However, this is an advanced topic that will be not covered in this book—you will find a reference to the appropriate tutorials in the <em>Further reading</em><strong> </strong>section. Here, you can find an example of a custom binding, which I used for authorizing a user:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/51163900-ab4e-4954-8200-e54f00e0c037.png" style="width:52.75em;height:17.83em;" width="713" height="241"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Pricing models</h1>
                </header>
            
            <article>
                
<p>In Azure Functions, there are two pricing models available:</p>
<ul>
<li><strong>Consumption model</strong>: This was<strong> </strong>described in the previous sections, where you pay for the number of executions of your functions and the computing power used</li>
<li><strong>App Service Plan </strong><strong>model</strong>: This is where you select an App Service Plan version, which has a fixed price, no matter how many times you execute your functions</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Scaling</h1>
                </header>
            
            <article>
                
<p>One of the most important features of serverless components and architectures is their ability to scale out as they are loaded <span>more and more</span>. While in traditional PaaS services, you often have to worry about available instances or scaling configuration. Serverless allows for the seamless handling of incoming requests, even if a service is hit by an unexpectedly high traffic. In this section, we will talk about the scaling capabilities of Azure Functions, with a focus on differences between consumption and App Service models.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Scaling in the consumption model</h1>
                </header>
            
            <article>
                
<p>When you use the consumption model in Azure Functions, you are not defining any available instances for your service and are unable to configure auto-scaling settings. In fact, in this model, you are completely unaware of the number of machines running your workloads (however, if you integrate your functions with Azure Application Insights, you will be able to see how many instances have been created by taking a look at the <strong>Live Stream</strong> blade).</p>
<div class="packt_infobox">In the consumption model, you have a fixed limit when it comes to the memory available for each execution of your function—this is 1.536 MBs. Whether your functions will scale or not depends on the current utilization of both memory and CPU.</div>
<p>The advantage of this plan is the ability to easily scale to hundreds of functions while running the same code concurrently. Of course, it all depends on the actual trigger used in a function—while, with the HTTP trigger, you have to scale out to be able to handle multiple requests at once, using the event hub trigger, for instance, will automatically increase the number of working instances for each partition used. On the other hand, you cannot always rely on the consumption plan to be sure that you will not expect delays in responses or temporary unavailability—immediate scaling out is not guaranteed by any means, so this particular pricing plan is not always the best solution when your application has to face quick peaks of traffic.</p>
<div class="packt_infobox">Remember that the current maximum for scaling a function app is limited to 200. Also worth noting is the fact that the runtime will allocate new instances no often than every 10 seconds.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Scaling in the App Service model</h1>
                </header>
            
            <article>
                
<p>Using the App Service model has its benefits, especially when it comes to covering some cases of scaling that are not covered in the consumption plan. As mentioned in the previous section, if you have to be sure that you are able to handle the incoming load, it is often a better idea to use this particular model, as it ensures that some fixed resources will be available for your function app. Additionally, you are 100% sure that the provided hardware is provisioned for your application—this is not always the case in the consumption model since you have no guarantees when it comes to delivered machines and their characteristics. What's more, you are sure that your runtime is always running—since, in the consumption model, when a function is not used, its resources will be de-allocated, you can face quite common issues such as cold starts.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Configuring the local environment for developing Azure Functions</h1>
                </header>
            
            <article>
                
<p>To get started with Azure Functions, we will need an environment that will allow us to test our functions and start developing them quickly and seamlessly. Fortunately, this particular Azure service comes with multiple tools that help us during programming and running them locally. I will describe some extra applications as well, which should help you analyze and debug possible problems and test triggers before deploying to the cloud.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Starting with Azure Functions locally</h1>
                </header>
            
            <article>
                
<p>If you have installed all of the required software mentioned at the beginning of this chapter, you should be able to start developing them without any additional configuration. To get started, we will create a simple function that we will try to run to make sure that everything is set and ready.</p>
<p class="mce-root"/>
<p>When you open your Visual Studio instance, click on <span class="packt_screen">File</span> | <span class="packt_screen">New Project</span>. In the new screen, search for the <span class="packt_screen">Cloud</span> | <span class="packt_screen">Azure Functions</span> template:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/66b6c426-c55a-4ad6-a632-e2b42063db37.png" width="932" height="644"/></p>
<p>This is the first step that will ensure that everything on your side is configured correctly. When you click <span class="packt_screen">OK</span>,<span class="packt_screen"> </span>you will see another screen that lets you select a few different things:</p>
<ul>
<li><strong>Runtime version</strong>: You can choose between <span class="packt_screen">v1</span> and <span class="packt_screen">v2</span>. In this book, we will focus on <span class="packt_screen">v1</span> as <span class="packt_screen">v2</span> is still in preview.</li>
<li><strong>Trigger type</strong>: Depending on the SDK version you have, you will have different options available. Of course, this is not the full list of available triggers for Azure Functions.</li>
<li><strong>Storage Account</strong>: Most functions require a storage account to work. Fortunately, you can use <span class="packt_screen">Storage Emulator</span> locally, which is a simple database running under the <kbd>LocalDB</kbd> instance that's installed on your computer.</li>
</ul>
<div class="packt_infobox">A new version of SDK for Azure should install <span class="packt_screen">Storage Emulator</span> automatically. If, for some reason, you are missing it, go to the following page and install the missing component: <a href="https://docs.microsoft.com/en-us/azure/storage/common/storage-use-emulator#get-the-storage-emulator">https://docs.microsoft.com/en-us/azure/storage/common/storage-use-emulator#get-the-storage-emulator</a>.<a href="https://docs.microsoft.com/en-us/azure/storage/common/storage-use-emulator#get-the-storage-emulator"/></div>
<p>For the purpose of this exercise, I chose <span class="packt_screen">Http trigger</span> and left all of the fields with their default values:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/a69ed484-e1fd-4fef-b1ae-c886c111d8b3.png" width="723" height="416"/></div>
<p>When you click <span class="packt_screen">OK </span>and wait for a second, you will see that a new function file has been created with some boilerplate code already inserted. Since I will explain both creating a function and its features in the next section, I will not explain this in detail at this moment. To make sure that everything is working correctly, press <em>F5</em> and wait until the project is compiled. You will notice two things:</p>
<ul>
<li><span class="packt_screen">Storage Emulator</span> will be started in the background to handle function requests</li>
<li>A new window with the console application will open, displaying some diagnostic messages regarding Azure Functions</li>
</ul>
<p class="mce-root"/>
<p>The former is the actual Azure Functions runtime, which handles the whole work when you communicate with your functions. Here, you can see how it looks on my computer:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/537df9e0-59dd-469e-9cd4-94bf0c08334e.png" width="972" height="507"/></p>
<p>It's important to notice a few things:</p>
<ul>
<li>It displays under which port the runtime listens to incoming requests</li>
<li>It tells you from which location the configuration file is fetched and loaded</li>
<li>It notifies you about loaded custom extensions (as I said, it is possible to introduce custom bindings, which will be loaded in the runtime)</li>
<li>It displays the names (and URLs, in the case of HTTP triggers) of all found functions</li>
</ul>
<p>When you scroll down, you should be able to see an endpoint to the function you have just created:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/c0971696-735a-4461-9df1-742013c0a1e7.png" width="784" height="137"/></p>
<p>Now, we will try to call it to see whether it works (I am using Postman, but you can use any kind of tool you are familiar with):</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/69fc6484-6342-4b32-87a4-2b0f8ebfaefa.png" style="width:40.92em;height:19.92em;" width="680" height="331"/></p>
<p>As you can see, it works—it returned a result (though the result itself is not a success—we are missing a required field, but that is not an issue right now). If you send the same request, you should be able to see the same result. If, for some reason, you are unable to do so, do the following:</p>
<ul>
<li>Make sure that your function's host is still working and that it displays no error</li>
<li>Make sure <span>that</span> the port under which the runtime listens for incoming requests is open</li>
<li>Make sure <span>that</span> the Azure Functions CLI is not blocked by your firewall</li>
<li>Make sure <span>that</span> you are calling the correct endpoint</li>
</ul>
<p>In the next section, I will describe the function's structure in detail so that you will be able to proceed with more advanced scenarios and features.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a function</h1>
                </header>
            
            <article>
                
<p>We discussed the overall serverless approach and went through local configuration to make sure that we have some basic understanding of what Azure Functions are and how we can start working with them. In the following of this chapter, I will show you what exactly this service offers and how to work with it on daily basis. This will help you start developing full projects with Functions—from the simplest to the most advanced ones.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using Visual Studio</h1>
                </header>
            
            <article>
                
<p>In the previous section, you created a function using a wizard in Visual Studio. If you go back to this particular project and open its file, you will see some common code, which is always created with this particular template. Here, you can find the same code but without the custom code introduced by it:</p>
<pre>using System.Net.Http;<br/>using System.Threading.Tasks;<br/>using Microsoft.Azure.WebJobs;<br/>using Microsoft.Azure.WebJobs.Extensions.Http;<br/>using Microsoft.Azure.WebJobs.Host;<br/><br/>namespace HandsOnAzure.Function<br/>{<br/>    public static class Function1<br/>    {<br/>        [FunctionName("Function1")]<br/>        public static async Task&lt;HttpResponseMessage&gt; Run(<br/>            [HttpTrigger(AuthorizationLevel.Function, "get", "post", Route = null)]<br/>            HttpRequestMessage req, TraceWriter log)<br/>        {<br/>        }<br/>    }<br/>}</pre>
<p>As you can see, I deleted the whole function body—this is the only part that is not a part of the service (remember our IaaS versus PaaS versus serverless comparison?). We can see some attributes, which decorate both a C# method and its parameters—they all are a part of the runtime that runs your functions. Let's compare it with a function that is triggered by Azure Storage Queue:</p>
<pre>using Microsoft.Azure.WebJobs;<br/>using Microsoft.Azure.WebJobs.Host;<br/><br/>namespace HandsOnAzure.Function<br/>{<br/>    public static class Function2<br/>    {<br/>        [FunctionName("Function2")]<br/>        public static void Run([QueueTrigger("myqueue-items", Connection = "connection-string")]<br/>            string myQueueItem, TraceWriter log)<br/>        {<br/>        }<br/>    }<br/>}</pre>
<p>Here, you can see that still we have the <kbd>[FunctionName]</kbd> attribute and some kind of trigger attribute. What differs is, in fact, the type of trigger parameter—in HTTP, we had <kbd>HttpRequestMessage</kbd>, while in Queue, we have a simple <kbd>string</kbd> parameter. This parameter (and its type) directly define the type of message delivered to a function. In general, it is pretty clear—each HTTP request is deserialized and delivered as <kbd>HttpRequestMessage </kbd>(as in Web API, for example), and each <span>in-queue service and each message is</span> a string. However, how about the following signature:</p>
<pre>using System.Net.Http;<br/>using Microsoft.Azure.WebJobs;<br/>using Microsoft.Azure.WebJobs.Extensions.Http;<br/>using Microsoft.Azure.WebJobs.Host;<br/><br/>namespace HandsOnAzure.Function<br/>{<br/>    public static class Function3<br/>    {<br/>        [FunctionName("Function3")]<br/>        public static HttpResponseMessage Run(<br/>            [HttpTrigger(AuthorizationLevel.Function, "get", "post", Route = "Function3/name/{name}")]<br/>            HttpRequestMessage req, string name, TraceWriter log)<br/>        {<br/>        }<br/>    }<br/>}</pre>
<p>As you can see, the preceding example introduced one more parameter—<kbd>name</kbd>, which is a string, though the whole function is triggered by an HTTP request. This particular parameter will be used during the binding procedure, which will find that this function's route contains it in its URL template. This is the very same model as in traditional MVC/Web API frameworks, which provide the same feature. </p>
<p class="mce-root"/>
<div class="packt_infobox">The binding procedure itself is quite complicated and mostly depends on the type of used trigger. Unfortunately, it is out of the scope of this book, so I will not cover it in detail—fortunately, Azure Functions are OSS, so you can check how the host works directly in the code. </div>
<p>If you want to quickly add a new function to your project, perform the following steps:</p>
<ol>
<li>Right-click on your project in Visual Studio and search for the <span class="packt_screen">Add</span> | <span class="packt_screen">New Azure Function...</span> menu item.</li>
<li>This will display a screen where you can enter new function name.</li>
<li>When you click <span class="packt_screen">Add</span>, you will see another screen, which allows you to select a function type with far more options than we initially saw:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="Images/961c2e9b-c583-4b55-a88e-c241900fabd2.png" style="width:49.17em;height:32.00em;" width="793" height="515"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using Azure Portal</h1>
                </header>
            
            <article>
                
<p>As with all other Azure services, it is also possible to create a function app instance by creating it directly in Azure Portal:</p>
<ol>
<li>When you log in, click on <span class="packt_screen">+ Create a resource</span><strong> </strong>and search for<span class="packt_screen"> Function App.</span></li>
</ol>
<ol start="2">
<li>When you click <span class="packt_screen">Create</span>, you will see a screen with a couple of fields that need to be filled in before processing occurs:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/22559cc8-25f6-48b3-af0c-678a98446a35.png" style="width:20.25em;height:40.33em;" width="312" height="622"/> </p>
<p>As you can see, the preceding form is familiar to the one we used when creating an App Service instance. This is because, <span>under the hood,</span> Azure Functions is powered by this particular service and multiple available features are shared between them. As you can see, you are able to select <span class="packt_screen">OS</span>, which defines the runtime you will be able to use.</p>
<div class="packt_tip">If you are interested in using .NET Core, you can start working with Linux as your OS. This is currently in preview, but allows for using the v2 version of the runtime. It has many enhancements and uses the newest .NET stack so, in many cases, it can be quicker than v1.</div>
<p>In the <span class="packt_screen">Hosting Plan </span>drop-down menu, you are able to select whether you want to use the <span class="packt_screen">Consumption Plan</span> or <span class="packt_screen">App Service</span> model for pricing. We discussed the differences between these in the previous part of this chapter, so you should be able to decide on which one to use by yourself. Remember that you will have to select the <span class="packt_screen">B1 </span>tier at least.</p>
<div class="packt_infobox">Azure Portal disallows you from using <span class="packt_screen">Shared </span>or <span class="packt_screen">Free </span>tiers as Azure Functions requires the <span class="packt_screen">Always On</span><strong> </strong>feature to be enabled—you probably remember that it is available only for <span class="packt_screen">Basic </span>and higher tiers. While it is possible to create a function app with, for example, <span class="packt_screen">Free </span>tier (using, for instance, ARM templates), it will not work correctly.</div>
<p class="mce-root">This wizard also gives you the possibility to enable<span class="packt_screen"> Application Insights</span> integration. Since we have not discussed this particular service yet, I will skip it in this chapter. However, if you are interested in monitoring your functions, it is a much better option than the integrated <span class="packt_screen">Monitor </span>feature—it gives you much more detail and is much more intuitive in daily work.</p>
<div class="packt_tip">Enabling <span class="packt_screen">Application Insights</span><em> </em>for your function app can drastically change the overall price of the whole service as, initially, each function produces many different traces and logs. For production, it is always a good idea to the lower logged severity of messages—you can find more information about configuration at: <a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-monitoring">https://docs.microsoft.com/en-us/azure/azure-functions/functions-monitoring</a>.</div>
<p>When you are satisfied with your settings, you can click <span class="packt_screen">Create</span>. Azure Portal will validate all of the fields and initiate the service provisioning procedure. After several seconds, your function app should be ready for work. When you go to it, you will see the dashboard, which is the starting point for accessing all of the features of Azure Functions:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/088ace13-4f61-49d8-a20a-44081da782b3.png" width="1200" height="429"/></div>
<p>Now, if you want to create a function, move your mouse cursor over the <span class="packt_screen">Functions </span>section and click on the plus sign (<span class="packt_screen">+</span>). It will display a new wizard screen, where you can choose to either start with a premade function or create a custom one. For the purpose of this exercise, I decided to go with a timer function written in JavaScript:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/1a15974d-efbb-41b9-81b0-76ae63037882.png" style="width:29.42em;height:26.67em;" width="507" height="460"/></p>
<p>After clicking on the <span class="packt_screen">Create this function</span><strong> </strong>button, you will see that some function code has been generated. Azure Portal allows also you to edit a function directly in your browser window, so if you want to try out some custom code, there is nothing preventing you from doing so:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/54e8d4f8-3c6e-4ccf-b781-7fb7276f2d53.png" style="width:53.92em;height:21.42em;" width="869" height="345"/></p>
<p>Additionally, you can click <span class="packt_screen">Run</span>—this is the so-called <strong>manual trigger</strong> and enables you to start a function immediately. The result of running a function will be visible in the <span class="packt_screen">Logs </span>window:</p>
<pre class="log-stream">2018-07-22T09:15:36  Welcome, you are now connected to log-streaming service.
2018-07-22T09:15:57.252 [Info] Function started (Id=63d9f8ff-b807-4805-8b24-5f90edfc0134)
2018-07-22T09:15:57.377 [Info] JavaScript timer trigger function ran!: 2018-07-22T09:15:57.377Z
2018-07-22T09:15:57.377 [Info] Function completed (Success, Id=63d9f8ff-b807-4805-8b24-5f90edfc0134, Duration=128ms)
2018-07-22T09:17:36  No new trace in the past 1 min(s).
2018-07-22T09:18:36  No new trace in the past 2 min(s).</pre>
<p>Congratulations—you have learned how to create a function using both Visual Studio and Azure Portal. In the next section, I will describe more advanced scenarios and will focus on understanding further Azure Functions features.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Azure Functions features</h1>
                </header>
            
            <article>
                
<p>Azure Functions is not only about providing executable code, which will be handled by the runtime. It allows for even more advanced scenarios, which make this service an excellent choice when you want to start developing quickly and with minimal configuration required. In this section, I will show you how to leverage more advanced features of functions<em> </em>and how to progress with your skill in using this Azure component.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Platform features</h1>
                </header>
            
            <article>
                
<p>As you may remember, Azure Functions is built on top App Service, which allows you to use multiple already known features, such as <span class="packt_screen">Custom domains</span>, <span class="packt_screen">Application settings</span>, and <span class="packt_screen">Authentication/Authorization</span>. To access all available <span class="packt_screen">Platform features</span>,<strong> </strong>go to your function app in Azure Portal and click on the appropriate tab:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/ca997ca5-430f-46be-843a-4259c00fcae5.png" width="1001" height="377"/></p>
<p>As you can see, we have a variety of different features available—what you are interested in depends solely on your specific requirements. There is, however, one function-specific feature that I would like to describe: <span class="packt_screen">Function app settings</span>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>When you click on this link, a new tab will open, with some crucial options that can be set:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/7dd59cbc-7818-4ed9-99d7-5f56b92b5057.png" width="870" height="667"/></p>
<p>In the preceding screenshot, you can see that most of the features are either not enabled or unavailable. This depends on the state of your function app—by design, all problematic functionalities are opt-out, so they will not interfere with your functions. Anyway, I will describe them here so that you can decide whether you need them or not:</p>
<ul>
<li><span class="packt_screen">Daily Usage Quota (GB-Sec)</span>: If you want to set a hard limit for function app usage, you can set it here. Thanks to this, you can ensure that it will not exceed some predefined quota you are aiming at.</li>
<li><span class="packt_screen">Runtime version</span>: This setting defines the current runtime version your function app uses. Note that it is not possible to change v1 to beta (v2, in this case), as it is possible that the newer version introduces some changes that would break your application.</li>
<li><span class="packt_screen">Function app edit mode</span>: If you decide to deploy your functions with any kind of CI/CD pipeline, this setting will be automatically set to <span class="packt_screen">Read Only</span>. This ensures that it is not possible to introduce changes while in runtime without going through the automated process.</li>
<li><span class="packt_screen">Slots </span><span class="packt_screen">(preview)</span>: If you want to perform blue/green deployment (to perform a rapid rollback if something goes wrong), this enables you to deploy a new version as a new instance and immediately swap it with the existing one.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Security</h1>
                </header>
            
            <article>
                
<p>We have not covered another important topic yet—Azure Function<em> </em>security. While it is possible to use, for example, Azure Active Directory or social providers as identity sources (and—as a result—add authentication to a function app), by default, functions are secured by their keys. You can check the available keys when you click on the <span class="packt_screen">Manage </span>tab:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/21bd3666-5676-4f2d-a401-84df75b1b134.png" style="width:40.42em;height:30.75em;" width="601" height="457"/></p>
<p>Depending on the way a function is triggered, different options may be available. Here, you can see what another function app looks like when it is triggered by an HTTP trigger instead of a timer:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/f00e9a65-5c87-4b97-a581-1661cdd873c5.png" style="width:42.92em;height:34.00em;" width="567" height="449"/></p>
<p>As you can see, we have two types of keys available:</p>
<ul>
<li><span class="packt_screen">Function Keys</span>: These are designed for this particular function</li>
<li><span class="packt_screen">Host Keys</span>: These allow for calling any function within a function app</li>
</ul>
<p>You can use keys as an easy way to implement authorization in your function app. You can generate a new one for each client, revoke them, and set a particular value. </p>
<div class="packt_infobox">Note that function keys are designed for functions that are triggered by HTTP requests—there is no possibility to use them for other kinds of triggers.</div>
<p>There are two ways of using function keys to authorize a request. You can put them in the query string:</p>
<pre>https://handsonazurefunctionapp.azurewebsites.net/api/HttpTriggerJS1?code=awKhkdPqyQvYUwzn6zle6V4hqk460YwOBs9RyaQUthX/AWGBMjtRIA==</pre>
<p>Or you can use headers and introduce the <kbd>x-functions-key</kbd><strong> </strong>header, which will contain a key inside it:</p>
<pre>GET /api/HttpTriggerJS1 HTTP/1.1<br/>Host: handsonazurefunctionapp.azurewebsites.net<br/>Content-Type: application/json<br/>x-functions-key: awKhkdPqyQvYUwzn6zle6V4hqk460YwOBs9RyaQUthX/AWGBMjtRIA==<br/>Cache-Control: no-cache</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Monitor</h1>
                </header>
            
            <article>
                
<p>Each call and each execution of a function is monitored and saved. When you click on the <span class="packt_screen">Monitor </span>tab, you will see a screen that contains the next execution with some diagnostics data.</p>
<div class="packt_tip">If you do not see a list, you will probably be asked to enable the <span class="packt_screen">Application Insights </span>integration. To access standard view, click on the <span class="packt_screen">Switch to classic view</span><strong> </strong>button.</div>
<p>Here, you can see the log of executions of my function, triggered by a timer:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/879c8038-c6ce-4489-b3fb-60603cb35f12.png" style="width:52.08em;height:35.17em;" width="841" height="567"/></div>
<p>As you can see, it contains information about each particular execution, the success and error count, and invocation details. When you select a specific item, you will also see all of the logs from a function.</p>
<div class="packt_infobox">The <span class="packt_screen">Monitor </span>feature is quite useful for quickly analyzing issues. For more detailed errors and logs, you will have to enable <span class="packt_screen">Application Insights</span> and use its features.</div>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Host.json</h1>
                </header>
            
            <article>
                
<p>When you create a function, you will see that a <kbd>host.json</kbd><strong> </strong>file is  automatically created. While initially empty, it is a global configuration file that defines how triggers and function will behave. Here, you can find an example file with most features, such as bindings' configuration and generic features, available:</p>
<pre>{<br/>    "aggregator": {<br/>        "batchSize": 1000,<br/>        "flushTimeout": "00:00:30"<br/>    },<br/>    "applicationInsights": {<br/>        "sampling": {<br/>          "isEnabled": true,<br/>          "maxTelemetryItemsPerSecond" : 5<br/>        }<br/>    },<br/>    "eventHub": {<br/>      "maxBatchSize": 64,<br/>      "prefetchCount": 256,<br/>      "batchCheckpointFrequency": 1<br/>    },<br/>    "functions": [ "QueueProcessor", "GitHubWebHook" ],<br/>    "functionTimeout": "00:05:00",<br/>    "healthMonitor": {<br/>        "enabled": true,<br/>        "healthCheckInterval": "00:00:10",<br/>        "healthCheckWindow": "00:02:00",<br/>        "healthCheckThreshold": 6,<br/>        "counterThreshold": 0.80<br/>    },<br/>    "http": {<br/>        "routePrefix": "api",<br/>        "maxOutstandingRequests": 20,<br/>        "maxConcurrentRequests": 10,<br/>        "dynamicThrottlesEnabled": false<br/>    },<br/>    "id": "9f4ea53c5136457d883d685e57164f08",<br/>    "logger": {<br/>        "categoryFilter": {<br/>            "defaultLevel": "Information",<br/>            "categoryLevels": {<br/>                "Host": "Error",<br/>                "Function": "Error",<br/>                "Host.Aggregator": "Information"<br/>            }<br/>        }<br/>    },<br/>    "queues": {<br/>      "maxPollingInterval": 2000,<br/>      "visibilityTimeout" : "00:00:30",<br/>      "batchSize": 16,<br/>      "maxDequeueCount": 5,<br/>      "newBatchThreshold": 8<br/>    },<br/>    "serviceBus": {<br/>      "maxConcurrentCalls": 16,<br/>      "prefetchCount": 100,<br/>      "autoRenewTimeout": "00:05:00"<br/>    },<br/>    "singleton": {<br/>      "lockPeriod": "00:00:15",<br/>      "listenerLockPeriod": "00:01:00",<br/>      "listenerLockRecoveryPollingInterval": "00:01:00",<br/>      "lockAcquisitionTimeout": "00:01:00",<br/>      "lockAcquisitionPollingInterval": "00:00:03"<br/>    },<br/>    "tracing": {<br/>      "consoleLevel": "verbose",<br/>      "fileLoggingMode": "debugOnly"<br/>    },<br/>    "watchDirectories": [ "Shared" ],<br/>}</pre>
<p>As you can see, it contains things such as logger settings, function timeout value, and particular triggers configuration. In the <em>Further reading</em><strong> </strong>section, you will find a link where each section of the <kbd>host.json</kbd> file is described in detail.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Publish</h1>
                </header>
            
            <article>
                
<p>Azure Functions are published the very same way as App Service, since they share many common parts. If you right-click on your functions project in Visual Studio and select <span class="packt_screen">Publish</span>, you will see a screen that's similar to the one we saw when working with App Services:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/6aea865a-9775-42d3-8585-103a8d20c47f.png" style="width:44.50em;height:12.83em;" width="787" height="227"/></p>
<p>Traditionally, you have the possibility to select to either create a new function app or use an existing one. When you use the existing one and click on the <span class="packt_screen">Publish </span>button, you will be able to find a function app in a specific <span class="packt_screen">Resource Group</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/05452f09-82d6-4e51-afa0-ea910913fa3a.png" style="width:49.00em;height:14.67em;" width="792" height="237"/></p>
<p>Now, when you click <span class="packt_screen">OK</span>, a new publish profile will be created and the whole application will be deployed.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Workflow in Azure Functions – Durable Functions</h1>
                </header>
            
            <article>
                
<p>In most cases, the best idea for working with functions<em> </em>is to keep them stateless. This makes things much easier as you do not have to worry about sharing resources and storing state. However, there are cases where you will like to access it and distribute between different instances of your functions. In such scenarios (such as orchestrating a workflow or scheduling a task to be done), a better option to start with would be to leverage the capabilities of Durable Functions, an extension to the main runtime, which changes the way you work a little bit.</p>
<p class="mce-root"/>
<p>It changes the way Azure Functions works as it lets you resume from where the execution was paused or stopped and introduces the possibility to take the output of one function and pass it as input. We will not cover this in detail, as this book is not only about Azure Functions, but you will get a glimpse of this feature, which will help you start it on your own.</p>
<div class="packt_tip">To get started, you don't need any extra extensions—the only thing you will need is an additional NuGet package named <kbd>Microsoft.Azure.WebJobs.Extensions.DurableTask</kbd>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Orchestrations and activities</h1>
                </header>
            
            <article>
                
<p>The main elements of Durable Functions are orchestrations and activities. There are some significant differences between them:</p>
<ul>
<li><kbd>Orchestrations</kbd>: These are designed to orchestrate different activities. They should be single-threaded and idempotent, and they can use only a very limited set of asynchronous methods. They are scaled based on the number of internal queues. What's more, they control the flow of one or more activities.</li>
<li><kbd>Activities</kbd>: These should contain most of the logic of your application. They work as typical functions (without the limits of orchestrations). They are scaled to multiple VMs.</li>
</ul>
<p>Here, you can find the code for both types of functions:</p>
<pre>[FunctionName("Orchestration")]<br/>public static async Task Orchestration_Start([OrchestrationTrigger] DurableOrchestrationContext context)<br/>{<br/>  var payload = context.GetInput&lt;string&gt;();<br/>  await context.CallActivityAsync(nameof(Activity), payload);<br/>}<br/><br/>[FunctionName("Activity")]<br/>public static string Activity([ActivityTrigger] DurableActivityContext context)<br/>{<br/>  var payload = context.GetInput&lt;string&gt;();<br/>  return $"Current payload is {payload}!";<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>As you can see, they are both decorated with the <kbd>[FunctionName]</kbd><strong> </strong>attribute as a typical function—the difference comes from the trigger that's used.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Orchestration client</h1>
                </header>
            
            <article>
                
<p>To get started with an orchestration, you need a host for it. In Durable Functions, that host is the orchestration client, which enables you to perform the following actions on an orchestration:</p>
<ul>
<li>Start it</li>
<li>Terminate it</li>
<li>Get its status</li>
<li>Raise an event and pass it to an orchestration</li>
</ul>
<p>The basic code for a client is pretty simple:</p>
<pre>[FunctionName("Orchestration_Client")]<br/>public static async Task&lt;string&gt; Orchestration_Client(<br/>  [HttpTrigger(AuthorizationLevel.Anonymous, "post", Route = "start")] HttpRequestMessage input,<br/>  [OrchestrationClient] DurableOrchestrationClient starter)<br/>{<br/>  return await starter.StartNewAsync("Orchestration", await input.Content.ReadAsStringAsync());<br/>}</pre>
<p>As you can see from the preceding code, we started an orchestration by providing its name and passing some payload, which will be deserialized and decoded. Here, you can find an example of a client that has been hosted to terminate an instance by passing its identifier:</p>
<pre>[FunctionName("Terminate")]<br/>public static async Task Terminate(<br/>  [HttpTrigger(AuthorizationLevel.Anonymous, "post", Route = "terminate/{id}")] HttpRequestMessage input,<br/>  string id,<br/>  [OrchestrationClient] DurableOrchestrationClient client)<br/>{<br/>  var reason = "Manual termination";<br/>  await client.TerminateAsync(id, reason);<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Orchestration history</h1>
                </header>
            
            <article>
                
<p>The way Durable Functions work ensures that, if any activity is replayed, its result will not be evaluated again (this is why orchestrations have to be idempotent). Here, you can find a diagram that shows how the framework works in detail:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/4d497554-936a-4975-8053-f65635e6301b.png" style="width:41.58em;height:40.50em;" width="1781" height="1735"/></p>
<p>To make a long story short, I divided the process into four parts:</p>
<ul>
<li><strong>Dispatcher</strong>: This is the internal part of the framework, which is responsible for calling orchestrations, performing replays, and saving the state</li>
<li><strong>Orchestrator function</strong>: This is an orchestration that calls activities</li>
<li><strong>Storage</strong>:<strong> </strong>This is a place where the orchestration history is stored</li>
<li><strong>Queue</strong>: This is an internal <span>queue </span>(implemented using Azure Storage Queues), which is used to control the flow of execution of an orchestration</li>
</ul>
<p>The way Durable Functions works is as follows:</p>
<ol>
<li>Dispatchers run an orchestration, which calls <kbd>Activity1</kbd> and awaits its result</li>
<li>The control is returned to a dispatcher, which commits the state in the orchestration history and pushes a message to a queue</li>
<li>In the meantime, orchestration is deallocated, saving memory and processor</li>
<li>After fetching a message from a queue and finishing a task, the dispatcher<strong> </strong>recreates an orchestration and replays all activities</li>
<li>If it finds that this particular activity has been finished, it gets only its result and proceeds to another activity</li>
</ol>
<p>The preceding process lasts until all of the activities are processed. Information about execution history can be found in a table called <kbd>DurableFunctionsHubHistory</kbd>, which you can find inside the Azure Table Storage used by your function app.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Timers</h1>
                </header>
            
            <article>
                
<p>Sometimes, you might want to schedule work after a specific delay. While using traditional functions, you have to create a custom solution that will somehow trigger a workflow at a specific time. In Durable Functions, it is as easy as writing one line of code. Consider the following example:</p>
<pre>[FunctionName("Orchestration_Client")]<br/>public static async Task&lt;string&gt; Orchestration_Client(<br/>  [HttpTrigger(AuthorizationLevel.Anonymous, "post", Route = "start")] HttpRequestMessage input,<br/>  [OrchestrationClient] DurableOrchestrationClient starter)<br/>{<br/>  return await starter.StartNewAsync("Orchestration", null);<br/>}<br/><br/>[FunctionName("Orchestration")]<br/>public static async Task Orchestration_Start([OrchestrationTrigger] DurableOrchestrationContext context, TraceWriter log)<br/>{<br/>  log.Info($"Scheduled at {context.CurrentUtcDateTime}");<br/><br/>  await context.CreateTimer(context.CurrentUtcDateTime.AddHours(1), CancellationToken.None);<br/>  await context.CallActivityAsync(nameof(Activity), context.CurrentUtcDateTime);<br/>}<br/><br/>[FunctionName("Activity")]<br/>public static void Activity([ActivityTrigger] DurableActivityContext context, TraceWriter log)<br/>{<br/>  var date = context.GetInput&lt;DateTime&gt;();<br/>  log.Info($"Executed at {date}");<br/>}</pre>
<p>In the preceding example, I used the <kbd>context.CreateTimer()</kbd><strong> </strong>method, which allows for creating a delay in function execution. If the previous orchestration is executed, it will return control to the dispatcher after awaiting a timer. Thanks to this, you will not be charged for this particular function execution as it will be deallocated and recreated later, after waiting for a specific interval.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">External events</h1>
                </header>
            
            <article>
                
<p>In Durable Functions, it is possible to wait for an external event before proceeding with a workflow. This is especially helpful if you want to create an interactive flow, where you initiate a process in one place and have a requirement to wait for someone's decision. To raise an event, you can use the following function:</p>
<pre>[FunctionName("Orchestration_Raise")]<br/>public static async Task Orchestration_Raise(<br/>  [HttpTrigger(AuthorizationLevel.Anonymous, "post", Route = "start_raise/{id}/{event}")] HttpRequestMessage input,<br/>  string id,<br/>  string @event,<br/>  [OrchestrationClient] DurableOrchestrationClient starter)<br/>{<br/>  await starter.RaiseEventAsync(id, @event, await input.Content.ReadAsStringAsync());<br/>}</pre>
<p>Here, you can find an example of waiting for an event:</p>
<pre>[FunctionName("Orchestration")]<br/>public static async Task&lt;string&gt; Orchestration_Start([OrchestrationTrigger] DurableOrchestrationContext context)<br/>{<br/>  var @event = await context.WaitForExternalEvent&lt;int&gt;("Approved");<br/><br/>  if (@event == 1)<br/>  {<br/>    var result = await context.CallActivityAsync&lt;string&gt;(nameof(Activity), @event);<br/>    return result;<br/>  }<br/><br/>  return "Not Approved";<br/>}</pre>
<p>The way this works can be described as follows: the first functions allows you to raise a custom event by passing the appropriate parameters. The second function is paused while waiting for the <kbd>context.WaitForExternalEvent()</kbd> function. If you send an event with the <kbd>Approved</kbd> type, a function will be resumed and will continue. Additionally, you can pass a payload of an event, which will be passed as a result of <kbd>WaitForExternalEvent()</kbd>. This method works in the same way as timers and other Durable Functions functions, which are available in <kbd>DurableOrchestrationType</kbd>—while awaiting, control is returned to the dispatcher and the function itself is deallocated.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Integrating functions with other services</h1>
                </header>
            
            <article>
                
<p>In the last part of this chapter, we will focus a little bit on understanding how Azure <span>Functions </span>integrate with other Azure services. We will take a look at the available triggers and bindings and try to figure out the best use cases for them and how they really work. This section is designed in a way that enables you to explore more by yourself, thanks to a common understanding of how Azure Functions work.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Function file</h1>
                </header>
            
            <article>
                
<p>When you take a look at your <kbd>bin </kbd>directory, where compiled functions are available, you will find a bit of a different structure than in traditional applications.</p>
<p>Here, you can find my folder from the exercise from this chapter:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/2a09935d-9b0f-4893-914a-9014868582d0.png" style="width:32.25em;height:6.50em;" width="457" height="92"/></p>
<p>As you can see, it contains the <kbd>Function1</kbd> directory, which contains one file named <kbd>function. json</kbd>. Here, you can find its content:</p>
<pre>{<br/>  "generatedBy": "Microsoft.NET.Sdk.Functions-1.0.14",<br/>  "configurationSource": "attributes",<br/>  "bindings": [<br/>    {<br/>      "type": "httpTrigger",<br/>      "methods": [<br/>        "get",<br/>        "post"<br/>      ],<br/>      "authLevel": "function",<br/>      "name": "req"<br/>    }<br/>  ],<br/>  "disabled": false,<br/>  "scriptFile": "../bin/HandsOnAzure.Function.dll",<br/>  "entryPoint": "HandsOnAzure.Function.Function1.Run"<br/>}</pre>
<p>It defines some metadata, which is further used by the function's runtime and the <kbd>bindings</kbd> field, which is a definition of used triggers. If you compare it with a code attribute, you will see that it is quite similar:</p>
<pre>[FunctionName("Function1")]<br/>public static async Task&lt;HttpResponseMessage&gt; Run(<br/>  [HttpTrigger(AuthorizationLevel.Function, "get", "post", Route = null)]<br/>  HttpRequestMessage req, TraceWriter log)<br/>{<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>When you compile your project, a compiler will produce a <kbd>function.json</kbd><strong> </strong>file for each function defined in your code. Here, you can find the output for the event hub trigger:</p>
<pre>{<br/>  "generatedBy": "Microsoft.NET.Sdk.Functions-1.0.0.0",<br/>  "configurationSource": "attributes",<br/>  "bindings": [<br/>    {<br/>      "type": "eventHubTrigger",<br/>      "path": "myhub",<br/>      "connection": "EhConnection",<br/>      "name": "myEventHubMessage"<br/>    }<br/>  ],<br/>  "disabled": false,<br/>  "scriptFile": "..\\bin\\FunctionsTest.dll",<br/>  "entryPoint": "FunctionsTest.Hub.Run"<br/>}</pre>
<p>As you can see, it has the same structure and only the <kbd>bindings</kbd> field differs, so it reflects another trigger type.</p>
<div class="packt_tip">Note that the <span>content and structure of</span> <kbd>function.json</kbd> may differ depending on the SDK version used. Do not use it in your application directly to avoid problems that have a lack of backward compatibility.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Input/output bindings</h1>
                </header>
            
            <article>
                
<p>Some bindings are bi-directional,  while some can be used only one way. What's more, not every binding can be used as a trigger. An example of both bi-directional and trigger binding is Azure Blob Storage<em>.</em> Here, you can find an example of how it works as a trigger:</p>
<pre>[FunctionName("BlobTriggerCSharp")] <br/>public static void Run([BlobTrigger("my-blobs/{name}")] Stream myBlob, string name, TraceWriter log)<br/>{<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>Compare it with an example of a function triggered by a queue, but accepting blob as input:</p>
<pre>[FunctionName("BlobInput")]<br/>public static void BlobInput(<br/>  [QueueTrigger("myqueue-items")] string myQueueItem,<br/>  [Blob("samples-workitems/{queueTrigger}", FileAccess.Read)] Stream myBlob,<br/>  TraceWriter log)<br/>{<br/>}</pre>
<p>As you can see, I used the same syntax in both cases besides one thing—I declared <kbd>FileAccess.Read</kbd><strong> </strong>to tell the runtime that this is not a trigger. Here is another example of output:</p>
<pre>[FunctionName("ResizeImage")]<br/>public static void ResizeImage_Run(<br/>  [BlobTrigger("sample-images/{name}")] Stream image,<br/>  [Blob("sample-images-sm/{name}", FileAccess.Write)] Stream imageSmall,<br/>  [Blob("sample-images-md/{name}", FileAccess.Write)] Stream imageMedium)<br/>{<br/>  // There goes your code...<br/>}</pre>
<p>As you can see, the syntax is still similar—the only thing that has changed is the <kbd>FileAccess</kbd> value. There are also other possibilities for using the return value of a function. Here, you can find out how to define the result by using an attribute:</p>
<pre>[FunctionName("QueueTrigger")]<br/>[return: Blob("output-container/{id}")]<br/>public static string QueueTrigger_Run([QueueTrigger("myqueue")] string input, TraceWriter log)<br/>{<br/>  return "Some string...";<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Custom bindings</h1>
                </header>
            
            <article>
                
<p>While Azure Functions offer a variety of different bindings for many different scenarios, sometimes, you want a custom functionality that is not available. In such cases, it is possible to create a custom binding, which I mentioned earlier in this chapter. To generate it, you need the following things:</p>
<ul>
<li>An attribute decorated with the <kbd>[Binding]</kbd><strong> </strong>attribute</li>
<li>An implementation of the <kbd>IBindingProvider</kbd> interface</li>
<li>An implementation of the <kbd>IBinding</kbd> interface</li>
<li>An implementation of the <kbd>IExtensionConfigProvider</kbd> interface</li>
</ul>
<p>By providing all of the preceding implementations, your binding will be automatically fetched by the runtime and enabled. If everything is set correctly, you will be notified of this during runtime start:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/b70e3ea1-aced-41b4-8e88-8b89ccda9112.png" width="985" height="185"/></p>
<p>In the <span>preceding </span>screenshot, you can see that the runtime extracted <kbd>IdentityExtensionConfig Provider</kbd> from my code, which will be used later when resolving my custom binding.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you have learned a lot about Azure Functions and how to work with this serverless component. You read about the differences in pricing models, scalability concerns, and basic triggers and bindings. We worked on some simple scenarios regarding monitoring, deploying, and developing this Azure service.</p>
<p>In the following chapters in this book, you will learn even more about serverless services. We will then come back to work even more with functions, as this is one of the most popular Azure components that can be easily integrated with other tools and products.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is the difference between App Service and the consumption pricing model?</li>
<li>What is GB/s?</li>
<li>Can you create stateful services with Azure Functions?</li>
<li>What is the name of a container that's used for functions?</li>
<li>Can you use Python in Azure Functions?</li>
</ol>
<ol start="6">
<li>Can a binding act both as a trigger and output? Can you provide an example?</li>
<li>Why is a function app mode sometimes set as read-only?</li>
<li>Can you use the <span class="packt_screen">Application Settings</span><strong> </strong>feature in the same way as in App Services?</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li>Azure Functions overview: <a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-overview">https://docs.microsoft.com/en-us/azure/azure-functions/functions-overview</a></li>
<li><kbd>host.json</kbd> description: <a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-host-json">https://docs.microsoft.com/en-us/azure/azure-functions/functions-host-json</a></li>
<li>The schema of the <kbd>functions.json</kbd> file: <a href="http://json.schemastore.org/function">http://json.schemastore.org/function</a></li>
<li>Triggers and bindings for Azure Functions: <a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings">https://docs.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings</a></li>
<li>Durable Functions: <a href="https://docs.microsoft.com/en-us/azure/azure-functions/durable-functions-overview">https://docs.microsoft.com/en-us/azure/azure-functions/durable-functions-overview</a></li>
</ul>


            </article>

            
        </section>
    </div>



  </body></html>