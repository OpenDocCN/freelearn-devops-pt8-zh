<html><head></head><body>
<div id="_idContainer170">
<h1 class="chapter-number" id="_idParaDest-235"><a id="_idTextAnchor569"/><span class="koboSpan" id="kobo.1.1">13</span></h1>
<h1 id="_idParaDest-236"><a id="_idTextAnchor570"/><span class="koboSpan" id="kobo.2.1">Getting Started on Google Cloud – Building Solutions with GCE</span></h1>
<p><span class="koboSpan" id="kobo.3.1">You’ve made it. </span><span class="koboSpan" id="kobo.3.2">After the previous six chapters, where we used two different cloud platforms and three different cloud computing paradigms to build six distinct solutions, we are finally ready to take our </span><a id="_idIndexMarker975"/><span class="koboSpan" id="kobo.4.1">final journey by adapting our solution to </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">Google Cloud </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.6.1">Platform</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.7.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.8.1">GCP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">Like the last two adventures, in this alternate universe, we will be starting our journey by building our solution with a </span><strong class="bold"><span class="koboSpan" id="kobo.11.1">virtual machine</span></strong><span class="koboSpan" id="kobo.12.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.13.1">VM</span></strong><span class="koboSpan" id="kobo.14.1">) architecture on Google Cloud. </span><span class="koboSpan" id="kobo.14.2">As we saw when we transitioned </span><a id="_idIndexMarker976"/><span class="koboSpan" id="kobo.15.1">between AWS and Azure when we compared how the same solution architecture was built on the two different cloud platforms, some things changed a lot, while many things changed only a tiny bit – or not at all. </span><span class="koboSpan" id="kobo.15.2">We observed that our Terraform code changed pretty consistently across all chapters. </span><span class="koboSpan" id="kobo.15.3">However, other things, such as Packer, Docker, and GitHub Actions workflows, only changed slightly. </span><span class="koboSpan" id="kobo.15.4">Our .NET-based application code didn’t change at all, whether being hosted in VMs or containers, but when we got to serverless, the application code went through </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">radical refactoring.</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">The same is true as we move the solution to GCP. </span><span class="koboSpan" id="kobo.17.2">As a result, we won’t be revisiting these topics at the same length in this chapter. </span><span class="koboSpan" id="kobo.17.3">However, I would encourage you to bookmark </span><em class="italic"><span class="koboSpan" id="kobo.18.1">Chapters 7</span></em><span class="koboSpan" id="kobo.19.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.20.1">8</span></em><span class="koboSpan" id="kobo.21.1"> and refer to them frequently. </span><span class="koboSpan" id="kobo.21.2">This chapter will only focus on the changes we must make to deploy our solution </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">on GCP.</span></span></p>
<p><span class="koboSpan" id="kobo.23.1">This chapter covers the </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.25.1">Laying </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">the foundation</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">Designing </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">the solution</span></span></li>
<li><span class="koboSpan" id="kobo.29.1">Building </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">the solution</span></span></li>
<li><span class="koboSpan" id="kobo.31.1">Automating </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">the deploymen</span><a id="_idTextAnchor571"/><span class="koboSpan" id="kobo.33.1">t</span></span></li>
</ul>
<h1 id="_idParaDest-237"><a id="_idTextAnchor572"/><span class="koboSpan" id="kobo.34.1">Laying the foundation</span></h1>
<p><span class="koboSpan" id="kobo.35.1">Our team at Söze Enterprises applauds their achievement of responding to the whimsical technical course correction of their fearless leader, Keyser Söze, and marvels at their success and fortune in</span><a id="_idIndexMarker977"/><span class="koboSpan" id="kobo.36.1"> launching their product successfully on Microsoft Azure. </span><span class="koboSpan" id="kobo.36.2">They utilized VMs, Kubernetes, and, finally, serverless technology. </span><span class="koboSpan" id="kobo.36.3">The comforting deep blue of the Azure portal begins to fade away when suddenly, the air fills with an eerie yet familiar sound: doodle-oo doodle-oo doodle-oo. </span><span class="koboSpan" id="kobo.36.4">The familiar duo appears – sitting in a cozy wood-paneled basement, a look typical of suburban basements from the late '80s and early '90s. </span><span class="koboSpan" id="kobo.36.5">The walls are adorned with posters and memorabilia, including a prominent Chicago Bears pennant, highlighting Wayne’s love for rock music and sports. </span><span class="koboSpan" id="kobo.36.6">They start the familiar chant: doodle-oo doodle-oo doodle-oo. </span><span class="koboSpan" id="kobo.36.7">Suddenly, we’re transported to another world – another universe, perhaps, where Google Cloud’s sleek multicolored logo replaces Azure’s deep blue. </span><span class="koboSpan" id="kobo.36.8">Söze Enterprises has now partnered with Google Cloud for their next-generation autonomous </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">vehicle platform.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">As before, we inherited a team from one of Söze Enterprises’ other divisions with a strong core team of C# .NET developers, so we’ll build version 1.0 of the platform using .NET technologies. </span><span class="koboSpan" id="kobo.38.2">The elusive CEO, Keyser, was rumored to have joined Google co-founder Sergey Brin aboard his super yacht, the Dragonfly, off the Amalfi Coast, and word has come down from corporate that we will be using Google Cloud to host the platform. </span><span class="koboSpan" id="kobo.38.3">Since the team doesn’t have much experience with containers and timelines are tight, we’ve decided to build a simple three-tier architecture and host on </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">Azure VMs:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer157">
<span class="koboSpan" id="kobo.40.1"><img alt="Figure 13.1 – Logical architecture for the autonomous vehicle platform" src="image/B21183_13_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.41.1">Figure 13.1 – Logical architecture for the autonomous vehicle platform</span></p>
<p><span class="koboSpan" id="kobo.42.1">The platform will need a frontend, which will be a web UI built using ASP.NET Core Blazor. </span><span class="koboSpan" id="kobo.42.2">The frontend will be powered by a REST API backend, which will be built using ASP.NET Core Web API. </span><span class="koboSpan" id="kobo.42.3">Having our core functionality encapsulated into a REST API will allow autonomous vehicles to communicate directly with the platform and allow us to expand by adding client interfaces with additional frontend technologies such as native mobile apps and virtual or mixed reality in the future. </span><span class="koboSpan" id="kobo.42.4">The backend will use a PostgreSQL database for persistent </span><a id="_idIndexMarker978"/><span class="koboSpan" id="kobo.43.1">storage since it’s lightweight, industry-standard, and </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">relatively inexpensiv</span><a id="_idTextAnchor573"/><span class="koboSpan" id="kobo.45.1">e.</span></span></p>
<h1 id="_idParaDest-238"><a id="_idTextAnchor574"/><span class="koboSpan" id="kobo.46.1">Designing the solution</span></h1>
<p><span class="koboSpan" id="kobo.47.1">Due to the tight timelines</span><a id="_idIndexMarker979"/><span class="koboSpan" id="kobo.48.1"> the team is facing, we want to keep the cloud architecture simple. </span><span class="koboSpan" id="kobo.48.2">Therefore, we’ll be keeping it simple and using Google Cloud services that will allow us to provision using familiar VM technologies as opposed to trying to learn something new. </span><span class="koboSpan" id="kobo.48.3">The first decision we have to make is what Google Cloud service each component of our logical architecture will be </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">hosted on.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">Our application architecture consists of three components: a frontend, a backend, and a database. </span><span class="koboSpan" id="kobo.50.2">The frontend and backend are application components and need to be hosted on a cloud service that provides general computing, while the database needs to be hosted on a cloud database service. </span><span class="koboSpan" id="kobo.50.3">There are many options for both types </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">of services:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer158">
<span class="koboSpan" id="kobo.52.1"><img alt="Figure 13.2 – Logical architecture for the autonomous vehicle platform and the hosts" src="image/B21183_13_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.53.1">Figure 13.2 – Logical architecture for the autonomous vehicle platform and the hosts</span></p>
<p><span class="koboSpan" id="kobo.54.1">Since we have decided we’re going to use VMs to host our application, we have narrowed down the different services that we</span><a id="_idIndexMarker980"/><span class="koboSpan" id="kobo.55.1"> can use to host our application. </span><span class="koboSpan" id="kobo.55.2">We have decided </span><strong class="bold"><span class="koboSpan" id="kobo.56.1">Google Compute Engine</span></strong><span class="koboSpan" id="kobo.57.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.58.1">GCE</span></strong><span class="koboSpan" id="kobo.59.1">) is the ideal choice for our </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">current situation:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer159">
<span class="koboSpan" id="kobo.61.1"><img alt="Figure 13.3 – Source control structure of our repository" src="image/B21183_13_3..jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.62.1">Figure 13.3 – Source control structure of our repository</span></p>
<p><span class="koboSpan" id="kobo.63.1">This solution will have six parts. </span><span class="koboSpan" id="kobo.63.2">We still have the application code and Packer templates for both the frontend and </span><a id="_idIndexMarker981"/><span class="koboSpan" id="kobo.64.1">backend. </span><span class="koboSpan" id="kobo.64.2">Then, we have GitHub Actions to implement our CI/CD process and Terraform to provision our Google Cloud infrastructure and reference the Packer-built VM images for our </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">GCE instanc</span><a id="_idTextAnchor575"/><span class="koboSpan" id="kobo.66.1">es.</span></span></p>
<h2 id="_idParaDest-239"><a id="_idTextAnchor576"/><span class="koboSpan" id="kobo.67.1">Cloud architecture</span></h2>
<p><span class="koboSpan" id="kobo.68.1">The first part of our design is </span><a id="_idIndexMarker982"/><span class="koboSpan" id="kobo.69.1">adapting our solution’s architecture to the target cloud platform: Google Cloud. </span><span class="koboSpan" id="kobo.69.2">This involves mapping application architecture components to GCP services and thinking through the configuration of those services so that they meet the requirements of </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">our solut</span><a id="_idTextAnchor577"/><span class="koboSpan" id="kobo.71.1">ion.</span></span></p>
<h3><span class="koboSpan" id="kobo.72.1">Projects and API access</span></h3>
<p><span class="koboSpan" id="kobo.73.1">Before we get started, we need a project within the organization where a service account can be created for Terraform to use. </span><span class="koboSpan" id="kobo.73.2">This service account needs to be granted access to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">roles/resourcemanager.projectCreator</span></strong><span class="koboSpan" id="kobo.75.1"> organizational role. </span><span class="koboSpan" id="kobo.75.2">This will allow you to create </span><a id="_idIndexMarker983"/><span class="koboSpan" id="kobo.76.1">projects with Terraform, which will allow you to keep a complete solution together and avoid additional boilerplate prerequisites that are executed outside of Terraform using the </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">command-line interface.</span></span></p>
<p><span class="koboSpan" id="kobo.78.1">Once this has been done, you </span><a id="_idIndexMarker984"/><span class="koboSpan" id="kobo.79.1">need to enable the </span><strong class="bold"><span class="koboSpan" id="kobo.80.1">Cloud Resource Manager API</span></strong><span class="koboSpan" id="kobo.81.1"> within the project where the Terraform service account resides. </span><span class="koboSpan" id="kobo.81.2">This API is required within the context of the Google Cloud project because of the way Google Cloud grants access to different features of the platform at the project level. </span><span class="koboSpan" id="kobo.81.3">It creates another gate for the Google Cloud</span><a id="_idIndexMarker985"/><span class="koboSpan" id="kobo.82.1"> identity to be able to access resources </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">on GCP.</span></span></p>
<p><span class="koboSpan" id="kobo.84.1">Your Terraform service account will also need access to Cloud Storage, which you plan on using to store Terraform state. </span><span class="koboSpan" id="kobo.84.2">When using the AWS and Azure providers, you can use different credentials to access the Terraform backend than you use to provision your environment. </span><span class="koboSpan" id="kobo.84.3">On Google Cloud, this can be accomplished by setting </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">GOOGLE_BACKEND_CREDENTIALS</span></strong><span class="koboSpan" id="kobo.86.1"> with credentials for the identity you wish to use to communicate with the Google Cloud Storage bucket and </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">GOOGLE_APPLICATION_CREDENTIALS</span></strong><span class="koboSpan" id="kobo.88.1"> with credentials for the identity you wish to use to communicate with Google Cloud to provision </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">your envir</span><a id="_idTextAnchor578"/><span class="koboSpan" id="kobo.90.1">onment.</span></span></p>
<h3><span class="koboSpan" id="kobo.91.1">Virtual network</span></h3>
<p><span class="koboSpan" id="kobo.92.1">VMs must be deployed </span><a id="_idIndexMarker986"/><span class="koboSpan" id="kobo.93.1">within a virtual network. </span><span class="koboSpan" id="kobo.93.2">As you may recall from </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.94.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.95.1">, when we provisioned this solution on AWS, we needed to set up multiple Subnets for our solution to span Availability Zones. </span><span class="koboSpan" id="kobo.95.2">In </span><a href="B21183_08.xhtml#_idTextAnchor402"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.96.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.97.1">, when deploying the solution to Azure, we only needed two subnets – one for the frontend and one for the backend. </span><span class="koboSpan" id="kobo.97.2">That’s because Azure’s virtual network architecture is structured differently than AWS’s and subnets on Azure span multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">Availability Zones.</span></span></p>
<p><span class="koboSpan" id="kobo.99.1">Google Cloud’s virtual network service is also structured differently. </span><span class="koboSpan" id="kobo.99.2">Unlike both AWS and Azure, which have virtual networks scoped to a particular region, virtual networks on GCP span multiple regions by default. </span><span class="koboSpan" id="kobo.99.3">Subnets are scoped to the region, which means, like Azure, a subnet on GCP can host VMs from multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">Availability Zones.</span></span></p>
<p><span class="koboSpan" id="kobo.101.1">The following diagram shows that the Google compute network is not tied to the region like it is on AWS </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">and Azure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer160">
<span class="koboSpan" id="kobo.103.1"><img alt="Figure 13.4 – Google Cloud network architecture" src="image/B21183_13_4..jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.104.1">Figure 13.4 – Google Cloud network architecture</span></p>
<p><span class="koboSpan" id="kobo.105.1">Although this seems like </span><a id="_idIndexMarker987"/><span class="koboSpan" id="kobo.106.1">a significant difference at the root of the deployment hierarchy, it doesn’t materially impact the design as the subnets (or </span><em class="italic"><span class="koboSpan" id="kobo.107.1">subnetworks</span></em><span class="koboSpan" id="kobo.108.1">) are still tied to </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">a region:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer161">
<span class="koboSpan" id="kobo.110.1"><img alt="Figure 13.5 – Isolated subnets for the frontend and backend application components" src="image/B21183_13_5..jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.111.1">Figure 13.5 – Isolated subnets for the frontend and backend application components</span></p>
<p><span class="koboSpan" id="kobo.112.1">When building a single-region solution, the multi-region capability of Google Cloud might seem like overkill. </span><span class="koboSpan" id="kobo.112.2">However, automatic spanning does simplify infrastructure management as</span><a id="_idIndexMarker988"/><span class="koboSpan" id="kobo.113.1"> businesses don’t have to manually set up and maintain inter-regional connections. </span><span class="koboSpan" id="kobo.113.2">This not only reduces administrative overhead but also allows for more agile and scalable deployments in response to changing demands by making active-active multi-region deployments easier to build </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">and m</span><a id="_idTextAnchor579"/><span class="koboSpan" id="kobo.115.1">aintain.</span></span></p>
<h3><span class="koboSpan" id="kobo.116.1">Network routing</span></h3>
<p><span class="koboSpan" id="kobo.117.1">Inside Google Cloud networks, the</span><a id="_idIndexMarker989"/><span class="koboSpan" id="kobo.118.1"> default setup is designed to provide straightforward and secure connectivity. </span><span class="koboSpan" id="kobo.118.2">As we know, by default, Google Cloud networks are global resources, meaning all the subnets (or </span><em class="italic"><span class="koboSpan" id="kobo.119.1">subnetworks</span></em><span class="koboSpan" id="kobo.120.1">) within a single network can communicate with each other, regardless of their regional location, without the need for explicit routes or VPNs. </span><span class="koboSpan" id="kobo.120.2">This inter-subnet communication uses the system-generated routes in </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">the network.</span></span></p>
<p><span class="koboSpan" id="kobo.122.1">For routing configurations, Google Cloud has </span><strong class="bold"><span class="koboSpan" id="kobo.123.1">routes</span></strong><span class="koboSpan" id="kobo.124.1">, which perform a role similar to AWS’s route tables, directing</span><a id="_idIndexMarker990"/><span class="koboSpan" id="kobo.125.1"> traffic based on IP ranges. </span><span class="koboSpan" id="kobo.125.2">For situations where instances need to initiate outbound connections to the internet without revealing their IP, Google Cloud provides Cloud NAT, which </span><a id="_idIndexMarker991"/><span class="koboSpan" id="kobo.126.1">is analogous to AWS’s </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.127.1">NAT gateways</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.129.1">Like Azure, Google Cloud does not have </span><a id="_idIndexMarker992"/><span class="koboSpan" id="kobo.130.1">a direct equivalent named </span><strong class="bold"><span class="koboSpan" id="kobo.131.1">internet gateway</span></strong><span class="koboSpan" id="kobo.132.1">. </span><span class="koboSpan" id="kobo.132.2">Instead, internet</span><a id="_idIndexMarker993"/><span class="koboSpan" id="kobo.133.1"> connectivity in GCP is managed using a combination of system-generated routes and </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">fi</span><a id="_idTextAnchor580"/><span class="koboSpan" id="kobo.135.1">rewall rules.</span></span></p>
<h3><span class="koboSpan" id="kobo.136.1">Load balancing</span></h3>
<p><span class="koboSpan" id="kobo.137.1">Google Cloud has two options when it comes to load balancers: global and regional. </span><span class="koboSpan" id="kobo.137.2">Global load balancers distribute traffic across multiple regions, ensuring users are served from the nearest or </span><a id="_idIndexMarker994"/><span class="koboSpan" id="kobo.138.1">most suitable region, while regional load balancers distribute traffic within a single region. </span><span class="koboSpan" id="kobo.138.2">The choice between them typically depends on the application’s user distribution and the need for low-latency access. </span><span class="koboSpan" id="kobo.138.3">However, sometimes, other limitations force </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">your hand:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer162">
<span class="koboSpan" id="kobo.140.1"><img alt="Figure 13.6 – Google Cloud regional load balancer" src="image/B21183_13_6..jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.141.1">Figure 13.6 – Google Cloud regional load balancer</span></p>
<p><span class="koboSpan" id="kobo.142.1">Unfortunately, the regional load balancer’s target pool does not allow you to specify a different port for the backend instances. </span><span class="koboSpan" id="kobo.142.2">This means the target pool will forward traffic to the same port where it received traffic. </span><span class="koboSpan" id="kobo.142.3">For instance, if the forwarding rule is listening on port </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">80</span></strong><span class="koboSpan" id="kobo.144.1">, the target pool will send traffic to port </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">80</span></strong><span class="koboSpan" id="kobo.146.1"> of the </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">backend instances.</span></span></p>
<p><span class="koboSpan" id="kobo.148.1">To achieve your goal of forwarding from port </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">80</span></strong><span class="koboSpan" id="kobo.150.1"> to port </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">5000</span></strong><span class="koboSpan" id="kobo.152.1">, you would need to use the global load balancer instead of the regional </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">load balancer:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer163">
<span class="koboSpan" id="kobo.154.1"><img alt="Figure 13.7 – Google Cloud global load balancer" src="image/B21183_13_7..jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.155.1">Figure 13.7 – Google Cloud global load balancer</span></p>
<p><span class="koboSpan" id="kobo.156.1">The global load balancer requires that you set up instance groups to organize the VMs that the load will be distributed across. </span><span class="koboSpan" id="kobo.156.2">Google</span><a id="_idIndexMarker995"/><span class="koboSpan" id="kobo.157.1"> Cloud instance groups are similar to AWS Auto Scaling groups and Azure’s </span><strong class="bold"><span class="koboSpan" id="kobo.158.1">Virtual Machine Scale Sets</span></strong><span class="koboSpan" id="kobo.159.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.160.1">VMSS</span></strong><span class="koboSpan" id="kobo.161.1">), but they have a bit more flexibility in that </span><a id="_idIndexMarker996"/><span class="koboSpan" id="kobo.162.1">you can either provide a VM template and allow GCP to </span><em class="italic"><span class="koboSpan" id="kobo.163.1">manage</span></em><span class="koboSpan" id="kobo.164.1"> the instances or you can provision the instances explicitly and add them later to the instance group. </span><span class="koboSpan" id="kobo.164.2">This dual-mode capability is similar to Azure’s VMSS rather than AWS’s Auto Scaling group, which can only operate in a </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.165.1">managed</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.166.1"> mode.</span></span></p>
<p><span class="koboSpan" id="kobo.167.1">As we saw when comparing AWS and Azure, all the anatomical parts of a load balancer are present and accounted for – they just might go by different names and connect in slightly different ways. </span><span class="koboSpan" id="kobo.167.2">The following table extends the mapping that we did between AWS and Azure and includes the </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">GCP equivalents:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-4">
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.169.1">AWS</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.170.1">Azure</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.171.1">GCP</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.172.1">Description</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.173.1">Application Load </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.174.1">Balancer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.175.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.176.1">ALB</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">)</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.178.1">Azure</span><a id="_idIndexMarker997"/> <span class="No-Break"><span class="koboSpan" id="kobo.179.1">Load Balancer</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.180.1">URL map</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.181.1">Load balancer</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.182.1">Listener</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.183.1">Frontend </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">IP configuration</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.185.1">Global </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">forwarding rule</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.187.1">The singular endpoint that accepts incoming traffic on a </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">load balancer</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.189.1">Target Group</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.190.1">Backend </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">Address pool</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.192.1">Backend </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">Service</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.194.1">A collection of VMs that incoming traffic is </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">forwarded to</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.196.1">Health check</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.197.1">Health probe</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.198.1">Health check</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.199.1">An endpoint published by each of the backend VMs that indicates it is healthy and ready to </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">handle traffic</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.201.1">Table 13.1 – Mapping of synonymous load balancer components between AWS, Azure, and GCP</span></p>
<p><span class="koboSpan" id="kobo.202.1">The URL map and the Target HTTP proxy compose the global load balancer, which attaches to the forwarding</span><a id="_idIndexMarker998"/><span class="koboSpan" id="kobo.203.1"> rule, which acts as the singular endpoint, and the backend service, which represents the collection of VMs to distribute </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">load across.</span></span><a id="_idTextAnchor581"/></p>
<h3><span class="koboSpan" id="kobo.205.1">Network security</span></h3>
<p><span class="koboSpan" id="kobo.206.1">To control network</span><a id="_idIndexMarker999"/><span class="koboSpan" id="kobo.207.1"> traffic, Google Cloud offers firewall rules that allow users to specify which packets are allowed into and out of instances. </span><span class="koboSpan" id="kobo.207.2">While Google Cloud’s firewall rules share some similarities with AWS’s </span><strong class="bold"><span class="koboSpan" id="kobo.208.1">network access control lists</span></strong><span class="koboSpan" id="kobo.209.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.210.1">NACLs</span></strong><span class="koboSpan" id="kobo.211.1">), it’s crucial to note that GCP firewall rules are</span><a id="_idIndexMarker1000"/><span class="koboSpan" id="kobo.212.1"> stateful, while AWS NACLs </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">are stateles</span><a id="_idTextAnchor582"/><span class="koboSpan" id="kobo.214.1">s.</span></span></p>
<h3><span class="koboSpan" id="kobo.215.1">Secrets management</span></h3>
<p><span class="koboSpan" id="kobo.216.1">Secrets such as database </span><a id="_idIndexMarker1001"/><span class="koboSpan" id="kobo.217.1">credentials or service access keys need to be stored securely. </span><span class="koboSpan" id="kobo.217.2">Each cloud platform has a service that provides this functionality. </span><span class="koboSpan" id="kobo.217.3">On GCP, this service is called Google Cloud </span><a id="_idIndexMarker1002"/><span class="No-Break"><span class="koboSpan" id="kobo.218.1">Secret Manager.</span></span></p>
<p><span class="koboSpan" id="kobo.219.1">Again, we will see slight naming convention differences but all the anatomical parts are there. </span><span class="koboSpan" id="kobo.219.2">The following table extends the mapping that we did between AWS and Azure and includes the </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">GCP equivalents:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table002-3">
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.221.1">AWS</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.222.1">Azure</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.223.1">GCP</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.224.1">Description</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.225.1">IAM</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.226.1">Microsoft Entra</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.227.1">Cloud Identity</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.228.1">Identity provider</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.229.1">Secrets </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">Manager</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.231.1">Key Vault</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.232.1">Secret Manager</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.233.1">Secure </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">secret storage</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.235.1">IAM role</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.236.1">User-assigned </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">managed identity</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.238.1">Service account</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.239.1">Identity for </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">machine-to-machine interaction</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.241.1">IAM policy</span></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.242.1">Role-based access </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.243.1">control</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.244.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.245.1">RBAC</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">)</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.247.1">IAM member</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.248.1">Permission to </span><a id="_idIndexMarker1003"/><span class="koboSpan" id="kobo.249.1">perform specific operations on specific services </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">or resources</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.251.1">IAM </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">role policy</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.253.1">Role assignment</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.254.1">IAM member</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.255.1">Associates specific permissions to </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">specific identities</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.257.1">Table 13.2 – Mapping of synonymous IAM components between AWS, Azure, and GCP</span></p>
<p><span class="koboSpan" id="kobo.258.1">Secrets stored in Google Cloud Secret Manager can be accessed by VMs once they have the necessary access </span><a id="_idIndexMarker1004"/><span class="koboSpan" id="kobo.259.1">granted. </span><span class="koboSpan" id="kobo.259.2">In </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.260.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.261.1">, we used an AWS IAM role assignment to allow a VM to do this, and with Azure, we used user-assigned managed identities and ole assignments. </span><span class="koboSpan" id="kobo.261.2">On GCP, we need to use a service account and grant it permissions to the </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">specific secrets:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer164">
<span class="koboSpan" id="kobo.263.1"><img alt="Figure 13.8 – Key Vault architecture" src="image/B21183_13_8..jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.264.1">Figure 13.8 – Key Vault architecture</span></p>
<p><span class="koboSpan" id="kobo.265.1">Granting the managed identity that is </span><a id="_idIndexMarker1005"/><span class="koboSpan" id="kobo.266.1">attached to the VMs access to the </span><strong class="bold"><span class="koboSpan" id="kobo.267.1">Key Vault Secrets User</span></strong><span class="koboSpan" id="kobo.268.1"> role will allow </span><a id="_idIndexMarker1006"/><span class="koboSpan" id="kobo.269.1">the VMs to read the secret values from Key Vault. </span><span class="koboSpan" id="kobo.269.2">This does not put the secrets on the machine. </span><span class="koboSpan" id="kobo.269.3">The VM will need to use the Azure CLI to access the Key </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">Vault secrets</span><a id="_idTextAnchor583"/><span class="koboSpan" id="kobo.271.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.272.1">VMs</span></h3>
<p><span class="koboSpan" id="kobo.273.1">Now that we have everything we need for our solution, we can finish by talking about where our application components will run: VMs provisioned on Google Cloud’s Compute Engine service. </span><span class="koboSpan" id="kobo.273.2">When provisioning VMs on GCP, you have two options. </span><span class="koboSpan" id="kobo.273.3">First, you can provide static </span><a id="_idIndexMarker1007"/><span class="koboSpan" id="kobo.274.1">VMs. </span><span class="koboSpan" id="kobo.274.2">In this approach, you need to specify key characteristics for every VM. </span><span class="koboSpan" id="kobo.274.3">You can organize these VMs into an instance group to better manage the health and life cycle of the VMs. </span><span class="koboSpan" id="kobo.274.4">The second option is to provision an instance group manager. </span><span class="koboSpan" id="kobo.274.5">This will allow you to dynamically scale up and down based on demand, as well as auto-heal VMs </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">that fail:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer165">
<span class="koboSpan" id="kobo.276.1"><img alt="Figure 13.9 – Google Cloud Compute Engine instance architecture" src="image/B21183_13_9..jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.277.1">Figure 13.9 – Google Cloud Compute Engine instance architecture</span></p>
<p><span class="koboSpan" id="kobo.278.1">Similar to Azure, Google Cloud separates the concept of grouping VMs that are tied together through the application life cycle from the management of their health and dynamic provisioning. </span><span class="koboSpan" id="kobo.278.2">In Azure, an availability set is a logical group that can be used to place individual VMs into a relationship so that their relationship is taken into consideration by the </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">underlying platform:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer166">
<span class="koboSpan" id="kobo.280.1"><img alt="Figure 13.10 – Instance group manager architecture" src="image/B21183_13_10..jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.281.1">Figure 13.10 – Instance group manager architecture</span></p>
<p><span class="koboSpan" id="kobo.282.1">On Google Cloud, that is an instance group. </span><span class="koboSpan" id="kobo.282.2">Both allow you to easily attach a pool of VMs to other services relevant to multiple VMs working a problem together, such as load balancers and health monitoring. </span><span class="koboSpan" id="kobo.282.3">To add dynamic provisioning and management, on Azure, you would </span><a id="_idIndexMarker1008"/><span class="koboSpan" id="kobo.283.1">need a VMSS. </span><span class="koboSpan" id="kobo.283.2">On Google </span><a id="_idIndexMarker1009"/><span class="koboSpan" id="kobo.284.1">Cloud, this is called an instance </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">group manager.</span></span></p>
<p><span class="koboSpan" id="kobo.286.1">Again, just as we saw previously, the names have been changed to protect the innocent, but make no mistake, they work the same way. </span><span class="koboSpan" id="kobo.286.2">The following table extends the mapping that we did between AWS and Azure and includes the </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">GCP equivalents:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table003-1">
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.288.1">AWS</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.289.1">Azure</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.290.1">GCP</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.291.1">Description</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.292.1">EC2</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.293.1">VMs</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.294.1">Compute </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">instance</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.296.1">VM service</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.297.1">AMI</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.298.1">VM image</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.299.1">Google </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">compute image</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.301.1">VM image either from the marketplace or a custom build (for example, using tools such </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">s Packer)</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.303.1">IAM role</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.304.1">User-assigned </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">managed identity</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.306.1">Service account</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.307.1">Identity for </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">machine-to-machine interaction</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.309.1">Auto </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">Scaling group</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.311.1">VMSS</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.312.1">Instance </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">group manager</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.314.1">Set of dynamically provisioned VMs that can be scaled up/down using a VM </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">configuration template</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.316.1">Launch template</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.317.1">VM profile</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.318.1">Instance template</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.319.1">Configuration template used to create </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">new VMs</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.321.1">Table 13.3 – Mapping of synonymous VM service components between AWS, Azure, and GCP</span></p>
<p><span class="koboSpan" id="kobo.322.1">In </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.323.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.324.1">, we provisioned our solution </span><a id="_idIndexMarker1010"/><span class="koboSpan" id="kobo.325.1">using AWS </span><strong class="bold"><span class="koboSpan" id="kobo.326.1">Elastic Cloud Compute</span></strong><span class="koboSpan" id="kobo.327.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.328.1">EC2</span></strong><span class="koboSpan" id="kobo.329.1">) service and in </span><a href="B21183_08.xhtml#_idTextAnchor402"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.330.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.331.1">, we did the same but with the Azure VM service. </span><span class="koboSpan" id="kobo.331.2">Like both of these platforms, on GCP, VMs are connected to virtual networks using network interfaces. </span><span class="koboSpan" id="kobo.331.3">Unlike AWS and Azure, these network interfaces cannot be provisioned independently of the VM and are then </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">attached later.</span></span></p>
<p><span class="koboSpan" id="kobo.333.1">We also discussed the subtle differences between how Azure and AWS handle network security, with AWS having low-level network security handled by NACLs that attach at the subnet and more logical </span><a id="_idIndexMarker1011"/><span class="koboSpan" id="kobo.334.1">security groups that attach at the instance and process network traffic in a stateful manner. </span><span class="koboSpan" id="kobo.334.2">Azure has similar constructs with network security groups, which focus more on network traffic between physical endpoints (IP address ranges and network gateways), and application security groups, which focus on network traffic between logical application endpoints. </span><span class="koboSpan" id="kobo.334.3">Google Cloud combines the two into Google Compute firewall resources that can control network traffic using physical network characteristics such as IP address ranges and logical constructs such as service accounts </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">and tags.</span></span></p>
<p><span class="koboSpan" id="kobo.336.1">This pattern of using tags to attach behavior or grant permissions is a common pattern on GCP and you should make note of it as other platforms do not regard tags as a method for establishing </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">security boundaries</span><a id="_idTextAnchor584"/><span class="koboSpan" id="kobo.338.1">.</span></span></p>
<h2 id="_idParaDest-240"><a id="_idTextAnchor585"/><span class="koboSpan" id="kobo.339.1">Deployment architecture</span></h2>
<p><span class="koboSpan" id="kobo.340.1">Now that we</span><a id="_idIndexMarker1012"/><span class="koboSpan" id="kobo.341.1"> have a good idea </span><a id="_idIndexMarker1013"/><span class="koboSpan" id="kobo.342.1">of what our cloud architecture is going to look like for our solution on Google Cloud, we need to come up with a plan on how to provision our environments and deploy </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">our co</span><a id="_idTextAnchor586"/><span class="koboSpan" id="kobo.344.1">de.</span></span></p>
<h3><span class="koboSpan" id="kobo.345.1">VM configuration</span></h3>
<p><span class="koboSpan" id="kobo.346.1">In our solution, we have two VM roles: the frontend role, which is responsible for handling web page requests from the end </span><a id="_idIndexMarker1014"/><span class="koboSpan" id="kobo.347.1">user’s web browser, and the backend role, which is responsible for handling REST API requests from the web application. </span><span class="koboSpan" id="kobo.347.2">Each of these roles has a different code and different configuration that needs to be set. </span><span class="koboSpan" id="kobo.347.3">Each will require its own Packer template to build a VM image that we can use to launch a VM on </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">Google Cloud:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer167">
<span class="koboSpan" id="kobo.349.1"><img alt="Figure 13.11 – Packer pipeline to build a VM image for the frontend" src="image/B21183_13_11..jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.350.1">Figure 13.11 – Packer pipeline to build a VM image for the frontend</span></p>
<p><span class="koboSpan" id="kobo.351.1">A GitHub Actions workflow that triggers off changes to the frontend application code and the frontend Packer template will execute </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">packer build</span></strong><span class="koboSpan" id="kobo.353.1"> and create a new VM image for the </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">solution’s frontend.</span></span></p>
<p><span class="koboSpan" id="kobo.355.1">Both the frontend and the backend will have identical GitHub workflows that execute </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">packer build</span></strong><span class="koboSpan" id="kobo.357.1">. </span><span class="koboSpan" id="kobo.357.2">The key difference between the workflows is the code bases that they execute against. </span><span class="koboSpan" id="kobo.357.3">Both the frontend and the backend might have slightly different operating system configurations, and both require different deployment packages for their respective </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">application components:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer168">
<span class="koboSpan" id="kobo.359.1"><img alt="Figure 13.12 – Packer pipeline to build a VM image for the backend" src="image/B21183_13_12..jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.360.1">Figure 13.12 – Packer pipeline to build a VM image for the backend</span></p>
<p><span class="koboSpan" id="kobo.361.1">It’s important to note that the application code will be baked into the VM image rather than copied to an already running VM. </span><span class="koboSpan" id="kobo.361.2">This means that to update the software running on the VMs, each VM will need to be restarted so that it can be restarted with a new VM image containing the latest copy of </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.363.1">This approach makes </span><a id="_idIndexMarker1015"/><span class="koboSpan" id="kobo.364.1">the VM image an immutable deployment artifact that is versioned and updated each time there is a release of the application code that needs to </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">be deploy</span><a id="_idTextAnchor587"/><span class="koboSpan" id="kobo.366.1">ed.</span></span></p>
<h3><span class="koboSpan" id="kobo.367.1">Cloud environment configuration</span></h3>
<p><span class="koboSpan" id="kobo.368.1">Once the VM images have been </span><a id="_idIndexMarker1016"/><span class="koboSpan" id="kobo.369.1">built for both the frontend and the backend, we can execute the final workflow that will both provision and deploy our solution to </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">Google Cloud:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer169">
<span class="koboSpan" id="kobo.371.1"><img alt="Figure 13.13 – VM images as inputs to the Terraform code, which provisions the environment on Google Cloud" src="image/B21183_13_13..jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.372.1">Figure 13.13 – VM images as inputs to the Terraform code, which provisions the environment on Google Cloud</span></p>
<p><span class="koboSpan" id="kobo.373.1">The Terraform code base will have two input variables for the version of the VM image for both the frontend and the backend. </span><span class="koboSpan" id="kobo.373.2">When new versions of the application software need to be deployed, the input parameters for these versions will be incremented to reflect the target version for deployment. </span><span class="koboSpan" id="kobo.373.3">When the workflow is executed, </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">terraform apply</span></strong><span class="koboSpan" id="kobo.375.1"> will simply replace the existing VMs with VMs using the new </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">VM ima</span><a id="_idTextAnchor588"/><span class="koboSpan" id="kobo.377.1">ge.</span></span></p>
<p><span class="koboSpan" id="kobo.378.1">Now that we have a solid plan for how we will implement both the cloud architecture using Google Cloud and the deployment architecture using GitHub Actions, let’s start building! </span><span class="koboSpan" id="kobo.378.2">In the next section, we’ll break</span><a id="_idIndexMarker1017"/><span class="koboSpan" id="kobo.379.1"> down the </span><strong class="bold"><span class="koboSpan" id="kobo.380.1">HashiCorp Configuration Language</span></strong><span class="koboSpan" id="kobo.381.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.382.1">HCL</span></strong><span class="koboSpan" id="kobo.383.1">) code that we’ll use to implement the Terraform and </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">Packer solutions.</span></span></p>
<h1 id="_idParaDest-241"><a id="_idTextAnchor589"/><span class="koboSpan" id="kobo.385.1">Building the solution</span></h1>
<p><span class="koboSpan" id="kobo.386.1">Now that we have a solid design for</span><a id="_idIndexMarker1018"/><span class="koboSpan" id="kobo.387.1"> our solution, we can begin building it. </span><span class="koboSpan" id="kobo.387.2">As discussed in the previous section, we’ll be using VMs powered by Google Cloud Compute Engine. </span><span class="koboSpan" id="kobo.387.3">As we did with AWS and Azure in </span><em class="italic"><span class="koboSpan" id="kobo.388.1">Chapters 7</span></em><span class="koboSpan" id="kobo.389.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.390.1">10</span></em><span class="koboSpan" id="kobo.391.1">, respectively, we’ll need to package our application into VM images using Packer and then provision an environment that provisions an environment using these </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">VM im</span><a id="_idTextAnchor590"/><span class="koboSpan" id="kobo.393.1">ages.</span></span></p>
<h2 id="_idParaDest-242"><a id="_idTextAnchor591"/><span class="koboSpan" id="kobo.394.1">Packer</span></h2>
<p><span class="koboSpan" id="kobo.395.1">In this section, we’ll cover how to implement our Packer templates provisioners so that we can install our .NET </span><a id="_idIndexMarker1019"/><span class="koboSpan" id="kobo.396.1">application code on a Linux VM. </span><span class="koboSpan" id="kobo.396.2">If you skipped </span><em class="italic"><span class="koboSpan" id="kobo.397.1">Chapters 7</span></em><span class="koboSpan" id="kobo.398.1"> through </span><em class="italic"><span class="koboSpan" id="kobo.399.1">9</span></em><span class="koboSpan" id="kobo.400.1"> due to a lack of interest in (AWS, I can’t hold that against you – particularly if your primary interest in reading this book is working on GCP. </span><span class="koboSpan" id="kobo.400.2">However, I would encourage you to review the corresponding section within </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.401.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.402.1"> to see how we use Packer’s provisioners to configure a Debian-based Linux VM with our .NET </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">application</span><a id="_idTextAnchor592"/><span class="koboSpan" id="kobo.404.1"> code.</span></span></p>
<h3><span class="koboSpan" id="kobo.405.1">Google Cloud plugin</span></h3>
<p><span class="koboSpan" id="kobo.406.1">As we discussed in </span><a href="B21183_04.xhtml#_idTextAnchor239"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.407.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.408.1">, Packer – like Terraform – is an extensible command-line executable. </span><span class="koboSpan" id="kobo.408.2">Each</span><a id="_idIndexMarker1020"/><span class="koboSpan" id="kobo.409.1"> cloud platform provides a plugin for Packer that encapsulates the integration with </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">its services:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.411.1">
packer {
  required_plugins {
    googlecompute = {
      source  = "github.com/hashicorp/googlecompute"
      version = "~&gt; 1.1.2"
    }
  }
}</span></pre> <p><span class="koboSpan" id="kobo.412.1">In </span><em class="italic"><span class="koboSpan" id="kobo.413.1">Chapters 7</span></em><span class="koboSpan" id="kobo.414.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.415.1">10</span></em><span class="koboSpan" id="kobo.416.1">, we saw how to declare the Packer plugin for AWS and Azure (respectively) as a required plugin. </span><span class="koboSpan" id="kobo.416.2">The preceding code demonstrates how to declare Google Cloud’s plugin – at the time of writing, the latest version </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">is 1.1.2.</span></span></p>
<p><span class="koboSpan" id="kobo.418.1">The Google Cloud plugin for Packer provides a </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">googlecompute</span></strong><span class="koboSpan" id="kobo.420.1"> builder that will generate Google Cloud compute images by creating a new VM from a base image, executing the provisioners, taking a snapshot of the Google Cloud instance’s boot disk, and creating a Google Cloud compute image from it. </span><span class="koboSpan" id="kobo.420.2">Like the AWS and Azure plugins, this behavior is encapsulated within Google </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">Cloud’s builder.</span></span></p>
<p><span class="koboSpan" id="kobo.422.1">Just as the other plugins encapsulated the logic to build VMs on their respective platforms, its configuration was oriented using terminology specific to each platform. </span><span class="koboSpan" id="kobo.422.2">Packer does not try to </span><a id="_idIndexMarker1021"/><span class="koboSpan" id="kobo.423.1">create a standard builder interface across cloud platforms – rather, it isolates the cloud-specific configuration within the builders. </span><span class="koboSpan" id="kobo.423.2">This keeps things simple for users who know the target platform well and allows the builder to take advantage of any platform-specific features without additional layers of complexity by trying to rationalize the syntax across </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">every platform.</span></span></p>
<p><span class="koboSpan" id="kobo.425.1">As a result, the structure</span><a id="_idIndexMarker1022"/><span class="koboSpan" id="kobo.426.1"> of the AWS, Azure, and Google Cloud builders is radically different in almost every way – from how they authenticate to how they look up marketplace images. </span><span class="koboSpan" id="kobo.426.2">There are some common fields and similarities, but they are very </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">different animals:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.428.1">
source "googlecompute" "vm" {
  project_id   = var.gcp_project_id
  source_image = "ubuntu-pro-2204-jammy-v20220923"
  ssh_username = "packer"
  zone         = var.gcp_primary_region
  image_name   = "${var.image_name}-${var.image_version}"
}</span></pre> <p><span class="koboSpan" id="kobo.429.1">The preceding code shows how we reference the Google Cloud marketplace version of the Ubuntu 22.04 VM. </span><span class="koboSpan" id="kobo.429.2">Notice how, unlike the other providers, which have rather complex lookup mechanisms, Google Cloud simply has a single string to represent the desired image. </span><span class="koboSpan" id="kobo.429.3">Each approach produces the same outcome: we select a marketplace image hosted by the</span><a id="_idIndexMarker1023"/><span class="koboSpan" id="kobo.430.1"> cloud platform to use as our boot disk, but we see different organizational philosophies manifesting in the three </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">differe</span><a id="_idTextAnchor593"/><span class="koboSpan" id="kobo.432.1">nt clouds.</span></span></p>
<h3><span class="koboSpan" id="kobo.433.1">Operating system configuration</span></h3>
<p><span class="koboSpan" id="kobo.434.1">We must configure the operating system so that it installs software dependencies (such as .NET 6.0), copies and </span><a id="_idIndexMarker1024"/><span class="koboSpan" id="kobo.435.1">deploys our application code’s deployment package to the correct location in the local filesystem, configures a Linux service that runs on boot, and sets a local user and group with necessary access for the service </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">to run.</span></span></p>
<p><span class="koboSpan" id="kobo.437.1">I expanded on these steps in detail in the corresponding section in </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.438.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.439.1">, so I encourage you to review this section if you want to refresh </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">y</span><a id="_idTextAnchor594"/><span class="koboSpan" id="kobo.441.1">our memory.</span></span></p>
<h2 id="_idParaDest-243"><a id="_idTextAnchor595"/><span class="koboSpan" id="kobo.442.1">Terraform</span></h2>
<p><span class="koboSpan" id="kobo.443.1">As we discussed in our</span><a id="_idIndexMarker1025"/><span class="koboSpan" id="kobo.444.1"> design, our solution is made up of two application components: the frontend and the backend. </span><span class="koboSpan" id="kobo.444.2">Each has a code base of application code that needs to be deployed. </span><span class="koboSpan" id="kobo.444.3">Since this is the first time we will be using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">google</span></strong><span class="koboSpan" id="kobo.446.1"> provider, we’ll look at basic provider setup and how to configure the backend before we consider the nuts and bolts of each component of </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">our a</span><a id="_idTextAnchor596"/><span class="koboSpan" id="kobo.448.1">rchitecture.</span></span></p>
<h3><span class="koboSpan" id="kobo.449.1">Provider setup</span></h3>
<p><span class="koboSpan" id="kobo.450.1">First, we need to specify all the </span><a id="_idIndexMarker1026"/><span class="koboSpan" id="kobo.451.1">providers that we</span><a id="_idIndexMarker1027"/><span class="koboSpan" id="kobo.452.1"> intend to use in this solution within the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">required_providers</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.454.1"> block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.455.1">
terraform {
  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "~&gt; 5.1.0"
    }
    cloudinit = {
      source  = "hashicorp/cloudinit"
      version = "~&gt; 2.3.2"
    }
    random = {
      source  = "hashicorp/random"
      version = "~&gt; 3.5.1"
    }
  }
  backend "gcs" {
  }
}</span></pre> <p><span class="koboSpan" id="kobo.456.1">We’ll also configure the Google Cloud provider. </span><span class="koboSpan" id="kobo.456.2">The Google Cloud provider, like Azure but unlike AWS, is not</span><a id="_idIndexMarker1028"/><span class="koboSpan" id="kobo.457.1"> scoped to a particular region. </span><span class="koboSpan" id="kobo.457.2">The Google Cloud provider doesn’t even need to be scoped to a</span><a id="_idIndexMarker1029"/><span class="koboSpan" id="kobo.458.1"> project. </span><span class="koboSpan" id="kobo.458.2">In this way, it is extremely flexible and can be used to provision cross-project and multi-region resources with the same </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">provider declaration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.460.1">
provider "google" {
  project = var.gcp_project
  region  = var.primary_region
}</span></pre> <p><span class="koboSpan" id="kobo.461.1">One major difference between the Google provider and the AWS and Azure providers is how you authenticate. </span><span class="koboSpan" id="kobo.461.2">While Azure and AWS have environment variables that specify the identity, the Google Cloud provider relies on an authentication file, so this will alter how our pipeline tools integrate with Terraform to ensure a Google Cloud solution has the right identity. </span><span class="koboSpan" id="kobo.461.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">GOOGLE_APPLICATION_CREDENTIALS</span></strong><span class="koboSpan" id="kobo.463.1"> environment variable specifies the path to this file. </span><span class="koboSpan" id="kobo.463.2">It is important to note that this file is a JSON file, but it contains secret information; therefore, it should be treated as a credential and pr</span><a id="_idTextAnchor597"/><span class="koboSpan" id="kobo.464.1">otected </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">as such.</span></span></p>
<h3><span class="koboSpan" id="kobo.466.1">Backend</span></h3>
<p><span class="koboSpan" id="kobo.467.1">Because we will be </span><a id="_idIndexMarker1030"/><span class="koboSpan" id="kobo.468.1">using a CI/CD pipeline to provision and maintain our environment in the long term, we need to set up a remote backend for our Terraform state. </span><span class="koboSpan" id="kobo.468.2">Because our solution will be hosted on Google Cloud, we’ll use the Google Cloud Storage backend to store our </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">Terraform state.</span></span></p>
<p><span class="koboSpan" id="kobo.470.1">Just like the Google Cloud provider, we don’t want to hard code the backend configuration in our code, so we’ll simply set up a placeholder for </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">the backend:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.472.1">
terraform {
  ...
</span><span class="koboSpan" id="kobo.472.2">  backend "gcs" {
  }
}</span></pre> <p><span class="koboSpan" id="kobo.473.1">We’ll configure the backend’s parameters using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">-backend-config</span></strong><span class="koboSpan" id="kobo.475.1"> parameters when we run </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">terraform init</span></strong><span class="koboSpan" id="kobo.477.1"> in ou</span><a id="_idTextAnchor598"/><span class="koboSpan" id="kobo.478.1">r </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">CI/CD pipeline.</span></span></p>
<h3><span class="koboSpan" id="kobo.480.1">Input variables</span></h3>
<p><span class="koboSpan" id="kobo.481.1">It’s good practice to pass in short names that identify the application’s name and the application’s environment. </span><span class="koboSpan" id="kobo.481.2">This </span><a id="_idIndexMarker1031"/><span class="koboSpan" id="kobo.482.1">allows you to embed consistent naming conventions across the resources that make up your solution, which makes it easier to identify and track resources from the Google </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">Cloud Console.</span></span></p>
<p><span class="koboSpan" id="kobo.484.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">primary_region</span></strong><span class="koboSpan" id="kobo.486.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">network_cidr_block</span></strong><span class="koboSpan" id="kobo.488.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">az_count</span></strong><span class="koboSpan" id="kobo.490.1"> input variables drive key architectural characteristics of the deployment. </span><span class="koboSpan" id="kobo.490.2">They mustn’t be hard-coded as this will limit the reusability of the Terraform </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.492.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">network_cidr_block</span></strong><span class="koboSpan" id="kobo.494.1"> input variable establishes the virtual network address space, which is often tightly regulated by an enterprise governance body. </span><span class="koboSpan" id="kobo.494.2">There is usually a process to ensure that teams across an organization do not use IP address ranges that conflict, thus making it impossible to allow those two applications to integrate in the future or integrate with shared network resources within </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">the enterprise.</span></span></p>
<p><span class="koboSpan" id="kobo.496.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">az_count</span></strong><span class="koboSpan" id="kobo.498.1"> input </span><a id="_idIndexMarker1032"/><span class="koboSpan" id="kobo.499.1">variable allows you to configure how much redundancy you want within our solution. </span><span class="koboSpan" id="kobo.499.2">This will affect the high availability of the solution but also the cost of the deployment. </span><span class="koboSpan" id="kobo.499.3">As you can imagine, cost is also a tightly regulated characteristic of cloud </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">infrastr</span><a id="_idTextAnchor599"/><span class="koboSpan" id="kobo.501.1">ucture deployments.</span></span></p>
<h3><span class="koboSpan" id="kobo.502.1">Consistent naming and tagging</span></h3>
<p><span class="koboSpan" id="kobo.503.1">Unlike the AWS console, and</span><a id="_idIndexMarker1033"/><span class="koboSpan" id="kobo.504.1"> very similar to Azure, Google Cloud is designed in such a way that it is extremely easy to get an application-centric view of your deployment through projects. </span><span class="koboSpan" id="kobo.504.2">Therefore, it’s not as important as an organizational strategy for your application to specify tags. </span><span class="koboSpan" id="kobo.504.3">By default, you will have a project-centric view of all the resources on </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">Google Cloud:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.506.1">
resource "google_compute_network" "main" {
  ...
</span><span class="koboSpan" id="kobo.506.2">  tags = {
    application = var.application_name
    environment = var.environment_name
  }
}</span></pre> <p><span class="koboSpan" id="kobo.507.1">It’s still important to tag the resources that you deploy that indicate what application and what environment they belong to. </span><span class="koboSpan" id="kobo.507.2">This helps with other reporting needs, such as budgets and compliance. </span><span class="koboSpan" id="kobo.507.3">Almost all resources within the Google Cloud provider have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">map</span></strong><span class="koboSpan" id="kobo.509.1"> attribute called </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">tags</span></strong><span class="koboSpan" id="kobo.511.1">. </span><span class="koboSpan" id="kobo.511.2">Like Azure, each resource usually has </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">name</span></strong><span class="koboSpan" id="kobo.513.1"> as a </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">required attribute.</span></span></p>
<h3><span class="koboSpan" id="kobo.515.1">Virtual network</span></h3>
<p><span class="koboSpan" id="kobo.516.1">Just as we did in </span><em class="italic"><span class="koboSpan" id="kobo.517.1">Chapters 7</span></em><span class="koboSpan" id="kobo.518.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.519.1">8</span></em><span class="koboSpan" id="kobo.520.1">, we need to construct a virtual network and keep its address space as tight as </span><a id="_idIndexMarker1034"/><span class="koboSpan" id="kobo.521.1">possible to avoid gobbling up unnecessary address space for the broader organization in </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">the future:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.523.1">
resource "google_compute_network" "main" {
  name                    = "${var.application_name}-${var.environment_name}"
  auto_create_subnetworks = false
}</span></pre> <p><span class="koboSpan" id="kobo.524.1">The network creation in Google Cloud is simpler than what we did with AWS because we don’t have to segment our subnets based on Availability Zone. </span><span class="koboSpan" id="kobo.524.2">This approach resembles how Azure structures subnets to span </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">Availability Zones:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.526.1">
resource "google_compute_subnetwork" "frontend" {
  name          = "frontend"
  region        = var.primary_region
  network       = google_compute_network.main.self_link
  ip_cidr_range = cidrsubnet(var.network_cidr_block, 2, 1)
}</span></pre> <h3><span class="koboSpan" id="kobo.527.1">Load balancing</span></h3>
<p><span class="koboSpan" id="kobo.528.1">As we discussed in the design, the Google Cloud Load Balancing service is structured quite a bit differently than </span><a id="_idIndexMarker1035"/><span class="koboSpan" id="kobo.529.1">AWS and Azure’s </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">equivalent offerings.</span></span></p>
<p><span class="koboSpan" id="kobo.531.1">The global forwarding rule acts as the main entry point for the global </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">load balancer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.533.1">
resource "google_compute_global_forwarding_rule" "frontend" { name = "my-forwarding-rule" ip_protocol = "TCP" port_range = "80" target = google_compute_target_http_proxy.http_proxy.self_link }</span></pre> <p><span class="koboSpan" id="kobo.534.1">It then references a target </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">HTTP proxy:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.536.1">
resource "google_compute_target_http_proxy" "http_proxy" {
  name    = "my-http-proxy"
  url_map = google_compute_url_map.url_map.self_link
}</span></pre> <p><span class="koboSpan" id="kobo.537.1">Subsequently, this</span><a id="_idIndexMarker1036"/><span class="koboSpan" id="kobo.538.1"> references a </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">URL map:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.540.1">
resource "google_compute_url_map" "url_map" {
  name            = "my-url-map"
  default_service = google_compute_backend_service.backend_service.self_link
}</span></pre> <p><span class="koboSpan" id="kobo.541.1">The URL map points to a backend service, which ultimately defines which Google Cloud services will be handling </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">the requests:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.543.1">
resource "google_compute_backend_service" "backend_service" {
  name        = "my-backend-service"
  port_name   = "http"
  protocol    = "HTTP"
  timeout_sec = 10
  dynamic "backend" {
    for_each = google_compute_instance_group.frontend
    content {
      group = backend.value.self_link
    }
  }
  health_checks = [google_compute_http_health_check.frontend.self_link]
}</span></pre> <p><span class="koboSpan" id="kobo.544.1">In the preceding code, you can see that we are connecting the backend to both a health check and the instance</span><a id="_idIndexMarker1037"/><span class="koboSpan" id="kobo.545.1"> group that contains the VMs that will ultimately be handling the </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">incoming requests:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.547.1">
resource "google_compute_http_health_check" "frontend" {
  name = "${var.application_name}-${var.environment_name}-hc"
  port         = 5000
  request_path = "/"
}</span></pre> <p><span class="koboSpan" id="kobo.548.1">The health check provides the configuration for the platform to determine if the backend service is healthy or not, with requests being sent to the health check endpoint on the corresponding backend service to determine if it is healthy enough to receive </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">incoming traffic.</span></span></p>
<h3><span class="koboSpan" id="kobo.550.1">Network security</span></h3>
<p><span class="koboSpan" id="kobo.551.1">First, we need to set up the logical firewall for each application architectural component. </span><span class="koboSpan" id="kobo.551.2">We’ll have </span><a id="_idIndexMarker1038"/><span class="koboSpan" id="kobo.552.1">one for the frontend and one for </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">the backend:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.554.1">
resource "google_compute_firewall" "default-hc-fw" {
  name    = "${var.application_name}-${var.environment_name}-hc"
  network = google_compute_network.main.self_link
  allow {
    protocol = "tcp"
    ports    = [5000]
  }
  source_ranges = ["130.211.0.0/22", "35.191.0.0/16"]
  target_tags   = ["allow-lb-service"]
}</span></pre> <p><span class="koboSpan" id="kobo.555.1">Google Cloud often has specific well-known IP addresses that need to be included in your firewall rules for</span><a id="_idIndexMarker1039"/><span class="koboSpan" id="kobo.556.1"> them to grant the necessary permissions to communicate </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">between services.</span></span></p>
<h3><span class="koboSpan" id="kobo.558.1">Secrets management</span></h3>
<p><span class="koboSpan" id="kobo.559.1">In </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.560.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.561.1">, we set up</span><a id="_idIndexMarker1040"/><span class="koboSpan" id="kobo.562.1"> secrets using AWS Secrets Manager and in </span><a href="B21183_08.xhtml#_idTextAnchor402"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.563.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.564.1">, we did the same with Key Vault on Microsoft Azure. </span><span class="koboSpan" id="kobo.564.2">As you might remember from </span><a href="B21183_08.xhtml#_idTextAnchor402"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.565.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.566.1">, Azure Key Vault is provisioned within a region. </span><span class="koboSpan" id="kobo.566.2">It’s within this context that secrets can be created. </span><span class="koboSpan" id="kobo.566.3">Google Cloud’s Secret Manager service works similarly to AWS in that there is no logical endpoint that needs to be provisioned where secrets are scoped within. </span><span class="koboSpan" id="kobo.566.4">The following code shows how to provision a secret within Google Cloud </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">Secret Manager:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.568.1">
resource "google_secret_manager_secret" "db_password" {
  secret_id = "db-password-secret"
  replication {
    automatic = true
  }
}</span></pre> <p><span class="koboSpan" id="kobo.569.1">This is a logical container for a secret that may have many different values over its life cycle as a result of regular </span><a id="_idIndexMarker1041"/><span class="koboSpan" id="kobo.570.1">secret rotation. </span><span class="koboSpan" id="kobo.570.2">The following code shows how we can define a specific version of </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">the secret:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.572.1">
resource "google_secret_manager_secret_version" "db_password_version" {
  secret      = google_secret_manager_secret.db_password.id
  secret_data = "abc1234"
}</span></pre> <p><span class="koboSpan" id="kobo.573.1">This might be a value that we pull in from other Google Cloud resources that we provision. </span><span class="koboSpan" id="kobo.573.2">The following code grants a service account access to our secrets within Google Cloud </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">Secret Manager:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.575.1">
resource "google_secret_manager_secret_iam_member" "secret_iam" {
  secret_id = "YOUR_SECRET_ID"
  role      = "roles/secretmanager.secretAccessor"
  member = "serviceAccount:YOUR_SERVICE_ACCOUNT_EMAIL"
}</span></pre> <h3><span class="koboSpan" id="kobo.576.1">VMs</span></h3>
<p><span class="koboSpan" id="kobo.577.1">When provisioning static VMs, we have much more control over the configuration of each machine. </span><span class="koboSpan" id="kobo.577.2">Some VMs </span><a id="_idIndexMarker1042"/><span class="koboSpan" id="kobo.578.1">have specific network and storage configurations to meet </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">workload demands.</span></span></p>
<p><span class="koboSpan" id="kobo.580.1">First, we’ll obtain the VM image from our input variables. </span><span class="koboSpan" id="kobo.580.2">This is the VM image that we built with Packer and provisioned into a different Google </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">Cloud project:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.582.1">
data "google_compute_image" "frontend" {
  name = var.frontend_image_name
}</span></pre> <p><span class="koboSpan" id="kobo.583.1">Next, we’ll create a VM using the Google Cloud instance. </span><span class="koboSpan" id="kobo.583.2">This resource will contain the network interface, disks, and </span><a id="_idIndexMarker1043"/><span class="koboSpan" id="kobo.584.1">service account configuration to set up our VM and connect it to the right subnetwork in our </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">virtual network:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.586.1">
resource "google_compute_instance" "frontend" {
  count = var.frontend_instance_count
  name         = "vm${var.application_name}-${var.environment_name}-frontend-${count.index}"
  machine_type = var.frontend_machine_type
  zone         = local.azs_random[count.index % 2]
  boot_disk {
    initialize_params {
      image = data.google_compute_image.frontend.self_link
    }
  }
  // Local SSD disk
  scratch_disk {
    interface = "NVME"
  }
  network_interface {
    subnetwork = google_compute_subnetwork.frontend.self_link
    access_config {
      // Ephemeral public IP
    }
  }
  service_account {
    # Google recommends custom service accounts that have cloud-platform scope and permissions granted via IAM Roles.
</span><span class="koboSpan" id="kobo.586.2">    email  = google_service_account.main.email
    scopes = ["cloud-platform"]
  }
  tags = ["ssh-access", "allow-lb-service"]
}</span></pre> <p><span class="koboSpan" id="kobo.587.1">Then, we’ll create the </span><a id="_idIndexMarker1044"/><span class="koboSpan" id="kobo.588.1">network interface for each VM by iterating over the </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">var.az_count</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.590.1">input variable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.591.1">
locals {
  zone_instances = { for z in local.azs_random : z =&gt;
    {
      instances = flatten([
        for i in google_compute_instance.frontend :
        i.zone == z ? </span><span class="koboSpan" id="kobo.591.2">[i.self_link] : []
      ])
    }
  }
}</span></pre> <p><span class="koboSpan" id="kobo.592.1">At this point, we can set</span><a id="_idIndexMarker1045"/><span class="koboSpan" id="kobo.593.1"> up instance groups for </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">each zone:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.595.1">
resource "google_compute_instance_group" "frontend" {
  count = var.az_count
  named_port {
    name = "http"
    port = 5000
  }
  name      = "frontend-${count.index}"
  zone      = local.azs_random[count.index]
  instances = local.zone_instances[local.azs_random[count.index]].instances
}</span></pre> <p><span class="koboSpan" id="kobo.596.1">Finally, we’ll set up the VM with all the necessary attributes before linking it to the network interface, the VM image, and the </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">managed identity.</span></span></p>
<p><span class="koboSpan" id="kobo.598.1">With that, we have implemented the Packer and Terraform solutions and have a working code base that will build VM images for both our frontend and backend application components and provision our cloud environment into Google Cloud. </span><span class="koboSpan" id="kobo.598.2">In the next section, we’ll dive into the YAML and Bash and implement the necessary GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">Actions workflows.</span></span></p>
<h1 id="_idParaDest-244"><a id="_idTextAnchor600"/><span class="koboSpan" id="kobo.600.1">Automating the deployment</span></h1>
<p><span class="koboSpan" id="kobo.601.1">As we discussed in our design, our solution is made up of two application components: the frontend and the </span><a id="_idIndexMarker1046"/><span class="koboSpan" id="kobo.602.1">backend. </span><span class="koboSpan" id="kobo.602.2">Each has a code base of application code and operating system configuration encapsulated within a Packer template. </span><span class="koboSpan" id="kobo.602.3">These two application components are then deployed into a cloud environment on Azure that is defined within our Terraform </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.604.1">Just as we did in </span><em class="italic"><span class="koboSpan" id="kobo.605.1">Chapters 7</span></em><span class="koboSpan" id="kobo.606.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.607.1">8</span></em><span class="koboSpan" id="kobo.608.1"> with the AWS and Azure solutions, there is an additional code base that we have to discuss: our automation pipelines on </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">GitHub Actions.</span></span></p>
<p><span class="koboSpan" id="kobo.610.1">In </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.611.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.612.1">, we went over the folder structure for our code base and where our GitHub Actions fit in so that we know that our automation pipelines are called workflows, and they’re stored in </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">/.github/workflows</span></strong><span class="koboSpan" id="kobo.614.1">. </span><span class="koboSpan" id="kobo.614.2">Each of our code bases is stored in its respective folder. </span><span class="koboSpan" id="kobo.614.3">Our solutions source code repository’s folder structure will look </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">like this:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">github</span></strong></span><ul><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">workflows</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">dotnet</span></strong></span><ul><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">backend</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">frontend</span></strong></span></li></ul></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">packer</span></strong></span><ul><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">backend</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">frontend</span></strong></span></li></ul></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">terraform</span></strong></span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.626.1">As per our design, we will have GitHub Actions workflows that will execute Packer and build VM images for </span><a id="_idIndexMarker1047"/><span class="koboSpan" id="kobo.627.1">both the frontend (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">packer-frontend.yaml</span></strong><span class="koboSpan" id="kobo.629.1">) and the backend (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">packer-backend.yaml</span></strong><span class="koboSpan" id="kobo.631.1">). </span><span class="koboSpan" id="kobo.631.2">We’ll also have workflows that will run </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">terraform plan</span></strong><span class="koboSpan" id="kobo.633.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">terraform apply</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">github</span></strong></span><ul><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">workflows</span></strong></span><ul><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">packer-backend.yaml</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">packer-frontend.yaml</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">terraform-apply.yaml</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">terraform-plan.yaml</span></strong></span></li></ul></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.643.1">In </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.644.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.645.1">, we covered the GitFlow process and how it interacts with our GitHub Actions workflows in greater detail. </span><span class="koboSpan" id="kobo.645.2">So, for now, let’s dig into how these pipelines will differ when targeting the </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">Azure platform.</span></span></p>
<h2 id="_idParaDest-245"><a id="_idTextAnchor601"/><span class="koboSpan" id="kobo.647.1">Packer</span></h2>
<p><span class="koboSpan" id="kobo.648.1">In </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.649.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.650.1">, we covered each </span><a id="_idIndexMarker1048"/><span class="koboSpan" id="kobo.651.1">step of the GitHub Actions workflow that executes Packer to build VM images. </span><span class="koboSpan" id="kobo.651.2">Thanks to the nature of Packer’s cloud-agnostic architecture, this overwhelmingly stays the same. </span><span class="koboSpan" id="kobo.651.3">The only thing that changes is the final step where we </span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">execute Packer.</span></span></p>
<p><span class="koboSpan" id="kobo.653.1">Because Packer needs to be configured to build a VM on Google Cloud, we need to pass in different input variables that are Google Cloud-specific. </span><span class="koboSpan" id="kobo.653.2">This includes the file path to the Google Cloud credential file, a Google Cloud region, and a Google Cloud </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">project ID.</span></span></p>
<p><span class="koboSpan" id="kobo.655.1">Just as we did with the input variables for the Packer template for AWS, we must ensure that all Google Cloud input variables are prefixed with </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">gcp_</span></strong><span class="koboSpan" id="kobo.657.1">. </span><span class="koboSpan" id="kobo.657.2">This will help if we ever want to introduce multi-targeting as many cloud platforms will have similar required inputs, such as target region and VM size. </span><span class="koboSpan" id="kobo.657.3">While most clouds will have similar required inputs, the input values are </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">not interchangeable.</span></span></p>
<p><span class="koboSpan" id="kobo.659.1">For example, each cloud</span><a id="_idIndexMarker1049"/><span class="koboSpan" id="kobo.660.1"> platform will require you to specify the region that you want Packer to provide the temporary VM into and the resulting VM image to be stored. </span><span class="koboSpan" id="kobo.660.2">On Google Cloud, the region has a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">us-west2-a</span></strong><span class="koboSpan" id="kobo.662.1">, as we saw with Azure and AWS, and each cloud platform will have infuriatingly similar and slightly different </span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">region names.</span></span></p>
<p><span class="koboSpan" id="kobo.664.1">Google Cloud does have a major difference in the way credentials are usually specified. </span><span class="koboSpan" id="kobo.664.2">Whereas AWS and Azure </span><a id="_idIndexMarker1050"/><span class="koboSpan" id="kobo.665.1">usually have particular environment variables that will house context and credentials, Google Cloud uses a file. </span><span class="koboSpan" id="kobo.665.2">As a result, before we run Packer, we need to ensure that the Google Cloud secret file has been dropped at a well-known location so that our Packer action can pick </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">it up:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.667.1">
- name: Create Secret File
  env:
    GOOGLE_APPLICATION_CREDENTIALS: ${{ secrets.GOOGLE_APPLICATION_CREDENTIALS }}
  working-directory: ${{ env.WORKING_DIRECTORY }}
  run: |
    # Create a local file with the secret value
    echo -n "$GOOGLE_APPLICATION_CREDENTIALS" &gt; gcp.json</span></pre> <p><span class="koboSpan" id="kobo.668.1">The GitHub Actions workflow YAML files are identical for Google Cloud, except for the use of a single input variable that is needed to specify the path to the credential file – that </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">is, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">gcp.json</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.672.1">
- id: build
  name: Packer Build
  env:
    GOOGLE_APPLICATION_CREDENTIALS: "gcp.json"
    PKR_VAR_gcp_project_id: ${{ vars.GOOGLE_PROJECT }}
    PKR_VAR_image_version: ${{ steps.image-version.outputs.version }}
    PKR_VAR_agent_ipaddress: ${{ steps.agent-ipaddress.outputs.ipaddress }}
  working-directory: ${{ env.WORKING_DIRECTORY }}
  run: |
    packer init ./
    packer build -var-file=variables.pkrvars.hcl ./</span></pre> <p><span class="koboSpan" id="kobo.673.1">The preceding code</span><a id="_idIndexMarker1051"/><span class="koboSpan" id="kobo.674.1"> references the secret file we created from the GitHub Actions secret. </span><span class="koboSpan" id="kobo.674.2">The Google Cloud plugin for Packer will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">GOOGLE_APPLICATION_CREDENTIALS</span></strong><span class="koboSpan" id="kobo.676.1"> environment variable to load the secret file so that it can authenticate with </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">Google Cloud.</span></span></p>
<h2 id="_idParaDest-246"><a id="_idTextAnchor602"/><span class="koboSpan" id="kobo.678.1">Terraform</span></h2>
<p><span class="koboSpan" id="kobo.679.1">With both of our VM images built and their versions input into our </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">.tfvars</span></strong><span class="koboSpan" id="kobo.681.1"> file, our Terraform automation pipeline is ready to take the reigns and not only provision our environment but deploy our solution as well (although not technically). </span><span class="koboSpan" id="kobo.681.2">The deployment was technically done within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">packer build</span></strong><span class="koboSpan" id="kobo.683.1"> process, with the physical deployment packages being </span><a id="_idIndexMarker1052"/><span class="koboSpan" id="kobo.684.1">copied to the home directory and the Linux service setup primed and ready. </span><span class="koboSpan" id="kobo.684.2">Terraform is finishing the job by actually launching VMs using </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">these images.</span></span></p>
<p><span class="koboSpan" id="kobo.686.1">In </span><a href="B21183_07.xhtml#_idTextAnchor365"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.687.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.688.1">, we covered each step of the GitHub Actions workflow that executes Terraform to provision the cloud environment and deploy the application code. </span><span class="koboSpan" id="kobo.688.2">Thanks to the nature of Terraform’s cloud-agnostic architecture, this overwhelmingly stays the same. </span><span class="koboSpan" id="kobo.688.3">The only thing that changes is the final step where we </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">execute Terraform.</span></span></p>
<p><span class="koboSpan" id="kobo.690.1">Just like we did in </span><em class="italic"><span class="koboSpan" id="kobo.691.1">Chapters 7</span></em><span class="koboSpan" id="kobo.692.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.693.1">8</span></em><span class="koboSpan" id="kobo.694.1"> with the AWS and Azure providers, we need to set the authentication context using environment variables that are specific to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">google</span></strong><span class="koboSpan" id="kobo.696.1"> provider. </span><span class="koboSpan" id="kobo.696.2">In this case, the single </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">GOOGLE_APPLICATION_CREDENTIALS</span></strong><span class="koboSpan" id="kobo.698.1"> attribute is passed to connect the provider with how it should authenticate with Terraform to provision </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">the environment:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.700.1">
- name: Create Secret File for Terraform
  env:
    GOOGLE_APPLICATION_CREDENTIALS: ${{ secrets.GOOGLE_APPLICATION_CREDENTIALS }}
  working-directory: ${{ env.WORKING_DIRECTORY }}
  run: |
    # Create a local file with the secret value
    echo -n "$GOOGLE_APPLICATION_CREDENTIALS" &gt; gcp-terraform.json</span></pre> <p><span class="koboSpan" id="kobo.701.1">The preceding code </span><a id="_idIndexMarker1053"/><span class="koboSpan" id="kobo.702.1">generates the necessary secret file for Terraform to authenticate with Google Cloud to provision </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">the environment.</span></span></p>
<p><span class="koboSpan" id="kobo.704.1">Just like we did in </span><em class="italic"><span class="koboSpan" id="kobo.705.1">Chapters 7</span></em><span class="koboSpan" id="kobo.706.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.707.1">8</span></em><span class="koboSpan" id="kobo.708.1"> with the AWS and Azure providers, we need to configure the Google-Cloud-specific backend that stores the Terraform state by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">-backend-config</span></strong><span class="koboSpan" id="kobo.710.1"> command-line arguments alongside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">terraform init</span></strong><span class="koboSpan" id="kobo.712.1"> command. </span><span class="koboSpan" id="kobo.712.2">The additional </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">GOOGLE_BACKEND_CREDENTIALS</span></strong><span class="koboSpan" id="kobo.714.1"> argument informs Terraform how to authenticate with the Google Cloud Storage backend that we are using to store the </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">Terraform state:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.716.1">
- name: Create Secret File for Backend
  env:
    GOOGLE_BACKEND_CREDENTIALS: ${{ secrets.GOOGLE_BACKEND_CREDENTIALS }}
  working-directory: ${{ env.WORKING_DIRECTORY }}
  run: |
    # Create a local file with the secret value
    echo -n "$GOOGLE_BACKEND_CREDENTIALS" &gt; gcp-backend.json</span></pre> <p><span class="koboSpan" id="kobo.717.1">The preceding code generates</span><a id="_idIndexMarker1054"/><span class="koboSpan" id="kobo.718.1"> the necessary secret file for Terraform to authenticate with Google Cloud so that it can store and retrieve the Terraform state for </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">the environment.</span></span></p>
<p><span class="koboSpan" id="kobo.720.1">Unlike with the AWS and Azure providers – and highlighting how significantly the Terraform backend implementations can diverge – the backend uses a </span><em class="italic"><span class="koboSpan" id="kobo.721.1">prefix</span></em><span class="koboSpan" id="kobo.722.1"> and the Terraform workspace </span><a id="_idIndexMarker1055"/><span class="koboSpan" id="kobo.723.1">name to uniquely identify the location to store </span><span class="No-Break"><span class="koboSpan" id="kobo.724.1">state files:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.725.1">
- id: plan
  name: Terraform Apply
  env:
    GOOGLE_BACKEND_CREDENTIALS: gcp-backend.json
    GOOGLE_APPLICATION_CREDENTIALS: gcp-terraform.json
    BACKEND_BUCKET_NAME: ${{ vars.BACKEND_BUCKET_NAME }}
    TF_VAR_gcp_project: ${{ vars.GOOGLE_PROJECT }}
  working-directory: ${{ env.WORKING_DIRECTORY }}
  run: |
    terraform init \
      -backend-config='bucket='$BACKEND_BUCKET_NAME \
      -backend-config="prefix=gcp-vm-sample"
    terraform apply -auto-approve</span></pre> <p><span class="koboSpan" id="kobo.726.1">Notice how, like with the Azure solution, we don’t need to perform a targeted </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">terraform apply</span></strong><span class="koboSpan" id="kobo.728.1"> command. </span><span class="koboSpan" id="kobo.728.2">This is because we don’t need to do dynamic calculations based on the number of Availability Zones in the region to configure our </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">virtual network.</span></span></p>
<p><span class="koboSpan" id="kobo.730.1">These subtle architectural differences between the cloud platforms can create radical structural changes, even when we’re deploying the same solution using the same technologies. </span><span class="koboSpan" id="kobo.730.2">It is a sobering reminder that while knowledge of the core concepts we looked at in </span><em class="italic"><span class="koboSpan" id="kobo.731.1">Chapters 4</span></em><span class="koboSpan" id="kobo.732.1"> through </span><em class="italic"><span class="koboSpan" id="kobo.733.1">6</span></em><span class="koboSpan" id="kobo.734.1"> will help us transcend to a multi-cloud point of view, to implement practical solutions, we need to under</span><a id="_idTextAnchor603"/><span class="koboSpan" id="kobo.735.1">stand the subtle nuances of </span><span class="No-Break"><span class="koboSpan" id="kobo.736.1">each platform.</span></span></p>
<h1 id="_idParaDest-247"><a id="_idTextAnchor604"/><span class="koboSpan" id="kobo.737.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.738.1">In this chapter, we built a multi-tier cloud architecture using VMs powered by Google Cloud Compute Engine with a fully operation GitFlow process and an end-to-end CI/CD pipeline using </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">GitHub Actions.</span></span></p>
<p><span class="koboSpan" id="kobo.740.1">In the next chapter, our fearless leader at Söze Enterprises will be throwing us into turmoil with some big new ideas, and we’ll have to respond to his call to action. </span><span class="koboSpan" id="kobo.740.2">It turns out our CEO, Keyser, has been up late watching some YouTube videos about the next big thing – containers – and after talking with his pal Sundar on his superyacht, he has decided that we need to refactor our whole solution so that it can run on Docker and Kubernetes. </span><span class="koboSpan" id="kobo.740.3">Luckily, the good people at Google have a service that might help us out: </span><strong class="bold"><span class="koboSpan" id="kobo.741.1">Google Kubernetes </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.742.1">Engine</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.743.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.744.1">GKE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">).</span></span></p>
</div>
</body></html>