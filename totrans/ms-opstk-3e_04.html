<html><head></head><body>
  <div id="_idContainer065">
   <h1 class="chapter-number" id="_idParaDest-80">
    <a id="_idTextAnchor125">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     4
    </span>
   </h1>
   <h1 id="_idParaDest-81">
    <a id="_idTextAnchor126">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     OpenStack Compute – Compute Capacity and Flavors
    </span>
   </h1>
   <p class="author-quote">
    <span class="koboSpan" id="kobo.3.1">
     “Magic is believing in yourself.
    </span>
    <span class="koboSpan" id="kobo.3.2">
     If you can do that, you can make anything happen.”
    </span>
   </p>
   <p class="author-quote">
    <span class="koboSpan" id="kobo.4.1">
     – Johann Wolfgang von Goethe
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     As a private cloud provider, typical OpenStack IaaS services are the building blocks of its offering to end users.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     At the heart of the IaaS offerings is the compute service that runs and manages the workload life cycle in different facets.
    </span>
    <span class="koboSpan" id="kobo.5.3">
     The OpenStack Foundation has committed to enlarging the scope of the OpenStack ecosystem and exposing new services by tailoring the Nova service in different ways.
    </span>
    <span class="koboSpan" id="kobo.5.4">
     Additional new trending projects such as managed elastic data
    </span>
    <a id="_idIndexMarker354">
    </a>
    <span class="koboSpan" id="kobo.6.1">
     processing (code-named
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.7.1">
      Sahara
     </span>
    </strong>
    <span class="koboSpan" id="kobo.8.1">
     ), managed databases (code-named
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.9.1">
      Trove
     </span>
    </strong>
    <span class="koboSpan" id="kobo.10.1">
     ), and a
    </span>
    <a id="_idIndexMarker355">
    </a>
    <span class="koboSpan" id="kobo.11.1">
     container application catalog (code-named
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.12.1">
      Murano
     </span>
    </strong>
    <span class="koboSpan" id="kobo.13.1">
     ) are examples
    </span>
    <a id="_idIndexMarker356">
    </a>
    <span class="koboSpan" id="kobo.14.1">
     of services that are offered on top of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.15.1">
      Nova service.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.16.1">
     As a cloud operator, having a solid understanding of the compute farm capabilities and the different segregation methods within the OpenStack environment is a foundational requirement to run a successful private cloud journey with the desired service offerings.
    </span>
    <span class="koboSpan" id="kobo.16.2">
     At the time of writing this edition, the Nova service had some updates, in addition to the emergence of more pertinent features and services around it.
    </span>
    <span class="koboSpan" id="kobo.16.3">
     To ensure a safe compute design update based on the draft elaborated on in the first chapter, it will be necessary to run through the new compute service that came out with the latest OpenStack releases starting from the Antelope release.
    </span>
    <span class="koboSpan" id="kobo.16.4">
     In this chapter, we will go through the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.17.1">
      following topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.18.1">
      Revisiting the Nova compute service from an
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.19.1">
       architecture perspective
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.20.1">
      Checking out the latest hypervisors supported by the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.21.1">
       compute service
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.22.1">
      Exploring the concept of compute segregation for massive OpenStack
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.23.1">
       compute deployment
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.24.1">
      Demystifying the art of filtering to construct advanced ways of performing compute resource allocations and hosting workloads based on an array
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.25.1">
       of strategies
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.26.1">
      Discussing the
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.27.1">
       Container Orchestration Engines
      </span>
     </strong>
     <span class="koboSpan" id="kobo.28.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.29.1">
       COEs
      </span>
     </strong>
     <span class="koboSpan" id="kobo.30.1">
      ) and their integration
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.31.1">
       with Magnum
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.32.1">
      Learning how to manage
     </span>
     <a id="_idIndexMarker357">
     </a>
     <span class="koboSpan" id="kobo.33.1">
      and operate containers in the most flexible way with the new, trending Zun OpenStack
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.34.1">
       container service
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.35.1">
      Configuring and deploying new compute nodes in a running OpenStack environment using Kolla-Ansible infrastructure as a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.36.1">
       code paradigm
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-82">
    <a id="_idTextAnchor127">
    </a>
    <span class="koboSpan" id="kobo.37.1">
     The compute service components
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.38.1">
     The compute
    </span>
    <a id="_idIndexMarker358">
    </a>
    <span class="koboSpan" id="kobo.39.1">
     service is composed of multiple components that take care of incoming compute requests and then launch and manage instances, as depicted in the following diagram showing the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.40.1">
      Nova architecture:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer053">
     <span class="koboSpan" id="kobo.41.1">
      <img alt="Figure 4.1 – The Nova component architecture" src="image/B21716_04_01.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.42.1">
     Figure 4.1 – The Nova component architecture
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.43.1">
     Let’s explore each compute component in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.44.1">
      following section.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-83">
    <a id="_idTextAnchor128">
    </a>
    <span class="koboSpan" id="kobo.45.1">
     API
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.46.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.47.1">
      nova-api
     </span>
    </strong>
    <span class="koboSpan" id="kobo.48.1">
     component deals with different (HTTP-based) requests via the queuing message service.
    </span>
    <span class="koboSpan" id="kobo.48.2">
     Keep in
    </span>
    <a id="_idIndexMarker359">
    </a>
    <span class="koboSpan" id="kobo.49.1">
     mind that the API is the first interface that accepts compute requests before forwarding them to the next Nova component and establishing a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.50.1">
      complete workflow.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-84">
    <a id="_idTextAnchor129">
    </a>
    <span class="koboSpan" id="kobo.51.1">
     Scheduler
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.52.1">
     The next station in the Nova
    </span>
    <a id="_idIndexMarker360">
    </a>
    <span class="koboSpan" id="kobo.53.1">
     workflow abstraction layer is the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.54.1">
      nova-scheduler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.55.1">
     component.
    </span>
    <span class="koboSpan" id="kobo.55.2">
     It is a major piece of the workflow that decides in which compute node each incoming instance creation request
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.56.1">
      will run.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.57.1">
     The scheduler component uses a variety of filters and preferences that can be customized to match different needs and reasoning for the availability of the existing resources.
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.58.1">
      Filtering
     </span>
    </strong>
    <span class="koboSpan" id="kobo.59.1">
     and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.60.1">
      weighting
     </span>
    </strong>
    <span class="koboSpan" id="kobo.61.1">
     are the main
    </span>
    <a id="_idIndexMarker361">
    </a>
    <span class="koboSpan" id="kobo.62.1">
     mechanisms used by the Nova scheduler in
    </span>
    <a id="_idIndexMarker362">
    </a>
    <span class="koboSpan" id="kobo.63.1">
     order to customize the allocation of underlying physical resources.
    </span>
    <span class="koboSpan" id="kobo.63.2">
     This chapter will break down the newly added filters and weighting references in the Antelope and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.64.1">
      later releases.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-85">
    <a id="_idTextAnchor130">
    </a>
    <span class="koboSpan" id="kobo.65.1">
     Conductor
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.66.1">
     Once a request is dealt with via the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.67.1">
      nova-scheduler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.68.1">
     process, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.69.1">
      nova-conductor
     </span>
    </strong>
    <span class="koboSpan" id="kobo.70.1">
     component will make sure that the reservation made in the physical host is saved in the shared database.
    </span>
    <span class="koboSpan" id="kobo.70.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.71.1">
      nova-scheduler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.72.1">
     process will be required to check the database beforehand and verify the available capacity before making a scheduling decision.
    </span>
    <span class="koboSpan" id="kobo.72.2">
     The conductor component is a major addition to the Nova workflow compared to the
    </span>
    <a id="_idIndexMarker363">
    </a>
    <span class="koboSpan" id="kobo.73.1">
     earlier releases of the Nova project in the OpenStack ecosystem.
    </span>
    <span class="koboSpan" id="kobo.73.2">
     As a brief reminder from the previous edition, the conductor comes with a security improvement, preventing the compute nodes from having direct access to the database.
    </span>
    <span class="koboSpan" id="kobo.73.3">
     In earlier versions, the compute nodes would update their status directly in the database shared between them.
    </span>
    <span class="koboSpan" id="kobo.73.4">
     That would reduce the blast radius of a possible security gap on the database level if one of the physical machines was compromised.
    </span>
    <span class="koboSpan" id="kobo.73.5">
     Nowadays, the conductor takes on that responsibility on its own.
    </span>
    <span class="koboSpan" id="kobo.73.6">
     Another great addition of the conductor component is dedicated operations dealing with the compute nodes, such as resizing, building,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.74.1">
      and migration.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.75.1">
     By having those capabilities in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.76.1">
      nova-conductor
     </span>
    </strong>
    <span class="koboSpan" id="kobo.77.1">
     , the compute nodes will act as simple worker nodes, leaving
    </span>
    <a id="_idIndexMarker364">
    </a>
    <span class="koboSpan" id="kobo.78.1">
     coordination and any database operations to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.79.1">
      conductor process.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-86">
    <a id="_idTextAnchor131">
    </a>
    <span class="koboSpan" id="kobo.80.1">
     Compute
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.81.1">
     Coming to the end of the Nova workflow, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.82.1">
      nova-compute
     </span>
    </strong>
    <span class="koboSpan" id="kobo.83.1">
     component will take the rest of the requests by dealing with the hypervisor.
    </span>
    <span class="koboSpan" id="kobo.83.2">
     The addition of a variety of features for different supported hypervisors in the OpenStack compute core makes almost every new release more exciting than the previous one.
    </span>
    <span class="koboSpan" id="kobo.83.3">
     Libvirt KVM, VMware vSphere, XenServer, XenAPI, Microsoft HyperV,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.84.1">
      Linux Containers
     </span>
    </strong>
    <span class="koboSpan" id="kobo.85.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.86.1">
      LXC
     </span>
    </strong>
    <span class="koboSpan" id="kobo.87.1">
     ), Quick Emulator, and a few others are supported by the Nova service.
    </span>
    <span class="koboSpan" id="kobo.87.2">
     The
    </span>
    <a id="_idIndexMarker365">
    </a>
    <span class="koboSpan" id="kobo.88.1">
     most exciting part is the continuous development and integration
    </span>
    <a id="_idIndexMarker366">
    </a>
    <span class="koboSpan" id="kobo.89.1">
     of each hypervisor feature by the vendors who own the hypervisor project.
    </span>
    <span class="koboSpan" id="kobo.89.2">
     This chapter will illustrate more details of those hypervisors and highlight a few common architectural
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.90.1">
      compute layouts.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-87">
    <a id="_idTextAnchor132">
    </a>
    <span class="koboSpan" id="kobo.91.1">
     Console access
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.92.1">
     Access to virtual machines through OpenStack Horizon (dashboard) or via the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.93.1">
      Command-Line Interface
     </span>
    </strong>
    <span class="koboSpan" id="kobo.94.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.95.1">
      CLI
     </span>
    </strong>
    <span class="koboSpan" id="kobo.96.1">
     ) is well developed
    </span>
    <a id="_idIndexMarker367">
    </a>
    <span class="koboSpan" id="kobo.97.1">
     by the OpenStack community in different iterations.
    </span>
    <span class="koboSpan" id="kobo.97.2">
     Console access is not a
    </span>
    <a id="_idIndexMarker368">
    </a>
    <span class="koboSpan" id="kobo.98.1">
     required component to run a fully working Nova service but is an additional aspect to interact with provisioned guests.
    </span>
    <span class="koboSpan" id="kobo.98.2">
     Until the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.99.1">
      Liberty
     </span>
    </em>
    <span class="koboSpan" id="kobo.100.1">
     release,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.101.1">
      nova-console
     </span>
    </strong>
    <span class="koboSpan" id="kobo.102.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.103.1">
      nova-novncproxy
     </span>
    </strong>
    <span class="koboSpan" id="kobo.104.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.105.1">
      nova-consoleauth
     </span>
    </strong>
    <span class="koboSpan" id="kobo.106.1">
     were mainly counted as the most stable console types.
    </span>
    <span class="koboSpan" id="kobo.106.2">
     Now, with the Antelope and later releases, more console types have joined the list, such as the SPICE console and serial console as an alternative graphical console extension.
    </span>
    <span class="koboSpan" id="kobo.106.3">
     Microsoft has also contributed to the console service with
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.107.1">
      Remote Desktop Protocol
     </span>
    </strong>
    <span class="koboSpan" id="kobo.108.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.109.1">
      RDP
     </span>
    </strong>
    <span class="koboSpan" id="kobo.110.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.110.2">
     However, the latter comes with
    </span>
    <a id="_idIndexMarker369">
    </a>
    <span class="koboSpan" id="kobo.111.1">
     a limitation as it supports only Hyper-V and requires integration with the console proxy in OpenStack, which has not been developed.
    </span>
    <span class="koboSpan" id="kobo.111.2">
     Hence, a third-party tool should be available along with the console configuration, such as the FreeRDP-WebConnect application, which can be found on GitHub.
    </span>
    <span class="koboSpan" id="kobo.111.3">
     Like Microsoft RDP, VMware has also contributed with another console type,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.112.1">
      Mouse, Keyboard, Mouse
     </span>
    </strong>
    <span class="koboSpan" id="kobo.113.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.114.1">
      MKM
     </span>
    </strong>
    <span class="koboSpan" id="kobo.115.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.115.2">
     This is bound to a virtual machine’s access console based on Vmware’s vSphere
    </span>
    <a id="_idIndexMarker370">
    </a>
    <span class="koboSpan" id="kobo.116.1">
     Hypervisor, but independently of an existing console proxy service in OpenStack.
    </span>
    <span class="koboSpan" id="kobo.116.2">
     With this growing list in the latest releases, one console-supported service has been deprecated since the Train release, which
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.117.1">
      is
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.118.1">
       nova-consoleauth
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.119.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.120.1">
     The associated Nova API services, including
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.121.1">
      nova-scheduler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.122.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.123.1">
      nova-conductor
     </span>
    </strong>
    <span class="koboSpan" id="kobo.124.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.125.1">
      nova-api
     </span>
    </strong>
    <span class="koboSpan" id="kobo.126.1">
     , run as part of the controller nodes, and the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.127.1">
      nova-compute
     </span>
    </strong>
    <span class="koboSpan" id="kobo.128.1">
     service runs on each compute node.
    </span>
    <span class="koboSpan" id="kobo.128.2">
     Running
    </span>
    <a id="_idIndexMarker371">
    </a>
    <span class="koboSpan" id="kobo.129.1">
     the Nova compute service is based on the hardware platform and the selected hypervisor, which will be covered in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.130.1">
      next section.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-88">
    <a id="_idTextAnchor133">
    </a>
    <span class="koboSpan" id="kobo.131.1">
     Reasoning for the hypervisors
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.132.1">
     By navigating through the different OpenStack releases, Nova supports a range of
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.133.1">
      Virtual Machine Monitors
     </span>
    </strong>
    <span class="koboSpan" id="kobo.134.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.135.1">
      VMMs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.136.1">
     ), also known as
    </span>
    <a id="_idIndexMarker372">
    </a>
    <span class="koboSpan" id="kobo.137.1">
     hypervisors.
    </span>
    <span class="koboSpan" id="kobo.137.2">
     Hypervisor software allows access to the physical
    </span>
    <a id="_idIndexMarker373">
    </a>
    <span class="koboSpan" id="kobo.138.1">
     machine hardware resources and provides different functions to create and manage virtual machines within a compute node.
    </span>
    <span class="koboSpan" id="kobo.138.2">
     At the time of writing this book, the latest OpenStack releases including the Dalmatian release
    </span>
    <a id="_idIndexMarker374">
    </a>
    <span class="koboSpan" id="kobo.139.1">
     support
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.140.1">
      Kernel Virtual Machine
     </span>
    </strong>
    <span class="koboSpan" id="kobo.141.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.142.1">
      KVM
     </span>
    </strong>
    <span class="koboSpan" id="kobo.143.1">
     ),
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.144.1">
      LXC
     </span>
    </strong>
    <span class="koboSpan" id="kobo.145.1">
     ,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.146.1">
      QEMU
     </span>
    </strong>
    <span class="koboSpan" id="kobo.147.1">
     ,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.148.1">
      VMware vSphere
     </span>
    </strong>
    <span class="koboSpan" id="kobo.149.1">
     (5.1.0 and later versions),
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.150.1">
      zVM
     </span>
    </strong>
    <span class="koboSpan" id="kobo.151.1">
     ,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.152.1">
      Ironic
     </span>
    </strong>
    <span class="koboSpan" id="kobo.153.1">
     (native OpenStack
    </span>
    <a id="_idIndexMarker375">
    </a>
    <span class="koboSpan" id="kobo.154.1">
     bare metal),
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.155.1">
      Hyper-V,
     </span>
    </strong>
    <span class="koboSpan" id="kobo.156.1">
     and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.157.1">
      Virtuozzo
     </span>
    </strong>
    <span class="koboSpan" id="kobo.158.1">
     (7.0.0 and later versions).
    </span>
    <span class="koboSpan" id="kobo.158.2">
     The different features and
    </span>
    <a id="_idIndexMarker376">
    </a>
    <span class="koboSpan" id="kobo.159.1">
     virtual machine management capabilities differ from one hypervisor to another.
    </span>
    <span class="koboSpan" id="kobo.159.2">
     A full list of supported features per hypervisor can be found in the official hypervisor support matrix, which is available at
    </span>
    <a href="https://docs.openstack.org/nova/latest/user/support-matrix.html">
     <span class="koboSpan" id="kobo.160.1">
      https://docs.openstack.org/nova/latest/user/support-matrix.html
     </span>
    </a>
    <span class="koboSpan" id="kobo.161.1">
     .
    </span>
    <span class="koboSpan" id="kobo.161.2">
     Make sure to parse each of the provided features based on your requirements and needs.
    </span>
    <span class="koboSpan" id="kobo.161.3">
     KVM is the most used hypervisor in the OpenStack
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.162.1">
      nova-compute
     </span>
    </strong>
    <span class="koboSpan" id="kobo.163.1">
     setup due to its early adoption and having the largest set of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.164.1">
      supported features.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.165.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.166.1">
     Other famous
    </span>
    <a id="_idIndexMarker377">
    </a>
    <span class="koboSpan" id="kobo.167.1">
     hypervisors such as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.168.1">
      Xen
     </span>
    </strong>
    <span class="koboSpan" id="kobo.169.1">
     ,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.170.1">
      XCP
     </span>
    </strong>
    <span class="koboSpan" id="kobo.171.1">
     ,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.172.1">
      UML
     </span>
    </strong>
    <span class="koboSpan" id="kobo.173.1">
     , and the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.174.1">
      Docker
     </span>
    </strong>
    <span class="koboSpan" id="kobo.175.1">
     driver are not listed in the latest
    </span>
    <a id="_idIndexMarker378">
    </a>
    <span class="koboSpan" id="kobo.176.1">
     OpenStack releases, including
    </span>
    <a id="_idIndexMarker379">
    </a>
    <span class="koboSpan" id="kobo.177.1">
     Antelope and Bobcat (released in October 2023).
    </span>
    <span class="koboSpan" id="kobo.177.2">
     The
    </span>
    <a id="_idIndexMarker380">
    </a>
    <span class="koboSpan" id="kobo.178.1">
     Docker driver has been supported since the Havana release and moved to its own project, code-named the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.179.1">
      Zun
     </span>
    </strong>
    <span class="koboSpan" id="kobo.180.1">
     project, which will be covered later in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.181.1">
      this chapter.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.182.1">
     The Nova compute service uses
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.183.1">
      Virt Driver
     </span>
    </strong>
    <span class="koboSpan" id="kobo.184.1">
     to interact with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.185.1">
      Libvirt
     </span>
    </strong>
    <span class="koboSpan" id="kobo.186.1">
     library via API calls and manages
    </span>
    <a id="_idIndexMarker381">
    </a>
    <span class="koboSpan" id="kobo.187.1">
     virtual machines through the hypervisor, as illustrated in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.188.1">
      following diagram:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer054">
     <span class="koboSpan" id="kobo.189.1">
      <img alt="Figure 4.2 – The Nova compute-supported hypervisors" src="image/B21716_04_02.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.190.1">
     Figure 4.2 – The Nova compute-supported hypervisors
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.191.1">
     The configuration of the hypervisor backend in Nova can be performed by adjusting the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.192.1">
      compute_driver
     </span>
    </strong>
    <span class="koboSpan" id="kobo.193.1">
     option in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.194.1">
      /
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.195.1">
       etc/nova/nova.conf
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.196.1">
      file.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.197.1">
     The KVM implementation requires
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.198.1">
      nova-compute
     </span>
    </strong>
    <span class="koboSpan" id="kobo.199.1">
     to be deployed on a Linux server with KVM virtualization modules installed.
    </span>
    <span class="koboSpan" id="kobo.199.2">
     For each compute node, make sure the KVM modules are properly loaded by checking the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.200.1">
      command line:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.201.1">
# lsmod | grep kvm
kvm_intel or kvm_amd</span></pre>
   <p>
    <span class="koboSpan" id="kobo.202.1">
     Optionally, and depending on the supported KVM module (Intel or AMD) in your nodes, add the listed modules in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.203.1">
      /etc/modules
     </span>
    </strong>
    <span class="koboSpan" id="kobo.204.1">
     files to persist your changes
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.205.1">
      at reboot.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.206.1">
     The next section considers KVM as the main adopted hypervisor of our production
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.207.1">
      compute nodes.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-89">
    <a id="_idTextAnchor134">
    </a>
    <span class="koboSpan" id="kobo.208.1">
     Compute segregation
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.209.1">
     OpenStack is designed to scale massively to respond to the growth of the infrastructure size and user demand.
    </span>
    <span class="koboSpan" id="kobo.209.2">
     As the
    </span>
    <a id="_idIndexMarker382">
    </a>
    <span class="koboSpan" id="kobo.210.1">
     compute service is the workhorse of the cloud infrastructure, designing for compute layer scalability and business continuity is a must.
    </span>
    <span class="koboSpan" id="kobo.210.2">
     Defining a compute segregation strategy will help you understand your private cloud infrastructure limits and forecast user compute demands – that’s what will be explored
    </span>
    <a id="_idIndexMarker383">
    </a>
    <span class="koboSpan" id="kobo.211.1">
     in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.212.1">
      following section.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-90">
    <a id="_idTextAnchor135">
    </a>
    <span class="koboSpan" id="kobo.213.1">
     Infrastructure segregation
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.214.1">
     Depending on the available compute farm resources and inventory specifications, as well as the hypervisors to be
    </span>
    <a id="_idIndexMarker384">
    </a>
    <span class="koboSpan" id="kobo.215.1">
     used, OpenStack exposes a variety of compute segregation mechanisms that can be leveraged, including
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.216.1">
      Availability Zones
     </span>
    </strong>
    <span class="koboSpan" id="kobo.217.1">
     ,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.218.1">
      Regions
     </span>
    </strong>
    <span class="koboSpan" id="kobo.219.1">
     ,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.220.1">
      Cells
     </span>
    </strong>
    <span class="koboSpan" id="kobo.221.1">
     , and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.222.1">
      Host Aggregates
     </span>
    </strong>
    <span class="koboSpan" id="kobo.223.1">
     .
    </span>
    <span class="koboSpan" id="kobo.223.2">
     Each of the previous concepts will be
    </span>
    <a id="_idIndexMarker385">
    </a>
    <span class="koboSpan" id="kobo.224.1">
     detailed in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.225.1">
      following section.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.226.1">
     Regions
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.227.1">
     A region in the OpenStack
    </span>
    <a id="_idIndexMarker386">
    </a>
    <span class="koboSpan" id="kobo.228.1">
     glossary presents a fully independent OpenStack deployment.
    </span>
    <span class="koboSpan" id="kobo.228.2">
     From operational and management perspectives, each region can expose its own OpenStack API services, including compute resources.
    </span>
    <span class="koboSpan" id="kobo.228.3">
     If you’re planning a Nova multi-regional setup, a Nova API endpoint should be created in each region and added to the identity services catalog.
    </span>
    <span class="koboSpan" id="kobo.228.4">
     Users can spawn instances and spread workloads between available regions through the available compute API.
    </span>
    <span class="koboSpan" id="kobo.228.5">
     Running workloads in a multi-region configuration setup offers a multitude of advantages for end users, but also presents challenges for operators, such as maintaining a consistent setup of the OpenStack control plane and shared service layers.
    </span>
    <span class="koboSpan" id="kobo.228.6">
     This is mainly due to the risk of having a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.229.1">
      split brain
     </span>
    </strong>
    <span class="koboSpan" id="kobo.230.1">
     between compute resources running in more than one region.
    </span>
    <span class="koboSpan" id="kobo.230.2">
     Hosting a
    </span>
    <a id="_idIndexMarker387">
    </a>
    <span class="koboSpan" id="kobo.231.1">
     user workload in a fleet of compute nodes running across multiple regions would require certain ways to provide consistency of shared resources such as virtual machine images, databases, or file shares.
    </span>
    <span class="koboSpan" id="kobo.231.2">
     Another important aspect of multi-regional consistency is the way to handle authorization to request compute resources.
    </span>
    <span class="koboSpan" id="kobo.231.3">
     One of the common design approaches is to consolidate all authentication
    </span>
    <a id="_idIndexMarker388">
    </a>
    <span class="koboSpan" id="kobo.232.1">
     calls through Keystone via a federated
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.233.1">
      Identity Provider
     </span>
    </strong>
    <span class="koboSpan" id="kobo.234.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.235.1">
      IdP
     </span>
    </strong>
    <span class="koboSpan" id="kobo.236.1">
     ), as shown in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.237.1">
      following diagram:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer055">
     <span class="koboSpan" id="kobo.238.1">
      <img alt="Figure 4.3 – OpenStack multi-region deployment" src="image/B21716_04_03.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.239.1">
     Figure 4.3 – OpenStack multi-region deployment
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.240.1">
     Each region can host one or
    </span>
    <a id="_idIndexMarker389">
    </a>
    <span class="koboSpan" id="kobo.241.1">
     more discrete compute structures defined as
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.242.1">
      Availability Zones
     </span>
    </em>
    <span class="koboSpan" id="kobo.243.1">
     , which will be covered in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.244.1">
      next section.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.245.1">
     Availability Zones
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.246.1">
     A region can be logically composed of one or multiple Availability Zones.
    </span>
    <span class="koboSpan" id="kobo.246.2">
     Unlike the regional setup, there is
    </span>
    <a id="_idIndexMarker390">
    </a>
    <span class="koboSpan" id="kobo.247.1">
     no need to deploy a full, standalone OpenStack deployment and provide consistency across the control plane services.
    </span>
    <span class="koboSpan" id="kobo.247.2">
     From a physical implementation standpoint, the compute nodes will be split into trees of logical
    </span>
    <a id="_idIndexMarker391">
    </a>
    <span class="koboSpan" id="kobo.248.1">
     groups called
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.249.1">
      fault domains
     </span>
    </strong>
    <span class="koboSpan" id="kobo.250.1">
     .
    </span>
    <span class="koboSpan" id="kobo.250.2">
     Each fault domain
    </span>
    <a id="_idIndexMarker392">
    </a>
    <span class="koboSpan" id="kobo.251.1">
     will be part of a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.252.1">
      Power Distribution Unit
     </span>
    </strong>
    <span class="koboSpan" id="kobo.253.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.254.1">
      PDU
     </span>
    </strong>
    <span class="koboSpan" id="kobo.255.1">
     ) within a given rack and different hypervisors will run across different racks.
    </span>
    <span class="koboSpan" id="kobo.255.2">
     This way, losing
    </span>
    <a id="_idIndexMarker393">
    </a>
    <span class="koboSpan" id="kobo.256.1">
     connectivity to the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.257.1">
      Top-of-Rack
     </span>
    </strong>
    <span class="koboSpan" id="kobo.258.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.259.1">
      ToR
     </span>
    </strong>
    <span class="koboSpan" id="kobo.260.1">
     ) switch or upon a PDU failure won’t fully bring down a user workload running in a multi-availability zone configuration, as shown in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.261.1">
      following diagram:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer056">
     <span class="koboSpan" id="kobo.262.1">
      <img alt="Figure 4.4 – Extended OpenStack multi-regional and zonal deployment" src="image/B21716_04_04.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.263.1">
     Figure 4.4 – Extended OpenStack multi-regional and zonal deployment
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.264.1">
     The Nova availability zone option empowers user workloads with high availability that can be considered a premium option for critical workloads that require the highest level of SLA.
    </span>
    <span class="koboSpan" id="kobo.264.2">
     A compute node can belong
    </span>
    <a id="_idIndexMarker394">
    </a>
    <span class="koboSpan" id="kobo.265.1">
     to only one availability zone as it is bound to the rack’s physical design, such as rack ID, location,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.266.1">
      and PDU.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.267.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.268.1">
     The logical abstraction of Availability Zones covers the network and block storage services besides the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.269.1">
      compute service.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.270.1">
     Users can select which Availability Zone to launch instances in.
    </span>
    <span class="koboSpan" id="kobo.270.2">
     For this reason, keeping an eye on the compute resource utilization for each Availability Zone is essential.
    </span>
    <span class="koboSpan" id="kobo.270.3">
     That will ensure that each Availability Zone will be able to accommodate more compute allocation within the available physical resources when needed, as well as ensure that users can spawn workloads across multiple compute nodes in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.271.1">
      different zones.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.272.1">
     Host aggregates
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.273.1">
     Unlike the Availability Zones concept, the host aggregates strategy groups compute nodes based on more granular hardware profile categories defined as metadata.
    </span>
    <span class="koboSpan" id="kobo.273.2">
     This type of grouping can be based on the definition of features such as hypervisor, storage type, CPU family, network
    </span>
    <a id="_idIndexMarker395">
    </a>
    <span class="koboSpan" id="kobo.274.1">
     speed, and so on.
    </span>
    <span class="koboSpan" id="kobo.274.2">
     Cloud operators should create different host aggregates in advance by attaching a set of metadata to the selected compute nodes.
    </span>
    <span class="koboSpan" id="kobo.274.3">
     This lets users spawn instances by selecting the desired host aggregate that responds to the workload requirements.
    </span>
    <span class="koboSpan" id="kobo.274.4">
     Metadata can be created based on plenty of hardware specifications, depending on what the private cloud operator has purchased.
    </span>
    <span class="koboSpan" id="kobo.274.5">
     For example, aggregation can be configured for an optimized disk host group, based on SSD, GPU architecture, high-performance networking capabilities, or even by aggregate compute nodes for a single tenant.
    </span>
    <span class="koboSpan" id="kobo.274.6">
     A compute node can be part of one or many host aggregates.
    </span>
    <span class="koboSpan" id="kobo.274.7">
     As a best practice, it is important to list all the different hardware capabilities once the compute nodes are in place and sort them into trees by grouping them based on the expected workload that they will host.
    </span>
    <span class="koboSpan" id="kobo.274.8">
     For example, if HPC workloads are included in your cloud business case offering for end users, you might consider creating a host aggregate in advance based on GPU capabilities and exposing it to end users.
    </span>
    <span class="koboSpan" id="kobo.274.9">
     The following diagram shows a use case for providing four host aggregates, where some compute nodes can be part of more than one
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.275.1">
      host aggregate:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer057">
     <span class="koboSpan" id="kobo.276.1">
      <img alt="Figure 4.5 – Host aggregation in the deployment of multiple Availability Zones" src="image/B21716_04_05.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.277.1">
     Figure 4.5 – Host aggregation in the deployment of multiple Availability Zones
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.278.1">
     The previous multi-region segregation compute layout involves four different host aggregates that can be spread across different Availability Zones
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.279.1">
      as follows:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.280.1">
       Host aggregate 1
      </span>
     </strong>
     <span class="koboSpan" id="kobo.281.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.282.1">
       HA_1
      </span>
     </strong>
     <span class="koboSpan" id="kobo.283.1">
      ): This involves grouping a set of compute nodes in the same region and Availability Zone to accommodate workloads that require low network-latency performance, such as HPC applications within a large network bandwidth and GPU architecture.
     </span>
     <span class="koboSpan" id="kobo.283.2">
      Workloads in this host aggregate do not have high availability as a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.284.1">
       major exigency.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.285.1">
       Host aggregate 2
      </span>
     </strong>
     <span class="koboSpan" id="kobo.286.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.287.1">
       HA_2
      </span>
     </strong>
     <span class="koboSpan" id="kobo.288.1">
      ): This aggregate involves grouping a set of compute nodes spread through two Availability Zones and within the same region to accommodate workloads that
     </span>
     <a id="_idIndexMarker396">
     </a>
     <span class="koboSpan" id="kobo.289.1">
      require large distributed workloads, such as big data processing running Hadoop or Cassandra.
     </span>
     <span class="koboSpan" id="kobo.289.2">
      The host aggregate metadata includes large network bandwidth, optimized disks based on SSD, and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.290.1">
       memory capacity.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.291.1">
       Host aggregate 3
      </span>
     </strong>
     <span class="koboSpan" id="kobo.292.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.293.1">
       HA_3
      </span>
     </strong>
     <span class="koboSpan" id="kobo.294.1">
      ): This involves grouping a set of compute nodes spread through three Availability Zones and across two regions to accommodate critical workloads that require the highest level of availability and scalability, such as web applications and webshops.
     </span>
     <span class="koboSpan" id="kobo.294.2">
      The metadata describes moderate network bandwidth, disk, memory, and CPU
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.295.1">
       standard capabilities.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.296.1">
       Host aggregate 4
      </span>
     </strong>
     <span class="koboSpan" id="kobo.297.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.298.1">
       HA_4
      </span>
     </strong>
     <span class="koboSpan" id="kobo.299.1">
      ): This involves grouping a set of compute nodes within the same region and Availability Zone to accommodate workloads that require enhanced networking capability within a VSphere environment.
     </span>
     <span class="koboSpan" id="kobo.299.2">
      The host aggregate metadata includes VMware as a configured hypervisor to extend an existing VCenter environment and spread the application load between VMware hosts (running the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.300.1">
        nova-compute
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.301.1">
       service).
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.302.1">
     We will demonstrate later in this chapter how the combination of the host aggregation approach, Placement service, and Nova scheduling can expose a gazillion ways to host different types of workloads in the most efficient way to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.303.1">
      cloud users.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.304.1">
     Cells
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.305.1">
     The concept of cells in OpenStack was introduced mainly to address the performance bottleneck of large-scale Nova deployment within a single OpenStack region.
    </span>
    <span class="koboSpan" id="kobo.305.2">
     A large number of compute nodes would increase
    </span>
    <a id="_idIndexMarker397">
    </a>
    <span class="koboSpan" id="kobo.306.1">
     the load on the main control plane services, including the messaging queue and database, resulting in performance degradation that would limit the expansion of the entire system.
    </span>
    <span class="koboSpan" id="kobo.306.2">
     The mitigation of performance degradation for large-scale deployment for Nova compute resources can be addressed by using the cell approach: compute nodes can be grouped within a logical boundary, where each group runs its own database and messaging queue service.
    </span>
    <span class="koboSpan" id="kobo.306.3">
     The cell architecture has been developed through different stages, resulting in two versions:
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.307.1">
      CellV1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.308.1">
     and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.309.1">
      CellV2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.310.1">
     .
    </span>
    <span class="koboSpan" id="kobo.310.2">
     CellV1 was the first version and was not widely implemented due to a number of caveats.
    </span>
    <span class="koboSpan" id="kobo.310.3">
     Since the OpenStack Ocata release, CellV2 has been introduced, with enhancements to the former version, and has become the official version within the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.311.1">
      Pike
     </span>
    </strong>
    <span class="koboSpan" id="kobo.312.1">
     release.
    </span>
    <span class="koboSpan" id="kobo.312.2">
     Let’s discuss the major differences between the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.313.1">
      versions next.
     </span>
    </span>
   </p>
   <h4>
    <span class="koboSpan" id="kobo.314.1">
     CellV1
    </span>
   </h4>
   <p>
    <span class="koboSpan" id="kobo.315.1">
     The logical grouping of
    </span>
    <a id="_idIndexMarker398">
    </a>
    <span class="koboSpan" id="kobo.316.1">
     compute nodes forming each cell is arranged in a tree structure where the top-level cell called the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.317.1">
      root
     </span>
    </strong>
    <span class="koboSpan" id="kobo.318.1">
     runs the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.319.1">
      nova-api
     </span>
    </strong>
    <span class="koboSpan" id="kobo.320.1">
     service.
    </span>
    <span class="koboSpan" id="kobo.320.2">
     The second level of cells, which run the Nova compute service, are referred to as child cells, as shown in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.321.1">
      following diagram:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer058">
     <span class="koboSpan" id="kobo.322.1">
      <img alt="Figure 4.6 – OpenStack compute CellV1 deployment" src="image/B21716_04_06.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.323.1">
     Figure 4.6 – OpenStack compute CellV1 deployment
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.324.1">
     The interaction between the cells running the Nova API and running the Nova compute goes through a dedicated messaging queue via RPC calls handled by a separate Nova service called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.325.1">
      nova-cell
     </span>
    </strong>
    <span class="koboSpan" id="kobo.326.1">
     (a major enhancement of CellV1 introduced in the Juno release).
    </span>
    <span class="koboSpan" id="kobo.326.2">
     Each cell runs its own messaging queue for interactive synchronization and is used by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.327.1">
      nova-cell
     </span>
    </strong>
    <span class="koboSpan" id="kobo.328.1">
     for selecting in
    </span>
    <a id="_idIndexMarker399">
    </a>
    <span class="koboSpan" id="kobo.329.1">
     which cell an instance will be spawned.
    </span>
    <span class="koboSpan" id="kobo.329.2">
     This exposes a higher level of instance scheduling but within the cell’s level.
    </span>
    <span class="koboSpan" id="kobo.329.3">
     Once a cell is selected, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.330.1">
      nova-scheduler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.331.1">
     service within that cell will process the rest of the request workflow to select a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.332.1">
      compute node.
     </span>
    </span>
   </p>
   <h4>
    <span class="koboSpan" id="kobo.333.1">
     CellV2
    </span>
   </h4>
   <p>
    <span class="koboSpan" id="kobo.334.1">
     The initial cell version
    </span>
    <a id="_idIndexMarker400">
    </a>
    <span class="koboSpan" id="kobo.335.1">
     went through experimental phases and was not successfully adopted in most large compute deployments.
    </span>
    <span class="koboSpan" id="kobo.335.2">
     This was mainly due to the multi-layer scheduling to spawn instances from the cell selection down to the compute scheduler service within the selected cell.
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.336.1">
       Figure 4
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.337.1">
      .6
     </span>
    </em>
    <span class="koboSpan" id="kobo.338.1">
     illustrates a simple tree composed of only root and child cells, but other, wider deployments could adopt more child cells, called
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.339.1">
      grandchild
     </span>
    </strong>
    <span class="koboSpan" id="kobo.340.1">
     cells.
    </span>
    <span class="koboSpan" id="kobo.340.2">
     The other major shortcoming of the first
    </span>
    <a id="_idIndexMarker401">
    </a>
    <span class="koboSpan" id="kobo.341.1">
     version is the amount of data (instance and compute node information) to be mapped and synchronized between cells, resulting in heavy data replication processes between the cells.
    </span>
    <span class="koboSpan" id="kobo.341.2">
     The new version, referred to as CellV2, has been developed and adopted officially from the Ocata release by addressing the caveats of the prior version.
    </span>
    <span class="koboSpan" id="kobo.341.3">
     Major
    </span>
    <a id="_idIndexMarker402">
    </a>
    <span class="koboSpan" id="kobo.342.1">
     changes have been introduced, such as the removal of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.343.1">
      nova-cell
     </span>
    </strong>
    <span class="koboSpan" id="kobo.344.1">
     component and the overall cell architecture, which is no longer a tree-like structure similar to CellV1.
    </span>
    <span class="koboSpan" id="kobo.344.2">
     This is illustrated in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.345.1">
      following diagram:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer059">
     <span class="koboSpan" id="kobo.346.1">
      <img alt="Figure 4.7 – OpenStack compute CellV2 deployment" src="image/B21716_04_07.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.347.1">
     Figure 4.7 – OpenStack compute CellV2 deployment
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.348.1">
     Sharding hypervisor nodes through the second version of cells in Nova involves major changes in the scheduling workflow within the multi-cell deployment, as illustrated in the previous diagram.
    </span>
    <span class="koboSpan" id="kobo.348.2">
     A cell API runs the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.349.1">
      nova-api
     </span>
    </strong>
    <span class="koboSpan" id="kobo.350.1">
     service,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.351.1">
      nova-scheduler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.352.1">
     , and more recently, the Placement service (the Placement service was not introduced in the OpenStack ecosystem in the Cellv1 development) to uniformly schedule resources across all defined cells.
    </span>
    <span class="koboSpan" id="kobo.352.2">
     The cell API exposes a separate database called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.353.1">
      nova_api
     </span>
    </strong>
    <span class="koboSpan" id="kobo.354.1">
     , which contains metadata of all global resources, such as instance flavors, quotas, keypairs, and so on.
    </span>
    <span class="koboSpan" id="kobo.354.2">
     In multi-cell deployment, the conductor piece in the API cell is called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.355.1">
      nova-super-conductor
     </span>
    </strong>
    <span class="koboSpan" id="kobo.356.1">
     , which deals with all database insulation.
    </span>
    <span class="koboSpan" id="kobo.356.2">
     Additionally, from the API level, a special cell called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.357.1">
      Cell0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.358.1">
     does not run any of the services but holds only the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.359.1">
      nova_cell0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.360.1">
     database containing information about failed instances to start due to a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.361.1">
      scheduler failure.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.362.1">
     Each cell grouping the compute nodes manages its own resources and they have no affiliation with each other.
    </span>
    <span class="koboSpan" id="kobo.362.2">
     Each cell has its own database storing information about instances and uses its own dedicated messaging queue to coordinate between the local cell’s
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.363.1">
      nova-conductor
     </span>
    </strong>
    <span class="koboSpan" id="kobo.364.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.365.1">
      nova-compute
     </span>
    </strong>
    <span class="koboSpan" id="kobo.366.1">
     services.
    </span>
    <span class="koboSpan" id="kobo.366.2">
     The new CellV2 method simply involves the following
    </span>
    <a id="_idIndexMarker403">
    </a>
    <span class="koboSpan" id="kobo.367.1">
     workflow steps to spawn a new instance in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.368.1">
      multi-cell deployment:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.369.1">
       nova-api
      </span>
     </strong>
     <span class="koboSpan" id="kobo.370.1">
      (in the API cell) receives the API REST call and forwards it to the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.371.1">
       nova-scheduler
      </span>
     </strong>
     <span class="koboSpan" id="kobo.372.1">
      service (in the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.373.1">
       API cell).
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.374.1">
       nova-scheduler
      </span>
     </strong>
     <span class="koboSpan" id="kobo.375.1">
      contacts the Placement service, applies its filters, and determines which compute node will
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.376.1">
       be assigned.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.377.1">
       nova-api
      </span>
     </strong>
     <span class="koboSpan" id="kobo.378.1">
      stores the mapping instance information in its
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.379.1">
       nova_api
      </span>
     </strong>
     <span class="koboSpan" id="kobo.380.1">
      database (the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.381.1">
        instance_mappings
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.382.1">
       table).
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.383.1">
       nova-api
      </span>
     </strong>
     <span class="koboSpan" id="kobo.384.1">
      stores the selected compute node record in the database target cell (for example,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.385.1">
       nova_cell01
      </span>
     </strong>
     <span class="koboSpan" id="kobo.386.1">
      if the selected compute node resides
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.387.1">
       in
      </span>
     </span>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.388.1">
        Cell01
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.389.1">
       ).
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.390.1">
       nova-api
      </span>
     </strong>
     <span class="koboSpan" id="kobo.391.1">
      sends an RPC call to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.392.1">
       nova-super-conductor
      </span>
     </strong>
     <span class="koboSpan" id="kobo.393.1">
      to build
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.394.1">
       the instance.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.395.1">
       nova-super-conductor
      </span>
     </strong>
     <span class="koboSpan" id="kobo.396.1">
      initiates an RPC call to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.397.1">
       nova-conductor
      </span>
     </strong>
     <span class="koboSpan" id="kobo.398.1">
      in the target cell to spawn the instance via the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.399.1">
       compute service.
      </span>
     </span>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.400.1">
     The CellV2 architecture has shifted drastically from the initial CellV1 architecture with the removal of an additional scheduling layer and the division of the data into multiple databases instead of carrying a replication process for each request.
    </span>
    <span class="koboSpan" id="kobo.400.2">
     This way, expanding a cell perimeter to welcome more compute hosts can be easily performed without the need to go through the whole synchronization process per cell, as we have seen in CellV1.
    </span>
    <span class="koboSpan" id="kobo.400.3">
     Moreover, the new cell architecture is simple as all cells are equal, making the whole multi-cell deployment a flat-like structure (only two layers), unlike its previous version, which was based on the tree structure.
    </span>
    <span class="koboSpan" id="kobo.400.4">
     Once the logical layout of cells is designed and ready for deployment, operators will just need to choose which hypervisor nodes will be associated with which cell.
    </span>
    <span class="koboSpan" id="kobo.400.5">
     Unlike host aggregation, regions, and Availability Zones, users are not aware of the concept of a cell, as the cell strategy is mainly for cloud operators to
    </span>
    <a id="_idIndexMarker404">
    </a>
    <span class="koboSpan" id="kobo.401.1">
     expand large compute environments with the best management and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.402.1">
      performance enhancements.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-91">
    <a id="_idTextAnchor136">
    </a>
    <span class="koboSpan" id="kobo.403.1">
     Workload segregation
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.404.1">
     The latest features of the Nova service provide different strategies to unlock a fully scalable OpenStack compute infrastructure by means of regions, Availability Zones, host aggregates, and cell concepts.
    </span>
    <span class="koboSpan" id="kobo.404.2">
     To have a full
    </span>
    <a id="_idIndexMarker405">
    </a>
    <span class="koboSpan" id="kobo.405.1">
     picture of a large deployment, adopting one or more of those approaches would require the definition of an orchestrator element to dispatch instances in a particular set of hypervisor hosts.
    </span>
    <span class="koboSpan" id="kobo.405.2">
     At the heart of the launch process of instances is the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.406.1">
      nova-scheduler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.407.1">
     service, which determines on which host an instance will be placed.
    </span>
    <span class="koboSpan" id="kobo.407.2">
     As highlighted in
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.408.1">
      Chapters 1
     </span>
    </em>
    <span class="koboSpan" id="kobo.409.1">
     and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.410.1">
      3
     </span>
    </em>
    <span class="koboSpan" id="kobo.411.1">
     , the latest OpenStack releases, come with the Placement service, which was introduced in the Newton release.
    </span>
    <span class="koboSpan" id="kobo.411.2">
     The Placement service works in tandem with the Nova scheduler for a more advanced and granular host pre-filtering selection process.
    </span>
    <span class="koboSpan" id="kobo.411.3">
     To make the most of the segregation approaches defined in the previous section, it is essential to skim the surface of different compute scheduling methods that are mindful of the overall compute segregation strategy in your
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.412.1">
      OpenStack deployment.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-92">
    <a id="_idTextAnchor137">
    </a>
    <span class="koboSpan" id="kobo.413.1">
     Pre-filtering
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.414.1">
     The main motivation for having a dedicated Placement service that runs alongside the Nova scheduler is to resolve the dilemma of a large compute deployment.
    </span>
    <span class="koboSpan" id="kobo.414.2">
     Prior to the introduction of the Placement
    </span>
    <a id="_idIndexMarker406">
    </a>
    <span class="koboSpan" id="kobo.415.1">
     service, the Nova scheduler had to loop through all the compute farms, including the enabled filters, in an entire large deployment, resulting in inefficiency and performance issues.
    </span>
    <span class="koboSpan" id="kobo.415.2">
     Additionally, the sum of resources reported by the compute nodes lacked accuracy due to the basic functions of Nova in calculating, in a detailed fashion, the exact number of resources and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.416.1">
      inventory usage.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.417.1">
     With the advent of the Placement service, the logic of resource reporting has been changed by adding a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.418.1">
      resource_tracker
     </span>
    </strong>
    <span class="koboSpan" id="kobo.419.1">
     component in a compute node that reports its inventory and available resources to the Placement service, which periodically stores a full synchronization of reported resources.
    </span>
    <span class="koboSpan" id="kobo.419.2">
     As detailed in
    </span>
    <a href="B21716_03.xhtml#_idTextAnchor108">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.420.1">
        Chapter 3
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.421.1">
     ,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.422.1">
      OpenStack Control Plane – Shared Services
     </span>
    </em>
    <span class="koboSpan" id="kobo.423.1">
     , the Placement service comes with the definition of
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.424.1">
      resource providers
     </span>
    </strong>
    <span class="koboSpan" id="kobo.425.1">
     and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.426.1">
      traits
     </span>
    </strong>
    <span class="koboSpan" id="kobo.427.1">
     to apply prefilters to its compute node list once contacted by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.428.1">
      nova-scheduler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.429.1">
     .
    </span>
    <span class="koboSpan" id="kobo.429.2">
     Under
    </span>
    <a id="_idIndexMarker407">
    </a>
    <span class="koboSpan" id="kobo.430.1">
     the hood,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.431.1">
      nova-scheduler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.432.1">
     calls the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.433.1">
      placement-api
     </span>
    </strong>
    <span class="koboSpan" id="kobo.434.1">
     service via a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.435.1">
      GET API
     </span>
    </strong>
    <span class="koboSpan" id="kobo.436.1">
     request by passing different scheduling parameters such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.437.1">
      VCPU
     </span>
    </strong>
    <span class="koboSpan" id="kobo.438.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.439.1">
      DISK_GB
     </span>
    </strong>
    <span class="koboSpan" id="kobo.440.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.441.1">
      MEMORY_MB
     </span>
    </strong>
    <span class="koboSpan" id="kobo.442.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.443.1">
      VGPU
     </span>
    </strong>
    <span class="koboSpan" id="kobo.444.1">
     .
    </span>
    <span class="koboSpan" id="kobo.444.2">
     These will be translated into
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.445.1">
      trait
     </span>
    </strong>
    <span class="koboSpan" id="kobo.446.1">
     requests at the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.447.1">
       placement-api
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.448.1">
      level.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-93">
    <a id="_idTextAnchor138">
    </a>
    <span class="koboSpan" id="kobo.449.1">
     Resource provider allocation
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.450.1">
     The Placement service, as reviewed in
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.451.1">
      Chapters 1
     </span>
    </em>
    <span class="koboSpan" id="kobo.452.1">
     and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.453.1">
      3
     </span>
    </em>
    <span class="koboSpan" id="kobo.454.1">
     , is used by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.455.1">
      nova-scheduler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.456.1">
     to list a set of pre-filtered
    </span>
    <a id="_idIndexMarker408">
    </a>
    <span class="koboSpan" id="kobo.457.1">
     compute nodes based on specific attributes before evaluating their candidacy, as shown in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.458.1">
      following diagram:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer060">
     <span class="koboSpan" id="kobo.459.1">
      <img alt="Figure 4.8 – The OpenStack compute placement workflow" src="image/B21716_04_08.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.460.1">
     Figure 4.8 – The OpenStack compute placement workflow
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.461.1">
     When the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.462.1">
      nova-api
     </span>
    </strong>
    <span class="koboSpan" id="kobo.463.1">
     service receives a user request for a new instance creation,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.464.1">
      nova-scheduler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.465.1">
     will fire a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.466.1">
      GET /allocation_candidates()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.467.1">
     request to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.468.1">
      placement-api
     </span>
    </strong>
    <span class="koboSpan" id="kobo.469.1">
     service.
    </span>
    <span class="koboSpan" id="kobo.469.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.470.1">
      allocation_candidates
     </span>
    </strong>
    <span class="koboSpan" id="kobo.471.1">
     method is a collection of a set of resource providers that will allocate resources based on the attributes encapsulated in the request.
    </span>
    <span class="koboSpan" id="kobo.471.2">
     A sample API GET request uses the following format as a filter condition to embed the required resources to launch
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.472.1">
      an instance:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.473.1">
GET/placement/allocation_candidates?resources=DISK_GB:500,MEMORY_MB:2048,VCPU:4</span></pre>
   <p>
    <span class="koboSpan" id="kobo.474.1">
     Upon the previous request, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.475.1">
      placement-api
     </span>
    </strong>
    <span class="koboSpan" id="kobo.476.1">
     service will fetch the complying hosts that will accommodate instance flavors: disk capacity of 500 GB, memory size of 2048 MB, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.477.1">
      4 vCPUs.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.478.1">
     The previous request can be extended to filter based on resource traits by adding the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.479.1">
      &amp;required
     </span>
    </strong>
    <span class="koboSpan" id="kobo.480.1">
     query parameter
    </span>
    <a id="_idIndexMarker409">
    </a>
    <span class="koboSpan" id="kobo.481.1">
     at the end of the request string, so the allocation query will look
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.482.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.483.1">
GET/placement/allocation_candidates?resources=DISK_GB:500,MEMORY_MB:2048,VCPU:4 &amp;required=HW_CPU_X86_SVM</span></pre>
   <p>
    <span class="koboSpan" id="kobo.484.1">
     This way, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.485.1">
      placement-api
     </span>
    </strong>
    <span class="koboSpan" id="kobo.486.1">
     service will combine the required resource attributes and an additional trait for hosts that support a CPU with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.487.1">
      X86_SVM architecture.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.488.1">
     Typically, cloud operators can use the OpenStack CLI to deal with placement configuration via the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.489.1">
      allocation candidate
     </span>
    </strong>
    <span class="koboSpan" id="kobo.490.1">
     command line, as in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.491.1">
      following example:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.492.1">
# openstack allocation candidate list --resource VCPU=4, 
MEMORY_ MB=2048,DISK_GB=500GB --required   HW_CPU_X86_SVM</span></pre>
   <p>
    <span class="koboSpan" id="kobo.493.1">
     Here’s
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.494.1">
      the output:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer061">
     <span class="koboSpan" id="kobo.495.1">
      <img alt="Figure 4.9 – The placement details of a registered allocation" src="image/B21716_04_09.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.496.1">
     Figure 4.9 – The placement details of a registered allocation
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.497.1">
     The main parameters that influence the logic of the subsequent scheduler pre-filtering process lie in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.498.1">
      allocation_requests
     </span>
    </strong>
    <span class="koboSpan" id="kobo.499.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.500.1">
      provider_summaries
     </span>
    </strong>
    <span class="koboSpan" id="kobo.501.1">
     .
    </span>
    <span class="koboSpan" id="kobo.501.2">
     The previous objects are returned by the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.502.1">
      placement-api
     </span>
    </strong>
    <span class="koboSpan" id="kobo.503.1">
     service to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.504.1">
      nova-scheduler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.505.1">
     service with two types of objects listed in JSON format with the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.506.1">
      data structure:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.507.1">
       allocation_requests
      </span>
     </strong>
     <span class="koboSpan" id="kobo.508.1">
      : A list of resource providers that can satisfy the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.509.1">
       allocation request:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.510.1">
"allocation_requests": [
        {
            "allocations": {
                "ad54422c-b345-5v44-ba23-00cad76e376a": {
                    "resources": {
                        "DISK_GB": 500
                    }
                },
                "652f6729-cd55-4747-91a1-543adfeea2a": {
                    "resources": {
                        "VCPU": 4,
                        "MEMORY_MB": 2048
                    }
                }
            }
        },
...</span></pre>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.511.1">
       provider_summaries
      </span>
     </strong>
     <span class="koboSpan" id="kobo.512.1">
      : The total amount of resources and information usage across all the resource providers that
     </span>
     <a id="_idIndexMarker410">
     </a>
     <span class="koboSpan" id="kobo.513.1">
      satisfy the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.514.1">
       allocation request:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.515.1">
...
</span><strong class="bold"><span class="koboSpan" id="kobo.516.1">"provider_summaries"</span></strong><span class="koboSpan" id="kobo.517.1">: {
        "ad54422c-b345-5v44-ba23-00cad76e376a": {
            "resources": {
                "DISK_GB": {
                    "used": 0,
                    "capacity": 2000
                }
            },
            "</span><strong class="bold"><span class="koboSpan" id="kobo.518.1">traits</span></strong><span class="koboSpan" id="kobo.519.1">": ["SRG_SHARES_STORE"],
            "parent_provider_uuid": null,
            "root_provider_uuid": 
              "ad54422c-b345-5v44-ba23- 00cad76e376a"
        },
        "652f6729-cd55-4747-91a1-543adfeea2a ": {
            "resources": {
                "VCPU": {
                    "used": 0,
                    "capacity": 244
                },
                "MEMORY_MB": {
                    "used": 0,
                    "capacity": 192604
                }
            },
            "</span><strong class="bold"><span class="koboSpan" id="kobo.520.1">traits</span></strong><span class="koboSpan" id="kobo.521.1">": ["HW_CPU_X86_SVM", "HW_CPU_X86_SSE2"],
            "parent_provider_uuid": null,
            "root_provider_uuid": 
              "652f6729-cd55-4747-91a1-543adfeea2a"
        },
...</span></pre>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.522.1">
     The JSON
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.523.1">
      provider_summaries
     </span>
    </strong>
    <span class="koboSpan" id="kobo.524.1">
     object output includes the associated traits with a resource provider.
    </span>
    <span class="koboSpan" id="kobo.524.2">
     The previous output example shows the resource provider for the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.525.1">
      52f6729-cd55-4747-91a1-543adfeea2a
     </span>
    </strong>
    <span class="koboSpan" id="kobo.526.1">
     compute
    </span>
    <a id="_idIndexMarker411">
    </a>
    <span class="koboSpan" id="kobo.527.1">
     node UUID, labeled with a trait class supporting the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.528.1">
      HW_CPU_X86_SVM
     </span>
    </strong>
    <span class="koboSpan" id="kobo.529.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.530.1">
      HW_CPU_X86_SSE2
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.531.1">
      CPU architectures.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-94">
    <a id="_idTextAnchor139">
    </a>
    <span class="koboSpan" id="kobo.532.1">
     Filtering
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.533.1">
     Once the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.534.1">
      placement-api
     </span>
    </strong>
    <span class="koboSpan" id="kobo.535.1">
     service returns the candidate host list to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.536.1">
      nova-scheduler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.537.1">
     service, the latter process
    </span>
    <a id="_idIndexMarker412">
    </a>
    <span class="koboSpan" id="kobo.538.1">
     runs a variety of filters based on the pre-configured filters in the Nova service.
    </span>
    <span class="koboSpan" id="kobo.538.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.539.1">
      /etc/nova/nova.conf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.540.1">
     file can be configured to run one or several schedulers by adjusting the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.541.1">
       enabled_filters
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.542.1">
      option.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.543.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.544.1">
     The scheduler filters in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.545.1">
      kolla-ansible
     </span>
    </strong>
    <span class="koboSpan" id="kobo.546.1">
     repository can be configured in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.547.1">
      filter_scheduler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.548.1">
     section, located in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.549.1">
      /
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.550.1">
       kolla-ansible/ansible/roles/nova/templates/nova.conf.j2
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.551.1">
      file.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.552.1">
     Some of the most common filters configured and supported by default in the scheduler are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.553.1">
      as follows:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.554.1">
       ComputeFilter
      </span>
     </strong>
     <span class="koboSpan" id="kobo.555.1">
      : This returns a list of fully operational hypervisor hosts that should be enabled
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.556.1">
       by default.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.557.1">
       ComputeCapabilitiesFilter
      </span>
     </strong>
     <span class="koboSpan" id="kobo.558.1">
      : This returns a list of hypervisor hosts that are capable of spawning an instance with the requested flavor.
     </span>
     <span class="koboSpan" id="kobo.558.2">
      For example, extra specifications could include verifying a compute host running a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.559.1">
       KVM hypervisor.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.560.1">
       ImagePropertiesFilter
      </span>
     </strong>
     <span class="koboSpan" id="kobo.561.1">
      : This returns a list of hypervisor hosts that meet the desired image properties defined in the instance image.
     </span>
     <span class="koboSpan" id="kobo.561.2">
      Image properties can be added based on the architecture of the hardware or hypervisor type.
     </span>
     <span class="koboSpan" id="kobo.561.3">
      For example, spawning an instance would require an image that should run on a host supporting KVM as
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.562.1">
       the hypervisor:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.563.1"># openstack image set --property img_hv_type=kvm img-uuid</span></strong></pre>
    </li>
   </ul>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.564.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.565.1">
     One of the major updates from the Liberty release is the image properties being passed to the filter for checks.
    </span>
    <span class="koboSpan" id="kobo.565.2">
     The new supported properties are
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.566.1">
      hw_architecture
     </span>
    </strong>
    <span class="koboSpan" id="kobo.567.1">
     (formerly named
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.568.1">
      architecture
     </span>
    </strong>
    <span class="koboSpan" id="kobo.569.1">
     ), which defines the hardware architecture,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.570.1">
      img_hv_type
     </span>
    </strong>
    <span class="koboSpan" id="kobo.571.1">
     (formerly named
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.572.1">
      hypervisor_type
     </span>
    </strong>
    <span class="koboSpan" id="kobo.573.1">
     ), which describes the type of the hypervisor,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.574.1">
      img_hv_requested_version
     </span>
    </strong>
    <span class="koboSpan" id="kobo.575.1">
     (formerly named
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.576.1">
      hypervisor_version_requires
     </span>
    </strong>
    <span class="koboSpan" id="kobo.577.1">
     ), which defines the required version of the hypervisor, and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.578.1">
      hw_vm_mode
     </span>
    </strong>
    <span class="koboSpan" id="kobo.579.1">
     (formerly named
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.580.1">
      vm_mode
     </span>
    </strong>
    <span class="koboSpan" id="kobo.581.1">
     ), which refers to the hypervisor application
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.582.1">
      binary interface.
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.583.1">
       ServerGroupAntiAffinityFilter
      </span>
     </strong>
     <span class="koboSpan" id="kobo.584.1">
      : This dispatches instances of the same group in different hypervisor hosts.
     </span>
     <span class="koboSpan" id="kobo.584.2">
      A common use case is to launch instances running the same workload and requiring an additional level of high availability.
     </span>
     <span class="koboSpan" id="kobo.584.3">
      To create server
     </span>
     <a id="_idIndexMarker413">
     </a>
     <span class="koboSpan" id="kobo.585.1">
      groups using an anti-affinity policy, use the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.586.1">
       --hint
      </span>
     </strong>
     <span class="koboSpan" id="kobo.587.1">
      flag in the Nova command-line tool
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.588.1">
       as follows:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.589.1"># openstack server group create --policy anti-affinity </span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.590.1">pp_webgroup</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.591.1"># openstack server create --image "Ubuntu 22.04" --hint group=122ee342-3345-2234-bac4-1515321e1ebb --flavor 5 "instance 01"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.592.1"># openstack server create --image "Ubuntu 22.04" --hint group=122ee342-3345-2234-bac4-1515321e1ebb --flavor 5 "instance 02"</span></strong></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.593.1">
       The outcome of the previous command lines will ensure that
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.594.1">
        instance 01
       </span>
      </strong>
      <span class="koboSpan" id="kobo.595.1">
       and
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.596.1">
        instance 02
       </span>
      </strong>
      <span class="koboSpan" id="kobo.597.1">
       are part of the same application server group,
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.598.1">
        pp_webgroup
       </span>
      </strong>
      <span class="koboSpan" id="kobo.599.1">
       , have the
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.600.1">
        122ee342-3345-2234-bac4-1515321e1ebb
       </span>
      </strong>
      <span class="koboSpan" id="kobo.601.1">
       UUID, and run in different
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.602.1">
        compute nodes.
       </span>
      </span>
     </p>
     <ul>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.603.1">
         ServerGroupAffinityFilter
        </span>
       </strong>
       <span class="koboSpan" id="kobo.604.1">
        : This dispatches instances in the same hypervisor host already running an affinity server group.
       </span>
       <span class="koboSpan" id="kobo.604.2">
        The affinity scheduler filter is recommended to run workloads that require the highest level of performance and
       </span>
       <a id="_idIndexMarker414">
       </a>
       <span class="koboSpan" id="kobo.605.1">
        low latency.
       </span>
       <span class="koboSpan" id="kobo.605.2">
        To create server groups using an affinity policy, use the
       </span>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.606.1">
         --hint
        </span>
       </strong>
       <span class="koboSpan" id="kobo.607.1">
        flag in the Nova command-line tool,
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.608.1">
         as follows:
        </span>
       </span>
       <pre class="source-code"><strong class="bold"><span class="koboSpan" id="kobo.609.1"># nova server-group-create --policy affinity</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.610.1">pp_perfgroup</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.611.1"># nova boot --image "Ubuntu 22.04" –hint group=44ee217-5543-9871-cda3-1e57522ecde1 --flavor 5 "instance 01"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.612.1"># nova boot --image "Ubuntu 22.04" –hint group=4ee217-5543-9871-cda3-1e57522ecde1 --flavor 5 "instance 02"</span></strong></pre>
      </li>
     </ul>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.613.1">
       The outcome of the previous command lines will ensure that
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.614.1">
        instance 01
       </span>
      </strong>
      <span class="koboSpan" id="kobo.615.1">
       and
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.616.1">
        instance 02
       </span>
      </strong>
      <span class="koboSpan" id="kobo.617.1">
       , part of the same application server group,
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.618.1">
        pp_perfgroup
       </span>
      </strong>
      <span class="koboSpan" id="kobo.619.1">
       , having the
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.620.1">
        144ee217-5543-9871-cda3-1e57522ecde1
       </span>
      </strong>
      <span class="koboSpan" id="kobo.621.1">
       UUID, will be running in the same
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.622.1">
        compute node.
       </span>
      </span>
     </p>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.623.1">
     OpenStack scheduling supports other filters, with more granular and customized options included in the latest releases of OpenStack.
    </span>
    <span class="koboSpan" id="kobo.623.2">
     At the time of writing this edition, an exhaustive list of the latest filters and configurations can be found
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.624.1">
      at
     </span>
    </span>
    <a href="https://docs.openstack.org/nova/latest/admin/scheduling.html#filters">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.625.1">
       https://docs.openstack.org/nova/latest/admin/scheduling.html#filters
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.626.1">
      .
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-95">
    <a id="_idTextAnchor140">
    </a>
    <span class="koboSpan" id="kobo.627.1">
     Weighting
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.628.1">
     Weighting is the last stage of the scheduling process, wherein the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.629.1">
      nova-scheduler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.630.1">
     service applies scoring for each filtered candidate host selected from the placement that passed all assigned filters.
    </span>
    <span class="koboSpan" id="kobo.630.2">
     The
    </span>
    <a id="_idIndexMarker415">
    </a>
    <span class="koboSpan" id="kobo.631.1">
     compute node with the highest weight will be selected by the scheduler at the final stage.
    </span>
    <span class="koboSpan" id="kobo.631.2">
     On the surface, the weighting logic might look less complex, but under the hood, additional factors should be considered.
    </span>
    <span class="koboSpan" id="kobo.631.3">
     The compute node metrics are periodically monitored and fed to the database to keep track of the host usage and resource claims.
    </span>
    <span class="koboSpan" id="kobo.631.4">
     The weighting process uses such information as factors and calculates the weights using a normalization function by giving each compute node a value between
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.632.1">
      0.0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.633.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.634.1">
      1.0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.635.1">
     .
    </span>
    <span class="koboSpan" id="kobo.635.2">
     Compute nodes with the most available resources (as reported by the monitoring) will be assigned a maximum value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.636.1">
      1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.637.1">
     and compute nodes with the lowest available resources will have a minimum value
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.638.1">
      of
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.639.1">
       0
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.640.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.641.1">
     The normalized factor is calculated based on the available resources using the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.642.1">
      following formula:
     </span>
    </span>
   </p>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.643.1">
      (host_availability_resource - min_value_all)/(max_value_all –
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.644.1">
       min_value_all)
      </span>
     </strong>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.645.1">
     Here, the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.646.1">
      following applies:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.647.1">
       host_availability_resource
      </span>
     </strong>
     <span class="koboSpan" id="kobo.648.1">
      is the value of the available resource in a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.649.1">
       compute node
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.650.1">
       min_value_all
      </span>
     </strong>
     <span class="koboSpan" id="kobo.651.1">
      is the minimum value of resources across all
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.652.1">
       compute nodes
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.653.1">
       max_value_all
      </span>
     </strong>
     <span class="koboSpan" id="kobo.654.1">
      is the maximum value of resources across all
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.655.1">
       compute nodes
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.656.1">
     The second step of the function is to multiply the normalized value of each compute node for each available resource by
    </span>
    <a id="_idIndexMarker416">
    </a>
    <span class="koboSpan" id="kobo.657.1">
     the associated weigher multiplier.
    </span>
    <span class="koboSpan" id="kobo.657.2">
     At the end of the weighting process, the scheduler will sum all normalized weights and select the compute node with the highest score, summarized
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.658.1">
      as follows:
     </span>
    </span>
   </p>
   <p>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.659.1">
       Σ
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.660.1">
       (weight(i)*norm_factor)
      </span>
     </strong>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.661.1">
     Here, the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.662.1">
      following applies:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.663.1">
       weight(i)
      </span>
     </strong>
     <span class="koboSpan" id="kobo.664.1">
      is the associated weight multiplier for a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.665.1">
       resource
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.666.1">
        i
       </span>
      </strong>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.667.1">
       norm_factor
      </span>
     </strong>
     <span class="koboSpan" id="kobo.668.1">
      is the assigned normalized weight factor for each
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.669.1">
       compute node
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.670.1">
     The following example illustrates the weighting process by calculating the normalized factors and weights for available RAM capacity and CPUs across five compute nodes, respectively.
    </span>
    <span class="koboSpan" id="kobo.670.2">
     The diagram illustrates the first subset size of nodes (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.671.1">
      subset 1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.672.1">
     ) – the first compiled list of evaluated hosts by the Nova scheduler through the filters –
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.673.1">
      as follows:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer062">
     <span class="koboSpan" id="kobo.674.1">
      <img alt="Figure 4.10 – The OpenStack compute weighting mechanism" src="image/B21716_04_10.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.675.1">
     Figure 4.10 – The OpenStack compute weighting mechanism
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.676.1">
     The scheduler then runs the weighting mechanism and generates the most suitable hypervisor hosts based on the
    </span>
    <a id="_idIndexMarker417">
    </a>
    <span class="koboSpan" id="kobo.677.1">
     weight scoring
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.678.1">
      as follows:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.679.1">
      Nodes A and D accommodate the highest RAM capacity and are assigned the maximum weight, normalized to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.680.1">
       1
      </span>
     </strong>
     <span class="koboSpan" id="kobo.681.1">
      .
     </span>
     <span class="koboSpan" id="kobo.681.2">
      The weight cost is denoted as
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.682.1">
       100
      </span>
     </strong>
     <span class="koboSpan" id="kobo.683.1">
      (1 multiplied
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.684.1">
       by 100).
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.685.1">
      Nodes B and C have the lowest amount of RAM capacity and are assigned the minimum weight normalized to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.686.1">
       0
      </span>
     </strong>
     <span class="koboSpan" id="kobo.687.1">
      .
     </span>
     <span class="koboSpan" id="kobo.687.2">
      The weight cost is denoted as
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.688.1">
       0
      </span>
     </strong>
     <span class="koboSpan" id="kobo.689.1">
      (0 multiplied
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.690.1">
       by 100).
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.691.1">
      Node E is assigned a weight normalized to 0.4 by applying the previous formula to calculate the normalized factor as follows: (350 - 250) / (500 – 250).
     </span>
     <span class="koboSpan" id="kobo.691.2">
      The weight cost is denoted as 40 (0.4 multiplied
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.692.1">
       by 100)
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.693.1">
      Nodes A and D accommodate the highest number of CPUs and are assigned the maximum weight, normalized to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.694.1">
       1
      </span>
     </strong>
     <span class="koboSpan" id="kobo.695.1">
      .
     </span>
     <span class="koboSpan" id="kobo.695.2">
      The weight cost is denoted as
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.696.1">
       100
      </span>
     </strong>
     <span class="koboSpan" id="kobo.697.1">
      (1 multiplied
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.698.1">
       by 100)
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.699.1">
      Node C has the lowest amount of CPU capacity and is assigned the minimum weight, normalized to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.700.1">
       0
      </span>
     </strong>
     <span class="koboSpan" id="kobo.701.1">
      .
     </span>
     <span class="koboSpan" id="kobo.701.2">
      The weight cost is denoted as
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.702.1">
       0
      </span>
     </strong>
     <span class="koboSpan" id="kobo.703.1">
      (0 multiplied
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.704.1">
       by 100)
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.705.1">
      Nodes B and E are assigned a weight normalized to 0.5 by applying the previous formula as follows: (10 - 5) / (20 – 10).
     </span>
     <span class="koboSpan" id="kobo.705.2">
      The weight cost is denoted as 50 (0.5 multiplied
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.706.1">
       by 100)
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.707.1">
      The final weighting for each host is calculated by summing up each weight cost of each CPU and RAM resource as follows: host A (100 + 100), host B (0 + 50), host C (0 + 0), host D (100 + 100), and host E (40 +
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.708.1">
       50)
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.709.1">
     In this example, both hosts A and D won the weighting bid and the scheduler will simply randomly select one of them from the
    </span>
    <a id="_idIndexMarker418">
    </a>
    <span class="koboSpan" id="kobo.710.1">
     second node’s subset to launch the instance.
    </span>
    <span class="koboSpan" id="kobo.710.2">
     Resource availability will be reflected in the database and the scheduler will update the weights accordingly on each new instance
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.711.1">
      creation request.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.712.1">
     The additional options brought to the filtering and scheduling mechanisms in the compute service can be handy in managing and distributing the workload demand across the compute farm.
    </span>
    <span class="koboSpan" id="kobo.712.2">
     By default, the scheduling allocates resources for instances by spreading them across the available hosts.
    </span>
    <span class="koboSpan" id="kobo.712.3">
     In some other cases, dispatching several instances with different flavors and sizes would create a concurrency issue when allocating resources, and hence prevent a subset of instances from being launched.
    </span>
    <span class="koboSpan" id="kobo.712.4">
     The scheduling weighting policy can be adjusted to use a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.713.1">
      stacking
     </span>
    </strong>
    <span class="koboSpan" id="kobo.714.1">
     approach.
    </span>
    <span class="koboSpan" id="kobo.714.2">
     In this case, instances will be allocated to the first
    </span>
    <a id="_idIndexMarker419">
    </a>
    <span class="koboSpan" id="kobo.715.1">
     filtered host until all of its resources are fully exhausted, before moving on to the next one.
    </span>
    <span class="koboSpan" id="kobo.715.2">
     A good example of a stacking method is the conjunction of the server affinity configuration and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.716.1">
      weighting mechanism.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.717.1">
     To customize the weighting mechanism in your deployment, make sure to apply the following configuration in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.718.1">
      /
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.719.1">
       etc/nova/nova.conf
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.720.1">
      file:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.721.1">
      Enable monitoring on the compute nodes to gather the CPU metrics by setting the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.722.1">
        compute_monitors
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.723.1">
       parameter:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.724.1">
compute_monitors = cpu.virt_driver</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.725.1">
      Enable the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.726.1">
        weights.all_weighers
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.727.1">
       class:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.728.1">
weight_classes = nova.scheduler.weights.all_weighers</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.729.1">
      Set the host subset size to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.730.1">
       1
      </span>
     </strong>
     <span class="koboSpan" id="kobo.731.1">
      .
     </span>
     <span class="koboSpan" id="kobo.731.2">
      Adjust the scheduler to select the host with the highest weight by setting the host subset size
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.732.1">
       to
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.733.1">
        1
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.734.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.735.1">
host_subset_size = 1</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.736.1">
      Adjust the weight multiplier to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.737.1">
       1
      </span>
     </strong>
     <span class="koboSpan" id="kobo.738.1">
      .
     </span>
     <span class="koboSpan" id="kobo.738.2">
      This way, the launch of a new instance will be spread evenly between
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.739.1">
       compute nodes:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.740.1">
weight_multiplier = 1.0</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.741.1">
      Adjust the RAM weight multiplier to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.742.1">
       1
      </span>
     </strong>
     <span class="koboSpan" id="kobo.743.1">
      .
     </span>
     <span class="koboSpan" id="kobo.743.2">
      This way, the launch of a new instance will be spread evenly between compute nodes with
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.744.1">
       free memory:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.745.1">
ram_weight_multiplier = 1.0</span></pre>
    </li>
   </ol>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.746.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.747.1">
     Setting up a weighted multiple as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.748.1">
      1.0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.749.1">
     will spread the resource allocation across all available filter hosts.
    </span>
    <span class="koboSpan" id="kobo.749.2">
     If the stacking option is the preferred option, set the associate value of the weight multiplier to a value
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.750.1">
      of
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.751.1">
       -1
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.752.1">
      .
     </span>
    </span>
   </p>
   <ol>
    <li value="6">
     <span class="koboSpan" id="kobo.753.1">
      Add a new multiplier to calculate the weighting host I/O operations.
     </span>
     <span class="koboSpan" id="kobo.753.2">
      Instruct Nova to use the active hosts
     </span>
     <a id="_idIndexMarker420">
     </a>
     <span class="koboSpan" id="kobo.754.1">
      evenly with the least I/O CPU metric by setting its weight multiplier to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.755.1">
       1.0
      </span>
     </strong>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.756.1">
       as follows:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.757.1">
io_ops_weight_multiplier = 1.0</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.758.1">
      Restart the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.759.1">
       nova-scheduler
      </span>
     </strong>
     <span class="koboSpan" id="kobo.760.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.761.1">
       nova-compute
      </span>
     </strong>
     <span class="koboSpan" id="kobo.762.1">
      services in the controller node and each compute node to apply
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.763.1">
       the changes:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.764.1"># service nova-compute restart</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.765.1"># service nova-scheduler restart</span></strong></pre>
    </li>
   </ol>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.766.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.767.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.768.1">
      kolla-ansible
     </span>
    </strong>
    <span class="koboSpan" id="kobo.769.1">
     repository does not, by default, provide a low-level configuration for Nova weighting policies.
    </span>
    <span class="koboSpan" id="kobo.769.2">
     It is possible to adjust the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.770.1">
      nova.conf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.771.1">
     template file located at
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.772.1">
      /kolla-ansible/ansible/roles/nova/templates/nova.conf.j2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.773.1">
     by adding the configuration lines described previously.
    </span>
    <span class="koboSpan" id="kobo.773.2">
     It is also recommended to cast an eye on the latest supported
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.774.1">
      nova.conf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.775.1">
     settings, as defined here for the latest
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.776.1">
      release:
     </span>
    </span>
    <a href="https://docs.openstack.org/nova/latest/configuration/sample-config.html">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.777.1">
       https://docs.openstack.org/nova/latest/configuration/sample-config.html
      </span>
     </span>
    </a>
   </p>
   <p>
    <span class="koboSpan" id="kobo.778.1">
     The OpenStack Bobcat release introduces a new scheduler weigher,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.779.1">
      NumInstancesWeigher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.780.1">
     , which is handy for dispatching instances based on the number of active instances each compute node is hosting.
    </span>
    <span class="koboSpan" id="kobo.780.2">
     As demonstrated in the previous example, setting the multiplier value to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.781.1">
      1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.782.1">
     will enable a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.783.1">
      packing
     </span>
    </strong>
    <span class="koboSpan" id="kobo.784.1">
     strategy by favoring the host with the most number
    </span>
    <a id="_idIndexMarker421">
    </a>
    <span class="koboSpan" id="kobo.785.1">
     of active instances.
    </span>
    <span class="koboSpan" id="kobo.785.2">
     A value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.786.1">
      -1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.787.1">
     will favor a spreading strategy by checking the least busy host in terms of active instances.
    </span>
    <span class="koboSpan" id="kobo.787.2">
     A full list of different weighers can be found
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.788.1">
      at
     </span>
    </span>
    <a href="https://docs.openstack.org/nova/latest/admin/scheduling.html#weights">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.789.1">
       https://docs.openstack.org/nova/latest/admin/scheduling.html#weights
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.790.1">
      .
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-96">
    <a id="_idTextAnchor141">
    </a>
    <span class="koboSpan" id="kobo.791.1">
     Extending compute for containers
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.792.1">
     Since 2014, the OpenStack community has been developing additional projects around containerization technology, allowing cloud users to leverage different sets of services to run applications on top of the compute service.
    </span>
    <span class="koboSpan" id="kobo.792.2">
     The most mature and in-production services are
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.793.1">
      Magnum
     </span>
    </strong>
    <span class="koboSpan" id="kobo.794.1">
     and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.795.1">
      Zun
     </span>
    </strong>
    <span class="koboSpan" id="kobo.796.1">
     , which we will
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.797.1">
      cover next.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-97">
    <a id="_idTextAnchor142">
    </a>
    <span class="koboSpan" id="kobo.798.1">
     Magnum
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.799.1">
     The main motivation to run a
    </span>
    <a id="_idIndexMarker422">
    </a>
    <span class="koboSpan" id="kobo.800.1">
     containerized environment is to run and deploy an application with minimal configuration complexity that’s portable and requires the least maintenance effort.
    </span>
    <span class="koboSpan" id="kobo.800.2">
     Running workloads that are composed of many containers requires a layer of orchestration to manage the logic of the life cycle of different components, as well as inter-communication, in an automated fashion.
    </span>
    <span class="koboSpan" id="kobo.800.3">
     This is referred to as a container cluster
    </span>
    <a id="_idIndexMarker423">
    </a>
    <span class="koboSpan" id="kobo.801.1">
     management
    </span>
    <a id="_idIndexMarker424">
    </a>
    <span class="koboSpan" id="kobo.802.1">
     platform, such as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.803.1">
      Mesos
     </span>
    </strong>
    <span class="koboSpan" id="kobo.804.1">
     ,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.805.1">
      Kubernetes
     </span>
    </strong>
    <span class="koboSpan" id="kobo.806.1">
     , and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.807.1">
      Docker Swarm
     </span>
    </strong>
    <span class="koboSpan" id="kobo.808.1">
     , to name a few.
    </span>
    <span class="koboSpan" id="kobo.808.2">
     There
    </span>
    <a id="_idIndexMarker425">
    </a>
    <span class="koboSpan" id="kobo.809.1">
     are some well-known
    </span>
    <a id="_idIndexMarker426">
    </a>
    <span class="koboSpan" id="kobo.810.1">
     public cloud
    </span>
    <a id="_idIndexMarker427">
    </a>
    <span class="koboSpan" id="kobo.811.1">
     services, such as
    </span>
    <a id="_idIndexMarker428">
    </a>
    <span class="koboSpan" id="kobo.812.1">
     AWS
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.813.1">
      Elastic Container Service
     </span>
    </strong>
    <span class="koboSpan" id="kobo.814.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.815.1">
      ECS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.816.1">
     ), AWS
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.817.1">
      Elastic Kubernetes Service
     </span>
    </strong>
    <span class="koboSpan" id="kobo.818.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.819.1">
      EKS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.820.1">
     ), GCP
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.821.1">
      Google Kubernetes Engine
     </span>
    </strong>
    <span class="koboSpan" id="kobo.822.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.823.1">
      GKE
     </span>
    </strong>
    <span class="koboSpan" id="kobo.824.1">
     ), and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.825.1">
      Azure Kubernetes Service
     </span>
    </strong>
    <span class="koboSpan" id="kobo.826.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.827.1">
      AKS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.828.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.828.2">
     In the OpenStack world, Magnum is
    </span>
    <a id="_idIndexMarker429">
    </a>
    <span class="koboSpan" id="kobo.829.1">
     the project code name that has been integrated into the
    </span>
    <a id="_idIndexMarker430">
    </a>
    <span class="koboSpan" id="kobo.830.1">
     OpenStack ecosystem and is referred to as a COE.
    </span>
    <span class="koboSpan" id="kobo.830.2">
     Like any other OpenStack service, Magnum exposes an API to interact with COEs as first-class resources, such as Kubernetes and Docker Swarm.
    </span>
    <span class="koboSpan" id="kobo.830.3">
     Containers will be deployed and run on top of the hypervisor nodes.
    </span>
    <span class="koboSpan" id="kobo.830.4">
     The exposure to different container engines unlocks cloud operators to offer an array of choices for users to select from, as illustrated in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.831.1">
      following diagram:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer063">
     <span class="koboSpan" id="kobo.832.1">
      <img alt="Figure 4.11 – The OpenStack Magnum multi-COE architecture" src="image/B21716_04_11.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.833.1">
     Figure 4.11 – The OpenStack Magnum multi-COE architecture
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.834.1">
     Magnum refers to each
    </span>
    <a id="_idIndexMarker431">
    </a>
    <span class="koboSpan" id="kobo.835.1">
     collection of COE nodes and their associated containers using the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.836.1">
      following terminologies:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.837.1">
       Bay
      </span>
     </strong>
     <span class="koboSpan" id="kobo.838.1">
      : This is a set of nodes running a COE.
     </span>
     <span class="koboSpan" id="kobo.838.2">
      At the heart of the bay run, Magnum calls the Heat service to
     </span>
     <a id="_idIndexMarker432">
     </a>
     <span class="koboSpan" id="kobo.839.1">
      deploy the bay.
     </span>
     <span class="koboSpan" id="kobo.839.2">
      Bays are simply a collection of Nova instances created and orchestrated by Heat using images that target both virtual machines and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.840.1">
       bare-metal ones.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.841.1">
       BayModel
      </span>
     </strong>
     <span class="koboSpan" id="kobo.842.1">
      : This is a collection of resources that constructs a bay defined in a simple template.
     </span>
     <span class="koboSpan" id="kobo.842.2">
      A bay can
     </span>
     <a id="_idIndexMarker433">
     </a>
     <span class="koboSpan" id="kobo.843.1">
      use the same
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.844.1">
       BayModel
      </span>
     </strong>
     <span class="koboSpan" id="kobo.845.1">
      template to run across
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.846.1">
       different COEs.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.847.1">
       Pod
      </span>
     </strong>
     <span class="koboSpan" id="kobo.848.1">
      : This is a group of
     </span>
     <a id="_idIndexMarker434">
     </a>
     <span class="koboSpan" id="kobo.849.1">
      containers running on the same
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.850.1">
       COE node.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.851.1">
       Service
      </span>
     </strong>
     <span class="koboSpan" id="kobo.852.1">
      : This is an abstraction of an
     </span>
     <a id="_idIndexMarker435">
     </a>
     <span class="koboSpan" id="kobo.853.1">
      arrangement of bays and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.854.1">
       access policies.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.855.1">
       Replication controller
      </span>
     </strong>
     <span class="koboSpan" id="kobo.856.1">
      : This is a dedicated process for monitoring, replicating, re-spawning failed containers, and
     </span>
     <a id="_idIndexMarker436">
     </a>
     <span class="koboSpan" id="kobo.857.1">
      scaling pods across
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.858.1">
       COE nodes.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.859.1">
       Magnum client
      </span>
     </strong>
     <span class="koboSpan" id="kobo.860.1">
      : This is a native
     </span>
     <a id="_idIndexMarker437">
     </a>
     <span class="koboSpan" id="kobo.861.1">
      client to query the COE that comes with the native
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.862.1">
       Docker CLI
      </span>
     </strong>
     <span class="koboSpan" id="kobo.863.1">
      for the Docker COE and
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.864.1">
       kubectl
      </span>
     </strong>
     <span class="koboSpan" id="kobo.865.1">
      for the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.866.1">
       Kubernetes COE.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.867.1">
     Other emerging keys to Magnum’s success are the functions that are well integrated with other OpenStack services, which are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.868.1">
      listed here:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.869.1">
       Identity
      </span>
     </strong>
     <span class="koboSpan" id="kobo.870.1">
      : This is an integration with Keystone for managing the authentication and authorization of the
     </span>
     <a id="_idIndexMarker438">
     </a>
     <span class="koboSpan" id="kobo.871.1">
      container cluster platform – for example, creating Kubernetes roles for users to run operational tasks on a cluster
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.872.1">
       via Keystone.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.873.1">
       Networking
      </span>
     </strong>
     <span class="koboSpan" id="kobo.874.1">
      : The Neutron service is leveraged through supported networking drivers – for example, the
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.875.1">
       Flannel
      </span>
     </strong>
     <span class="koboSpan" id="kobo.876.1">
      overlay network is
     </span>
     <a id="_idIndexMarker439">
     </a>
     <span class="koboSpan" id="kobo.877.1">
      the default one for both the Kubernetes and Swarm COEs, allowing multi-host communication and managing the IP addresses of containers in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.878.1">
       each bay.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.879.1">
       Imaging
      </span>
     </strong>
     <span class="koboSpan" id="kobo.880.1">
      : A prebuilt Glance image is provided to the Kubernetes and Swarm COEs, which can be configured and used to launch the nodes in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.881.1">
       the cluster.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.882.1">
       Storage
      </span>
     </strong>
     <span class="koboSpan" id="kobo.883.1">
      : The official supported storage is provided by Cinder as block storage in two forms: ephemeral and persistent storage options.
     </span>
     <span class="koboSpan" id="kobo.883.2">
      Aside from the Docker storage driver, Cinder also comes with additional backend storage such as
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.884.1">
       Rexray
      </span>
     </strong>
     <span class="koboSpan" id="kobo.885.1">
      as the volume driver.
     </span>
     <span class="koboSpan" id="kobo.885.2">
      At the time
     </span>
     <a id="_idIndexMarker440">
     </a>
     <span class="koboSpan" id="kobo.886.1">
      of writing this, Cinder only supports the Rexray driver for Swarm and the default Cinder
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.887.1">
       for Kubernetes.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.888.1">
     Other main highlights of Magnum that have been initiated or are in progress can be summarized
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.889.1">
      as follows:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.890.1">
       Security posture
      </span>
     </strong>
     <span class="koboSpan" id="kobo.891.1">
      : The Magnum architecture is secure by design.
     </span>
     <span class="koboSpan" id="kobo.891.2">
      Each bay is isolated from others, providing security
     </span>
     <a id="_idIndexMarker441">
     </a>
     <span class="koboSpan" id="kobo.892.1">
      for the workloads they host.
     </span>
     <span class="koboSpan" id="kobo.892.2">
      Additionally, Magnum enables a multi-tenancy layout by preventing bays from being shared between
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.893.1">
       OpenStack tenants.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.894.1">
       Scalability
      </span>
     </strong>
     <span class="koboSpan" id="kobo.895.1">
      : The scaling of the cluster nodes is performed automatically by adjusting the Heat template attributes or manually via the OpenStack COE CLI.
     </span>
     <span class="koboSpan" id="kobo.895.2">
      Note that container scaling will depend on the cluster container configuration as per
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.896.1">
       the COE.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.897.1">
       High availability
      </span>
     </strong>
     <span class="koboSpan" id="kobo.898.1">
      : At the time of writing this, the Magnum high availability criteria supports only one default Availability Zone.
     </span>
     <span class="koboSpan" id="kobo.898.2">
      The group of compute nodes will be spawned in the same logical Availability Zone.
     </span>
     <span class="koboSpan" id="kobo.898.3">
      The OpenStack community is considering enlarging the span of Magnum cluster nodes across more multi-Availability Zones in the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.899.1">
       next releases.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.900.1">
     Since the Liberty release, the Magnum service has received a lot of credit due to its exposure to an array of COEs and maturity, which can be seen in dozens of production workloads.
    </span>
    <span class="koboSpan" id="kobo.900.2">
     The service has
    </span>
    <a id="_idIndexMarker442">
    </a>
    <span class="koboSpan" id="kobo.901.1">
     enabled engineering and architect teams to migrate to microservice-based architecture without the need to redesign and re-integrate the existing container toolsets.
    </span>
    <span class="koboSpan" id="kobo.901.2">
     Other enhancements have been captured and can be followed by checking the release updates
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.902.1">
      at
     </span>
    </span>
    <a href="https://docs.openstack.org/magnum/latest/">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.903.1">
       https://docs.openstack.org/magnum/latest/
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.904.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.905.1">
     The Magnum service is not enabled by default in the current
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.906.1">
      kolla-ansible
     </span>
    </strong>
    <span class="koboSpan" id="kobo.907.1">
     infrastructure code repository.
    </span>
    <span class="koboSpan" id="kobo.907.2">
     Setting
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.908.1">
      enable_magnum
     </span>
    </strong>
    <span class="koboSpan" id="kobo.909.1">
     to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.910.1">
      yes
     </span>
    </strong>
    <span class="koboSpan" id="kobo.911.1">
     in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.912.1">
      /kolla-ansible/etc/kolla/globals.yml
     </span>
    </strong>
    <span class="koboSpan" id="kobo.913.1">
     file will enable the Magnum API service.
    </span>
    <span class="koboSpan" id="kobo.913.2">
     Make sure to update the inventory file created in the previous chapter,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.914.1">
      /ansible/inventory/multi_packtpub
     </span>
    </strong>
    <span class="koboSpan" id="kobo.915.1">
     , by adding the Magnum services, including the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.916.1">
      magnum-api
     </span>
    </strong>
    <span class="koboSpan" id="kobo.917.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.918.1">
      magnum-conductor
     </span>
    </strong>
    <span class="koboSpan" id="kobo.919.1">
     services, in the controller node as in the following configuration
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.920.1">
      stanza code:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.921.1">
…
[magnum:children]
control
[magnum-api:children]
magnum
[magnum-conductor:children]
magnum
…</span></pre>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.922.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.923.1">
     More Magnum configuration options are listed in the Ansible playbook, under the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.924.1">
      /kolla-ansible/ansible/roles/magnum/default/main.yml
     </span>
    </strong>
    <span class="koboSpan" id="kobo.925.1">
     file.
    </span>
    <span class="koboSpan" id="kobo.925.2">
     Additionally, Horizon supports the Magnum panel in the dashboard, which is disabled by default and can be added by setting
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.926.1">
      enable_horizon_magnum
     </span>
    </strong>
    <span class="koboSpan" id="kobo.927.1">
     to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.928.1">
      yes
     </span>
    </strong>
    <span class="koboSpan" id="kobo.929.1">
     in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.930.1">
      /
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.931.1">
       kolla-ansible/etc/kolla/
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.932.1">
       globals
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.933.1">
       .yml
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.934.1">
      file.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.935.1">
     Once both files are updated, run the CI/CD pipeline to roll out the Magnum Ansible playbooks and provide the
    </span>
    <a id="_idIndexMarker443">
    </a>
    <span class="koboSpan" id="kobo.936.1">
     Magnum service containers as part of the control plane in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.937.1">
      OpenStack environment.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-98">
    <a id="_idTextAnchor143">
    </a>
    <span class="koboSpan" id="kobo.938.1">
     Zun
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.939.1">
     Beyond the Magnum service and its multitude of container orchestration support options, there is the Zun service – a very simple service to run containers quickly in OpenStack without the need to
    </span>
    <a id="_idIndexMarker444">
    </a>
    <span class="koboSpan" id="kobo.940.1">
     manage or deploy a container orchestration environment based on Kubernetes Pods or Docker Swarm clusters.
    </span>
    <span class="koboSpan" id="kobo.940.2">
     You can simply fire a Zun command line to create any type of container for any Docker repository and run your workload.
    </span>
    <span class="koboSpan" id="kobo.940.3">
     To resolve any confusion between Magnum and Zun use cases, the latter is dedicated to managing and operating containers through OpenStack directly without the need to interface with an additional orchestration toolset layer of a COE such as Kubernetes or Swarm, unlike the Magnum service.
    </span>
    <span class="koboSpan" id="kobo.940.4">
     Another potential source of confusion is the difference between Zun and the former OpenStack container originator, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.941.1">
      nova-docker
     </span>
    </strong>
    <span class="koboSpan" id="kobo.942.1">
     service.
    </span>
    <span class="koboSpan" id="kobo.942.2">
     While
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.943.1">
      nova-docker
     </span>
    </strong>
    <span class="koboSpan" id="kobo.944.1">
     relies on the Nova API service to manage containers, Zun is independent of the Nova API and leverages its fully featured API interface to create and operate containers.
    </span>
    <span class="koboSpan" id="kobo.944.2">
     The Zun service is well integrated with a number of versatile OpenStack services, including Nova, Glance, Keystone, Neutron, Cinder, Ceilometer, and Magnum, as illustrated in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.945.1">
      following diagram:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer064">
     <span class="koboSpan" id="kobo.946.1">
      <img alt="Figure 4.12 – The OpenStack Zun compute integration" src="image/B21716_04_12.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.947.1">
     Figure 4.12 – The OpenStack Zun compute integration
    </span>
   </p>
   <p>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.948.1">
       Figure 4
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.949.1">
      .12
     </span>
    </em>
    <span class="koboSpan" id="kobo.950.1">
     exposes two additional services that Zun compute uses and runs in tandem with Neutron and Cinder, respectively summarized
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.951.1">
      as follows:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.952.1">
       Kuryr
      </span>
     </strong>
     <span class="koboSpan" id="kobo.953.1">
      : This integrates with Neutron to provide
     </span>
     <a id="_idIndexMarker445">
     </a>
     <span class="koboSpan" id="kobo.954.1">
      advanced networking features for containers
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.955.1">
       through
      </span>
     </span>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.956.1">
        libnetwork
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.957.1">
       .
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.958.1">
       Fuxi
      </span>
     </strong>
     <span class="koboSpan" id="kobo.959.1">
      : This leverages the
     </span>
     <a id="_idIndexMarker446">
     </a>
     <span class="koboSpan" id="kobo.960.1">
      Docker API to manage volumes backed by Cinder and Manila
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.961.1">
       storage services.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.962.1">
     The Zun service is not
    </span>
    <a id="_idIndexMarker447">
    </a>
    <span class="koboSpan" id="kobo.963.1">
     enabled by default in the current
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.964.1">
      kolla-ansible
     </span>
    </strong>
    <span class="koboSpan" id="kobo.965.1">
     infrastructure code repository.
    </span>
    <span class="koboSpan" id="kobo.965.2">
     To enable the service, the following settings should be adjusted in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.966.1">
      /kolla-ansible/etc/kolla/globals.yml
     </span>
    </strong>
    <span class="koboSpan" id="kobo.967.1">
     file
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.968.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.969.1">
...
</span><span class="koboSpan" id="kobo.969.2">enable_zun: "yes"
enable_kuryr: "yes"
enable_etcd: "yes"
docker_configure_for_zun: "yes"
containerd_configure_for_zun: "yes"
...</span></pre>
   <p>
    <span class="koboSpan" id="kobo.970.1">
     Make sure to update the inventory file created in the previous chapter,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.971.1">
      /ansible/inventory/ multi_packtpub
     </span>
    </strong>
    <span class="koboSpan" id="kobo.972.1">
     , by adding the Zun services, including
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.973.1">
      zun-api
     </span>
    </strong>
    <span class="koboSpan" id="kobo.974.1">
     and optionally
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.975.1">
      zun-wsproxy
     </span>
    </strong>
    <span class="koboSpan" id="kobo.976.1">
     , as part of the control plane
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.977.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.978.1">
…
[zun:children]
control
[zun-api:children]
zun
[zun-wsproxy:children]
zun</span></pre>
   <p>
    <span class="koboSpan" id="kobo.979.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.980.1">
      zun-compute
     </span>
    </strong>
    <span class="koboSpan" id="kobo.981.1">
     and optionally
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.982.1">
      zun-cni-daemon
     </span>
    </strong>
    <span class="koboSpan" id="kobo.983.1">
     services can be added as part of the compute node as
    </span>
    <a id="_idIndexMarker448">
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.984.1">
      depicted here:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.985.1">
...
</span><span class="koboSpan" id="kobo.985.2">[zun-compute:children]
compute
[zun-cni-daemon:children]
compute
…</span></pre>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.986.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.987.1">
     More Zun configuration options are listed in the Ansible playbook under the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.988.1">
      /kolla-ansible/ansible/roles/zun/default/main.yml
     </span>
    </strong>
    <span class="koboSpan" id="kobo.989.1">
     file.
    </span>
    <span class="koboSpan" id="kobo.989.2">
     Additionally, Horizon supports the Magnum panel in the dashboard, which is disabled by default and can be added by setting
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.990.1">
      enable_horizon_zun
     </span>
    </strong>
    <span class="koboSpan" id="kobo.991.1">
     to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.992.1">
      yes
     </span>
    </strong>
    <span class="koboSpan" id="kobo.993.1">
     in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.994.1">
      /
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.995.1">
       kolla-ansible/etc/kolla/globals.yml
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.996.1">
      file.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.997.1">
     Once both files are updated, run the CI/CD pipeline to roll out the Magnum Ansible playbooks.
    </span>
    <span class="koboSpan" id="kobo.997.2">
     The Zun service and its associated processes will be launched in containers as part of the control plane in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.998.1">
      OpenStack environment.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.999.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.1000.1">
     Make sure to double-check that the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1001.1">
      etcd
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1002.1">
     daemon is running on the controller node.
    </span>
    <span class="koboSpan" id="kobo.1002.2">
     Similarly, ensure that the Docker runtime and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1003.1">
      kuryr-libnetwork
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1004.1">
     are properly installed in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1005.1">
      compute node.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1006.1">
     Check that the Zun service
    </span>
    <a id="_idIndexMarker449">
    </a>
    <span class="koboSpan" id="kobo.1007.1">
     can be performed through the Zun service list
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1008.1">
      command line:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.1009.1">
$ openstack appcontainer service list</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1010.1">
     Zun containers should be created in the compute nodes.
    </span>
    <span class="koboSpan" id="kobo.1010.2">
     To list the registered compute nodes for Zun, use the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1011.1">
      command line:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.1012.1">
$ openstack appcontainer create --name container_pp_zun cirros</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1013.1">
     Creating containers using the Zun CLI is straightforward.
    </span>
    <span class="koboSpan" id="kobo.1013.2">
     It is possible to use, by default,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.1014.1">
      Docker Hub
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1015.1">
     to pull images and rapidly run
    </span>
    <a id="_idIndexMarker450">
    </a>
    <span class="koboSpan" id="kobo.1016.1">
     a container in the designated compute node.
    </span>
    <span class="koboSpan" id="kobo.1016.2">
     The following example command line creates a Zun container using a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1017.1">
      CirrOS image:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.1018.1">
$ zun create --name container_pp_zun cirros</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1019.1">
     An amazing hands-on feature brought by Zun is the flexibility to manage a container’s life cycle by using the native Docker API or the Zun API itself.
    </span>
    <span class="koboSpan" id="kobo.1019.2">
     For example, attaching a terminal to a running container can be performed by running
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1020.1">
      openstack appcontainer attach &lt;container_name&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1021.1">
     in a similar way to firing a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1022.1">
      docker attach
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1023.1">
      command line.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-99">
    <a id="_idTextAnchor144">
    </a>
    <span class="koboSpan" id="kobo.1024.1">
     Expanding the compute farm
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.1025.1">
     Managing the compute fleet hypervisors through
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1026.1">
      kolla-ansible
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1027.1">
     to spawn instances or containers is straightforward.
    </span>
    <span class="koboSpan" id="kobo.1027.2">
     After collecting your compute requirements, hardware capacity, types of workloads, and scheduling strategies, adding a compute node can be performed on the fly without incurring a complex operation overhead.
    </span>
    <span class="koboSpan" id="kobo.1027.3">
     The main requirements that should be considered are the listing of compute services – mainly,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1028.1">
      nova-compute
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1029.1">
     and a networking plugin agent to provide connectivity with the control plane and sync with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1030.1">
      nova-scheduler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1031.1">
     for each resource allocation.
    </span>
    <span class="koboSpan" id="kobo.1031.2">
     The previous section
    </span>
    <a id="_idIndexMarker451">
    </a>
    <span class="koboSpan" id="kobo.1032.1">
     demonstrated that additional components can be part of the compute node, including the Zun compute service, if you’re planning to offer an easy and quick container playground to end users.
    </span>
    <span class="koboSpan" id="kobo.1032.2">
     Another aspect of managing compute nodes from code through
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1033.1">
      kolla-ansible
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1034.1">
     is listing the available configuration options of the compute service, such as overcommitment ratios for CPU and memory, covered in
    </span>
    <a href="B21716_01.xhtml#_idTextAnchor014">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1035.1">
        Chapter 1
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.1036.1">
     ,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1037.1">
      Revisiting OpenStack – Design Considerations
     </span>
    </em>
    <span class="koboSpan" id="kobo.1038.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1038.2">
     As you might deploy several compute nodes with different configurations,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1039.1">
      kolla-ansible
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1040.1">
     provides ways to customize compute service configuration and override configuration with the global configuration defined in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1041.1">
      /etc/kolla/globals.yml
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1042.1">
     file.
    </span>
    <span class="koboSpan" id="kobo.1042.2">
     The following example will instruct Kolla to add a new compute host named
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1043.1">
      cn02.os.packtpub
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1044.1">
     (24 CPUs and 255 GB of RAM) with custom configuration supporting QEMU as a hypervisor, and a CPU and RAM overcommitment ratio of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1045.1">
      8.0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1046.1">
     and
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1047.1">
       4.0
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1048.1">
      , respectively:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.1049.1">
      First, let’s start by populating the hostname in the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1050.1">
       inventory file:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1051.1">
…
[compute]
…
cn02.os.packtpub</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1052.1">
      Create a new
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1053.1">
       nova.conf
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1054.1">
      file under
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1055.1">
       /etc/kolla/config/nova/cn02.os.packtpub/
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1056.1">
      .
     </span>
     <span class="koboSpan" id="kobo.1056.2">
      Kolla looks for any possible config file under
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1057.1">
       /etc/kolla/
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1058.1">
      .
     </span>
     <span class="koboSpan" id="kobo.1058.2">
      If one is found, Kolla will override and merge the global one with the custom settings provided in a separate file.
     </span>
     <span class="koboSpan" id="kobo.1058.3">
      Note that you will need to create the path directories in the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1059.1">
       kolla-ansible
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1060.1">
      repository, including the hostname of the compute node, following the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1061.1">
       /etc/kolla/config/nova/COMPUTE_HOSTNAME/nova.conf
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1062.1">
      format, wherein
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1063.1">
       COMPUTE_HOSTNAME
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1064.1">
      is the hostname of the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1065.1">
       compute node.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1066.1">
      Edit the newly created
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1067.1">
       nova.conf
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1068.1">
      file by adding the CPU and RAM allocation ratio values of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1069.1">
       8.0
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1070.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1071.1">
       4.0
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1072.1">
      , respectively, in a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1073.1">
       new section:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1074.1">
[DEFAULT]
cpu_allocation_ratio = 8.0
ram_allocation_ratio = 4.0</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1075.1">
      Add to the same file the
     </span>
     <a id="_idIndexMarker452">
     </a>
     <span class="koboSpan" id="kobo.1076.1">
      desired
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1077.1">
       qemu
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1078.1">
      hypervisor to run on the new
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1079.1">
       compute node:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1080.1">
...
</span><span class="koboSpan" id="kobo.1080.2">[libvirt]
virt_type=qemu
cpu_mode = none</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1081.1">
      It is possible to overwrite the default scheduler by forcing a set of filters and using the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1082.1">
       ComputeCapabilitiesFilter
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1083.1">
      filter to use any host with total available RAM for users of more than
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1084.1">
       250,000 MB:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1085.1">
...
</span><span class="koboSpan" id="kobo.1085.2">[filter_scheduler]
enabled_filters = ComputeFilter,ComputeCapabilitiesFilter,
ImagePropertiesFilter,ServerGroupAntiAffinityFilter,
ServerGroupAffinityFilter</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1086.1">
      Optionally, you can use the filtering strategy for RAM criteria by stacking instances in the same host with a defined flavor.
     </span>
     <span class="koboSpan" id="kobo.1086.2">
      That way, you can make sure that the compute node will exactly accommodate a defined number of instances with specific flavors that you can predict in advance.
     </span>
     <span class="koboSpan" id="kobo.1086.3">
      By doing so, the 250 GB of RAM can be used fully without leaving smaller slots that would otherwise lay unused.
     </span>
     <span class="koboSpan" id="kobo.1086.4">
      The way to go
     </span>
     <a id="_idIndexMarker453">
     </a>
     <span class="koboSpan" id="kobo.1087.1">
      in this case is the stacking strategy, by defining a negative weight multiplier in the same
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1088.1">
       custom nova.conf
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1089.1">
      file
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1090.1">
       as follows:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1091.1">
...
</span><span class="koboSpan" id="kobo.1091.2">weight_classes nova.scheduler.weights.all_weighers
ram_weight_multiplier -1.0</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1092.1">
      Using your CI/CD pipeline, trigger the run job to deploy the code in the staging environment, as demonstrated in the previous chapters, before merging to the production branch.
     </span>
     <span class="koboSpan" id="kobo.1092.2">
      The deployment stage should provision the new additional Kolla containers in the new compute node and start syncing with the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1093.1">
       control plane.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1094.1">
      An example of resource allocation inspired by the filtering strategy covered in this chapter and
     </span>
     <a href="B21716_01.xhtml#_idTextAnchor014">
      <span class="No-Break">
       <em class="italic">
        <span class="koboSpan" id="kobo.1095.1">
         Chapter 1
        </span>
       </em>
      </span>
     </a>
     <span class="koboSpan" id="kobo.1096.1">
      ,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1097.1">
       Revisiting OpenStack – Design Considerations
      </span>
     </em>
     <span class="koboSpan" id="kobo.1098.1">
      is to dispatch a specific flavor of instances to a dedicated compute node.
     </span>
     <span class="koboSpan" id="kobo.1098.2">
      For example, a cloud operator would use the scheduler filter described in
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1099.1">
       step 5
      </span>
     </em>
     <span class="koboSpan" id="kobo.1100.1">
      to provision instances only with medium-sized allocation requests.
     </span>
     <span class="koboSpan" id="kobo.1100.2">
      For that to take effect, run the following command line in the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1101.1">
       controller node:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1102.1">$ openstack flavor set m1.medium --property total_usable_ram_mb="&gt;= 250000"</span></strong></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.1103.1">
       The enabled
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1104.1">
        ComputeCapabilitiesFilter
       </span>
      </strong>
      <span class="koboSpan" id="kobo.1105.1">
       filter should match any compute node attributes with a flavor, as defined against its usable amount of memory attribute for a specific instance flavor.
      </span>
      <span class="koboSpan" id="kobo.1105.2">
       If the available amount of RAM in the first compute node is below 250, a new instance request of the
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1106.1">
        m1.medium
       </span>
      </strong>
      <span class="koboSpan" id="kobo.1107.1">
       size will likely be dispatched by the scheduler on the new compute node that has freshly joined the compute
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1108.1">
        node farm.
       </span>
      </span>
     </p>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.1109.1">
     By the end of the previous steps, a new compute node should join the OpenStack compute cluster with advanced
    </span>
    <a id="_idIndexMarker454">
    </a>
    <span class="koboSpan" id="kobo.1110.1">
     scheduling configured based on filter and weighting mechanisms.
    </span>
    <span class="koboSpan" id="kobo.1110.2">
     Any new compute request with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1111.1">
      m1.medium
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1112.1">
     flavor will be launched in the new compute node if the amount of RAM available is at least
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1113.1">
      250 GB.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-100">
    <a id="_idTextAnchor145">
    </a>
    <span class="koboSpan" id="kobo.1114.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.1115.1">
     In this chapter, we looked at some powerful capabilities and additional features brought by the Nova service.
    </span>
    <span class="koboSpan" id="kobo.1115.2">
     You should be acquainted with the vast array of choices given by the latest updates in the compute services – from the variety of supported hypervisor technologies, to compute and workload segregation, to the art of filtering.
    </span>
    <span class="koboSpan" id="kobo.1115.3">
     Scheduling in OpenStack is a key element that cloud operators should pay special attention to when dealing with growing infrastructure and high demand for resources.
    </span>
    <span class="koboSpan" id="kobo.1115.4">
     Although we did not cover all possible scenarios, the filtering mechanism was introduced in the early days of the Nova project, and this chapter demonstrated that an extension to deploy compute power beyond a limited perimeter has since become possible.
    </span>
    <span class="koboSpan" id="kobo.1115.5">
     Thanks to the new, mature version of Nova CellV2, the host aggregation and Availability Zone concepts enable massive deployments if planned and designed properly, as we learned.
    </span>
    <span class="koboSpan" id="kobo.1115.6">
     At the end of the chapter, both Magnum and Zun were covered as popular container projects within the OpenStack ecosystem.
    </span>
    <span class="koboSpan" id="kobo.1115.7">
     We learned that cloud users can run native container applications driven by Magnum as a COE and Zun as a simple container API that’s well integrated with different core services around the OpenStack ecosystem.
    </span>
    <span class="koboSpan" id="kobo.1115.8">
     Furthermore, we learned that adopting microservice prototypes and running native cloud applications is no longer a challenge for an OpenStack user.
    </span>
    <span class="koboSpan" id="kobo.1115.9">
     With the continuous development of those services, enterprises can adopt a hybrid environment between private and public clouds not only due to the portability and flexibility of the containers but also because OpenStack has proven its capability to be in the container race with the other public cloud players.
    </span>
    <span class="koboSpan" id="kobo.1115.10">
     We discussed this in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1116.1">
      this chapter.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1117.1">
     Nova is not the only service that has seen some updates.
    </span>
    <span class="koboSpan" id="kobo.1117.2">
     Storage services including file share, block, and object storage have been empowered with additional features, which we will cover in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1118.1">
      next chapter.
     </span>
    </span>
   </p>
  </div>
 </body></html>