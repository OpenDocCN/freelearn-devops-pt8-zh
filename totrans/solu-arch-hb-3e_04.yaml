- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Solution Architecture Design Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案架构设计模式
- en: Have you ever wondered how large enterprises design scalable systems? Before
    starting application development, solutions architects work across organizations
    and weigh multiple options to develop architecture designs to handle their business
    needs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾想过大型企业是如何设计可扩展的系统的？在开始应用开发之前，解决方案架构师需要跨组织工作，权衡多个选项，制定架构设计以应对业务需求。
- en: There are multiple ways to design a solution. A solutions architect needs to
    take the right approach based on user requirements and the architecture constraints
    of cost, performance, scalability, and availability. In this chapter, you will
    learn about various solution architecture patterns, reference architectures, and
    how to apply them in real-world scenarios.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 设计解决方案有多种方式。解决方案架构师需要根据用户需求以及成本、性能、可扩展性和可用性等架构约束来选择合适的方法。在本章中，你将了解各种解决方案架构模式、参考架构，以及如何将它们应用于实际场景。
- en: In the previous chapters, you learned about the principles of solution architecture
    design. This chapter is exciting and essential as you can apply your learning
    to various architectural design patterns. In this chapter, you will gain an understanding
    of some of the significant solution architecture patterns, such as layered, event-driven,
    microservice, loosely coupled, service-oriented, and RESTful architectures.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，你学习了解决方案架构设计的原则。本章既激动人心又至关重要，因为你可以将所学应用于各种架构设计模式。在本章中，你将了解一些重要的解决方案架构模式，如分层架构、事件驱动架构、微服务架构、松耦合架构、面向服务架构和RESTful架构。
- en: 'You will learn about the advantages of various architectural designs and look
    at examples demonstrating when to utilize them. You will also gain an understanding
    of architecture design anti-patterns in addition to the following architecture
    design patterns:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你将了解各种架构设计的优势，并查看示例，演示何时使用它们。你还将了解架构设计中的反模式以及以下架构设计模式：
- en: Building an n-tier layered architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建n层架构
- en: Creating a multi-tenant SaaS-based architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基于多租户的SaaS架构
- en: Understanding service-oriented architecture
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解面向服务的架构
- en: RESTful web service architecture
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESTful Web服务架构
- en: Building a cache-based architecture
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建基于缓存的架构
- en: '**Model-View-Controller** (**MVC**) architecture'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型-视图-控制器**（**MVC**）架构'
- en: Building **Domain-Driven Design** (**DDD**)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建**领域驱动设计**（**DDD**）
- en: Understanding the circuit breaker pattern
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解断路器模式
- en: Implementing the bulkhead pattern
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现舱壁模式
- en: Creating a floating IP pattern
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建浮动IP模式
- en: Deploying an application with a container
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用容器部署应用程序
- en: Database handling in application architecture
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用架构中的数据库处理
- en: Clean Architecture
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清洁架构
- en: Avoiding anti-patterns in solution architecture
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免解决方案架构中的反模式
- en: By the end of the chapter, you will know how to optimize your solution architecture
    design and apply best practices, making this chapter the center point and core
    of your learning.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解如何优化你的解决方案架构设计并应用最佳实践，使得本章成为你学习的中心和核心。
- en: Building an n-tier layered architecture
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建n层架构
- en: In *n*-tier architecture (also known as **multitier architecture**), you need
    to apply loosely coupled design principles and attributes of scalability and elasticity.
    In n-tier architecture, you divide your product functions into multiple layers,
    such as presentation, business, database, and services, so that each layer can
    be implemented and scaled independently.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在*n*层架构（也称为**多层架构**）中，你需要应用松耦合设计原则，并具备可扩展性和弹性属性。在n层架构中，你将产品功能划分为多个层次，例如展示层、业务层、数据库层和服务层，使得每个层次可以独立实现和扩展。
- en: With n-tier architecture, adopting new technologies and making development more
    efficient is easy. This layered architecture provides the flexibility to add new
    features in each layer without disturbing the features of other layers. In terms
    of security, you can keep each layer secure and isolated from the others, so if
    one layer gets compromised, the other layers won’t be impacted. Application troubleshooting
    and management also become manageable as you can quickly pinpoint where an issue
    is coming from and which part of the application needs to be troubleshot.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 n 层架构，采用新技术并提高开发效率变得容易。这种分层架构提供了灵活性，可以在每一层中添加新功能，而不影响其他层的功能。在安全性方面，您可以确保每一层都安全且彼此隔离，这样如果一层被攻破，其他层不会受到影响。应用程序故障排除和管理也变得更加可控，因为您可以快速定位问题所在，并明确需要进行故障排除的应用程序部分。
- en: 'The most common architecture in multilayer design is **three-tier architecture**,
    so let’s learn more about it. The following diagram shows an AWS example architecture
    that allows you to interact with a web application from the browser and perform
    the required functions, for example, ordering your favorite T-shirt or reading
    a blog and leaving a comment:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的多层设计架构是**三层架构**，所以让我们进一步了解它。以下图示展示了一个 AWS 示例架构，允许您通过浏览器与 web 应用程序进行交互，并执行所需功能，例如订购您喜欢的
    T 恤或阅读博客并留言：
- en: '![](img/B21336_04_01.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21336_04_01.png)'
- en: 'Figure 4.1: Three-tier website architecture'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：三层网站架构
- en: 'In the preceding architecture, you have the following three layers:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述架构中，您有以下三层：
- en: '**Web Layer**: The web layer is the user-facing part of the application. End
    users interact with the web layer to collect or provide information.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络层**：网络层是应用程序的面向用户部分。最终用户通过网络层与应用程序互动，以收集或提供信息。'
- en: '**Application Layer**: The application layer mainly contains business logic
    and acts upon information received from the web layer.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用层**：应用层主要包含业务逻辑，并根据从网络层接收到的信息进行处理。'
- en: '**Database Layer**: All kinds of user data and application data are stored
    in the database layer.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库层**：所有类型的用户数据和应用数据都存储在数据库层中。'
- en: Let’s take a look at these layers in more detail.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看一下这些层次。
- en: The web layer
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络层
- en: The web layer is also known as the **presentation tier**. The web layer provides
    a user interface that helps the end user to interact with the application. The
    web layer is your user interface (in this case, the website page), where the user
    enters information or browses it. Web developers may build a presentation tier
    user interface in technologies such as HTML, CSS, Angular, React, **JavaServer
    Pages** (**JSP**), and **Active Server Pages** (**ASP**). This tier collects the
    information from the user and passes it to the application layer.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层也被称为**表现层**。网络层提供用户界面，帮助最终用户与应用程序进行交互。网络层是你的用户界面（在这个例子中是网站页面），用户在此输入信息或浏览内容。网页开发者可能使用
    HTML、CSS、Angular、React、**JavaServer Pages**（**JSP**）和**Active Server Pages**（**ASP**）等技术来构建表现层用户界面。这个层次从用户处收集信息，并将其传递给应用层。
- en: The web layer is user-facing, so organizations spend most of their time improving
    the user experience. Many organizations have dedicated **User Experience** (**UX**)
    teams researching various areas to understand how users interact with applications.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层是面向用户的，因此组织会花费大部分时间来提升用户体验。许多组织有专门的**用户体验**（**UX**）团队，研究各个领域，以了解用户如何与应用程序互动。
- en: Also, the solutions architect must ensure the architecture design includes UX
    input and page load performance. There should be a seamless information flow between
    the web and application layers to return the correct information to users within
    the expected timeframe, such as user login, profile loading, etc.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，解决方案架构师必须确保架构设计包括用户体验（UX）的输入和页面加载性能。网络层和应用层之间应该有无缝的信息流，以便在预期的时间内将正确的信息返回给用户，例如用户登录、个人资料加载等。
- en: Let’s look at the application layer.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下应用层。
- en: The application layer
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用层
- en: The application layer is also known as the **logic tier**, as this is the core
    of the product where all the business logic resides. The presentation tier collects
    the information from the user and passes it to the logic tier to process it and
    get a result. For example, on an e-commerce website such as Amazon, users can
    enter a date range on the website’s order page to find their order summary. In
    return, the web layer passes the data range information to the application layer.
    The application layer processes the user input to perform business logic, such
    as the count of orders, the sum of amounts, and the number of items purchased.
    This returns information to the web layer to render it for the user.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层也被称为**逻辑层**，因为这是产品的核心，所有业务逻辑都驻留在此。展示层从用户处收集信息并将其传递给逻辑层进行处理，以获取结果。例如，在像 Amazon
    这样的电子商务网站上，用户可以在网站的订单页面输入日期范围，以查找其订单摘要。作为回报，web 层将数据范围信息传递给应用层。应用层处理用户输入以执行业务逻辑，如订单数量、金额总和和购买的商品数量。然后，这些信息返回给
    web 层并呈现给用户。
- en: Generally, in a three-tier architecture, all algorithms and complex logic live
    in the application tier, including creating a recommendation engine or showing
    personalized pages to the user as per their browsing history. You may add layers
    such as a domain layer, data access layer, or presentation layer to make a four-
    or five-tier architecture. Developers may choose to implement this layer in a
    server-side programming language, for example, C++, Java, .NET, or Node.js. The
    application layer is the center of system design and requires most of the design
    effort. Most of the application features depend on logic built at the application
    layer. The application layer performs logic on the data stored in the database
    layer. Let’s look at the database layer in more detail.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，在三层架构中，所有算法和复杂的逻辑都位于应用层，包括创建推荐引擎或根据用户的浏览历史向用户展示个性化页面。你可以添加诸如领域层、数据访问层或展示层等层次，以构建四层或五层架构。开发人员可以选择在服务器端编程语言中实现这一层，例如
    C++、Java、.NET 或 Node.js。应用层是系统设计的核心，通常需要最多的设计工作。大多数应用功能都依赖于在应用层构建的逻辑。应用层对存储在数据库层的数据进行逻辑处理。让我们更详细地了解数据库层。
- en: The database layer
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库层
- en: The database layer, also known as the **data tier**, stores all the information
    related to user profiles and transactions. Essentially, it contains any data that
    needs to persist in being stored in the data tier. This information is sent back
    to the application layer for logic processing, and then, eventually, is rendered
    to the user in the web layer. For example, suppose the user is logged in to a
    website with their ID and password. In that case, the application layer verifies
    the user credentials with information stored in the database. If the credentials
    match the stored information, the user is allowed to log in and access the authorized
    area of the website.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库层，也称为**数据层**，存储与用户档案和交易相关的所有信息。本质上，它包含需要持久化存储在数据层中的任何数据。这些信息被发送回应用层进行逻辑处理，然后最终在
    web 层呈现给用户。例如，假设用户使用 ID 和密码登录网站。在这种情况下，应用层会验证存储在数据库中的用户凭证。如果凭证与存储的信息匹配，用户将被允许登录并访问网站的授权区域。
- en: The architect may choose to build a data tier in relational databases, for example,
    PostgreSQL, MariaDB, Oracle Database, MySQL, Microsoft SQL Server, Amazon Aurora,
    or Amazon RDS. The architect may add a NoSQL database such as Amazon DynamoDB,
    MongoDB, or Apache Cassandra.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 架构师可以选择在关系型数据库中构建数据层，例如 PostgreSQL、MariaDB、Oracle Database、MySQL、Microsoft SQL
    Server、Amazon Aurora 或 Amazon RDS。架构师也可以添加 NoSQL 数据库，如 Amazon DynamoDB、MongoDB
    或 Apache Cassandra。
- en: The data tier is used to store transaction information and hold user session
    information and application configuration. An architect may consider adding caching
    databases such as Memcached and Redis to meet performance needs. You will learn
    more about various databases in *Chapter 12*, *Data Engineering for Solution Architecture*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 数据层用于存储交易信息、用户会话信息和应用程序配置。架构师可能会考虑添加缓存数据库，如 Memcached 和 Redis，以满足性能需求。你将在*第12章*，*解决方案架构的数据工程*中了解更多关于各种数据库的知识。
- en: The data tier needs special attention in terms of security. You must protect
    user information by applying data encryption at rest and in transit. In the *n*-tier
    layered architecture diagram, you will notice that each layer has its own auto-scaling
    configuration, which means it can be scaled independently. Also, each layer has
    a network boundary, which means having access to one layer doesn’t allow access
    to other layers. You will learn more about security considerations in *Chapter
    7*, *Security Considerations*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在安全方面，数据层需要特别注意。您必须通过在静止状态和传输过程中应用数据加密来保护用户信息。在*n*-层分层架构图中，您会注意到每一层都有自己的自动扩展配置，这意味着可以独立扩展每一层。此外，每一层都有网络边界，这意味着访问一层并不能访问其他层。您将在*第7章*，*安全考虑*中了解更多关于安全方面的内容。
- en: The architect needs to decide on the number of tiers based on application complexity
    and user requirements. For example, you might add additional tiers, such as a
    data access layer for database access logic, and keep the data storage layer for
    the database engine. You can add more layers to reduce complexity by defining
    logical separation, which can help increase the application’s general maintainability
    and the ability to scale and achieve performance.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 架构师需要根据应用程序的复杂性和用户需求决定层数。例如，您可以添加额外的层，如用于数据库访问逻辑的数据访问层，并保持数据存储层作为数据库引擎。您可以通过定义逻辑分离来增加应用程序的整体可维护性、扩展性和性能。
- en: Creating a multi-tenant SaaS-based architecture
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基于多租户SaaS的架构
- en: In the previous section, you learned about multitier architecture, also called
    a **single tenancy**, when built for a single organization. Multi-tenant architecture
    is becoming more popular as organizations welcome the digital revolution while
    keeping the overall application and operational cost low.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，您了解了多层架构，也称为**单租户**，适用于单个组织构建。随着组织欢迎数字革命，多租户架构变得越来越流行，同时保持整体应用程序和运营成本较低。
- en: The **Software-as-a-Service** (**SaaS**) model is constructed upon a multi-tenant
    architecture, where an instance of the software and the accompanying infrastructure
    caters to numerous customers. Within this framework, each customer utilizes the
    application and database in a shared manner. With each tenant being isolated by
    their unique configuration, identity, and data, they remain invisible to each
    other while sharing the same product.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**软件即服务**（**SaaS**）模型建立在多租户架构之上，其中软件实例和相关基础设施为众多客户提供服务。在这个框架内，每个客户都以共享方式使用应用程序和数据库。通过每个租户独特的配置、身份和数据隔离，他们彼此相互隔离，同时共享同一产品。'
- en: As multi-tenant SaaS providers are responsible for everything from the hardware
    to the software, SaaS-based products offload an organization’s responsibilities
    to the application’s maintenance and updates, as the SaaS provider takes care
    of this.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 作为多租户SaaS提供商，它们负责从硬件到软件的一切，基于SaaS的产品将组织的责任转移到应用程序的维护和更新上，因为SaaS提供商负责处理这些事务。
- en: Each organizations those are buyer of SaaS product consider as tenant. These
    tenants can customize their user interface using a configuration without code
    changes. As multiple customers share a common infrastructure, they benefit from
    scale, which further lowers the cost. Some of the most popular SaaS providers
    are Salesforce CRM, Jira Software, Slack, Google Workspace, and Amazon Connect.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每个购买SaaS产品的组织都被视为租户。这些租户可以使用配置而无需进行代码更改来自定义其用户界面。由于多个客户共享公共基础设施，它们可以从规模中受益，进一步降低成本。一些最受欢迎的SaaS提供商包括Salesforce
    CRM、Jira Software、Slack、Google Workspace和Amazon Connect。
- en: 'As shown in the following architecture diagram, two organizations (tenants)
    use the same software and infrastructure. The SaaS vendor provides access to the
    application layer by allocating a unique tenant ID to each organization:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示的架构图表明，两个组织（租户）使用相同的软件和基础设施。SaaS供应商通过为每个组织分配唯一的租户ID，提供对应用层的访问：
- en: '![](img/B21336_04_02.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21336_04_02.png)'
- en: 'Figure 4.2: Multi-tenant SaaS architecture'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：多租户SaaS架构
- en: 'The preceding architecture design shows that the presentation layer provides
    a user interface, and the application layer holds the business logic. At the data
    access layer, each tenant will have data-level isolation with one of the following
    methods:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前述架构设计显示，表现层提供用户界面，应用层保存业务逻辑。在数据访问层，每个租户将通过以下一种方法实现数据级隔离：
- en: '**Database-Level Isolation**: In this model, each tenant has its database associated
    with its tenant ID. When each tenant queries data from the user interface, they
    are redirected to their database. This model is required if the customer doesn’t
    want a single shared database for compliance and security reasons.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库级隔离**：在这种模型中，每个租户都有与其租户ID关联的数据库。当每个租户从用户界面查询数据时，将其重定向到其数据库。如果客户出于合规性和安全性原因不希望使用单一共享数据库，则需要此模型。'
- en: '**Table-Level Isolation**: This isolation level can be achieved by providing
    a separate table for each tenant. In this model, tables need to be uniquely assigned
    to each tenant, for example, with the tenant ID prefix. When each tenant queries
    data from the user interface, they are redirected to their tables as per their
    unique identifier.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表级隔离**：可以通过为每个租户提供单独的表来实现此隔离级别。在此模型中，需要为每个租户唯一分配表，例如使用租户ID前缀。当每个租户从用户界面查询数据时，根据其唯一标识符将其重定向到其表中。'
- en: '**Row-Level Isolation**: All tenants share the same table in a database in
    this isolation level. There is an additional column in a table where a unique
    tenant ID is stored against each row. When an individual tenant wants to access
    their data from the user interface, the application’s data access layer formulates
    a query based on the tenant ID to the shared table. Each tenant gets a row that
    belongs to their users only.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行级隔离**：在这种隔离级别中，所有租户在数据库中共享同一张表。表中有一个额外的列，存储每行针对的唯一租户ID。当单个租户希望从用户界面访问其数据时，应用程序的数据访问层根据租户ID向共享表生成查询。每个租户仅获取属于其用户的行。'
- en: For enterprise customers, a careful assessment should be carried out to understand
    whether a SaaS solution fits them based on their unique features’ requirements.
    This is because, often, a SaaS model has limited customization capabilities.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对企业客户而言，应进行仔细评估，以了解SaaS解决方案是否适合基于其独特功能需求。这是因为，通常情况下，SaaS模型的定制能力有限。
- en: The selection of isolation approaches is based on considerations around the
    organization’s compliance, security, cost, and tenant contractual requirements.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离方法的选择基于组织的合规性、安全性、成本以及租户合同要求等考虑因素。
- en: It’s important to find the cost value proposition if many users need to subscribe.
    The cost comparison should be calculated based on the total cost of ownership
    when making a *build versus buy* decision. This is because building software is
    not the primary business of most organizations, so the SaaS model is becoming
    highly popular as organizations can focus on their business and let the experts
    handle the IT side of it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要许多用户订阅，找到成本价值主张非常重要。在进行“构建还是购买”决策时，成本比较应基于总体拥有成本来计算。这是因为构建软件并不是大多数组织的主营业务，因此SaaS模型因其使组织能够专注于业务并让专家处理其IT方面而变得非常流行。
- en: '**Service-oriented architecture** (**SOA**) is a popular approach for designing
    and building applications, especially when organizations have unique, customized
    requirements. Let’s learn more about it.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向服务的架构** (**SOA**) 是设计和构建应用程序的流行方法，特别是当组织有独特的定制需求时。让我们更多地了解它。'
- en: Understanding service-oriented architecture
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解面向服务的架构
- en: In **SOA** patterns, different application components interact using a communication
    protocol over the network. Each service provides end-to-end functionality, for
    example, *fetching an order history*. SOA is widely adopted by large systems to
    integrate business processes, for example, taking your payment service from the
    main application and putting it as a separate solution.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在**SOA**模式中，不同的应用程序组件通过网络上的通信协议进行交互。每个服务提供端到端的功能，例如*获取订单历史记录*。SOA被大型系统广泛采用，以集成业务流程，例如从主应用程序中取出您的支付服务并将其作为单独的解决方案。
- en: In a general sense, SOAs take monolithic applications and spread some of those
    operations into individual *services* that operate independently. The goal of
    using an SOA is to loosen the coupling of your application’s services. Sometimes,
    an SOA includes splitting services apart from one another and splitting resources
    into separate instances of that service. For example, while some choose to store
    their company’s data in a single database split by tables, an SOA would consider
    modularizing the application by function into separate databases altogether. This
    allows you to scale and manage throughput based on the individual needs of tables
    for each database.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从一般意义上讲，SOA 将单体应用程序拆分为一些独立运行的 *服务*。使用 SOA 的目标是松耦合应用程序的服务。有时，SOA 包括将服务彼此拆分并将资源拆分为该服务的独立实例。例如，虽然有些人选择将公司数据存储在一个通过表格拆分的单一数据库中，但
    SOA 会考虑按功能模块化应用程序，将其拆分成完全独立的数据库。这使得你可以根据每个数据库中表格的个别需求进行扩展和管理吞吐量。
- en: SOA has multiple benefits, for example, the parallelization of development,
    deployment, and operation. It decouples the service so that you can optimize and
    scale each service individually.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: SOA 具有多个优点，例如开发、部署和运营的并行化。它解耦了服务，使你能够单独优化和扩展每个服务。
- en: However, it also requires more robust governance to ensure work performed by
    each service’s team meets the same standard. With SOA, the solution could become
    complex enough to increase the overhead to balance that, so you need to choose
    tools and implement automation for service monitoring, deployment, and scaling.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它也需要更强有力的治理来确保每个服务团队所执行的工作符合相同的标准。在 SOA 中，解决方案可能会变得足够复杂，从而增加开销，因此你需要选择工具并实施自动化来进行服务监控、部署和扩展。
- en: There are multiple ways to implement SOA.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 SOA 的方式有多种。
- en: '**Simple Object Access Protocol** (**SOAP**) was initially the most popular
    messaging protocol, but it is heavyweight as it relies entirely on XML for data
    interchange. **Representational State Transfer** (**REST**) architecture is becoming
    more popular as developers need to build more lightweight mobile and web applications.
    As of the time of writing, SOAP architecture is considered legacy architecture,
    so in this edition of the book, we will focus on learning REST architecture.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单对象访问协议** (**SOAP**) 最初是最流行的消息传递协议，但由于完全依赖 XML 进行数据交换，它的重量较重。**表现层状态转移**
    (**REST**) 架构越来越受欢迎，因为开发人员需要构建更轻量的移动和 Web 应用程序。在撰写本文时，SOAP 架构已被视为遗留架构，因此在本书的这一版本中，我们将重点学习
    REST 架构。'
- en: RESTful web service architecture
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RESTful Web 服务架构
- en: A **REST** or RESTful web service offers better performance due to its lightweight
    architecture. It allows different messaging formats, such as JSON, plaintext,
    HTML, and XML, compared to SOAP, which only allows XML. REST is an architecture
    style that defines the standard for loosely coupled application design using the
    HTTP protocol for data transmission.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**REST** 或 RESTful Web 服务因其轻量级架构而提供更好的性能。与仅允许 XML 的 SOAP 不同，REST 允许多种消息格式，如
    JSON、纯文本、HTML 和 XML。REST 是一种架构风格，定义了使用 HTTP 协议进行数据传输的松耦合应用程序设计标准。'
- en: '**JavaScript Object Notation** (**JSON**) is a more accessible format for data
    exchange in REST architecture. JSON is also lightweight and language-independent.
    It contains a simple key-value pair that makes it compatible with data structures
    defined in most programming languages.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript 对象表示法** (**JSON**) 是 REST 架构中更易于访问的数据交换格式。JSON 也是轻量级的，且与语言无关。它包含一个简单的键值对，使其与大多数编程语言中定义的数据结构兼容。'
- en: 'RESTful web services, also known as REST web services, establish a framework
    with specific rules to design web services. They are aimed at ensuring compatibility
    between various computer systems connected through the internet. With RESTful
    web services, systems can communicate by accessing and modifying text-based data
    on the web using a consistent and predefined set of operations that don’t rely
    on past interactions or states. Here are some fundamental principles of RESTful
    web service architecture, along with an illustration of the principles of RESTful
    web service architecture using the example of an e-commerce website:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful Web 服务，也称为 REST Web 服务，建立了一个具有特定规则的框架，用于设计 Web 服务。其目的是确保通过互联网连接的各种计算机系统之间的兼容性。通过
    RESTful Web 服务，系统可以使用一致的、预定义的一组操作访问和修改基于文本的数据，而不依赖于过去的交互或状态。以下是 RESTful Web 服务架构的一些基本原则，以及使用电子商务网站示例来说明
    RESTful Web 服务架构的原则：
- en: '**Stateless**: Every request from the client to the server must contain all
    the information the server needs to understand and process. Every request made
    by a client includes all the necessary information to fulfill that request, and
    there is no need to maintain any session-related information on the server; instead,
    it is entirely managed on the client side. Taking the example of an e-commerce
    website, each request from a client, like viewing a product or adding it to the
    cart, must contain all the information needed for processing. If a user wants
    to view their cart, the request must include the user’s ID or any other relevant
    details so the server can identify and respond with the appropriate card details.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态**: 客户端到服务器的每个请求必须包含服务器理解和处理所需的所有信息。客户端发出的每个请求都包含完成该请求所需的所有必要信息，并且无需在服务器端维护任何会话相关的信息；相反，所有信息完全由客户端管理。以一个电子商务网站为例，客户端的每个请求，比如查看产品或将其添加到购物车，都必须包含处理该请求所需的所有信息。如果用户想查看他们的购物车，请求必须包含用户的
    ID 或其他相关细节，以便服务器能够识别并返回相应的购物车详情。'
- en: '**Client-server architecture**: In this design, there are two distinct parts,
    the client and the server, which communicate with each other through a network.
    The client is responsible for managing the user interface and interacting with
    the user, and the server is responsible for the backend and data processing. They
    can evolve separately without affecting each other. The client (browser or app)
    manages user interaction, like selecting products, while the server handles data
    retrieval, cart management, and checkout processing. They interact through HTTP
    requests and responses.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端-服务器架构**: 在这种设计中，客户端和服务器是两个独立的部分，它们通过网络进行通信。客户端负责管理用户界面并与用户互动，而服务器负责后端和数据处理。它们可以独立演化而不互相影响。客户端（浏览器或应用程序）管理用户交互，比如选择产品，而服务器处理数据检索、购物车管理和结账处理。它们通过
    HTTP 请求和响应进行交互。'
- en: '**Uniform interface**: REST uses a uniform interface, simplifying and decoupling
    the architecture. For RESTful APIs, interactions are facilitated through a set
    of standard HTTP methods that correspond to **CRUD** (**Create, Read, Update,
    Delete**) operations. These methods include:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统一接口**: REST 使用统一接口，简化和解耦架构。对于 RESTful API，交互通过一组标准的 HTTP 方法来促进，这些方法对应 **CRUD**（**创建、读取、更新、删除**）操作。这些方法包括：'
- en: '**GET**: This method is used to retrieve data from the server. For example,
    when a user wants to view a list of products on example.com, their browser sends
    a GET request to the server. The URL might look like `https://example.com/api/products`,
    and the server responds with the list of products in a structured format like
    JSON or XML.'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GET**: 这种方法用于从服务器检索数据。例如，当用户想要查看 example.com 上的产品列表时，他们的浏览器会向服务器发送一个 GET
    请求。URL 可能看起来像 `https://example.com/api/products`，服务器会以结构化格式（如 JSON 或 XML）返回产品列表。'
- en: '**POST**: This method is used to create a new resource on the server. Suppose
    a user wants to add a new product to their shopping cart on `example.com`. They
    might fill out a form with the product details and click **Add to Cart**. This
    action would trigger a POST request to `https://example.com/api/cart`, including
    the product details in the request body. The server then processes this data and
    adds the new product to the user’s cart.'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**POST**: 这种方法用于在服务器上创建新的资源。假设用户想在 `example.com` 上将一个新产品添加到购物车中。他们可能会填写一个包含产品详情的表单，并点击
    **添加到购物车**。这个操作会触发一个 POST 请求，发送到 `https://example.com/api/cart`，并将产品详情包含在请求体中。然后，服务器处理这些数据并将新产品添加到用户的购物车中。'
- en: '**PUT**: This method is used to update an existing resource on the server.
    If the user wants to update the quantity of a product in their cart, a PUT request
    would be sent to a specific URL like `https://example.com/api/cart/{productId}`.
    The request body would include the updated quantity, and the server would update
    the corresponding item in the user’s cart.'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PUT**：此方法用于更新服务器上已存在的资源。如果用户想要更新购物车中某个商品的数量，则会向像`https://example.com/api/cart/{productId}`这样的特定URL发送PUT请求。请求体中会包括更新后的数量，服务器将会更新用户购物车中对应的商品。'
- en: '**DELETE**: This method is used to remove a resource from the server. For instance,
    if the user decides to remove a product from their cart, their browser would send
    a DELETE request to a URL like `https://example.com/api/cart/{productId}`. The
    server would then remove the specified product from the cart.'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DELETE**：此方法用于从服务器移除某个资源。例如，如果用户决定从购物车中删除某个商品，浏览器会向像`https://example.com/api/cart/{productId}`这样的URL发送DELETE请求。服务器随后会从购物车中移除指定的商品。'
- en: By adhering to these standard methods, APIs provide a consistent way for developers
    to interact with web services, enabling them to perform basic operations on resources
    without needing to understand the underlying implementation details.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过遵循这些标准方法，API为开发者提供了一种与Web服务交互的一致方式，使开发者能够对资源执行基本操作，而无需了解底层实现细节。
- en: '**Resource-based**: In REST, everything is considered a resource, and a specific
    URL can access each resource. Resources are the key abstractions in REST, and
    a resource can represent a single object or a collection of objects. Resources
    like products, users, orders, and cart items are all identified by URLs. For example,
    a specific product could be accessed at `www.amazon.com/products/{product_id}`.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于资源**：在REST中，所有事物都被视为资源，每个资源都可以通过特定的URL进行访问。资源是REST中的关键抽象，资源可以表示一个单独的对象或多个对象的集合。像商品、用户、订单和购物车商品等资源都通过URL进行标识。例如，特定商品可以通过`www.amazon.com/products/{product_id}`进行访问。'
- en: '**Representation of resources**: Resources can have different representations,
    such as JSON, XML, HTML, etc. Clients interact with resources by obtaining representations
    of them and manipulating these representations. When a client holds a representation
    of a resource, it has enough information to modify the resource on the server.
    The same product resource might be rendered differently for a web browser than
    a mobile app.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源的表示**：资源可以有不同的表示形式，如JSON、XML、HTML等。客户端通过获取资源的表示并操作这些表示来与资源交互。当客户端持有资源的表示时，它拥有足够的信息来修改服务器上的资源。相同的商品资源可能在网页浏览器和移动应用中以不同的方式呈现。'
- en: '**Layered system**: The architecture allows for an intermediate layer (such
    as a load balancer or a cache layer) to be introduced without affecting how the
    client interacts with the server. Each layer can provide a specific set of functionalities,
    improving the scalability and maintainability of the system. An e-commerce website
    can have various layers, like load balancers, caching layers, or authentication
    layers. The client does not need to know about these layers. A request to view
    a product might pass through a cache layer to improve response time without the
    client’s awareness.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分层系统**：这种架构允许引入中间层（如负载均衡器或缓存层），而不影响客户端与服务器的交互方式。每一层可以提供特定的功能集，从而提高系统的可扩展性和可维护性。一个电子商务网站可能会有多个层次，如负载均衡层、缓存层或认证层。客户端不需要了解这些层次。请求查看商品时，可能会经过缓存层以提高响应速度，但客户端对此并不知情。'
- en: '**Code on demand**: Servers can provide executable code to the client to be
    executed in the client’s context. This allows for part of the application logic
    to be shifted to the client. An e-commerce website could send JavaScript code
    to the client’s browser to execute certain functionalities like client-side validation
    or enhance interactivity within the user’s browsing experience.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按需代码**：服务器可以向客户端提供可执行代码，供客户端在其上下文中执行。这允许部分应用逻辑转移到客户端。例如，一个电子商务网站可以向客户端的浏览器发送JavaScript代码，以执行客户端验证或增强用户浏览体验中的交互性。'
- en: The RESTful architectural style uses standard HTTP methods, and by adhering
    to these principles, RESTful web services aim to be simple, scalable, and maintainable.
    Many modern web APIs are developed following the RESTful principles, using standard
    conventions to perform CRUD operations on resources. Let’s learn about a reference
    architecture based on RESTful architecture.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful 架构风格使用标准的 HTTP 方法，并通过遵循这些原则，RESTful Web 服务旨在简单、可扩展和可维护。许多现代 Web API
    遵循 RESTful 原则开发，使用标准约定对资源执行 CRUD 操作。让我们了解基于 RESTful 架构的参考架构。
- en: Building a RESTful-architecture-based e-commerce website
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建基于 RESTful 架构的电子商务网站
- en: An e-commerce website such as [www.amazon.com](http://www.amazon.com) has users
    worldwide and a vast catalog with millions of products. Each product has multiple
    images, reviews, and videos. Maintaining such an extensive catalog for a global
    user base is a very challenging task.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如 [www.amazon.com](http://www.amazon.com) 的电子商务网站具有全球用户和庞大的数百万产品目录。每个产品都有多个图像、评论和视频。为全球用户群维护如此庞大的目录是一项非常具有挑战性的任务。
- en: 'This reference architecture in AWS follows RESTful principles. The services
    are operating as independently as possible from each other:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此 AWS 中的参考架构遵循 RESTful 原则。服务尽可能独立运行：
- en: '![](img/B21336_04_03.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21336_04_03.png)'
- en: 'Figure 4.3: RESTful architecture for an e-commerce website'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：电子商务网站的 RESTful 架构
- en: 'As shown in the preceding architecture diagram, we can take note of the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述架构图所示，我们可以注意到以下内容：
- en: When a user types a website address into the browser, the user request reaches
    out to the DNS server to load the website. The DNS requests for the website are
    routed by Amazon Route 53 to the server where the web applications are being hosted.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户在浏览器中输入网站地址时，用户请求会到达 DNS 服务器以加载网站。Amazon Route 53 将网站的 DNS 请求路由到托管 Web 应用程序的服务器。
- en: The user base is global, and users continue browsing for products to purchase
    as the website has an extensive product catalog with static images and videos.
    A content distribution network like Amazon CloudFront caches and delivers static
    assets to users.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户群体是全球的，用户继续浏览要购买的产品，因为该网站具有庞大的产品目录，包括静态图像和视频。像 Amazon CloudFront 这样的内容分发网络缓存和向用户传递静态资产。
- en: The catalog contents, such as static product images and videos, and other application
    data, such as log files, are stored in Amazon S3.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储在 Amazon S3 中的目录内容，如静态产品图像和视频，以及其他应用程序数据，如日志文件。
- en: Users will browse the website from multiple devices; for example, they will
    add items to a cart from their mobile and then make a payment on a desktop. A
    persistent session store, such as DynamoDB, is required to handle user sessions.
    DynamoDB is a NoSQL database where you don’t need to provide a fixed schema, so
    it is a great storage option for product catalogs and attributes.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户将从多个设备浏览网站；例如，他们将从移动设备向购物车添加商品，然后在桌面上进行付款。需要持久的会话存储，如 DynamoDB，来处理用户会话。DynamoDB
    是一个 NoSQL 数据库，无需提供固定的模式，因此它是产品目录和属性的优秀存储选项。
- en: Amazon ElastiCache is used as a caching layer for the product to reduce read
    and write operations on the database to provide high performance and reduce latency.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amazon ElastiCache 用作产品的缓存层，以减少对数据库的读写操作，提供高性能并减少延迟。
- en: A convenient search feature is vital for product sales and business success.
    Amazon CloudSearch helps to build scalable search capability by loading the product
    catalog from DynamoDB. You can also use Amazon Kendra for an AI-powered search
    engine.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 便捷的搜索功能对产品销售和业务成功至关重要。Amazon CloudSearch 通过从 DynamoDB 加载产品目录来帮助构建可扩展的搜索能力。您还可以使用
    Amazon Kendra 实现 AI 驱动的搜索引擎。
- en: A recommendation can encourage users to buy additional products based on browsing
    history and past purchases. A separate recommendation service can consume the
    log data stored on Amazon S3 and provide potential product recommendations to
    the user.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推荐可以鼓励用户基于浏览历史和过往购买行为购买其他产品。独立的推荐服务可以消耗存储在 Amazon S3 上的日志数据，并向用户提供潜在的产品推荐。
- en: The e-commerce application can also have multiple layers and components that
    require frequent deployment. AWS Elastic Beanstalk handles the auto-provisioning
    of the infrastructure, deploys the application, handles the load by applying auto-scaling,
    and monitors the application.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子商务应用程序还可以具有多个层和组件，需要频繁部署。AWS Elastic Beanstalk 处理基础设施的自动配置，部署应用程序，通过应用自动扩展来处理负载，并监视应用程序。
- en: You learned about RESTful architecture in this section. Let’s learn more about
    the critical aspect of cache-based architecture design.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本节中了解了 RESTful 架构。接下来让我们深入了解基于缓存的架构设计中的关键方面。
- en: Building a cache-based architecture
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建基于缓存的架构
- en: Caching involves temporarily storing data or files in an intermediate location
    positioned between the requester and the permanent storage. This practice is aimed
    at speeding up future requests and minimizing network bandwidth usage. Caching
    increases application speed and lowers cost. It allows you to reuse previously
    retrieved data. To increase application performance, caching can be applied at
    various layers of the architecture, such as the web layer, application layer,
    data layer, and network layer.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存涉及将数据或文件临时存储在请求者与永久存储之间的中间位置。这种做法旨在加速未来的请求并最小化网络带宽的使用。缓存提高了应用程序的速度并降低了成本。它允许你重复使用先前检索的数据。为了提高应用程序性能，缓存可以应用于架构的各个层次，如
    Web 层、应用层、数据层和网络层。
- en: Typically, the server’s **random-access memory** (**RAM**) and in-memory cache
    engines are utilized to support application caching. However, if caching is coupled
    to a local server, then the cache will not persist data in case of a server crash.
    Most applications are in a distributed environment, so it’s better to have a dedicated
    caching layer that should be independent of the application life cycle. If you
    apply horizontal scaling to your application, all servers should be able to access
    the centralized caching layer to achieve the best performance.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，服务器的 **随机存取内存** (**RAM**) 和内存缓存引擎被用来支持应用程序缓存。然而，如果缓存与本地服务器耦合，那么在服务器崩溃时缓存将不会持久化数据。大多数应用程序都运行在分布式环境中，因此最好拥有一个独立于应用生命周期的专用缓存层。如果你对应用程序进行水平扩展，那么所有服务器都应该能够访问集中式缓存层，以实现最佳性能。
- en: 'The following diagram depicts the mechanism of caching in various layers of
    solution architecture:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下图描述了解决方案架构各层中的缓存机制：
- en: '![](img/B21336_04_04.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21336_04_04.png)'
- en: 'Figure 4.4: Caching at the architecture layers'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4：架构层的缓存
- en: 'As shown in the preceding diagram, the following are the caching mechanisms
    at each layer of the architecture:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，以下是每一层架构中的缓存机制：
- en: '**Client-side caching**: Client-side caching is applied to user devices such
    as mobile and desktop. Client-side caching caches the previously visited web content
    to respond faster to a subsequent request. Each browser has its own caching mechanism.
    HTTP caching makes the application faster by caching content in the local browser.
    The cache-control HTTP header defines browser caching policies for client requests
    and server responses. These policies define where the content should be cached
    and how long it will persist, known as the **time to live** (**TTL**). Cookies
    are another method used to store information on the client’s machine to respond
    to the browser faster.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端缓存**：客户端缓存应用于用户设备，如手机和桌面。客户端缓存将先前访问的网页内容缓存起来，以便更快地响应随后的请求。每个浏览器都有自己的缓存机制。HTTP
    缓存通过在本地浏览器缓存内容来加速应用程序。`cache-control` HTTP 头定义了客户端请求和服务器响应的浏览器缓存策略。这些策略定义了内容应该缓存在哪里，以及它会持续多长时间，这被称为
    **生存时间** (**TTL**) 。Cookies 是另一种用于存储信息在客户端计算机上，以便更快响应浏览器的方法。'
- en: '**Internet DNS cache**: When a user types the website address over the Internet,
    the public **Domain Name System** (**DNS**) server looks up the IP address. Caching
    this DNS resolution information will reduce the website’s load time. DNS information
    can be cached to a local server or browser after the first request, and any further
    requests to that website will be faster.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互联网 DNS 缓存**：当用户在互联网上输入网站地址时，公共 **域名系统** (**DNS**) 服务器会查找 IP 地址。缓存此 DNS 解析信息将减少网站的加载时间。DNS
    信息在第一次请求后可以缓存到本地服务器或浏览器中，任何进一步对该网站的请求都将更快。'
- en: '**Web content caching**: Much of the request involves retrieving web content
    such as images, videos, and HTML pages. Caching these assets near the user’s location
    can provide a much faster response for a page load. This also eliminates disk
    read and server load time. A **content distribution network** (**CDN**) provides
    a network of edge locations where static content, such as high-resolution images
    and videos, can be cached. It’s beneficial for reading heavy applications such
    as games, blogs, e-commerce product catalog pages, and more. The user session
    contains lots of information regarding user preference and their state. It provides
    a great user experience by storing the user’s session in its own key-value store
    for quick user response.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web 内容缓存**：许多请求涉及检索 Web 内容，如图像、视频和 HTML 页面。将这些资产缓存到用户附近的位置可以为页面加载提供更快的响应。这还消除了磁盘读取和服务器负载时间。**内容分发网络**（**CDN**）提供了一个边缘位置的网络，在这些位置可以缓存静态内容，如高分辨率图像和视频。这对重读型应用程序（如游戏、博客、电商产品目录页面等）非常有益。用户会话包含有关用户偏好和状态的大量信息。通过将用户会话存储在自己的键值存储中，提供了快速的用户响应，从而提供了良好的用户体验。'
- en: '**Application caching**: At the application layer, caching can be applied to
    store the result of a complex repeated request to avoid business logic calculations
    and database hits. Overall, it improves application performance and reduces the
    load on the database and infrastructure.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用缓存**：在应用层，可以通过缓存来存储复杂的重复请求的结果，从而避免业务逻辑计算和数据库访问。总体而言，它提高了应用性能，减少了数据库和基础设施的负担。'
- en: '**Database caching**: Application performance highly depends upon the speed
    and throughput provided by the database. Database caching increases database throughput
    significantly and lowers data retrieval latency. A database cache can be applied
    in front of any relational or non-relational database. Some database providers
    integrate caching, while applications handle local caching.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库缓存**：应用性能高度依赖于数据库提供的速度和吞吐量。数据库缓存显著提高了数据库的吞吐量，并降低了数据检索的延迟。数据库缓存可以应用于任何关系型或非关系型数据库之前。一些数据库提供商集成了缓存功能，而应用程序则处理本地缓存。'
- en: '**Redis** and **Memcached** are the most popular caching engines. While Memcached
    is faster (it is suitable for low-structure data and stores data in a key-value
    format), Redis is a more persistent caching engine and is capable of handling
    complex data structures required for an application such as a gaming leaderboard;
    you will learn more details in the *Memcached versus Redis* section in this chapter.
    Let’s learn about a few more caching design patterns.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**Redis** 和 **Memcached** 是最流行的缓存引擎。虽然 Memcached 更快（它适用于低结构数据，并以键值对格式存储数据），但
    Redis 是一个更持久的缓存引擎，能够处理应用所需的复杂数据结构，例如游戏排行榜；你将在本章的 *Memcached 与 Redis* 部分学习更多细节。接下来让我们了解几种其他的缓存设计模式。'
- en: Cache distribution pattern in a three-tier web architecture
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三层 Web 架构中的缓存分发模式
- en: Conventional web hosting architecture follows a common three-tier web application
    model, which divides the architecture into presentation, application, and persistence
    layers.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的 Web 托管架构遵循常见的三层 Web 应用模型，将架构划分为表示层、应用层和持久层。
- en: 'As shown in the following AWS architecture diagram, caching is applied at the
    web, application, and database layers:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，在 AWS 架构中，缓存应用于 Web、应用和数据库层：
- en: '![](img/B21336_04_05.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21336_04_05.png)'
- en: 'Figure 4.5: Cache distribution pattern architecture'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5：缓存分发模式架构
- en: 'In caching patterns, your goal is to try to hit the backend as little as possible.
    You can write an application where you can cache images, JavaScript, or even full
    pages to provide a better experience for your users. In the diagram above, caching
    is strategically implemented across various layers of the architecture:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在缓存模式中，目标是尽量减少后端的访问。你可以编写一个应用程序，在其中缓存图像、JavaScript，甚至是整个页面，从而为用户提供更好的体验。在上图中，缓存被战略性地实施在架构的各个层次上：
- en: Amazon Route 53 plays a role in caching DNS-to-IP mappings, simplifying domain
    management.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amazon Route 53 在缓存 DNS 到 IP 的映射中起到了作用，从而简化了域名管理。
- en: Amazon S3 serves as the storage location for static content, including high-resolution
    images and videos.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amazon S3 作为静态内容的存储位置，包括高分辨率图像和视频。
- en: Amazon CloudFront offers edge caching for high-traffic content, utilizing cache-control
    headers to determine update frequency from the origin.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amazon CloudFront 提供边缘缓存服务，用于高流量内容，通过使用缓存控制头部来确定从源服务器更新的频率。
- en: Amazon DynamoDB is used for session stores, helping web applications manage
    user sessions through caching.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊 DynamoDB 用于会话存储，帮助 Web 应用通过缓存管理用户会话。
- en: Elastic Load Balancing evenly distributes traffic among web server Auto Scaling
    groups.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹性负载均衡 (Elastic Load Balancing) 将流量均匀分配到 Web 服务器的自动扩展组中。
- en: Amazon ElastiCache offers caching services for the application, effectively
    reducing the load on the database tier.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊 ElastiCache 提供应用程序的缓存服务，能有效减轻数据库层的负担。
- en: Typically, static content is cached, but there are scenarios where caching dynamic
    or unique content can improve application performance. The decision depends on
    specific usage patterns and demands.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，静态内容会被缓存，但也有一些场景中，缓存动态或唯一的内容可以提高应用程序性能。是否缓存取决于具体的使用模式和需求。
- en: Let’s take a look at a more specific pattern.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一个更具体的模式。
- en: Rename distribution pattern
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重命名分发模式
- en: When using a **CDN** such as Amazon CloudFront, you store frequently used data
    in an edge location near the user for fast performance. Often, you set up the
    TTL in the CDN for your data, which means the edge location will not query back
    to the server for updated data until the TTL expires. TTL is when an object is
    stored in a caching system before it’s deleted or refreshed. You may have situations
    where you need to update CDN cached content immediately, for example, if you need
    to correct the wrong product description.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **CDN**（如 Amazon CloudFront）时，你可以将经常使用的数据存储在离用户较近的边缘位置，以便获得更快的性能。通常，你会在 CDN
    中为你的数据设置 TTL，这意味着在 TTL 到期之前，边缘位置不会回到服务器请求更新的数据。TTL 是指对象在缓存系统中存储的时间，直到被删除或刷新。你可能会遇到需要立即更新
    CDN 缓存内容的情况，例如，如果你需要修正错误的产品描述。
- en: 'You can’t wait for the file’s TTL to expire in such a situation. The rename
    distribution pattern helps you update the cache as soon as new changes are published
    so the user can get updated information immediately. The following diagram shows
    this pattern with AWS:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你不能等待文件的 TTL 到期。重命名分发模式可以帮助你在新更改发布后立即更新缓存，这样用户就能立刻获得更新的信息。下图展示了 AWS 中的这一模式：
- en: '![](img/B21336_04_06.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21336_04_06.png)'
- en: 'Figure 4.6: Rename distribution pattern architecture'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6：重命名分发模式架构
- en: As shown in the preceding diagram, using the rename distribution pattern with
    the cache distribution pattern helps to solve the update issue. With this pattern,
    instead of overwriting the file in the origin server and waiting for the TTL in
    CloudFront to expire, the server uploads the updated file with a new filename
    and then updates the web page with the new URL. When the user requests original
    content, CloudFront has to fetch it from the origin and can’t serve the obsolete
    file that’s already cached.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，使用重命名分发模式与缓存分发模式结合有助于解决更新问题。通过这种模式，服务器上传带有新文件名的更新文件，而不是覆盖原始服务器中的文件并等待
    CloudFront 中 TTL 到期，然后更新网页中的新 URL。当用户请求原始内容时，CloudFront 必须从源服务器获取内容，不能提供已缓存的过时文件。
- en: However, you can invalidate the old file immediately, but that will cost more,
    so it’s better to put a new version of the file for the CDN to pick immediately.
    Again, you must update the URL in the application to pick up a new file, adding
    some overhead compared to the invalidation option. It would be best to decide
    based on your business requirements and budget.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以立即使旧文件失效，但这会产生更多成本，因此最好上传文件的新版本，供 CDN 立即获取。同样，你必须在应用程序中更新 URL 以便获取新文件，这相比使失效的选项会增加一些开销。最好根据你的业务需求和预算来做出决定。
- en: You can use the proxy cache server to use something other than a CDN for a user
    base distributed across the country. Let’s learn more about it in the next section.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用代理缓存服务器来代替 CDN，尤其是当用户分布在全国各地时。让我们在下一部分中详细了解它。
- en: Cache proxy pattern
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存代理模式
- en: 'You can increase your application performance significantly by adding a cache
    layer. In a cache proxy pattern, static or dynamic content is cached upstream
    of the web app server. As shown in the following architectural diagram, you have
    a caching layer in front of the web application cluster:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加缓存层，你可以显著提高应用程序的性能。在缓存代理模式中，静态或动态内容会被缓存到 Web 应用服务器的上游。如下面的架构图所示，你在 Web 应用集群前面有一个缓存层：
- en: '![](img/B21336_04_07.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21336_04_07.png)'
- en: 'Figure 4.7: Cache proxy pattern architecture'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7：缓存代理模式架构
- en: 'In the preceding diagram, for high-performance delivery, cache content is delivered
    by the cache server. A few benefits of cache proxy patterns are as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，为了高效交付，缓存内容由缓存服务器传递。缓存代理模式的一些好处如下：
- en: Cache proxy patterns help you to deliver content using the cache, which means
    no modification is needed at the web server or application server level.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存代理模式帮助您通过缓存传递内容，这意味着无需在 web 服务器或应用服务器级别进行修改。
- en: They reduce the load of content generation for dynamic content.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们减少了动态内容生成的负载。
- en: You can set up a cache at the browser level, such as in HTTP headers, URLs,
    cookies, and more. Alternatively, you can cache information in the cache layer
    if you don’t want to store it at the browser level.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在浏览器级别设置缓存，例如在 HTTP 头、URL、Cookies 等中。或者，如果不想在浏览器级别存储缓存，可以在缓存层存储信息。
- en: In the cache proxy pattern, you must maintain multiple copies of the cache to
    avoid a single point of failure. Sometimes, you may want to serve your static
    content from both the server and CDN, each requiring a different approach. Let’s
    dive deep into this hybrid situation in the next section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在缓存代理模式中，必须维护多个缓存副本，以避免单点故障。有时，您可能希望从服务器和 CDN 提供静态内容，每个方法需要不同的处理方式。让我们在下一节深入探讨这种混合情况。
- en: Rewrite proxy pattern
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重写代理模式
- en: 'Sometimes, you want to change the access destinations of static website content,
    such as images and videos, but you don’t want to change the existing systems.
    You can achieve this by providing a proxy server using rewrite proxy patterns.
    To change the destination of static content to other storage, such as a content
    service or internet storage, you can use a proxy server in front of the web server
    fleet. As shown in the following architecture diagram, you have a proxy server
    in front of your application layer, which helps to change the content delivery
    destination without modifying the actual application:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您希望更改静态网站内容的访问目标，如图像和视频，但又不想更改现有系统。您可以通过提供代理服务器来实现这一点，使用重写代理模式。要将静态内容的目标更改为其他存储，如内容服务或互联网存储，您可以在
    web 服务器群集前使用代理服务器。如以下架构图所示，您在应用层前放置一个代理服务器，帮助在不修改实际应用的情况下更改内容交付目标：
- en: '![A picture containing text, screenshot, diagram, line  Description automatically
    generated](img/B21336_04_08.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![一张包含文本、截图、图表、线条的图片  自动生成的描述](img/B21336_04_08.png)'
- en: 'Figure 4.8: Rewrite proxy pattern architecture'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8：重写代理模式架构
- en: 'As shown in the preceding diagram, place the proxy server in front of the currently
    running system to rewrite the proxy pattern. You can construct a proxy server
    using software such as **Apache** or **NGINX**. The following are the steps to
    build a rewrite proxy pattern, using AWS as the example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，将代理服务器放置在当前运行系统的前端，以重写代理模式。您可以使用如**Apache**或**NGINX**等软件构建代理服务器。以下是构建重写代理模式的步骤，使用
    AWS 作为示例：
- en: Put a running proxy server on an EC2 instance, which can overwrite the content
    between the **load balancer** and the storage service, such as **Amazon S3**,
    which stores the static content.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将运行中的代理服务器放置在 EC2 实例上，代理服务器可以在**负载均衡器**和存储服务（如存储静态内容的**Amazon S3**）之间覆盖内容。
- en: Add to the proxy server rules for overwriting URLs within the content. These
    rules will help **Elastic Load Balancing** (**ELB**) to point to a new location,
    as shown in the preceding diagram, which redirects the proxy server rule from
    `https://cdn/test.jpg to /test.jpg`. ELB is a service provided by AWS that automatically
    distributes incoming application traffic across multiple targets, such as Amazon
    EC2 servers, containers, and IP addresses.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代理服务器规则中添加覆盖内容中 URL 的规则。这些规则将帮助**弹性负载均衡**（**ELB**）指向新位置，如前图所示，将代理服务器规则从`https://cdn/test.jpg`重定向到/test.jpg。ELB
    是 AWS 提供的一项服务，可以自动将传入的应用流量分配到多个目标上，如 Amazon EC2 服务器、容器和 IP 地址。
- en: As required, apply auto-scaling to the proxy servers by configuring minimum
    and maximum proxy server amounts as per the application load.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照应用负载要求，为代理服务器配置自动扩展，设定代理服务器的最小和最大数量。
- en: In this building a cache-based architecture section, you learned how to handle
    caching for static content distribution over the network. However, caching at
    the application layer is very important for improving application performance
    for the overall user experience. Let’s learn more about the app caching pattern
    to handle the dynamic user data delivery performance.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节“构建基于缓存的架构”中，你学习了如何处理静态内容分发的缓存。然而，在应用层进行缓存非常重要，可以提高应用性能，改善整体用户体验。接下来，让我们了解更多关于应用缓存模式的内容，以应对动态用户数据传输的性能需求。
- en: App caching pattern
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用缓存模式
- en: When it comes to applying caching to applications, you want to add a cache engine
    layer between your application servers and the database. The app caching pattern
    allows you to reduce the load on the database as the most frequent query is served
    from the caching layer. The *app caching pattern* improves overall application
    and database performance.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在为应用程序应用缓存时，你需要在应用服务器和数据库之间添加一个缓存引擎层。应用缓存模式可以帮助你减少数据库的负载，因为最频繁的查询是通过缓存层提供的。*应用缓存模式*可以提升整体应用和数据库的性能。
- en: 'As shown in the following diagram, you can see the caching layer applied between
    the application layer and the database layer in AWS:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，你可以看到在 AWS 中，缓存层应用于应用层和数据库层之间：
- en: '![A picture containing text, screenshot, diagram, number  Description automatically
    generated](img/B21336_04_09.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![一张包含文本、截图、图表、数字的图片，描述自动生成](img/B21336_04_09.png)'
- en: 'Figure 4.9: App caching pattern architecture'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9：应用缓存模式架构
- en: As shown in the preceding diagram, you can use either **lazy caching** or **write-through**
    based on your data access pattern. In lazy caching, the cache engine checks whether
    the data is in the cache and, if not, gets it from the database and keeps it in
    the cache to serve future requests. Lazy caching is also called the **cache aside
    pattern**. In the **write-through** method, data is written in the cache and in
    the data store at the same time. If the data gets lost from the cache, it can
    get it again from the database.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，你可以根据数据访问模式使用**惰性缓存**或**写穿透缓存**。在惰性缓存中，缓存引擎检查数据是否在缓存中，如果没有，它将从数据库中获取并存入缓存，以便服务未来的请求。惰性缓存也叫做**缓存旁路模式**。在**写穿透**方法中，数据同时写入缓存和数据存储。如果数据从缓存中丢失，可以从数据库中重新获取。
- en: Choose lazy caching when you have a read-heavy application with acceptable stale
    data and choose write-through caching when dealing with write-heavy operations
    requiring immediate data consistency. For example, you can use lazy caching in
    a product catalog in an e-commerce website where product details are read frequently
    but updated less often. When a user accesses a product detail that is not in the
    cache, it’s fetched from the database and stored in the cache for subsequent access,
    reducing database load. You might want to use write-through for a user review
    section on an e-commerce website, where user-generated reviews are instantly displayed
    on the product page. When a user submits a review, it’s written to both the cache
    and the database simultaneously, ensuring that any subsequent read requests fetch
    the most current data.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用是读密集型且能接受过时数据时，选择惰性缓存；而当处理写密集型操作并需要即时数据一致性时，选择写穿透缓存。例如，你可以在电子商务网站的产品目录中使用惰性缓存，其中产品细节经常被读取，但更新较少。当用户访问不在缓存中的产品详情时，它会从数据库中获取并存入缓存，供后续访问，减少数据库负载。在电子商务网站的用户评价部分，你可能希望使用写穿透缓存，因为用户生成的评价需要即时显示在产品页面。当用户提交评价时，它会同时写入缓存和数据库，确保后续的读取请求获取到最新数据。
- en: Let’s learn more about the popular caching engines *Redis* and *Memcached*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解流行的缓存引擎*Redis*和*Memcached*。
- en: Memcached versus Redis
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Memcached 与 Redis
- en: 'Redis and Memcached are two popular caching engines used in application design.
    The Redis cache engine is often required for more complex application caching
    needs, such as creating a leaderboard for a game. However, Memcached is more high-performing
    and helps handle heavy application loads. Each caching engine has its pros and
    cons. Let’s take a look at the significant differences between them, which will
    help you to make a decision about which to use:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 和 Memcached 是两种在应用设计中常用的缓存引擎。Redis 缓存引擎通常用于更复杂的应用缓存需求，例如为游戏创建排行榜。然而，Memcached
    性能更高，有助于处理重负载应用。每种缓存引擎各有优缺点。我们来看看它们之间的主要区别，这将帮助你决定使用哪种：
- en: '| **Memcached** | **Redis** |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| **Memcached** | **Redis** |'
- en: '| Offers multithreading | Single-threaded |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 提供多线程支持 | 单线程 |'
- en: '| Able to use more CPU cores for faster processing | Unable to utilize multi-core
    processor, which results in comparatively slow performance |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 能够利用更多的CPU核心进行更快速的处理 | 无法利用多核处理器，导致相对较慢的性能 |'
- en: '| Supports key-value style data | Supports complex and advanced data structures
    |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 支持键值对数据 | 支持复杂和高级数据结构 |'
- en: '| Lacks data persistence; loses the data stored in cache memory in the event
    of a crash | Data can persist using built-in read replicas with failover |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 缺乏数据持久性；在崩溃时丢失缓存中的数据 | 可以通过内建的读取副本和故障转移来保持数据持久性 |'
- en: '| Easy maintenance | More complexity is involved owing to the need to maintain
    the cluster |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 易于维护 | 由于需要维护集群，涉及更多复杂性 |'
- en: '| Good to cache flat strings such as flat HTML pages, serialized JSON, and
    more | Good to create a cache for a gaming leaderboard, a live voting app, and
    more |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 适合缓存简单字符串，如简单HTML页面、序列化JSON等 | 适合为游戏排行榜、实时投票应用等创建缓存 |'
- en: Table 4.1 – Memcached versus Redis comparison
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.1 – Memcached与Redis的比较
- en: If you need to decide which engine to use, base it on a use case that can justify
    using Redis or Memcached. Memcached is simple and has lower maintenance, and it
    is typically preferred when your cache doesn’t need the advanced features that
    Redis offers. However, Redis is the best solution if you need the advantage of
    data persistence, advanced data types, or any of the other features listed.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要决定使用哪个引擎，应该根据一个能够证明使用Redis或Memcached的用例来选择。Memcached简单且维护成本较低，通常在你的缓存不需要Redis提供的高级功能时优先选择。然而，如果你需要数据持久性、高级数据类型或其他任何Redis列出的特性，Redis是最好的解决方案。
- en: When implementing caching, it’s essential to understand the validity of data
    that needs to be cached. If the **cache hit** rate is high, the data is available
    in the cache when required. For a higher cache hit ratio, offload the database
    by reducing direct queries, improving the overall application performance. A **cache
    miss** occurs when data is not present in the cache, which increases the load
    in the database. The cache is not a large data store, so you need to set the TTL
    and evict the cache as per your application needs.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现缓存时，理解需要缓存的数据的有效性是至关重要的。如果**缓存命中**率很高，则数据在需要时可以从缓存中获取。为了提高缓存命中率，通过减少直接查询来卸载数据库，从而提升整体应用性能。**缓存未命中**发生在数据不在缓存中时，这会增加数据库的负担。缓存不是一个大型数据存储，因此你需要根据应用需求设置TTL并逐出缓存。
- en: As you have seen in this section, applying caches has multiple benefits, including
    application performance improvement, the ability to provide predictable performance,
    and the reduction in database cost.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，应用缓存有多个好处，包括提升应用性能、提供可预测的性能以及减少数据库成本。
- en: Let’s learn about some more application-based architecture that demonstrates
    the principle of loose coupling and constraint handling, MVC architecture.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解更多应用程序架构，展示松耦合和约束处理原则的MVC架构。
- en: Model-View-Controller (MVC) architecture
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型-视图-控制器（MVC）架构
- en: 'MVC is one of the most popular design patterns for developing software applications.
    It separates an application into three interconnected components: Model, View,
    and Controller. This separation enables more modular development, easier testing,
    and excellent maintainability. Let’s explore these components in detail:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: MVC是开发软件应用程序时最流行的设计模式之一。它将应用程序分为三个互相关联的组件：模型、视图和控制器。这样的分离实现了更模块化的开发、更容易的测试和出色的可维护性。让我们详细探讨这些组件：
- en: '**Model**: The Model represents the internal state of the application, along
    with the rules, logic, and data that govern and manipulate that state. The model
    does not depend on the View or Controller, meaning changes to the UI or business
    logic do not affect the data handling. It ensures that the application’s data
    remains consistent across different parts of the application. Its responsibilities
    include:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：模型表示应用程序的内部状态，以及管理和操作该状态的规则、逻辑和数据。模型不依赖于视图或控制器，这意味着UI或业务逻辑的变化不会影响数据处理。它确保应用程序的数据在不同部分之间保持一致。它的责任包括：'
- en: '**Managing data**: It contains all the data-related logic. Whether it’s retrieving
    data from a database or an API, the model handles it.'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理数据**：它包含所有与数据相关的逻辑。无论是从数据库还是API中检索数据，模型都会处理。'
- en: '**Implementing business rules**: Implements business logic, such as calculations
    or data transformations.'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现业务规则**：实现业务逻辑，如计算或数据转换。'
- en: '**Notifying of changes**: Informs associated Views and Controllers when the
    data has changed so they can update themselves accordingly.'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通知变更**：当数据发生变化时，通知相关的视图和控制器，以便它们可以相应地更新自己。'
- en: '**View**: The View is the visual representation of the Model’s data. It defines
    exactly how the application’s data is presented to the user. The View automatically
    updates when the underlying Model data changes, ensuring the user always sees
    the most current data. Multiple Views can be created from the same Model data,
    allowing different representations (e.g., tables, charts, detailed views). Its
    responsibilities include:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：视图是模型数据的可视化表现。它定义了应用程序数据如何呈现给用户。当底层模型数据发生变化时，视图会自动更新，确保用户始终看到最新的数据。可以从同一模型数据创建多个视图，允许不同的表现形式（例如，表格、图表、详细视图）。它的职责包括：'
- en: '**Displaying data**: Takes the data from the model and presents it in a format
    that’s easy to understand.'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示数据**：从模型中获取数据，并以易于理解的格式呈现。'
- en: '**Handling the user interface** (**UI**): Handles all the UI logic of the application,
    such as user input fields, buttons, display screens, etc.'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理用户界面**（**UI**）：处理应用程序的所有 UI 逻辑，如用户输入字段、按钮、显示屏等。'
- en: '**Controller**: The Controller mediates between the Model and the View. It
    takes user inputs from the View, processes them (with potential updates to the
    Model), and returns the output display to the View. The controller ensures that
    the View and the Model are always in sync with each other. It acts as a centralized
    handler for all user interactions, making the management of those interactions
    more systematic and organized. Its responsibilities include:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：控制器在模型和视图之间进行调解。它从视图获取用户输入，处理这些输入（可能会更新模型），并将输出显示返回给视图。控制器确保视图和模型始终保持同步。它充当所有用户交互的集中处理器，使得这些交互的管理更加系统化和有序。它的职责包括：'
- en: '**Handling user input**: Takes and interprets user commands, translating them
    into actions to be performed by the model'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理用户输入**：接收并解释用户命令，将其转化为模型执行的动作'
- en: '**Updating the Model**: Modifies the data in the Model by sending commands
    to it'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新模型**：通过向模型发送命令来修改模型中的数据'
- en: '**Updating the View**: Changes what is presented in the View based on user
    input and Model changes'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新视图**：根据用户输入和模型变化更改视图中呈现的内容'
- en: 'The following are the key advantages of applying the MVC pattern:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是应用 MVC 模式的主要优势：
- en: '**Separation of concerns**: By isolating the application’s data, user interface,
    and control logic, MVC promotes modular development.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点分离**：通过将应用程序的数据、用户界面和控制逻辑隔离开来，MVC 促进了模块化开发。'
- en: '**Reusability**: Components can be reused across different parts of an application
    or even different applications.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：组件可以在应用程序的不同部分甚至不同的应用程序之间重用。'
- en: '**Maintainability**: It makes updating, testing, and debugging different parts
    of the application easier.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：使得更新、测试和调试应用程序的不同部分变得更加容易。'
- en: '**Flexibility**: Enables developers to change one part of the system without
    affecting others, such as changing the UI without altering the underlying data
    processing.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：使开发者能够在不影响其他部分的情况下更改系统的一部分，例如更改 UI 而不改变底层数据处理。'
- en: MVC is a powerful architectural pattern that offers robust data management,
    user interface, and business logic management. It’s widely used in various application
    development environments, from web development frameworks to desktop applications,
    to create scalable and maintainable software. By following the principles of MVC,
    application architects can create organized, efficient, and flexible applications
    that are easier to update and maintain. Let’s consider an example to understand
    MVC better.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 是一种强大的架构模式，提供了强大的数据管理、用户界面和业务逻辑管理。它广泛应用于各种应用开发环境，从 Web 开发框架到桌面应用程序，帮助创建可扩展和易于维护的软件。通过遵循
    MVC 原则，应用程序架构师可以创建组织良好、高效且灵活的应用程序，便于更新和维护。让我们通过一个例子更好地理解 MVC。
- en: Applying MVC to design an online bookstore
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 MVC 应用于设计一个在线书店
- en: 'When designing an online bookstore, for example, the MVC architecture efficiently
    handles complex interactions between book data, user interface, and user inputs,
    leading to a more robust and scalable system. Let’s look at the details of each
    module:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在设计一个在线书店时，MVC 架构可以高效地处理书籍数据、用户界面和用户输入之间的复杂交互，从而构建一个更加健壮和可扩展的系统。让我们来看看每个模块的详细内容：
- en: '**Model**: Managing the data related to books, authors, categories, customer
    reviews, etc. Examples of operations are:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：管理与书籍、作者、分类、客户评价等相关的数据。操作示例包括：'
- en: Retrieving details of a specific book
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取特定书籍的详细信息
- en: Updating the inventory after a purchase
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购买后更新库存
- en: Adding a new book to the catalog
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新书到目录
- en: '**View**: Displaying information to the user in a readable and interactive
    format. Examples of Views are:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：以易读和互动的格式向用户展示信息。视图的示例包括：'
- en: '**Book listing page**: Displays a list of books with their titles, covers,
    and prices'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**书籍列表页面**：显示书籍的标题、封面和价格列表'
- en: '**Book detail page**: Shows detailed information about a specific book, including
    author, description, reviews, etc.'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**书籍详情页**：显示有关特定书籍的详细信息，包括作者、简介、评价等。'
- en: '**Shopping cart page**: Allows users to view, add, or remove items from their
    shopping cart'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**购物车页面**：允许用户查看、添加或移除购物车中的商品'
- en: '**Controller**: Handling user interaction, updating the model as needed, and
    updating the View to reflect changes. Examples of actions are:'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：处理用户交互，根据需要更新模型，并更新视图以反映变化。操作示例包括：'
- en: '**Searching for a book**: The user enters a search term. The Controller queries
    the model for matching books and updates the View to display the results.'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索书籍**：用户输入搜索词。控制器查询模型中匹配的书籍，并更新视图以显示结果。'
- en: '**Adding to cart**: The user clicks **Add to Cart**, the Controller updates
    the model to reflect the new item in the cart, and the View is updated to show
    the new cart status.'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加到购物车**：用户点击**添加到购物车**，控制器更新模型，反映购物车中的新商品，视图随之更新以显示新的购物车状态。'
- en: '**Checkout**: The user decides to purchase. The Controller processes the transaction,
    updates the model (including inventory), and redirects to a confirmation View.'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结账**：用户决定购买。控制器处理交易，更新模型（包括库存），并重定向到确认视图。'
- en: The MVC pattern provides a clean separation of concerns, making extending, maintaining,
    and testing applications easier.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 模式提供了清晰的关注点分离，使得扩展、维护和测试应用程序变得更加容易。
- en: Building Domain-Driven Design (DDD)
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建领域驱动设计（DDD）
- en: '**Domain-Driven Design** (**DDD**) is a methodology and set of practices aimed
    at understanding and solving complexity at the heart of software. This approach
    is used to design and model software based on the “domain,” or the business’s
    core logic and key concepts. Using a common language and dividing the system into
    clear contexts, DDD promotes a deep understanding of the problem space and leads
    to a design that accurately reflects the underlying business needs. It’s particularly
    valuable in complex domains, where aligning the software closely with the real-world
    concepts it represents is vital.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**领域驱动设计**（**DDD**）是一种方法论和一组实践，旨在理解并解决软件核心复杂性。该方法用于基于“领域”或业务核心逻辑和关键概念来设计和建模软件。通过使用通用语言并将系统划分为清晰的上下文，DDD
    促进了对问题空间的深入理解，并导致一个准确反映底层业务需求的设计。它在复杂领域中特别有价值，因为在这些领域，确保软件与它所代表的现实世界概念紧密对齐至关重要。'
- en: 'Let’s delve into DDD using a concrete example and use case. For this, we’ll
    consider the domain of a **Healthcare Management System** (**HMS**). Imagine we’re
    developing a system that manages patient records, appointments, medical treatments,
    billing, etc. for a healthcare provider. Here’s how we could apply DDD concepts
    to this domain:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个具体的示例和用例深入探讨 DDD。为此，我们将考虑一个**医疗健康管理系统**（**HMS**）的领域。假设我们正在开发一个为医疗服务提供商管理患者记录、预约、医疗治疗、账单等的系统。我们可以将
    DDD 的概念应用到这个领域，方法如下：
- en: '**Domain**: A “domain” refers to a specific problem area the software intends
    to address. The application logic revolves around the sphere of knowledge and
    activity. Understanding the domain is essential for creating a system that truly
    meets the needs of the business. For HMS, the domain will behealthcare management,
    focusing on patients, medical staff, appointments, treatments, and billing.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域**： "领域"指的是软件旨在解决的特定问题领域。应用逻辑围绕着这一知识和活动范围展开。理解领域对于创建一个真正满足业务需求的系统至关重要。对于医疗管理系统（HMS）来说，领域将是医疗管理，聚焦于病人、医疗人员、预约、治疗和账单。'
- en: '**Ubiquitous Language**: Ubiquitous Language is a shared language between developers
    and non-technical stakeholders that describes the domain. This common language
    ensures that all team members understand the key terms and concepts in the same
    way, reducing misunderstandings and promoting clear communication for the HMS,
    creating a shared language that both medical professionals and developers understand,
    for example, **Patient**, **Appointment**, **Treatment**, **Medical Staff**, etc.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用语言**：通用语言是开发人员和非技术利益相关者之间共享的语言，用来描述领域。这种共同的语言确保团队成员对关键术语和概念有统一的理解，减少误解，促进清晰的沟通。对于HMS，创建一个既能被医疗专业人员又能被开发人员理解的共享语言，例如，**病人**、**预约**、**治疗**、**医疗人员**等。'
- en: '**Bounded contexts**: In DDD, the application is divided into different bounded
    contexts, each representing a specific responsibility or functionality within
    the overall domain. A bounded context encapsulates all the terms, definitions,
    and logic for that specific part of the domain, and it is explicit about what
    is inside and outside its boundaries. For example, the **Patient Management**
    bounded context handles patient records, personal information, medical history,
    etc. An **Appointment Scheduling** bounded context includes managing appointments,
    scheduling, cancellations, rescheduling, etc., and the **Billing** bounded context
    includes processing payments, insurance, invoices, etc.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限界上下文**：在领域驱动设计（DDD）中，应用程序被划分为不同的限界上下文，每个上下文代表领域内的特定职责或功能。限界上下文封装了该领域特定部分的所有术语、定义和逻辑，并明确什么是其边界内的，什么是边界外的。例如，**病人管理**限界上下文处理病人记录、个人信息、病历等；**预约调度**限界上下文包括管理预约、调度、取消、重新安排等；而**账单**限界上下文则包括处理付款、保险、发票等事务。'
- en: '**Entities**: These objects have a distinct identity that runs through time
    and different states, for example, patients (with a unique ID) and medical staff
    (with unique credentials).'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体**：这些对象具有独特的身份，贯穿不同的时间和状态，例如病人（拥有唯一ID）和医疗人员（拥有独特的资格证书）。'
- en: '**Value objects**: Objects that describe characteristics of a thing but have
    no conceptual identity. They are immutable and can be easily replaced. For example,
    **Address**, **Date of Birth**, and **Medical History** (as these don’t have individual
    identities).'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值对象**：描述事物特征但没有概念性身份的对象。它们是不可变的，可以轻松替换。例如，**地址**、**出生日期**和**病历**（因为这些没有单独的身份）。'
- en: '**Aggregates**: An aggregate is a cluster of associated objects treated as
    a single unit for data changes. One entity within the aggregate is the root, and
    external references are restricted to this root to ensure integrity. For example,
    in an online healthcare management system, a medical appointment can be modeled
    as an aggregate. The aggregate might include entities and value objects like **Patient**
    (who the appointment is for), **Medical Staff** (who will attend the patient),
    **Treatment Room** (where the appointment will take place), and **Time Slot**
    (when the appointment is scheduled). Here, the **Appointment** entity would be
    the aggregate root. Any changes to the **Patient**, **Medical Staff**, **Treatment
    Room**, or **Time Slot** related to a specific appointment would be made through
    the Appointment entity. This ensures that the appointment aggregate maintains
    consistency and enforces all business rules related to medical appointments.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合**：聚合是指一组关联对象，作为数据更改的单一单元进行处理。聚合内的一个实体被称为根实体，外部引用仅限于该根实体，以确保数据完整性。例如，在一个在线医疗管理系统中，医疗预约可以被建模为一个聚合。该聚合可能包括像**病人**（预约的对象）、**医疗人员**（为病人提供服务的人员）、**治疗室**（预约地点）、**时间段**（预约的时间）等实体和值对象。在这里，**预约**实体将是聚合根。与特定预约相关的任何**病人**、**医疗人员**、**治疗室**或**时间段**的更改都应通过预约实体进行。这确保了预约聚合的一致性，并强制执行所有与医疗预约相关的业务规则。'
- en: '**Repositories**: Repositories are used to retrieve aggregates from the underlying
    persistence layer. They provide an abstraction allowing the rest of the application
    to interact with the data store in a way consistent with the domain model. For
    example, the **Patient** repository is used to fetch and manage Patient entities,
    and the Appointment repository is used to retrieve and store Appointment aggregates.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仓储**：仓储用于从底层持久化层中检索聚合。它们提供了一种抽象，使得应用程序的其他部分可以以与领域模型一致的方式与数据存储进行交互。例如，**病人**仓储用于获取和管理病人实体，而预约仓储用于检索和存储预约聚合。'
- en: '**Factories**: Factories are responsible for encapsulating the logic of creating
    complex objects and aggregates. They ensure that an object or aggregate is created
    in a consistent and valid state. For example, the **Patient** factory is used
    to create a new **Patient** entity with a valid initial state, and the **Appointment**
    factory is used to create a new **Appointment** aggregate with the required details.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工厂**：工厂负责封装创建复杂对象和聚合的逻辑。它们确保对象或聚合在一致且有效的状态下创建。例如，**病人**工厂用于创建一个具有有效初始状态的新**病人**实体，而**预约**工厂用于创建一个包含必要细节的新**预约**聚合。'
- en: '**Services**: When an operation doesn’t logically belong to a value object
    or entity, it can be defined as a service. Services are part of the domain model
    and contain business logic that operates on the domain’s concepts. For example,
    in the **Billing** context, the billing service contains operations like calculating
    total charges, applying insurance discounts, generating invoices, etc.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**：当某个操作在逻辑上不属于值对象或实体时，可以将其定义为服务。服务是领域模型的一部分，包含针对领域概念的业务逻辑。例如，在**计费**上下文中，计费服务包含计算总费用、应用保险折扣、生成发票等操作。'
- en: '**Domain events**: Domain events capture the fact that something significant
    has happened within the domain. They can trigger other activities within the system
    or in other systems. For example, an appointment scheduled event triggered when
    a new appointment is scheduled may notify relevant staff members and a payment
    processed event occurs after successful payment, which might initiate a receipt
    generation process.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域事件**：领域事件捕捉领域内发生的重大事件。它们可以触发系统内或其他系统中的其他活动。例如，预约调度事件会在新预约安排时触发，通知相关工作人员；支付处理事件则会在支付成功后发生，可能会启动生成收据的流程。'
- en: '**Anti-corruption layer**: This layer translates between different parts of
    the system that use different languages or models. It ensures that each model’s
    integrity is maintained, and inconsistencies are handled.If the Billing system
    must interact with an external third-party payment gateway, an anti-corruption
    layer could translate between the domain model in the Billing context and the
    model used by the external system.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反腐层**：这一层负责在使用不同语言或模型的系统各部分之间进行转换。它确保每个模型的完整性得到维护，并处理不一致性。如果计费系统必须与外部第三方支付网关进行交互，反腐层可以在计费上下文中的领域模型与外部系统使用的模型之间进行转换。'
- en: In this HMS, DDD ensures that complex domain logic is carefully modeled and
    organized. It encourages collaboration between healthcare professionals (domain
    experts) and developers to create a shared understanding and language.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个HMS中，DDD确保复杂的领域逻辑得到精心建模和组织。它鼓励医疗专业人员（领域专家）与开发人员之间的协作，以创建共享的理解和语言。
- en: The system’s design closely aligns with real-world healthcare operations by
    defining clear bounded contexts, entities, aggregates, and other DDD concepts.
    This alignment ensures that the software provides a robust and flexible solution
    tailored to the specific needs of the healthcare domain.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的设计紧密结合了现实世界的医疗操作，通过定义明确的界限上下文、实体、聚合和其他DDD概念。这种对齐确保了软件提供了一种稳健且灵活的解决方案，满足医疗领域的特定需求。
- en: This example shows how DDD can be an essential tool in crafting complex, well-structured
    systems by focusing on the core domain and facilitating collaboration between
    different stakeholders.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了DDD如何通过关注核心领域并促进不同利益相关者之间的协作，成为打造复杂、结构良好的系统的关键工具。
- en: Dependency handling is an important aspect when working in complex systems.
    Let’s learn about how to handle dependency between different services via a circuit
    breaker to make sure an error in one service does not bring the entire system
    down.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the circuit breaker pattern
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s common for a distributed system to make a call to other downstream services,
    and the call could fail or hang without a response. You will often see code that
    retries the failed call several times. The problem with a remote service is that
    it could take minutes or even hours to correct, and an immediate retry might end
    up in another failure. As a result, end users wait longer to get an error response
    while your code retries several times. This retry function would consume the threads
    and potentially induce a cascading failure.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: The circuit breaker pattern is about understanding the health of downstream
    dependencies. It detects when those dependencies are unhealthy and implements
    logic to gracefully fail requests until it detects that they are healthy again.
    The circuit breaker can be implemented using a persistence layer to monitor healthy
    and unhealthy requests over the past request interval.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: If a defined percentage of requests observe an unhealthy behavior over the past
    interval or a total count of exceptions, regardless of percentage, the circuit
    is marked as open. In such a situation, all requests throw exceptions rather than
    integrate with the dependency for a defined timeout period. Once the timeout period
    has subsided, a small percentage of requests try integrating with the downstream
    dependency to detect when the health has returned. Once a sufficient percentage
    of requests are healthy again over an interval, or no errors are observed, the
    circuit closes again, and all the requests are allowed to thoroughly integrate
    as they usually would.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: The implementation decisions involve the state machine tracking/sharing the
    healthy/unhealthy request counts. The states of services can be maintained in
    DynamoDB, Redis/Memcached, or another low-latency persistence store.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Let’s next turn to the bulkhead architectural pattern, which helps to reduce
    dependency between services and mitigate the situation in the case of a service
    getting an error.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the bulkhead pattern
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bulkheads are structural partitions used in ships to create individual watertight
    sections. The primary purpose is to contain the consequences of any breach in
    the ship’s hull, thereby preventing water from spreading throughout the vessel
    in the event of damage. This design serves as a crucial safety measure, aiming
    to minimize the risk of the entire ship sinking if one area is compromised.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'The same concept is helpful to limit the scope of failure in the architecture
    of large systems where you want to partition your system to decouple dependencies
    between services. The idea is that one failure should not cause the entire system
    to fail, as shown in the following diagram:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing screenshot, rectangle, text  Description automatically
    generated](img/B21336_04_10.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![A picture containing screenshot, rectangle, text  Description automatically
    generated](img/B21336_04_10.png)'
- en: 'Figure 4.10: Bulkhead pattern'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10：舱壁模式
- en: 'In the bulkhead pattern, it’s better to isolate the element of the application
    into the pool for service, which has a high dependency; so, if one fails, others
    continue to serve upstream services. **Service 3** is partitioned into two pools
    from a single service in the preceding diagram. Here, if **Service 3** fails,
    then the impact of either **Service 1** or **Service 2** depends on their dependency
    on the pool, but the entire system does not go down. The following are the significant
    points to consider when introducing the bulkhead pattern in your design, especially
    for the shared service model:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在舱壁模式（bulkhead pattern）中，最好将应用程序的高依赖元素隔离到服务池中，这样如果其中一个发生故障，其他的可以继续为上游服务提供服务。**Service
    3** 在前面的图中从单一服务分隔成了两个池。在这里，如果**Service 3** 发生故障，**Service 1** 或 **Service 2**
    的影响将取决于它们对该池的依赖，但整个系统不会崩溃。引入舱壁模式时，需要特别注意以下几点，尤其是在共享服务模型下：
- en: Save part of the ship, which means your application should not shut down due
    to the failure of one service.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存部分船体，这意味着你的应用程序不应因一个服务的失败而关闭。
- en: Decide whether less efficient use of resources is okay. Performance issues in
    one partition should be fine for the overall application.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定是否可以接受资源使用效率较低。一个分区中的性能问题应该不会影响整个应用程序。
- en: Pick a useful granularity. Make sure to make the service pools manageable; make
    sure they can handle the application load.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择合适的粒度。确保服务池是可管理的，并且能够处理应用程序负载。
- en: Monitor each service partition performance and adhere to the SLA. Ensure all
    moving parts are working together and test the overall application when one service
    pool is down.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控每个服务分区的性能，并遵守服务水平协议（SLA）。确保所有组件协同工作，并在一个服务池宕机时测试整个应用程序。
- en: You should define a service partition for each business or technical requirement.
    It would be best if you used this pattern to prevent the application from cascading
    failure and isolating critical consumers from the standard consumer.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 应根据每个业务或技术需求定义一个服务分区。最好使用这种模式，以防止应用程序发生级联故障，并将关键消费者与普通消费者隔离开来。
- en: Often, legacy application servers have a configuration with hardcoded **Internet
    Protocol** (**IP**) addresses or **Domain Name System** (**DNS**) names. Making
    any server change for modernization and upgrade requires changing and revalidating
    the application. In these cases, you want to keep the server address the same.
    In the next section, let’s learn how to handle such a situation with a floating
    IP.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，遗留应用服务器的配置中会包含硬编码的**互联网协议**（**IP**）地址或**域名系统**（**DNS**）名称。进行现代化和升级时，任何服务器变更都需要修改和重新验证应用程序。在这种情况下，你希望保持服务器地址不变。在下一节中，我们将学习如何通过浮动IP来处理这种情况。
- en: Creating a floating IP pattern
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建浮动IP模式
- en: Commonly, monolithic applications have many dependencies on the server where
    they are deployed. Application configuration and code often have hardcoded parameters
    based on the server’s DNS name and IP address. Hardcoded IP configuration creates
    challenges if you want to bring up a new server in case of an issue with the original
    server. Additionally, you don’t want to bring down the entire application for
    the upgrade, which may cause significant downtime.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，单体应用程序对其部署的服务器有很多依赖。应用程序配置和代码通常会根据服务器的DNS名称和IP地址进行硬编码。如果你想在原始服务器出现问题时启动新服务器，硬编码的IP配置会带来挑战。此外，你不希望因升级而使整个应用程序停机，这可能会导致较长时间的停机。
- en: To handle such a situation, you need to create a new server keeping the same
    server IP address and DNS name. This can be achieved by moving the network interface
    from a problematic instance to the new server. The network interface is generally
    based on a **Network Interface Card** (**NIC**), which facilitates communication
    between servers over a network. It can be in the form of hardware or software.
    Moving the network interface means that now your new server assumes the identity
    of the old server. Your application can live with the same DNS and IP address.
    It also allows easy rollback by moving the network interface to the original instance.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理这种情况，您需要创建一个新的服务器，保持相同的服务器IP地址和DNS名称。这可以通过将网络接口从有问题的实例移动到新服务器来实现。网络接口通常基于**网络接口卡**（**NIC**），用于在网络上服务器之间进行通信。它可以是硬件或软件形式。移动网络接口意味着现在您的新服务器承担了旧服务器的身份。您的应用程序可以使用相同的DNS和IP地址。它还允许通过将网络接口移回原始实例来轻松回滚。
- en: 'The public cloud (for example, AWS) made it easy by providing an **Elastic
    IP** (**EIP**) and **Elastic Network Interface** (**ENI**). If your instance fails
    and you need to push traffic to another instance with the same public IP address,
    then you can move the EIP address from one server to another, as shown in the
    following architecture diagram:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 公共云（例如AWS）通过提供**弹性IP**（**EIP**）和**弹性网络接口**（**ENI**）简化了操作。如果您的实例发生故障，并且需要将流量推送到具有相同公共IP地址的另一个实例，则可以将EIP地址从一台服务器移动到另一台服务器，如下面的架构图所示：
- en: '![A picture containing text, screenshot, diagram, line  Description automatically
    generated](img/B21336_04_11.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![A picture containing text, screenshot, diagram, line  Description automatically
    generated](img/B21336_04_11.png)'
- en: 'Figure 4.11: Floating IP and interface pattern'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11：浮动IP和接口模式
- en: Since you are moving EIP, the DNS may not need to be updated. EIP can move your
    server’s public IP across instances. If you need to move public and private IP
    addresses, use a more flexible approach, such as ENI, as shown on the right of
    the preceding diagram. ENI can move across instances, and you can use the same
    public and private address for traffic routing or application upgrades.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您正在移动EIP，DNS可能不需要更新。EIP可以将您的服务器公共IP移动到不同的实例。如果需要移动公共和私有IP地址，则可以使用更灵活的方法，例如ENI，如前图右侧所示。ENI可以跨实例移动，并且您可以使用相同的公共和私有地址进行流量路由或应用程序升级。
- en: So far, you have learned about multiple architecture patterns where applications
    are deployed in the virtual machine. However, you may need help to utilize the
    virtual machine in many cases. To optimize your utilization further, you can deploy
    your application in containers. Containers are most suitable for microservice
    deployment. Let’s learn more about container-based deployment in the next section.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经了解了多种架构模式，其中应用程序部署在虚拟机中。但是，在许多情况下，您可能需要帮助来利用虚拟机。为了进一步优化您的利用率，您可以将应用程序部署在容器中。容器最适合于微服务部署。让我们在下一节中深入了解基于容器的部署。
- en: Deploying an application with a container
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用容器部署应用程序
- en: As many programming languages are invented, and technologies evolve, this creates
    new challenges. Different application stacks require different hardware and software
    deployment environments. Often, there is a need to run applications across different
    platforms and migrate from one platform to another. Solutions require something
    that can run anything everywhere and is consistent, lightweight, and portable.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 随着许多编程语言的发明和技术的进步，这带来了新的挑战。不同的应用堆栈需要不同的硬件和软件部署环境。通常需要在不同平台上运行应用程序并迁移至另一个平台。解决方案需要一种可以在任何地方运行并且一致、轻量且可移植的东西。
- en: Just as shipping containers standardize the transport of freight goods, software
    containers standardize the transport of applications. Docker creates a container
    that includes everything a software application would need to run its files, such
    as filesystem structure, daemons, libraries, and application dependencies.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 就像运输集装箱标准化了货物的运输一样，软件容器标准化了应用程序的运输。Docker创建一个包含软件应用程序运行所需的所有内容的容器，例如文件系统结构、守护程序、库和应用程序依赖项。
- en: Containers provide isolation for software within its respective development
    and staging environments. This isolation is essential because it prevents conflicts
    from arising when multiple teams are running various software applications on
    the same underlying infrastructure.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 容器为软件提供了相应开发和测试环境中的隔离。这种隔离至关重要，因为它可以防止多个团队在相同底层基础设施上运行各种软件应用时产生冲突。
- en: 'VMs are isolated at the operating system level, and containers isolate at the
    kernel level. This isolation allows several applications to run on a single-host
    operating system and yet still have their filesystem, storage, RAM, libraries,
    and, mostly, their own *view* of the system:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机在操作系统级别进行隔离，而容器则在内核级别进行隔离。这种隔离允许多个应用程序在单一主机操作系统上运行，并且仍然拥有各自的文件系统、存储、RAM、库，以及大多数情况下，各自的*系统视图*：
- en: '![A picture containing text, screenshot, font, number  Description automatically
    generated](img/B21336_04_12.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![一张包含文本的图片，截图，字体，数字  描述自动生成](img/B21336_04_12.png)'
- en: 'Figure 4.12: Virtual machines and containers for application deployment'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12：应用程序部署的虚拟机和容器
- en: As shown in the preceding diagram, containers deploy multiple applications in
    a single virtual machine. Each application has its runtime environment, so you
    can run many individual applications while keeping the same number of servers.
    Containers share a machine’s operating system kernel. They offer advantages like
    quick startup times and efficient use of computing resources such as RAM. Container
    images are built using layers from the filesystem, and they can share common files.
    This shared resource approach reduces disk usage and speeds up the process of
    downloading container images.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，容器在单个虚拟机中部署多个应用程序。每个应用程序都有其运行时环境，因此您可以在保持服务器数量不变的情况下运行多个独立应用程序。容器共享机器的操作系统内核。它们具有快速启动时间和高效利用计算资源（如
    RAM）的优点。容器镜像是通过文件系统的层构建的，可以共享公共文件。这种共享资源的方法减少了磁盘使用量并加快了下载容器镜像的速度。
- en: Let’s look at why containers are becoming more popular, along with their benefits.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看为什么容器越来越受欢迎，以及它们的好处。
- en: The benefit of containers
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器的好处
- en: 'These questions are often asked when it comes to containers:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 关于容器，经常会有人提出以下问题：
- en: Why do we need containers when we have instances?
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们已有实例时，为什么还需要容器？
- en: Don’t instances already provide us with isolation from the underlying hardware?
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 难道实例不已经为我们提供了与底层硬件的隔离吗？
- en: While the preceding questions are valid, several benefits accrue from using
    a system such as **Docker**. One of the key benefits of Docker is that it allows
    you to fully utilize your virtual machine resources by hosting multiple applications
    (on distinct ports) in the same instance.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的问题是有效的，但使用像**Docker**这样的系统仍然有许多好处。Docker 的一个关键优势是，它允许您通过在同一实例中托管多个应用程序（在不同端口上）来充分利用虚拟机资源。
- en: 'Docker uses certain features of the Linux kernel, namely kernel namespaces
    and groups, to achieve complete isolation between each Docker process, as indicated
    in the following architecture diagram:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 利用 Linux 内核的某些特性，特别是内核命名空间和组，来实现每个 Docker 进程之间的完全隔离，正如下图所示：
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B21336_04_13.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  描述自动生成，可信度较低](img/B21336_04_13.png)'
- en: 'Figure 4.13: Container layer in application infrastructure'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13：应用程序基础架构中的容器层
- en: 'As shown in the preceding diagram, it’s possible to run two or more applications
    that require different versions of the Java runtime on the same machine, as each
    Docker container has its version of Java and the associated libraries installed.
    In turn, the container layer in the application infrastructure makes it easier
    to decompose your applications into microservices that can run side by side on
    the same instance. Containers have the following benefits:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，实际上可以在同一台机器上运行两个或多个需要不同版本 Java 运行时的应用程序，因为每个 Docker 容器都有自己安装的 Java 版本和相关库。进而，应用程序基础架构中的容器层使得将应用程序拆解为微服务变得更加容易，这些微服务可以在同一实例上并行运行。容器具有以下优点：
- en: '**Portable runtime application environment**: Containers provide platform-independent
    capabilities, where you build your application once and deploy it anywhere regardless
    of the underlying operating system.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可移植的运行时应用环境**：容器提供平台无关的能力，您可以一次构建应用程序并在任何地方部署，无论底层操作系统如何。'
- en: '**Faster development and deployment cycles**: Modify the application and run
    it anywhere with a quick boot time, typically within seconds.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更快的开发和部署周期**：修改应用程序并快速启动，通常几秒钟内即可运行，几乎可以在任何地方进行。'
- en: '**Package dependencies and application in a single artifact**: Package the
    code, library, and dependencies together to run the application in any operating
    system.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将依赖项和应用程序打包成单一工件**：将代码、库和依赖项打包在一起，使应用程序能够在任何操作系统上运行。'
- en: '**Run different application versions**: Applications with different dependencies
    run simultaneously in a single server.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行不同版本的应用程序**：具有不同依赖关系的应用程序可以在同一服务器上同时运行。'
- en: '**Everything can be automated**: Container management and deployment are done
    through scripting, which helps to reduce cost and the risk of human error.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一切皆可自动化**：容器管理和部署通过脚本进行，帮助减少成本并降低人为错误的风险。'
- en: '**Better resource utilization**: Containers provide efficient scaling and high
    availability, and multiple copies of the same microservice container can be deployed
    across servers for your application.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的资源利用**：容器提供高效的扩展和高可用性，同一微服务容器的多个副本可以在服务器之间部署，为您的应用程序提供支持。'
- en: '**Easy to manage the security aspect**: Containers are platform-specific rather
    than application-specific.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻松管理安全性**：容器是特定于平台的，而不是特定于应用程序的。'
- en: Container deployment is becoming very popular due to its benefits. There are
    multiple ways to orchestrate containers. Let’s look at container deployment in
    more detail next.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其优势，容器部署变得非常流行。有多种方式可以编排容器。接下来，我们将更详细地了解容器部署。
- en: Container deployment
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器部署
- en: Complex applications with multiple microservices can be quickly deployed using
    container deployment. The container makes building and deploying the application
    more manageable as the environment is the same. Build the container in development
    mode, push it to test, and then release it to production. For hybrid cloud environments,
    container deployment is very useful. Containers make it easier to keep environments
    consistent across microservices. As microservices aren’t always very resource-consuming,
    they can be placed together in a single instance to reduce cost.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器部署，具有多个微服务的复杂应用程序可以迅速部署。容器使得构建和部署应用程序更加可管理，因为环境是一致的。在开发模式下构建容器，将其推送到测试环境，再发布到生产环境。对于混合云环境，容器部署非常有用。容器使得在微服务之间保持环境一致性变得更容易。由于微服务通常不会消耗大量资源，它们可以被放置在同一个实例中以降低成本。
- en: Sometimes, customers have short workflows that require a temporary environment
    setup. Those environments may be queue systems or continuous integration jobs,
    which don’t always utilize server resources efficiently. Container orchestration
    services such as Docker and Kubernetes can be a workaround, allowing them to push
    and pop containers onto the instance.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，客户的工作流较短，需要临时的环境设置。这些环境可能是队列系统或持续集成任务，这些任务不总是高效地利用服务器资源。容器编排服务如 Docker 和
    Kubernetes 可以作为解决方案，允许它们将容器推送到实例并随时弹出。
- en: Docker’s lightweight container virtualization platform provides tools to manage
    your applications. Its standalone application can be installed on any computer
    to run containers. Kubernetes is a container orchestration service that works
    with Docker and another container platform. Kubernetes allows automated container
    provisioning and diligently handles security, networking, and scaling aspects.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 的轻量级容器虚拟化平台提供了管理应用程序的工具。它的独立应用程序可以安装在任何计算机上，以运行容器。Kubernetes 是一个与 Docker
    以及其他容器平台配合使用的容器编排服务。Kubernetes 允许自动化容器配置，并精心处理安全性、网络和扩展等方面的问题。
- en: Containers help the enterprise to create more cloud-native workloads, and public
    cloud providers such as AWS extend services to manage Docker containers and Kubernetes.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 容器帮助企业创建更多的云原生工作负载，公共云服务提供商如 AWS 扩展了服务来管理 Docker 容器和 Kubernetes。
- en: 'The following diagram shows Docker’s container management using Amazon **Elastic
    Container Service** (**ECS**), providing a fully managed elastic service to automate
    the scaling and orchestration of Docker containers:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了 Docker 使用 Amazon **弹性容器服务** (**ECS**) 进行容器管理，提供全托管的弹性服务，自动化 Docker 容器的扩展和编排：
- en: '![A diagram of a load balancer  Description automatically generated with low
    confidence](img/B21336_04_14.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![负载均衡器的图示  描述自动生成，置信度较低](img/B21336_04_14.png)'
- en: 'Figure 4.14: Container deployment architecture'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14：容器部署架构
- en: In the preceding diagram, multiple containers are deployed in a single Amazon
    EC2 virtual machine managed through Amazon ECS, which facilitates the agent communication
    service and cluster management. All user requests are distributed using a load
    balancer among the containers. Similarly, AWS provides Amazon **Elastic Kubernetes
    Service** (**EKS**) to manage containers using Kubernetes.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Containers are a broad topic, and as a solutions architect, you must be familiar
    with all the available options. This section provides an overview of containers.
    However, you will need to dive further if you utilize containers for your microservice
    deployment. Let’s look at container-based architecture in the next section.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Building container-based architecture
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you learned in the previous section, containerization helps create environments
    for repeatable and scalable applications. To start container adoption, you need
    to identify a pilot workload managed through container orchestration. You can
    take existing microservice components and deploy them in containers. After identifying
    gaps and operational needs, you can define a migration strategy to move your workload
    to containers.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Container migrations can be challenging if your applications are not originally
    designed to operate in a containerized environment. This is because many applications
    typically store files locally and rely on stateful sessions. When migrating to
    containers, it’s essential to address these specific requirements and ensure that
    your applications can function smoothly within the container environment.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: For container platforms, you can make choices; you can choose Docker, OpenShift,
    Kubernetes, and so on. However, Kubernetes is becoming an increasingly popular
    open-source container orchestrator. Public cloud vendors like AWS provide a platform
    to manage containers, such as Amazon ECS for Docker and Amazon EKS for Kubernetes.
    These cloud services provide a control plane to choose various compute options
    to select self-managed nodes, managed nodes, or serverless options with AWS Fargate.
    The control plane serves as the central management interface, allowing for the
    orchestration and operational oversight of containerized applications and their
    resources. If you are utilizing Amazon EKS for deploying a microservices-based
    application, for example, the Kubernetes control plane, managed by AWS, takes
    care of orchestrating container deployments, managing state, and maintaining desired
    configurations. This setup allows you to focus on application development rather
    than managing infrastructure.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: The following architecture diagram shows running a stateful service on Amazon
    EKS in your programming languages of choice, such as Java or .NET. Given the architecture,
    you can manage the session state in a Redis database.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing text, screenshot, diagram, display  Description automatically
    generated](img/B21336_04_15.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.15: Deploying a stateful application on a container'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the preceding diagram, the container-based architecture comprises
    several key components:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'An Amazon **Virtual Private Cloud** (**VPC**) with specific subnets:'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Public subnet: Hosts the load balancer'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Private subnets: Used for deploying the application and database'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An Application Load Balancer, responsible for providing access to the website
    hosted within the containers.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Amazon **Elastic Kubernetes Service** (**EKS**) cluster featuring a managed
    node group within Kubernetes. These nodes are responsible for running multiple
    application containers.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Amazon ElastiCache Redis database, utilized to store user session state.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This architecture allows for the scalability of the application by storing user
    sessions in a Redis database. However, please note that implementing this solution
    may require modifications to the application code, which may not be feasible in
    certain scenarios.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Now, you have learned about various architecture patterns focusing on application
    development. Data is an integral part of any architectural design, and most of
    the architecture revolves around collecting, storing, and processing data visualization.
    In the next section, let’s learn more about handling data in application architecture.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Database handling in application architecture
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data is always central to any application development, and scaling data has
    always been challenging. Handling data efficiently improves application latency
    and performance. In the earlier section *Building a cache-based architecture*,
    you learned how to handle frequently queried data by putting a cache in front
    of your database under the app caching pattern. You can put either a Memcached
    or Redis cache in front of your database, reducing the many hits on the database
    and improving database latency.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: In application deployment, as your application’s user base grows, you need to
    handle more data with your relational database. You need to add more storage or
    vertically scale the database server by adding more memory and CPU power. Often,
    horizontal scaling is more complex when it comes to scaling relational databases.
    If your application is read-heavy, you can achieve horizontal scaling by creating
    a read replica. Route all read requests to database read replicas while keeping
    the master database node to serve write and update requests. As a read replica
    has asynchronous replication, it can add some lag time. You should choose the
    read replica option if your application can tolerate some milliseconds of latency.
    You can use read replicas to offload reporting.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: You can use database sharding to create a multi-master for your relational database
    and inject the concept of horizontal scaling. The sharding technique is used to
    improve writing performance with multiple database servers. The database is structured
    and segmented into identical sections, with appropriate table columns serving
    as keys for distributing the writing processes.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'As demonstrated in the following architecture diagram, the customer database
    can be divided into multiple shards:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing text, screenshot, diagram, line  Description automatically
    generated](img/B21336_04_16.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.16: Relational database sharding'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding diagram, without *shards*, all data resides in one
    partition, for example, the first names of all users being in one single database.
    With sharding, data is split into large chunks called shards. For example, all
    users’ first names beginning with **A to I** are in one database, **J to R** in
    another, and **S to Z** in a third database. In many circumstances, sharding gives
    you higher performance and better operating efficiency.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing Amazon RDS for sharding backend databases involves installing sharding
    software, such as MySQL, along with a Spider storage engine on an Amazon EC2 instance.
    Subsequently, you can begin by setting up multiple RDS databases and employing
    them as backend databases for sharding.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: However, what if your master database instance goes down? In that case, you
    need to maintain high availability for your database. Let’s take a closer look
    at the high-availability database pattern.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: High-availability database pattern
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the high availability of your application, it is critical to keep your
    database up and running all the time. As horizontal scaling is not a straightforward
    option in the relational database, it creates additional challenges. To achieve
    high database availability, you can have a standby replica of the master database
    instance, as shown in the following diagram:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing text, screenshot, line, diagram  Description automatically
    generated](img/B21336_04_17.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.17: High-availability database pattern'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding diagram, your application server switches over to
    the standby instance if the primary instance goes down. A read replica takes the
    load off the primary instance to handle latency. The primary and standby are located
    in different **availability zones**, so your application will still be up even
    when an entire availability zone is down. This architecture also helps to achieve
    zero downtime, which may be caused during the database maintenance window. When
    a primary instance is down for maintenance, the application can fail over to a
    secondary standby instance and continue serving user requests.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: For disaster recovery, you will want to define the database backup and archival
    strategy, depending on your application’s **recovery point objective** (**RPO**)
    of how frequently you want to take backups. You will learn about RPOs and RTOs
    in depth in *Chapter 8*, *Architectural Reliability Considerations*.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: If your RPO is 30 minutes, it means your organization can only tolerate 30 minutes’
    worth of data loss. In that case, you should take a backup every half an hour.
    While storing the backup, you need to determine how long the data can be stored
    for customer query purposes. You can store data for six months as an active backup
    and then in an archival store as per the compliance requirement.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Consider how quickly you need to access your backup and determine the type of
    network connection needed to meet your backup and recovery requirements as per
    the company’s **recovery time objective** (**RTO**).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: For example, if your company’s RTO is 60 minutes, it means you should have enough
    network bandwidth to retrieve and restore your backup within an hour. Also, define
    whether you are backing up snapshots of complete systems or volumes attached to
    systems.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: You may also need to classify your data, for example, if it has customer-sensitive
    information such as email, addresses, personally identifiable information, and
    more. It would be best if you defined the data encryption strategy accordingly.
    You will learn more about data security in *Chapter 7*, *Security Considerations*.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your application’s growth and complexity, consider migrating from
    an RDBMS to a NoSQL database. NoSQL can provide greater scalability, management,
    performance, and reliability than most relational databases. However, the process
    of migrating to NoSQL from an RDBMS can be time-consuming and labor-intensive.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot of data to process in any application, for example, clickstream
    data, application log data, rating and review data, social media data, and more.
    Analyzing these datasets and getting insight can help you to grow your organization
    exponentially. *Chapter 12*, *Data Engineering for Solution Architecture*, will
    teach you more about these use cases and patterns.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn about building a maintainable system using Clean Architecture.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Clean Architecture
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clean Architecture, also known as Hexagonal Architecture or Ports and Adapters,
    is an architectural pattern used in designing business applications. Robert C.
    Martin proposed it and it emphasizes the separation of concerns, maintainability,
    and testability. Clean Architecture aims to create a flexible, adaptable, and
    maintainable system over time.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'Clean Architecture divides your application into five key components; let’s
    understand them through the example of an online bookstore:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '**Entities (innermost layer)**: Entities are the business objects that encapsulate
    the core business rules. They are independent of any specific technology, database,
    or framework. Entities represent the “things” in the system and what they can
    do. In an online bookstore, a `Book` entity might have properties like title,
    author, price, and methods to check availability or apply discounts.'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Use cases**: Use cases contain the application-specific rules and define
    how the entities interact to fulfill specific scenarios or user stories. They
    coordinate the flow of data and actions between entities and external interfaces.
    They are also technology-agnostic, focusing only on business logic. The checkout
    use case might involve validating the shopping cart, applying discounts, calculating
    shipping, and processing payment, for example.'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Interfaces (ports)**: Interfaces define contracts for how different layers
    of the system interact with each other. They create a boundary that separates
    the inner layers (entities and use cases) from the outer layers (adapters, frameworks,
    and drivers). This separation enables flexibility and maintainability. There might
    be an interface for payment processing that defines methods like processing payments
    and refunds.'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Adapters**: Adapters implement the interfaces and translate between the inner
    and outer layers. They allow the application to interact with external components
    like databases, APIs, or third-party libraries. Adapters allow the core logic
    to remain isolated from technological changes or external dependencies. A database
    adapter might implement a data access interface to handle interaction with a specific
    database technology.'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Frameworks and drivers (outermost layer)**: This layer comprises all the
    technical details and tools used to build the application. It includes web servers,
    databases, UI frameworks, third-party libraries, etc. This layer interacts with
    the adapters to connect the core application to the outside world. This could
    include implementing a RESTful API using a specific web framework, setting up
    a connection to an SQL database, or integrating with a third-party payment gateway.'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Clean Architecture, each layer is independent of the others, allowing changes
    in one layer without affecting the others. You can switch databases, change the
    UI framework, or modify business logic without causing ripple effects throughout
    the system. Since your architecture has well-defined interfaces, it’s easier to
    create mocks or stubs for testing. Core business logic can be tested independently
    from databases, UI, or other external dependencies.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: While using Clean Architecture, make sure to avoid over-engineering. For simple
    or small projects, the complexity and overhead of Clean Architecture might need
    to be revised. It requires careful consideration of whether the benefits outweigh
    the increased complexity and development time.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Clean Architecture provides a robust and flexible foundation for developing
    software that can adapt to changing technologies and requirements. Focusing on
    separating concerns and clear boundaries between layers promotes maintainability,
    scalability, and testability. It’s a robust pattern that can serve well in complex
    systems but must be applied with an understanding of the needs and context of
    the specific project to avoid unnecessary complexity.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Now, you have learned about various architectural patterns and best practices.
    Let’s learn about key anti-patterns that you should be careful of when designing
    application architecture.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding anti-patterns in solution architecture
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you have learned about a different way of designing solution
    architecture with various design patterns. Often, teams can drift away from best
    practices due to timeline pressure or the unavailability of resources. It is advised
    to try and avoid the following architecture design anti-patterns. An anti-pattern
    serves as an example of a poorly designed system:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: In an anti-pattern, scaling is handled reactively and manually. When application
    servers reach their maximum capacity and have no more resources available, users
    face disruptions in accessing the application. It’s only when users start reporting
    issues that the administrator becomes aware of the problem. The admin then initiates
    the process of launching a new server instance to alleviate the load on existing
    servers. However, there’s a drawback to this approach as there’s typically a delay
    of a few minutes between the instance launches and its actual availability. During
    this intervening period, users experience service interruptions and are unable
    to access the application. You should take a proactive approach and use auto-scaling
    to add processing power when servers reach a certain threshold, like 60% CPU or
    60% memory utilization.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With anti-patterns, automation is missing. When application servers crash, the
    admin manually launches and configures the new server and notifies the users manually.
    Automating the detection of unhealthy resources and launching replacement resources
    can streamline operations. Furthermore, it’s possible to implement automated notifications
    when such resource changes occur.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With anti-patterns, the server is kept for a long time with hardcoded IP addresses,
    which prevents flexibility. Over time, server configurations can become inconsistent,
    leading to the inefficient allocation of resources, with some resources running
    when they are not needed. It would help if you kept all of the servers identical
    and had the ability to switch to a new IP address. You should automatically terminate
    any unused resources.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With anti-patterns, an application is built monolithically, where all layers
    of the architecture, including web, application, and data layers, are tightly
    coupled and server-dependent. If one server crashes, it brings down the entire
    application. Keep the application and web layers independent by adding a load
    balancer in between. In the event that one of the application servers becomes
    unavailable, the load balancer automatically redirects all traffic to the remaining
    healthy servers.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With anti-patterns, the application is server-bound, and the servers communicate
    directly with each other. User authentication and sessions are stored in the server
    locally, and all static files are served from the local server. You should create
    a service-oriented RESTful architecture, where the services talk to each other
    using a standard protocol such as HTTP. User authentication and sessions should
    be stored in low-latency distributed storage to scale the application horizontally.
    The static asset should be stored in centralized object storage decoupled from
    the server.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With anti-patterns, a single database is used for all kinds of needs. You use
    a relational database for all needs, which introduces performance and latency
    issues. You should use the right storage for the right need, such as the following:'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NoSQL to store the user session
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache data storage for low-latency data availability
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Data warehouse for reporting needs
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Relational database for transactional data
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With anti-patterns, you will find a single point of failure by having a single
    database instance to serve the application. Whenever feasible, remove single points
    of failure from your architecture. Establish a secondary server (standby) and
    replicate the data. In the event of a primary database server failure, the secondary
    server can take over the workload.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With anti-patterns, static content such as high-resolution images and videos
    are served directly from the server without caching. It would be best if you considered
    using a CDN to cache heavy content near the user location, which helps to improve
    page latency and reduce page load time.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With anti-patterns, you can find security loopholes that open server access
    without a fine-grained security policy. You should always apply the principle
    of least privilege, which means starting with no access and only giving access
    to the required user group.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding points provide some of the most common anti-patterns. Throughout
    this book, you will learn the best practices for avoiding them in solution design.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter delved into constructing robust and scalable software architectures
    through various architectural paradigms. It began with exploring n-tier layered
    architecture, dissecting the essential components comprising the web, application,
    and database layers. The discussion transitioned into the intricate world of multi-tenant
    **Software-as-a-Service** (**SaaS**) architecture, delving into the complexities
    and benefits of accommodating diverse user bases within a unified framework.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: As for web services, the chapter dove into the RESTful architectural style,
    elucidating its principles and applications. This was followed by a journey through
    constructing a RESTful e-commerce architecture, offering practical insights into
    real-world implementation.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Cache-based architectures were then discussed, with a comprehensive exploration
    of cache distribution, proxy patterns such as cache proxy and rewrite proxy, and
    efficient caching strategies like app caching. A comparative study of Memcached
    and Redis shed light on selecting the optimal caching solution.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: The significance of architectural patterns was underscored by exploring the
    **Model-View-Controller** (**MVC**) approach and **Domain-Driven Design** (**DDD**)
    methodology, empowering architects to create structured, adaptable, and maintainable
    systems.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Architectural resilience was covered through an in-depth section on the circuit
    breaker pattern and on implementing the bulkhead pattern for enhanced system stability.
    Coverage of the floating IP pattern further enriched your toolkit for achieving
    high availability.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: The chapter delved into containerization, unearthing the manifold benefits of
    containers and providing a roadmap for effective container deployment. Database
    handling strategies were examined within application architecture, looking at
    high-availability patterns to ensure data integrity and continuous operation.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: The chapter concluded by spotlighting the Clean Architecture principles and
    imparting strategies for avoiding detrimental anti-patterns in solution architecture.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: By embarking on this architectural expedition, you have gained profound insights
    into the intricacies of building resilient, scalable, and future-ready software
    systems, and you are now armed with the knowledge needed to navigate the dynamic
    landscape of modern technology.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Leave a review!
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below to get a free eBook of your choice.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
