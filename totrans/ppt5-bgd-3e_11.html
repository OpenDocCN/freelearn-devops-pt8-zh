<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;Orchestrating cloud resources"><div class="titlepage"><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Orchestrating cloud resources</h1></div></div></div><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><span class="emphasis"><em>Rest is not idleness, and to lie sometimes on the grass under trees on a summer's day, listening to the murmur of the water, or watching the clouds float across the sky, is by no means a waste of time.</em></span></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<span class="attribution"><span class="emphasis"><em>John Lubbock</em></span></span></td></tr></table></div><p>In this chapter you'll learn how to use the <code class="literal">puppetlabs/aws</code> module to create and manage Amazon AWS cloud instances, and associated resources such as subnets, security groups, and VPCs. You'll also learn how to build your entire cloud infrastructure directly from Hiera data.</p><div class="mediaobject"><img src="graphics/8880_11_01.jpg" alt="Orchestrating cloud resources"/></div><div class="section" title="Introducing the cloud"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec61"/>Introducing the cloud</h1></div></div></div><p>Before exploring the <a id="id505" class="indexterm"/>advantages of cloud computing, perhaps we should define what it is. In the pre-cloud days, if you needed computing power, you bought an actual, physical computer. But from the customer's point of view, we don't necessarily want a computer: we just want to compute. We would like to be able to buy as much or as little compute resource as we happen to need at a given time, without paying a large fixed cost for a dedicated computer.</p><p>Enter <span class="strong"><strong>virtualization</strong></span>. A <a id="id506" class="indexterm"/>single physical server can provide a large number of virtual servers, each of which is (in theory) completely isolated from the others. The hosting provider builds a platform (consisting of many physical servers networked together) which provides, from the customer's point of view, a large intangible <span class="strong"><strong>cloud</strong></span> of virtual compute resources (hence the term).</p><div class="section" title="Automating cloud provisioning"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec178"/>Automating cloud provisioning</h2></div></div></div><p>Creating new cloud <a id="id507" class="indexterm"/>instances is cheaper and easier than buying physical hardware, but you still have choices to make: how much CPU or memory the instance has, how much disk space, what kind of disks (physical, solid-state, network-attached storage), what operating system should be installed, whether the instance has a public IP address, what firewall rules it should have, and so on.</p><p>If you've read the book this far in the book, you should now recognize this as a <span class="strong"><strong>configuration management</strong></span> problem. You will also probably have some idea what I'm going to recommend in order to solve it, but first let's look at a few of the available options.</p></div><div class="section" title="Using CloudFormation"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec179"/>Using CloudFormation</h2></div></div></div><p>CloudFormation is a <a id="id508" class="indexterm"/>template language specific to <span class="strong"><strong>Amazon Web Services</strong></span> (<span class="strong"><strong>AWS</strong></span>). It describes AWS resources in a declarative way, rather like Puppet resources. You <a id="id509" class="indexterm"/>upload your CloudFormation template to the AWS portal (or API), apply it, and AWS will create all the resources specified. The following example shows a snippet of CloudFormation code:</p><div class="informalexample"><pre class="programlisting"> "Resources" : {
    "EC2Instance" : {
      "Type" : "AWS::EC2::Instance",
      "Properties" : {
        "InstanceType" : { "Ref" : "InstanceType" },
        "SecurityGroups" : [ { "Ref" : "InstanceSecurityGroup" } ],
        "KeyName" : { "Ref" : "KeyName" },
        "ImageId" : { "Fn::FindInMap" : [ "AWSRegionArch2AMI", { "Ref" : "AWS::Region" },
                          { "Fn::FindInMap" : [ "AWSInstanceType2Arch", { "Ref" : "InstanceType" }, "Arch" ] } ] }
      }
    },</pre></div><p>Frankly, it's not much fun <a id="id510" class="indexterm"/>to program in. While it may technically be infrastructure as code, it's pretty basic. Nonetheless, it still represents an advance on manually setting <a id="id511" class="indexterm"/>up AWS infrastructure with a web browser.</p></div><div class="section" title="Using Terraform"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec180"/>Using Terraform</h2></div></div></div><p>Terraform is a rather more <a id="id512" class="indexterm"/>sophisticated tool for provisioning cloud <a id="id513" class="indexterm"/>resources. It allows you to describe your resources in a declarative way, like CloudFormation, but at a slightly higher level of abstraction, which is not AWS-specific. The following example shows what Terraform code looks like:</p><div class="informalexample"><pre class="programlisting">resource "aws_instance" "web" {
  ami           = "${data.aws_ami.ubuntu.id}"
  instance_type = "t2.micro"

  tags {
    Name = "HelloWorld"
  }
}</pre></div><p>Terraform is a promising technology, but it's fair to say it's at an early stage of development.</p></div><div class="section" title="Using Puppet"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec181"/>Using Puppet</h2></div></div></div><p>Stand-alone tools for <a id="id514" class="indexterm"/>managing cloud infrastructure are fine, but if we're doing everything else with Puppet, it seems a shame to introduce a whole new tool just for that. So could we use Puppet to manage cloud resources instead?</p><p>Fortunately, Puppet provides an excellent Forge module (<code class="literal">puppetlabs/aws</code>) which does exactly this. In the rest of this chapter, we'll work through some examples of how to use <code class="literal">puppetlabs/aws</code> to manage AWS cloud resources.</p></div></div></div>
<div class="section" title="Setting up an Amazon AWS account"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec62"/>Setting up an Amazon AWS account</h1></div></div></div><p>If you already have <a id="id515" class="indexterm"/>an AWS account, skip to the next section. Otherwise, you can follow these instructions to set up a new account and get the credentials you need to start building infrastructure with Puppet.</p><div class="section" title="Creating an AWS account"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec182"/>Creating an AWS account</h2></div></div></div><p>Follow these steps to create <a id="id516" class="indexterm"/>a new AWS account:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Browse to the following URL:<p>
<a class="ulink" href="https://aws.amazon.com/">https://aws.amazon.com/</a>
</p></li><li class="listitem">Click <span class="strong"><strong>Sign In to the Console</strong></span>.</li><li class="listitem">Follow the instructions to create and verify your account.</li></ol></div><p>To manage AWS resources using Puppet, we will create an additional AWS user account specifically for Puppet, using Amazon's <span class="strong"><strong>Identiy and Access Management </strong></span>(<span class="strong"><strong>IAM</strong></span>) framework. We'll see how to do this in the following sections.</p></div><div class="section" title="Creating an IAM policy"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec183"/>Creating an IAM policy</h2></div></div></div><p>Before we create the user <a id="id517" class="indexterm"/>account for Puppet, we need to <a id="id518" class="indexterm"/>grant specific permissions for the things it needs to do, such as read and create EC2 instances. This involves creating an <span class="strong"><strong>IAM policy</strong></span>, which is a set of named permissions you can associate with a user account.</p><p>IAM policies are expressed as a JSON-format document. There is a policy JSON file in the example repo, named <code class="literal">/examples/iam_policy.json</code>. Open this file and copy the contents, ready to paste into your web browser.</p><p>Follow these steps to create the policy and associate it with the Puppet user:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the AWS console, select <span class="strong"><strong>Services</strong></span> | <span class="strong"><strong>IAM</strong></span>.</li><li class="listitem">Select <span class="strong"><strong>Policies</strong></span>.</li><li class="listitem">Click <span class="strong"><strong>Create Policy</strong></span>.</li><li class="listitem">On the <span class="strong"><strong>Create Policy</strong></span> screen, select <span class="strong"><strong>Create Your Own Policy</strong></span>.</li><li class="listitem">Enter <span class="strong"><strong>Policy Name</strong></span> (for example, <code class="literal">puppet</code>).</li><li class="listitem">In the <span class="strong"><strong>Policy Document</strong></span> textbox, paste the text you copied from the <code class="literal">iam_policy.json</code> file.</li><li class="listitem">Click <span class="strong"><strong>Create Policy</strong></span> at the bottom to save this.<div class="mediaobject"><img src="graphics/8880_11_02.jpg" alt="Creating an IAM policy"/></div></li></ol></div></div><div class="section" title="Creating an IAM user"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec184"/>Creating an IAM user</h2></div></div></div><p>To create the <a id="id519" class="indexterm"/>Puppet IAM user and associate it with the <a id="id520" class="indexterm"/>policy, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Sign in to the AWS console.</li><li class="listitem">Select <span class="strong"><strong>Services</strong></span> | <span class="strong"><strong>IAM</strong></span> | <span class="strong"><strong>Users</strong></span>.</li><li class="listitem">Click <span class="strong"><strong>Add user</strong></span>.</li><li class="listitem">Enter the username you want to use for this account (for example, <code class="literal">puppet</code>).</li><li class="listitem">In the <span class="strong"><strong>Access type</strong></span> section, select <span class="strong"><strong>Programmatic access</strong></span>.<div class="mediaobject"><img src="graphics/8880_11_03.jpg" alt="Creating an IAM user"/></div></li><li class="listitem">Click <span class="strong"><strong>Next: Permissions</strong></span>.</li><li class="listitem">Create <a id="id521" class="indexterm"/><span class="strong"><strong>Attach existing policies </strong></span><a id="id522" class="indexterm"/><span class="strong"><strong>directly</strong></span>.</li><li class="listitem">Type <code class="literal">puppet</code> in the <span class="strong"><strong>Policy Type</strong></span> search box and press <span class="emphasis"><em>Enter</em></span>.<div class="mediaobject"><img src="graphics/8880_11_04.jpg" alt="Creating an IAM user"/></div></li><li class="listitem">You should see the policy we created in the previous section, so check the box next to it and click <span class="strong"><strong>Next: Review</strong></span>.</li><li class="listitem">Check that the settings are correct and click on <span class="strong"><strong>Create user</strong></span>.</li></ol></div><p>When you finish creating the IAM user and policy, you should see the <span class="strong"><strong>Success</strong></span> screen, which lists your access <a id="id523" class="indexterm"/>credentials. Copy the access key ID and the secret access key (click <span class="strong"><strong>Show</strong></span> to see the secret access key). You will need these <a id="id524" class="indexterm"/>credentials for the next steps (but keep them safe).</p></div><div class="section" title="Storing your AWS credentials"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec185"/>Storing your AWS credentials</h2></div></div></div><p>Follow these steps to <a id="id525" class="indexterm"/>configure your VM for access to <a id="id526" class="indexterm"/>AWS with your newly-generated credentials:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">On your Vagrant VM, run the following command to create the directory to hold your credentials file:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mkdir /home/ubuntu/.aws</strong></span>
</pre></div></li><li class="listitem">Create a file named <code class="literal">/home/ubuntu/.aws/credentials</code> with the following contents (substitute your Access Key ID and Secret Access Key values from the AWS console screen):<div class="informalexample"><pre class="programlisting">[default]
aws_access_key_id = AKIAINSZUVFYMBFDJCEQ
aws_secret_access_key = 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</pre></div></li></ol></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip53"/>Tip</h3><p>Creating the file <a id="id527" class="indexterm"/>manually is fine for this <a id="id528" class="indexterm"/>example, but for production use, you should manage the credentials file with Puppet using encrypted Hiera data, as shown in the <span class="emphasis"><em>Managing secret data</em></span> section in <a class="link" href="ch06.html" title="Chapter 6. Managing data with Hiera">Chapter 6</a>, <span class="emphasis"><em>Managing data with Hiera</em></span>.</p></div></div></div></div>
<div class="section" title="Getting ready to use puppetlabs/aws"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec63"/>Getting ready to use puppetlabs/aws</h1></div></div></div><p>In the following sections, we'll <a id="id529" class="indexterm"/>see how to generate an SSH key pair to connect to your EC2 instances, and also install the <code class="literal">puppetlabs/aws</code> module with its dependencies.</p><div class="section" title="Creating a key pair"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec186"/>Creating a key pair</h2></div></div></div><p>You'll need an SSH key <a id="id530" class="indexterm"/>pair in order to connect to any EC2 instances you create. We will generate and download your key pair in this section.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the AWS console, go to the <span class="strong"><strong>EC2</strong></span> section and select <span class="strong"><strong>Key pairs</strong></span> under <span class="strong"><strong>Network &amp; Security</strong></span> in the left pane.</li><li class="listitem">Click the <span class="strong"><strong>Create Key Pai</strong></span>r button.<div class="mediaobject"><img src="graphics/8880_11_05.jpg" alt="Creating a key pair"/></div></li><li class="listitem">You will be <a id="id531" class="indexterm"/>prompted for the name of your key pair. Enter <code class="literal">pbg</code> for this example.</li><li class="listitem">A file named <code class="literal">pbg.pem</code> will be automatically downloaded by your browser. Move this file to your <code class="literal">~/.ssh</code> directory on your own computer (or copy it to the <code class="literal">ubuntu</code> user's <code class="literal">~/.ssh</code> directory on the Vagrant VM, if you'd rather access your AWS instances from there).</li><li class="listitem">Set the correct permissions on the key file with the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>chmod 600 ~/.ssh/pbg.pem</strong></span>
</pre></div></li></ol></div></div><div class="section" title="Installing the puppetlabs/aws module"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec187"/>Installing the puppetlabs/aws module</h2></div></div></div><p>Follow these <a id="id532" class="indexterm"/>steps to install the <code class="literal">puppetlabs/aws</code> module:</p><p>If you've already set up the <code class="literal">r10k</code> module management tool, as shown in <a class="link" href="ch07.html" title="Chapter 7. Mastering modules">Chapter 7</a>, <span class="emphasis"><em>Mastering modules</em></span>, the <a id="id533" class="indexterm"/>required module will already be installed. If not, run the following commands to install it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cd /etc/puppetlabs/code/environments/pbg</strong></span>
<span class="strong"><strong>sudo r10k puppetfile install</strong></span>
</pre></div></div><div class="section" title="Installing the AWS SDK gem"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec188"/>Installing the AWS SDK gem</h2></div></div></div><p>The <a id="id534" class="indexterm"/>
<code class="literal">puppetlabs/aws</code> module requires a <a id="id535" class="indexterm"/>couple of gems, which we can install easily using Puppet, with the following manifest (<code class="literal">aws_sdk.pp</code>):</p><div class="informalexample"><pre class="programlisting">ensure_packages([
  'aws-sdk-core',
  'retries'
],
  { provider =&gt; puppet_gem })</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip54"/>Tip</h3><p>Notice the <code class="literal">provider =&gt; puppet_gem</code> in that example? You might remember from <a class="link" href="ch04.html" title="Chapter 4. Understanding Puppet resources">Chapter 4</a>, <span class="emphasis"><em>Understanding Puppet resources</em></span>, that <code class="literal">puppet_gem</code> installs a Ruby gem in Puppet's context (as opposed to the system Ruby context, which is completely separate). Gems which are required by Puppet modules need to be installed in this way or Puppet won't be able to load them.</p></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Apply the manifest with the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo puppet apply --environment pbg /examples/aws_sdk.pp</strong></span>
</pre></div></li><li class="listitem">Create the <code class="literal">/home/ubuntu/.aws/config</code> file with the following contents:<div class="informalexample"><pre class="programlisting">[default]
region=us-east-1</pre></div></li></ol></div></div></div>
<div class="section" title="Creating EC2 instances with Puppet"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec64"/>Creating EC2 instances with Puppet</h1></div></div></div><p>Although you can <a id="id536" class="indexterm"/>manage many different types of AWS resources with Puppet, the most important is the EC2 instance (the virtual server). In this section, we'll see how to create your first EC2 instance.</p><div class="section" title="Choosing an Amazon Machine Image (AMI)"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec189"/>Choosing an Amazon Machine Image (AMI)</h2></div></div></div><p>In order to run an <a id="id537" class="indexterm"/>EC2 instance, which is to <a id="id538" class="indexterm"/>say an AWS virtual machine, you need to choose which virtual machine to run out of the many thousands available. Each virtual machine snapshot is called an <span class="strong"><strong>Amazon Machine Image</strong></span> (<span class="strong"><strong>AMI</strong></span>) and has a unique ID. It's this ID that you will add to your Puppet manifest to tell it what kind of instance to start.</p><p>It doesn't matter much for the purposes of this example which AMI you choose, but we'll be using an official Ubuntu image. To find one, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Browse to the following URL:<p>
<a class="ulink" href="https://cloud-images.ubuntu.com/locator/ec2/">https://cloud-images.ubuntu.com/locator/ec2/</a>
</p></li><li class="listitem">In the <span class="strong"><strong>Search</strong></span> box, enter <code class="literal">us-east-1 xenial</code></li><li class="listitem">You should see a list of Ubuntu Xenial AMIs in the <code class="literal">us-east-1</code> region, of various instance types, looking something like the following screenshot:<div class="mediaobject"><img src="graphics/8880_11_06.jpg" alt="Choosing an Amazon Machine Image (AMI)"/></div></li><li class="listitem">Find an AMI in the list whose <span class="strong"><strong>Instance Type</strong></span> is <code class="literal">ebs-ssd</code>. In the preceding screenshot, the third AMI in the list (<code class="literal">ami-26d6d131</code>) is suitable.</li></ol></div><p>The hexadecimal <a id="id539" class="indexterm"/>code in the <code class="literal">AMI-ID</code> column, starting <code class="literal">ami-</code> is the AMI ID. Make a note of this for later. Click the link to see the AWS instance type selection page, and check that the AMI you've selected has a label saying <span class="strong"><strong>Free tier eligible</strong></span>; these AMIs do not incur charges. If you start an instance of a non-free-tier AMI, you will be charged for it.</p></div><div class="section" title="Creating the EC2 instance"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec190"/>Creating the EC2 instance</h2></div></div></div><p>Now we have <a id="id540" class="indexterm"/>chosen a suitable AMI, we're ready to create an EC2 instance with Puppet.</p><p>Before we can do that, however, we need to make a couple of changes to the AWS settings, so follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the AWS console, select <span class="strong"><strong>VPC</strong></span> from the <span class="strong"><strong>Services</strong></span> menu.</li><li class="listitem">Select <span class="strong"><strong>Your VPCs</strong></span> in the left pane.</li><li class="listitem">There will be only one VPC listed. Click in the <span class="strong"><strong>Name</strong></span> field and set its name to <code class="literal">default-vpc</code></li><li class="listitem">Select <span class="strong"><strong>Subnets</strong></span> in the left pane.</li><li class="listitem">There will be several subnets listed, one for each availability zone. Find the one associated with the <code class="literal">us-east-1a</code> availability zone.</li><li class="listitem">Click the subnet's <span class="strong"><strong>Name</strong></span> field and set the name to <code class="literal">default-subnet</code><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip55"/>Tip</h3><p>Why do we have to set <a id="id541" class="indexterm"/>names for the VPC and subnet before running the example? The <code class="literal">puppetlabs/aws</code> module refers to resources by their 'name', which is an arbitrary string, rather than their ID, which is a long hexadecimal code like the AMI ID. Although AWS creates a default VPC and subnet for you automatically, it doesn't assign them a name, which means we can't refer to them in Puppet code until we've set names for them. It doesn't matter what the names actually are so long as the name in your Puppet code is the same as the name assigned in the AWS control panel. We'll find out more about what VPCs and subnets do, and how to use them, later in the chapter.</p></div></div></li><li class="listitem">Edit the file <code class="literal">/examples/aws_instance.pp</code>, and change the value of <code class="literal">$ami</code> in the first line to the AMI ID you picked earlier (in our example, <code class="literal">ami-26d6d131</code>):<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo vi /examples/aws_instance.pp</strong></span>
$ami = 'ami-26d6d131'</pre></div></li><li class="listitem">Save the file, and run the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo puppet apply --environment pbg /examples/aws_instance.pp</strong></span>
</pre></div></li><li class="listitem">You should see some output from Puppet like the following:<div class="informalexample"><pre class="programlisting">Notice: /Stage[main]/Main/Ec2_securitygroup[pbg-sg]/ensure: created
Notice: /Stage[main]/Main/Ec2_instance[pbg-demo]/ensure: changed absent to running</pre></div></li><li class="listitem">If you check the <span class="strong"><strong>EC2</strong></span> section of the AWS console, you should see that your new instance's status is <span class="strong"><strong>Initializing</strong></span>, and it will soon be ready to use.</li></ol></div></div><div class="section" title="Accessing your EC2 instance"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec191"/>Accessing your EC2 instance</h2></div></div></div><p>Once the status of the <a id="id542" class="indexterm"/>newly-launched instance has changed from <span class="strong"><strong>Initializing</strong></span> to <span class="strong"><strong>Running</strong></span> (you may need to click the refresh button on the AWS console), you can connect to it using SSH and the key file you downloaded earlier.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the AWS console, look for the <span class="strong"><strong>Public IP</strong></span> address of the instance and copy it.</li><li class="listitem">From your own machine (or from the Vagrant VM if you copied the <code class="literal">pbg.pem</code> file to it) run the following command (replace <code class="literal">YOUR_INSTANCE_IP</code> with the public IP of the instance):<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ssh -i ~/.ssh/pbg.pem -l ubuntu YOUR_INSTANCE_IP</strong></span>
The authenticity of host 'YOUR_INSTANCE_IP (YOUR_INSTANCE_IP)' can't be established.
ECDSA key fingerprint is SHA256:T/pyWVJYWys2nyASJVHmDqOkQf8PbRGru3vwwKH71sk.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added 'YOUR_INSTANCE_IP' (ECDSA) to the list of known hosts.
Welcome to Ubuntu 16.04.3 LTS (GNU/Linux 4.4.0-1030-aws x86_64)</pre></div></li></ol></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip56"/>Tip</h3><p>Now that you have SSH access to the instance, you can bootstrap it with Puppet in the same way as for physical nodes, or just install Puppet and Git manually and check out the manifest repo. (We'll develop a complete, automated bootstrap process in <a class="link" href="ch12.html" title="Chapter 12. Putting it all together">Chapter 12</a>, <span class="emphasis"><em>Putting it all together</em></span>.)</p></div></div><p>Congratulations! You've just created your first EC2 instance with Puppet. In the next section, we'll look at the code and examine the resources in detail.</p></div><div class="section" title="VPCs, subnets, and security groups"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec192"/>VPCs, subnets, and security groups</h2></div></div></div><p>Let's go through the <a id="id543" class="indexterm"/>example manifest and see how it works. But first, we need to <a id="id544" class="indexterm"/>know something about AWS resources.</p><p>An EC2 <span class="strong"><strong>instance</strong></span> lives <a id="id545" class="indexterm"/>inside a <span class="strong"><strong>subnet</strong></span>, which is a self-contained virtual network. All instances within the subnet can communicate with each other. Subnets are partitions of a <span class="strong"><strong>Virtual Private Cloud</strong></span> (<span class="strong"><strong>VPC</strong></span>), which is a private internal network specific to your AWS account.</p><p>An instance also has a <span class="strong"><strong>security group</strong></span>, which is a set of firewall rules governing network access to the instance.</p><p>When you create an AWS <a id="id546" class="indexterm"/>account, you get a default VPC, divided into subnets for each <a id="id547" class="indexterm"/>AWS <span class="strong"><strong>availability zone</strong></span> (<span class="strong"><strong>AZ</strong></span>). We are using the default <a id="id548" class="indexterm"/>VPC and one of the default subnets for the example instance, but since we also need a security group, we create that first in Puppet code.</p></div><div class="section" title="The ec2_securitygroup resource"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec193"/>The ec2_securitygroup resource</h2></div></div></div><p>The first part of the <a id="id549" class="indexterm"/>example manifest creates the <a id="id550" class="indexterm"/>required <code class="literal">ec2_securitygroup</code> resource (<code class="literal">aws_instance.pp</code>):</p><div class="informalexample"><pre class="programlisting">ec2_securitygroup { 'pbg-sg':
  ensure      =&gt;  present,
  description =&gt; 'PBG security group',
  region      =&gt; $region,
  vpc         =&gt; 'default-vpc',
  ingress     =&gt; [
    {
      description =&gt; 'SSH access from world',
      protocol    =&gt; 'tcp',
      port        =&gt; 22,
      cidr        =&gt; '0.0.0.0/0',
    },
    {
      description =&gt; 'Ping access from world',
      protocol    =&gt; 'icmp',
      cidr        =&gt; '0.0.0.0/0',
    },
  ],
}</pre></div><p>First of all, an <code class="literal">ec2_securitygroup</code> has a title (<code class="literal">pbg-sg</code>) which we will use to refer to it from other resources (such as the <code class="literal">ec2_instance</code> resource). It also has a <code class="literal">description</code>, which is just to remind us what it's for.</p><p>It is part of a <code class="literal">region</code> and a <code class="literal">vpc</code>, and has an array of <code class="literal">ingress</code> rules. These are your firewall rules. Each firewall port or protocol you want to allow needs a separate ingress rule.</p><p>Each ingress rule is a hash like the following:</p><div class="informalexample"><pre class="programlisting">{
  description =&gt; 'SSH access from world',
  protocol    =&gt; 'tcp',
  port        =&gt; 22,
  cidr        =&gt; '0.0.0.0/0',
}</pre></div><p>The <code class="literal">protocol</code> specifies the type of traffic (<code class="literal">tcp</code>, <code class="literal">udp</code>, and so on).</p><p>The <code class="literal">port</code> is the <a id="id551" class="indexterm"/>port number to open (<code class="literal">22</code> is the SSH port, which we'll need in order to log in to the instance).</p><p>Finally, the <code class="literal">cidr</code> key <a id="id552" class="indexterm"/>specifies the range of network addresses to allow access to. (<code class="literal">0.0.0.0/0</code> means 'all addresses'.)</p></div><div class="section" title="The ec2_instance resource"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec194"/>The ec2_instance resource</h2></div></div></div><p>The <code class="literal">ec2_instance</code> <a id="id553" class="indexterm"/>resource, as you'd expect, manages an <a id="id554" class="indexterm"/>individual EC2 instance. Here's the relevant section of the example manifest (<code class="literal">aws_instance.pp</code>):</p><div class="informalexample"><pre class="programlisting">ec2_instance { 'pbg-demo':
  ensure                      =&gt; present,
  region                      =&gt; $region,
  subnet                      =&gt; 'default-subnet',
  security_groups             =&gt; 'pbg-sg',
  image_id                    =&gt; $ami,
  instance_type               =&gt; 't1.micro',
  associate_public_ip_address =&gt; true,
  key_name                    =&gt; 'pbg',
}</pre></div><p>First, <code class="literal">ensure =&gt; present</code> tells AWS that the instance should be running. (You can also use <code class="literal">running</code> as a synonym for <code class="literal">present</code>.) Setting <code class="literal">ensure =&gt; absent</code> will terminate and delete the instance (and any ephemeral storage attached to it).</p><p>EC2 instances can also be in a third state, <code class="literal">stopped</code>. Stopped instances preserve their storage and can be restarted. Because AWS bills by the instance-hour, you don't pay for instances that are stopped, so it's a good idea to stop any instances that don't need to be running right now.</p><p>The instance is part of a <code class="literal">region</code> and a <code class="literal">subnet</code>, and has one or more <code class="literal">security_groups</code>.</p><p>The <code class="literal">image_id</code> attribute tells AWS which AMI ID to use for the instance.</p><p>The <code class="literal">instance_type</code> attribute selects from AWS's large range of types, which more or less correspond to the computing power of the instance (different types vary in memory size and the number of virtual CPUs, and a few other factors).</p><p>As we're inside a private network, instances will not be reachable from the Internet unless we assign them a public IP address. Setting <code class="literal">associate_public_ip_address</code> to <code class="literal">true</code> enables this feature. (You should set this to <code class="literal">false</code> unless the instance actually needs to expose a port to the Internet.)</p><p>Finally, the instance has a <code class="literal">key_name</code> attribute which tells AWS which SSH key we are going to use to access it. In this case, we're using the key we created earlier in the <a id="id555" class="indexterm"/>chapter, named <code class="literal">pbg</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip57"/>Tip</h3><p>Before going on to the next example, terminate your instance to avoid using up your free hours. You can do this by selecting the instance in the AWS control panel and clicking <span class="strong"><strong>Actions</strong></span> | <span class="strong"><strong>Instance State</strong></span> | <span class="strong"><strong>Terminate</strong></span>, or reapplying your Puppet manifest with the instance's <code class="literal">ensure</code> attribute set to <code class="literal">absent</code>.</p></div></div></div></div>
<div class="section" title="Managing custom VPCs and subnets"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec65"/>Managing custom VPCs and subnets</h1></div></div></div><p>In the previous <a id="id556" class="indexterm"/>example, we used the pre-existing default VPC and subnet to create our instance. That's fine for demonstration purposes, but in production you'll want to use a dedicated VPC for your Puppet-managed resources, to keep it separate from any other resources in your AWS account, and from other Puppet-managed VPCs. You could, for example, have a staging VPC and a production VPC.</p><p>By default, a new VPC has no access to the Internet; we'll also need an <span class="strong"><strong>Internet gateway</strong></span> (which routes Internet traffic to and from the VPC) and a <span class="strong"><strong>route table</strong></span> (which tells a given subnet to send non-local traffic to the gateway). The <code class="literal">puppetlabs/aws</code> module provides Puppet resources to create and manage each of these entities.</p><div class="section" title="Creating an instance in a custom VPC"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec195"/>Creating an instance in a custom VPC</h2></div></div></div><p>In this section, we'll <a id="id557" class="indexterm"/>use a more sophisticated example manifest to create a new VPC and subnet, with an associated Internet gateway and route table, then add a security group and EC2 instance.</p><p>Follow these steps to apply the manifest:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Edit the file <code class="literal">/examples/aws_vpc.pp</code> and change the value of <code class="literal">$ami</code> in the first line to the AMI ID you picked earlier (in our example, <code class="literal">ami-26d6d131</code>):<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo vi /examples/aws_vpc.pp</strong></span>
$ami = 'ami-26d6d131'</pre></div></li><li class="listitem">Save the file and run the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo puppet apply --environment pbg /examples/aws_vpc.pp</strong></span>
</pre></div></li><li class="listitem">You should see <a id="id558" class="indexterm"/>some output from Puppet like the following:<div class="informalexample"><pre class="programlisting">Notice: /Stage[main]/Main/Ec2_vpc[pbg-vpc]/ensure: created
Notice: /Stage[main]/Main/Ec2_vpc_internet_gateway[pbg-igw]/ensure: created
Notice: /Stage[main]/Main/Ec2_vpc_routetable[pbg-rt]/ensure: created
Notice: /Stage[main]/Main/Ec2_vpc_subnet[pbg-vpc-subnet]/ensure: created
Notice: /Stage[main]/Main/Ec2_securitygroup[pbg-vpc-sg]/ensure: created
Notice: /Stage[main]/Main/Ec2_instance[pbg-vpc-demo]/ensure: changed absent to running</pre></div></li><li class="listitem">If you check the <span class="strong"><strong>EC2</strong></span> section of the AWS console, you should see that your new instance status is <span class="strong"><strong>Initializing</strong></span>, and it will soon be ready to use.</li></ol></div></div><div class="section" title="The ec2_vpc resource"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec196"/>The ec2_vpc resource</h2></div></div></div><p>Let's look at the <a id="id559" class="indexterm"/>example manifest in detail. Here's the <code class="literal">ec2_vpc</code> resource (<code class="literal">aws_vpc.pp</code>): </p><div class="informalexample"><pre class="programlisting">ec2_vpc { 'pbg-vpc':
  ensure     =&gt; present,
  region     =&gt; $region,
  cidr_block =&gt; '10.99.0.0/16',
}</pre></div><p>The VPC requires a <code class="literal">region</code> attribute and <code class="literal">cidr_block</code>, which is the range of network addresses that the VPC will use. (Actually, this isn't required, as AWS will allocate you one at random if you don't specify it. We specify one here just for the demonstration.)</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip58"/>Tip</h3><p>It doesn't matter what your network range actually is, as it's entirely internal. However, it's good practice to use one of the address ranges officially assigned to private networks, such as <code class="literal">10.x.y.z</code>. To make it less likely that your range will conflict with any other assigned in your organization, pick a random number for <code class="literal">x</code> (we've used <code class="literal">99</code> in the example).</p></div></div></div><div class="section" title="The ec2_vpc_internet_gateway resource"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec197"/>The ec2_vpc_internet_gateway resource</h2></div></div></div><p>We saw earlier <a id="id560" class="indexterm"/>that a VPC, by default, is not connected to the Internet. There are various ways to get Internet traffic into <a id="id561" class="indexterm"/>the VPC, including VPNs and Amazon <span class="strong"><strong>Elastic </strong></span>
<a id="id562" class="indexterm"/>
<span class="strong"><strong>Load Balancers</strong></span> (<span class="strong"><strong>ELB</strong></span>), but for this example, we'll use an <code class="literal">ec2_vpc_internet_gateway</code> resource, which looks like the following:</p><div class="informalexample"><pre class="programlisting">ec2_vpc_internet_gateway { 'pbg-igw':
  ensure =&gt; present,
  region =&gt; $region,
  vpc    =&gt; 'pbg-vpc',
}</pre></div><p>The gateway has a title (<code class="literal">pbg-igw</code>), and it is associated with a particular <code class="literal">region</code> and <code class="literal">vpc</code>.</p></div><div class="section" title="The ec2_vpc_routetable resource"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec198"/>The ec2_vpc_routetable resource</h2></div></div></div><p>Having <a id="id563" class="indexterm"/>provisioned an <code class="literal">ec2_vpc_internet_gateway</code>, we now need to set up a route table to determine which traffic to send to it. Here <a id="id564" class="indexterm"/>is the <code class="literal">ec2_vpc_routetable</code> resource from the example:</p><div class="informalexample"><pre class="programlisting">ec2_vpc_routetable { 'pbg-rt':
  ensure =&gt; present,
  region =&gt; $region,
  vpc    =&gt; 'pbg-vpc',
  routes =&gt; [
    {
      destination_cidr_block =&gt; '10.99.0.0/16',
      gateway                =&gt; 'local'
    },
    {
      destination_cidr_block =&gt; '0.0.0.0/0',
      gateway                =&gt; 'pbg-igw'
    },
  ],
}</pre></div><p>As usual, a route table has a title, <code class="literal">region</code>, and <code class="literal">vpc</code>. It also has an array of one or more routes.</p><p>A <span class="strong"><strong>route</strong></span> is like a road sign for network packets. It says, "if you're heading for this destination, take this junction." Each route in the array is a hash containing a <code class="literal">destination_cidr_block</code> and <code class="literal">gateway</code> key.</p><p>The first route in our example is for local traffic (destined for the <code class="literal">10.99.0.0/16</code> network, which is the network we assigned to our VPC):</p><div class="informalexample"><pre class="programlisting">{
  destination_cidr_block =&gt; '10.99.0.0/16',
  gateway                =&gt; 'local'
}</pre></div><p>This tells traffic for the <code class="literal">10.99.0.0/16</code> network that it is local; that is, there's no need to use a gateway, <a id="id565" class="indexterm"/>because it's already on the desired network.</p><p>The second route is for all other traffic:</p><div class="informalexample"><pre class="programlisting">{
  destination_cidr_block =&gt; '0.0.0.0/0',
  gateway                =&gt; 'pbg-igw'
}</pre></div><p>The network address <code class="literal">0.0.0.0/0</code> matches all possible network addresses (traffic for <code class="literal">10.99.0.0/16</code> will <a id="id566" class="indexterm"/>already have been filtered out by the previous route, so we are left with all other traffic, which must be for the Internet). The designated gateway is <code class="literal">pbg-igw</code>, which is the <code class="literal">ec2_vpc_internet_gateway</code> we created earlier.</p><p>So this route table equates to the following instructions for routing traffic:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Traffic for <code class="literal">10.99.0.0/16</code>, stay on this network</li><li class="listitem" style="list-style-type: disc">All other traffic, please proceed to the <code class="literal">pbg-igw</code> gateway</li></ul></div><p>These routes will suffice for a single VPC; if you have a more complicated network setup in AWS, you will need a more complicated route table, but the principles will be the same.</p></div><div class="section" title="The ec2_vpc_subnet resource"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec199"/>The ec2_vpc_subnet resource</h2></div></div></div><p>A subnet, as we've <a id="id567" class="indexterm"/>seen, is a subdivision of the VPC <a id="id568" class="indexterm"/>network, which enables you to logically partition your VPC for different groups of resources. For example, you might have one subnet which is accessible from the Internet for public-facing nodes, and another for internal resources such as database or log servers.</p><p>In the example we just have one subnet:</p><div class="informalexample"><pre class="programlisting">ec2_vpc_subnet { 'pbg-vpc-subnet':
  ensure            =&gt; present,
  vpc               =&gt; 'pbg-vpc',
  region            =&gt; $region,
  cidr_block        =&gt; '10.99.0.0/24',
  availability_zone =&gt; "${region}a",
  route_table       =&gt; 'pbg-rt',
}</pre></div><p>It has a title, <code class="literal">vpc</code>, and <code class="literal">region</code>. Because it is a subdivision of the VPC network, it also needs a <code class="literal">cidr_block</code> specifying exactly which part of the network address space it occupies. This must be a subdivision of the network address you assigned to the containing VPC, as indeed it is in this example.</p><p>A subnet exists within an AWS availability zone (equivalent to a data center). These are named after their region; for example, the <code class="literal">us-east-1</code> region has availability zones <code class="literal">us-east-1a</code>, <code class="literal">us-east-1b</code>, and so on. This allows you to provision redundant resources in different availability zones, so that if one should fail, the other can take over. For this example, however, we're using just one availability zone, <code class="literal">us-east-1a</code>, which we pass to the <code class="literal">availability_zone</code> attribute.</p><p>By default, resources <a id="id569" class="indexterm"/>in a subnet can only communicate within the subnet. To allow traffic in and out of the subnet, we need to associate it with <code class="literal">route_table</code>. By using the <code class="literal">pbg-rt</code> route table we created earlier, we can send Internet traffic via the <code class="literal">pbg-igw</code> gateway.</p><p>And that's it. The <code class="literal">ec2_securitygroup</code> and <code class="literal">ec2_instance</code> resources are more or less the same as in our earlier <a id="id570" class="indexterm"/>example, except for using the new subnet.</p></div><div class="section" title="Other AWS resource types"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec200"/>Other AWS resource types</h2></div></div></div><p>Puppet is not limited to <a id="id571" class="indexterm"/>managing EC2 instances; the <code class="literal">puppetlabs/aws</code> module also supports ELB load balancers, Cloudwatch alarms, auto scaling groups, Elastic IPs, DHCP, VPNs, IAM users and policies, RDS databases, S3 storage buckets, SQS queues, Route 53 DNS management, and the <a id="id572" class="indexterm"/>
<span class="strong"><strong>EC2 Container Service</strong></span> (<span class="strong"><strong>ECS</strong></span>). Due to constraints of space, time, and energy, I have not provided examples for all of these, but you can consult the module's admirably comprehensive documentation at this URL:</p><p>
<a class="ulink" href="https://forge.puppet.com/puppetlabs/aws">https://forge.puppet.com/puppetlabs/aws</a>
</p></div></div>
<div class="section" title="Provisioning AWS resources from Hiera data"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec66"/>Provisioning AWS resources from Hiera data</h1></div></div></div><p>There's nothing <a id="id573" class="indexterm"/>wrong with managing AWS resources directly in the code, as we've done in the previous examples, but we can do just a little bit better.</p><p>In <a class="link" href="ch06.html" title="Chapter 6. Managing data with Hiera">Chapter 6</a>, <span class="emphasis"><em>Managing data with Hiera</em></span>, we saw how to create Puppet resources directly from Hiera data. In that example (<span class="emphasis"><em>Building resources from Hiera hashes</em></span>), we stored all the users for our infrastructure in a Hiera hash called <code class="literal">users</code>, and then used the <code class="literal">each</code> keyword to iterate over that hash, creating a user resource for each user. Here's the example code again (<code class="literal">hiera_users2.pp</code>):</p><div class="informalexample"><pre class="programlisting">lookup('users2', Hash, 'hash').each | String $username, Hash $attrs | {
  user { $username:
    * =&gt; $attrs,
  }
}</pre></div><p>The magic <code class="literal">*</code> character (the <span class="strong"><strong>attribute splat operator</strong></span>) tells Puppet to use the contents of the <code class="literal">$attrs</code> hash <a id="id574" class="indexterm"/>as the attributes of the resource.</p><p>The advantage of describing <a id="id575" class="indexterm"/>resources as Hiera data is that when we come to add a new user, or change the details for an existing user, we don't need to touch Puppet code at all. Everything is defined in Hiera.</p><div class="section" title="Iterating over Hiera data to create resources"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec201"/>Iterating over Hiera data to create resources</h2></div></div></div><p>Alert readers may be wondering, "Couldn't we do the same thing with all these AWS resources? Can we just define everything in a Hiera hash and have Puppet iterate over it to create the resources?"</p><p>Indeed we can. The manifest to create all these resources is surprisingly concise (<code class="literal">aws_hiera.pp</code>):</p><div class="informalexample"><pre class="programlisting">$aws_resources = lookup('aws_resources', Hash, 'hash')
$aws_resources.each | String $r_type, Hash $resources | {
  $resources.each | String $r_title, Hash $attrs | {
    Resource[$r_type] { $r_title:
      * =&gt; $attrs,
    }
  }
}</pre></div><p>To apply the manifest, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Edit the Hiera data file <code class="literal">aws.yaml</code> and change the value of the <code class="literal">ami:</code> setting in the first line to the AMI ID you picked earlier (in our example, <code class="literal">ami-26d6d131</code>):<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo vi /etc/puppetlabs/code/environments/pbg/data/aws.yaml</strong></span>
ami: 'ami-26d6d131'</pre></div></li><li class="listitem">Save the file and run the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo puppet apply --environment pbg /examples/aws_hiera.pp</strong></span>
</pre></div></li></ol></div><p>If you've already run the previous example and the AWS resources are still present, you'll see no output from Puppet, because the resources are exactly the same.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>Remember, if the state of the system is already the same as the desired state expressed in the manifest, Puppet will do nothing.</p></div></div><p>If you want to <a id="id576" class="indexterm"/>prove to yourself that the example manifest really works, delete the resources using the AWS control panel (or use Puppet to delete them by changing <code class="literal">present</code> to <code class="literal">absent</code> in the Hiera data) and reapply the manifest.</p><p>If you compare the manifest to that from the Hiera users example, you can see that instead of a single loop, it consists of two nested loops. The outer loop iterates over the contents of the <code class="literal">$aws_resources</code> hash:</p><div class="informalexample"><pre class="programlisting">$aws_resources = lookup('aws_resources', Hash, 'hash')
$aws_resources.each | String $r_type, Hash $resources | {
  ...
  }
}</pre></div><p>Each key of the <code class="literal">$aws_resources</code> hash is the name of a Puppet resource type. Here's the first one (from <code class="literal">hiera_aws.yaml</code>):</p><div class="informalexample"><pre class="programlisting"> 'ec2_vpc':
      ...
</pre></div><p>So the first time round this loop, the value of <code class="literal">$r_type</code> will be <code class="literal">ec2_vpc</code>, and the value of <code class="literal">$resources</code> will be this hash:</p><div class="informalexample"><pre class="programlisting">'pbg-vpc':
  ensure: present
  region: "%{lookup('region')}"
  cidr_block: '10.99.0.0/16'</pre></div><p>Now we enter the inner loop, which creates all the resources of type <code class="literal">$r_type</code>:</p><div class="informalexample"><pre class="programlisting">$resources.each | String $r_title, Hash $attrs | {
  Resource[$r_type] { $r_title:
    * =&gt; $attrs,
  }
}</pre></div><p>As it happens, there is only one <code class="literal">ec2_vpc</code> resource, so the first time round the inner loop, the value of <code class="literal">$r_title</code> will be <code class="literal">pbg-vpc</code>, and the value of <code class="literal">$attrs</code> will be this hash:</p><div class="informalexample"><pre class="programlisting">ensure: present
region: "%{lookup('region')}"
cidr_block: '10.99.0.0/16'</pre></div><p>So Puppet will create this resource:</p><div class="informalexample"><pre class="programlisting">ec2_vpc { 'pbg-vpc':
  ensure     =&gt; present,
  region     =&gt; 'us-east-1',
  cidr_block =&gt; '10.99.0.0/16',
}</pre></div><p>This is identical to <a id="id577" class="indexterm"/>the <code class="literal">ec2_vpc</code> resource in the previous example, and as we go round the outer loop we will create the other resources in the same way.</p><p>What's <code class="literal">Resource[$r_type]</code>? This is a bit of Puppet wizardry. The problem is that we need to declare a Puppet resource whose type we don't know yet; it will be supplied by the <code class="literal">$r_type</code> variable. You might at first try using a syntax like the following:</p><div class="informalexample"><pre class="programlisting">$r_type = 'ec2_vpc'
$r_type { 'pbg-vpc':
  ...
}</pre></div><p>Unfortunately, Puppet doesn't allow this syntax, but there is a way to get round the problem. The abstract data type <code class="literal">Resource</code> matches any resource type (you can read more about Puppet data types in <a class="link" href="ch08.html" title="Chapter 8. Classes, roles, and profiles">Chapter 8</a>, <span class="emphasis"><em>Classes, roles, and profiles</em></span>).</p><p>We can make <code class="literal">Resource</code> more specific by including the actual resource type in square brackets: <code class="literal">Resource['ec2_vpc']</code>. This is valid syntax for declaring a resource.</p><p>So this is how we declare a resource whose type comes from a variable:</p><div class="informalexample"><pre class="programlisting">$r_type = 'ec2_vpc'
Resource[$r_type] { 'pbg-vpc':
  ...
}</pre></div><p>Now that your AWS resources are described by Hiera data, it should be much easier to maintain and extend them as you use Puppet in production.</p></div><div class="section" title="Cleaning up unused resources"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec202"/>Cleaning up unused resources</h2></div></div></div><p>To close down your EC2 <a id="id578" class="indexterm"/>instance, and thus avoid using up your free hours or being billed for the instance, edit your Hiera data to set <code class="literal">ensure: absent</code> on the <code class="literal">ec2_instance</code> resource:</p><div class="informalexample"><pre class="programlisting">'ec2_instance':
  'pbg-vpc-demo':
    ensure: absent
    region: "%{lookup('region')}"
    subnet: 'pbg-vpc-subnet'
    security_groups: 'pbg-vpc-sg'
    image_id: "%{lookup('ami')}"
    instance_type: 't1.micro'
    associate_public_ip_address: true
    key_name: 'pbg'</pre></div><p>When you reapply the manifest, Puppet will stop the instance. You can leave other resources in place, as they don't incur charges.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec67"/>Summary</h1></div></div></div><p>In this chapter, we've introduced the basic idea of cloud computing, and looked at some options for managing cloud resources, including CloudFormation and Terraform, before meeting the <code class="literal">puppetlabs/aws</code> module.</p><p>We've worked through the process of creating an AWS account, setting up an IAM user and policy, generating credentials and SSH keys, installing the AWS SDK gem, and choosing a suitable AMI (Amazon Machine Image).</p><p>Using Puppet, we've created an EC2 instance and security group, and seen how to connect to the running instance with SSH. Going further, we've created a whole VPC from scratch, complete with subnets, Internet gateway, route table, security group, and EC2 instance.</p><p>Lastly, we've seen how to build all these cloud resources directly from Hiera data, which is the most flexible and powerful way to describe Puppet resources.</p><p>In the next and final chapter, we'll draw together ideas and techniques from all the previous chapters in this book to create a complete, working example Puppet infrastructure which you can use as a basis for your own.</p></div></body></html>