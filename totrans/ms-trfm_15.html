<html><head></head><body>
<div id="_idContainer194">
<h1 class="chapter-number" id="_idParaDest-263"><a id="_idTextAnchor641"/><span class="koboSpan" id="kobo.1.1">15</span></h1>
<h1 id="_idParaDest-264"><a id="_idTextAnchor642"/><span class="koboSpan" id="kobo.2.1">Go Serverless on Google Cloud – Building Solutions with Google Cloud Functions </span></h1>
<p><span class="koboSpan" id="kobo.3.1">We are almost there! </span><span class="koboSpan" id="kobo.3.2">In this chapter, we will build the last of the nine solutions we’ll build in this book. </span><span class="koboSpan" id="kobo.3.3">We are about to close the door on Google Cloud—but only after we take the final step of transitioning our application to serverless architecture as we did on AWS and Azure. </span><span class="koboSpan" id="kobo.3.4">In the previous two chapters, we worked hard to implement our solution on Google Cloud using virtual machines and </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">then containers.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">We’ve taken time to make some comparisons between how things work across all three cloud platforms to help us understand the subtle and sometimes not-so-subtle differences </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">between them.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">We’ve noticed that while our Terraform code has been changing pretty consistently between cloud platforms, our application code and the operating system configuration—either in Packer or Docker—haven’t. </span><span class="koboSpan" id="kobo.7.2">As we take our final step with Google Cloud, we’ll be going through a similar process to the one we went through when we transitioned our application to AWS Lambda and Azure Functions. </span><span class="koboSpan" id="kobo.7.3">We’ll have to completely refactor the </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">application code.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">The chapter covers the </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">Laying </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">the foundation</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Designing </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">the solution</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Building </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">the solution</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Automating </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">the deployment</span></span></li>
</ul>
<h1 id="_idParaDest-265"><a id="_idTextAnchor643"/><span class="koboSpan" id="kobo.19.1">Laying the foundation</span></h1>
<p><span class="koboSpan" id="kobo.20.1">Our skilled team </span><a id="_idIndexMarker1102"/><span class="koboSpan" id="kobo.21.1">had just finished putting the finishing touches on the final ConfigMap in our Kubernetes configuration when they received a not-so-surprising telephone call. </span><span class="koboSpan" id="kobo.21.2">Keyser seems to have had yet another epiphany, this time while hanging out with </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">Larry Page.</span></span></p>
<p><span class="koboSpan" id="kobo.23.1">While </span><a id="_idIndexMarker1103"/><span class="koboSpan" id="kobo.24.1">walking through Larry’s private terminal at San Jose International Airport to his personal Boeing 767 waiting for them, Keyser and Larry were discussing Keyser’s new venture. </span><span class="koboSpan" id="kobo.24.2">Larry mentioned in passing, </span><em class="italic"><span class="koboSpan" id="kobo.25.1">“Keyser, why are you even investing in infrastructure? </span><span class="koboSpan" id="kobo.25.2">These days, everybody is going serverless. </span><span class="koboSpan" id="kobo.25.3">Focus on your platform. </span><span class="koboSpan" id="kobo.25.4">Let Google Cloud focus on how to </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.26.1">scale it.”</span></em></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.27.1">“Eureka!”</span></em><span class="koboSpan" id="kobo.28.1"> exclaimed Keyser, as he tossed a few warm cashews into his mouth before elaborating. </span><em class="italic"><span class="koboSpan" id="kobo.29.1">“Oh man, Larry, you’re so right! </span><span class="koboSpan" id="kobo.29.2">I need to get my team on this right away! </span><span class="koboSpan" id="kobo.29.3">What was I thinking? </span><span class="koboSpan" id="kobo.29.4">We don’t have time for the plumbing; we need to move fast to stay ahead of </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.30.1">the competition!”</span></em></span></p>
<p><span class="koboSpan" id="kobo.31.1">Back at headquarters, the team is adapting to this exciting yet sudden change in direction. </span><span class="koboSpan" id="kobo.31.2">Now, thanks to Keyser’s bold new strategy, they’re gearing up to dive deep into serverless computing. </span><span class="koboSpan" id="kobo.31.3">This shift will require more than just repackaging the application—they’ll have to completely refactor </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">the code</span><a id="_idTextAnchor644"/><span class="koboSpan" id="kobo.33.1">!</span></span></p>
<h1 id="_idParaDest-266"><a id="_idTextAnchor645"/><span class="koboSpan" id="kobo.34.1">Designing the solution</span></h1>
<p><span class="koboSpan" id="kobo.35.1">In this section, we</span><a id="_idIndexMarker1104"/><span class="koboSpan" id="kobo.36.1"> will look at the overall design of our solution given the shift from virtual machine- and container-based architectures toward serverless architectures. </span><span class="koboSpan" id="kobo.36.2">As we saw in previous transformations, serverless at its core has the quintessential objective of eliminating heavy infrastructure from the stack. </span><span class="koboSpan" id="kobo.36.3">Therefore, we will be looking for ways to </span><a id="_idIndexMarker1105"/><span class="koboSpan" id="kobo.37.1">shed any Google Cloud services that require significant fixed costs, such as </span><strong class="bold"><span class="koboSpan" id="kobo.38.1">virtual machines</span></strong><span class="koboSpan" id="kobo.39.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.40.1">Kubernetes clusters</span></strong><span class="koboSpan" id="kobo.41.1">, and replace them with serverless options. </span><span class="koboSpan" id="kobo.41.2">This </span><a id="_idIndexMarker1106"/><span class="koboSpan" id="kobo.42.1">change in our operational context and our technology landscape will likely require us to rethink some things about our solution, including its design, implementation, and </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">deployment strategy:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer177">
<span class="koboSpan" id="kobo.44.1"><img alt="Figure 15.1 – The logical architecture for the autonomous vehicle platform" src="image/B21183_15_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.45.1">Figure 15.1 – The logical architecture for the autonomous vehicle platform</span></p>
<p><span class="koboSpan" id="kobo.46.1">While our </span><a id="_idIndexMarker1107"/><span class="koboSpan" id="kobo.47.1">application’s architecture doesn’t change significantly, we will use different Google Cloud services to host it. </span><span class="koboSpan" id="kobo.47.2">In this case, we’ll be using Google Cloud Storage to host the application’s frontend, and we’ll be using Google Cloud Functions to host the application’s backend, as illustrated in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.48.1">Figure 15</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.49.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer178">
<span class="koboSpan" id="kobo.51.1"><img alt="Figure 15.2 – The source control structure of our repository" src="image/B21183_15_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.52.1">Figure 15.2 – The source control structure of our repository</span></p>
<p><span class="koboSpan" id="kobo.53.1">In this solution, we’ll have four parts of our code base: Terraform code that provisions the environment, GitHub Actions code that executes the deployment process, and the two code bases for our application’s frontend </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">and backe</span><a id="_idTextAnchor646"/><span class="koboSpan" id="kobo.55.1">nd.</span></span></p>
<h2 id="_idParaDest-267"><a id="_idTextAnchor647"/><span class="koboSpan" id="kobo.56.1">Cloud architecture</span></h2>
<p><span class="koboSpan" id="kobo.57.1">In </span><a href="B21183_13.xhtml#_idTextAnchor569"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.58.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.59.1">, our </span><a id="_idIndexMarker1108"/><span class="koboSpan" id="kobo.60.1">cloud-hosting solution was a set of dedicated virtual machines, and in </span><a href="B21183_14.xhtml#_idTextAnchor605"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.61.1">Chapter 14</span></em></span></a><span class="koboSpan" id="kobo.62.1">, it was a set of shared virtual machines within our Kubernetes cluster’s node pool. </span><span class="koboSpan" id="kobo.62.2">Using virtual machines has the most sunk cost, whether they are standalone virtual machines or part of a Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">node pool.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">In </span><a href="B21183_14.xhtml#_idTextAnchor605"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.65.1">Chapter 14</span></em></span></a><span class="koboSpan" id="kobo.66.1">, our </span><a id="_idIndexMarker1109"/><span class="koboSpan" id="kobo.67.1">entire solution was executed on containers that allowed the frontend and the backend to coexist as a set of containers on the same virtual machine. </span><span class="koboSpan" id="kobo.67.2">This saved some money, but we still needed servers to host the workload. </span><span class="koboSpan" id="kobo.67.3">In this chapter, we have a new objective: take advantage of the power of the cloud by leveraging cloud-native services that abstract the underlying infrastructure from us and allow us to truly pay for only what we use. </span><span class="koboSpan" id="kobo.67.4">Google Cloud’s serverless offerings will be crucial to us in </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">this ende</span><a id="_idTextAnchor648"/><span class="koboSpan" id="kobo.69.1">avor.</span></span></p>
<h3><span class="koboSpan" id="kobo.70.1">Frontend</span></h3>
<p><span class="koboSpan" id="kobo.71.1">In previous </span><a id="_idIndexMarker1110"/><span class="koboSpan" id="kobo.72.1">chapters, we hosted our frontend on public-facing servers that return the HTML and JavaScript that composed our web application, and we still required a cloud-hosted solution to host the files and respond </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">to requests.</span></span></p>
<p><span class="koboSpan" id="kobo.74.1">However, due to the nature of the web application running within the end user’s browser, we really don’t need to use cloud-hosted virtual machines to host what are essentially flat files. </span><span class="koboSpan" id="kobo.74.2">We can use simple cloud storage to host the frontend as a static website and rely on the cloud platform to shoulder the burden of returning the </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">web content.</span></span></p>
<p><span class="koboSpan" id="kobo.76.1">We can use the Google Cloud Storage service on Google Cloud. </span><span class="koboSpan" id="kobo.76.2">This service allows us to host static web content that is internet accessible. </span><span class="koboSpan" id="kobo.76.3">As we did on AWS and Azure in previous chapters, most of this functionality is </span><a id="_idIndexMarker1111"/><span class="koboSpan" id="kobo.77.1">achieved by adding a </span><strong class="bold"><span class="koboSpan" id="kobo.78.1">Storage bucket</span></strong><span class="koboSpan" id="kobo.79.1"> and enabling it to host web content. </span><span class="koboSpan" id="kobo.79.2">However, unlike how we handled this on AWS and Azure, we need to add our own load balancer to ensure our web application functions properly, as illustrated in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.80.1">Figure 15</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.81.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer179">
<span class="koboSpan" id="kobo.83.1"><img alt="Figure 15.3 – Google Cloud Storage handles web page requests while Google Cloud Functions handles REST API requests" src="image/B21183_15_3..jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.84.1">Figure 15.3 – Google Cloud Storage handles web page requests while Google Cloud Functions handles REST API requests</span></p>
<p><span class="koboSpan" id="kobo.85.1">As we saw </span><a id="_idIndexMarker1112"/><span class="koboSpan" id="kobo.86.1">on other platforms, we will gain a huge advantage because Google Cloud Storage has absolutely no sunk costs. </span><span class="koboSpan" id="kobo.86.2">When you create a Google Cloud Storage bucket, it costs you absolutely zero dollars ($0) per month. </span><span class="koboSpan" id="kobo.86.3">Like other serverless offerings, it uses a set of microtransactions to measure your activity and charge you for precisely what you use. </span><span class="koboSpan" id="kobo.86.4">In Google Cloud Storage, this can be a bit complicated as there are several measurements that </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">incur costs.</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.88.1">Table 15.1</span></em><span class="koboSpan" id="kobo.89.1"> shows all the costs you will run into when using Google Cloud Storage to host your </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">static websites:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-5">
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.91.1">Metric</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.92.1">Unit</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.93.1">Scale</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.94.1">Price</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.95.1">Storage</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.96.1">GBs</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.97.1">1,000</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.98.1">$</span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">0.023</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.100.1">Write Transactions</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.101.1">Transactions</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.102.1">1,000</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.103.1">$</span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">0.01</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.105.1">Read Transactions</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.106.1">Transactions</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.107.1">1,000</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.108.1">$</span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">0.0004</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.110.1">Table 15.1 – Google Cloud Storage micro-transactional pricing</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.111.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.112.1">The prices listed are, at the time of writing, for Google Cloud’s West US 2 region. </span><span class="koboSpan" id="kobo.112.2">Prices may have changed by the time you are reading this, so it’s best to check the latest prices for the most accurate </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">cost estimation.</span></span></p>
<p><span class="koboSpan" id="kobo.114.1">I included </span><a id="_idIndexMarker1113"/><span class="koboSpan" id="kobo.115.1">these prices to make a point. </span><span class="koboSpan" id="kobo.115.2">We can host a static website on a three-node Kubernetes cluster for approximately $300 a month, or we can host a static website on Google Cloud Storage for less than $0.01 a month on the most rock-solid storage tier that Google Cloud has to offer. </span><span class="koboSpan" id="kobo.115.3">Which approach would </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">you choose?</span></span><a id="_idTextAnchor649"/></p>
<h3><span class="koboSpan" id="kobo.117.1">Backend</span></h3>
<p><span class="koboSpan" id="kobo.118.1">Like our frontend, in </span><a id="_idIndexMarker1114"/><span class="koboSpan" id="kobo.119.1">previous chapters, our backend was also hosted on virtual machines in two different ways: dedicated virtual machines and shared virtual machines within the node pool on our </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">Kubernetes cluster.</span></span></p>
<p><span class="koboSpan" id="kobo.121.1">Unlike our frontend, our backend doesn’t have the option of running entirely client-side inside the end user’s web browser. </span><span class="koboSpan" id="kobo.121.2">In the backend, we have custom code that needs to run on a server. </span><span class="koboSpan" id="kobo.121.3">Therefore, we need to find a solution to host these components without all the overhead of a fleet of virtual machines. </span><span class="koboSpan" id="kobo.121.4">On Google Cloud, we can use Google Cloud Functions to accomplish this. </span><span class="koboSpan" id="kobo.121.5">Google Cloud Functions is a managed service that allows you to deploy your code without paying the sunk costs for any of the underlying virtual machines. </span><span class="koboSpan" id="kobo.121.6">Like Google Cloud Storage, it has its own micro-transactional pricing model that charges you for precisely what </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">you use.</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.123.1">Table 15.2</span></em><span class="koboSpan" id="kobo.124.1"> shows what costs that you will incur when deploying your code to Google </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">Cloud Functions:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table002-4">
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.126.1">Metric</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.127.1">Unit</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.128.1">Scale</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.129.1">Price</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.130.1">Compute</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.131.1">GHz/s</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.132.1">1</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.133.1">$</span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">0.00001</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.135.1">Memory</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.136.1">GB/s</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.137.1">1</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.138.1">$</span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">0.0000025</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.140.1">Total Executions</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.141.1">Transactions</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.142.1">1,000,000</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.143.1">$</span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">0.40</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.145.1">Table 15.2 – Google Cloud Functions microtransactions pricing</span></p>
<p><span class="koboSpan" id="kobo.146.1">The first thing that you’ll probably notice is that, like Google Cloud Storage, these prices are extremely small but they measure a very small amount of activity on </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">the platform.</span></span></p>
<p><span class="koboSpan" id="kobo.148.1">For </span><a id="_idIndexMarker1115"/><span class="koboSpan" id="kobo.149.1">example, the </span><strong class="bold"><span class="koboSpan" id="kobo.150.1">compute</span></strong><span class="koboSpan" id="kobo.151.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.152.1">memory</span></strong><span class="koboSpan" id="kobo.153.1"> metrics have units that correspond to that resource’s unit of measure per second. </span><span class="koboSpan" id="kobo.153.2">For compute metrics, it’s measured in GHz per second, and for memory metrics, it’s measured in GB per second. </span><span class="koboSpan" id="kobo.153.3">These units of measurement give you the flexibility to adjust the amount of compute and memory resources your cloud functions have access to when they are executed. </span><span class="koboSpan" id="kobo.153.4">Given that it measures at a </span><em class="italic"><span class="koboSpan" id="kobo.154.1">per second</span></em><span class="koboSpan" id="kobo.155.1"> interval, you don’t have to be running your Google Cloud Functions very long to rack up quite a few of these. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.156.1">Figure 15</span></em></span><em class="italic"><span class="koboSpan" id="kobo.157.1">.4</span></em><span class="koboSpan" id="kobo.158.1"> shows Google Cloud Functions deploying the application code to Google </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">Cloud Storage:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer180">
<span class="koboSpan" id="kobo.160.1"><img alt="Figure 15.4 – Google Cloud Functions runs the application code which is deployed to Google Cloud Storage" src="image/B21183_15_4..jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.161.1">Figure 15.4 – Google Cloud Functions runs the application code which is deployed to Google Cloud Storage</span></p>
<p><span class="koboSpan" id="kobo.162.1">Previously, our ASP.NET REST API was set up using a traditional ASP.NET project that used Controllers to implement the REST API endpoints. </span><span class="koboSpan" id="kobo.162.2">However, when transitioning to Google Cloud Functions, this solution structure is incompatible with the Google Cloud Functions framework. </span><span class="koboSpan" id="kobo.162.3">In order to be able to host our REST API as Google Cloud Functions, we need to conform to the framework that Cloud Functions dictates. </span><span class="koboSpan" id="kobo.162.4">This means that the ASP.NET controller classes will need to be refactored to conform to this standard. </span><span class="koboSpan" id="kobo.162.5">In the next section, we’ll delve into the code that makes </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">this possible.</span></span></p>
<h2 id="_idParaDest-268"><a id="_idTextAnchor650"/><span class="koboSpan" id="kobo.164.1">Deployment architecture</span></h2>
<p><span class="koboSpan" id="kobo.165.1">Now that we have a </span><a id="_idIndexMarker1116"/><span class="koboSpan" id="kobo.166.1">good idea of what our cloud architecture for our solution on Google Cloud will look like, we need to devise a plan for provisioning our environments and deploying </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">our code.</span></span></p>
<p><span class="koboSpan" id="kobo.168.1">In </span><a href="B21183_12.xhtml#_idTextAnchor543"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.169.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.170.1">, when</span><a id="_idIndexMarker1117"/><span class="koboSpan" id="kobo.171.1"> we deployed our application to virtual machines, we baked our compiled application code into a virtual machine image </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">using Packer:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer181">
<span class="koboSpan" id="kobo.173.1"><img alt="Figure 15.5 – The deployment process for virtual machines using Packer-built virtual machine images" src="image/B21183_15_5..jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.174.1">Figure 15.5 – The deployment process for virtual machines using Packer-built virtual machine images</span></p>
<p><span class="koboSpan" id="kobo.175.1">Similarly, in </span><a href="B21183_13.xhtml#_idTextAnchor569"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.176.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.177.1">, when we deployed our application to containers on our Kubernetes cluster, we baked our application code into container images </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">using Docker:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer182">
<span class="koboSpan" id="kobo.179.1"><img alt="Figure 15.6 – The deployment process for Kubernetes using Docker-built container images" src="image/B21183_15_6..jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.180.1">Figure 15.6 – The deployment process for Kubernetes using Docker-built container images</span></p>
<p><span class="koboSpan" id="kobo.181.1">With </span><a id="_idIndexMarker1118"/><span class="koboSpan" id="kobo.182.1">serverless, this completely changes because Google Cloud’s serverless offerings abstract away the </span><a id="_idIndexMarker1119"/><span class="koboSpan" id="kobo.183.1">operating system. </span><span class="koboSpan" id="kobo.183.2">This means that all we are responsible for is producing a compatible </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">deployment package</span><a id="_idTextAnchor651"/><span class="koboSpan" id="kobo.185.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.186.1">Creating the deployment package</span></h3>
<p><span class="koboSpan" id="kobo.187.1">As discussed in the </span><a id="_idIndexMarker1120"/><span class="koboSpan" id="kobo.188.1">previous section, we have two components of our application: the frontend and the backend. </span><span class="koboSpan" id="kobo.188.2">Each has a different deployment target. </span><span class="koboSpan" id="kobo.188.3">For the frontend, we are going to be deploying as a static website, while the backend is going to be deployed as a Google Cloud function. </span><span class="koboSpan" id="kobo.188.4">Since both are .NET projects, we will be using both .NET and Google Cloud Platform-specific tools in order to create deployment packages and deploy them to their target Google Cloud services. </span><span class="koboSpan" id="kobo.188.5">The following diagram shows the process we go through to provision our environment, package our application code, and deploy it to the target environment in </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">Google Cloud:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer183">
<span class="koboSpan" id="kobo.190.1"><img alt="Figure 15.7 – The deployment pipeline to build our .NET application code for deployment to Google Cloud" src="image/B21183_15_7..jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.191.1">Figure 15.7 – The deployment pipeline to build our .NET application code for deployment to Google Cloud</span></p>
<p><span class="koboSpan" id="kobo.192.1">For the frontend, this means enabling the feature to deploy our ASP.NET Blazor web application as WebAssembly. </span><span class="koboSpan" id="kobo.192.2">This will allow the frontend to be hosted as a static website that can run completely client-side without any server-side rendering. </span><span class="koboSpan" id="kobo.192.3">This is only possible </span><a id="_idIndexMarker1121"/><span class="koboSpan" id="kobo.193.1">because of the way we have designed our frontend web application, which uses HTML, CSS, and JavaScript to interact with server-side REST APIs. </span><span class="koboSpan" id="kobo.193.2">It’s important to note that ASP.NET Blazor supports both hosting options, but we specifically chose to go down the client-side-only path and eliminate any dependency on server-side page rendering. </span><span class="koboSpan" id="kobo.193.3">As a result, when we use the .NET CLI to publish our ASP.NET Blazor project, it will emit a folder containing static web content. </span><span class="koboSpan" id="kobo.193.4">Then, using a Google Cloud CLI, we can upload the contents of this folder to our Google Cloud Storage bucket to complete the deployment, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.194.1">Figure 15</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.195.1">.8</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer184">
<span class="koboSpan" id="kobo.197.1"><img alt="Figure 15.8 – The deployment process for Google Cloud Functions using custom-built deployment packages" src="image/B21183_15_8..jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.198.1">Figure 15.8 – The deployment process for Google Cloud Functions using custom-built deployment packages</span></p>
<p><span class="koboSpan" id="kobo.199.1">For the backend, unlike on AWS and Azure, the application code on Google Cloud shouldn’t be compiled as it needs to be processed by Google Cloud Functions. </span><span class="koboSpan" id="kobo.199.2">This means the actual source code files need to be uploaded as opposed to the compiled artifacts, as we have done previously. </span><span class="koboSpan" id="kobo.199.3">Therefore, we must zip the source code folder into a ZIP archive. </span><span class="koboSpan" id="kobo.199.4">Another major difference is that the Terraform provider for Google Cloud requires this zip archive to be uploaded </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">by Terraform:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer185">
<span class="koboSpan" id="kobo.201.1"><img alt="Figure 15.9 – The GitFlow process to create new versioned artifacts" src="image/B21183_15_9..jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.202.1">Figure 15.9 – The GitFlow process to create new versioned artifacts</span></p>
<p><span class="koboSpan" id="kobo.203.1">This process </span><a id="_idIndexMarker1122"/><span class="koboSpan" id="kobo.204.1">will integrate nicely with the GitFlow process discussed in </span><a href="B21183_06.xhtml#_idTextAnchor330"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.205.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.206.1">. </span><span class="koboSpan" id="kobo.206.2">With each new feature we develop, we’ll open a new feature branch, and when we’re ready to integrate our updates with the main body of work, we’ll submit a </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">pull request:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer186">
<span class="koboSpan" id="kobo.208.1"><img alt="Figure 15.10 – GitFlow process to create new versioned artifacts" src="image/B21183_15_10..jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.209.1">Figure 15.10 – GitFlow process to create new versioned artifacts</span></p>
<p><span class="koboSpan" id="kobo.210.1">This pull request will trigger GitHub Actions that run built-in quality checks on our application code and run a </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">terraform plan</span></strong><span class="koboSpan" id="kobo.212.1"> to evaluate the impact on our long-lived environments. </span><span class="koboSpan" id="kobo.212.2">We can do any number of tests before the code is merged, which is good to verify that our updates–both to the application code and to the infrastructure code– won’t negatively impact our target environment. </span><span class="koboSpan" id="kobo.212.3">Once our pull request is approved and merged, it will trigger additional GitHub Actions that will apply the changes to the </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">target environment.</span></span><a id="_idTextAnchor652"/></p>
<p><span class="koboSpan" id="kobo.214.1">Now that we have a solid plan for implementing both the cloud architecture using Google Cloud Platform and the deployment architecture using GitHub Actions, let’s start building! </span><span class="koboSpan" id="kobo.214.2">In the next section, we’ll break down the </span><strong class="bold"><span class="koboSpan" id="kobo.215.1">HashiCorp Configuration Language</span></strong><span class="koboSpan" id="kobo.216.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.217.1">HCL</span></strong><span class="koboSpan" id="kobo.218.1">) code that we use to implement Terraform, and we’ll look at the application code changes we need to make to get our application up and running using Google </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">Cloud Functions.</span></span></p>
<h1 id="_idParaDest-269"><a id="_idTextAnchor653"/><span class="koboSpan" id="kobo.220.1">Building the solution</span></h1>
<p><span class="koboSpan" id="kobo.221.1">Now that we </span><a id="_idIndexMarker1123"/><span class="koboSpan" id="kobo.222.1">have a solid design for our solution, we can begin building it. </span><span class="koboSpan" id="kobo.222.2">As we discussed in the previous section, because we’ll be using Google Cloud’s serverless offerings such as Google Cloud Storage and Google Cloud Functions to host our application, we will need to make some changes to our application code. </span><span class="koboSpan" id="kobo.222.3">This is something that we have never had to do in </span><em class="italic"><span class="koboSpan" id="kobo.223.1">Chapters 13</span></em><span class="koboSpan" id="kobo.224.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.225.1">14</span></em><span class="koboSpan" id="kobo.226.1">, as we were able to deploy our application to the cloud by packaging it in either a virtual machine image (using Packer) or in a container image (using Docker). </span><span class="koboSpan" id="kobo.226.2">Therefore, in order to build our solution, we need to write some Terraform and make updates to our application code </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">in C#</span><a id="_idTextAnchor654"/><span class="koboSpan" id="kobo.228.1">.</span></span></p>
<h2 id="_idParaDest-270"><a id="_idTextAnchor655"/><span class="koboSpan" id="kobo.229.1">Terraform</span></h2>
<p><span class="koboSpan" id="kobo.230.1">As we </span><a id="_idIndexMarker1124"/><span class="koboSpan" id="kobo.231.1">discussed in our design, our solution comprises two application components: the frontend and </span><a id="_idIndexMarker1125"/><span class="koboSpan" id="kobo.232.1">the backend. </span><span class="koboSpan" id="kobo.232.2">Each has its own application codebase that needs to be deployed. </span><span class="koboSpan" id="kobo.232.3">Unlike previous chapters, where we also had operating system configuration, now that we are using serverless offerings, this is no longer our responsibility as the platform takes care of it </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">for us:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer187">
<span class="koboSpan" id="kobo.234.1"><img alt="Figure 15.11 – A Google Cloud Functions resource structure" src="image/B21183_15_11..jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.235.1">Figure 15.11 – A Google Cloud Functions resource structure</span></p>
<p><span class="koboSpan" id="kobo.236.1">Much of the Terraform setup is very similar to what we have done in previous chapters so we will only</span><a id="_idIndexMarker1126"/><span class="koboSpan" id="kobo.237.1"> focus on new resources needed for our solution. </span><span class="koboSpan" id="kobo.237.2">You can check the full source code for this book, which is available on GitHub, if you want to work with the </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">complete solution.</span></span></p>
<h3><span class="koboSpan" id="kobo.239.1">Frontend</span></h3>
<p><span class="koboSpan" id="kobo.240.1">As we saw in </span><a id="_idIndexMarker1127"/><span class="koboSpan" id="kobo.241.1">previous chapters, when working with Google Cloud, we need to activate the required Google APIs to provision resources to our new project. </span><span class="koboSpan" id="kobo.241.2">For the frontend, we will mainly use Google Cloud Storage, but we also need a </span><strong class="bold"><span class="koboSpan" id="kobo.242.1">Cloud Load Balancer</span></strong><span class="koboSpan" id="kobo.243.1">, which requires the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">compute.googleapis.com</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.245.1"> API.</span></span></p>
<p><span class="koboSpan" id="kobo.246.1">First, we need to provision a Google Cloud Storage bucket to which we can deploy our frontend. </span><span class="koboSpan" id="kobo.246.2">However, we need to configure our Google Cloud Storage bucket differently using an optional block called </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">website</span></strong><span class="koboSpan" id="kobo.248.1"> to enable the static </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">websites feature:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.250.1">
resource "google_storage_bucket" "frontend" {
  project  = google_project.main.project_id
  name     = "${var.application_name}-${var.environment_name}-frontend-${random_string.project_id.result}"
  location = "US"
  website {
    main_page_suffix = "index.html"
    not_found_page   = "404.html"
  }
  cors {
    origin          = ["*"]
    method          = ["GET", "HEAD"]
    response_header = ["Authorization", "Content-Type"]
    max_age_seconds = 3600
  }
}</span></pre> <p><span class="koboSpan" id="kobo.251.1">To </span><a id="_idIndexMarker1128"/><span class="koboSpan" id="kobo.252.1">allow anonymous internet traffic to access the content stored within the bucket, we need to set up a binding with the Identity and Access Management service. </span><span class="koboSpan" id="kobo.252.2">This will grant </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">allUsers</span></strong><span class="koboSpan" id="kobo.254.1"> access to view objects within the </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">storage bucket:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.256.1">
resource "google_storage_bucket_iam_binding" "frontend" {
  bucket = google_storage_bucket.frontend.name
  role   = "roles/storage.objectViewer"
  members = [
    "allUsers"
  ]
}</span></pre> <p><span class="koboSpan" id="kobo.257.1">In previous chapters, we’ve set up Google Cloud Load Balancing, which establishes a load balancer as the frontend and allows you to configure many different types </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">of backends:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer188">
<span class="koboSpan" id="kobo.259.1"><img alt="Figure 15.12 – Google Cloud Load Balancing routes traffic to the Frontend hosted on Google Cloud Storage" src="image/B21183_15_12..jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.260.1">Figure 15.12 – Google Cloud Load Balancing routes traffic to the Frontend hosted on Google Cloud Storage</span></p>
<p><span class="koboSpan" id="kobo.261.1">In this </span><a id="_idIndexMarker1129"/><span class="koboSpan" id="kobo.262.1">case, the backend for the load balancer becomes extremely simple; it’s just a Google Cloud </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">Storage bucket:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.264.1">
resource "google_compute_backend_bucket" "frontend" {
  project = google_project.main.project_id
  name        = "${var.application_name}-${var.environment_name}-frontend-${random_string.project_id.result}"
  bucket_name = google_storage_bucket.frontend.name
  enable_cdn  = true
}</span></pre> <p><span class="koboSpan" id="kobo.265.1">The Google Cloud Storage bucket needs to be set up as the backend for the load balancer, which will allow traffic to be routed to the </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">appropriate location.</span></span></p>
<h3><span class="koboSpan" id="kobo.267.1">Backend</span></h3>
<p><span class="koboSpan" id="kobo.268.1">Our Backend</span><a id="_idIndexMarker1130"/><span class="koboSpan" id="kobo.269.1"> will be hosted on Google Cloud Functions, so we need to enable </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">logging.googleapis.com</span></strong><span class="koboSpan" id="kobo.271.1"> to allow Google Cloud Functions’ telemetry to be accessible from the Google </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">Cloud console.</span></span></p>
<p><span class="koboSpan" id="kobo.273.1">As we discussed in the previous section, Google Cloud Functions requires our source code to be uploaded, not compiled artifacts; this is because of the way Google Cloud Functions handles the packaging of our application on our behalf. </span><span class="koboSpan" id="kobo.273.2">As a result, this creates a dependency on </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">cloudbuild.googleapis.com</span></strong><span class="koboSpan" id="kobo.275.1">, which Google Cloud Functions uses to create a packaged artifact based on the source code </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">we upload.</span></span></p>
<p><span class="koboSpan" id="kobo.277.1">For our </span><a id="_idIndexMarker1131"/><span class="koboSpan" id="kobo.278.1">Google Cloud Functions to execute, we need two additional Google APIs, the Cloud Run API (i.e., </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">run.googleapis.com</span></strong><span class="koboSpan" id="kobo.280.1">) and the Cloud Functions API (i.e., </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">cloudfunctions.googleapis.com</span></strong><span class="koboSpan" id="kobo.282.1">). </span><span class="koboSpan" id="kobo.282.2">Google Cloud Functions is a layer built onto the Cloud Run API that provides an additional layer of abstraction and additional capabilities to create event-driven workflows, while the Cloud Run API provides a foundational service to run stateless containers that are invocable via </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">HTTP requests.</span></span></p>
<p><span class="koboSpan" id="kobo.284.1">Google Cloud Functions have a rather simple deployment model. </span><span class="koboSpan" id="kobo.284.2">Like AWS Lambda, you must declare a resource for the function itself. </span><span class="koboSpan" id="kobo.284.3">The resource has two main configuration components—the build and service configurations—as </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.286.1">
resource "google_cloudfunctions2_function" "backend" {
  project  = google_project.main.project_id
  name = "func-${var.application_name}-${var.environment_name}-backend-${random_string.project_id.result}"
  location = var.primary_region
  description = "a new function"
}</span></pre> <p><span class="koboSpan" id="kobo.287.1">The build configuration controls the type of execution runtime (e.g., Python, Java, or .NET), the entry point in the application code, and the location in storage where the application code can </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">be found:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.289.1">
  build_config {
    runtime     = "dotnet6"
    entry_point = "FleetAPI.Function"
    source {
      storage_source {
        bucket = google_storage_bucket.backend.name
        object = google_storage_bucket_object.deployment.name
      }
    }
  }</span></pre> <p><span class="koboSpan" id="kobo.290.1">The service </span><a id="_idIndexMarker1132"/><span class="koboSpan" id="kobo.291.1">configuration controls how many resources the cloud function has access to when invoked. </span><span class="koboSpan" id="kobo.291.2">Consequently, this configuration is also the primary driver </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">of costs:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.293.1">
  service_config {
    max_instance_count = 1
    available_memory   = "256M"
    timeout_seconds    = 60
  }</span></pre> <p><span class="koboSpan" id="kobo.294.1">The service configuration block also allows you to set environment variables that can be used to pass non-sensitive configuration settings to the </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">cloud function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.296.1">
  service_config {
    ...
</span><span class="koboSpan" id="kobo.296.2">    environment_variables = {
        SERVICE_CONFIG_TEST = "config_test"
    }
  }</span></pre> <h3><span class="koboSpan" id="kobo.297.1">Secrets management</span></h3>
<p><span class="koboSpan" id="kobo.298.1">As we saw in </span><a id="_idIndexMarker1133"/><span class="koboSpan" id="kobo.299.1">previous chapters, we can only provision secrets using Google Cloud Secrets Manager once we have enabled the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">secretmanager.googleapis.com</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.301.1"> API.</span></span></p>
<p><span class="koboSpan" id="kobo.302.1">First, we need to define the secret with a unique secret identifier that we can use to look up the secret’s value from our application code. </span><span class="koboSpan" id="kobo.302.2">If we are building multi-region deployments, we can also set the regions to which we want this </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">secret replicated:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.304.1">
resource "google_secret_manager_secret" "sauce" {
  secret_id = "sauce"
  replication {
    user_managed {
      replicas {
        location = var.primary_region
      }
    }
  }
}</span></pre> <p><span class="koboSpan" id="kobo.305.1">As we saw with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">aws</span></strong><span class="koboSpan" id="kobo.307.1"> provider in earlier chapters, the secret is just a placeholder, a unique way to look up our secret’s value. </span><span class="koboSpan" id="kobo.307.2">We need to create versions of our secret to store the actual </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">secret value:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.309.1">
resource "google_secret_manager_secret_version" "sauce" {
  secret = google_secret_manager_secret.secret.name
  secret_data = "secret"
  enabled = true
}</span></pre> <p><span class="koboSpan" id="kobo.310.1">After </span><a id="_idIndexMarker1134"/><span class="koboSpan" id="kobo.311.1">provisioning the secret and a version of our secret, we can access it from our Google Cloud Functions. </span><span class="koboSpan" id="kobo.311.2">There are two methods for injecting our secrets into our cloud function; the first is using </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">environment variables:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.313.1">
    secret_environment_variables {
      key        = "sauce"
      project_id = google_project.main.project_id
      secret     = google_secret_manager_secret.sauce.secret_id
      version    = "latest"
    }</span></pre> <p><span class="koboSpan" id="kobo.314.1">The preceding code demonstrates how we can add a secret to the service configuration block of our cloud function to inject our secrets stored in the Google Secret Manager device using the </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">secret’s identifier.</span></span></p>
<p><span class="koboSpan" id="kobo.316.1">The second approach is probably more secure as it avoids exposing the secret within the </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">process’ environment:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.318.1">
    secret_volumes {
      mount_path = "/etc/secrets"
      project_id = google_project.main.project_id
      secret     = google_secret_manager_secret.secret.secret_id
    }</span></pre> <p><span class="koboSpan" id="kobo.319.1">The preceding code shows how to set a mount point within the filesystem and drop the secret’s value there using the </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">secret’s i</span><a id="_idTextAnchor656"/><span class="koboSpan" id="kobo.321.1">dentifier.</span></span></p>
<h2 id="_idParaDest-271"><a id="_idTextAnchor657"/><span class="koboSpan" id="kobo.322.1">Application code</span></h2>
<p><span class="koboSpan" id="kobo.323.1">Google Cloud Functions </span><a id="_idIndexMarker1135"/><span class="koboSpan" id="kobo.324.1">are inherently event-based. </span><span class="koboSpan" id="kobo.324.2">Each cloud function is triggered by a different type of event from a wide variety of Google Cloud services. </span><span class="koboSpan" id="kobo.324.3">For the purposes of this book, we’ll focus on the HTTP trigger only, but if you are interested, I’d recommend you go check out all the other options that Google Cloud Functions has—it’s </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">quite extensive:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer189">
<span class="koboSpan" id="kobo.326.1"><img alt="Figure 15.13 – ASP.NET MVC controller class anatomy" src="image/B21183_15_13..jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.327.1">Figure 15.13 – ASP.NET MVC controller class anatomy</span></p>
<p><span class="koboSpan" id="kobo.328.1">In a traditional ASP.NET REST API solution, you have controller classes that embody a specific route and then methods that implement different operations at that route. </span><span class="koboSpan" id="kobo.328.2">The controller class needs to be decorated with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">ApiController</span></strong><span class="koboSpan" id="kobo.330.1"> attribute informing the ASP.NET runtime that this class should be used to process incoming web requests at the route specified in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">Route</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.332.1"> attribute.</span></span></p>
<p><span class="koboSpan" id="kobo.333.1">Each method is decorated with an attribute that denotes which HTTP verb the method should respond to. </span><span class="koboSpan" id="kobo.333.2">In the preceding example, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">HttpGet</span></strong><span class="koboSpan" id="kobo.335.1">, but there are corresponding attributes for each of the supported HTTP Verbs. </span><span class="koboSpan" id="kobo.335.2">The method can take strongly typed parameters that can either be part of the route, the Query String, or the request body. </span><span class="koboSpan" id="kobo.335.3">The method returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">IActionResult</span></strong><span class="koboSpan" id="kobo.337.1"> by default, which allows us to return different data structures depending on the outcome of </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">the request.</span></span></p>
<p><span class="koboSpan" id="kobo.339.1">In order to implement a REST API using Azure Functions, we need to implement a class using the </span><a id="_idIndexMarker1136"/><span class="koboSpan" id="kobo.340.1">Azure Function SDK. </span><span class="koboSpan" id="kobo.340.2">This requires us to slightly adjust how we implement both our class and our method. </span><span class="koboSpan" id="kobo.340.3">We will employ different class and method attributes in order to achieve a similar outcome, defining an endpoint that responds to web requests at a </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">specific route:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer190">
<span class="koboSpan" id="kobo.342.1"><img alt="Figure 15.14 – Google Cloud Functions class anatomy" src="image/B21183_15_14..jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.343.1">Figure 15.14 – Google Cloud Functions class anatomy</span></p>
<p><span class="koboSpan" id="kobo.344.1">Google Cloud Functions has a very simple method for integrating with the underlying cloud service that drives the runtime. </span><span class="koboSpan" id="kobo.344.2">The only requirement is to implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">IHttpFunction</span></strong><span class="koboSpan" id="kobo.346.1"> interface. </span><span class="koboSpan" id="kobo.346.2">This interface has a single requirement to implement a method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">HandleAsync</span></strong><span class="koboSpan" id="kobo.348.1"> that takes an </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">HttpContext</span></strong><span class="koboSpan" id="kobo.350.1"> object as its only parameter. </span><span class="koboSpan" id="kobo.350.2">There is no return object. </span><span class="koboSpan" id="kobo.350.3">Therefore, the only way we have to respond to the client is by writing to the response object that is accessible from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">HttpContext</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.352.1"> object.</span></span></p>
<p><span class="koboSpan" id="kobo.353.1">As we can see, the cloud architecture radically simplifies, but one trade-off is that our backend code needs to be adapted to the Google Cloud Functions framework. </span><span class="koboSpan" id="kobo.353.2">This will require development and testing efforts in order to transform our code base into this new hosting </span><a id="_idIndexMarker1137"/><span class="koboSpan" id="kobo.354.1">model. </span><span class="koboSpan" id="kobo.354.2">This stands in stark contrast to what we explored in previous chapters, where we hosted on virtual machines or containerized and hosted on a Kubernetes cluster. </span><span class="koboSpan" id="kobo.354.3">While conforming to the Google Cloud Functions model does take work, its benefits are twofold. </span><span class="koboSpan" id="kobo.354.4">First, it allows us to take advantage of near-zero sunk cost, and second, it allows us to fully abstract the underlying infrastructure from us and let Google Cloud Platform take care of scalability and high availability. </span><span class="koboSpan" id="kobo.354.5">This allows us to focus more on the functionality of our solutions rather than the plumbing of managing the </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">underlying infrastructure.</span></span></p>
<p><span class="koboSpan" id="kobo.356.1">Now that we have implemented Terraform to provision our solution and made changes to our application code to conform it to the Google Cloud Functions framework, in the next section, we’ll dive into YAML and Bash and implement the GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">Actions workflows.</span></span></p>
<h1 id="_idParaDest-272"><a id="_idTextAnchor658"/><span class="koboSpan" id="kobo.358.1">Automating the deployment</span></h1>
<p><span class="koboSpan" id="kobo.359.1">As we </span><a id="_idIndexMarker1138"/><span class="koboSpan" id="kobo.360.1">discussed in the previous section, serverless offerings such as Google Cloud Functions and Google Cloud Storage abstract away the operating system configuration. </span><span class="koboSpan" id="kobo.360.2">Therefore, when we deploy, we only need an application package that is compatible with the target platform. </span><span class="koboSpan" id="kobo.360.3">In this section, we’ll create an automation pipeline using GitHub Actions that will provision our application to its new serverless home in </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">Google Cloud.</span></span></p>
<h2 id="_idParaDest-273"><a id="_idTextAnchor659"/><span class="koboSpan" id="kobo.362.1">Terraform</span></h2>
<p><span class="koboSpan" id="kobo.363.1">The first thing </span><a id="_idIndexMarker1139"/><span class="koboSpan" id="kobo.364.1">that we need to do is to provision our environment to Google Cloud. </span><span class="koboSpan" id="kobo.364.2">This is going to be extremely similar to the way we did this in the previous chapters. </span><span class="koboSpan" id="kobo.364.3">In </span><a href="B21183_13.xhtml#_idTextAnchor569"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.365.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.366.1">, we needed to ensure that our virtual machine images were built and available before we executed Terraform because the Terraform code base referenced the virtual machine images when it provisioned the virtual machines. </span><span class="koboSpan" id="kobo.366.2">This means that with our virtual machine architecture, application deployment happens before Terraform provisions the environment, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.367.1">Figure 15</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.368.1">.15</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer191">
<span class="koboSpan" id="kobo.370.1"><img alt="Figure 15.15 – Packer-produced virtual machine images are a prerequisite for Terraform" src="image/B21183_15_15..jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.371.1">Figure 15.15 – Packer-produced virtual machine images are a prerequisite for Terraform</span></p>
<p><span class="koboSpan" id="kobo.372.1">In </span><a href="B21183_14.xhtml#_idTextAnchor605"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.373.1">Chapter 14</span></em></span></a><span class="koboSpan" id="kobo.374.1">, we provisioned our</span><a id="_idIndexMarker1140"/><span class="koboSpan" id="kobo.375.1"> Kubernetes cluster using </span><strong class="bold"><span class="koboSpan" id="kobo.376.1">Google Kubernetes Engine</span></strong><span class="koboSpan" id="kobo.377.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.378.1">GKE</span></strong><span class="koboSpan" id="kobo.379.1">) without </span><a id="_idIndexMarker1141"/><span class="koboSpan" id="kobo.380.1">such a prerequisite. </span><span class="koboSpan" id="kobo.380.2">In fact, the application deployment occurred after the Kubernetes cluster was online. </span><span class="koboSpan" id="kobo.380.3">This means that with container-based architecture, application deployment happens after Terraform provisions </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">the environment:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer192">
<span class="koboSpan" id="kobo.382.1"><img alt="Figure 15.16 – Docker-produced container images are provisioned to Kubernetes after Terraform executes" src="image/B21183_15_16..jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.383.1">Figure 15.16 – Docker-produced container images are provisioned to Kubernetes after Terraform executes</span></p>
<p><span class="koboSpan" id="kobo.384.1">When using </span><a id="_idIndexMarker1142"/><span class="koboSpan" id="kobo.385.1">Google Cloud’s serverless offerings, the deployment process is split. </span><span class="koboSpan" id="kobo.385.2">While both the frontend and backend of our application need a deployment package to be created, the way they are deployed is different. </span><span class="koboSpan" id="kobo.385.3">For the frontend, like on other platforms, we simply generate static web content. </span><span class="koboSpan" id="kobo.385.4">However, for the backend, due to Google Cloud Functions’ unique approach to packaging and deployment, we need to generate a ZIP archive with the application’s source code itself. </span><span class="koboSpan" id="kobo.385.5">These artifacts share a similar purpose to Docker images in that they are a target service-compatible way of packaging our application for deployment, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.386.1">Figure 15</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.387.1">.17</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer193">
<span class="koboSpan" id="kobo.389.1"><img alt="Figure 15.17 – The ZIP archive with the source code acts as the deployment artifacts that are provisioned to Google Cloud when Terraform executes" src="image/B21183_15_17..jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.390.1">Figure 15.17 – The ZIP archive with the source code acts as the deployment artifacts that are provisioned to Google Cloud when Terraform executes</span></p>
<p><span class="koboSpan" id="kobo.391.1">As you can see, the backend deployment looks very similar to the approach used with the virtual-machine-based architecture. </span><span class="koboSpan" id="kobo.391.2">The Terraform code references the packaged artifact and is responsible for deploying it to the Google Cloud Functions that </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">i</span><a id="_idTextAnchor660"/><span class="koboSpan" id="kobo.393.1">t provisions.</span></span></p>
<h2 id="_idParaDest-274"><a id="_idTextAnchor661"/><span class="koboSpan" id="kobo.394.1">Deployment</span></h2>
<p><span class="koboSpan" id="kobo.395.1">Now that </span><a id="_idIndexMarker1143"/><span class="koboSpan" id="kobo.396.1">Terraform has provisioned the Google Cloud infrastructure we need for our serverless solution, we need to take the final step of deploying both deployment artifacts to the appropriate locations in </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">Google Cloud.</span></span></p>
<p><span class="koboSpan" id="kobo.398.1">We will use .NET and Google Cloud custom tools to produce the artifacts and deploy the frontend. </span><span class="koboSpan" id="kobo.398.2">However, the backend will be provisioned </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">by Terraform.</span></span></p>
<h3><span class="koboSpan" id="kobo.400.1">Frontend</span></h3>
<p><span class="koboSpan" id="kobo.401.1">As we saw in </span><a id="_idIndexMarker1144"/><span class="koboSpan" id="kobo.402.1">other chapters, our .NET application code needs to follow a continuous integration process where the code is built and tested using automated unit testing and other built-in quality controls. </span><span class="koboSpan" id="kobo.402.2">Nothing changes there, except that we need to add some special handling to the deployment artifact that these processes produce to ensure it is available to our GitHub Actions job that deploys the workload to the </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">appropriate location:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.404.1">
      - name: Upload to Google Cloud Storage Bucket
        working-directory: ${{ env.DOTNET_WORKING_DIRECTORY }}/upload-staging
        run: |
          gsutil -o Credentials:gs_service_key_file=../gcp-terraform.json -m cp -r . </span><span class="koboSpan" id="kobo.404.2">gs://${{ needs.terraform.outputs.frontend_bucket_name }}</span></pre> <p><span class="koboSpan" id="kobo.405.1">We need to ensure that we authenticate with Google Cloud and target the right Google Cloud project with the right Google Cloud Storage bucket. </span><span class="koboSpan" id="kobo.405.2">The Google Cloud command-line tool that we are using is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">gsutil</span></strong><span class="koboSpan" id="kobo.407.1">. </span><span class="koboSpan" id="kobo.407.2">It can be configured to obtain credentials in several ways, but it is probably the safest to specify the path to a Google Cloud credentials file. </span><span class="koboSpan" id="kobo.407.3">We can use the GitHub Actions secret to generate a file that we then reference when we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">gsutil</span></strong><span class="koboSpan" id="kobo.409.1">. </span><span class="koboSpan" id="kobo.409.2">Once done, we can execute </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">gsutil</span></strong><span class="koboSpan" id="kobo.411.1"> to recursively upload all the files within the </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">staging directory.</span></span></p>
<h3><span class="koboSpan" id="kobo.413.1">Backend</span></h3>
<p><span class="koboSpan" id="kobo.414.1">In order</span><a id="_idIndexMarker1145"/><span class="koboSpan" id="kobo.415.1"> to deploy the Google Cloud function, we need to modify our Terraform to provision a location for the zip archive to be uploaded to and specify the ZIP archive containing the source code of our </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">application code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.417.1">
resource "google_storage_bucket" "backend" {
  project  = google_project.main.project_id
  name     = "${var.application_name}-${var.environment_name}-backend-${random_string.project_id.result}"
  location = "US"
}</span></pre> <p><span class="koboSpan" id="kobo.418.1">After the Google Cloud Storage bucket has been provisioned, we must upload the </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">deployment package:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.420.1">
resource "google_storage_bucket_object" "deployment" {
  name   = "deployment.zip"
  bucket = google_storage_bucket.backend.name
  source = "deployment.zip"
}</span></pre> <p><span class="koboSpan" id="kobo.421.1">The preceding code will reference the </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">deployment.zip</span></strong><span class="koboSpan" id="kobo.423.1"> file in Terraform’s root directory and upload it to the Google Cloud </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">Storage bucket.</span></span></p>
<p><span class="koboSpan" id="kobo.425.1">That’s it! </span><span class="koboSpan" id="kobo.425.2">Now, our application has been fully deployed to Google </span><a id="_idTextAnchor662"/><span class="No-Break"><span class="koboSpan" id="kobo.426.1">Cloud Functions!</span></span></p>
<h1 id="_idParaDest-275"><a id="_idTextAnchor663"/><span class="koboSpan" id="kobo.427.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.428.1">In this chapter, we designed, built, and automated the deployment of a complete end-to-end solution using serverless architecture using Google Cloud Functions. </span><span class="koboSpan" id="kobo.428.2">To accomplish this, we finally had to make some major changes to our application code to conform to the requirements of the serverless runtime. </span><span class="koboSpan" id="kobo.428.3">When adopting serverless offerings, one must make this distinct and considerable decision, as it tightly couples your application code with the target </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">cloud platform.</span></span></p>
<p><span class="koboSpan" id="kobo.430.1">As we conclude this chapter and this Google Cloud-centric narrative, we have successfully implemented cloud architectures on three different cloud platforms—</span><strong class="bold"><span class="koboSpan" id="kobo.431.1">Amazon Web Services</span></strong><span class="koboSpan" id="kobo.432.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.433.1">AWS</span></strong><span class="koboSpan" id="kobo.434.1">), Microsoft Azure, and Google </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">Cloud Platform.</span></span></p>
<p><span class="koboSpan" id="kobo.436.1">Throughout our journey with our enigmatic CEO, Keyser Söze, we saw many similarities that cross from one cloud platform to another, but we also saw distinct differences between the cloud platforms, spanning from small naming convention differences, design and implementation variations up to large structural changes within the entire taxonomy of the cloud platforms. </span><span class="koboSpan" id="kobo.436.2">In addition to exploring these three cloud platforms, we witnessed the journey that many organizations face when navigating their journey to the cloud—whether to stick with what they know or to leap into new capabilities and service offerings that pose challenges due to the learning curve while also granting potential opportunities to streamline operations and better take advantage of the economies of scale that the public cloud has </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">to offer.</span></span></p>
<p><span class="koboSpan" id="kobo.438.1">In the next chapter, we’ll switch gears and look at the distinct challenges when we aren’t starting from scratch but trying to adapt existing environments and architectures to bring them into an </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">infrastructure-as-code world.</span></span></p>
</div>


<div class="Content" id="_idContainer195">
<h1 id="_idParaDest-276" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor664"/><span class="koboSpan" id="kobo.1.1">Part 6: Day 2 Operations and Beyond</span></h1>
<p><span class="koboSpan" id="kobo.2.1">In this part, we explore the challenges and common pitfalls when working with existing environments using Terraform, either importing existing environments that were provisioned initially outside of Terraform or managing environments long-term </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">with Terraform.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B21183_16.xhtml#_idTextAnchor665"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 16</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Already Provisioned? </span><span class="koboSpan" id="kobo.8.2">Strategies for Importing Existing Environments</span></em></li>
<li><a href="B21183_17.xhtml#_idTextAnchor700"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 17</span></em></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Managing Production Environments with Terraform</span></em></li>
<li><a href="B21183_18.xhtml#_idTextAnchor740"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 18</span></em></a><span class="koboSpan" id="kobo.13.1">, </span><em class="italic"><span class="koboSpan" id="kobo.14.1">Looking Ahead – Certification, Emerging Trends, and Next Steps</span></em></li>
</ul>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer196">
</div>
</div>
</body></html>