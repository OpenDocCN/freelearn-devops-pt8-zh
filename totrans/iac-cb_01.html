<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Vagrant Development Environments"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Vagrant Development Environments</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Adding an Ubuntu Xenial (16.04 LTS) Vagrant box</li><li class="listitem" style="list-style-type: disc">Using a disposable Ubuntu Xenial (16.04) in seconds</li><li class="listitem" style="list-style-type: disc">Enabling VirtualBox Guest Additions in Vagrant</li><li class="listitem" style="list-style-type: disc">Using a disposable CentOS 7.x with VMware in seconds</li><li class="listitem" style="list-style-type: disc">Extending the VMware VM capabilities</li><li class="listitem" style="list-style-type: disc">Enabling multiprovider Vagrant environments</li><li class="listitem" style="list-style-type: disc">Customizing a Vagrant VM</li><li class="listitem" style="list-style-type: disc">Using Docker with Vagrant</li><li class="listitem" style="list-style-type: disc">Using Docker in Vagrant for a Ghost blog behind NGINX</li><li class="listitem" style="list-style-type: disc">Using Vagrant remotely with AWS EC2 and Docker</li><li class="listitem" style="list-style-type: disc">Simulating dynamic multiple host networking</li><li class="listitem" style="list-style-type: disc">Simulating a networked three-tier architecture app with Vagrant</li><li class="listitem" style="list-style-type: disc">Showing your work on the LAN while working with Laravel</li><li class="listitem" style="list-style-type: disc">Sharing access to your Vagrant environment with the world</li><li class="listitem" style="list-style-type: disc">Simulating Chef upgrades using Vagrant</li><li class="listitem" style="list-style-type: disc">Using Ansible with Vagrant to create a Docker host</li><li class="listitem" style="list-style-type: disc">Using Docker containers on CoreOS with Vagrant</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Introduction</h1></div></div></div><p>Vagrant is a free and open source tool by Hashicorp aimed at building a repeatable development environment inside a virtual machine, using simple Ruby code. You can then distribute this simple file with other people, team members, and external contributors, so that they immediately have a working running environment as long as they have virtualization on their laptop. It also means that you can use a Mac laptop, and with a simple command, launch a fully configured Linux environment for you to use locally. Everyone can work using the same environment, regardless of their own local machine. Vagrant is also very useful to simulate full production environments, with multiple machines and specific operating system versions. Vagrant is compatible with most hypervisors, such as VMware, VirtualBox, or Parallels, and can be largely extended using plugins.</p><p>Vagrant <a id="id0" class="indexterm"/>uses <span class="emphasis"><em>boxes</em></span> to run. These boxes are just packaged virtual machines images that are available, for example, from <a class="ulink" href="https://atlas.hashicorp.com/boxes/search">https://atlas.hashicorp.com/boxes/search</a>, or you can alternatively build your own using various tools.</p><p>Vagrant can be greatly extended using plugins. There're plugins for almost anything you can think about, and most of them are community supported. From specific guest operating systems to remote IaaS providers, features around sharing, caching or snapshotting, networking, testing or specifics to Chef/Puppet, a lot can be done through plugins in Vagrant.</p><p>A list of all available plugins, including all Vagrant providers is available on the Vagrant wiki here: <a class="ulink" href="https://github.com/mitchellh/vagrant/wiki/Available-Vagrant-Plugins">https://github.com/mitchellh/vagrant/wiki/Available-Vagrant-Plugins</a>.</p><p>More information <a id="id1" class="indexterm"/>about all integrated providers can be found on Vagrant's website: <a class="ulink" href="https://www.vagrantup.com/docs/providers/">https://www.vagrantup.com/docs/providers/</a>.</p><p>You can <a id="id2" class="indexterm"/>download a Vagrant installer for your platform from <a class="ulink" href="https://www.vagrantup.com/downloads.html">https://www.vagrantup.com/downloads.html</a>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>The Vagrant version in use for this book is Vagrant 1.8.4</p></div></div></div></div>
<div class="section" title="Adding an Ubuntu Xenial (16.04 LTS) Vagrant box"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Adding an Ubuntu Xenial (16.04 LTS) Vagrant box</h1></div></div></div><p>Vagrant <a id="id3" class="indexterm"/>boxes are referred to by their names, usually following the <span class="emphasis"><em>username/boxname</em></span> naming scheme. A 64-bits <span class="emphasis"><em>Precise</em></span> box released by <span class="emphasis"><em>Ubuntu</em></span> will be named <span class="emphasis"><em>ubuntu/precise64</em></span> while the <span class="emphasis"><em>centos/7</em></span> box will always be the latest CentOS 7 official box.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Vagrant installation using the free and open source Virtualbox hypervisor</li><li class="listitem" style="list-style-type: disc">An Internet connection</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>How to do it…</h2></div></div></div><p>Open a terminal and type the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vagrant box add ubuntu/xenial64</strong></span>
<span class="strong"><strong>==&gt; box: Loading metadata for box 'ubuntu/xenial64'</strong></span>
<span class="strong"><strong>    box: URL: https://atlas.hashicorp.com/ubuntu/xenial64</strong></span>
<span class="strong"><strong>==&gt; box: Adding box 'ubuntu/xenial64' (v20160815.0.0) for provider: virtualbox</strong></span>
<span class="strong"><strong>    box: Downloading: https://atlas.hashicorp.com/ubuntu/boxes/xenial64/versions/20160815.0.0/providers/virtualbox.box</strong></span>
<span class="strong"><strong>==&gt; box: Successfully added box 'ubuntu/xenial64' (v20160815.0.0) for 'virtualbox'!</strong></span>
</pre></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>How it works…</h2></div></div></div><p>Vagrant <a id="id4" class="indexterm"/>knows where to look for the latest version for the requested box on the Atlas service and automatically downloads it over the Internet. All boxes are stored by default in <code class="literal">~/.vagrant.d/boxes</code>.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>There's more…</h2></div></div></div><p>If you're interested in creating your own base Vagrant boxes, refer to Packer (<a class="ulink" href="https://www.packer.io/">https://www.packer.io/</a>) and the Chef Bento project (<a class="ulink" href="http://chef.github.io/bento/">http://chef.github.io/bento/</a>).</p></div></div>
<div class="section" title="Using a disposable Ubuntu Xenial (16.04) in seconds"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Using a disposable Ubuntu Xenial (16.04) in seconds</h1></div></div></div><p>We want <a id="id5" class="indexterm"/>to access and use an Ubuntu Xenial system (16.04 LTS) as quickly as possible.</p><p>To do that, Vagrant uses a file named <code class="literal">Vagrantfile</code> to describe the Vagrant infrastructure. This file is in fact pure Ruby that Vagrant reads to manage your environment. Everything related to Vagrant is done inside a block such as the following:</p><div class="informalexample"><pre class="programlisting">Vagrant.configure("2") do |config|
  # all your Vagrant configuration here
end</pre></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Vagrant installation</li><li class="listitem" style="list-style-type: disc">A working VirtualBox installation</li><li class="listitem" style="list-style-type: disc">An Internet connection</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a <a id="id6" class="indexterm"/>folder for the project:<div class="informalexample"><pre class="programlisting">$ mkdir vagrant_ubuntu_xenial_1 &amp;&amp; cd $_</pre></div></li><li class="listitem">Using your favorite editor, create this very minimal Vagrantfile to launch an ubuntu/<code class="literal">xenial64</code> box:<div class="informalexample"><pre class="programlisting">Vagrant.configure("2") do |config|
  config.vm.box = "ubuntu/xenial64"
end</pre></div></li><li class="listitem">Now you can execute Vagrant, by explicitly using the Virtualbox hypervisor:<div class="informalexample"><pre class="programlisting">$ vagrant up --provider=virtualbox</pre></div></li><li class="listitem">Within seconds, you'll have a running Ubuntu 16.04 Vagrant box on your host and you can do whatever you want with it. For example, start by logging into it via <span class="strong"><strong>Secure Shell</strong></span> (<span class="strong"><strong>SSH</strong></span>) by issuing the following <code class="literal">vagrant</code> command and use the system normally:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vagrant ssh</strong></span>
<span class="strong"><strong>Welcome to Ubuntu 16.04.1 LTS (GNU/Linux 4.4.0-34-generic x86_64)</strong></span>
<span class="strong"><strong>[…]</strong></span>
<span class="strong"><strong>ubuntu@ubuntu-xenial:~$ hostname</strong></span>
<span class="strong"><strong>ubuntu-xenial</strong></span>
<span class="strong"><strong>ubuntu@ubuntu-xenial:~$ free -m</strong></span>
<span class="strong"><strong>ubuntu@ubuntu-xenial:~$ cat /proc/cpuinfo</strong></span>
</pre></div></li><li class="listitem">When you're done with your Vagrant VM, you can simply destroy it:<div class="informalexample"><pre class="programlisting">$ vagrant destroy
==&gt; default: Forcing shutdown of VM...
<span class="strong"><strong>==&gt; default: Destroying VM and associated drives...</strong></span>
</pre></div><p>Alternatively, we can just stop the Vagrant VM with the goal of restarting it later in its current state using vagrant halt: </p><p>
<span class="strong"><strong>$ vagrant halt</strong></span>
</p></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec18"/>How it works…</h2></div></div></div><p>When you started Vagrant, it read the Vagrantfile, asking for a specific box to run (Ubuntu Xenial). If you previously added it, it will launch it right away through the default hypervisor (in this case, VirtualBox), or if it's a new box, download it for you automatically. It created the required virtual network interfaces, then the Ubuntu VM got a private <a id="id7" class="indexterm"/>IP address. Vagrant took care of configuring <span class="strong"><strong>SSH</strong></span> by <a id="id8" class="indexterm"/>exposing an available port and inserting a default key, so you can log into it via SSH without problems.</p></div></div>
<div class="section" title="Enabling VirtualBox Guest Additions in Vagrant"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Enabling VirtualBox Guest Additions in Vagrant</h1></div></div></div><p>The VirtualBox <a id="id9" class="indexterm"/>Guest Additions are a set of drivers and applications to be deployed on a virtual machine to have better performance and enable features such as folder sharing. While it's possible to include <a id="id10" class="indexterm"/>the <span class="strong"><strong>Guest Additions</strong></span> directly in the box, not all the boxes you'll find have it, and even when they do, they can be outdated very quickly.</p><p>The solution is to automatically deploy the VirtualBox Guest Additions on demand, through a plugin.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>The downside to using this plugin is that the Vagrant box may now take longer to boot, as it may need to download and install the right guest additions for the box.</p></div></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec19"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Vagrant installation</li><li class="listitem" style="list-style-type: disc">A working VirtualBox installation</li><li class="listitem" style="list-style-type: disc">An internet connection</li><li class="listitem" style="list-style-type: disc">The Vagrantfile from the previous recipe</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec20"/>How to do it…</h2></div></div></div><p>Follow these steps to enable VirtualBox Guest Additions in Vagrant:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Install the <code class="literal">vagrant-vbguest</code> plugin:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vagrant plugin install vagrant-vbguest</strong></span>
<span class="strong"><strong>Installing the 'vagrant-vbguest' plugin. This can take a few minutes...</strong></span>
<span class="strong"><strong>Installed the plugin 'vagrant-vbguest (0.13.0)'!</strong></span>
</pre></div></li><li class="listitem">Confirm that the plugin is installed:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vagrant plugin list</strong></span>
<span class="strong"><strong>vagrant-vbguest (0.13.0)</strong></span>
</pre></div></li><li class="listitem">Start Vagrant and see that the VirtualBox Guest Additions are installed:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vagrant up</strong></span>
<span class="strong"><strong>[…]</strong></span>
<span class="strong"><strong>Installing Virtualbox Guest Additions 5.0.26</strong></span>
<span class="strong"><strong>[…]</strong></span>
<span class="strong"><strong>Building the VirtualBox Guest Additions kernel modules</strong></span>
<span class="strong"><strong> ...done.</strong></span>
<span class="strong"><strong>Doing non-kernel setup of the Guest Additions …done.</strong></span>
</pre></div></li><li class="listitem">Now, maybe you don't want to do this every time you start you Vagrant box, because <a id="id11" class="indexterm"/>it takes time and bandwidth or because the minor difference between your host VirtualBox version and the one already installed in the Vagrant box isn't a problem for you. In this case, you can simply tell Vagrant to disable the auto-update feature right from the Vagrantfile:<div class="informalexample"><pre class="programlisting">config.vbguest.auto_update = false</pre></div></li><li class="listitem">An even better way to keep your code compatible with people without this plugin is to use this plugin configuration only if the plugin is found by Vagrant itself:<div class="informalexample"><pre class="programlisting">if Vagrant.has_plugin?("vagrant-vbguest") then
    config.vbguest.auto_update = false
end</pre></div></li><li class="listitem">The full Vagrantfile now looks like this:<div class="informalexample"><pre class="programlisting">Vagrant.configure("2") do |config|
    config.vm.box = "ubuntu/xenial64"
    if Vagrant.has_plugin?("vagrant-vbguest") then
          config.vbguest.auto_update = false
    end
end</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec21"/>How it works…</h2></div></div></div><p>Vagrant plugins are automatically installed from the vendor's website, and made available globally on your system for all other Vagrant environments you'll run. Once the virtual machine is ready, the plugin will detect the operating system, decide if the Guest Additions need to be installed or not, and if they do, install the necessary tools to do that (compilers, kernel headers, and libraries), and finally download and install the corresponding Guest Additions.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec22"/>There's more…</h2></div></div></div><p>Using <a id="id12" class="indexterm"/>Vagrant plugins also extends what you can do with the Vagrant CLI. In the case of the VirtualBox Guest Addition plugin, you can do a lot of things such as status checks, manage the installation, and much more:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vagrant vbguest --status</strong></span>
<span class="strong"><strong>[default] GuestAdditions 5.0.26 running --- OK.</strong></span>
</pre></div><p>The plugin can later be called through Vagrant directly; here it's triggering the Guest Additions installation in the virtual machine:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vagrant vbguest --do install</strong></span>
</pre></div></div></div>
<div class="section" title="Using a disposable CentOS 7.x with VMware in seconds"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Using a disposable CentOS 7.x with VMware in seconds</h1></div></div></div><p>Vagrant <a id="id13" class="indexterm"/>supports both VMware Workstation and <a id="id14" class="indexterm"/>VMware Fusion through official plugins available on the Vagrant store (<a class="ulink" href="https://www.vagrantup.com/vmware">https://www.vagrantup.com/vmware</a>). Follow the indications from the official website to install the plugins.</p><p>Vagrant <a id="id15" class="indexterm"/>boxes depend on the hypervisor—a VirtualBox image won't run on VMware. You need to use dedicated images for each supervisor you choose to use. For example, Ubuntu official releases only provide VirtualBox images. If you try to create a Vagrant box with a provider while using an image built for another provider, you'll get an error.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec23"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Vagrant installation</li><li class="listitem" style="list-style-type: disc">A working VMware Workstation (PC) or Fusion (Mac) installation</li><li class="listitem" style="list-style-type: disc">A working Vagrant VMware plugin installation</li><li class="listitem" style="list-style-type: disc">An Internet connection</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec24"/>How to do it…</h2></div></div></div><p>The Chef Bento project provides various multiprovider images we can use. For example, let's use a CentOS 7.2 with Vagrant (bento/centos-7.2) with this simplest Vagrantfile:</p><div class="informalexample"><pre class="programlisting">Vagrant.configure("2") do |config|
  config.vm.box = "bento/centos-7.2"
end</pre></div><p>Start your CentOS 7.2 virtual environment and specify the hypervisor you want to run:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vagrant up --provider=vmware_fusion</strong></span>
<span class="strong"><strong>$ vagrant ssh</strong></span>
</pre></div><p>You're now running a CentOS 7.2 Vagrant box using VMware!</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec25"/>How it works…</h2></div></div></div><p>Vagrant <a id="id16" class="indexterm"/>is powered by plugins extending its usage <a id="id17" class="indexterm"/>and capabilities. In this case, the Vagrant plugin for VMware delegates all the virtualization features to the VMware installation, removing the need for VirtualBox.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec26"/>There's more…</h2></div></div></div><p>If VMware is your primary hypervisor, you'll soon be tired to always specify the provider in the command line. By setting the <code class="literal">VAGRANT_DEFAULT_PROVIDER</code> environment variable to the corresponding plugin, you will never have to specify the provider again, VMware will be the default:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ export VAGRANT_DEFAULT_PROVIDER=vmware_fusion</strong></span>
<span class="strong"><strong>$ vagrant up</strong></span>
</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec27"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Chef <a id="id18" class="indexterm"/>Bento Project at <a class="ulink" href="http://chef.github.io/bento/">http://chef.github.io/bento/</a></li><li class="listitem" style="list-style-type: disc">A community <a id="id19" class="indexterm"/>VMware vSphere plugin at <a class="ulink" href="https://github.com/nsidc/vagrant-vsphere">https://github.com/nsidc/vagrant-vsphere</a></li><li class="listitem" style="list-style-type: disc">A community <a id="id20" class="indexterm"/>VMware vCloud Director plugin at <a class="ulink" href="https://github.com/frapposelli/vagrant-vcloud">https://github.com/frapposelli/vagrant-vcloud</a></li><li class="listitem" style="list-style-type: disc">A community <a id="id21" class="indexterm"/>VMware vCenter plugin at <a class="ulink" href="https://github.com/frapposelli/vagrant-vcenter">https://github.com/frapposelli/vagrant-vcenter</a></li><li class="listitem" style="list-style-type: disc">A community <a id="id22" class="indexterm"/>VMware vCloud Air plugin at <a class="ulink" href="https://github.com/frapposelli/vagrant-vcloudair">https://github.com/frapposelli/vagrant-vcloudair</a></li></ul></div></div></div>
<div class="section" title="Extending the VMware VM capabilities"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Extending the VMware VM capabilities</h1></div></div></div><p>The hardware <a id="id23" class="indexterm"/>specifications of the Vagrant box vary from image to image as they're specified at the creation time. However, it's not fixed forever: it's just the default behavior. You can set the requirements right in the Vagrantfile, so you can keep a daily small Vagrant box and on-demand.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec28"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Vagrant installation</li><li class="listitem" style="list-style-type: disc">A working VMware Workstation (PC) or Fusion (Mac) installation</li><li class="listitem" style="list-style-type: disc">A working Vagrant VMware plugin installation</li><li class="listitem" style="list-style-type: disc">An internet connection</li><li class="listitem" style="list-style-type: disc">The Vagrantfile from the previous recipe using a bento/centos72 box</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec29"/>How to do it…</h2></div></div></div><p>The VMware provider can be configured inside the following configuration blocks:</p><div class="informalexample"><pre class="programlisting"># VMware Fusion configuration
config.vm.provider "vmware_fusion" do |vmware|
  # enter all the vmware configuration here
end

# VMware Workstation configuration
config.vm.provider "vmware_workstation" do |vmware|
  # enter all the vmware configuration here
end</pre></div><p>If the configuration is the same, you'll end up with a lot of duplicated code. Take advantage of the Ruby nature of the Vagrantfile and use a simple loop to iterate through both values:</p><div class="informalexample"><pre class="programlisting">["vmware_fusion", "vmware_workstation"].each do |vmware|
  config.vm.provider vmware do |v|
    # enter all the vmware configuration here
  end
end</pre></div><p>Our default Bento CentOS 7.2 image has only 512 MB of RAM and one CPU. Let's double that for better performance using the <code class="literal">vmx["numvcpus"]</code> and <code class="literal">vmx["memsize"]</code> keys:</p><div class="informalexample"><pre class="programlisting">  ["vmware_fusion", "vmware_workstation"].each do |vmware|
    config.vm.provider vmware do |v|
      v.vmx["numvcpus"] = "2"
      v.vmx["memsize"] = "1024"
    end
  end</pre></div><p>Start or restart your Vagrant machine to apply the changes:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vagrant up</strong></span>
<span class="strong"><strong>[…]</strong></span>
</pre></div><p>Your box is now using two CPUs and 1 GB of RAM.</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec30"/>How it works…</h2></div></div></div><p>Virtual <a id="id24" class="indexterm"/>machine configuration is the last thing done by Vagrant before starting up. Here, it just tells VMware to allocate two CPUs and 1 GB of RAM to the virtual machine it's launching the way you would have done manually from inside the software.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec31"/>There's more…</h2></div></div></div><p>Vagrant's authors may merge both plugins into one at some point in the future. The current 4.x version of the plugins is still split.</p><p>The VMX format is not very well documented by VMware. The possible keys and values can be found on most VMware Inc. documentation about VMX configuration.</p></div></div>
<div class="section" title="Enabling multiprovider Vagrant environments"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Enabling multiprovider Vagrant environments</h1></div></div></div><p>You might <a id="id25" class="indexterm"/>be running VMware on your laptop, but your coworker might not. Alternatively, you want people to have the choice, or you simply want both environments to work! We'll see how to build a single Vagrantfile to support them all.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec32"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Vagrant installation</li><li class="listitem" style="list-style-type: disc">A working VirtualBox installation</li><li class="listitem" style="list-style-type: disc">A working VMware Workstation (PC) or Fusion (Mac) installation</li><li class="listitem" style="list-style-type: disc">A working Vagrant VMware plugin installation</li><li class="listitem" style="list-style-type: disc">An internet connection</li><li class="listitem" style="list-style-type: disc">The Vagrantfile from the previous recipe using a bento/centos72 box</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec33"/>How to do it…</h2></div></div></div><p>Some Vagrant boxes are available for multiple hypervisors, such as the CentOS 7 Bento box we previously used. This way, we can simply choose which one to use.</p><p>Let's start <a id="id26" class="indexterm"/>with our previous Vagrantfile including customizations for VMware:</p><div class="informalexample"><pre class="programlisting">Vagrant.configure("2") do |config|
  config.vm.box = "bento/centos-7.2"
  ["vmware_fusion", "vmware_workstation"].each do |vmware|
    config.vm.provider vmware do |v|
      v.vmx["numvcpus"] = "2"
      v.vmx["memsize"] = "1024"
    end
  end
end</pre></div><p>How would we add the same configuration on VirtualBox as we have on VMware? Here's how to customize VirtualBox similarly in the Vagrantfile:</p><div class="informalexample"><pre class="programlisting">  config.vm.provider :virtualbox do |vb|
    vb.memory = "1024"
    vb.cpus = "2"
  end</pre></div><p>Add this to your current Vagrantfile, reload and you'll get the requested resources from your hypervisor, be it VMware or VirtualBox.</p><p>It's nice, but we're still repeating ourselves with the values, leading to possible errors, omissions, or mistakes in the future. Let's take advantage once again of the Ruby nature of our Vagrantfile and declare some meaningful variables at the top of our file:</p><div class="informalexample"><pre class="programlisting">vm_memory = 1024
vm_cpus = 2</pre></div><p>Now replace the four values by their variable names and you're done: you're centrally managing characteristics of the Vagrant environment you're using and distributing, whatever hypervisor you're using.</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec34"/>How it works…</h2></div></div></div><p>The simple fact that the Vagrantfile is a pure Ruby file helps creating powerful and dynamic configuration, by simply setting variables that we use later for all the providers.</p></div></div>
<div class="section" title="Customizing a Vagrant VM"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Customizing a Vagrant VM</h1></div></div></div><p>Vagrant <a id="id27" class="indexterm"/>supports many configuration options through the Vagrantfile. Here are the most useful ones for daily use.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec35"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Vagrant installation (with a hypervisor)</li><li class="listitem" style="list-style-type: disc">An Internet connection</li><li class="listitem" style="list-style-type: disc">The Vagrantfile from the previous recipe using a bento/centos72 box</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec36"/>How to do it…</h2></div></div></div><p>Here are some possible customizations for your Vagrant Virtual Machine.</p><div class="section" title="Set the hostname"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Set the hostname</h3></div></div></div><p>If you <a id="id28" class="indexterm"/>want to specify the VM name right from Vagrant, just add the following:</p><div class="informalexample"><pre class="programlisting">config.vm.hostname = "vagrant-lab-1"</pre></div><p>This will also add an entry with the hostname to the <code class="literal">/etc/host</code> file.</p></div><div class="section" title="Disable new box version check at startup"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Disable new box version check at startup</h3></div></div></div><p>You may <a id="id29" class="indexterm"/>be using a slow internet connection, or you know you do want to use your current installed box, or maybe you're in a hurry and just want to get the job done; you can just remove the option to check for a new version of the box at startup by adding the following:</p><div class="informalexample"><pre class="programlisting">config.vm.box_check_update = false</pre></div></div><div class="section" title="Use a specific box version"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec03"/>Use a specific box version</h3></div></div></div><p>If you <a id="id30" class="indexterm"/>know you want to use a specific version of the box (maybe for debugging purposes or compliance) and not the latest, you can simply declare it as follows:</p><div class="informalexample"><pre class="programlisting">config.vm.box_version = "2.2.9"</pre></div></div><div class="section" title="Display an informational message to the user"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec04"/>Display an informational message to the user</h3></div></div></div><p>A useful <a id="id31" class="indexterm"/>feature is to display some basic but relevant information to the user launching the Vagrant box, such as usage or connection information. Don't forget to escape the special characters. As it's Ruby, you <a id="id32" class="indexterm"/>can access all available variables, so the message can be even more dynamic and useful to the user:</p><div class="informalexample"><pre class="programlisting">config.vm.post_up_message = "Use \"vagrant ssh\" to log into the box. This VM uses #{vm_cpus} CPUs and #{vm_memory}MB of RAM."</pre></div></div><div class="section" title="Specify a minimum Vagrant version"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec05"/>Specify a minimum Vagrant version</h3></div></div></div><p>Vagrant is <a id="id33" class="indexterm"/>updated quite often, and new features are added regularly. A good practice, if you use a feature that is known to work only after a specific version, is to declare it in the Vagrantfile, so people with an older version know they have to update:</p><div class="informalexample"><pre class="programlisting">Vagrant.require_version "&gt;= 1.8.0"</pre></div></div></div></div>
<div class="section" title="Using Docker with Vagrant"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec17"/>Using Docker with Vagrant</h1></div></div></div><p>Development <a id="id34" class="indexterm"/>environments can often be mixed, using <a id="id35" class="indexterm"/>both virtual machines and Docker containers. While virtual machines include everything needed to run a full operating system like memory, CPU, a kernel and all required libraries, a container is much more lightweight and can share all this with its host, while keeping a good isolation through special kernel features named cgroups. Docker containers helps developers use, share and ship a <span class="emphasis"><em>bundle</em></span> including everything needed to run their application. Here, we'll show how to use Vagrant to start containers. Since Docker usage is a little different between Linux hosts and other platforms, the reference used here is the native Docker platform—Linux.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec37"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Vagrant installation (no hypervisor needed)</li><li class="listitem" style="list-style-type: disc">A working Docker installation and basic Docker knowledge</li><li class="listitem" style="list-style-type: disc">An Internet connection</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec38"/>How to do it…</h2></div></div></div><p>We'll see how to use, access, and manipulate an NGINX container in Vagrant using Docker as a provider.</p><div class="section" title="Using NGINX Docker container through Vagrant"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec06"/>Using NGINX Docker container through Vagrant</h3></div></div></div><p>Let's start <a id="id36" class="indexterm"/>with the simplest Vagrantfile possible, using the <code class="literal">nginx:stable</code> container with the Docker Vagrant provider:</p><div class="informalexample"><pre class="programlisting">Vagrant.configure("2") do |config|
  config.vm.hostname = "vagrant-docker-1"
  config.vm.post_up_message = "HTTP access: http://localhost/"
  config.vm.provider "docker" do |docker|
      docker.image = "nginx:stable"
  end
end</pre></div><p>Simply start it up with the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vagrant up --provider=docker</strong></span>
<span class="strong"><strong>Bringing machine 'default' up with 'docker' provider...</strong></span>
<span class="strong"><strong>==&gt; default: Creating the container...</strong></span>
<span class="strong"><strong>[…]</strong></span>
<span class="strong"><strong>==&gt; default: HTTP access: http://localhost/</strong></span>
</pre></div><p>Let's <a id="id37" class="indexterm"/>remove the need to specify the provider on the command line by setting a simple Ruby environment access code at the top of the Vagrantfile:</p><div class="informalexample"><pre class="programlisting">ENV['VAGRANT_DEFAULT_PROVIDER'] = 'docker'</pre></div><p>Now you can distribute your Vagrantfile and not worry about people forgetting to explicitly specify the Docker provider.</p></div><div class="section" title="Exposing Docker ports in Vagrant"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec07"/>Exposing Docker ports in Vagrant</h3></div></div></div><p>Okay, the <a id="id38" class="indexterm"/>previous example wasn't terribly useful as we didn't expose any ports. Let's tell Vagrant to expose the Docker container HTTP (TCP/80) port to our host's HTTP (TCP/80) port:</p><div class="informalexample"><pre class="programlisting">  config.vm.provider "docker" do |docker|
      docker.image = "nginx:stable"
      docker.ports = ['80:80']
  end</pre></div><p>Restart the Vagrant and verify you can access your NGINX container:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl http://localhost/</strong></span>
</pre></div></div><div class="section" title="Sharing folders with Docker through Vagrant"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec08"/>Sharing folders with Docker through Vagrant</h3></div></div></div><p>What about <a id="id39" class="indexterm"/>sharing a local folder so you can code on your laptop and see the result processed by the Vagrant environment? The default NGINX configuration reads files from <code class="literal">/usr/share/nginx/html</code>. Let's put our own <code class="literal">index.html</code> in there.</p><p>Create a simple <code class="literal">src/index.html</code> file, containing some text:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mkdir src; echo "&lt;h1&gt;Hello from Docker via Vagrant&lt;h1&gt;" &gt; src/index.html</strong></span>
</pre></div><p>Add the Docker volume configuration to our Docker provider block in Vagrant:</p><div class="informalexample"><pre class="programlisting">  config.vm.provider "docker" do |docker|
      docker.image = "nginx:stable"
      docker.ports = ['80:80']
      docker.volumes = ["#{Dir.pwd}/src:/usr/share/nginx/html"]
  end</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>
<code class="literal">#{Dir.pwd}</code> is the Ruby for finding the current directory, so you don't hardcode paths, making it highly distributable.</p></div></div><p>Restart <a id="id40" class="indexterm"/>the Vagrant environment and see the result:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl http://localhost</strong></span>
<span class="strong"><strong>&lt;h1&gt;Hello from Docker via Vagrant&lt;h1&gt;</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>On SELinux-enabled systems you may need to do some configuration that's beyond the scope of this book. We encourage you to secure your Docker systems using SELinux, but to disable SELinux just type the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo setenforce 0</strong></span>
</pre></div></div></div></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec39"/>There's more…</h2></div></div></div><p>You can choose not to use your local or default Docker installation, but instead use a dedicated VM, maybe to reflect production or a specific OS (such as CoreOS). In this case, you can specify a dedicated Vagrantfile as follows:</p><div class="informalexample"><pre class="programlisting">config.vm.provider "docker" do |docker|
docker.vagrant_vagrantfile = "docker_host/Vagrantfile"
end</pre></div></div></div>
<div class="section" title="Using Docker in Vagrant for a Ghost blog behind NGINX"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec18"/>Using Docker in Vagrant for a Ghost blog behind NGINX</h1></div></div></div><p>Vagrant in <a id="id41" class="indexterm"/>Docker can be used <a id="id42" class="indexterm"/>more usefully to simulate traditional setups such as an application behind a load balancer or a reverse proxy. We've already set up NGINX, so what about using it as a front reverse proxy with a blog engine such as Ghost behind it? We'll end up by showing how to do something similar with docker-compose.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec40"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Vagrant installation (no hypervisor needed)</li><li class="listitem" style="list-style-type: disc">A working Docker installation and basic Docker knowledge</li><li class="listitem" style="list-style-type: disc">An Internet connection</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec41"/>How to do it…</h2></div></div></div><p>The previous <a id="id43" class="indexterm"/>example allows <a id="id44" class="indexterm"/>only one container to be launched simultaneously, which is sad considering the power of Docker. Let's define multiple containers and start by creating a <code class="literal">front</code> container (our previous NGINX):</p><div class="informalexample"><pre class="programlisting">  config.vm.define "front" do |front|
    front.vm.provider "docker" do |docker|
      docker.image = "nginx:stable"
      docker.ports = ['80:80']
      docker.volumes = ["#{Dir.pwd}/src:/usr/share/nginx/html"]
    end
  end</pre></div><p>Now how about creating an application container, maybe a blog engine such as Ghost? Ghost publishes a ready-to-use container on the Docker Hub, so let's use that (version 0.9.0 at the time of writing) and expose on TCP/8080 the application container listening on TCP/2368:</p><div class="informalexample"><pre class="programlisting">  config.vm.define "app" do |app|
    app.vm.provider "docker" do |docker|
      docker.image = "ghost:0.9.0"
      docker.ports = ['8080:2368']
    end
  end</pre></div><p>Check if you can access the blog on <code class="literal">http://localhost:8080</code> and NGINX on <code class="literal">http://localhost</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl -IL http://localhost:8080</strong></span>
<span class="strong"><strong>HTTP/1.1 200 OK</strong></span>
<span class="strong"><strong>X-Powered-By: Express</strong></span>
<span class="strong"><strong>[…]</strong></span>

<span class="strong"><strong>$ curl -IL http://localhost</strong></span>
<span class="strong"><strong>HTTP/1.1 200 OK</strong></span>
<span class="strong"><strong>Server: nginx/1.10.1</strong></span>
</pre></div><p>Now let's use NGINX for what it's for—serving the application. Configuring NGINX as a reverse proxy is beyond the scope of this book, so just use the following simple configuration for the <code class="literal">nginx.conf</code> file at the root of your working folder:</p><div class="informalexample"><pre class="programlisting">server {
  listen 80;
  location / {
    proxy_set_header   X-Real-IP $remote_addr;
    proxy_set_header   Host      $http_host;
    proxy_pass         http://app:2368;
  }
}</pre></div><p>Change <a id="id45" class="indexterm"/>the configuration <a id="id46" class="indexterm"/>of the <code class="literal">front</code> container in Vagrant to use this configuration, remove the old <code class="literal">index.html</code> as we're not using it anymore, and link this container to the <code class="literal">app</code> container:</p><div class="informalexample"><pre class="programlisting">  config.vm.define "front" do |front|
    front.vm.provider "docker" do |docker|
      docker.image = "nginx:stable"
      docker.ports = ['80:80']
      docker.volumes = ["#{Dir.pwd}/nginx.conf:/etc/nginx/conf.d/default.conf"]
      docker.link("app:app")
    end
  end</pre></div><p>Linking the <code class="literal">app</code> container makes it available to the <code class="literal">front</code> container, so now there's no need to expose the Ghost blog container directly, let's make it simpler and more secure behind the reverse proxy:</p><div class="informalexample"><pre class="programlisting">  config.vm.define "app" do |app|
    app.vm.provider "docker" do |docker|
      docker.name = "app"
      docker.image = "ghost:0.9.0"
    end
  end</pre></div><p>We're close! But this setup will eventually fail for a simple reason: our systems are too fast, and Vagrant parallelizes the startup of virtual machines by default, and also does this for containers. Containers start so fast that the <code class="literal">app</code> container may not be ready for NGINX when it's started. To ensure sequential startup, use the <code class="literal">VAGRANT_NO_PARALLEL</code> environment variable at the top of the Vagrantfile:</p><div class="informalexample"><pre class="programlisting">ENV['VAGRANT_NO_PARALLEL'] = 'true'</pre></div><p>Now you can browse to <code class="literal">http://localhost/admin</code> and start using your Ghost blog in a container, behind <a id="id47" class="indexterm"/>a NGINX reverse proxy container, with the whole thing managed by Vagrant!</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec42"/>There's more…</h2></div></div></div><p>You <a id="id48" class="indexterm"/>can access the containers logs directly using Vagrant:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vagrant docker-logs --follow</strong></span>
<span class="strong"><strong>==&gt; app: &gt; ghost@0.9.0 start /usr/src/ghost</strong></span>
<span class="strong"><strong>==&gt; app: &gt; node index</strong></span>
<span class="strong"><strong>==&gt; app: Migrations: Creating tables...</strong></span>
<span class="strong"><strong>[…]</strong></span>
<span class="strong"><strong>==&gt; front: 172.17.0.1 - - [21/Aug/2016:10:55:08 +0000] "GET / HTTP/1.1" 200 1547 "-" "Mozilla/5.0 (X11; Fedora; Linux x86_64; rv:48.0) Gecko/20100101 Firefox/48.0" "-"</strong></span>
<span class="strong"><strong>==&gt; app: GET / 200 113.120 ms - -</strong></span>
<span class="strong"><strong>[…]</strong></span>
</pre></div><div class="section" title="A Docker Compose equivalent"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec09"/>A Docker Compose equivalent</h3></div></div></div><p>Docker Compose is a tool to orchestrate multiple containers and manage Docker features from a single YAML file. So if you're <a id="id49" class="indexterm"/>more familiar with Docker Compose, or if you'd like to do something similar with this tool, here's what the code would look like in the <code class="literal">docker-compose.yml</code> file:</p><div class="informalexample"><pre class="programlisting">version: '2'
services:
  front:
    image: nginx:stable
    volumes:
      - "./nginx.conf:/etc/nginx/conf.d/default.conf"
    restart: always
    ports:
      - "80:80"
    depends_on:
      - app
    links:
      - app
  app:
    image: ghost:0.9.0
    restart: always</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>Remember that with Vagrant, you can mix virtual machines and Docker containers, while you can't with docker-compose.</p></div></div></div></div></div>
<div class="section" title="Using Vagrant remotely with AWS EC2 and Docker"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec19"/>Using Vagrant remotely with AWS EC2 and Docker</h1></div></div></div><p>Another <a id="id50" class="indexterm"/>powerful usage of Vagrant can be with remote IaaS resources such as Amazon EC2. Amazon Web Services Elastic Compute Cloud (EC2) and similar Infrastructure-as-a-Service providers like Google Cloud, Azure or Digital Ocean, to name a few, are selling virtual machines with varying compute power and network bandwidth for a fee. You don't always have all the necessary CPU <a id="id51" class="indexterm"/>and memory you need on your laptop, or you need to have some specific computing power for a task, or you just want to replicate part of an existing production environment: here's how you can leverage the power of Vagrant using Amazon EC2.</p><p>Here, we'll deploy a Ghost blog with an NGINX reverse proxy, all on Docker, using an Ubuntu Xenial 16.04 on AWS EC2! This is to simulate a real deployment of an application, so you can see if it is working in real conditions.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec43"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Vagrant installation (no hypervisor needed)</li><li class="listitem" style="list-style-type: disc">An Amazon <a id="id52" class="indexterm"/>EC2 account (or create one for free at <a class="ulink" href="https://aws.amazon.com/">https://aws.amazon.com/</a> if you don't have one already), with valid Access Keys, a keypair named <span class="emphasis"><em>iac-lab</em></span>, a security group named <span class="emphasis"><em>iac-lab</em></span> allowing at least HTTP ports, and SSH access.</li><li class="listitem" style="list-style-type: disc">An Internet connection</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec44"/>How to do it…</h2></div></div></div><p>Begin by installing the plugin:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vagrant plugin install vagrant-aws</strong></span>
</pre></div><p>A requirement of this plugin is the presence of a dummy Vagrant box that does nothing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vagrant box add dummy https://github.com/mitchellh/vagrant-aws/raw/master/dummy.box</strong></span>
</pre></div><p>Remember how we configured the Docker provider in the previous recipes? This is no different:</p><div class="informalexample"><pre class="programlisting">config.vm.provider :aws do |aws, override|
  # AWS Configuration
  override.vm.box = "dummy"
end</pre></div><p>Then, defining <a id="id53" class="indexterm"/>an application VM will consist of specifying which provider it's using (AWS in our case), the <span class="strong"><strong>Amazon Machine Image</strong></span> (<span class="strong"><strong>AMI</strong></span>) (Ubuntu 16.04 LTS in our case), and a provisioning script that we creatively named <code class="literal">script.sh</code>.</p><p>You can <a id="id54" class="indexterm"/>find other AMI IDs at <a class="ulink" href="http://cloud-images.ubuntu.com/locator/ec2/">http://cloud-images.ubuntu.com/locator/ec2/</a>:</p><div class="informalexample"><pre class="programlisting">config.vm.define "srv-1" do |config|
    config.vm.provider :aws do |aws|
      aws.ami = "ami-c06b1eb3"
    end
    config.vm.provision :shell, :path =&gt; "script.sh"
end</pre></div><p>So what is the AWS-related information we need to fill in so Vagrant can launch servers on AWS?</p><p>We need the AWS Access Keys, preferably from environment variables so you don't hardcode them in your Vagrantfile:</p><div class="informalexample"><pre class="programlisting">aws.access_key_id = ENV['AWS_ACCESS_KEY_ID']
aws.secret_access_key = ENV['AWS_SECRET_ACCESS_KEY']</pre></div><p>Indicate the region and availability zone where you want the instance to start:</p><div class="informalexample"><pre class="programlisting">aws.region = "eu-west-1"
aws.availability_zone = "eu-west-1a"</pre></div><p>Include <a id="id55" class="indexterm"/>the instance type; here, we've chosen the one included in the AWS free tier plan so it won't cost you a dime with a new account:</p><div class="informalexample"><pre class="programlisting">aws.instance_type = "t2.micro"</pre></div><p>Indicate <a id="id56" class="indexterm"/>in which security group this instance will live (it's up to you to adapt the requirements to your needs):</p><div class="informalexample"><pre class="programlisting">aws.security_groups = ['iac-lab']</pre></div><p>Specify the AWS keypair name, and override the default SSH username and keys:</p><div class="informalexample"><pre class="programlisting">aws.keypair_name = "iac-lab"
override.ssh.username = "ubuntu"
override.ssh.private_key_path = "./keys/iac-lab.pem"</pre></div><p>Under some circumstances, you can experience a bug with NFS while using Vagrant and AWS EC2, so I choose to disable this feature:</p><div class="informalexample"><pre class="programlisting">override.nfs.functional = false</pre></div><p>Finally, it's a good practice to tag the instances, so you can later find out where they come from:</p><div class="informalexample"><pre class="programlisting">aws.tags = {
  'Name'   =&gt; 'Vagrant'
}</pre></div><p>Add a simple shell script that will install Docker and <code class="literal">docker-compose</code>, then execute the docker-compose file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>#!/bin/sh</strong></span>
<span class="strong"><strong># install Docker</strong></span>
<span class="strong"><strong>curl -sSL https://get.docker.com/ | sh</strong></span>
<span class="strong"><strong># add ubuntu user to docker group</strong></span>
<span class="strong"><strong>sudo usermod -aG docker ubuntu</strong></span>
<span class="strong"><strong># install docker-compose</strong></span>
<span class="strong"><strong>curl -L https://github.com/docker/compose/releases/download/1.8.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</strong></span>
<span class="strong"><strong>sudo chmod +x /usr/local/bin/docker-compose</strong></span>
<span class="strong"><strong># execute the docker compose file</strong></span>
<span class="strong"><strong>cd /vagrant</strong></span>
<span class="strong"><strong>docker-compose up -d</strong></span>
</pre></div><p>Include <a id="id57" class="indexterm"/>both NGINX configuration and <code class="literal">docker-compose.yml</code> files from the previous recipe and you're good to go:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vagrant up</strong></span>
<span class="strong"><strong>Bringing machine 'srv-1' up with 'aws' provider...</strong></span>
<span class="strong"><strong>[…]</strong></span>
<span class="strong"><strong>==&gt; srv-1: Launching an instance with the following settings...</strong></span>
<span class="strong"><strong>==&gt; srv-1:  -- Type: t2.micro</strong></span>
<span class="strong"><strong>==&gt; srv-1:  -- AMI: ami-c06b1eb3</strong></span>
<span class="strong"><strong>==&gt; srv-1:  -- Region: eu-west-1</strong></span>
<span class="strong"><strong>[…]</strong></span>
<span class="strong"><strong>==&gt; srv-1: Waiting for SSH to become available...</strong></span>
<span class="strong"><strong>==&gt; srv-1: Machine is booted and ready for use!</strong></span>
<span class="strong"><strong>[…]</strong></span>
<span class="strong"><strong>==&gt; srv-1:  docker version</strong></span>
<span class="strong"><strong>[…]</strong></span>
<span class="strong"><strong>==&gt; srv-1: Server:</strong></span>
<span class="strong"><strong>==&gt; srv-1:  Version:      1.12.1</strong></span>
<span class="strong"><strong>[…]</strong></span>
<span class="strong"><strong>==&gt; srv-1: Creating vagrant_app_1</strong></span>
<span class="strong"><strong>==&gt; srv-1: Creating vagrant_front_1</strong></span>
</pre></div><p>Open <a id="id58" class="indexterm"/>your browser at <code class="literal">http://a.b.c.d/</code> (using the EC2 instance public IP) and you'll see your Ghost blog behind an NGINX reverse proxy, using Docker containers, using Vagrant on Amazon EC2.</p><p>A common usage for such a setup is for the developer to test the application in close to real production conditions, maybe to show a new feature to a remote product owner, replicate a bug seen only in this setup, or at some point in the CI. Once Docker containers have been built, smoke test them on EC2 before going any further.</p></div></div>
<div class="section" title="Simulating dynamic multiple host networking"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec20"/>Simulating dynamic multiple host networking</h1></div></div></div><p>Vagrant <a id="id59" class="indexterm"/>is also very useful when used to simulate multiple hosts in a network. This way you can have full systems able to talk to each other in the same private network and easily test connectivity between systems.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec45"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Vagrant installation</li><li class="listitem" style="list-style-type: disc">A working VirtualBox installation</li><li class="listitem" style="list-style-type: disc">An Internet connection</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec46"/>How to do it…</h2></div></div></div><p>Here's how we would create one CentOS 7.2 machine with 512 MB of RAM and one CPU, in a private network with a fixed IP 192.168.50.11, and a simple shell output:</p><div class="informalexample"><pre class="programlisting">vm_memory = 512
vm_cpus = 1

Vagrant.configure("2") do |config|

  config.vm.box = "bento/centos-7.2"

  config.vm.provider :virtualbox do |vb|
    vb.memory = vm_memory
    vb.cpus = vm_cpus
  end

   config.vm.define "srv-1" do |config|
     config.vm.provision :shell, :inline =&gt; "ip addr | grep \"inet\" | awk '{print $2}'"
     config.vm.network "private_network", ip: "192.168.50.11", virtualbox__intnet: "true"
   end
end</pre></div><p>To add a new machine to this network, we could simply duplicate the <code class="literal">srv-1</code> machine definition, as in the following code:</p><div class="informalexample"><pre class="programlisting">config.vm.define "srv-2" do |config|
     config.vm.provision :shell, :inline =&gt; "ip addr | grep \"inet\" | awk '{print $2}'"
     config.vm.network "private_network", ip: "192.168.50.12", virtualbox__intnet: "true"
end</pre></div><p>That's not very DRY, so let's take advantage of the Ruby nature of the Vagrantfile to create a loop that will dynamically and simply create as many virtual machines as we want.</p><p>First, declare a variable with the amount of virtual machines we want (<code class="literal">2</code>):</p><div class="informalexample"><pre class="programlisting">vm_num = 2</pre></div><p>Then iterate through that value, so it can generate values for an IP and for a hostname:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(1..vm_num).each do |n|</strong></span>
    # a lan lab in the 192.168.50.0/24 range
    <span class="strong"><strong>lan_ip = "192.168.50.#{n+10}"</strong></span>
    config.vm.define "<span class="strong"><strong>srv-#{n}</strong></span>" do |config|
      config.vm.provision :shell, :inline =&gt; "ip addr | grep \"inet\" | awk '{print $2}'"
      config.vm.network "private_network", <span class="strong"><strong>ip: lan_ip</strong></span>, virtualbox__intnet: "true"
    end
  end</pre></div><p>This <a id="id60" class="indexterm"/>will create two virtual machines (<code class="literal">srv-1</code> at <code class="literal">192.168.50.11</code> and <code class="literal">srv-2</code> at <code class="literal">192.168.50.12</code>) on the same internal network, so they can talk to each other.</p><p>Now you can simply change the value of <code class="literal">vm_num</code> and you'll easily spawn new virtual machines in seconds.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec47"/>There's more…</h2></div></div></div><p>We can optionally go even further, using the following cloning and networking features.</p><div class="section" title="Speed up deployments with linked clones"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec10"/>Speed up deployments with linked clones</h3></div></div></div><p>Linked <a id="id61" class="indexterm"/>clones is a feature that enables new VMs to be created based on an initial existing disk image, without the need to duplicate everything. Each VM stores only its delta state, allowing very fast virtual machines boot times.</p><p>As we're launching many machines, you can optionally enable linked clones to speed things up:</p><div class="informalexample"><pre class="programlisting">config.vm.provider :virtualbox do |vb|
    vb.memory = vm_memory
    vb.cpus = vm_cpus
<span class="strong"><strong>    vb.linked_clone = true</strong></span>
end</pre></div></div><div class="section" title="Using named NAT networks"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec11"/>Using named NAT networks</h3></div></div></div><p>VirtualBox <a id="id62" class="indexterm"/>has the option to let you define your own networks for further reference or reuse. Configure them under <span class="strong"><strong>Preferences</strong></span> | <span class="strong"><strong>Network</strong></span> | <span class="strong"><strong>NAT Networks</strong></span>. Luckily, Vagrant can work with those named NAT networks too. To test the feature, you can create in VirtualBox a network (like iac-lab) and assign it the network <code class="literal">192.168.50.0/24</code>.</p><p>Just change the network configuration from the preceding Vagrantfile to launch the VMs in this specific network:</p><div class="informalexample"><pre class="programlisting">config.vm.network "private_network", ip: lan_ip, virtualbox__intnet: <span class="strong"><strong>"iac-lab"</strong></span>
</pre></div></div></div></div>
<div class="section" title="Simulating a networked three-tier architecture app with Vagrant"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec21"/>Simulating a networked three-tier architecture app with Vagrant</h1></div></div></div><p>Vagrant <a id="id63" class="indexterm"/>is a great tool to help simulate systems in isolated networks, allowing us to easily mock architectures found in production. The idea behind the multiple tiers is to separate the logic and execution of the various elements of the application, and not centralize everything in one place. A common pattern is to get a first layer that gets the common user requests, a second layer that does the application job, and a third layer that stores and retrieves data, usually from a database.</p><p>In this simulation, we'll have the traditional three tiers, each running CentOS 7 virtual machines on their own isolated network:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Front</strong></span>: NGINX reverse proxy</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>App</strong></span>: a Node.js app running on two nodes</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Database</strong></span>: Redis</li></ul></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Virtual Machine Name</p>
</th><th style="text-align: left" valign="bottom">
<p>front_lan IP</p>
</th><th style="text-align: left" valign="bottom">
<p>app_lan IP</p>
</th><th style="text-align: left" valign="bottom">
<p>db_lan IP</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>front-1</p>
</td><td style="text-align: left" valign="top">
<p>10.10.0.11/24</p>
</td><td style="text-align: left" valign="top">
<p>10.20.0.101/24</p>
</td><td style="text-align: left" valign="top">
<p>N/A</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>app-1</p>
</td><td style="text-align: left" valign="top">
<p>N/A</p>
</td><td style="text-align: left" valign="top">
<p>10.20.0.11/24</p>
</td><td style="text-align: left" valign="top">
<p>10.30.0.101/24</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>app-2</p>
</td><td style="text-align: left" valign="top">
<p>N/A</p>
</td><td style="text-align: left" valign="top">
<p>10.20.0.12/24</p>
</td><td style="text-align: left" valign="top">
<p>10/30.0.102/24</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>db-1</p>
</td><td style="text-align: left" valign="top">
<p>N/A</p>
</td><td style="text-align: left" valign="top">
<p>N/A</p>
</td><td style="text-align: left" valign="top">
<p>10.30.0.11/24</p>
</td></tr></tbody></table></div><p>You will access the reverse proxy (NGINX), which alone can contact the application server (Node.js), which is the only one to be able to connect to the database.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec48"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Vagrant installation</li><li class="listitem" style="list-style-type: disc">A working VirtualBox installation</li><li class="listitem" style="list-style-type: disc">An Internet connection</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec49"/>How to do it…</h2></div></div></div><p>Follow <a id="id64" class="indexterm"/>these steps for simulating a networked three-tier architecture app with Vagrant.</p><div class="section" title="Tier 3 – the database"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec12"/>Tier 3 – the database</h3></div></div></div><p>The <a id="id65" class="indexterm"/>database lives in a db_lan private network with the IP 10.30.0.11/24.</p><p>This application will use a simple Redis installation. Installing and configuring Redis is beyond the scope of this book, so we'll keep it as simple as possible (install it, configure it to listen on the LAN port instead of 127.0.0.1, and start it):</p><div class="informalexample"><pre class="programlisting">  config.vm.define "db-1" do |config|
    config.vm.hostname = "db-1"
    config.vm.network "private_network", ip: "10.30.0.11", virtualbox__intnet: "db_lan"
    config.vm.provision :shell, :inline =&gt; "sudo yum install -q -y epel-release"
    config.vm.provision :shell, :inline =&gt; "sudo yum install -q -y redis"
    config.vm.provision :shell, :inline =&gt; "sudo sed -i 's/bind 127.0.0.1/bind 127.0.0.1 10.30.0.11/' /etc/redis.conf"
    config.vm.provision :shell, :inline =&gt; "sudo systemctl enable redis"
    config.vm.provision :shell, :inline =&gt; "sudo systemctl start redis"
  end</pre></div></div><div class="section" title="Tier 2: the application servers"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec13"/>Tier 2: the application servers</h3></div></div></div><p>This tier <a id="id66" class="indexterm"/>is where our application lives, backed by an application (web) server. The application can connect to the database tier, and will be available to the end user through tier 1 proxy servers. This is usually where all the logic is done (by the application).</p><div class="section" title="The Node.js application"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl4sec01"/>The Node.js application</h4></div></div></div><p>This will <a id="id67" class="indexterm"/>be simulated with the simplest Node.js code I could produce to demonstrate the usage, displaying the server hostname (the filename is <code class="literal">app.js</code>).</p><p>First, it creates a connection to the Redis server on the <code class="literal">db_lan</code> network:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env node
var os = require("os");
var redis = require('redis');
var client = redis.createClient(6379, '10.30.0.11');
client.on('connect', function() {
    console.log('connected to redis on '+os.hostname()+' 10.30.0.11:6379');
});</pre></div><p>Then if it goes well, it creates an HTTP server listening on <code class="literal">:8080</code>, displaying the server's hostname:</p><div class="informalexample"><pre class="programlisting">var http = require('http');
http.createServer(function (req, res) {
  res.writeHead(200, {'Content-Type': 'text/plain'});
  res.end('Running on '+os.hostname()+'\n');
}).listen(8080);
console.log('HTTP server listening on :8080');</pre></div><p>Start the app, the simplest of the <code class="literal">systemd</code> service file (<code class="literal">systemd</code> unit files are out of the scope of this book):</p><div class="informalexample"><pre class="programlisting">[Unit]
Description=Node App
After=network.target

[Service]
ExecStart=/srv/nodeapp/app.js
Restart=always
User=vagrant
Group=vagrant
Environment=PATH=/usr/bin
Environment=NODE_ENV=production
WorkingDirectory=/srv/nodeapp
[Install]
WantedBy=multi-user.target</pre></div><p>Let's iterate <a id="id68" class="indexterm"/>through the deployment of a number of application servers (in this case: two) to serve the app. Once again, deploying Node.js applications is out of the scope of this book, so I kept it as simple as possible—simple directories and permissions creation and systemd unit deployment. In production, this would probably be done through a configuration management tool such as Chef or Ansible and maybe coupled with a proper deployment tool:</p><div class="informalexample"><pre class="programlisting"># Tier 2: a scalable number of application servers
vm_app_num = 2
  (1..vm_app_num).each do |n|
    app_lan_ip = "10.20.0.#{n+10}"
    db_lan_ip = "10.30.0.#{n+100}"
    config.vm.define "app-#{n}" do |config|
      config.vm.hostname = "app-#{n}"
      config.vm.network "private_network", ip: app_lan_ip, virtualbox__intnet: "app_lan"
      config.vm.network "private_network", ip: db_lan_ip, virtualbox__intnet: "db_lan"
      config.vm.provision :shell, :inline =&gt; "sudo yum install -q -y epel-release"
      config.vm.provision :shell, :inline =&gt; "sudo yum install -q -y nodejs npm"
      config.vm.provision :shell, :inline =&gt; "sudo mkdir /srv/nodeapp"
      config.vm.provision :shell, :inline =&gt; "sudo cp /vagrant/app.js /src/nodeapp"
      config.vm.provision :shell, :inline =&gt; "sudo chown -R vagrant.vagrant /srv/"
      config.vm.provision :shell, :inline =&gt; "sudo chmod +x /srv/nodeapp/app.js"
      config.vm.provision :shell, :inline =&gt; "cd /srv/nodeapp; npm install redis"
      config.vm.provision :shell, :inline =&gt; "sudo cp /vagrant/nodeapp.service /etc/systemd/system"
      config.vm.provision :shell, :inline =&gt; "sudo systemctl daemon-reload"
      config.vm.provision :shell, :inline =&gt; "sudo systemctl start nodeapp"
    end
  end</pre></div></div></div><div class="section" title="Tier 1: the NGINX reverse proxy"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec14"/>Tier 1: the NGINX reverse proxy</h3></div></div></div><p>Tier 1 is <a id="id69" class="indexterm"/>represented here by an NGINX reverse proxy configuration on CentOS 7, as simple as it could be for this demo. Configuring an NGINX reverse proxy with a pool of servers is out of the scope of this book:</p><div class="informalexample"><pre class="programlisting">events {
  worker_connections 1024;
}
http {
  upstream app {
    server 10.20.0.11:8080 max_fails=1 fail_timeout=1s;
    server 10.20.0.12:8080 max_fails=1 fail_timeout=1s;
  }
  server {
    listen 80;
    server_name  _;
    location / {
      proxy_set_header   X-Real-IP $remote_addr;
      proxy_set_header   Host      $http_host;
      proxy_pass         http://app;
    }
  }
}</pre></div><p>Now let's <a id="id70" class="indexterm"/>create the reverse proxy VM that will serve <code class="literal">http://localhost:8080</code> through the pool of application servers. This VM listens on 10.10.0.11/24 on its own LAN (<code class="literal">front_lan</code>), and on <code class="literal">10.20.0.101</code>/<code class="literal">24</code> on the application servers' LAN (<code class="literal">app_lan</code>):</p><div class="informalexample"><pre class="programlisting">  # Tier 1: an NGINX reverse proxy VM, available on http://localhost:8080
  config.vm.define "front-1" do |config|
    config.vm.hostname = "front-1"
    config.vm.network "private_network", ip: "10.10.0.11", virtualbox__intnet: "front_lan"
    config.vm.network "private_network", ip: "10.20.0.101", virtualbox__intnet: "app_lan"
    config.vm.network "forwarded_port", guest: 80, host: 8080
    config.vm.provision :shell, :inline =&gt; "sudo yum install -q -y epel-release"
    config.vm.provision :shell, :inline =&gt; "sudo yum install -q -y nginx"
    config.vm.provision :shell, :inline =&gt; "sudo cp /vagrant/nginx.conf /etc/nginx/nginx.conf"
    config.vm.provision :shell, :inline =&gt; "sudo systemctl enable nginx"
    config.vm.provision :shell, :inline =&gt; "sudo systemctl start nginx"
  end</pre></div><p>Start this up (<code class="literal">vagrant up</code>) and navigate to <code class="literal">http://localhost:8080</code>, where the app displays the application server hostname so you can confirm that the load balancing across networks is working (while application servers can talk to the Redis backend).</p></div></div></div>
<div class="section" title="Showing your work on the LAN while working with Laravel"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec22"/>Showing your work on the LAN while working with Laravel</h1></div></div></div><p>You're <a id="id71" class="indexterm"/>working on your application using Laravel, the free and open source PHP framework (https://laravel.com/), and you'd like to showcase your work to your colleagues. Using a Vagrant development environment can help keep your work machine clean and allow you to use your usual tools and editors while using an infrastructure close to production.</p><p>In this example, we'll deploy a CentOS 7 server, with NGINX, PHP-FPM, and MariaDB, all the PHP dependencies, and install Composer. You can build from this example and others in this book to create an environment that mimics production (three-tier, multiple machines, and other characteristics).</p><p>This environment will be available for access to all your coworkers on your network, and the code will be accessible to you locally.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec50"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Vagrant installation</li><li class="listitem" style="list-style-type: disc">A working VirtualBox or VMware installation</li><li class="listitem" style="list-style-type: disc">An Internet connection</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec51"/>How to do it…</h2></div></div></div><p>Let's <a id="id72" class="indexterm"/>start with the simplest Vagrant environment we know:</p><div class="informalexample"><pre class="programlisting">Vagrant.configure("2") do |config|
  config.vm.box = "bento/centos-7.2"
  config.vm.define "srv-1" do |config|
    config.vm.hostname = "srv-1"
  end
end</pre></div><div class="section" title="A sample NGINX configuration for Laravel"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec15"/>A sample NGINX configuration for Laravel</h3></div></div></div><p>Configuring <a id="id73" class="indexterm"/>NGINX for Laravel is out of the scope for this book, but for reference, here's a simple NGINX configuration that will work well for us, listening on HTTP, serving files located on <code class="literal">/srv/app/public</code>, and using PHP-FPM (the file name is <code class="literal">nginx.conf</code>):</p><div class="informalexample"><pre class="programlisting">events {
  worker_connections 1024;
}
http {
  sendfile off;
  server {
    listen 80;
    server_name  _;
    root /srv/app/public ;
    try_files $uri $uri/ /index.php?q=$uri&amp;$args;
    index index.php;
    location / {
      try_files $uri $uri/ /index.php?$query_string;
    }
    location ~ \.php$ {
      try_files $uri /index.php =404;
      fastcgi_split_path_info ^(.+\.php)(/.+)$;
      fastcgi_pass 127.0.0.1:9000;
      fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
      fastcgi_param PATH_INFO $fastcgi_script_name;
      include fastcgi_params;
    }
  }
}</pre></div></div><div class="section" title="Simple shell provisioning"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec16"/>Simple shell provisioning</h3></div></div></div><p>We'll create <a id="id74" class="indexterm"/>a provisioning script that we'll name as <code class="literal">provision.sh</code>, which contains all the steps we need to have a fully working Laravel environment. The details are out of the scope of this book, but here are the steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We want <span class="strong"><strong>Extra Packages for Enterprise Linux</strong></span> (<span class="strong"><strong>EPEL</strong></span>):<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo yum install -q -y epel-release</strong></span>
</pre></div></li><li class="listitem">We want PHP-FPM:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo yum install -q -y php-fpm</strong></span>
</pre></div></li><li class="listitem">We want PHP-FPM to run as the Vagrant user so we have the rights:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo sed -i 's/user = apache/user = vagrant/' /etc/php-fpm.d/www.conf</strong></span>
</pre></div></li><li class="listitem">Install a bunch of PHP dependencies:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo yum install -q -y php-pdo php-mcrypt php-mysql php-cli php-mbstring php-dom</strong></span>
</pre></div></li><li class="listitem">Install Composer:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>curl -sS https://getcomposer.org/installer | php</strong></span>
<span class="strong"><strong>sudo mv composer.phar /usr/local/bin/composer</strong></span>
<span class="strong"><strong>sudo chmod +x /usr/local/bin/composer</strong></span>
</pre></div></li><li class="listitem">Install and ship a good enough NGINX configuration:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo yum install -q -y nginx</strong></span>
<span class="strong"><strong>sudo cp /vagrant/nginx.conf /etc/nginx/nginx.conf</strong></span>
</pre></div></li><li class="listitem">Install MariaDB Server:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo yum install -q -y mariadb-server</strong></span>
</pre></div></li><li class="listitem">Start all the services:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo systemctl enable php-fpm</strong></span>
<span class="strong"><strong>sudo systemctl start php-fpm</strong></span>
<span class="strong"><strong>sudo systemctl enable nginx</strong></span>
<span class="strong"><strong>sudo systemctl start nginx</strong></span>
<span class="strong"><strong>sudo systemctl enable mariadb</strong></span>
<span class="strong"><strong>sudo systemctl start mariadb</strong></span>
</pre></div></li></ol></div></div><div class="section" title="Enable provisioning"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec17"/>Enable provisioning</h3></div></div></div><p>To enable <a id="id75" class="indexterm"/>provisioning using our script, add the following code in the VM definition block:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>config.vm.provision :shell, :path =&gt; "provision.sh"</strong></span>
</pre></div></div><div class="section" title="Shared folder"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec18"/>Shared folder</h3></div></div></div><p>To <a id="id76" class="indexterm"/>share the <code class="literal">src</code> folder between your host and the Vagrant VM under <code class="literal">/srv/app</code>, you can add the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>config.vm.synced_folder "src/", "/srv/app"</strong></span>
</pre></div></div><div class="section" title="Public LAN Networking"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec19"/>Public LAN Networking</h3></div></div></div><p>The last <a id="id77" class="indexterm"/>thing we need to do now is to add a network interface to our Vagrant virtual machine, that will be on the real LAN, so our coworkers will access it easily through the network:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>config.vm.network "public_network", bridge: "en0: Wi-Fi (AirPort)"</strong></span>
</pre></div><p>Adapt the name of your network adapter to use (this was on a Mac, as you can guess) to your needs. Another solution is not to specify any adapter name, so you will be presented a list of possible adapters to bridge:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>==&gt; srv-1: Available bridged network interfaces:</strong></span>
<span class="strong"><strong>1) en0: Wi-Fi (AirPort)</strong></span>
<span class="strong"><strong>[...]</strong></span>
</pre></div><p>Start the Vagrant environment (<code class="literal">vagrant up</code>), and when it's available, you can execute commands such as finding out the network information: <code class="literal">vagrant ssh -c "ip addr"</code>. Your mileage will vary, but in this network, the public IP of this Vagrant box is <code class="literal">192.168.1.106</code>, so our work is available.</p><p>Now you can start coding in the <code class="literal">./src/</code> folder. This is not a Laravel book, but a way to create a new project in a clean directory is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cd /srv/app</strong></span>
<span class="strong"><strong>composer create-project --prefer-dist laravel/laravel.</strong></span>
</pre></div><p>Don't forget to remove all files from the folder beforehand. Navigate to <code class="literal">http://local-ip/</code> and you'll see the default Laravel welcome screen.</p><p>To verify <a id="id78" class="indexterm"/>the file sharing sync is working correctly, edit the <code class="literal">./resources/views/welcome.blade.php</code> file and reload your browser to see the change reflected.</p></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec52"/>There's more…</h2></div></div></div><p>If you <a id="id79" class="indexterm"/>include the Vagrantfile directly with your project's code, coworkers or contributors will only have to run <code class="literal">vagrant up</code> to see it running.</p><p>Other Vagrantfile sharing options include Windows Sharing (smb), rsync (useful with remote virtual machines such as on AWS EC2), and even NFS.</p><p>A noticeable bug in the sharing feature using VirtualBox leads to corrupted or non-updating files. The workaround is to deactivate in the web server configuration <code class="literal">sendfile</code>, using NGINX:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sendfile off;</strong></span>
</pre></div><p>Using Apache, it is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>EnableSendfile Off</strong></span>
</pre></div></div></div>
<div class="section" title="Sharing access to your Vagrant environment with the world"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec23"/>Sharing access to your Vagrant environment with the world</h1></div></div></div><p>You're <a id="id80" class="indexterm"/>working on your project with your local Vagrant environment, and you'd like to show the status of the job to your customer who's located in another city. Maybe you have an issue configuring something and you'd like some remote help from your coworker on the other side of the planet. Alternatively, maybe you'd like to access your work Vagrant box from home, hotel, or coworking space? There's a neat Vagrant sharing feature we'll use here, working with a Ghost blog on CentOS 7.2.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec53"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Vagrant installation</li><li class="listitem" style="list-style-type: disc">A working VirtualBox installation</li><li class="listitem" style="list-style-type: disc">A free <a id="id81" class="indexterm"/>HashiCorp Atlas account (<a class="ulink" href="https://atlas.hashicorp.com/account/new">https://atlas.hashicorp.com/account/new</a>)</li><li class="listitem" style="list-style-type: disc">An Internet connection</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec54"/>How to do it…</h2></div></div></div><p>Let's start with this simple Vagrantfile:</p><div class="informalexample"><pre class="programlisting">Vagrant.configure("2") do |config|
  config.vm.box = "bento/centos-7.2"
  config.vm.define "blog" do |config|
    config.vm.hostname = "blog"
  end
end</pre></div><p>We know <a id="id82" class="indexterm"/>we'll have to install some packages, so let's add a provisioning script to be executed:</p><div class="informalexample"><pre class="programlisting">    config.vm.provision :shell, :path =&gt; "provision.sh"</pre></div><p>We'll want to hack locally on our Ghost blog, such as adding themes and more, so let's sync our <code class="literal">src/</code> folder to the remote <code class="literal">/srv/blog</code> folder:</p><div class="informalexample"><pre class="programlisting">    config.vm.synced_folder "src/", "/srv/blog"</pre></div><p>We want a local private network so we can access the virtual machine, with the <code class="literal">2368</code> TCP port (Ghost default) redirected to our host <code class="literal">8080</code> HTTP port:</p><div class="informalexample"><pre class="programlisting">    config.vm.network "private_network", type: "dhcp"
    config.vm.network "forwarded_port", guest: 2368, host: 8080</pre></div><div class="section" title="Provisioning"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec20"/>Provisioning</h3></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To configure <a id="id83" class="indexterm"/>our new box, we'll first need to enable EPEL:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo yum install -q -y epel-release</strong></span>
</pre></div></li><li class="listitem">Then install the requirements, <code class="literal">node</code>, <code class="literal">npm</code>, and <code class="literal">unzip</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo yum install -q -y node npm unzip </strong></span>
</pre></div></li><li class="listitem">Download the latest Ghost version:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>curl -L https://ghost.org/zip/ghost-latest.zip -o ghost.zip</strong></span>
</pre></div></li><li class="listitem">Uncompress it in the <code class="literal">/srv/blog</code> folder:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo unzip -uo ghost.zip -d /srv/blog/</strong></span>
</pre></div></li><li class="listitem">Install the Ghost dependencies:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cd /srv/blog &amp;&amp; sudo npm install --production</strong></span>
</pre></div></li></ol></div><p>Put all those commands in the <code class="literal">provisioning.sh</code> script and we're good to go: <code class="literal">vagrant up</code>.</p></div><div class="section" title="Starting Ghost engine"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec21"/>Starting Ghost engine</h3></div></div></div><p>As you <a id="id84" class="indexterm"/>would do normally, log in to your Vagrant box to launch the node server:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>vagrant ssh</strong></span>
<span class="strong"><strong>cd /srv/blog &amp;&amp; sudo npm start --production</strong></span>
<span class="strong"><strong>[…]</strong></span>
<span class="strong"><strong>Ghost is running in production...</strong></span>
<span class="strong"><strong>Your blog is now available on http://my-ghost-blog.com</strong></span>
<span class="strong"><strong>Ctrl+C to shut down</strong></span>
</pre></div><p>Change the host IP from <code class="literal">127.0.0.1</code> to <code class="literal">0.0.0.0</code> in the generated <code class="literal">config.js</code> file so the server listens on all interfaces:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>server: {</strong></span>
<span class="strong"><strong>            host: '0.0.0.0',</strong></span>
<span class="strong"><strong>            port: '2368'</strong></span>
<span class="strong"><strong>        }</strong></span>
</pre></div><p>Restart the node server:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cd /srv/blog &amp;&amp; sudo npm start --production</strong></span>
</pre></div><p>You now have a direct access to the blog through your box LAN IP (adapt the IP to your case): <code class="literal">http://172.28.128.3:2368/</code>.</p></div><div class="section" title="Sharing access"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec22"/>Sharing access</h3></div></div></div><p>Now you <a id="id85" class="indexterm"/>can access your application locally through your Vagrant box, let's give access to it to others through the Internet using <code class="literal">vagrant share</code>:</p><div class="section" title="HTTP"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl4sec02"/>HTTP</h4></div></div></div><p>The default <a id="id86" class="indexterm"/>is to share through HTTP, so your work is available through a web browser:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vagrant share</strong></span>
<span class="strong"><strong>==&gt; srv-1: Detecting network information for machine...</strong></span>
<span class="strong"><strong>[...]</strong></span>
<span class="strong"><strong>==&gt; srv-1: Your Vagrant Share is running! Name: anxious-cougar-6317</strong></span>
<span class="strong"><strong>==&gt; srv-1: URL: http://anxious-cougar-6317.vagrantshare.com</strong></span>
</pre></div><p>This URL is the one you can give to anyone to access publicly your work: Vagrant servers being used as proxy.</p></div></div><div class="section" title="SSH"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec23"/>SSH</h3></div></div></div><p>Another <a id="id87" class="indexterm"/>possible sharing option is by SSH (deactivated by default). The program will ask you for a password you'll need to connect to the box remotely:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vagrant share --ssh</strong></span>
<span class="strong"><strong>==&gt; srv-1: Detecting network information for machine...</strong></span>
<span class="strong"><strong>[...]</strong></span>
<span class="strong"><strong>srv-1: Please enter a password to encrypt the key:</strong></span>
<span class="strong"><strong>    srv-1: Repeat the password to confirm:</strong></span>
<span class="strong"><strong>[...]</strong></span>
<span class="strong"><strong>==&gt; srv-1: You're sharing with SSH access. This means that another user</strong></span>
<span class="strong"><strong>==&gt; srv-1: simply has to run `vagrant connect --ssh subtle-platypus-4976`</strong></span>
<span class="strong"><strong>==&gt; srv-1: to SSH to your Vagrant machine.</strong></span>
<span class="strong"><strong>[...]</strong></span>
</pre></div><p>Now, at home or at the coworking space, you can simply connect to your work Vagrant box (if needed, the default Vagrant password is vagrant):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vagrant connect --ssh subtle-platypus-4976</strong></span>
<span class="strong"><strong>Loading share 'subtle-platypus-4976'...</strong></span>
<span class="strong"><strong>[...]</strong></span>
<span class="strong"><strong>[vagrant@srv-1 ~]$ head -n1 /srv/blog/config.js</strong></span>
<span class="strong"><strong>// # Ghost Configuration</strong></span>
</pre></div><p>You or your coworker are now remotely logged into your own Vagrant box over the Internet!</p></div></div></div>
<div class="section" title="Simulating Chef upgrades using Vagrant"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec24"/>Simulating Chef upgrades using Vagrant</h1></div></div></div><p>Wouldn't it <a id="id88" class="indexterm"/>be awesome to simulate <a id="id89" class="indexterm"/>production changes quickly? Chances are you're using Chef in production. We'll see how to use both Chef cookbooks with Vagrant, as well as how to simulate Chef version upgrades between environments. This kind of setup is the beginning of a good combination of infrastructure as code.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec55"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Vagrant installation</li><li class="listitem" style="list-style-type: disc">A working VirtualBox installation</li><li class="listitem" style="list-style-type: disc">An Internet connection</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec56"/>How to do it…</h2></div></div></div><p>Let's <a id="id90" class="indexterm"/>start with a minimal virtual <a id="id91" class="indexterm"/>machine named <code class="literal">prod</code> that simply boots a CentOS 7.2, like we have in our production environment:</p><div class="informalexample"><pre class="programlisting">Vagrant.configure("2") do |config|
  config.vm.box = "bento/centos-7.2"
  config.vm.define "prod" do |config|
    config.vm.hostname = "prod"
    config.vm.network "private_network", type: "dhcp"
  end

end</pre></div><div class="section" title="Vagrant Omnibus Chef plugin"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec24"/>Vagrant Omnibus Chef plugin</h3></div></div></div><p>Now, if we <a id="id92" class="indexterm"/>want to use Chef code, if we want to use Chef code (Ruby files organized in directories that form a unit called a 'cookbook' that configure and maintain a specific area of a system), we first need to install Chef on the Vagrant box. There're many ways to do this, from provisioning shell scripts to using boxes with Chef already installed. A clean, reliable, and repeatable way is to use a Vagrant plugin to do just that—vagrant-omnibus. Omnibus is a packaged Chef. Install it like any other Vagrant plugin:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vagrant plugin install vagrant-omnibus</strong></span>
<span class="strong"><strong>Installing the 'vagrant-omnibus' plugin. This can take a few minutes...</strong></span>
<span class="strong"><strong>Installed the plugin 'vagrant-omnibus (1.4.1)'!</strong></span>
</pre></div><p>Then, just add the following configuration in your VM definition of the Vagrantfile and you'll always have the latest Chef version installed on this box:</p><div class="informalexample"><pre class="programlisting">config.omnibus.chef_version = :latest</pre></div><p>However, our goal is to mimic production, maybe we're still using the latest in v11.x series of Chef instead of the latest 12.x, so instead let's specify exactly which version we want:</p><div class="informalexample"><pre class="programlisting">config.omnibus.chef_version = "11.18.12"</pre></div><p>Now that we're using a new plugin, our Vagrantfile won't work out of the box for everybody. Users will have to install this vagrant-omnibus plugin. If you care about consistency and repeatability, an option is to add the following Ruby check at the beginning of your Vagrantfile:</p><div class="informalexample"><pre class="programlisting">%w(vagrant-vbguest vagrant-omnibus).each do |plugin|
  unless Vagrant.has_plugin?(plugin)
    raise "#{plugin} plugin is not installed! Please install it using `vagrant plugin install #{plugin}`"
  end
end</pre></div><p>This <a id="id93" class="indexterm"/>code snippet will simply iterate over each plugin name to verify that Vagrant returns them as <span class="emphasis"><em>installed</em></span>. If not, stop there and return a helpful exit message on how to install the required plugins.</p></div><div class="section" title="A sample Chef recipe"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec25"/>A sample Chef recipe</h3></div></div></div><p>This part <a id="id94" class="indexterm"/>of the book isn't about writing Chef recipes (read more about it later in the book!), so we'll keep that part simple. Our objective is to install the Apache 2 web server on CentOS 7 (<code class="literal">httpd</code> package), and start it. Here's what our sample recipe looks like (<code class="literal">cookbooks/apache2/recipes/default.rb</code>); it does exactly what it says in plain English:</p><div class="informalexample"><pre class="programlisting">package "httpd"

service "httpd" do
  action [ :enable, :start ]
end</pre></div></div><div class="section" title="Vagrant and Chef integration"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec26"/>Vagrant and Chef integration</h3></div></div></div><p>Here's how, in our VM definition block, we'll tell Vagrant to work with Chef Solo (a way of running Chef in standalone mode, without the need of a Chef server) to provision <a id="id95" class="indexterm"/>our box:</p><div class="informalexample"><pre class="programlisting">    config.vm.provision :chef_solo do |chef|
      chef.add_recipe 'apache2'
    end</pre></div><p>As simple <a id="id96" class="indexterm"/>as that. Vagrant this up (<code class="literal">vagrant up</code>), and you'll end up with a fully provisioned VM, using the old 11.18.12 version, and a running Apache 2 web server.</p><p>Our manual tests can include checking that the chef-solo version is the one we requested:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ chef-solo --version</strong></span>
<span class="strong"><strong>Chef: 11.18.12</strong></span>
</pre></div><p>They can also check if we have <code class="literal">httpd</code> installed:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ httpd -v</strong></span>
<span class="strong"><strong>Server version: Apache/2.4.6 (CentOS)</strong></span>
</pre></div><p>Also, we can check if <code class="literal">httpd</code> is running:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ pidof httpd</strong></span>
<span class="strong"><strong>13029 13028 13027 13026 13025 13024</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>Various other options than chef-solo exist, such as chef-client and chef-zero.</p></div></div></div><div class="section" title="Testing the Chef version update"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec27"/>Testing the Chef version update</h3></div></div></div><p>So we <a id="id97" class="indexterm"/>simulated our production environment locally, with the same CentOS version, the apache2 cookbook used in production, and the old Chef version 11. Our next task is to test if everything is still running smoothly after an upgrade to the new version 12. Let's create a second "staging" VM, very similar to our production setup, except we want to install the current latest Chef version (12.13.37 at the time of writing, feel free to use <code class="literal">:latest </code>instead):</p><div class="informalexample"><pre class="programlisting">  config.vm.define "staging" do |config|
    config.vm.hostname = "staging"
    config.omnibus.chef_version = "12.13.37"
    config.vm.network "private_network", type: "dhcp"
    config.vm.provision :chef_solo do |chef|
      chef.add_recipe 'apache2'
    end
  end</pre></div><p>Launch this new machine (<code class="literal">vagrant up staging</code>) and we'll see if our setup still works with the new major Chef version:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vagrant ssh staging</strong></span>
<span class="strong"><strong>$ chef-solo --version</strong></span>
<span class="strong"><strong>Chef: 12.13.37</strong></span>
<span class="strong"><strong>$ httpd -v</strong></span>
<span class="strong"><strong>Server version: Apache/2.4.6 (CentOS)</strong></span>
<span class="strong"><strong>$ pidof httpd</strong></span>
<span class="strong"><strong>13029 13028 13027 13026 13025 13024</strong></span>
</pre></div><p>So we can safely assume, as far as our testing goes, that the newest Chef version still works correctly with our production Chef code.</p></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec57"/>There's more…</h2></div></div></div><p>Here <a id="id98" class="indexterm"/>are more ways of controlling <a id="id99" class="indexterm"/>a Vagrant environment, and use even better Chef tooling inside it.</p><div class="section" title="Controlling default Vagrant VMs"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec28"/>Controlling default Vagrant VMs</h3></div></div></div><p>You may <a id="id100" class="indexterm"/>not always want to boot both production and staging vagrant virtual machines, especially when you just want to work on the default production setup. To specify a default VM:</p><div class="informalexample"><pre class="programlisting">config.vm.define "prod", <span class="strong"><strong>primary: true</strong></span> do |config|
  […]
end</pre></div><p>To not <a id="id101" class="indexterm"/>start automatically a VM when issuing the <code class="literal">vagrant up</code> command:</p><div class="informalexample"><pre class="programlisting">config.vm.define "staging", <span class="strong"><strong>autostart: false</strong></span> do |config|
  […]
end</pre></div></div><div class="section" title="Berkshelf and Vagrant"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec29"/>Berkshelf and Vagrant</h3></div></div></div><p>Chances <a id="id102" class="indexterm"/>are, if your production environment is using Chef, you're also using Berkshelf for dependency management and not 100% local cookbooks (if you aren't, you should!).</p><p>Vagrant <a id="id103" class="indexterm"/>work pretty well with a Berkshelf enabled <a id="id104" class="indexterm"/>Chef environment, using the <code class="literal">vagrant-berkshelf</code> plugin.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>Your workstation will need the Chef Development Kit (Chef DK: <a class="ulink" href="https://downloads.chef.io/chef-dk/">https://downloads.chef.io/chef-dk/</a>) for this to work correctly.</p></div></div></div><div class="section" title="Testing with Test Kitchen"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec30"/>Testing with Test Kitchen</h3></div></div></div><p>This <a id="id105" class="indexterm"/>setup is in fact so close to what's used to make infrastructure code testing that you'll see a lot of similarities in the dedicated section of this book.</p></div></div></div>
<div class="section" title="Using Ansible with Vagrant to create a Docker host"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec25"/>Using Ansible with Vagrant to create a Docker host</h1></div></div></div><p>Ansible (<a class="ulink" href="https://www.ansible.com/">https://www.ansible.com/</a>) <a id="id106" class="indexterm"/>is a very simple and powerful <a id="id107" class="indexterm"/>open source automation tool. While using and creating Ansible <span class="emphasis"><em>playbooks</em></span> is off-topic for this book, we'll use <a id="id108" class="indexterm"/>a very simple <span class="emphasis"><em>playbook</em></span> to install and configure Docker on a CentOS 7 box. Starting from here, you'll be able to iterate through more complex Ansible playbooks.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec58"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Vagrant installation</li><li class="listitem" style="list-style-type: disc">A working hypervisor</li><li class="listitem" style="list-style-type: disc">A working Ansible installation on your machine (an easy way is to <code class="literal">$ pip install ansible</code> or to pick your usual package manager like APT or YUM/DNF)</li><li class="listitem" style="list-style-type: disc">An Internet connection</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec59"/>How to do it…</h2></div></div></div><p>Because <a id="id109" class="indexterm"/>writing complex Ansible <a id="id110" class="indexterm"/>playbooks is out of the scope <a id="id111" class="indexterm"/>of this book, we'll use a very simple one, so you can learn more about Ansible later and still reuse this recipe.</p><div class="section" title="A simple Ansible Docker playbook for Vagrant"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec31"/>A simple Ansible Docker playbook for Vagrant</h3></div></div></div><p>Our <a id="id112" class="indexterm"/>playbook file (<code class="literal">playbook.yml</code>) is a plain YAML file, and we'll do the following in this order:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Install EPEL.</li><li class="listitem">Create a Docker Unix group.</li><li class="listitem">Add the default Vagrant user to the new Docker group.</li><li class="listitem">Install Docker from CentOS repositories.</li><li class="listitem">Enable and start Docker Engine.</li></ol></div><p>Here's how the <code class="literal">playbook.yml</code> file looks:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>---</strong></span>
<span class="strong"><strong>- hosts: all</strong></span>
<span class="strong"><strong>  become: yes</strong></span>
<span class="strong"><strong>  tasks:</strong></span>
<span class="strong"><strong>    - name: Enable EPEL</strong></span>
<span class="strong"><strong>      yum: name=epel-release state=present</strong></span>
<span class="strong"><strong>    - name: Create a Docker group</strong></span>
<span class="strong"><strong>      group: name=docker state=present</strong></span>
<span class="strong"><strong>    - name: Add the vagrant user to Docker group</strong></span>
<span class="strong"><strong>      user: name=vagrant groups=docker append=yes</strong></span>
<span class="strong"><strong>    - name: Install Docker</strong></span>
<span class="strong"><strong>      yum: name=docker state=present</strong></span>
<span class="strong"><strong>    - name: Enable and Start Docker Daemon</strong></span>
<span class="strong"><strong>      service: name=docker state=started enabled=yes</strong></span>
</pre></div></div><div class="section" title="Apply Ansible from Vagrant"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec32"/>Apply Ansible from Vagrant</h3></div></div></div><p>To use <a id="id113" class="indexterm"/>our Ansible playbook, let's start with a simple Vagrantfile starting a CentOS 7 box:</p><div class="informalexample"><pre class="programlisting">Vagrant.configure("2") do |config|
  config.vm.box = "bento/centos-7.2"
  config.vm.define "srv-1" do |config|
    config.vm.hostname = "srv-1"
    config.vm.network "private_network", type: "dhcp"
  end
end</pre></div><p>Simply <a id="id114" class="indexterm"/>add Ansible provisioning like this to the VM definition so it will load and apply your <code class="literal">playbook.yml</code> file:</p><div class="informalexample"><pre class="programlisting">    config.vm.provision "ansible" do |ansible|
      ansible.playbook = "playbook.yml"
    end</pre></div><p>You can now run <code class="literal">vagrant up</code> and use CentOS 7 Docker Engine version right away:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vagrant ssh</strong></span>
<span class="strong"><strong>[vagrant@srv-1 ~]$ systemctl status docker</strong></span>
<span class="strong"><strong>[vagrant@srv-1 ~]$ docker --version</strong></span>
<span class="strong"><strong>Docker version 1.10.3, build d381c64-unsupported</strong></span>
<span class="strong"><strong>[vagrant@srv-1 ~]$ docker run -it --rm alpine /bin/hostname</strong></span>
<span class="strong"><strong>0f44a4d7afcd</strong></span>
</pre></div></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec60"/>There's more…</h2></div></div></div><p>What if <a id="id115" class="indexterm"/>for some reason you don't or <a id="id116" class="indexterm"/>can't have Ansible installed on your host machine? Alternatively, maybe you need a specific Ansible version on your <a id="id117" class="indexterm"/>Vagrant box to mimic production and you don't want to mess with your local Ansible installation. There's an interesting variant Ansible provider you can use: it will either use Ansible directly from the guest VM, and if it's not installed, it will install it from official repositories or PIP. You can use this very simple default configuration:</p><div class="informalexample"><pre class="programlisting">    config.vm.provision <span class="strong"><strong>"ansible_local"</strong></span> do |ansible|
      ansible.playbook = "playbook.yml"
    end</pre></div><p>You can also use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vagrant up</strong></span>
<span class="strong"><strong>[…]</strong></span>
<span class="strong"><strong>==&gt; srv-1: Running provisioner: ansible_local...</strong></span>
<span class="strong"><strong>    srv-1: Installing Ansible...</strong></span>
<span class="strong"><strong>    srv-1: Running ansible-playbook...</strong></span>
<span class="strong"><strong>[…]</strong></span>
</pre></div><p>Log in to the box via SSH and check that Ansible is locally installed with the latest version:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vagrant ssh</strong></span>
<span class="strong"><strong>$ ansible --version</strong></span>
<span class="strong"><strong>ansible 2.1.1.0</strong></span>
</pre></div><p>If your <a id="id118" class="indexterm"/>use case is different, you can use more precise deployment options, to be able to fix an Ansible version number <a id="id119" class="indexterm"/>using PIP (here, version 1.9.6 instead of the latest 2.x series):</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>It will take noticeably longer to start, as it needs to install many packages on the guest system.</p></div></div><div class="informalexample"><pre class="programlisting">    config.vm.provision <span class="strong"><strong>"ansible_local"</strong></span> do |ansible|
<span class="strong"><strong>      ansible.version = "1.9.6"</strong></span>
<span class="strong"><strong>      ansible.install_mode = :pip</strong></span>
      ansible.playbook = "playbook.yml"
    end</pre></div><p>You <a id="id120" class="indexterm"/>can also use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vagrant up</strong></span>
<span class="strong"><strong>[…]</strong></span>
<span class="strong"><strong>==&gt; srv-1: Running provisioner: ansible_local...</strong></span>
<span class="strong"><strong>    srv-1: Installing Ansible...</strong></span>
<span class="strong"><strong>    srv-1: Installing pip... (for Ansible installation)</strong></span>
<span class="strong"><strong>    srv-1: Running ansible-playbook...</strong></span>
</pre></div><p>Inside the Vagrant guest, you can now check for the PIP and Ansible versions:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ pip --version</strong></span>
<span class="strong"><strong>pip 8.1.2 from /usr/lib/python2.7/site-packages (python 2.7)</strong></span>
<span class="strong"><strong>$ ansible --version</strong></span>
<span class="strong"><strong>ansible 1.9.6</strong></span>
</pre></div><p>You can also check if our playbook has been installed correctly with the old 1.x Ansible version:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker version</strong></span>
</pre></div><p>Also check if Docker is installed, and verify now it's working as the Vagrant user:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker run -it --rm alpine ping -c2 google.com</strong></span>
<span class="strong"><strong>PING google.com (216.58.211.78): 56 data bytes</strong></span>
<span class="strong"><strong>64 bytes from 216.58.211.78: seq=0 ttl=61 time=22.078 ms</strong></span>
<span class="strong"><strong>64 bytes from 216.58.211.78: seq=1 ttl=61 time=21.061 ms</strong></span>
</pre></div></div></div>
<div class="section" title="Using Docker containers on CoreOS with Vagrant"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec26"/>Using Docker containers on CoreOS with Vagrant</h1></div></div></div><p>Vagrant <a id="id121" class="indexterm"/>can help in simulating environments, and Docker containers are not forgotten with Vagrant. We'll use one of the best platforms to run containers, the free and open source lightweight operating system CoreOS. Based on Linux, targeting easy container and clustered deployments, it also provides official Vagrant boxes. We'll deploy the official WordPress container with MariaDB on another container using the Vagrant Docker provisioner (and not the Vagrant Docker provider).</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec61"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A working Vagrant installation</li><li class="listitem" style="list-style-type: disc">A working hypervisor</li><li class="listitem" style="list-style-type: disc">An Internet connection</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec62"/>How to do it…</h2></div></div></div><p>CoreOS doesn't host its official images at the default location on Atlas, it hosts it itself. So, we have to specify the full URL to the Vagrant box in our Vagrantfile:</p><div class="informalexample"><pre class="programlisting">Vagrant.configure("2") do |config|
  config.vm.box = https://stable.release.core-os.net/amd64-usr/current/coreos_production_vagrant.box
end</pre></div><p>As CoreOS is a minimal OS, it doesn't support any of the VirtualBox guest addition tools, so we'll disable them, and don't try anything if we (most likely) have the <code class="literal">vagrant-vbguest</code> plugin:</p><div class="informalexample"><pre class="programlisting">  config.vm.provider :virtualbox do |vb|
      vb.check_guest_additions = false
      vb.functional_vboxsf     = false
  end

  if Vagrant.has_plugin?("vagrant-vbguest") then
    config.vbguest.auto_update = false
  end</pre></div><p>Let's create a new VM definition, using the CoreOS Vagrant box:</p><div class="informalexample"><pre class="programlisting">  config.vm.define "core-1" do |config|
    config.vm.hostname = "core-1"
    config.vm.network "private_network", type: "dhcp" 
  end</pre></div><p>We now need to run the <code class="literal">mariadb</code> and <code class="literal">wordpress</code> official containers from the Docker Hub. Using <a id="id122" class="indexterm"/>Docker directly, we would have run the following: </p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker run -d --name mariadb -e MYSQL_ROOT_PASSWORD=h4ckm3 mariadb</strong></span>
<span class="strong"><strong>$ docker run -d -e WORDPRESS_DB_HOST=mariadb -e 'WORDPRESS_DB_PASSWORD=h4ckm3 --link mariadb:mariadb -p 80:80 wordpress</strong></span>
</pre></div><p>Let's translate <a id="id123" class="indexterm"/>this into our Vagrantfile:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>db_root_password = "h4ckm3"</strong></span>
<span class="strong"><strong>config.vm.provision "docker" do |docker|</strong></span>
<span class="strong"><strong>      docker.run "mariadb",</strong></span>
<span class="strong"><strong>        args: "--name 'mariadb' -e 'MYSQL_ROOT_PASSWORD=#{db_root_password}'"</strong></span>
<span class="strong"><strong>      docker.run "wordpress",</strong></span>
<span class="strong"><strong>        args: "-e 'WORDPRESS_DB_HOST=mariadb' -e 'WORDPRESS_DB_PASSWORD=#{db_root_password}' --link 'mariadb:mariadb' -p '80:80'"</strong></span>
<span class="strong"><strong>    end</strong></span>
</pre></div><p>Vagrant this up (<code class="literal">$ vagrant up</code>), and you'll access a ready-to-use WordPress installation running on CoreOS:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl -IL http://172.28.128.3/wp-admin/install.php</strong></span>
<span class="strong"><strong>HTTP/1.1 200 OK</strong></span>
<span class="strong"><strong>Date: Thu, 25 Aug 2016 10:54:17 GMT</strong></span>
<span class="strong"><strong>Server: Apache/2.4.10 (Debian)</strong></span>
<span class="strong"><strong>X-Powered-By: PHP/5.6.25</strong></span>
<span class="strong"><strong>Expires: Wed, 11 Jan 1984 05:00:00 GMT</strong></span>
<span class="strong"><strong>Cache-Control: no-cache, must-revalidate, max-age=0</strong></span>
<span class="strong"><strong>Content-Type: text/html; charset=utf-8</strong></span>
</pre></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec63"/>There's more…</h2></div></div></div><p>The CoreOS <a id="id124" class="indexterm"/>team proposes a full Vagrant environment to try and manipulate a CoreOS cluster <a class="ulink" href="https://github.com/coreos/coreos-vagrant">https://github.com/coreos/coreos-vagrant</a>. You'll then be able to try all CoreOS features and configuration options for all release channels (alpha, beta, or stable).</p><p>Other operating systems such as Ubuntu or CentOS are fully supported to provision Docker containers, even if Docker isn't installed at first on the base image. Vagrant will install Docker for you, so it will work transparently and run the containers as soon as it's installed.</p></div></div></body></html>