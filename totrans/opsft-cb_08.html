<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;8.&#xA0;OpenShift for Python Developers"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08" class="calibre1"/>Chapter 8. OpenShift for Python Developers</h1></div></div></div><p class="calibre6">This chapter presents a number of recipes that will help you to get started with Python web application development on OpenShift. This chapter contains the following recipes:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Creating your first Python application</li><li class="listitem">Managing Python application dependencies</li><li class="listitem">Creating and deploying Flask web applications using Python and PostgreSQL cartridges</li><li class="listitem">Enabling hot deployment for Python applications</li><li class="listitem">Forcing a clean Python virtual environment</li><li class="listitem">Accessing an application's Python virtual environment</li><li class="listitem">Using Gevent with Python applications</li><li class="listitem">Installing a custom Python package</li><li class="listitem">Using the .htaccess file to configure Apache</li></ul></div></div>

<div class="book" title="Chapter&#xA0;8.&#xA0;OpenShift for Python Developers">
<div class="book" title="Introduction"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch08lvl1sec99" class="calibre1"/>Introduction</h1></div></div></div><p class="calibre6">Python<a id="id796" class="calibre1"/> is a general-purpose, high-level, easy-to-use, popular programming language. It is an interpreted language that emphasizes source code readability using strict indentation to determine code blocks. Python is very commonly used as a scripting language, but it is also very popular in the web application development and scientific computing world. There are various powerful web application frameworks, such as Django, Flask, Bottle, and Tornado, available to help developers build awesome web applications using the Python programming language.</p><p class="calibre6">OpenShift provides Python web developers with a hosting platform to deploy their web applications. At the time of writing this book, it supports three versions of Python—2.6, 2.7, and 3.3. You can view all the available Python versions by running the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ rhc cartridges |grep python</strong></span>
<span class="strong"><strong class="calibre7">python-2.6          Python 2.6                              web</strong></span>
<span class="strong"><strong class="calibre7">python-2.7          Python 2.7                              web</strong></span>
<span class="strong"><strong class="calibre7">python-3.3          Python 3.3                              web</strong></span>
</pre></div><p class="calibre6">The <span class="strong"><em class="calibre10">Creating your first Python application</em></span> recipe will help you take your first steps toward developing Python applications on OpenShift. OpenShift supports Apache with the <code class="email">mode_wsgi</code> HTTP server<a id="id797" class="calibre1"/> module (<a class="calibre1" href="https://code.google.com/p/modwsgi/">https://code.google.com/p/modwsgi/</a>) to run your Python web applications. Python applications can choose any of the supported versions and run within a virtualenv tool. A virtualenv tool<a id="id798" class="calibre1"/> is an isolated and private copy of your Python installation, which will be only used for that project without affecting the system's global Python installation. The <span class="strong"><em class="calibre10">Accessing an application's Python virtual environment</em></span> recipe will show you how to access the virtual environment by connecting to the application gear using SSH.</p><p class="calibre6">We will also cover various ways in which you can manage application dependencies in Python applications. You can use <code class="email">requirements.txt</code> or <code class="email">setup.py</code> or both to manage application dependencies. This will be covered in the <span class="strong"><em class="calibre10">Managing Python application dependencies</em></span> recipe.</p><p class="calibre6">The example application in this chapter will be developed using the Flask web framework and PostgreSQL database. I choose Flask because of its popularity and ease of use. You can use any other web framework, such as Bottle, web2py, and Django. The <span class="strong"><em class="calibre10">Creating and deploying Flask web applications using Python and PostgreSQL cartridges</em></span> recipe will cover step-by-step how to write Flask web applications on OpenShift. All the source code is available on the OpenShift-Cookbook GitHub organization (<a class="calibre1" href="https://github.com/OpenShift-Cookbook">https://github.com/OpenShift-Cookbook</a>).</p><p class="calibre6">It is also feasible to use a standalone WSGI server, such as Gevent or Gunicorn, with OpenShift Python applications. The <span class="strong"><em class="calibre10">Using Gevent with Python applications</em></span> recipe will cover this in detail.</p><p class="calibre6">If you want to run the examples on your local machine, please install Python, pip, and virtualenv. pip is a command-line tool to install and manage Python packages. The instructions to install Python<a id="id799" class="calibre1"/> for your operating system can be found at <a class="calibre1" href="http://docs.python-guide.org/en/latest/index.html">http://docs.python-guide.org/en/latest/index.html</a>. Instructions to install pip<a id="id800" class="calibre1"/> can be found at <a class="calibre1" href="http://pip.readthedocs.org/en/latest/installing.html">http://pip.readthedocs.org/en/latest/installing.html</a>. Finally, you can install virtualenv<a id="id801" class="calibre1"/> on your machine by following the instructions mentioned at <a class="calibre1" href="http://docs.python-guide.org/en/latest/dev/virtualenvs/">http://docs.python-guide.org/en/latest/dev/virtualenvs/</a>.</p><p class="calibre6">This chapter assumes that you are comfortable with the Python web development basics, OpenShift application basics, and how to work with OpenShift database cartridges. In case you are not comfortable with these topics, I recommend that you first read <a class="calibre1" title="Chapter 3. Creating and Managing Applications" href="part0041_split_000.html#page">Chapter 3</a>, <span class="strong"><em class="calibre10">Creating and Managing Applications</em></span>, through <a class="calibre1" title="Chapter 6. Using MongoDB and Third-party Database Cartridges with OpenShift Applications" href="part0079_split_000.html#page">Chapter 6</a>, <span class="strong"><em class="calibre10">Using MongoDB and Third-party Database Cartridges with OpenShift Applications</em></span>, before continuing with this chapter.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Creating your first Python application"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec100" class="calibre1"/>Creating your first Python application</h1></div></div></div><p class="calibre6">In this recipe, you will<a id="id802" class="calibre1"/> learn how to create an OpenShift Python application using the rhc command-line tool. We will create a Python 3.3 application and then understand the template application created by OpenShift.</p></div>

<div class="book" title="Creating your first Python application">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec390" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre6">To walk through this recipe, you will need the rhc command-line client installed on your machine. Please refer to the <span class="strong"><em class="calibre10">Installing the OpenShift rhc command-line client</em></span> recipe in <a class="calibre1" title="Chapter 1. Getting Started with OpenShift" href="part0014_split_000.html#page">Chapter 1</a>, <span class="strong"><em class="calibre10">Getting Started with OpenShift</em></span>, for details.</p></div></div>

<div class="book" title="Creating your first Python application">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec391" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre6">Perform the following steps to create your first Python application:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Open a new command-line terminal, and change the directory to a convenient location where you want to create the application.</li><li class="listitem" value="2">To create a new Python 3.3 application, run the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ rhc create-app myapp python-3.3</strong></span>
</pre></div></li><li class="listitem" value="3">You can replace Python 3.3 with Python 2.6 or Python 2.7 to create applications that use the respective Python versions.</li><li class="listitem" value="4">Open your favorite web browser, and go to <code class="email">http://myapp-{domain-name}.rhcloud.com</code> to view the application. Please replace <code class="email">{domain-name}</code> with your OpenShift account domain name. You will see the OpenShift template application in your browser as follows:<div class="mediaobject"><img src="../images/00103.jpeg" alt="How to do it…" class="calibre8"/></div><p class="calibre12"> </p></li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Creating your first Python application">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec392" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre6">When you run<a id="id803" class="calibre1"/> the<a id="id804" class="calibre1"/> <code class="email">rhc create-app</code> command, OpenShift broker will receive the request and will initiate the application creation process. The application creation process was explained in detail in the <span class="strong"><em class="calibre10">Creating an OpenShift application using the rhc command-line client</em></span> recipe in <a class="calibre1" title="Chapter 3. Creating and Managing Applications" href="part0041_split_000.html#page">Chapter 3</a>, <span class="strong"><em class="calibre10">Creating and Managing Applications</em></span>. To run your Python applications, OpenShift needs to know the Python version you want to use. In step 2, you specified that OpenShift should create a Python 3.3 application with <code class="email">myapp</code> as the application name. OpenShift will use these details along with a few defaults to create the <code class="email">myapp</code> application. The defaults include a small gear size, non-scalable application, and the use of the current directory to clone the Git repository. To run Python-3.3-based web applications, OpenShift will install Python 3.3 language runtime and configure the Apache server with the <code class="email">mod_wsgi</code> module. The <code class="email">mod_wsgi</code> module<a id="id805" class="calibre1"/> provides an implementation of the <span class="strong"><strong class="calibre7">Web Server Gateway Interface</strong></span> (<span class="strong"><strong class="calibre7">WSGI</strong></span>)<a id="id806" class="calibre1"/> specification, allowing the Apache web server to host Python web applications that support the Python WSGI interface. The WSGI specification describes a simple interface between web servers and web applications or frameworks for the Python programming language. Most of the popular <a id="id807" class="calibre1"/>web frameworks (<a class="calibre1" href="http://wsgi.readthedocs.org/en/latest/frameworks.html">http://wsgi.readthedocs.org/en/latest/frameworks.html</a>) in the Python community support the WSGI interface. This makes it very easy for developers to run their choice of framework on OpenShift, as it provides the Apache <code class="email">mod_wsgi</code> deployment environment.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note27" class="calibre1"/>Note</h3><p class="calibre6">You can also run Python web applications on alternative Python web servers, such as <a id="id808" class="calibre1"/>Gevent. This will be covered in the <span class="strong"><em class="calibre10">Using Gevent with Python applications</em></span> recipe.</p></div><p class="calibre6">Apart from installing <a id="id809" class="calibre1"/>Python and configuring Apache with <code class="email">mod_wsgi</code>, every OpenShift application uses virtualenv and pip to manage application dependencies. A virtualenv tool is an isolated and private copy of your Python installation, which will be only used for that project without affecting the system's global Python installation. You can install packages in a virtualenv tool using pip, and virtualenv will ensure the application has access only to the package that it needs. Another advantage of virtual environments is that they don't require administrative rights.</p><p class="calibre6">Now, let's look at the template application created by OpenShift as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ cd myapp &amp;&amp; ls -ap</strong></span>
<span class="strong"><strong class="calibre7">$ .git/.openshift/ requirements.txt   wsgi.py  setup.py </strong></span>
</pre></div><p class="calibre6">The template application has three files—<code class="email">requirements.txt</code>, <code class="email">wsgi.py</code>, and <code class="email">setup.py</code>—apart from the <code class="email">.openshift</code> and <code class="email">.git</code> directories. We have already talked about <code class="email">.openshift</code> and <code class="email">.git</code> in the <span class="strong"><em class="calibre10">Creating an OpenShift application using the rhc command-line client</em></span> recipe in <a class="calibre1" title="Chapter 3. Creating and Managing Applications" href="part0041_split_000.html#page">Chapter 3</a>, <span class="strong"><em class="calibre10">Creating and Managing Applications</em></span>, so I will not cover them here. Let's talk about the three application files one by one:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">requirements.txt</code>: The <code class="email">requirements.txt</code> file<a id="id810" class="calibre1"/> is used to specify libraries that your application depends on. The pip package manager will install all the application dependencies mentioned in <code class="email">requirements.txt</code>. This is a regular text file with one dependency per line. The format is <code class="email">[package name]==[package version]</code>. The sample <code class="email">requirements.txt</code> file is shown as follows:<div class="informalexample"><pre class="programlisting">Flask==0.10.1
Jinja2==2.7.2
MarkupSafe==0.21
Werkzeug==0.9.4
itsdangerous==0.24</pre></div></li><li class="listitem"><code class="email">setup.py</code>: The <code class="email">setup.py</code> file<a id="id811" class="calibre1"/> allows developers to more easily build and distribute python packages that will be imported as dependencies by other projects. It allows you to specify project-specific metadata, such as name and description, as well as specify dependencies. The sample <code class="email">setup.py</code> file is shown as follows:<div class="informalexample"><pre class="programlisting">from setuptools import setup
setup(name='MyAwesomeApp',
      version='1.0',
      description='My Awesome OpenShift Application',
      author='Shekhar Gulati',
      author_email='shekhargulati84@gmail.com',
      url='http://www.python.org/sigs/distutils-sig/',
      install_requires=['Flask&gt;=0.7.2', 'MarkupSafe'],
      )</pre></div></li><li class="listitem"><code class="email">wsgi.py</code>: The <code class="email">wsgi.py</code> file<a id="id812" class="calibre1"/> is a WSGI-compatible application created by OpenShift. This file is mandatory if you want to use the Apache <code class="email">mod_wsgi</code> server to host your Python web application. This file contains the code <code class="email">mod_wsgi</code> module, which will execute on startup to get the application object. The application object is a callable that takes two parameters—<code class="email">environ</code> and <code class="email">start_response</code>. The <code class="email">environ</code> parameter is a dictionary containing environment variables, and <code class="email">start_response</code> is a callable that takes two required parameters: <code class="email">status</code> and <code class="email">response_headers</code>.</li></ul></div><p class="calibre6">You can check the<a id="id813" class="calibre1"/> exact version of Python running inside the application gear by running the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ rhc ssh --command 'python -V'</strong></span>
<span class="strong"><strong class="calibre7">Python 3.3.2</strong></span>
</pre></div></div></div>

<div class="book" title="Creating your first Python application">
<div class="book" title="There's more..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch08lvl2sec393" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre6">By default, a Python application expects <code class="email">wsgi.py</code> to be available at the application's root directory. If you want to change the directory layout and use a different location for <code class="email">wsgi.py</code>, you can set the <code class="email">OPENSHIFT_PYTHON_WSGI_APPLICATION</code> environment variable to specify a different location, as shown in the following command. You can view the list of available environment variables for a Python application<a id="id814" class="calibre1"/> at <a class="calibre1" href="https://access.redhat.com/documentation/en-US/OpenShift_Online/2.0/html/User_Guide/Python_Environment_Variables.html">https://access.redhat.com/documentation/en-US/OpenShift_Online/2.0/html/User_Guide/Python_Environment_Variables.html</a>.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ rhc env-set OPENSHIFT_PYTHON_WSGI_APPLICATION=wsgi/wsgi.py</strong></span>
</pre></div></div></div>

<div class="book" title="Creating your first Python application">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch08lvl2sec394" class="calibre1"/>See also</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">The <span class="strong"><em class="calibre10">Managing Python application dependencies</em></span> recipe</li><li class="listitem">The <span class="strong"><em class="calibre10">Enabling hot deployment for Python applications</em></span> recipe</li><li class="listitem">The <span class="strong"><em class="calibre10">Creating and deploying Flask web applications using Python and PostgreSQL cartridges</em></span> recipe</li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Managing Python application dependencies"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec101" class="calibre1"/>Managing Python application dependencies</h1></div></div></div><p class="calibre6">OpenShift gives the<a id="id815" class="calibre1"/> Python developer two options to specify their application dependencies. You can specify application dependencies either in the <code class="email">install_requires</code> element in <code class="email">setup.py</code>, in <code class="email">requirements.txt</code>, or both. When dependencies are specified in both the <code class="email">setup.py</code> and <code class="email">requirements.txt</code> files, OpenShift will install all the libraries mentioned in both the files. The <code class="email">setup.py</code> file is required when you want to distribute your library as a package that others can use. All the packages listed on PyPi need to have the <code class="email">setup.py</code> script in their root directory. As you do not want to distribute your web applications as a package, there is no need to use the <code class="email">setup.py</code> file. I recommend that you use <code class="email">requirements.txt</code> for your OpenShift applications. The reason why <code class="email">setup.py</code> exists is that OpenShift initially only supported <code class="email">setup.py</code> and later added support for the <code class="email">requirements.txt</code> file. So to make sure that the existing application continues to work on OpenShift, we need to support both the options. In this recipe, you will learn how to use <code class="email">requirements.txt</code> to specify application dependencies. The source code of the application created in this recipe is available on GitHub (<a class="calibre1" href="https://github.com/OpenShift-Cookbook/chapter8-recipe2">https://github.com/OpenShift-Cookbook/chapter8-recipe2</a>).</p></div>

<div class="book" title="Managing Python application dependencies">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec395" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre6">This recipe is based on the assumption that you have read the <span class="strong"><em class="calibre10">Creating your first Python application</em></span> recipe. To walk through this recipe, you will need the rhc command-line client installed on your machine. Please refer to the <span class="strong"><em class="calibre10">Installing the OpenShift rhc command-line client</em></span> recipe in <a class="calibre1" title="Chapter 1. Getting Started with OpenShift" href="part0014_split_000.html#page">Chapter 1</a>, <span class="strong"><em class="calibre10">Getting Started with OpenShift</em></span>, for details. This recipe will require you to have virtualenv installed on your machine. You can install virtualenv<a id="id816" class="calibre1"/> on your machine by following the instructions mentioned at <a class="calibre1" href="http://docs.python-guide.org/en/latest/dev/virtualenvs/">http://docs.python-guide.org/en/latest/dev/virtualenvs/</a>.</p></div></div>

<div class="book" title="Managing Python application dependencies">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec396" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre6">Perform the following steps to build a <code class="email">Hello World</code> Flask web application that will demonstrate how you can work with application dependencies:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Open a new command-line terminal, and run the following command to create a new Python application:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ rhc create-app myapp python-3.3</strong></span>
</pre></div><p class="calibre14">If you want to create Python 2.6 or Python 2.7 applications, use <code class="email">python-2.6</code> or <code class="email">python-2.7</code> as the web cartridge name instead of <code class="email">python-3.3</code>.</p></li><li class="listitem" value="2">Change the directory to <code class="email">myapp</code>, and delete the <code class="email">setup.py</code> file as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ cd myapp</strong></span>
<span class="strong"><strong class="calibre7">$ rm –f setup.py</strong></span>
</pre></div></li><li class="listitem" value="3">Create a new virtual environment by running the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ virtualenv venv --python=python3.3</strong></span>
</pre></div></li><li class="listitem" value="4">Before you can work with the virtual environment, you have to activate it. To activate the virtual environment, run the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ . venv/bin/activate</strong></span>
</pre></div></li><li class="listitem" value="5">Once you have activated virtualenv, you can begin installing modules without affecting the system's default Python interpreter. Install the Flask module by running the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ pip install flask</strong></span>
</pre></div></li><li class="listitem" value="6">Create a new Python file named <code class="email">hello.py</code> in the <code class="email">myapp</code> directory, and populate it with the following code:<div class="informalexample"><pre class="programlisting">from flask import Flask
app = Flask(__name__)

@app.route('/')
def index():
  return 'Hello World!'

if __name__ == '__main__':
  app.run()</pre></div></li><li class="listitem" value="7">To run this<a id="id817" class="calibre1"/> application on your local machine, run the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ python hello.py</strong></span>
</pre></div></li><li class="listitem" value="8">Next, open your favorite web browser, and go to <code class="email">http://127.0.0.1:5000</code>. You will see <span class="strong"><strong class="calibre7">Hello World!</strong></span> displayed in the browser.</li><li class="listitem" value="9">To deploy this application on OpenShift, we have to declare all the dependencies in <code class="email">requirements.txt</code>. The following command will write all of your application dependencies in <code class="email">requirements.txt</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ pip freeze &gt; requirements.txt</strong></span>
</pre></div></li><li class="listitem" value="10">The preceding command will populate <code class="email">requirements.txt</code> with all the application dependencies. This includes transitive dependencies as well. The <code class="email">requirements.txt</code> file will look as shown in the following code:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">Flask==0.10.1</strong></span>
<span class="strong"><strong class="calibre7">Jinja2==2.7.2</strong></span>
<span class="strong"><strong class="calibre7">MarkupSafe==0.23</strong></span>
<span class="strong"><strong class="calibre7">Werkzeug==0.9.4</strong></span>
<span class="strong"><strong class="calibre7">distribute==0.7.3</strong></span>
<span class="strong"><strong class="calibre7">itsdangerous==0.24</strong></span>
</pre></div><div class="note" title="Note"><h3 class="title2"><a id="note28" class="calibre1"/>Note</h3><p class="calibre6">Please make sure that the distribute version is 0.7.3, as earlier versions do not work with Python 3.3. Earlier versions of the distribute are not compatible with Python 3.3, so you might face trouble if you use them.</p></div></li><li class="listitem" value="11">Also, we have to update the <code class="email">wsgi.py</code> file to load the Flask application instead of the default one created by OpenShift. Delete all the content in the <code class="email">wsgi.py</code> file, and replace it with the one shown in the following code:<div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
from hello import app as application</pre></div></li><li class="listitem" value="12">Create a new file named <code class="email">.gitignore</code> in the <code class="email">myapp</code> directory, and add the <code class="email">venv</code> directory to be ignored. We do not want to push the virtual environment to OpenShift; OpenShift will create the virtual environment based on the dependencies mentioned in the <code class="email">requirements.txt</code> file. The <code class="email">.gitignore</code> file is created as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ cat .gitignore </strong></span>
<span class="strong"><strong class="calibre7">venv/</strong></span>
</pre></div></li><li class="listitem" value="13">Now commit<a id="id818" class="calibre1"/> the code to the local repository, and then push changes to application gear. OpenShift will install all the packages specified in the <code class="email">requirements.txt</code> file and make them available to the application via the virtual environment as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ git add .</strong></span>
<span class="strong"><strong class="calibre7">$ git commit -am "Hello World Flask application"</strong></span>
<span class="strong"><strong class="calibre7">$ git push</strong></span>
</pre></div></li><li class="listitem" value="14">Now, you can see the application running at <code class="email">http://myapp-{domain-name}.rhcloud.com</code>. Please replace <code class="email">{domain-name}</code> with your application domain name. You will see <span class="strong"><strong class="calibre7">Hello World</strong></span> in your browser.</li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Managing Python application dependencies">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec397" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre6">In the previous steps, you created a simple Flask framework<a id="id819" class="calibre1"/> web application that uses <code class="email">requirements.txt</code> to specify application dependencies. Flask is a micro web framework for the Python programming language. It is an easy-to-learn framework with extensive documentation, which can be found at <a class="calibre1" href="http://flask.pocoo.org/docs">http://flask.pocoo.org/docs</a>.</p><p class="calibre6">In step 1, you created a Python 3.3 application with the name <code class="email">myapp</code>. Read the <span class="strong"><em class="calibre10">Creating your first Python application</em></span> recipe to understand the Python application created by OpenShift. As you will use <code class="email">requirement.txt</code> to specify application dependencies, you deleted the <code class="email">setup.py</code> file in step 2. If you wish, you can keep the <code class="email">setup.py</code> file and specify your application metadata in it. The application metadata includes the name, description, version, and so on, of the application. I recommend that you specify application dependencies in only one file to avoid <a id="id820" class="calibre1"/>dependency hell (<a class="calibre1" href="http://en.wikipedia.org/wiki/Dependency_hell">http://en.wikipedia.org/wiki/Dependency_hell</a>).</p><p class="calibre6">Step 3 created a new virtual environment using the Python 3.3 interpreter. To use a virtual environment, you have to first activate it using the command shown in step 4. The virtual environment is the ideal way to work with Python applications, as it avoids polluting the system global Python installation.</p><p class="calibre6">You installed the Flask web framework using pip in step 5, as we are going to develop a web application that uses this framework. The Flask framework will be installed in the virtual environment and will become available to your application.</p><p class="calibre6">In step 6, you created a new Python file named <code class="email">hello.py</code> and added the source code for the <code class="email">Hello World</code> application. The code shown in step 6 does the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">In line 1, you<a id="id821" class="calibre1"/> imported the <code class="email">Flask</code> class from the <code class="email">flask</code> module.</li><li class="listitem">In line 2, you created an instance of the <code class="email">Flask</code> class. This instance will be that of the WSGI application.</li><li class="listitem">Then, you defined a route for the root (<code class="email">/</code>) URL. The route tells the Flask framework that it should invoke the <code class="email">index()</code> function when a request is made to the root URL. The <code class="email">index()</code> function will simply render <span class="strong"><strong class="calibre7">Hello World!</strong></span> in the browser.</li><li class="listitem">Finally, if the name of the application module is equal to <code class="email">'__main__</code>', the development server will be launched. The <code class="email">__name__ == '__main__'</code> expression is used to ensure the development server is started only when the script is executed directly using the <code class="email">python hello.py</code> command.</li></ul></div><p class="calibre6">Step 7 started the development web server by executing the <code class="email">hello.py</code> script. This will start the development server and launch the Flask application.</p><p class="calibre6">In step 8, you used the <code class="email">pip freeze</code> command to add all the dependencies to the <code class="email">requirements.txt</code> file. OpenShift will download all the dependencies mentioned in this file and populate the application virtual environment with them. OpenShift uses Apache <code class="email">mod_wsgi</code> to run your Python applications. The entry point of <code class="email">mod_wsgi</code> is the <code class="email">wsgi.py</code> file. This file should contain the code that will provide the application object on startup. In step 9, you replaced the content of the <code class="email">wsgi.py</code> file so that it uses the Flask application object instead of the application object created by the template.</p><p class="calibre6">Finally, you committed the code to the local Git repository and pushed the code to the OpenShift application gear. OpenShift will first stop the Apache server, download all the dependencies mentioned in the <code class="email">requirements.txt</code> file inside a virtual environment, and then finally start the Apache server. The part of the <code class="email">git push</code> output is shown as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ git push</strong></span>
<span class="strong"><strong class="calibre7">Counting objects: 9, done.</strong></span>
<span class="strong"><strong class="calibre7">Writing objects: 100% (6/6), 695 bytes, done.</strong></span>
<span class="strong"><strong class="calibre7">Total 6 (delta 0), reused 0 (delta 0)</strong></span>
<span class="strong"><strong class="calibre7">remote: Stopping Python 3.3 cartridge</strong></span>
<span class="strong"><strong class="calibre7">remote: Building git ref 'master', commit 128311d</strong></span>
<span class="strong"><strong class="calibre7">remote: Activating virtenv</strong></span>
<span class="strong"><strong class="calibre7">remote: Checking for pip dependency listed in requirements.txt file..</strong></span>
<span class="strong"><strong class="calibre7">remote: Downloading/unpacking Flask==0.10.1 (from -r /var/lib/openshift/536f59b3e0b8cd628600138b/app-root/runtime/repo/requirements.txt (line 1))</strong></span>
<span class="strong"><strong class="calibre7">remote: Downloading/unpacking Jinja2==2.7.2 (from -r /var/lib/openshift/536f59b3e0b8cd628600138b/app-root/runtime/repo/requirements.txt (line 2))</strong></span>
<span class="strong"><strong class="calibre7">…</strong></span>
<span class="strong"><strong class="calibre7">remote: Successfully installed Flask Jinja2 MarkupSafe Werkzeug itsdangerous setuptools distribute</strong></span>
<span class="strong"><strong class="calibre7">remote: Cleaning up...</strong></span>
<span class="strong"><strong class="calibre7">remote: Starting Python 3.3 cartridge (Apache+mod_wsgi)</strong></span>
<span class="strong"><strong class="calibre7">remote: Application directory "/" selected as DocumentRoot</strong></span>
<span class="strong"><strong class="calibre7">remote: Application "wsgi.py" selected as default WSGI entry point</strong></span>
<span class="strong"><strong class="calibre7">remote: Deployment completed with status: success </strong></span>
</pre></div></div></div>

<div class="book" title="Managing Python application dependencies">
<div class="book" title="There's more..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch08lvl2sec398" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre6">If you want to<a id="id822" class="calibre1"/> use <code class="email">setup.py</code> instead of <code class="email">requirements.txt</code>, you can delete <code class="email">requirement.txt</code> or keep it empty and specify all the requirements under the <code class="email">install_requires</code> element, as shown in the following code. The full source code of the application is available on GitHub at <a class="calibre1" href="https://github.com/OpenShift-Cookbook/chapter8-recipe2-setup.py">https://github.com/OpenShift-Cookbook/chapter8-recipe2-setup.py</a>.</p><div class="informalexample"><pre class="programlisting">from setuptools import setup

setup(name='MyApp',
      version='1.0',
      description='My OpenShift App',
      author='Shekhar Gulati',
      author_email='shekhargulati84@gmail.com',
      url='http://www.python.org/sigs/distutils-sig/',
     install_requires=['Flask&gt;=0.10.1'],
     )</pre></div></div></div>

<div class="book" title="Managing Python application dependencies">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch08lvl2sec399" class="calibre1"/>See also</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">The <span class="strong"><em class="calibre10">Creating your first Python application</em></span> recipe</li><li class="listitem">The <span class="strong"><em class="calibre10">Enabling hot deployment for Python applications</em></span> recipe</li><li class="listitem">The <span class="strong"><em class="calibre10">Creating and deploying Flask web applications using Python and PostgreSQL cartridges</em></span> recipe</li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Creating and deploying Flask web applications using Python and PostgreSQL cartridges"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec102" class="calibre1"/>Creating and deploying Flask web applications using Python and PostgreSQL cartridges</h1></div></div></div><p class="calibre6">In this recipe, you will develop a simple job portal application using the Python Flask<a id="id823" class="calibre1"/> web framework (<a class="calibre1" href="http://flask.pocoo.org/">http://flask.pocoo.org/</a>) and the PostgreSQL database. I have chosen Flask because it is a very easy-to-use and popular web framework. You can run any web framework, such as Django, Bottle, Zope, and Tornado, on OpenShift. The example application will allow users to post job openings and view a list of all the persisted jobs in the system. These two functionalities will be exposed using the two REST endpoints. The source code for this recipe is available on GitHub at <a class="calibre1" href="https://github.com/OpenShift-Cookbook/chapter8-jobstore-simple">https://github.com/OpenShift-Cookbook/chapter8-jobstore-simple</a>.</p></div>

<div class="book" title="Creating and deploying Flask web applications using Python and PostgreSQL cartridges">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec400" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre6">This recipe is <a id="id824" class="calibre1"/>based on the assumption that you have<a id="id825" class="calibre1"/> read previous recipes <a id="id826" class="calibre1"/>in this chapter. To <a id="id827" class="calibre1"/>walk through this recipe, you will need the rhc command-line client installed on your machine. Please refer to the <span class="strong"><em class="calibre10">Installing the OpenShift rhc command-line client</em></span> recipe in <a class="calibre1" title="Chapter 1. Getting Started with OpenShift" href="part0014_split_000.html#page">Chapter 1</a>, <span class="strong"><em class="calibre10">Getting Started with OpenShift</em></span>, for details. Also, if you want to run the application on your local machine, you will need to have Python, pip, and virtualenv installed on your machine. Please refer to the introduction section for links to installation instructions for respective software.</p></div></div>

<div class="book" title="Creating and deploying Flask web applications using Python and PostgreSQL cartridges">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec401" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre6">To create the application, perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Open a new command-line terminal, and navigate to a convenient location where you want to create the application. Create a new Python 2.7 and PostgreSQL 9.2 OpenShift application, and type the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ rhc create-app jobstore python-2.7 postgresql-9.2</strong></span>
</pre></div></li><li class="listitem" value="2">After the application is created, change the directory to <code class="email">jobstore</code>, and delete the <code class="email">setup.py</code> file:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ cd jobstore</strong></span>
<span class="strong"><strong class="calibre7">$ rm -f setup.py</strong></span>
</pre></div></li><li class="listitem" value="3">Also, create a <code class="email">.gitignore</code> file, and add the following to it:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">venv/</strong></span>
<span class="strong"><strong class="calibre7">*.pyc</strong></span>
</pre></div></li><li class="listitem" value="4">Create a new<a id="id828" class="calibre1"/> virtual environment for <a id="id829" class="calibre1"/>the <code class="email">jobstore</code> application. Run the following command to create the virtual <a id="id830" class="calibre1"/>environment, and <a id="id831" class="calibre1"/>then activate it:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ virtualenv venv --python=python2.7</strong></span>
<span class="strong"><strong class="calibre7">$ . venv/bin/activate</strong></span>
</pre></div></li><li class="listitem" value="5">Now that the virtual environment is activated, you can install the application dependencies. This application uses the Flask web framework. To install the dependencies in the virtual environment, run the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ pip install flask</strong></span>
</pre></div></li><li class="listitem" value="6">Create a new file named <code class="email">jobstore.py</code>, which will house the application source code. The following code is a simple Flask application that renders an <code class="email">index.html</code> file when a request is made to the root URL:<div class="informalexample"><pre class="programlisting">from flask import Flask, render_template,jsonify, request, Response

app = Flask(__name__)
app.config['PROPAGATE_EXCEPTIONS'] = True

@app.route('/')
def index():
  return render_template('index.html')

if __name__ == '__main__':
  app.run(debug=True)</pre></div></li><li class="listitem" value="7">In the previous code, the index route will render <code class="email">index.html</code> when a request is made to the root URL. By default, Flask looks for templates in the <code class="email">templates</code> directory inside the application folder. The <code class="email">render_template()</code> function provided by the Flask framework integrates the Jinja 2 template engine with the application. To make sure this code works, create a new directory named <code class="email">templates</code> in the application source code repository as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ mkdir templates</strong></span>
</pre></div></li><li class="listitem" value="8">Now, create a new <code class="email">index.html</code> file inside the <code class="email">templates</code> directory, and add the following content to it:<div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;JobStore&lt;/title&gt;
&lt;link href="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.1.1/css/bootstrap.css" rel="stylesheet"&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div class="container"&gt;
    &lt;div class="row"&gt;
      &lt;h2&gt;JobStore application expose Two REST End Points&lt;/h2&gt;
      &lt;ul&gt;
        &lt;li&gt;
          To create a Job, make a HTTP POST request to &lt;code&gt;/api/v1/jobs&lt;/code&gt;
        &lt;/li&gt;
        &lt;li&gt;
          To view all Jobs, make a HTTP GET request to &lt;code&gt;/api/v1/jobs&lt;/code&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;</pre></div></li><li class="listitem" value="9">You can test the<a id="id832" class="calibre1"/> application when you<a id="id833" class="calibre1"/> start the <a id="id834" class="calibre1"/>Python server<a id="id835" class="calibre1"/> by running the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ python jobstore.py</strong></span>
</pre></div></li><li class="listitem" value="10">To view the application, go to <code class="email">http://127.0.0.1:5000/</code> in your favorite browser. You will see <code class="email">index.html</code> rendered in your browser.</li><li class="listitem" value="11">The main responsibility of this application is to store the job data in the database. Python has support functionalities for various database frameworks that makes it very easy to work with a variety of databases. Among them, SQLAlchemy is the most popular and powerful relational database framework that supports various RDBMS backends. To use SQLAlchemy with Flask applications, you have to first install the Flask SQLAlchemy extension. The Flask SQLAlchemy extension simplifies working with SQLAlchemy inside Flask applications. To install Flask SQLAlchemy, run the following <code class="email">pip</code> command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ pip install flask-sqlalchemy</strong></span>
</pre></div></li><li class="listitem" value="12">Now that you have installed the Flask SQLAlchemy extension, the next task is to write the configuration code so that the <code class="email">jobstore</code> application can connect to the PostgreSQL database. Add the following content to <code class="email">jobstore.py</code>. You can view the full source code on GitHub at <a class="calibre1" href="https://github.com/OpenShift-Cookbook/chapter8-jobstore-simple/blob/master/jobstore.py">https://github.com/OpenShift-Cookbook/chapter8-jobstore-simple/blob/master/jobstore.py</a>.<div class="informalexample"><pre class="programlisting">from flask.ext.sqlalchemy import SQLAlchemy

app.config['SQLALCHEMY_DATABASE_URI'] = os.environ['OPENSHIFT_POSTGRESQL_DB_URL']
app.config['SQLALCHEMY_COMMIT_ON_TEARDOWN'] = True

db = SQLAlchemy(app)</pre></div></li><li class="listitem" value="13">In the<a id="id836" class="calibre1"/> preceding code, you added two <a id="id837" class="calibre1"/>configuration<a id="id838" class="calibre1"/> options<a id="id839" class="calibre1"/> to the Flask application configuration object. <code class="email">SQLALCHEMY_DATABASE_URI</code> points to the database connection URL. OpenShift exposes the PostgreSQL database connection URL using the <code class="email">OPENSHIFT_POSTGRESQL_DB_URL</code> environment variable. The <code class="email">SQLALCHEMY_COMMIT_ON_TEARDOWN</code> option enables automatic commits of database changes at the end of each request. Finally, you instantiated the <code class="email">db</code> object from the <code class="email">SQLAlchemy</code> class, passing it the application object. This <code class="email">db</code> object provides access to all the database-related functionalities.</li><li class="listitem" value="14">Next, you will write a model class to represent the <code class="email">Job</code> table in the PostgreSQL database. The model represents a persistent entity stored in the database. The <code class="email">db</code> instance that we got in step 7 provides a base class that a model can extend. Apart from this, the <code class="email">db</code> object also provides helper functions to define the structure of a model class. The <code class="email">Job</code> model is shown as follows:<div class="informalexample"><pre class="programlisting">class Job(db.Model):
  __tablename__ = 'jobs'
  id = db.Column(db.Integer(), primary_key=True)
  title = db.Column(db.String(64), index=True, nullable=False)
  description = db.Column(db.Text())
  posted_at = db.Column(db.DateTime(), nullable=False, default=datetime.utcnow)
  company = db.Column(db.String(100), nullable=False)

  def __repr__(self):
    return 'Job %s' % self.title

  def to_json(self):
    job_json = {
      'id' : self.id,
      'title': self.title,
      'description' : self.description,
      'posted_at' : self.posted_at,
      'company':self.company
    }
    return job_json


  @staticmethod
  def from_json(job_json):
    title = job_json.get('title')
    description = job_json.get('description')
    company = job_json.get('company')
    return Job(title=title, description=description,company=company)</pre></div><p class="calibre14">The <code class="email">__tablename__</code> variable is used to define the name of the table in the database. The <code class="email">db.Column()</code> function is used to define the class variables that will be mapped to columns in the database table. You also defined a couple of helper functions that will help convert to and from JSON. These methods will be useful when we build the REST API.</p></li><li class="listitem" value="15">Now you <a id="id840" class="calibre1"/>will write a couple of REST <a id="id841" class="calibre1"/>endpoints<a id="id842" class="calibre1"/> that will <a id="id843" class="calibre1"/>expose a couple of functionalities. The first endpoint will allow users to list all the jobs inside the database, and the second endpoint will allow users to create a new job. The REST endpoints are shown as follows:<div class="informalexample"><pre class="programlisting">@app.route('/api/v1/jobs')
def all_jobs():
  jobs = Job.query.all()
  return jsonify({'jobs':[job.to_json() for job in jobs]})

@app.route('/api/v1/jobs', methods=['POST'])
def post_job():
  job = Job.from_json(request.json)
  db.session.add(job)
  db.session.commit()
  return jsonify(job.to_json()) , 201</pre></div><p class="calibre14">In the previous code, the <code class="email">all_jobs()</code> function queries the database for all the <code class="email">Job</code> rows. The result from the database is converted to JSON and returned to the user. The <code class="email">jsonify()</code> function is provided by Flask and creates a response with the JSON representation and the <code class="email">application/json</code> MIME type.</p><p class="calibre14">The <code class="email">post_job()</code> function first converts the JSON request to the <code class="email">Job</code> object and then writes it to the database. Finally, it returns the persisted job to the user.</p></li><li class="listitem" value="16">As discussed in the <span class="strong"><em class="calibre10">Managing Python application dependencies</em></span> recipe, you have to update the <code class="email">wsgi.py</code> file to load the Flask application instead of the default created by OpenShift. Delete all the content in the <code class="email">wsgi.py</code> file, and replace it with the one shown in the following code:<div class="informalexample"><pre class="programlisting">#!/usr/bin/python
import os
virtenv = os.environ['OPENSHIFT_PYTHON_DIR'] + '/virtenv/'
virtualenv = os.path.join(virtenv, 'bin/activate_this.py')
try:
    execfile(virtualenv, dict(__file__=virtualenv))
except IOError:
    pass
from jobstore import app as application
from jobstore import *
db.create_all()</pre></div></li><li class="listitem" value="17">The last<a id="id844" class="calibre1"/> thing to do before we can deploy <a id="id845" class="calibre1"/>the application <a id="id846" class="calibre1"/>is specify<a id="id847" class="calibre1"/> the dependencies in <code class="email">requirements.txt</code>. Run the following command to populate the application <code class="email">requirements.txt</code> file:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ pip freeze &gt; requirements.txt</strong></span>
</pre></div></li><li class="listitem" value="18">Now, commit the code and push the application changes to the application gear as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ git add .</strong></span>
<span class="strong"><strong class="calibre7">$ git commit -am "jobstore application created"</strong></span>
<span class="strong"><strong class="calibre7">$ git push</strong></span>
</pre></div></li><li class="listitem" value="19">The application will be up and running at <code class="email">http://jobstore-{domain-name}.rhcloud.com</code>.</li><li class="listitem" value="20">To test the REST endpoints, you could use cURL. To create a new <code class="email">Job</code> instance, run the following cURL command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ curl -i -X POST -H "Content-Type: application/json" -H "Accept: application/json" -d '{"title":"OpenShift Evangelist","description":"OpenShift Evangelist","company":"Red Hat"}' http://jobstore-{domain-name}.rhcloud.com/api/v1/jobs</strong></span>
</pre></div></li><li class="listitem" value="21">To view all the jobs, you can run the following cURL command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ curl http://jobstore-osbook.rhcloud.com/api/v1/jobs</strong></span>
</pre></div></li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Creating and deploying Flask web applications using Python and PostgreSQL cartridges">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec402" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre6">In the <a id="id848" class="calibre1"/>previous steps, you created a Python web<a id="id849" class="calibre1"/> application and deployed it on<a id="id850" class="calibre1"/> OpenShift. From<a id="id851" class="calibre1"/> steps 1 through 4, you first created a new Python 2.7 OpenShift application, created a virtual environment for the project, and finally activated the virtual environment. The application uses the Python Flask framework, so you installed it using pip in step 5.</p><p class="calibre6">In steps 6 through 8, you created a Flask web application that renders the <code class="email">index.html</code> file. The code shown in step 4 does the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">You imported all the required classes and functions.</li><li class="listitem">Then, you created an instance of the <code class="email">Flask</code> class. The only required argument is the name of the main module or package of the application. The correct value is <code class="email">__name__</code> in most cases. Then, you defined a route for the root URL using the <code class="email">app.route</code> decorator. A route allows you to bind HTTP requests to function calls based on the URL requested. The index function will render <code class="email">index.html</code> in the browser.</li><li class="listitem">Finally, if the name of the application module is equal to <code class="email">'_ _main_ _</code>', the development server is launched. The <code class="email">__name__ == '__main__'</code> expression is used to ensure the development server is started only when the script is executed directly using the <code class="email">python jobstore.py</code> command. You tested the application on your local machine in step 10.</li></ul></div><p class="calibre6">In steps 11 through 14, you first installed the Flask SQLAlchemy extension and then did the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">First, you imported the <code class="email">SQLAlchemy</code> class from the <code class="email">Flask-SQLAlchemy</code> extension.</li><li class="listitem">Then, you configured the URL of the application database using <code class="email">SQLALCHEMY_DATABASE_URI</code> in the Flask configuration object. You also used another useful option, <code class="email">SQLALCHEMY_COMMIT_ON_TEARDOWN</code>, to configure the automatic commits of the database changes at the end of each request.</li><li class="listitem">Next, you created an instance of the <code class="email">SQLAlchemy</code> class that provides access to all the SQLAlchemy APIs.</li><li class="listitem">Then, you defined the <code class="email">Job</code> model class using the SQLAlchemy API. The <code class="email">company</code> class extends the <code class="email">db.Model</code> base class and uses the <code class="email">db.Column</code> constructor to define the structure of the model class. The <code class="email">__tablename__</code> variable is used to define the name of the table in the database.</li><li class="listitem">Finally, you defined a couple of helper functions that will help convert to and from JSON. These methods will be useful when we build the REST API.</li></ul></div><p class="calibre6">In step 15, you <a id="id852" class="calibre1"/>defined REST endpoints for<a id="id853" class="calibre1"/> the <code class="email">Job</code> model class. The code <a id="id854" class="calibre1"/>listing shown in<a id="id855" class="calibre1"/> step 15 does the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">When a user makes a <code class="email">GET</code> request to <code class="email">/api/v1/jobs</code>, the <code class="email">all_jobs()</code> function is invoked. The function finds all the jobs using the SQLAlchemy API, iterates over the result set, and then converts it into JSON.</li><li class="listitem">When a user makes a <code class="email">POST</code> request to <code class="email">/api/v1/jobs</code>, a new job is created. The JSON data is exposed as the <code class="email">request.json</code> Python dictionary. Then, the <code class="email">request.json</code> dictionary is converted into the <code class="email">Job</code> object using the <code class="email">from_json</code> method. The data is then persisted into the database using the <code class="email">db.session</code> API.</li></ul></div><p class="calibre6">In step 16, you replaced the content of the <code class="email">wsgi.py</code> file so that it uses the Flask application object instead of the application object created by the template. Finally, you committed the code to your local Git repository and then pushed the changes to the OpenShift application gear. Once deployed, you can go to <code class="email">http://jobstore-{domain-name}.rhcloud.com</code> and work with the application.</p></div></div>

<div class="book" title="Creating and deploying Flask web applications using Python and PostgreSQL cartridges">
<div class="book" title="There's more"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch08lvl2sec403" class="calibre1"/>There's more</h2></div></div></div><p class="calibre6">You can do all the previously performed steps with just a single command. The Git repository mentioned in the command contains the source code for this recipe as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ rhc create-app jobstore python-2.7 postgresql-9.2 --from-code https://github.com/OpenShift-Cookbook/chapter8-jobstore-simple.git </strong></span>
</pre></div></div></div>

<div class="book" title="Creating and deploying Flask web applications using Python and PostgreSQL cartridges">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch08lvl2sec404" class="calibre1"/>See also</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">The <span class="strong"><em class="calibre10">Creating your first Python application</em></span> recipe</li><li class="listitem">The <span class="strong"><em class="calibre10">Enabling hot deployment for Python applications</em></span> recipe</li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Enabling hot deployment for Python applications"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec103" class="calibre1"/>Enabling hot deployment for Python applications</h1></div></div></div><p class="calibre6">Every time you make a<a id="id856" class="calibre1"/> change to your application source<a id="id857" class="calibre1"/> code and push the changes to the OpenShift application gear Git repository, OpenShift first stops your gear (which stops all the cartridges installed on the gear), copies the source code from your application Git repository to <code class="email">app-root/runtime/repo</code>, performs a build, prepares the artifact, and finally starts your gear (which starts all the cartridges). This process takes time and does not suit rapid development and deployment. To enable rapid development and faster deployments, OpenShift supports hot deployment. Hot deployment means that you can deploy your changes without the need to restart all the application cartridges.</p><p class="calibre6">In this recipe, you will learn how you can enable hot deployment for Python applications.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note29" class="calibre1"/>Note</h3><p class="calibre6">This recipe will work with all the three supported Python versions.</p></div></div>

<div class="book" title="Enabling hot deployment for Python applications">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec405" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre6">Perform the following steps to enable hot deployment for your application:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create a new Python application using the source code developed in the previous recipe as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ rhc create-app myapp python-3.3 --from-code=https://github.com/OpenShift-Cookbook/chapter8-recipe2.git</strong></span>
</pre></div></li><li class="listitem" value="2">Open the <code class="email">hello.py</code> file, and update <code class="email">Hello World!</code> to <code class="email">Hello from OpenShift</code>.</li><li class="listitem" value="3">To enable hot deployment, create an empty file named <code class="email">hot_deploy</code> under the <code class="email">.openshift/markers</code> directory. This file is called the marker file, as this does not contain any content. On the *nix machine, you can create a new file by executing the following command. On a Windows machine, you can use file explorer to create a new file.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ touch .openshift/markers/hot_deploy</strong></span>
</pre></div></li><li class="listitem" value="4">Add the file to the Git repository, and then commit and push changes to the application gear as shown in the following code:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ git add –A .</strong></span>
<span class="strong"><strong class="calibre7">$ git commit -am "enabled hot deployment"</strong></span>
<span class="strong"><strong class="calibre7">$ git push</strong></span>
</pre></div></li><li class="listitem" value="5">In the <code class="email">git push</code> logs, you will see a message that cartridges are not stopped because hot deployment is enabled as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">remote: Not stopping cartridge python because hot deploy is enabled</strong></span>
</pre></div></li><li class="listitem" value="6">Now open the application URL in your favorite web browser, and you will see the change deployed without a restart.</li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Enabling hot deployment for Python applications">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec406" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre6">The presence of<a id="id858" class="calibre1"/> the <code class="email">hot_deploy</code> marker<a id="id859" class="calibre1"/> file informs OpenShift that you want to do hot deployment. Before stopping and starting the application cartridges, OpenShift checks for the existence of the <code class="email">hot_deploy</code> marker file. If the <code class="email">hot_deploy</code> marker file exists, OpenShift will not stop the cartridges, and changes will be deployed without cartridge restart. Hot deployment is ideal for development, and I recommend that you should always use it during development.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note30" class="calibre1"/>Note</h3><p class="calibre6">If you set new environment variables with hot deployment enabled or install new cartridges, you have to restart the application to allow the server to pick the new environment variables.</p></div></div></div>

<div class="book" title="Enabling hot deployment for Python applications">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec407" class="calibre1"/>See also</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">The <span class="strong"><em class="calibre10">Forcing a clean Python virtual environment</em></span> recipe</li><li class="listitem">The <span class="strong"><em class="calibre10">Accessing an application's Python virtual environment</em></span> recipe</li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Forcing a clean Python virtual environment"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec104" class="calibre1"/>Forcing a clean Python virtual environment</h1></div></div></div><p class="calibre6">The first time you push your<a id="id860" class="calibre1"/> changes to the application gear, pip will download all the dependencies mentioned in <code class="email">setup.py</code> or <code class="email">requirements.txt</code> and populate the virtual environment with these dependencies. On every successive push, OpenShift will reuse the dependencies and will only download new dependencies mentioned in <code class="email">setup.py</code> or <code class="email">requirements.txt</code>. This makes the application build faster, as it does not have to download dependencies on every <code class="email">git push</code>. There are scenarios, such as a corrupt virtual environment, where you will like to recreate the virtual environment and download all the dependencies again. In this recipe, you will learn how you can force OpenShift to recreate the virtual environment.</p></div>

<div class="book" title="Forcing a clean Python virtual environment">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec408" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre6">This recipe is based on the assumption that you have read the previous recipes in this chapter. To step through this recipe, you will need the rhc command-line client installed on your machine. Please refer to the <span class="strong"><em class="calibre10">Installing the OpenShift rhc command-line client</em></span> recipe in <a class="calibre1" title="Chapter 1. Getting Started with OpenShift" href="part0014_split_000.html#page">Chapter 1</a>, <span class="strong"><em class="calibre10">Getting Started with OpenShift</em></span>, for details.</p></div></div>

<div class="book" title="Forcing a clean Python virtual environment">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec409" class="calibre1"/>How to do it…</h2></div></div></div><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Recreate the application you developed in the <span class="strong"><em class="calibre10">Creating and deploying Flask web applications using Python and PostgreSQL cartridges</em></span> recipe by running the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ rhc create-app jobstore python-2.7 postgresql-9.2 --from-code https://github.com/OpenShift-Cookbook/chapter8-jobstore-simple.git</strong></span>
</pre></div></li><li class="listitem" value="2">Create a marker file named <code class="email">force_clean_build</code> in the application's <code class="email">.openshift/markers</code> directory. On *nix machines, you can use the <code class="email">touch</code> command as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ cd jobstore</strong></span>
<span class="strong"><strong class="calibre7">$ touch .openshift/markers/force_clean_build</strong></span>
</pre></div></li><li class="listitem" value="3">Commit the file, and push the changes to the OpenShift application gear. From now on, every <code class="email">git push</code> will do a clean deployment. This is demonstrated using the following commands:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ git add .</strong></span>
<span class="strong"><strong class="calibre7">$ git commit –am "enabled force_clean_build"</strong></span>
<span class="strong"><strong class="calibre7">$ git push</strong></span>
</pre></div></li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Forcing a clean Python virtual environment">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec410" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre6">The presence <a id="id861" class="calibre1"/>of the <code class="email">force_clean_build</code> marker file informs OpenShift that you want to do a clean build. When you do a <code class="email">git push</code>, OpenShift will first recreate the virtual environment, activate the environment, and finally download all the dependencies using the pip package manager. You will see the following log message in the <code class="email">git push</code> logs:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">remote: Force clean build enabled - cleaning dependencies</strong></span>
</pre></div></div></div>

<div class="book" title="Forcing a clean Python virtual environment">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch08lvl2sec411" class="calibre1"/>See also</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">The <span class="strong"><em class="calibre10">Enabling hot deployment for Python applications</em></span> recipe</li><li class="listitem">The <span class="strong"><em class="calibre10">Forcing a clean Python virtual environment</em></span> recipe</li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Accessing an application's Python virtual environment"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec105" class="calibre1"/>Accessing an application's Python virtual environment</h1></div></div></div><p class="calibre6">By now, you will be aware<a id="id862" class="calibre1"/> that every OpenShift Python application has a virtual environment associated with it. Your application will only be able to use the dependencies available in the virtual environment. In this recipe, you will learn how to access the virtual environment of your OpenShift Python application.</p></div>

<div class="book" title="Accessing an application's Python virtual environment">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec412" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre6">This recipe is based on the assumption that you have read previous recipes in this chapter. To walk through this recipe, you will need the rhc command-line client installed on your machine. Please refer to the <span class="strong"><em class="calibre10">Installing the OpenShift rhc command-line client</em></span> recipe in <a class="calibre1" title="Chapter 1. Getting Started with OpenShift" href="part0014_split_000.html#page">Chapter 1</a>, <span class="strong"><em class="calibre10">Getting Started with OpenShift</em></span>, for details. Also, if you want to run the application on your local machine, you will need to have Python, pip, and virtualenv installed on your machine. Please refer to the introduction section for links to installation instructions for the respective software.</p></div></div>

<div class="book" title="Accessing an application's Python virtual environment">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec413" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre6">Perform the following steps to access the Python application virtual environment:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Recreate the application you developed in the <span class="strong"><em class="calibre10">Creating and deploying Flask web applications using Python and PostgreSQL cartridges</em></span> recipe by running the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ rhc create-app jobstore python-2.7 postgresql-9.2 --from-code https://github.com/OpenShift-Cookbook/chapter8-jobstore-simple.git</strong></span>
</pre></div></li><li class="listitem" value="2">Change the directory to <code class="email">jobstore</code>, and then SSH into the application gear by executing the <code class="email">rhc ssh</code> command.</li><li class="listitem" value="3">To access the virtual environment, run the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">[536fdb88e0b8cd76ee000262]\&gt; . $VIRTUAL_ENV/bin/activate</strong></span>
<span class="strong"><strong class="calibre7">(virtenv)[536fdb88e0b8cd76ee000262]\&gt;</strong></span>
</pre></div></li><li class="listitem" value="4">Once you are inside the virtual environment, you can manually download the new dependencies using pip. To install a command-line utility called <span class="strong"><strong class="calibre7">Yolk</strong></span>, run the following command. Yolk can list packages installed within an environment.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">(virtenv)[ 536fdb88e0b8cd76ee000262]\&gt; pip install yolk</strong></span>
</pre></div></li><li class="listitem" value="5">To list all the installed packages in this virtual environment, run the following command. Only part of the output is shown here for brevity.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">(virtenv)[ 536fdb88e0b8cd76ee000262]\&gt; yolk -l</strong></span>
<span class="strong"><strong class="calibre7">Babel           - 0.9.6        - active development (/opt/rh/python27/root/usr/lib/python2.7/site-packages)</strong></span>
<span class="strong"><strong class="calibre7">Extractor       - 0.6          - active development (/opt/rh/python27/root/usr/lib/python2.7/site-packages)</strong></span>
<span class="strong"><strong class="calibre7">Flask-SQLAlchemy - 1.0          - active development (/var/lib/openshift/536fdb88e0b8cd76ee000262/app-root/runtime/dependencies/python/virtenv/lib/python2.7/site-packages)</strong></span>
</pre></div></li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Accessing an application's Python virtual environment">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec414" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre6">You created a new<a id="id863" class="calibre1"/> Python application in step 1 and then connected to the application gear using SSH in step 2 when you used the <code class="email">rhc ssh</code> command. The location of the virtual environment is available as an environment variable, <code class="email">$VIRTUAL_ENV</code>. You activated the virtual environment in step 3 so that you can use it. Finally, in step 4, you installed a package using the <code class="email">pip</code> command manually. After installation, the package becomes available to the application.</p></div></div>

<div class="book" title="Accessing an application's Python virtual environment">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch08lvl2sec415" class="calibre1"/>See also</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">The <span class="strong"><em class="calibre10">Enabling hot deployment for Python applications</em></span> recipe</li><li class="listitem">The <span class="strong"><em class="calibre10">Forcing a clean Python virtual environment</em></span> recipe</li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Using Gevent with Python applications"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec106" class="calibre1"/>Using Gevent with Python applications</h1></div></div></div><p class="calibre6">So far in this chapter, you<a id="id864" class="calibre1"/> have used Apache with <code class="email">mod_wsgi</code> to run your <a id="id865" class="calibre1"/>Python applications. It is also possible to run other standalone WSGI servers, such as Gevent and Gunicorn, with OpenShift. In this recipe, you will learn how to use Gevent to run your Python applications. Gevent is a coroutine-based Python networking library that uses greenlet to provide a high-level, synchronous API on top of the libevent event loop. The source code for this repository is on GitHub at <a class="calibre1" href="https://github.com/OpenShift-Cookbook/chapter8-gevent-recipe">https://github.com/OpenShift-Cookbook/chapter8-gevent-recipe</a>.</p></div>

<div class="book" title="Using Gevent with Python applications">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec416" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre6">This recipe is based on the assumption that you have read the previous recipes in this chapter. To step through this recipe, you will need the rhc command-line client installed on your machine. Please refer to the <span class="strong"><em class="calibre10">Installing the OpenShift rhc command-line client</em></span> recipe in <a class="calibre1" title="Chapter 1. Getting Started with OpenShift" href="part0014_split_000.html#page">Chapter 1</a>, <span class="strong"><em class="calibre10">Getting Started with OpenShift</em></span>, for details. Also, if you want to run the application on your local machine, you will need to have Python, pip, and virtualenv installed on your machine. Please refer to the introduction section for links to installation instructions for the respective software.</p></div></div>

<div class="book" title="Using Gevent with Python applications">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec417" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre6">Perform the following steps to use Gevent's standalone WSGI server to run OpenShift Python applications:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Open a new <a id="id866" class="calibre1"/>command-line terminal, and run the<a id="id867" class="calibre1"/> following command to create a new Python 2.7 application:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ rhc app create myapp python-2.7</strong></span>
</pre></div><p class="calibre14">If you want to create Python 2.6 or Python 3.3 applications, use Python 2.6 and Python 3.3 respectively.</p></li><li class="listitem" value="2">Change the directory to <code class="email">myapp</code>, and delete the <code class="email">setup.py</code> and <code class="email">wsgi.py</code> files as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ cd myapp</strong></span>
<span class="strong"><strong class="calibre7">$ rm –f setup.py</strong></span>
<span class="strong"><strong class="calibre7">$ rm –f wsgi.py</strong></span>
</pre></div></li><li class="listitem" value="3">Create a new virtual environment by running the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ virtualenv venv --python=python2.7</strong></span>
</pre></div></li><li class="listitem" value="4">Before you can work with the virtual environment, you have to activate it. To activate the virtual environment, run the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ . venv/bin/activate</strong></span>
</pre></div></li><li class="listitem" value="5">Once you have activated virtualenv, you can begin installing modules without affecting the system's default Python interpreter. Install the Flask module by running the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ pip install flask</strong></span>
</pre></div></li><li class="listitem" value="6">Create a new Python file named <code class="email">hello.py</code> in the <code class="email">myapp</code> directory, and populate it with the following code:<div class="informalexample"><pre class="programlisting">from flask import Flask
app = Flask(__name__)
@app.route('/')
def index():
  return 'Hello World!'

if __name__ == '__main__':
  app.run()</pre></div></li><li class="listitem" value="7">Next, install the Gevent library, as we want to use it to run our application, as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ pip install gevent</strong></span>
</pre></div></li><li class="listitem" value="8">Create a new file named <code class="email">app.py</code>, and add the following code to it:<div class="informalexample"><pre class="programlisting">import os
virtenv = os.environ['OPENSHIFT_PYTHON_DIR'] + '/virtenv/'
virtualenv = os.path.join(virtenv, 'bin/activate_this.py')
try:
    execfile(virtualenv, dict(__file__=virtualenv))
except IOError:
    pass

from gevent.wsgi import WSGIServer
from hello import app

ip   = os.environ['OPENSHIFT_PYTHON_IP']
port = int(os.environ['OPENSHIFT_PYTHON_PORT'])

http_server = WSGIServer((ip, port), app)
http_server.serve_forever()</pre></div></li><li class="listitem" value="9">To deploy this application on OpenShift, we have to declare all the dependencies in <code class="email">requirements.txt</code>. The following command will write all of your application dependencies in <code class="email">requirements.txt</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ pip freeze &gt; requirements.txt</strong></span>
</pre></div></li><li class="listitem" value="10">The previous<a id="id868" class="calibre1"/> command will populate <code class="email">requirements.txt</code> <a id="id869" class="calibre1"/>with all the application dependencies. This includes transitive dependencies as well. The <code class="email">requirements.txt</code> file is shown as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">Flask==0.10.1</strong></span>
<span class="strong"><strong class="calibre7">Jinja2==2.7.2</strong></span>
<span class="strong"><strong class="calibre7">MarkupSafe==0.23</strong></span>
<span class="strong"><strong class="calibre7">Werkzeug==0.9.4</strong></span>
<span class="strong"><strong class="calibre7">gevent==1.0.1</strong></span>
<span class="strong"><strong class="calibre7">greenlet==0.4.2</strong></span>
<span class="strong"><strong class="calibre7">itsdangerous==0.24</strong></span>
<span class="strong"><strong class="calibre7">wsgiref==0.1.2</strong></span>
</pre></div></li><li class="listitem" value="11">Create a new file named <code class="email">.gitignore</code> in the <code class="email">myapp</code> directory, and add the <code class="email">venv</code> directory to be ignored. We do not want to push the virtual environment to OpenShift, as OpenShift will create the one based on the dependencies mentioned in the <code class="email">requirements.txt</code> file. The <code class="email">.gitignore</code> file is shown as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ cat .gitignore </strong></span>
<span class="strong"><strong class="calibre7">venv/</strong></span>
</pre></div></li><li class="listitem" value="12">Now commit the code to the local repository, and then push changes to the application gear. OpenShift will install all the packages specified in <code class="email">requirements.txt</code> and make them available to the application via the virtual environment, as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ git add .</strong></span>
<span class="strong"><strong class="calibre7">$ git commit -am "using Gevent standalone WSGI server"</strong></span>
<span class="strong"><strong class="calibre7">$ git push</strong></span>
</pre></div></li><li class="listitem" value="13">Now, open the web application URL in your favorite browser to see the application in action. You will be greeted by the <span class="strong"><strong class="calibre7">Hello World</strong></span> text in your browser.</li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Using Gevent with Python applications">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec418" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre6">In steps 1 through 6, you<a id="id870" class="calibre1"/> created a simple Flask web application <a id="id871" class="calibre1"/>as explained in the <span class="strong"><em class="calibre10">Managing Python application dependencies</em></span> recipe. As we will use Gevent to run this application, you installed the Gevent library in step 7. In step 8, you created a new Python file, <code class="email">app.py</code>. If the user does not use the default <code class="email">wsgi.py</code> file or WSGI endpoint configured using the <code class="email">OPENSHIFT_PYTHON_WSGI_APPLICATION</code> environment variable, OpenShift uses the server configured in the <code class="email">app.py</code> file to serve your application. This Python file should have the name <code class="email">app</code> and exist under the <code class="email">app</code> root directory. The code in <code class="email">app.py</code> first activates the virtual environment and then starts the Gevent WSGI server at <code class="email">$OPENSHIFT_PYTHON_IP</code> and <code class="email">$OPENSHIFT_PYTHON_PORT</code>.</p><p class="calibre6">In step 9, you used the <code class="email">pip freeze</code> command to add all the dependencies in the <code class="email">requirements.txt</code> file. OpenShift will download all the dependencies mentioned in this file and populate the application's virtual environment with them.</p><p class="calibre6">Finally, you committed the code to the local Git repository and pushed the code to the OpenShift application gear. OpenShift will use the Gevent WSGI server to run your application. You will see a line, as shown in the following command-line output, in the <code class="email">git push</code> logs. The following line clearly tells you that OpenShift is using the server configured in <code class="email">app.py</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">remote: Starting Python 2.7 cartridge (app.py server)</strong></span>
</pre></div></div></div>

<div class="book" title="Using Gevent with Python applications">
<div class="book" title="There's more..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch08lvl2sec419" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre6">Similarly, you <a id="id872" class="calibre1"/>can use the Tornado web server to serve your Python <a id="id873" class="calibre1"/>web applications. Uninstall the Gevent and greenlet libraries, and then install the Tornado library:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ pip uninstall gevent greenlet</strong></span>
<span class="strong"><strong class="calibre7">$ pip install tornado</strong></span>
</pre></div><p class="calibre6">Update the <code class="email">requirements.txt</code> file with dependencies by running the <code class="email">pip freeze &gt; requirements.txt</code> command.</p><p class="calibre6">In the <code class="email">app.py</code> file, replace the Gevent code with the following code:</p><div class="informalexample"><pre class="programlisting">from tornado.wsgi import WSGIContainer
from tornado.httpserver import HTTPServer
from tornado.ioloop import IOLoop
from hello import app

http_server = HTTPServer(WSGIContainer(app))
ip   = os.environ['OPENSHIFT_PYTHON_IP']
port = int(os.environ['OPENSHIFT_PYTHON_PORT'])

http_server.listen(port, ip)
IOLoop.instance().start()</pre></div><p class="calibre6">Now your application will use the Tornado web server.</p></div></div>

<div class="book" title="Using Gevent with Python applications">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch08lvl2sec420" class="calibre1"/>See also</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">The <span class="strong"><em class="calibre10">Creating your first Python application</em></span> recipe</li><li class="listitem">The <span class="strong"><em class="calibre10">Creating and deploying Flask web applications using Python and PostgreSQL cartridges</em></span> recipe</li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Installing a custom Python package"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec107" class="calibre1"/>Installing a custom Python package</h1></div></div></div><p class="calibre6">Most of the time, your application <a id="id874" class="calibre1"/>dependencies can be downloaded<a id="id875" class="calibre1"/> from PyPi using pip, but there are times when your application needs to depend on custom libraries that do not exist in the PyPi index. In this recipe, you will learn how to use custom Python packages with your OpenShift Python applications. The source code for this recipe is on GitHub at <a class="calibre1" href="https://github.com/OpenShift-Cookbook/chapter8-custom-package-recipe">https://github.com/OpenShift-Cookbook/chapter8-custom-package-recipe</a>.</p></div>

<div class="book" title="Installing a custom Python package">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec421" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre6">This recipe is based on the assumption that you have read the previous recipes in this chapter. To walk through this recipe, you will need the rhc command-line client installed on your machine. Please refer to the <span class="strong"><em class="calibre10">Installing the OpenShift rhc command-line client</em></span> recipe in <a class="calibre1" title="Chapter 1. Getting Started with OpenShift" href="part0014_split_000.html#page">Chapter 1</a>, <span class="strong"><em class="calibre10">Getting Started with OpenShift</em></span>, for details. Also, if you want to run the application on your local machine, you will need to have Python, pip, and virtualenv installed on your machine. Please refer to the introduction section for links to installation instructions for the respective software.</p></div></div>

<div class="book" title="Installing a custom Python package">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec422" class="calibre1"/>How to do it…</h2></div></div></div><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Open a new<a id="id876" class="calibre1"/> command-line terminal, and run <a id="id877" class="calibre1"/>the following command to create a new Python 2.7 application:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ rhc create-app myapp python-2.7</strong></span>
</pre></div><p class="calibre14">If you want to create Python 2.6 or Python 3.3 applications, use Python 2.6 and Python 3.3 respectively.</p></li><li class="listitem" value="2">Change the directory to <code class="email">myapp</code>, and delete the <code class="email">setup.py</code> file as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ cd myapp</strong></span>
<span class="strong"><strong class="calibre7">$ rm –f setup.py</strong></span>
</pre></div></li><li class="listitem" value="3">Also, create a <code class="email">.gitignore</code> file to ignore the virtual environment artifacts and Python-compiled files as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ touch .gitignore</strong></span>
</pre></div></li><li class="listitem" value="4">Add the following lines to it:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">venv</strong></span>
<span class="strong"><strong class="calibre7">*.pyc</strong></span>
</pre></div></li><li class="listitem" value="5">Create a new virtual environment and activate it by running the following commands:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ virtualenv venv --python=python2.7</strong></span>
<span class="strong"><strong class="calibre7">$ . venv/bin/activate</strong></span>
</pre></div></li><li class="listitem" value="6">Once you have activated virtualenv, you can begin installing modules without affecting the system's default Python interpreter. Install the Flask module by running the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ pip install flask</strong></span>
</pre></div></li><li class="listitem" value="7">Create a new directory named <code class="email">libs</code> in the application root, as shown in the following code. The <code class="email">libs</code> directory will be used to store your custom packages:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ mkdir libs</strong></span>
</pre></div></li><li class="listitem" value="8">Now, we will create a custom package named <code class="email">msgs</code> in the <code class="email">libs</code> directory. To create a custom package, perform the following steps:<div class="book"><ol class="orderedlist1"><li class="listitem" value="1">Create an <code class="email">msgs</code> directory inside the <code class="email">libs</code> directory.</li><li class="listitem" value="2">Create an empty file named <code class="email">__init__.py</code> inside the <code class="email">msgs</code> directory.</li><li class="listitem" value="3">Create another file named <code class="email">hello.py</code> inside the <code class="email">msgs</code> directory, and place the following code inside it:<div class="informalexample"><pre class="programlisting">def hello():
  return 'Hello World'</pre></div></li></ol><div class="calibre13"/></div></li><li class="listitem" value="9">Next, create a <a id="id878" class="calibre1"/>new Python file named <code class="email">myapp.py</code> in<a id="id879" class="calibre1"/> the <code class="email">myapp</code> directory, and populate it with the following code. This simple Flask application will use the <code class="email">msgs</code> package. Have a look at the following code:<div class="informalexample"><pre class="programlisting">from flask import Flask
import msgs.hello as hello
app = Flask(__name__)
@app.route('/')
def index():
  return hello.hello()
if __name__ == '__main__':
  app.run(debug=True)</pre></div></li><li class="listitem" value="10">Now, you need to update the <code class="email">wsgi.py</code> file to load the Flask application instead of the default created by OpenShift. Delete all the content in the <code class="email">wsgi.py</code> file, and replace it with the following code:<div class="informalexample"><pre class="programlisting">#!/usr/bin/python
import os
virtenv = os.environ['OPENSHIFT_PYTHON_DIR'] + '/virtenv/'
virtualenv = os.path.join(virtenv, 'bin/activate_this.py')
try:
    execfile(virtualenv, dict(__file__=virtualenv))
except IOError:
    pass

from myapp import app as application </pre></div></li><li class="listitem" value="11">To deploy this application on OpenShift, we have to declare all the dependencies in <code class="email">requirements.txt</code>. The following command will write all of your application dependencies in <code class="email">requirements.txt</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ pip freeze &gt; requirements.txt</strong></span>
</pre></div></li><li class="listitem" value="12">Now, commit the code to the local repository, and then push changes to the application gear. OpenShift will install all the packages specified in <code class="email">requirements.txt</code> and make them available to the application via the virtual environment:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ git add .</strong></span>
<span class="strong"><strong class="calibre7">$ git commit -am "application with custom package"</strong></span>
<span class="strong"><strong class="calibre7">$ git push</strong></span>
</pre></div></li><li class="listitem" value="13">Now, open the web application URL in your favorite browser to see the application in action. You will be greeted by the <span class="strong"><strong class="calibre7">Hello World</strong></span> text in your browser.</li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Installing a custom Python package">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec423" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre6">In the preceding <a id="id880" class="calibre1"/>steps, you learned how to use the <code class="email">libs</code> directory to<a id="id881" class="calibre1"/> store your custom packages. The <code class="email">libs</code> directory is an example of how OpenShift uses convention over configuration. The phrase <span class="strong"><em class="calibre10">convention over configuration</em></span> means that if you follow certain conventions, you do not have to write the configuration code. OpenShift follows a convention that all the packages in the <code class="email">libs</code> directory should be placed in the path so that your application can use them. In step 6, you created a custom package named <code class="email">msgs</code> in the <code class="email">libs</code> directory, and without any configuration, your application could access the package.</p></div></div>

<div class="book" title="Installing a custom Python package">
<div class="book" title="There's more…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch08lvl2sec424" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre6">Now, let's suppose that you want to use the <code class="email">mydeps</code> directory to store your custom packages. For your application to work, you have to write code in your application to add the <code class="email">mydeps</code> directory to the system path. Adding two lines in the application's <code class="email">wsgi.py</code> file can solve this problem. The full application source code is on GitHub at <a class="calibre1" href="https://github.com/OpenShift-Cookbook/chapter8-custom-package-mydeps-recipe">https://github.com/OpenShift-Cookbook/chapter8-custom-package-mydeps-recipe</a>. Have a look at the following code:</p><div class="informalexample"><pre class="programlisting">import os,sys
sys.path.append(os.path.join(os.getenv("OPENSHIFT_REPO_DIR"), "mydeps"))  </pre></div><p class="calibre6">The previous two lines will add the <code class="email">mydeps</code> directory to the application's system path.</p></div></div>

<div class="book" title="Installing a custom Python package">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch08lvl2sec425" class="calibre1"/>See also</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">The <span class="strong"><em class="calibre10">Creating your first Python application</em></span> recipe</li><li class="listitem">The <span class="strong"><em class="calibre10">Creating and deploying Flask web applications using Python and PostgreSQL cartridges</em></span> recipe</li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Using the .htaccess file to configure Apache"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec108" class="calibre1"/>Using the .htaccess file to configure Apache</h1></div></div></div><p class="calibre6">By now, you will be <a id="id882" class="calibre1"/>aware that OpenShift uses <a id="id883" class="calibre1"/>Apache with <code class="email">mod_wsgi</code> to serve your web applications. In this recipe, you will learn to use the <code class="email">.htaccess</code> and <code class="email">.htpasswd</code> files to configure the Apache web server for the HTTP basic authentication. The GitHub repository for this recipe is <a class="calibre1" href="https://github.com/OpenShift-Cookbook/chapter8-htaccess-recipe">https://github.com/OpenShift-Cookbook/chapter8-htaccess-recipe</a>.</p></div>

<div class="book" title="Using the .htaccess file to configure Apache">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec426" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre6">This recipe is based on the assumption that you have read the previous recipes in this chapter. To walk through this recipe, you will need the rhc command-line client installed on your machine. Please refer to the <span class="strong"><em class="calibre10">Installing the OpenShift rhc command-line client</em></span> recipe in <a class="calibre1" title="Chapter 1. Getting Started with OpenShift" href="part0014_split_000.html#page">Chapter 1</a>, <span class="strong"><em class="calibre10">Getting Started with OpenShift</em></span>, for details.</p></div></div>

<div class="book" title="Using the .htaccess file to configure Apache">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec427" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre6">Perform the following steps to enable the HTTP basic authentication:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create a new Python 2.7 application using the rhc command-line tool:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ rhc create-app myapp python-2.7</strong></span>
</pre></div></li><li class="listitem" value="2">Change the directory to <code class="email">myapp</code>, and create two files, <code class="email">.htaccess</code> and <code class="email">.htpasswd</code>, in the <code class="email">myapp</code> directory. If you are using a *nix machine, you can use the <code class="email">touch</code> command. On a Windows machine, you can use file explorer to create files. Have a look at the following commands:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ cd myapp</strong></span>
<span class="strong"><strong class="calibre7">$ touch .htaccess</strong></span>
<span class="strong"><strong class="calibre7">$ touch .htpasswd</strong></span>
</pre></div></li><li class="listitem" value="3">In <code class="email">.htaccess</code>, copy and paste the content as shown in the following code:<div class="informalexample"><pre class="programlisting">AuthType Basic
AuthName "Authentication Required"
AuthUserFile "$OPENSHIFT_REPO_DIR/.htpasswd"
Require valid-user</pre></div><p class="calibre14">Replace <code class="email">$OPENSHIFT_REPO_DIR</code> with the <code class="email">$OPENSHIFT_REPO_DIR</code> location of your application. To get the value of <code class="email">$OPENSHIFT_REPO_DIR</code>, run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ rhc ssh --command 'echo $OPENSHIFT_REPO_DIR'</strong></span>
</pre></div></li><li class="listitem" value="4">The <code class="email">.htpasswd</code> file is used to store username and password credentials. To generate a new username and password, you can use the online generator at <a class="calibre1" href="http://www.htaccesstools.com/htpasswd-generator/">http://www.htaccesstools.com/htpasswd-generator/</a>. For this recipe, the username and password combination is <code class="email">admin</code> and <code class="email">password</code> respectively. Place the content generated by the online tool in the <code class="email">.htpasswd</code> file. My <code class="email">.htpasswd</code> file looks as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">admin:$apr1$EVxfKxv/$2BIOIAPHOZiyx4k52b5jT1ewdfg</strong></span>
</pre></div></li><li class="listitem" value="5">Commit<a id="id884" class="calibre1"/> the code, and push the changes <a id="id885" class="calibre1"/>to the application gear:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">$ git add .</strong></span>
<span class="strong"><strong class="calibre7">$ git commit -am "added .htaccess and .htpasswd"</strong></span>
<span class="strong"><strong class="calibre7">$ git push</strong></span>
</pre></div></li><li class="listitem" value="6">After the application is deployed, open the application URL in your favorite web browser. This time, you will be greeted by a pop up asking you to enter the username and password, as shown in the following screenshot:<div class="mediaobject"><img src="../images/00104.jpeg" alt="How to do it…" class="calibre8"/></div><p class="calibre12"> </p></li><li class="listitem" value="7">After entering the <code class="email">admin</code>/<code class="email">password</code> combination, you will be able to enter your web application.</li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Using the .htaccess file to configure Apache">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec428" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre6">This recipe is another example of the flexibility that OpenShift offers to the application developers. There are a couple of ways you can configure the Apache web server. One way to configure the Apache web server is to update the main configuration file, usually named <code class="email">httpd.conf</code>. OpenShift does not allow users to update the <code class="email">httpd.conf</code> file. OpenShift allows users to configure the Apache web server via the <code class="email">.htaccess</code> file. The <code class="email">.htaccess</code> file provides a way to make configuration changes on a per-directory basis. This file can contain one or more configuration directives. These directives will then be applied to the directory in which the <code class="email">.htaccess</code> file exists and all its subdirectories.</p><p class="calibre6">In step 1, you created a new Python 2.7 application with the name <code class="email">myapp</code>. Then, in step 2, you created a couple of files—<code class="email">.htaccess</code> and <code class="email">.htpasswd</code>—in the <code class="email">myapp</code> directory. In step 3, you updated the content of the <code class="email">.htaccess</code> file with the HTTP basic authentication configuration. You can learn more from the documentation at <a class="calibre1" href="http://httpd.apache.org/docs/2.2/howto/auth.html">http://httpd.apache.org/docs/2.2/howto/auth.html</a>.</p><p class="calibre6">Next, in step 4, you<a id="id886" class="calibre1"/> generated content for the <code class="email">.htpasswd</code> file using an online <code class="email">.htpasswd</code> generator. You placed the content generated <a id="id887" class="calibre1"/>by generator in the <code class="email">.htpasswd</code> file and then committed all the changes in step 5. On successful deployment, you opened the application URL in the browser in step 6. You were asked to enter the <code class="email">admin</code>/<code class="email">password</code> username/password credentials. On entering the valid username/password combination, you were allowed to enter the application in step 7.</p></div></div>

<div class="book" title="Using the .htaccess file to configure Apache">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch08lvl2sec429" class="calibre1"/>See also</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">The <span class="strong"><em class="calibre10">Creating your first Python application</em></span> recipe</li><li class="listitem">The <span class="strong"><em class="calibre10">Creating and deploying Flask web applications using Python and PostgreSQL cartridges</em></span> recipe</li></ul></div></div></div></body></html>