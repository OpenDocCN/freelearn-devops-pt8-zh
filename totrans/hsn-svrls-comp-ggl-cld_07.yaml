- en: Exploring Functions as a Service
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索函数即服务（Functions as a Service）
- en: In this chapter, we will take a deep dive into Cloud Functions on Google Cloud.
    We have covered a fair bit already; however, there is still so much more to know
    and learn. Our primary focus so far has been to understand HTTP endpoints and
    to build some simple applications in order to demonstrate their associated capabilities.
    In addition to exciting HTTP event functionality, there are also background functions,
    that is, those functions that do not require access to an external HTTP endpoint.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入研究Google Cloud上的Cloud Functions。我们已经涵盖了相当一部分内容；然而，还有很多知识需要了解和学习。到目前为止，我们的主要关注点是理解HTTP端点，并构建一些简单的应用程序，以展示其相关功能。除了令人兴奋的HTTP事件功能外，还有后台功能，即那些不需要访问外部HTTP端点的功能。
- en: To increase our understanding of these types of functions, we will be building
    several tools throughout this chapter to illustrate various concepts and techniques.
    We will continue to utilize the Functions Framework to create our code, and start
    to integrate the external system in order to showcase the ease of building a tool
    that meets our requirements.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加深我们对这些类型函数的理解，我们将在本章中构建几个工具，以说明各种概念和技术。我们将继续利用Functions框架创建代码，并开始集成外部系统，以展示构建满足我们需求的工具的简便性。
- en: Later in this chapter, we will build a simple application based on creating
    a `SignedURL` function by utilizing Google APIs, which provides a way to establish
    a time-constrained URL. The source data for this will reside on Cloud Storage,
    and we will extend our function to have a simple frontend. Finally, we will continue
    to use the Functions Framework to enable us to work locally and to maintain compatibility
    with Google Cloud Functions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章稍后，我们将基于创建`SignedURL`函数，利用Google API来构建一个简单的应用程序，提供一种建立时间限制URL的方式。源数据将存储在Cloud
    Storage上，我们将扩展我们的函数，添加一个简单的前端。最后，我们将继续使用Functions框架，使我们能够在本地工作并保持与Google Cloud
    Functions的兼容性。
- en: 'In this chapter, we will learn about the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Developing an HTTP endpoint application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发HTTP端点应用程序
- en: Exploring Cloud Functions and Google APIs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Cloud Functions和Google API
- en: Exploring Google Cloud Storage events
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Google Cloud Storage事件
- en: Building an enhanced signed URL service
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建增强的签名URL服务
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete the exercises in this chapter, you will require a Google Cloud project
    or a Qwiklabs account.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章的练习，你需要一个Google Cloud项目或一个Qwiklabs账户。
- en: You can find the code files of this chapter in the GitHub repository for the
    book under the `ch05` subdirectory at [https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch05](https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch05).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在书籍的GitHub代码库中找到本章的代码文件，位于`ch05`子目录下，链接为[https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch05](https://github.com/PacktPublishing/Hands-on-Serverless-Computing-with-Google-Cloud/tree/master/ch05)。
- en: While you are going through code snippets in the book, you will notice that,
    in a few instances, a few lines from the code/output have been removed and replaced
    with dots (`...`). The use of ellipses is only to show relevant code/output. The
    complete code is available on GitHub at the previously mentioned link.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在书中浏览代码片段时，你会注意到在一些情况下，代码/输出中的几行已被移除，并用省略号（`...`）替代。使用省略号仅是为了显示相关的代码/输出。完整代码可以在GitHub上找到，链接已在前文提到。
- en: Developing an HTTP endpoint application
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发HTTP端点应用程序
- en: Working with Cloud Functions allows isolated and standalone components to create
    extended functionality. These components or microservices offer an excellent way
    to build your applications as decoupled architecture. In this example, we will
    go back to basics and learn how to extend our knowledge to call Google Cloud APIs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Cloud Functions可以让独立和孤立的组件创建扩展功能。这些组件或微服务提供了一个出色的方式来构建解耦的架构。在这个例子中，我们将回到基础，学习如何扩展我们的知识，以调用Google
    Cloud API。
- en: Events provide the ability to react to system notifications associated with
    a provider. As outlined in earlier chapters on Google Cloud, these providers present
    multiple options in which to extend services through defined provider interfaces
    such as Cloud Pub/Sub and Cloud Storage.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 事件提供了响应与提供者相关的系统通知的能力。如前几章关于Google Cloud所述，这些提供者通过定义的提供者接口（如Cloud Pub/Sub和Cloud
    Storage）呈现多个扩展服务的选项。
- en: We have already looked at the HTTP functions invoked using a URL. Utilizing
    the same semantic notation (for example, GET/POST) and signature (for example,
    request/response) for HTTP communications, these types of functions are well understood
    and can build upon existing knowledge. Due to the abstraction of HTTP complexities
    over time, the general understanding of the HTTP construct represents a well-understood
    API.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过通过 URL 调用的 HTTP 函数。利用相同的语义标记（例如，GET/POST）和签名（例如，请求/响应）进行 HTTP 通信，这些类型的函数已经得到广泛理解，并可以在现有知识的基础上构建。由于
    HTTP 的复杂性随着时间的推移逐渐抽象化，HTTP 构造的普遍理解代表了一个被广泛理解的 API。
- en: However, not everything will support an HTTP endpoint; therefore, another approach
    for integrating providers with existing services is required. Background (that
    is, asynchronous) functions enhance the Cloud Functions model beyond parameters
    to establish middleware interfaces that are capable of passing data between disparate
    components. Examples of these types of providers include Cloud Pub/Sub and Cloud
    Storage, which both offer a rich interface for messaging and event notifications.
    In both instances, any data presented must conform to the standard supported schemas
    to be capable of responding to the provider interface.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有内容都支持 HTTP 端点；因此，需要另一种将提供者与现有服务集成的方法。后台（即异步）功能扩展了 Cloud Functions 模型，通过参数建立中间件接口，能够在不同组件之间传递数据。这类提供者的示例包括
    Cloud Pub/Sub 和 Cloud Storage，它们都提供了丰富的消息传递和事件通知接口。在这两种情况下，任何呈现的数据都必须符合支持的标准模式，才能响应提供者接口。
- en: Additionally, a trigger needs to be defined in order to invoke background Cloud
    Functions. However, the integration mechanism changes depending on the trigger
    used. Over the following sections, we will focus our discussion on the different
    types of triggers available on Google Cloud. For background functions, Cloud Pub/Sub
    and Cloud Storage will be the primary areas of discussion; however, there many
    other trigger types that are available for an application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还需要定义触发器以调用后台 Cloud Functions。然而，集成机制会根据使用的触发器而变化。在接下来的章节中，我们将重点讨论 Google
    Cloud 上可用的不同类型的触发器。对于后台功能，Cloud Pub/Sub 和 Cloud Storage 将是主要讨论的领域；然而，还有许多其他触发器类型可供应用程序使用。
- en: Triggering Cloud Pub/Sub
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发 Cloud Pub/Sub
- en: 'A Cloud Pub/Sub trigger is based on a message queue in which information is
    passed between the publisher and the subscriber:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Pub/Sub 触发器基于消息队列，在该队列中信息在发布者和订阅者之间传递：
- en: The *publisher* is responsible for the schema associated with the message to
    be propagated using a topic.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*发布者* 负责与主题一起传播消息的模式。'
- en: A *topic* indicates the available queue on which information consumption takes
    place.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*主题* 表示信息消费所在的可用队列。'
- en: The *subscriber* (consumer) of the message queue can read the associated information
    in the queue.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息队列的 *订阅者*（消费者）可以读取队列中关联的信息。
- en: 'It''s worth pointing out that, in general, subscriptions are either pull or
    push subscriptions, as shown in the following diagram:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，一般来说，订阅分为拉取订阅和推送订阅，如下图所示：
- en: '![](img/e2ba5f99-3c56-45a0-bde9-1af1d96de893.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2ba5f99-3c56-45a0-bde9-1af1d96de893.png)'
- en: In the preceding diagram, you can see an overview of the pull and push subscription
    types.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，您可以看到拉取和推送订阅类型的概述。
- en: For scenarios that require high levels of throughput, a pull mechanism is currently
    the most effective way to manage this type of requirement.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要高吞吐量的场景，当前拉取机制是管理此类需求的最有效方式。
- en: Having the publisher and subscriber together enables both sides of the message
    queue deliver a payload from the origin to the destination. Cloud Pub/Sub uses
    several scenarios in order to provide information to and from sources consistently.
    As you might expect, there are many design patterns associated with Cloud Pub/Sub
    that ensure the transmission of data occurs with a regularity scheduled for the
    service that is required.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 发布者和订阅者共同工作，使消息队列的两端能够将有效载荷从源头传送到目标。Cloud Pub/Sub 使用多种场景来提供信息的双向传输，确保源和目标之间的一致性。如你所料，Cloud
    Pub/Sub 关联了许多设计模式，确保数据传输按照所需的服务计划定期进行。
- en: The distribution of messages uses a globally distributed message bus that enables
    the exchange of information between systems. In this instance, an event system
    for Cloud Pub/Sub uses a push mechanism with Cloud Functions to trigger messages.
    A trigger type of `google.pubsub.topic.publish` is defined to manage events used
    by Cloud Functions, allowing you to have complete control over the publishing
    of events. For each message published, the notification of the event establishes
    the message payload to be published.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 消息的分发使用全球分布的消息总线，使得系统之间能够交换信息。在这种情况下，Cloud Pub/Sub 的事件系统使用推送机制与 Cloud Functions
    触发消息。定义了 `google.pubsub.topic.publish` 的触发器类型，用于管理 Cloud Functions 使用的事件，使你能够完全控制事件的发布。每次发布消息时，事件通知会确定要发布的消息负载。
- en: 'Besides this, Cloud Pub/Sub supports different design patterns depending on
    where you want to go. Subscribers will provide an acknowledgment for each message
    that is processed for every subscription. If a subscriber cannot acknowledge a
    message within the `ackDeadline` threshold, then the message payload is re-sent.
    Based on your own use case, the following patterns are good examples to consider
    when thinking about incorporating Cloud Pub/Sub into your design:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，Cloud Pub/Sub 支持根据你的需求不同的设计模式。订阅者会为每个处理过的消息提供确认。若订阅者在 `ackDeadline` 阈值内未能确认消息，则该消息负载会被重新发送。根据你的使用场景，以下模式是考虑将
    Cloud Pub/Sub 纳入设计时的良好示例：
- en: '| **Pattern** | **Description** |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| **模式** | **描述** |'
- en: '| Straight-through processing | A simple queue mechanism—from topic to subscription.
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 直通处理 | 简单的队列机制——从主题到订阅。 |'
- en: '| Multiple publishers | Multiple publishers of the same topic—this enables
    the concurrent processing of a source message. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 多个发布者 | 同一主题的多个发布者——这使得源消息可以并发处理。 |'
- en: '| Multiple subscribers | Multiple subscribers to the same subscription—this
    enables you to have different subscribers for the originating topic consumed through
    subscription. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 多个订阅者 | 同一订阅的多个订阅者——这使你可以为通过订阅消费的原始主题设置不同的订阅者。 |'
- en: An event for Cloud Pub/Sub has the defined trigger value of `google.pubsub.topic.publish`.
    The event notification is triggered when a payload message publishes to the event
    type associated with a Cloud Function. Input data will take the message payload
    that is passed and execute the named Cloud Function to establish data to any subscriber
    set to receive information.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Pub/Sub 的事件具有定义的触发器值 `google.pubsub.topic.publish`。当有效负载消息发布到与 Cloud Function
    关联的事件类型时，事件通知会被触发。输入数据将包含传递的消息负载，并执行指定的 Cloud Function，以将数据传递给任何设置为接收信息的订阅者。
- en: 'The following example illustrates how you can use a background function with
    Cloud Pub/Sub; the blueprint code that is shown represents the default function
    used by Google:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了如何使用 Cloud Pub/Sub 和后台函数；展示的蓝图代码代表了 Google 使用的默认函数：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, the signature relating to the background function definition
    remains consistent. We define an `exports` function onto which the trigger establishes
    a corresponding action. The service related to the event information to be used
    requires parameters, that is, event payload data and event metadata. In the Cloud
    Pub/Sub Cloud Functions example, the function will take the input to the message
    queue and display the content as a log entry.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，背景函数定义的签名保持一致。我们定义了一个 `exports` 函数，触发器在此上定义了相应的操作。与事件信息相关的服务需要参数，即事件负载数据和事件元数据。在
    Cloud Pub/Sub 的 Cloud Functions 示例中，该函数将获取消息队列的输入并将内容显示为日志条目。
- en: Creating an event type trigger of the Cloud Pub/Sub type requires a topic to
    be created as part of the initiation of the function. Once created, testing the
    service presents the same properties that we saw previously with the HTTP trigger,
    for example, region, memory allocation, timeout, and last deployment. However,
    here, the HTTP endpoint is replaced with the trigger type of Cloud Pub/Sub and
    the associated defined topic.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Cloud Pub/Sub 类型的事件触发器需要在函数初始化时创建一个主题。创建后，测试该服务展示的属性与我们之前看到的 HTTP 触发器相同，例如区域、内存分配、超时和最后的部署。然而，在这里，HTTP
    端点被 Cloud Pub/Sub 的触发器类型及其关联的定义主题所替代。
- en: 'To test the function, an important thing to remember is that Cloud Pub/Sub
    expects its data to be formatted as `base64`. Follow these two steps:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 测试该功能时，需要记住一个重要事项，那就是 Cloud Pub/Sub 期望其数据格式为 `base64`。请按照以下两个步骤进行操作：
- en: 'Transpose the data to `base64` to trigger an event from the Cloud Functions
    testing page. Thankfully, you can do this from Google Cloud Shell by entering
    the following on the command line:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据转换为`base64`以触发来自 Cloud Functions 测试页面的事件。幸运的是，你可以通过在命令行输入以下内容，在 Google Cloud
    Shell 中完成此操作：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output of the preceding command shows the `base64` equivalent of the text
    entered:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面命令的输出显示了输入文本的`base64`等效形式：
- en: '![](img/a87f23d7-5ef0-4081-a137-5ab284161809.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a87f23d7-5ef0-4081-a137-5ab284161809.png)'
- en: In the preceding example, we need to convert the information using `base64`
    manually. If you were to use the Cloud Pub/Submenu item or the `gcloud pubsub
    topics publish` command, both of these tools will automatically convert your text
    message.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们需要手动使用`base64`转换信息。如果你使用 Cloud Pub/Sub 菜单项或`gcloud pubsub topics publish`命令，这两个工具将自动转换你的文本消息。
- en: From the preceding, you may discern the raw power of this event type, as it
    can pass information between multiple services. For example, Stackdriver supports
    Cloud Pub/Sub interfaces (a Stackdriver sink). Understanding this means that it
    is possible to use Cloud Pub/Sub to invoke a coupling across services, such as
    publishing information in Stackdriver and consuming this data in services such
    as BigQuery or Cloud Storage.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的内容中，你可以看出这个事件类型的原始力量，因为它可以在多个服务之间传递信息。例如，Stackdriver 支持 Cloud Pub/Sub 接口（Stackdriver
    接收端）。了解这一点意味着可以使用 Cloud Pub/Sub 来在服务之间调用，例如，在 Stackdriver 中发布信息，并在 BigQuery 或
    Cloud Storage 等服务中消费这些数据。
- en: Now that we know a bit more about the power and versatility of Cloud Pub/Sub,
    we can turn our attention to Cloud Storage.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 Cloud Pub/Sub 的功能和多样性有了更多了解，我们可以将注意力转向 Cloud Storage。
- en: Triggering Cloud Storage
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发 Cloud Storage
- en: As indicated in earlier chapters, Cloud Storage is an object data store that
    has an associated life cycle and event notification. More commonly referred to
    as a bucket, Cloud Storage adds a highly functional notification mechanism to
    your arsenal. Having the ability to incorporate intermediary storage into your
    application opens up greater possibilities, and it provides the means to apply
    stage gating as part of any processing via the associated event types that are
    supported. The flexibility of this solution means that it is a useful service
    to familiarize yourself with, as the storage can be adopted for multiple scenarios.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，Cloud Storage 是一个具有生命周期和事件通知的对象数据存储。通常被称为桶（bucket），Cloud Storage 为你的工具库添加了一个高功能的通知机制。能够将中间存储集成到应用程序中，开辟了更多可能性，并且通过支持的关联事件类型，提供了将阶段门控应用于任何处理过程的手段。这种解决方案的灵活性意味着它是一个值得熟悉的服务，因为这种存储可以适用于多种场景。
- en: The typical use cases for storage is that of either temporary storage (that
    is, where an application might need to store an intermediary file such as audio
    or text output) or as a cheap form of storage for something like a static website.
    Later in this chapter, we will present an example for building a simple website
    that can be used to show information, based on a defined template.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 存储的典型用例是临时存储（即应用程序可能需要存储一个中间文件，如音频或文本输出），或者作为一种廉价的存储形式，用于像静态网站这样的东西。在本章稍后，我们将展示一个示例，构建一个简单的网站，基于定义的模板来显示信息。
- en: Cloud storage can be used in a number of different ways; however, here, we will
    primarily focus on using this as storage. Event types focus on the notification
    of actions such as `finalize`, `delete`, `archive`, and `metadataUpdate`. It should
    be noted that the notification mechanism for storage leverages Cloud Pub/Sub notifications
    to ensure scalable and flexible messaging.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Storage 可以以多种不同的方式使用；然而，在这里，我们将主要集中在将其用作存储。事件类型关注的是通知诸如`finalize`、`delete`、`archive`和`metadataUpdate`等操作。需要注意的是，存储的通知机制利用
    Cloud Pub/Sub 通知，以确保可扩展和灵活的消息传递。
- en: Over the course of this section, we will cover a few of the most common use
    cases for Cloud Storage. In addition to this, the event type mentions that you
    are still able to retain all the existing benefits, for example, life cycle access,
    API access, support of different storage classes, and secure/durable storage.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖 Cloud Storage 的一些最常见的用例。除此之外，事件类型还提到，你仍然可以保留所有现有的好处，例如生命周期访问、API
    访问、支持不同存储类别以及安全/持久存储。
- en: 'Google provides a wealth of APIs and learning how to access these APIs gives
    you the opportunity to access different services. Due to the richness of the Cloud
    Storage API, there are a number of event types that are supported. The most common,
    perhaps, is the creation of an object within Cloud Storage:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Google 提供了丰富的 API，学习如何访问这些 API 为您提供了访问不同服务的机会。由于 Cloud Storage API 的丰富性，支持许多事件类型。最常见的事件类型可能是
    Cloud Storage 中对象的创建：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding example, a notification occurs when an *object creation* event
    is generated from the bucket object. When setting up the function, an essential
    requirement is to specify a storage bucket on which the action will respond.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，当存储桶对象生成 *对象创建* 事件时，会触发通知。在设置函数时，一个关键要求是指定一个存储桶，函数将在其上响应操作。
- en: Notably, there are several parameters supported that enable an application to
    derive further information about the state of the calling object. If an event
    has passed additional metadata, this high-level event metadata (of the type invocation
    information) is also accessible. Additionally, background functions can utilize
    other properties, such as data that contains the message to be processed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，支持多个参数，使应用程序能够获取调用对象状态的进一步信息。如果事件传递了附加的元数据，这些高级事件元数据（如调用信息类型）也可以访问。此外，后台函数可以利用其他属性，如包含要处理的消息的数据。
- en: A notification emitting from the function has a similar pattern across each
    of the notification types. This event structure is one that you should aim to
    become familiar with, as the use of functions is very consistent, irrespective
    of the kind of service used.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从函数发出的通知在每种通知类型中都有类似的模式。您应该熟悉这种事件结构，因为无论使用何种服务，函数的使用模式都是非常一致的。
- en: 'The specific function referenced by the Google Cloud Storage event is captured
    in the event parameter, which is passed to the Cloud Function when the service
    is run. The blueprint code listed previously will log the event notification that
    has been processed along with the name of the file residing within the bucket.
    Outside, more essential services include additional triggers such as Firebase
    Authentication. However, the patterns outlined follow for these functions, and
    it should be a smooth and easy transition to be able to work with any of these
    other function triggers as they become available:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cloud Storage 事件所引用的具体功能被捕获在事件参数中，这些参数会在服务运行时传递给 Cloud Function。前面列出的蓝图代码将记录已处理的事件通知以及存储在存储桶中的文件名。除此之外，更为关键的服务包括
    Firebase Authentication 等额外触发器。然而，这些函数的模式在这里有所展示，随着其他触发器的可用，您应该能够平滑过渡并使用它们：
- en: Google Cloud Firestore
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Cloud Firestore
- en: Google Analytics for Firebase
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Analytics for Firebase
- en: Firebase Authentication
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firebase Authentication
- en: Firebase Realtime Database
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firebase Realtime Database
- en: Firebase Remote Config
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firebase Remote Config
- en: At this point, you will hopefully be thinking about how to incorporate some
    of these trigger types into your application. When working with functions, it
    is essential to remember that the services should be short-lived and built around
    lightweight components. Clearly, there are many cases and examples that are both
    innovative and useful that will show how to use the code in a real-world example.
    The documentation for Cloud Functions is amazingly detailed and can provide answers
    to many of the queries you may come across in your implementations.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到这时，您应该开始思考如何将这些触发器类型纳入到您的应用程序中。在使用函数时，重要的是要记住，服务应该是短暂的，并围绕轻量级组件构建。显然，有很多创新且实用的案例和示例将展示如何在实际应用中使用这些代码。Cloud
    Functions 的文档极其详细，能够回答您在实现过程中可能遇到的许多问题。
- en: Later in this chapter, we will be looking at some use cases that utilize these
    notification types. First, we will look at how to utilize the vast software library
    of Google APIs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 本章稍后，我们将查看一些使用这些通知类型的案例。首先，我们将看看如何利用 Google API 的丰富软件库。
- en: Exploring Cloud Functions and Google APIs
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Cloud Functions 和 Google APIs
- en: In this example, we will build an application that will use Cloud Pub/Sub to
    provide resilient access to a document. Earlier, we introduced our new friend,
    Google Cloud Pub. Now we will get to see how we can utilize this feature as part
    of a simple solution.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将构建一个使用 Cloud Pub/Sub 提供弹性文档访问的应用程序。之前，我们介绍了我们的新朋友，Google Cloud Pub。现在我们将看到如何将此功能作为一个简单解决方案的一部分来利用。
- en: Our application will create a time-constrained link to a text file, which can
    only be accessed by an authenticated source. This type of functionality is actually
    an everyday use case for transferring data securely across the internet.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将创建一个时效性链接指向一个文本文件，只有经过身份验证的源才能访问。这个功能实际上是一个常见的日常用例，用于通过互联网安全地传输数据。
- en: General architecture
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用架构
- en: 'To create a signed URL, we will need an existing file that has been uploaded
    to a storage bucket. For the sake of this example, we will take the following
    approach in terms of the types of functions to be developed:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个签名 URL，我们需要一个已经上传到存储桶中的现有文件。为了这个示例，我们将采取以下方法来开发所需的功能：
- en: '![](img/beb8344e-a02a-48dd-b13a-041c32c40204.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/beb8344e-a02a-48dd-b13a-041c32c40204.png)'
- en: 'From the preceding diagram, we are going to create two services in order to
    create a signed URL:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图示来看，我们将创建两个服务来创建一个签名 URL：
- en: '**Frontend service**: A straightforward service that will be based on an HTTP
    endpoint and be made publically available.'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**前端服务**：一个基于 HTTP 端点的简单服务，并将公开可用。'
- en: '**Backend service**: A second service that will be used to perform the background
    function of creating the signed URL.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**后端服务**：第二个服务，用于执行创建签名 URL 的后台功能。'
- en: Let's understand each service in more detail next.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更详细地了解每个服务。
- en: Frontend service
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端服务
- en: Our primary export function named `gcpSecureURL` accepts a request and response
    parameters, indicating that this is an HTTP function. This signature is consistent
    across all Cloud Functions and provides a common way to pass and receive information
    in an application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要导出函数名为`gcpSecureURL`，它接受请求和响应参数，表明这是一个 HTTP 函数。这个签名在所有 Cloud Functions
    中是一致的，提供了一种通用的方式来传递和接收应用程序中的信息。
- en: From the architecture diagram previously presented, it should be apparent that
    our frontend service uses Cloud Pub/Sub. As described earlier in this chapter,
    we can use Pub/Sub to provide information to our application. In this example,
    we are using the initial request information and adding this to the message queue
    of Cloud Pub/Sub.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前展示的架构图中，应该能明显看出我们的前端服务使用了 Cloud Pub/Sub。如本章前面所述，我们可以使用 Pub/Sub 向应用程序提供信息。在本例中，我们使用初始请求信息并将其添加到
    Cloud Pub/Sub 的消息队列中。
- en: 'To start, we need to initialize our environment once more:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要再次初始化我们的环境：
- en: Create a new directory called `ch05` and make this the current directory.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ch05`的新目录，并将其设为当前目录。
- en: Create a new subdirectory called `frontend-service`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`frontend-service`的新子目录。
- en: Create a second new subdirectory called `backend-service`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`backend-service`的第二个新子目录。
- en: 'At this point, you will have the following directory structure:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到此时，您将拥有以下目录结构：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Make `frontend-service` the current directory.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`frontend-service`设置为当前目录。
- en: Initialize the `npm` package for this directory, that is, `npm init --yes`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化该目录的`npm`包，即`npm init --yes`。
- en: Then, add the `pubsub` package, that is, `npm install @google-cloud/pubsub`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加`pubsub`包，即`npm install @google-cloud/pubsub`。
- en: 'In order to process the information presented at the frontend, we need to create
    a new application:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理前端呈现的信息，我们需要创建一个新的应用程序：
- en: Create a new file called `index.js`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`index.js`的新文件。
- en: 'Add the following code to `index.js`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`index.js`：
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The entry point for the code is the `gcpSecureURL` function. Here is an overview
    of this application''s activities:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的入口点是`gcpSecureURL`函数。以下是此应用程序活动的概述：
- en: From here, we call the `gcpCreatePayload` function with an example filename,
    for example, `google-cloud.png`.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们使用一个示例文件名（例如，`google-cloud.png`）调用`gcpCreatePayload`函数。
- en: The `gcpCreatePayload` function performs a single task in order to establish
    a new topic and publish the filename to it.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gcpCreatePayload`函数执行一个单一任务，用于创建一个新主题并将文件名发布到该主题。'
- en: After this action has been taken, the application will return a `200` HTTP response
    code and output a message indicating that a secure URL has been created for the
    filename.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行此操作后，应用程序将返回一个`200` HTTP 响应代码，并输出一条消息，指示已为文件名创建了一个安全 URL。
- en: 'To deploy the function, we take the normal steps for an HTTP endpoint, that
    is, the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署该函数，我们按照 HTTP 端点的常规步骤操作，即以下步骤：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As mentioned previously, we are going to use Cloud Pub/Sub; therefore, we need
    to create a topic to enable communication to take place:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将使用 Cloud Pub/Sub，因此我们需要创建一个主题以便进行通信：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Congratulations! The frontend application has been successfully deployed and
    is ready to serve filenames to Cloud Pub/Sub.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！前端应用程序已成功部署，并准备将文件名传递给Cloud Pub/Sub。
- en: Backend service
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后端服务
- en: Now that we have the frontend service created, what is left to do? Well, so
    far we have essentially been creating a queue of files to be processed. In this
    section, we will set about processing the filenames that have been added to the
    message queue.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经创建了前端服务，接下来该做什么？到目前为止，我们基本上是在创建一个待处理文件的队列。在这一部分，我们将开始处理已添加到消息队列中的文件名。
- en: 'Once again, we need to reinitialize our environment—this time, focusing our
    efforts on the `backend-service` subdirectory:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们需要重新初始化我们的环境——这一次，集中精力在`backend-service`子目录：
- en: Move to the `backend-service` subdirectory created earlier.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到之前创建的`backend-service`子目录。
- en: Initialize the `npm` package for this directory, that is, `npm init --yes`.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此目录初始化`npm`包，即执行`npm init --yes`。
- en: Add the `pubsub` package, that is, `npm install @google-cloud/pubsub`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`pubsub`包，即执行`npm install @google-cloud/pubsub`。
- en: Then, add the Cloud Storage package, that is, `npm install @google-cloud/storage`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加云存储包，即执行`npm install @google-cloud/storage`。
- en: 'In order to process the information presented at the backend, we need to create
    a new application:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理后端展示的信息，我们需要创建一个新的应用程序：
- en: Create a new file called `index.js`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件，命名为`index.js`。
- en: 'Add the following code to `index.js`:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`index.js`中：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding code, we will take information from a message queue and convert
    it from `base64`. The information presented should represent the example filename
    passed. Using a console log message, we can confirm that it has been correctly
    accessed. Deploy this initial revision of the code in order to check our assumption:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将从消息队列中获取信息，并将其从`base64`格式转换。展示的信息应代表传递的示例文件名。通过控制台日志消息，我们可以确认信息已正确访问。部署此代码的初始版本，以便验证我们的假设：
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'At this point, we now have two Cloud Functions deployed on Google Cloud:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在Google Cloud上部署了两个云函数：
- en: '| **Name** | **Function type** |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **功能类型** |'
- en: '| `gcpSecureURL` | HTTP endpoint function |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `gcpSecureURL` | HTTP端点函数 |'
- en: '| `gcpCreateSignedURL` | Background function |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `gcpCreateSignedURL` | 背景函数 |'
- en: 'Testing the functions can be done via the Cloud Console using the `trigger`
    commands. Go to the Cloud Functions option in Google Cloud and select the function
    for accessing the required command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过Cloud Console使用`trigger`命令来测试这些函数。进入Google Cloud的Cloud Functions选项，并选择需要的命令函数：
- en: Select the trigger from the menu and choose the URL associated with `gcpSecureURL`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中选择触发器，并选择与`gcpSecureURL`相关的URL。
- en: 'The function will display the message `Creating a secure URL for: google-cloud.png`.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '函数将显示消息`Creating a secure URL for: google-cloud.png`。'
- en: Now select the second `gcpCreateSignedURL` function.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在选择第二个`gcpCreateSignedURL`函数。
- en: From the invocation list, it can be seen that this function has been called.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从调用列表中可以看到，这个函数已经被调用。
- en: Then, select the view logs options to see the associated log messages.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择查看日志选项，以查看相关的日志消息。
- en: 'Observe the message, `gcpCreateSignedURL: google-cloud.png`, in the logs.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在日志中观察到消息`gcpCreateSignedURL: google-cloud.png`。'
- en: Congratulations! The `gcpCreateSignedURL` (backend) service has been successfully
    deployed and is receiving messages from the `gcpSecureURL` (frontend) service.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！`gcpCreateSignedURL`（后端）服务已成功部署，并开始接收来自`gcpSecureURL`（前端）服务的消息。
- en: At this point in the development, we are unapologetically using unauthenticated
    invocations of our functions, as this makes the development process more straightforward.
    In a production environment, this approach would be unacceptable. As there are
    components for both the frontend and the backend, one approach would be to amend
    the permissions so only the `gcpSecureURL` is able to call the `gcpCreateSignedURL`
    service. Toward the end of the chapter, we will come to a different conclusion
    on how to address this particular issue.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，我们毫不掩饰地使用未经身份验证的函数调用，因为这使开发过程更加直接。在生产环境中，这种方法是不可接受的。由于前端和后端都有组件，一种方法是修改权限，使得只有`gcpSecureURL`能够调用`gcpCreateSignedURL`服务。在本章的后面部分，我们将得出不同的结论，来解决这个特定问题。
- en: Our application is really progressing quite quickly. Now we need to add the
    signed URL processing capability to our existing `gcpCreateSignedURL` backend
    code.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序进展得相当迅速。现在，我们需要将签名URL处理功能添加到现有的`gcpCreateSignedURL`后端代码中。
- en: 'To process the information presented at the backend, we need to create a new
    application:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理后端提供的信息，我们需要创建一个新应用：
- en: Edit the `index.js` file.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `index.js` 文件。
- en: 'Add the following code to the top of the existing `index.js` file:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到现有 `index.js` 文件的顶部：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, we make some assumptions regarding the bucket and filename
    for the purposes of brevity. As you can see, the function performs one task, which
    is to create a signed URL. Again, we use the `console.log` function for debugging
    purposes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，为了简洁，我们对存储桶和文件名做了一些假设。如你所见，函数执行的任务是创建一个签名 URL。再次强调，我们使用 `console.log`
    函数进行调试。
- en: Additionally, we also need to add some definitions to our code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要向代码中添加一些定义。
- en: 'Add the following code to the top of the existing `index.js` file:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到现有 `index.js` 文件的顶部：
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the code extract, we need to ensure that the both variables' names `bucketName`
    and `filename` exist in your project before running the application. In addition
    to this, **make sure that the expiration date is set to a future date**, taking
    note of the expected format. We will fix that in a later revision; however, for
    now, just remember that these attributes are valid for your project.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段中，我们需要确保项目中存在变量名 `bucketName` 和 `filename`，在运行应用程序之前检查这一点。此外，**确保过期日期设置为未来的日期**，并注意格式要求。我们会在后续版本中修复这个问题；不过现在，只需要记住这些属性对你的项目是有效的。
- en: 'Finally, we want to reference our new `SignedURL` function within the subdirectory
    `backend-service` :'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们想在子目录 `backend-service` 中引用我们的新 `SignedURL` 函数：
- en: 'Edit the `index.js` file and amend the entry point function:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `index.js` 文件并修改入口函数：
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Based on the preceding enhancements, we are now ready to deploy the updated
    version of `gcpCreateSignedURL` (that is, the `backend-service`)
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于之前的改进，我们现在准备部署更新版本的 `gcpCreateSignedURL`（即 `backend-service`）。
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To test the newly deployed `backend-service`, we replicate the process that
    we followed earlier. Go to the Cloud Functions option in Google Cloud and invoke
    the `frontend-service` by pressing the associated URL available in the Cloud Console.
    Then, observe the logs for the `backend-service` as the information is processed
    and logs messages.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试新部署的 `backend-service`，我们重复之前的过程。前往 Google Cloud 中的 Cloud Functions 选项，并通过按下
    Cloud Console 中的关联 URL 来调用 `frontend-service`。然后，观察 `backend-service` 的日志，查看信息是如何处理并记录的。
- en: Congratulations! The logs contain a reference to the signed URL for the file
    presented. We have covered a lot of important context in this section. Continue
    to the next section to work on an example using Cloud Storage.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！日志中包含了指向所展示文件签名 URL 的引用。我们在这一部分涵盖了很多重要的上下文。继续到下一部分，使用云存储进行示例操作。
- en: Exploring Google Cloud Storage events
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Google Cloud Storage 事件
- en: In this example, we want to expand our understanding of background functions.
    In particular, we will be integrating with Cloud Storage in order to automate
    object life cycle management.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们希望扩展对后台函数的理解。特别是，我们将与 Cloud Storage 集成，以实现自动化对象生命周期管理。
- en: Taking advantage of existing functionality (for example, packages and libraries)
    is an excellent way to build your application. In this example, we will leverage
    Google Cloud Storage encrypted by default to develop a secure data solution.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 利用现有的功能（例如，包和库）是构建应用程序的绝佳方式。在这个例子中，我们将利用默认加密的 Google Cloud Storage 来开发一个安全的数据解决方案。
- en: General architecture
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一般架构
- en: 'The main difference from our Cloud Pub/Sub example will be the notifications
    that we attach to Cloud Storage. In this example, we will want the storage bucket
    to initiate the request to provide a `SignedURL` function, rather than having
    to invoke our function manually. Remember, in the first version of our application,
    there was no event notification between the storage bucket and the `frontend-service`—let''s
    fix that:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的 Cloud Pub/Sub 示例的主要区别在于我们将通知附加到 Cloud Storage。在这个示例中，我们希望存储桶发起请求来提供 `SignedURL`
    函数，而不是手动调用我们的函数。请记住，在我们应用程序的第一个版本中，存储桶和 `frontend-service` 之间没有事件通知——我们来修复这一点：
- en: '![](img/d57ad862-00c7-46c7-b0d9-db31cc9e75ce.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d57ad862-00c7-46c7-b0d9-db31cc9e75ce.png)'
- en: 'From the diagram, we will introduce an additional service to react to storage
    event notifications (that is, create/finalize):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从图表中，我们将引入一个额外的服务来响应存储事件通知（即，创建/完成）：
- en: '**Storage**: A file is uploaded to the storage bucket.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储**：文件已上传到存储桶。'
- en: '**Stream Processing**: A notification is generated as well as a payload containing
    the filename.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流处理**：生成通知以及包含文件名的有效负载。'
- en: '**SignedURL Frontend Service**: This maintains a subscription to a topic and
    invokes its function on receipt of a new payload.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**签名URL前端服务**：此服务保持对主题的订阅，并在接收到新有效负载时调用其函数。'
- en: '**SignedURL Backend Service**: This performs the background function of creating
    the signed URL.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**签名URL后台服务**：执行创建签名URL的后台功能。'
- en: 'We need to make two changes to our existing code to enable this functionality.
    First, we need to amend the frontend service:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对现有代码进行两处修改，以启用此功能。首先，我们需要修改前端服务：
- en: '**Frontend service**: Amend the code.'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**前端服务**：修改代码。'
- en: '**Storage service**: Set up a new notification.'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**存储服务**：设置新的通知。'
- en: Frontend service
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端服务
- en: 'As you may have guessed, the signature for a Cloud Storage trigger is different
    from an HTTP endpoint. Therefore, the code in `frontend-service` subdirectory
    will require a small amendment to retain compatibility. We need to change our
    application code so that we can process the information correctly:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜测的，Cloud Storage触发器的签名与HTTP端点不同。因此，`frontend-service`子目录中的代码需要做一个小的修改，以保持兼容性。我们需要修改应用程序代码，以便正确处理信息：
- en: In the `frontend-service` subdirectory, edit the `index.js` file.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`frontend-service`子目录中，编辑`index.js`文件。
- en: Remove the existing `gcpSecureURL` function as this relates to an HTTP endpoint.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除现有的`gcpSecureURL`函数，因为它与HTTP端点相关。
- en: 'Add the following code so that the Cloud Storage trigger can be processed:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，以便处理Cloud Storage触发器：
- en: '[PRE13]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note how the signature for `gcpSecureURL` is now using data and context as we
    are now referencing information from Cloud Storage. Compare this to previous examples
    that use request and response for HTTP based triggers.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`gcpSecureURL`的签名现在使用了数据和上下文，因为我们现在引用的是Cloud Storage中的信息。与之前使用HTTP触发器的请求和响应相比，请进行对比。
- en: Congratulations! The `gcpSecureURL frontend-service` is now able to accept notifications
    from Cloud Storage. Let's move on to establishing a suitable trigger for the storage
    bucket used in our project.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！`gcpSecureURL前端服务`现在能够接受来自Cloud Storage的通知。让我们继续为我们项目中使用的存储桶建立合适的触发器。
- en: Storage service
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储服务
- en: To enable the storage service, unlike the previous section, we need to let Google
    Cloud Storage know that we want to receive notifications. Due to the richness
    of the API associated with storage, there is also another command that we need
    to use, `gsutil`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用存储服务，与前一部分不同，我们需要让Google Cloud Storage知道我们想接收通知。由于与存储相关的API功能非常丰富，我们还需要使用另一个命令`gsutil`。
- en: 'From the command line, we need to tell our storage bucket which notification
    event we want to monitor. Besides that, we also want it to inform us when something
    has happened. [Chapter 4](9431bfa5-ef43-4043-9779-d5b6d3fef36c.xhtml), *Developing
    Cloud Functions*, contains the Cloud Storage triggers that are supported. Specifically,
    the one relevant to our task is `google.storage.object.finalize` (that is, the
    `finalize`/`create` activities), which includes the events based on the creation
    of an object within a bucket:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行，我们需要告诉存储桶我们希望监控哪些通知事件。此外，我们还希望它在发生某些事件时通知我们。[第4章](9431bfa5-ef43-4043-9779-d5b6d3fef36c.xhtml)，*开发云函数*，包含了Cloud
    Storage支持的触发器。具体来说，和我们任务相关的是`google.storage.object.finalize`（即`finalize`/`create`活动），它包括基于存储桶内对象创建的事件：
- en: Delete the existing `gcpSecureURL` Cloud Function.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除现有的`gcpSecureURL`云函数。
- en: 'Deploy the `frontend` function with a trigger based on the bucket resource:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用基于存储桶资源的触发器部署`frontend`函数：
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the above code my bucket is defined as `roselabs-signed-upload` which is
    unique to my application. In your project, the bucket should be named appropriately
    based on your Google Cloud project settings.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我的存储桶被定义为`roselabs-signed-upload`，这是我应用程序独有的。在你的项目中，存储桶的名称应根据你的Google
    Cloud项目设置进行命名。
- en: Upload a file to the bucket. This can be any file you have handy.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向存储桶上传一个文件。这可以是你手头的任何文件。
- en: The `gcpSecureURL` will now be invoked through a Cloud Pub/Sub notification.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gcpSecureURL`将通过Cloud Pub/Sub通知被调用。'
- en: Congratulations, integrating notifications within an application is a huge time-saver.
    In the next section, we will enhance the function in order to learn how to integrate
    it with Google Cloud Services.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，将通知集成到应用程序中是一个巨大的时间节省。在下一部分中，我们将增强功能，学习如何将其与Google Cloud服务集成。
- en: Building an enhanced signed URL service
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建增强版签名 URL 服务
- en: In the final revision of the application, we will fix some of the apparent issues
    with the Cloud Function. The main thing that needs addressing is the hard coding
    of the bucket reference, filename, and expiration date. One option would be to
    provide a nice graphical frontend for the application. However—spoiler alert—we
    won't be taking that approach here.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的最终修订中，我们将修复一些明显的问题，特别是 Cloud Function 的问题。需要解决的主要问题是存储桶引用、文件名和到期日期的硬编码。一个可选方案是为应用程序提供一个漂亮的图形前端界面。然而——剧透警告——我们在这里不会采用这种方法。
- en: 'To conclude the application, we need to correct three things to make the Cloud
    Function super useful:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成应用程序，我们需要纠正三件事，以使 Cloud Function 更加有用：
- en: Filename
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件名
- en: Bucket reference
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储桶引用
- en: Expiration date
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到期日期
- en: Small changes can have a substantive impact, and these three things will make
    the application significantly better. To make the changes, we need to amend both
    services and pass additional variables from one service to another. Remember,
    we have previously implemented Cloud Pub/Sub to pass information between our services.
    Now we need to expand this approach. But will this make the task more difficult?
    By enhancing the components in turn and discussing the impact it has, we will
    answer this question as we start our enhancement journey with the frontend service.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 小的改变可能带来实质性的影响，这三项修改将大大改善应用程序。为了进行这些修改，我们需要同时修改两个服务，并从一个服务传递额外的变量到另一个服务。记住，我们之前已经实现了
    Cloud Pub/Sub 来在服务之间传递信息。现在我们需要扩展这一方法。但这会使任务更难吗？通过逐步增强组件并讨论其影响，我们将在开始前端服务的增强之旅时解答这个问题。
- en: Frontend service
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端服务
- en: In terms of the frontend service, the application currently sends the filename
    as the payload. However, we are missing a trick here, as the Cloud Storage data
    object actually includes some really useful information.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 就前端服务而言，应用程序当前将文件名作为负载发送。然而，我们在这里漏掉了一个技巧，因为 Cloud Storage 数据对象实际上包含一些非常有用的信息。
- en: '**Cl****oud Storage context object**:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cloud Storage 上下文对象**：'
- en: The following table contains the information associated with a context object.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格包含与上下文对象相关的信息。
- en: '| **Object** | **Field** |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| **Object** | **Field** |'
- en: '| `Context` | `eventId` |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `Context` | `eventId` |'
- en: '| `Context` | `eventType` |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `Context` | `eventType` |'
- en: '**Cloud Storage data object**:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cloud Storage 数据对象**：'
- en: The following table outlines the information associated with a data object.
    As you can see there is some useful information available here that we can use
    in our application.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了与数据对象相关的信息。如你所见，这里有一些可以在应用程序中使用的有用信息。
- en: '| **Object** | **Field** |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| **Object** | **Field** |'
- en: '| `data` | `bucket` |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `data` | `bucket` |'
- en: '| `data` | `name` |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `data` | `name` |'
- en: '| `data` | `metageneration` |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `data` | `metageneration` |'
- en: '| `data` | `timeCreation` |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `data` | `timeCreation` |'
- en: '| `data` | `updated` |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `data` | `updated` |'
- en: 'Based on the preceding information, much of what we need is available in the
    data object. In this case, we can pass this object to our message queue for further
    processing by the backend:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的信息，我们需要的很多数据都可以在数据对象中找到。在这种情况下，我们可以将该对象传递到消息队列中，供后端进一步处理：
- en: Go to the `frontend-service` subdirectory.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入 `frontend-service` 子目录。
- en: 'Amend the `entrypoint` function, which is outlined as follows:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `entrypoint` 函数，其修改如下：
- en: '[PRE15]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, amend the `gcpCreatePayload` function as follows:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按如下方式修改 `gcpCreatePayload` 函数：
- en: '[PRE16]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Congratulations! The `gcpSecureURL` function is now forwarding the data object
    to Cloud Pub/Sub. Rather than creating additional potentially complex code, we
    simply pass data between services utilizing Cloud Pub/Sub messaging.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！`gcpSecureURL` 函数现在将数据对象转发到 Cloud Pub/Sub。我们不再需要编写额外可能复杂的代码，而是利用 Cloud Pub/Sub
    消息传递在服务之间传递数据。
- en: Backend service
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后端服务
- en: 'The backend service will not have a data object presented to the `entrypoint`
    function. Instead of accessing a filename, we need to extract both the filename
    and the bucket name from the data object:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 后端服务将不会向 `entrypoint` 函数提供数据对象。我们需要从数据对象中提取文件名和存储桶名称，而不是直接访问文件名：
- en: Go to the `backend-service` subdirectory.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入 `backend-service` 子目录。
- en: 'Amend the `gcpCreateSignedURL` function, which is as outlined as follows:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `gcpCreateSignedURL` 函数，修改内容如下：
- en: '[PRE17]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Amend the `signedURL` function:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `signedURL` 函数：
- en: '[PRE18]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'While we are in the `backend-service` subdirectory, we can also fix the hard
    coded expiration date. One simple way to correct the issue with expiration dates
    is to add a standard duration for signed URLs. Adding a duration means that we
    can automatically supply a future date on which the URLs supplied will automatically
    expire:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处于`backend-service`子目录时，我们还可以修复硬编码的过期日期。解决过期日期问题的一种简单方法是为签名URL添加标准时长。添加时长意味着我们可以自动提供一个未来的日期，届时提供的URL将自动过期：
- en: Go to the `backend-service` subdirectory.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`backend-service`子目录。
- en: 'Add an expiry date function above the `gcpGenerateSignedURL` function:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`gcpGenerateSignedURL`函数上方添加一个过期日期函数：
- en: '[PRE19]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Amend the `options` object in order to call the `gcpExpirationDate` function:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`options`对象，以便调用`gcpExpirationDate`函数：
- en: '[PRE20]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Rather than adding complex code, we pass the current information provided by
    Cloud Storage, and that enables our services to take advantage of a complete dataset.
    Additionally, we now have a set duration for signed URLs, so the process is completely
    automated from start to finish.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 与其添加复杂的代码，我们传递Cloud Storage提供的当前信息，这使得我们的服务能够利用完整的数据集。此外，我们现在为签名URL设置了一个固定的时长，因此整个过程从头到尾完全自动化。
- en: 'Go ahead and delete the existing Cloud Functions from your project, and delete
    any content from the storage bucket. We will redeploy our functions one last time.
    However, this time, when asked whether you want to allow unauthenticated invocations,
    select **No**:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 继续删除项目中的现有Cloud Functions，并清空存储桶中的内容。我们将重新部署函数，这是最后一次部署。然而，这次当被问及是否允许未经身份验证的调用时，请选择**否**：
- en: 'Deploy the updated frontend service:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署更新后的前端服务：
- en: '[PRE21]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Deploy the backend service:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署后端服务：
- en: '[PRE22]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Once the Cloud Functions are deployed, upload a new file to the storage bucket.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦Cloud Functions部署完成，上传一个新文件到存储桶。
- en: Once the user uploads a document to the bucket, the automated process takes
    over. Our functions still work, as they use the service account associated with
    the project. The Cloud Functions are no longer externally accessible to unauthenticated
    invocations.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户将文档上传到存储桶，自动化流程就会接管。我们的功能仍然有效，因为它们使用与项目关联的服务帐户。Cloud Functions不再允许未经身份验证的调用访问。
- en: 'The data object for Cloud Storage provides all the information we need for
    our service to be completely self-reliant (that is, a filename and a bucket name).
    With the application now seamlessly passing information between services using
    a service account, we no longer have to worry so much about the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Storage的数据对象提供了我们服务所需的所有信息，以实现完全自给自足（即文件名和存储桶名称）。现在，应用程序通过服务帐户无缝地在服务之间传递信息，我们不再需要过多担心以下问题：
- en: The security of the Cloud Functions, as a service account manages them
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cloud Functions的安全性，由服务帐户管理它们
- en: User validation, as the information in the storage bucket is provided automatically
    on file upload
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户验证，因为存储桶中的信息在文件上传时会自动提供
- en: Scaling our function, as the data uses Cloud Storage and Cloud Pub/Sub
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展我们的功能，因为数据使用了Cloud Storage和Cloud Pub/Sub
- en: Congratulations! The `backend-service` is now using the data object consumed
    from Cloud Pub/Sub. Before we conclude this topic, please take a minute to consider
    how flexible our solution has become. We started with a simple requirement, and
    by making some small incremental changes, we now have a fully automated service.
    Due to the inclusion of both Cloud Pub/Sub and Cloud Storage, we also have a solution
    that will scale and has a level of resilience built-in. The architecture maintains
    loose coupling between the functions, so we can continue to iterate our design
    without fear of breaking links to components, thanks to the inclusion of Cloud
    Pub/Sub messages.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！现在`backend-service`正在使用从Cloud Pub/Sub消费的数据对象。在我们结束这一话题之前，请花一点时间思考一下我们的解决方案变得多么灵活。我们从一个简单的需求开始，通过进行一些小的增量更改，现在我们已经拥有了一个完全自动化的服务。由于同时包含了Cloud
    Pub/Sub和Cloud Storage，我们还拥有一个可扩展的解决方案，并且内建了弹性。架构保持了各功能之间的松散耦合，因此我们可以继续迭代设计，而不必担心破坏与组件之间的链接，这得益于Cloud
    Pub/Sub消息的引入。
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: At this point, you should have a reasonable understanding of the general architecture
    and components provided by Cloud Functions. While the typical use case of Cloud
    Functions is to use HTTP endpoints, it is also incredibly useful to have background
    functions (for example, Cloud Pub/Sub and Cloud Storage) available to integrate
    different services using a standardized interface. Our use of HTTP endpoints and
    background functions has enabled us to prototype a simple service application
    to create a `signedURL` function. Building on the knowledge we have gathered over
    the previous chapters, we have been able to perform the majority of this work
    from a local development environment.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，你应该对 Cloud Functions 提供的一般架构和组件有一个合理的理解。虽然 Cloud Functions 的典型用例是使用 HTTP
    端点，但拥有后台功能（例如 Cloud Pub/Sub 和 Cloud Storage）来集成不同的服务，通过标准化接口进行集成，也是非常有用的。我们使用
    HTTP 端点和后台功能，成功地从本地开发环境中原型化了一个简单的服务应用程序来创建 `signedURL` 函数。在前几章所学的基础上，我们已经能够完成大部分工作。
- en: The Cloud Functions process of developing an application demonstrates how a
    simple solution can be quick to build and extend. Cloud Pub/Sub requires a message
    queue to be defined that provides the capability to integrate different services.
    Being able to decouple the background processing of data allows solutions to be
    loosely coupled and more open to integration with a broader range of technical
    solutions. In many instances, Cloud Pub/Sub operates as the glue for Google Cloud,
    delivering data exchanges between a variety of services. Cloud Storage offers
    a simple, yet effective, means for users to upload data without needing to expose
    portals or create complex life cycle management code.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 云函数开发应用程序的过程展示了一个简单的解决方案如何能够快速构建和扩展。Cloud Pub/Sub 需要定义一个消息队列，提供将不同服务集成的能力。能够解耦数据的后台处理使得解决方案能够松散耦合，更容易与更广泛的技术解决方案集成。在许多情况下，Cloud
    Pub/Sub 作为 Google Cloud 的粘合剂，提供多种服务之间的数据交换。Cloud Storage 提供了一种简单而有效的方式，允许用户上传数据，而无需暴露门户或创建复杂的生命周期管理代码。
- en: In the next chapter, we will create some general examples to build on the techniques
    we have learned so far. Our focus will remain on Cloud Functions and building
    components to whet our appetite for developing a more complete and challenging
    application. The emphasis of this content will be to provide a more comprehensive
    series of examples and also cover some of the elements necessary to incorporate
    Cloud Functions within your portfolio.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创建一些通用示例，以便在我们迄今为止学到的技术基础上继续构建。我们的重点将继续放在 Cloud Functions 和构建组件上，以激发我们开发更完整、更具挑战性的应用程序的兴趣。本章内容的重点将是提供一系列更全面的示例，并涵盖一些将
    Cloud Functions 纳入你的项目组合所必需的元素。
- en: Questions
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What subscription types does Cloud Pub/Sub support?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cloud Pub/Sub 支持哪些订阅类型？
- en: Name three message design patterns for Cloud Pub/Sub?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出三种 Cloud Pub/Sub 的消息设计模式？
- en: What verbs are associated with HTTP?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与 HTTP 相关的动词有哪些？
- en: If I want to have user data accessible in the URL, should I use GET or POST?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我希望用户数据能在 URL 中访问，我应该使用 GET 还是 POST？
- en: What Cloud Storage property maintains information on the data content?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个 Cloud Storage 属性维护关于数据内容的信息？
- en: If my code responds with an error code of 5xx, where should I expect the error
    to be?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我的代码响应一个 5xx 错误代码，我应该在何处找到这个错误？
- en: Does Google Cloud support OAuth v2?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Google Cloud 是否支持 OAuth v2？
- en: If a Cloud Pub/Sub message is not acknowledged before its deadline, is the message
    lost?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个 Cloud Pub/Sub 消息在截止时间前没有被确认，消息会丢失吗？
- en: Further reading
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '**Authentication Developers, Functions, and End Users**: [https://cloud.google.com/functions/docs/securing/authenticating](https://cloud.google.com/functions/docs/securing/authenticating)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证开发人员、函数和最终用户**: [https://cloud.google.com/functions/docs/securing/authenticating](https://cloud.google.com/functions/docs/securing/authenticating)'
- en: '**Using OAuth 2.0 and Google Cloud Functions to access Google services**: [https://cloud.google.com/community/tutorials/cloud-functions-oauth-gmail](https://cloud.google.com/community/tutorials/cloud-functions-oauth-gmail)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 OAuth 2.0 和 Google Cloud Functions 访问 Google 服务**: [https://cloud.google.com/community/tutorials/cloud-functions-oauth-gmail](https://cloud.google.com/community/tutorials/cloud-functions-oauth-gmail)'
- en: '**Understanding OAuth2 and Deploying a Basic Authorization Service to Cloud
    Functions**: [https://cloud.google.com/community/tutorials/understanding-oauth2-and-deploy-a-basic-auth-srv-to-cloud-functions](https://cloud.google.com/community/tutorials/understanding-oauth2-and-deploy-a-basic-auth-srv-to-cloud-functions)'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解 OAuth2 并将基本授权服务部署到云函数**: [https://cloud.google.com/community/tutorials/understanding-oauth2-and-deploy-a-basic-auth-srv-to-cloud-functions](https://cloud.google.com/community/tutorials/understanding-oauth2-and-deploy-a-basic-auth-srv-to-cloud-functions)'
- en: '**Securing Google Cloud Functions**: [https://cloud.google.com/functions/docs/securing/](https://cloud.google.com/functions/docs/securing/)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保护 Google Cloud 函数**: [https://cloud.google.com/functions/docs/securing/](https://cloud.google.com/functions/docs/securing/)'
