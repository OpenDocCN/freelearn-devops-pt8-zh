- en: Application Orchestration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Application orchestration provides a few key features for the Puppet language.
    Application orchestration extends the concept of exported resources to a more
    targeted application, allowing the sharing of configuration items between nodes.
    Additionally, this feature provides a way to order Puppet runs to ensure that
    dependency nodes have finished building or converging prior to the nodes that
    require them. Application orchestration allows us to entangle multiple nodes together
    in an ordered run. Most importantly, configuration updates are not randomly applied
    on check-in, but are applied in a particular, ordered pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Application Orchestration only works in Puppet Enterprise. Puppet open source
    users can use the language constructs, but ordered runs are provided by Puppet
    Enterprise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Application orchestration has three new language constructs we''ll need to
    use to create ordered runs that share information automatically with each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application definitions**: An end-to-end description of a collection of components
    describing an entire application stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application components**: An individual component of an entire application
    stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service resources**: Resources designed to share information across application
    components'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Application definitions look a lot like a defined resource, but are also similar
    to a traditional Puppet profile. They describe a collection of components that
    make an entire system, but unlike profiles, are not tied down to a single node.
    These application definitions describe a configured state of one or more nodes,
    broken down by application components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Application definitions will resemble defined types, with a few key differences:'
  prefs: []
  type: TYPE_NORMAL
- en: They are titled `application` instead of `define`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each resource must be name spaced within the module:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'What is important to note is that each resource in this application can be
    tied to an entirely different node with our site definition. We can also use our
    site definitions to pass in those shared configuration items, represented by `$var`
    in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Inside of the node's hash, notice that the `Node` object and `Example::App<X>`
    objects are capitalized.
  prefs: []
  type: TYPE_NORMAL
- en: Application components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Application components provide the individual pieces of the multi-node application.
    They are most often defined types (for reusability), but can also consist of classes
    or even native resources, such as files, in very simple cases. Application components
    are created by the `export`, `consume`, or `require` metaparameters that are used
    in an application declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Application components are written as general classes or defined types. They
    follow the same autoload format as all other Puppet code. The manifest for `example::app2`
    would still be located at `manifests/example/app2.pp`. Application components
    can explicitly list the values they export and consume in their individual manifests
    by placing an additional statement at the bottom of the manifests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding sample, `$db_host` is a value that could be passed to any resource
    in the manifest. Rather than passing it via Hiera or Puppet DSL, we instead consume
    that value from the `host` parameter provided by another application. We also
    export the node's own FQDN and hostname, so that follow-on applications can use
    those values to point at the web service created by `example::app2`. `Database`
    and `Http` are both service resources, describing information that's shared between
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Service resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Service resources are environment-wide information pools filled and viewed by
    application components. Service resources work like exported resources, providing
    information about other nodes from PuppetDB. The uniqueness of service resources
    is found in their building of  dependencies between nodes. Service resources are
    declared as Puppet types, written in Ruby. Providers are optional, and allow for
    exported resource availability tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Service resource types provide a framework of information that can be stored
    and transported via application orchestration''s `consume` and `export` metaparameters.
    The type is required for a service resource, and declares the structure of the
    information using Ruby code. They are always stored in modules at `lib/puppet/type/<resource>.rb`,
    and will be sent to all nodes in an environment when deployed, but will not be
    actioned upon by nodes not using the resource. The following sample type could
    encompass the database resource exported by `app1` and consumed by `app2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This simple example provides us with a way to export information about a database,
    specifically the `host` parameter. This can be filled with the `export` parameter,
    and read with the `consume` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the rest of this chapter, we'll be focusing on building a simple and a more
    complex example of an orchestrated application. Our first phase will be to create
    a single database and a single webserver.
  prefs: []
  type: TYPE_NORMAL
- en: Application and database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our first example, we'll export information from a database on one node,
    and retrieve it on a WordPress instance. This simple example will allow us to
    deploy nodes in pairs, and ensure that the database is built before the web application
    that relies on it.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we begin writing our code, we''ll want to check the Forge for relevant
    supported or open source modules. WordPress requires an SQL server and a web host,
    which we''ll provide via Apache HTTPD. Before we begin, we''ll want to install
    the following modules from the Forge:'
  prefs: []
  type: TYPE_NORMAL
- en: '`puppetlabs-mysql`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`puppetlabs-apache`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hunner-wordpress`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll write our code from the top down. It helps to think about the end state
    of the code as we're learning it, and learn the pieces that enable it along the
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Node declaration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our first piece will be the node declaration. This will go in our `site.pp`,
    and each application will go under a specific site call. In the following sample,
    notice the following:'
  prefs: []
  type: TYPE_NORMAL
- en: All apps are declared in the top-level `site{}` declaration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`myapp {''myapp'': }` is just one possible app that can go in `site.pp`. We
    could have another beneath it called `myapp.{''myapp2'': }` is inside of the site,
    and has a second standalone instance of this application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Node[''<nodename>'']` and `Myapp::<app>` are capitalized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I can still use the `site.pp` for other things, as indicated by the classification
    of the Puppet Master, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This particular configuration will ensure that the `mysql` node gets the database,
    `appserver` will get WordPress, and HAProxy will get the load balancer configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Application declaration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous example, we called a resource called `myapp` just under the
    `site{}` declaration. This manifest, located in the `myapp` module at `manifests/init.pp`,
    declares the application, describes some overridable parameters, and orchestrates
    applications using the `export` and `consume` metaparameters. Notice the following:'
  prefs: []
  type: TYPE_NORMAL
- en: On the first line, the application `myapp` is used in place of a class or define.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`myapp::db` exports to the SQL resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`myapp::web` consumes the SQL resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`myapp::db` will run before `myapp::web`, because `myapp::web` has a dependency
    via consume.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We use the `$name` variable so that each component receives `myapp` as a name,
    taken from `myapp {''myapp'':}`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: DB service resource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll build our own custom DB type for this simple use case. It will allow
    us to pass values from our database to our WordPress application. This simple
    example ensures that the type is named `db`, marks it as a service resource, and
    provides five available parameters to the database service resource. This file
    is placed in `lib/puppet/type/db.rb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Application components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `myapp` defined type will make use of the `db` resource we created in the
    previous section, passing four values to PuppetDB, directly from `myapp::db`.
    We''ll use this manifest to build a MySQL server, and provide information to our
    WordPress instance on another node. Notice the following in the example:'
  prefs: []
  type: TYPE_NORMAL
- en: A regular defined type, with standard Puppet DSL. We build a server and a database
    to support the app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$host` is not used in the manifest, but is passed along to the produced `Db`
    resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Myapp::Db produces Db` is placed directly after the define, in the same manifest:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`Myapp::Web` is a defined type meant to consume the `Db` produced by `Myapp::Db`.
    It installs the required packages, installs Apache, builds a vhost, and deploys
    WordPress to the `docroot` of the vhost. Notice the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$vhost` and `$webpath` were provided by application `myapp`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$dbuser`, `$dbpass`, `$dbhost`, and `$dbname` are provided by the consumes
    `Db {}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Because our manifest uses the values `dbpass`, `dbhost`, `dbuser` and `dbname`,
    our mappings don''t need to be declared. The following example will directly declare
    variables:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the preceding collection of code to order and deploy our multitier
    application. Our current module should resemble the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can then use the `puppet app` and `puppet job` commands to deploy our application.
  prefs: []
  type: TYPE_NORMAL
- en: Deploy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To view applications listed in our `site.pp`, we can use the command `puppet
    app show`. This command reads our main manifest, and lists all applications and
    their components. In the following example, from the preceding code, we''re deploying
    `Myapp::Db` to `mysql` and `Myapp::Web` to `appserver`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may receive a message when running this lab: *Application management is
    disabled. To enable it, set `app-management: true` in the orchestrator service
    config*. To fix this, you can log into the Puppet Enterprise console, enter the
    Puppet Master configuration and change the value of `puppet_enterprise::profile::master::app-management`
    to `true`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To simulate a deployment, we can use the `puppet job plan` command. We give
    it both an `application` and `environment` flag to let application orchestrator
    know which version of `site.pp` to use. This command primarily shows ordering,
    and you can see in the following results that `mysql` will be configured before
    `appserver`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'By switching from `puppet job plan` to `puppet job show`, we actually deploy
    our code in an ordered fashion. The run first takes place on the `mysql` server,
    which produces information that will be consumed by the `appserver` node. This
    run ensures that the necessary components are fully deployed before attempting
    to deploy applications that depend on them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We've now deployed a very simple ordered application. Our database will be fully
    up and running before the configuration of our `wordpress` server. In the next
    example, we'll allow for multiple `wordpress` servers and multiple load balancers
    to provide scaling to our application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a load balancer and providing horizontal scaling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many cases, we want our applications to scale horizontally. Building more
    nodes allows us to serve more customers. This will be a complete rewrite of the
    previous application, also incorporating `puppetlabs/app_modeling` from the Forge.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To provide new capabilities, we''ll need to grab the `puppetlabs-haproxy` module
    and the `puppetlabs/app_modeling` module from the Forge. If you''re using a `Puppetfile`,
    simply add them to the `Puppetfile`. In the following example, I am manually installing
    these dependencies on an existing master:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We now have the capability to build `haproxy` nodes and new app orchestration
    features via `app_modeling`.
  prefs: []
  type: TYPE_NORMAL
- en: Build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll begin at the `site.pp` again, and model our application from the endpoint.
    I have added two additional service lines that ensure that firewalls are disabled
    for the purpose of this lesson. We could consider using `puppetlabs/firewall`
    to manage our firewall as well, and even produce and consume FQDNs for our firewall.
    In the following sample, you will notice a few things:'
  prefs: []
  type: TYPE_NORMAL
- en: We're passing a `dbpass` variable to the application. This could be stored in
    Hiera and encrypted with EYAML.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have two `wordpress` nodes and two `haproxy` nodes that each have their
    own unique name in the `appserver`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After our application is declared, we can model our `init.pp` to declare the
    entire application. There is a lot going on in this application, so note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Five variables are made available, and the `db` variables are used in both the
    `DB` and the `App`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Myapp::Db` produces a database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Myapp::Web` consumes a database and produces an HTTP service resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the `collect_component_titles` function from `puppetlabs/app_modeling`
    to provide an array that we can iterate over. We're collecting the nodes via `$nodes`
    that are attached to `Myapp::Web` and `Myapp::Lb`. These values are named `allwebs`
    and `alllbs`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use a map function from `puppetlabs/stdlib` against `$allwebs`. In this map
    function, we turn each node name into the value `Http["web-${wordpress_name}"]`,
    where `$wordpress_name` is the name of each node attached to the `Myapp::Web`
    application. We use this value as our export on each `MyApp::Web` declaration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We provide the value of `$http (Http["web-${wordpress_name}"])` back to the
    array of `$https`, so that we can use these values on the load balancer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our load balancer uses an each statement in place of a map statement, because
    we don''t need to transform any of this data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `myapp::db` produces a MySQL server, and a single database meant to serve
    our application. We use the values of `dbuser`, `dbpass`, and `dbname` from our
    application at `init.pp`. Pay special attention to the produces line, using the
    `app_modeling` service resource for databases at the bottom of the manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: Produces a host from the FQDN of the machine to be consumed by the web application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Produces a port which is not used by our web manifest, but provides an availability
    test to our application orchestration nodes. The application orchestration for
    the web will not trigger until the node can reach a database at the FQDN on port
    `3306`. Without this declaration, it will default to `5432`, which is the default
    port of a postgres server:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Myapp::Web` call will make use of five variables from our initial application,
    but receive its database host from the consumed resources. Pay attention to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: The value for `$dbhost` is filled by consuming the database. At the bottom,
    we explicitly map the value of `$dbhost` to the consumed `$host` value in the
    `Myapp::Web` consumes `Myapp::Db`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We pass `$dbhost`, provided by the consume to class `wordpress`, providing an
    automatic connection to a remote DB.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Myapp::Web` produces an HTTP resource that provides host, port, IP, and status
    codes. We''ll use the host, port, and IP for our load balancer, but the `status_codes`
    is another availability test to ensure that the website served by the `haproxy`
    is up with a status code of `302` or `200`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`Myapp::Lb` doesn''t actually consume or export any resources. We build a `haproxy::listen`
    service, and then for every `balancermember`, we import the aforementioned values.
    In our application declaration, we ran each statement against every member of
    the `$https` array, and the following code transforms that data into a relevant
    load balancer. We take the host, port, and IP produced from every `myapp::web`,
    and add it as a member to our `haproxy::listen`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Deploy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deploying our new applications uses the same commands as before. We''ll use `puppet
    app show` to provide a list of nodes with ordering. You''ll see that our single
    DB produces a database; each webapp uses that database and produces an HTTP service
    resource, which is finally consumed by each load balancer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we launch our application, we can run a `puppet job plan` to get an
    idea of what ordering will look like during our run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we run our application and see MySQL configured first, then our `wordpress`
    instances, followed by the load balancers. Thanks to the service resources provided
    by `puppetlabs/app_modeling`, we also know that our database is actively seen
    before the `wordpress` servers, and that our `wordpress` servers are producing
    302 status codes prior to the load balancers being configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to order our applications using application
    orchestration. This builds upon the fundamental knowledge we learned when writing
    Puppet code, and even when using exported resources. As we build more applications
    and objects to configure, we'll need to make sure that our Puppet Master is available
    to service all these nodes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll discuss scaling Puppet Enterprise both horizontally
    and vertically.
  prefs: []
  type: TYPE_NORMAL
