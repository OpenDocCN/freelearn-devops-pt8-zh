<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer252">
<h1 class="chapter-number" id="_idParaDest-134"><a id="_idTextAnchor135"/>9</h1>
<h1 id="_idParaDest-135"><a id="_idTextAnchor136"/>Implementing CI/CD for Azure Services</h1>
<p>In this chapter, you are going to put everything you have learned so far into an end-to-end solution, deploying a group of applications and promoting it from a test environment to a production environment. From the simplest to the most complex solution architecture, this chapter showcases the flexibility of Azure Pipelines to handle the provisioning, configuration, and deployment of applications in Azure, no matter the different services involved and the programming languages used in <span class="No-Break">your applications.</span></p>
<p>The following topics will <span class="No-Break">be covered:</span></p>
<ul>
<li>Introducing the <span class="No-Break">solution architecture</span></li>
<li>Building and packaging applications and <strong class="bold">infastruture as </strong><span class="No-Break"><strong class="bold">code</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">IaC</strong></span><span class="No-Break">)</span></li>
<li><span class="No-Break">Creating environments</span></li>
<li>Deploying a Python catalog service to <strong class="bold">Azure Kubernetes </strong><span class="No-Break"><strong class="bold">Service</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">AKS</strong></span><span class="No-Break">)</span></li>
<li>Deploying a Node.js cart service to <strong class="bold">Azure Container </strong><span class="No-Break"><strong class="bold">Apps</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">ACA</strong></span><span class="No-Break">)</span></li>
<li>Deploying a .NET checkout service to <strong class="bold">Azure Container </strong><span class="No-Break"><strong class="bold">Instances</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">ACI</strong></span><span class="No-Break">)</span></li>
<li>Deploying an Angular frontend app to <strong class="bold">Azure App </strong><span class="No-Break"><strong class="bold">Service</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">AAS</strong></span><span class="No-Break">)</span></li>
<li>Approving <span class="No-Break">environment deployments</span></li>
</ul>
<p>Let’s first take care of the technical requirements for <span class="No-Break">this chapter.</span></p>
<h1 id="_idParaDest-136"><a id="_idTextAnchor137"/>Technical requirements</h1>
<p>You will need to have handy the following URL to the GitHub repository, which will be the base for this <span class="No-Break">chapter: </span><a href="https://github.com/PacktPublishing/Implementing-CI-CD-Using-Azure-Pipelines/tree/main/ch09"><span class="No-Break">https://github.com/PacktPublishing/Implementing-CI-CD-Using-Azure-Pipelines/tree/main/ch09</span></a><span class="No-Break">.</span></p>
<p>Like in the previous chapter, you must have access to an Azure account to complete the steps in this chapter; if you don’t have one, you can create a free one <span class="No-Break">at </span><a href="https://azure.microsoft.com/en-us/free/"><span class="No-Break">https://azure.microsoft.com/en-us/free/</span></a><span class="No-Break">.</span></p>
<p>That’s it for the technical requirements; now, let’s get started with <span class="No-Break">this chapter.</span></p>
<h1 id="_idParaDest-137"><a id="_idTextAnchor138"/>Getting started</h1>
<p>The first thing you must do is import the sample repository; let’s get <span class="No-Break">to it.</span></p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor139"/>Importing the sample repository</h2>
<p>You will need to <a id="_idIndexMarker419"/>import the application and IaC sources from GitHub for this book, to be able to complete the end-to-end pipelines in this chapter and <span class="No-Break">the next.</span></p>
<p>You can do this from the <strong class="bold">Azure Repos</strong> | <strong class="bold">Files</strong> section in the navigation menu, clicking on the repository dropdown on the top part of the screen and then clicking on the <strong class="bold">Import repository</strong> option, as shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer234">
<img alt="Figure 9.1 – Import repository" height="459" src="image/B18875_09_1.jpg" width="479"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Import repository</p>
<p>Enter <a href="https://github.com/PacktPublishing/Implementing-CI-CD-Using-Azure-Pipelines.git">https://github.com/PacktPublishing/Implementing-CI-CD-Using-Azure-Pipelines.git</a> in the <strong class="bold">Clone URL</strong> field and <strong class="source-inline">Implementing-CI-CD-Using-Azure-Pipeline</strong> in the <strong class="bold">Name</strong> field, and then hit the <span class="No-Break"><strong class="bold">Import</strong></span><span class="No-Break"> button:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer235">
<img alt="Figure 9.2 – Importing the sample repository" height="370" src="image/B18875_09_2.jpg" width="461"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Importing the sample repository</p>
<p>After a few<a id="_idIndexMarker420"/> minutes, the process will be complete, and then you will be able to browse all the code in the repository. Everything you need will be in the <span class="No-Break"><strong class="source-inline">e2e</strong></span><span class="No-Break"> directory.</span></p>
<p>With the repository imported, let’s understand the <span class="No-Break">sample architecture.</span></p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor140"/>Introducing the solution architecture</h2>
<p>For our sample <a id="_idIndexMarker421"/>architecture, you will use a fictitious Packt store made up of four different applications, which represents a complex distributed architecture where teams working with different programming languages can use different Azure platform services to deliver <span class="No-Break">their capabilities:</span></p>
<ul>
<li>An Angular frontend application, the user interface of <span class="No-Break">the store</span></li>
<li>A Python product catalog service, implemented as a <span class="No-Break">REST API</span></li>
<li>A Node.js shopping cart service, implemented as a <span class="No-Break">REST API</span></li>
<li>An ASP.NET checkout service, implemented as a <span class="No-Break">REST API</span></li>
</ul>
<p>The following solution diagram depicts how an environment for the web store looks, where each of the applications independently runs in a different <span class="No-Break">Azure service:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer236">
<img alt="Figure 9.3 – The solution diagram" height="688" src="image/B18875_09_3.jpg" width="1491"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – The solution diagram</p>
<p>Later in the chapter, you will implement the Azure Pipeline with the following steps for <span class="No-Break">each application:</span></p>
<ol>
<li>Build and package the application and its <span class="No-Break">corresponding IaC.</span></li>
<li>Deploy<a id="_idIndexMarker422"/> them to a <span class="No-Break">test environment.</span></li>
<li>Deploy them to a production environment, including a manual <span class="No-Break">approval check.</span></li>
</ol>
<p>The following diagram depicts the <span class="No-Break">CI/CD process:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer237">
<img alt="Figure 9.4 – The CI/CD end-to-end process" height="702" src="image/B18875_09_4.jpg" width="1510"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – The CI/CD end-to-end process</p>
<p class="callout-heading">Important note</p>
<p class="callout">During this chapter, no details about the code in the applications will be covered, as that is not relevant to CI/CD. We will focus instead on the Azure Pipelines details needed to make the CI/CD <span class="No-Break">process work.</span></p>
<p>To implement the<a id="_idIndexMarker423"/> CI/CD process, you will be take advantage of multi-stage pipelines with environments <span class="No-Break">and templates:</span></p>
<ul>
<li><strong class="bold">Stages</strong> allow <a id="_idIndexMarker424"/>us to encapsulate all the jobs that need to happen together in a logical way and control dependencies, but they also provide the ability to execute jobs in parallel; this will help us reduce the total time <span class="No-Break">when needed</span></li>
<li><strong class="bold">Environments</strong> are linked <a id="_idIndexMarker425"/>to jobs and allow us to add additional controls, such as manual approval in this case, to ensure that the deployment proceeds to production only when a human intervenes and <span class="No-Break">approves it</span></li>
<li><strong class="bold">Templates</strong> were<a id="_idIndexMarker426"/> introduced in <a href="B18875_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>; here, you will put them into practice to demonstrate how to use them, to build modular and <span class="No-Break">reusable pipelines</span></li>
</ul>
<p>Let’s look at the following pipeline definition; create this file in <strong class="source-inline">ch09/azure/azure-pipeline.yml</strong>, inside the <strong class="source-inline">Implementing-CI-CD-Using-Azure-Pipeline</strong> repository <span class="No-Break">you imported:</span></p>
<pre class="source-code">
# Multi-Stage pipeline
trigger:
- main
pool:
  vmImage: ubuntu-latest
stages:
- stage: build
  displayName: Build
  jobs:
  - template: build-apps.yml
  - template: build-iac.yml
- stage: deployTest
  displayName: Deploy Test
  dependsOn: build
  jobs:
  - template: deploy.yml
    parameters:
      envName: test
- stage: deployProduction
  displayName: Deploy Production
  dependsOn: deployTest
  jobs:
  - template: deploy.yml
    parameters:
      envName: production</pre> <p>Let’s break this <span class="No-Break">code down:</span></p>
<ul>
<li>The <strong class="source-inline">build</strong> stage has no dependencies and includes jobs from templates in the <strong class="source-inline">build-apps.yml</strong> and <strong class="source-inline">build-iac.yml</strong> files. You will review these later in the <em class="italic">Building and packaging applications and </em><span class="No-Break"><em class="italic">IaC</em></span><span class="No-Break"> section.</span></li>
<li>The <strong class="source-inline">deployTest</strong> stage <a id="_idIndexMarker427"/>must wait for the build stage to complete and will run the jobs in the <strong class="source-inline">deploy.yml</strong> template, passing a parameter of <strong class="source-inline">envName</strong> with the <strong class="source-inline">test</strong> value to uniquely identify <span class="No-Break">this environment.</span></li>
<li>The <strong class="source-inline">deployProduction</strong> stage, in turn, waits for the <strong class="source-inline">deployTest</strong> stage to complete and uses the same <strong class="source-inline">deploy.yml</strong> template, passing a value of production for the <span class="No-Break"><strong class="source-inline">envName</strong></span><span class="No-Break"> parameter.</span></li>
</ul>
<p>This pipeline definition demonstrates the flexibility of templates and the ability to break into smaller portions the work that needs to be done, which provides a way for teams to focus on different stages of the pipeline, based on <span class="No-Break">their responsibilities.</span></p>
<p>Once the file is in the repository, add it as a new pipeline and rename it <strong class="source-inline">E2E-Azure</strong>. You will have to add some security configuration for everything to <span class="No-Break">ultimately work.</span></p>
<p>If you have not renamed a pipeline <a id="_idIndexMarker428"/>before, click on the sub-menu on the far-right side of the <strong class="bold">Recently run pipelines</strong> screen, as shown in the following screenshot, and <span class="No-Break">rename it:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer238">
<img alt="Figure 9.5 – Renaming a pipeline" height="433" src="image/B18875_09_5.jpg" width="771"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Renaming a pipeline</p>
<p class="callout-heading">A pro tip about templates</p>
<p class="callout">When using <strong class="source-inline">job.template</strong> to reference a template defined in another file, make sure to create that file with at least one step defined in it before referencing it from the parent template. An easy way to accomplish this is to use a <strong class="source-inline">script</strong> task that runs an <strong class="source-inline">echo</strong> command, such as <span class="No-Break"><strong class="source-inline">echo hello</strong></span><span class="No-Break">.</span></p>
<p>Let’s now move on to the <span class="No-Break">build stage.</span></p>
<h1 id="_idParaDest-140"><a id="_idTextAnchor141"/>Building and packaging applications and IaC</h1>
<p>The applications in <a id="_idIndexMarker429"/>this solution are all container-enabled, a standard packaging mechanism that includes all operating system dependencies to allow them to run in many different hosting environments, making them extremely lightweight <span class="No-Break">and portable.</span></p>
<p>For simplicity, the repository includes a <strong class="source-inline">docker-compose.yml</strong> file, which facilitates working with applications made of multiple services that must run at the <span class="No-Break">same time.</span></p>
<p>This file defines the services and the location of their corresponding <strong class="source-inline">Dockerfile</strong>, the file that defines how the container must be built, and several other things, such as the ports or environment variables needed for the container <span class="No-Break">to run.</span></p>
<p>In this chapter, the <strong class="source-inline">SUB_ID</strong> placeholder is the ID of the Azure subscription you have access to; make sure to replace it <span class="No-Break">when appropriate.</span></p>
<p>Before you can proceed, you must <a id="_idIndexMarker430"/>have an <strong class="bold">Azure Container Registry</strong> available for the pipeline to store the container images. You can create one easily with the following Azure <span class="No-Break">CLI command:</span></p>
<pre class="console">
az acr create -n packtadocicd -g packt –sku Standard -l eastus –admin-enabled</pre> <p>We will also need to ensure that the service principal we created previously in the <em class="italic">Creating a service connection to AWS</em> section of <a href="B18875_08.xhtml#_idTextAnchor103"><span class="No-Break"><em class="italic">Chapter 8</em></span></a> has permissions to manage user access to this service; you can do this with the following commands in the <span class="No-Break">PowerShell window:</span></p>
<pre class="console">
$id=az ad sp list –display-name azure-pipelines –query "[].id" -o tsv
az role assignment create –assignee-object-id $id –scope /subscriptions/<strong class="bold">SUB_ID</strong>/resourceGroups/packt/providers/Microsoft.ContainerRegistry/registries/packtadocicd --role 'User Access Administrator'</pre> <p>With the registry in place, you can now move on to create the <strong class="source-inline">build-apps.yml</strong> file, which will be used to build the application containers and push them to the Azure <span class="No-Break">Container Registry.</span></p>
<p>To build and push<a id="_idIndexMarker431"/> the containers, you can use the Docker Compose task. However, this must be done as a two-step process; you must build the images first and then push them. To make the task easier to read, let’s first look at the build portion in the following <span class="No-Break">YAML code:</span></p>
<pre class="source-code">
parameters:
- name: azureSubscription
  type: string
  default: 'azure-packt-rg'
- name: azureContainerRegistry
  type: string
  default: '{"loginServer":"packtadocicd.azurecr.io", "id" : "/subscriptions/SUB_ID/resourceGroups/packt/providers/Microsoft.ContainerRegistry/registries/packtadocicd"}'
jobs:
- job: BuildAndPushContainers
  displayName: Build and Push Containers
  steps:
  - task: DockerCompose@0
    displayName: 'Build Containers'
    inputs:
      containerregistrytype: 'Azure Container Registry'
      azureSubscription: ${{parameters.azureSubscription}}
      azureContainerRegistry: ${{parameters.azureContainerRegistry}}
      dockerComposeFile: 'docker-compose.yml'
      projectName: 'packt-store'
      action: 'Build services'
      additionalImageTags: '$(Build.BuildNumber)'
      includeLatestTag: true</pre> <p>Let’s break this <span class="No-Break">code down:</span></p>
<ul>
<li>The <strong class="source-inline">azureSubscription</strong> parameter<a id="_idIndexMarker432"/> is a reference to the Azure Resource Manager Service connection created in the <span class="No-Break">previous chapter.</span></li>
<li>The <strong class="source-inline">azureContainerRegistry</strong> parameter is a little tricky; it is a JSON document that includes the <strong class="source-inline">loginServer</strong> and <strong class="source-inline">id</strong> properties related to the Container Registry resource <span class="No-Break">in Azure.</span></li>
<li>The Docker Compose task with the <strong class="source-inline">'Build Containers'</strong> <strong class="source-inline">displayName</strong> uses the <strong class="source-inline">docker-compose.yml</strong> file to build container images locally in the agent, as indicated by the <strong class="source-inline">action</strong> property. Note the use of <strong class="source-inline">additionalImageTags</strong>, where you provide a predefined variable, <strong class="source-inline">$(Build.BuildNumber)</strong>, and set to <strong class="source-inline">true</strong> the <strong class="source-inline">includeLatestTag</strong> property; we will elaborate on this in the <em class="italic">Understanding container image </em><span class="No-Break"><em class="italic">tags</em></span><span class="No-Break"> section.</span></li>
</ul>
<p>With the images built, the next step is to push them to the registry, which is done with the same task, with just a change to the <strong class="source-inline">action</strong> property, as shown in the following <span class="No-Break">code snippet:</span></p>
<pre class="source-code">
  - task: DockerCompose@0
    displayName: 'Push Containers'
    inputs:
      containerregistrytype: 'Azure Container Registry'
      azureSubscription: ${{parameters.azureSubscription}}
      azureContainerRegistry: ${{parameters.azureContainerRegistry}}
      dockerComposeFile: 'docker-compose.yml'
      projectName: 'packt-store'
      action: 'Push services'
      additionalImageTags: '$(Build.BuildNumber)'
      includeLatestTag: true</pre> <p>The Docker Compose task with <strong class="source-inline">displayName</strong> <strong class="source-inline">'Push Containers'</strong> uses the <strong class="source-inline">docker-compose.yml</strong> file to push the previously built container images to the Container Registry in Azure as indicated by the <span class="No-Break"><strong class="source-inline">action</strong></span><span class="No-Break"> property.</span></p>
<p>Remember that <a id="_idIndexMarker433"/>the two portions of YAML presented here are part of the <span class="No-Break"><strong class="source-inline">build-apps.yaml</strong></span><span class="No-Break"> file.</span></p>
<p>Now that we have covered how to build and push container images, let’s take a break to discuss how container image tags work and why they <span class="No-Break">are important.</span></p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor142"/>Understanding container image tags</h2>
<p>Building a container is like <a id="_idIndexMarker434"/>compiling an application and packaging all its files into a ZIP archive that you can then use for deployment, along with all the OS dependencies needed for the application <span class="No-Break">to run.</span></p>
<p>However, the result is called a container image and it is typically a complex artifact made up of multiple layers stored in a registry and is not manageable via the filesystem. For this reason, just like you would name a ZIP file based on a versioning convention to track when the artifact was generated, when working with containers, it is important to <span class="No-Break">tag them.</span></p>
<p>The <strong class="source-inline">latest</strong> tag mentioned previously is a convention in the container world that allows you to retrieve the newest image available without specifying a specific tag. This is very helpful during development cycles for <span class="No-Break">experimentation purposes.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Always tag your containers with a specific version number and deploy that version number across all your environments for proper traceability. The <strong class="source-inline">latest</strong> tag is only a convenience to easily pull the newest version of a container image and it should never be used for environment deployments, because it can be a reference to different builds depending on the date and time that you <span class="No-Break">pull it.</span></p>
<p>Now that you understand the importance of container image tags, let’s see what you can use within Azure Pipelines to <span class="No-Break">name them.</span></p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor143"/>Understanding your pipeline build number</h2>
<p>The <strong class="source-inline">$(Build.BuildNumber)</strong> predefined <a id="_idIndexMarker435"/>variable is a convenient way to get a unique label in every pipeline run to version your artifacts, and its default value is a timestamp and revision number with the format <strong class="source-inline">YYYYMMDD.R</strong>, where <strong class="source-inline">YYYY</strong> is the current year, <strong class="source-inline">MM</strong> is the month, <strong class="source-inline">DD</strong> is the day, and <strong class="source-inline">R</strong> is a sequential automatically <span class="No-Break">incremented number.</span></p>
<p>If you don’t set your build name explicitly, it will use the following default format for your <span class="No-Break">YAML pipelines:</span></p>
<pre class="console">
name: $(Date:yyyyMMdd).$(Rev:r)</pre> <p>This special notation will use the current date in the given format, automatically increase the number generated by the <strong class="source-inline">$(Rev:r)</strong> token, and reset it to <strong class="source-inline">1</strong> if the portion of text before it <span class="No-Break">is changed.</span></p>
<p>Most organizations prefer to use semantic versioning for artifacts or APIs, which follows a <strong class="source-inline">MAJOR.MINOR.PATCH</strong> format, <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">1.0.1</strong></span><span class="No-Break">:</span></p>
<ul>
<li><strong class="source-inline">MAJOR</strong> changes indicate incompatible <span class="No-Break">API changes</span></li>
<li><strong class="source-inline">MINOR</strong> changes indicate that functionality is added with <span class="No-Break">backward compatibility</span></li>
<li><strong class="source-inline">PATCH</strong> changes indicate a bug fix without impact <span class="No-Break">on functionality</span></li>
</ul>
<p>If you need to use semantic versioning in your pipelines, an easy way to implement this is by adding <strong class="source-inline">name</strong> at the very top of your YAML file, <span class="No-Break">as follows:</span></p>
<pre class="console">
name: 1.0.$(Rev:r)</pre> <p>Notice that in this case, you are responsible for increasing the <strong class="source-inline">MAJOR</strong> and <strong class="source-inline">MINOR</strong> portions of the name based on your <span class="No-Break">code changes.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Always consider the implications of your pipeline build number, its format, and where you will be using it. This value can have adverse effects depending on where you <span class="No-Break">use it.</span></p>
<p>Now that you have the container images available, let’s talk a bit about Helm, a tool you will be using to deploy applications in <span class="No-Break">Kubernetes environments.</span></p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor144"/>Understanding Helm</h2>
<p><strong class="bold">Helm</strong> is a package manager for<a id="_idIndexMarker436"/> Kubernetes. Typically, you take advantage of it to deploy third-party or open source applications into your Kubernetes clusters. The packages created with Helm are referred to<a id="_idIndexMarker437"/> as <span class="No-Break"><strong class="bold">Helm charts</strong></span><span class="No-Break">.</span></p>
<p>Helm is also extremely useful for packaging your own applications, since they will likely have more than one manifest needed to configure all required components in Kubernetes, and Helm provides facilities to override parameters <span class="No-Break">with ease.</span></p>
<p>For example, a simple Helm chart will contain the <span class="No-Break">following files:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer239">
<img alt="Figure 9.6 – Basic Helm chart contents" height="260" src="image/B18875_09_6.jpg" width="266"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Basic Helm chart contents</p>
<p>If you want to learn more about <a id="_idIndexMarker438"/>Helm, go <span class="No-Break">to </span><a href="https://helm.sh/"><span class="No-Break">https://helm.sh/</span></a><span class="No-Break">.</span></p>
<p>Validating Helm charts is not a trivial task; several options are available for this. Helm provides a basic <strong class="source-inline">lint</strong> command to accomplish this task, but it covers only basic format issues. In this book, you are using an open source<a id="_idIndexMarker439"/> tool called <strong class="bold">kube-linter</strong>, available as a Docker container. This will validate the YAML syntax of the Kubernetes manifests used to deploy the application and perform a series of best-practice checks. If you want to learn more about this tool, go <a id="_idIndexMarker440"/><span class="No-Break">to </span><a href="https://docs.kubelinter.io/"><span class="No-Break">https://docs.kubelinter.io/</span></a><span class="No-Break">.</span></p>
<p>Now that you have learned about Helm, let’s work on <span class="No-Break">the IaC.</span></p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor145"/>Verifying and packaging IaC</h2>
<p>You learned<a id="_idIndexMarker441"/> how to work with Azure Resource Manager templates in the previous chapter, so you need to validate the templates and publish them as artifacts to <span class="No-Break">the pipeline.</span></p>
<p>To do this, you will create a <strong class="source-inline">build-iac.yml</strong> file in the repository and add the following seven segments to it (they have been separated in this section only to make it easier <span class="No-Break">to read):</span></p>
<ul>
<li><strong class="bold">The parameters segment</strong>: These <a id="_idIndexMarker442"/>parameters will allow us to easily replace values when called from the main <span class="No-Break"><strong class="source-inline">azure-pipeline.yaml</strong></span><span class="No-Break"> file:</span><pre class="source-code">
parameters:
- name: azureSubscription
  type: string
  default: 'azure-packt-rg'
- name: resourceGroupName
  type: string
  default: 'packt'
- name: location
  type: string
  default: 'East US'</pre></li> <li><strong class="bold">The jobs segment</strong>: This<a id="_idIndexMarker443"/> segment <a id="_idIndexMarker444"/>groups all the subsequent segments that include <span class="No-Break">only tasks:</span><pre class="source-code">
jobs:
- job: VerifyAndPackageIaC
  displayName: Verify and Package IaC
  steps:</pre></li> <li><strong class="bold">IaC catalog tasks segment</strong>: This can<a id="_idIndexMarker445"/> be written <span class="No-Break">as follows:</span><pre class="source-code">
    - task: AzureResourceManagerTemplateDeployment@3
      displayName: 'Validate Catalog Template'
      inputs:
        deploymentScope: 'Resource Group'
        azureResourceManagerConnection: ${{parameters.azureSubscription}}
        resourceGroupName: ${{parameters.resourceGroupName}}
        templateLocation: 'Linked artifact'
        csmFile: 'e2e/iac/azure/catalog/template.json'
        deploymentMode: 'Validation'
        location: ${{parameters.location}}
    - task: PublishPipelineArtifact@1
      displayName: 'Publish Catalog Artifacts'
      inputs:
        targetPath: 'e2e/iac/azure/catalog'
        artifact: catalog-iac
        publishLocation: 'pipeline'</pre><p class="list-inset">Let’s break <span class="No-Break">it down:</span></p><ul><li>The <strong class="source-inline">AzureResourceManagerTemplateDeployment@3</strong> task is used to validate the ARM templates for the <span class="No-Break">catalog application</span></li><li>The <strong class="source-inline">PublishPipelineArtifact@1</strong> task is then used to publish the artifacts to<a id="_idIndexMarker446"/> be used <span class="No-Break">for deployment</span></li></ul></li> <li><strong class="bold">Catalog helm chart segment</strong>: You <a id="_idIndexMarker447"/>can<a id="_idIndexMarker448"/> write this block <span class="No-Break">as follows:</span><pre class="source-code">
    - script: |
        docker run --rm -v $(pwd):/manifests stackrox/kube-linter lint /manifests --config /manifests/.kube-linter.yml
      displayName: 'Lint Catalog Helm Chart'
      workingDirectory: e2e/iac/helm-charts/catalog
    - task: HelmInstaller@1
      displayName: 'Install Helm'
    - task: HelmDeploy@0
      displayName: 'Package Catalog Helm Chart'
      inputs:
        command: package
        chartPath: e2e/iac/helm-charts/catalog
        destination: $(Build.ArtifactStagingDirectory)
    - task: PublishPipelineArtifact@1
      displayName: 'Publish Catalog Helm Chart'
      inputs:
        targetPath: $(Build.ArtifactStagingDirectory)
        artifact: catalog-helm-chart
        publishLocation: 'pipeline'</pre><p class="list-inset">Let’s break <span class="No-Break">it down:</span></p><ul><li>The script task with <strong class="source-inline">displayName</strong> <strong class="source-inline">'Lint Catalog Helm Chart'</strong> performs a validation of the <span class="No-Break">Helm chart</span></li><li>The <strong class="source-inline">HelmInstaller@1</strong> task installs the <span class="No-Break">Helm tool</span></li><li>The <strong class="source-inline">HelmDeploy@0</strong> task is<a id="_idIndexMarker449"/> used to package the <span class="No-Break">Helm chart</span></li></ul></li> <li><strong class="bold">IaC cart tasks segment</strong>: An<a id="_idIndexMarker450"/> example <a id="_idIndexMarker451"/>of this is <span class="No-Break">as follows:</span><pre class="source-code">
    - task: AzureResourceManagerTemplateDeployment@3
      displayName: 'Validate Cart Template'
      inputs:
        deploymentScope: 'Resource Group'
        azureResourceManagerConnection: ${{parameters.azureSubscription}}
        resourceGroupName: ${{parameters.resourceGroupName}}
        templateLocation: 'Linked artifact'
        csmFile: 'e2e/iac/azure/cart/template.json'
        deploymentMode: 'Validation'
        location: ${{parameters.location}}
    - task: PublishPipelineArtifact@1
      displayName: 'Publish Cart Artifacts'
      inputs:
        targetPath: 'e2e/iac/azure/cart'
        artifact: cart-iac
        publishLocation: 'pipeline'</pre><p class="list-inset">Let’s break <span class="No-Break">it down:</span></p><ul><li>The <strong class="source-inline">AzureResourceManagerTemplateDeployment@3</strong> task is used to validate the ARM templates for the <span class="No-Break">cart application</span></li><li>The <strong class="source-inline">PublishPipelineArtifact@1</strong> task is then used to publish the artifacts to be <a id="_idIndexMarker452"/>used <span class="No-Break">for deployment</span></li></ul></li> <li><strong class="bold">IaC checkout tasks segment</strong>: This<a id="_idIndexMarker453"/> section <a id="_idIndexMarker454"/>looks like <span class="No-Break">the following:</span><pre class="source-code">
    - task: AzureResourceManagerTemplateDeployment@3
      displayName: 'Validate Checkout Template'
      inputs:
        deploymentScope: 'Resource Group'
        azureResourceManagerConnection: ${{parameters.azureSubscription}}
        resourceGroupName: ${{parameters.resourceGroupName}}
        templateLocation: 'Linked artifact'
        csmFile: 'e2e/iac/azure/checkout/template.json'
        deploymentMode: 'Validation'
        location: ${{parameters.location}}
    - task: PublishPipelineArtifact@1
      displayName: 'Publish Checkout Artifacts'
      inputs:
        targetPath: 'e2e/iac/azure/checkout'
        artifact: checkout-iac
        publishLocation: 'pipeline'</pre><p class="list-inset">Let’s break <span class="No-Break">it down:</span></p><ul><li>The <strong class="source-inline">AzureResourceManagerTemplateDeployment@3</strong> task is used to validate the ARM templates for the <span class="No-Break">checkout application</span></li><li>The <strong class="source-inline">PublishPipelineArtifact@1</strong> task is then used to publish the artifacts to be used <a id="_idIndexMarker455"/><span class="No-Break">for deployment</span></li></ul></li> <li><strong class="bold">IaC frontend tasks segment</strong>: Here<a id="_idIndexMarker456"/> is a <a id="_idIndexMarker457"/>sample of this part of <span class="No-Break">the code:</span><pre class="source-code">
    - task: AzureResourceManagerTemplateDeployment@3
      displayName: 'Validate Frontend Template'
      inputs:
        deploymentScope: 'Resource Group'
        azureResourceManagerConnection: ${{parameters.azureSubscription}}
        resourceGroupName: ${{parameters.resourceGroupName}}
        templateLocation: 'Linked artifact'
        csmFile: 'e2e/iac/azure/frontend/template.json'
        deploymentMode: 'Validation'
        location: ${{parameters.location}}
        overrideParameters: '-catalogAppUrl catalogAppUrl.com -cartAppUrl cartAppUrl.com -checkoutAppUrl checkoutAppUrl.com'
    - task: PublishPipelineArtifact@1
      displayName: 'Publish Frontend Artifacts'
      inputs:
        targetPath: 'e2e/iac/azure/frontend'
        artifact: frontend-iac
        publishLocation: 'pipeline'</pre><p class="list-inset">For simplicity, let’s break down what <span class="No-Break">is happening:</span></p><ul><li>The <strong class="source-inline">AzureResourceManagerTemplateDeployment@3</strong> task is used to validate the ARM templates for the <span class="No-Break">frontend application</span></li><li>The <strong class="source-inline">PublishPipelineArtifact@1</strong> task is then used to publish the artifacts to be used <span class="No-Break">for deployment</span></li></ul></li> </ul>
<p>That brings us to the <a id="_idIndexMarker458"/>end of the <strong class="source-inline">build-iac.yaml</strong> file; make sure you keep all the segments together in the <span class="No-Break">same file.</span></p>
<p>Now that you have all the artifacts ready, let’s move on to create <span class="No-Break">our environments.</span></p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor146"/>Managing environments</h1>
<p>In this section, you will learn about how to create environments and deploy <span class="No-Break">to them.</span></p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor147"/>Configuring environments</h2>
<p>In<a id="_idIndexMarker459"/> this section, you will define the environments in Azure Pipelines, which will be logical representations of the deployment targets. This will allow us to add approval and checks to control how the pipeline advances from one stage to <span class="No-Break">the next:</span></p>
<ol>
<li>You start by clicking on the <strong class="bold">Environments</strong> option under <strong class="bold">Pipelines</strong> in the main menu on the left, <span class="No-Break">as follows:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer240">
<img alt="Figure 9.7 – Accessing the Environments option in the menu" height="330" src="image/B18875_09_7.jpg" width="259"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Accessing the Environments option in the menu</p>
<ol>
<li value="2">If you have<a id="_idIndexMarker460"/> no environments, you will see a screen like the following; click on <span class="No-Break"><strong class="bold">Create environment</strong></span><span class="No-Break">:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer241">
<img alt="Figure 9.8 – Creating your first environment" height="285" src="image/B18875_09_8.jpg" width="505"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – Creating your first environment</p>
<p class="list-inset">Otherwise, you will see a <strong class="bold">New environment</strong> option in the top-right part of the screen above your <span class="No-Break">existing environments.</span></p>
<ol>
<li value="3">Once the pop-up screen shows up to create the new environment, enter <strong class="source-inline">test</strong> for <strong class="bold">Name</strong> and <strong class="source-inline">Test Environment</strong> for <strong class="bold">Description</strong>, leave the <strong class="bold">Resource</strong> option as <strong class="bold">None</strong>, and click on the <strong class="bold">Create</strong> button, as <span class="No-Break">shown here:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer242">
<img alt="Figure 9.9 – Creating the test environment" height="608" src="image/B18875_09_9.jpg" width="460"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – Creating the test environment</p>
<ol>
<li value="4">Repeat <em class="italic">steps 2 and 3</em> to<a id="_idIndexMarker461"/> create another environment using <strong class="source-inline">production</strong> for <strong class="bold">Name</strong> and <strong class="source-inline">Production Environment</strong> <span class="No-Break">for </span><span class="No-Break"><strong class="bold">Description</strong></span><span class="No-Break">.</span></li>
<li>With the two environments created, click on the <strong class="bold">production</strong> one in the list, as <span class="No-Break">shown here:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer243">
<img alt="Figure 9.10 – Environments" height="232" src="image/B18875_09_10.jpg" width="661"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 – Environments</p>
<ol>
<li value="6">In the next <a id="_idIndexMarker462"/>screen, you are going to add an approval check, to ensure you can only deploy to production once a human indicates it <span class="No-Break">is possible.</span><p class="list-inset">For this, start by clicking on the ellipsis button in the top-right part of the screen and then on the <strong class="bold">Approvals and checks</strong> item, as <span class="No-Break">shown here:</span></p></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer244">
<img alt="Figure 9.11 – Adding an environment approval gate" height="219" src="image/B18875_09_11.jpg" width="247"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11 – Adding an environment approval gate</p>
<ol>
<li value="7">Since no checks have been added yet, you should see a screen like the following; selecting <strong class="bold">Approvals</strong> will get us to the next step to complete the <span class="No-Break">check configuration:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer245">
<img alt="Figure 9.12 – Adding an approval check" height="354" src="image/B18875_09_12.jpg" width="599"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.12 – Adding an approval check</p>
<p class="list-inset">In this form, provide <a id="_idIndexMarker463"/>the required approvers (it could be yourself initially). You can optionally provide instructions, such as manual steps to verify by the approver, and change <strong class="bold">Timeout</strong>. If you are the approver, you must make sure the <strong class="bold">Allow approvers to approve their own runs</strong> option is checked under <strong class="bold">Advanced</strong>. Finally, hit the <strong class="bold">Create</strong> button and you will be ready to move on to the <span class="No-Break">next steps:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer246">
<img alt="Figure 9.13 – Creating an approval check" height="550" src="image/B18875_09_13.jpg" width="457"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.13 – Creating an approval check</p>
<ol>
<li value="8">Lastly, you must also <a id="_idIndexMarker464"/>add permissions for each environment to allow them to be used in the <strong class="bold">E2E-Azure</strong> pipeline. Like before, click on the ellipsis option in the top-right part of the screen and click the <strong class="bold">Security</strong> option from <span class="No-Break">the menu.</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer247">
<img alt="Figure 9.14 – Environment security settings" height="221" src="image/B18875_09_14.jpg" width="250"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.14 – Environment security settings</p>
<ol>
<li value="9">Then click on the <strong class="bold">+</strong> button and search for the <strong class="bold">E2E-Azure</strong> pipeline to add the permissions; just click on the name to <span class="No-Break">add it.</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer248">
<img alt="Figure 9.15 – Adding pipeline permissions to environment" height="258" src="image/B18875_09_15.jpg" width="600"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.15 – Adding pipeline permissions to environment</p>
<p class="list-inset">A properly configured environment will look like <span class="No-Break">the following:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer249">
<img alt="Figure 9.16 – Environment with pipeline permissions" height="193" src="image/B18875_09_16.jpg" width="629"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.16 – Environment with pipeline permissions</p>
<p class="callout-heading">Important</p>
<p class="callout">It is a good practice to create environments for all deployment stages; this allows us to be modular and templatize deployment steps, giving us the opportunity to add approvals or gates later if <span class="No-Break">need be.</span></p>
<p>Now that you have our environments configured, let’s move on to the <span class="No-Break">deployment steps.</span></p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor148"/>Deploying to environments</h2>
<p>You will deploy the<a id="_idIndexMarker465"/> environment by creating a <strong class="source-inline">deploy.yml</strong> file and start by adding the steps needed for AKS deployment and the Python <span class="No-Break">catalog service.</span></p>
<p>The <strong class="source-inline">deploy.yml</strong> file will start with the following content; you will be adding to it in every <span class="No-Break">section hereafter:</span></p>
<pre class="source-code">
parameters:
- name: envName
  type: string
  default: 'test'
- name: azureSubscription
  type: string
  default: 'azure-packt-rg'
- name: resourceGroupName
  type: string
  default: 'packt'
- name: location
  type: string
  default: 'East US'
jobs:
- deployment: deployment_${{ parameters.envName }}
  displayName: Deploy to ${{ parameters.envName }}
  environment: ${{ parameters.envName }}
  strategy:
    runOnce:
      deploy:
        steps:</pre> <p>So far, you don’t <a id="_idIndexMarker466"/>have much in this file, but let’s break <span class="No-Break">it down:</span></p>
<ul>
<li>The <strong class="source-inline">parameters</strong> section defines all the values available for reuse within the pipeline definition. The only one being used from the main pipeline is the <strong class="source-inline">envName</strong> one, but this gives you the flexibility to change them <span class="No-Break">when needed.</span></li>
<li>The <strong class="source-inline">jobs</strong> collection includes a new job type you haven’t used before called <strong class="source-inline">deployment</strong>, which allows us to implement different rollout strategies. For simplicity, here you will be using the <strong class="source-inline">runOnce</strong> strategy, but you can also use <strong class="source-inline">canary</strong> and <strong class="source-inline">rolling</strong> where appropriate. To learn more about these, go <span class="No-Break">to </span><a href="https://learn.microsoft.com/en-us/azure/devops/pipelines/yaml-schema/jobs-deployment-strategy"><span class="No-Break">https://learn.microsoft.com/en-us/azure/devops/pipelines/yaml-schema/jobs-deployment-strategy</span></a><span class="No-Break">.</span></li>
</ul>
<p>Now, you can proceed with the first service <span class="No-Break">deployment steps.</span></p>
<h3>Deploying the Python catalog service to AKS</h3>
<p>The deployment <a id="_idIndexMarker467"/>of the Python catalog service to Azure Kubernetes Service is performed as a <span class="No-Break">two-phase process:</span></p>
<ol>
<li>Deploy the ARM template to create and configure the AKS cluster using IaC. Refer to <a href="B18875_08.xhtml#_idTextAnchor103"><span class="No-Break"><em class="italic">Chapter 8</em></span></a> for more information on how to <span class="No-Break">do this.</span></li>
<li>Deploy the application using the Helm chart provided in <span class="No-Break">the repository.</span></li>
</ol>
<p>In our <strong class="source-inline">deploy.yml</strong> file, you will add the following <span class="No-Break">six steps:</span></p>
<ol>
<li>The <strong class="source-inline">download</strong> task <strong class="source-inline">Download catalog iac</strong> retrieves the <span class="No-Break">pipeline artifact:</span><pre class="source-code">
- download: current
  displayName: 'Download catalog iac'
  artifact: catalog-iac</pre></li> <li>The <strong class="source-inline">AzureResourceGroupDeployment@2</strong> task performs the <span class="No-Break">AKS deployment:</span><pre class="source-code">
- task: AzureResourceGroupDeployment@2
  name: catalogInfra
  displayName: 'Deploy catalog Infra'
  inputs:
    azureSubscription: ${{ parameters.azureSubscription }}
    action: 'Create Or Update Resource Group'
    resourceGroupName: ${{ parameters.resourceGroupName }}
    location: ${{ parameters.location }}
    templateLocation: 'Linked artifact'
    csmFile: '$(Pipeline.Workspace)/catalog-iac/template.json'
    overrideParameters: '-environmentName ${{ parameters.envName }}'
    deploymentMode: 'Incremental'
    deploymentName: 'catalog-$(Build.BuildNumber)'
    deploymentOutputs: 'catalogInfraOutputs'</pre><p class="list-inset">Notice that you are using the <strong class="source-inline">deploymentOutputs</strong> property to set the name of a variable that will contain the outputs generated in the ARM template; this will be needed later for the <span class="No-Break">frontend deployment.</span></p></li> <li>The <strong class="source-inline">PowerShell@2</strong> task parses out the cluster name from the output <a id="_idIndexMarker468"/>parameters of the ARM template deployment and makes it available as another variable for the duration of <span class="No-Break">the job:</span><pre class="source-code">
- task: PowerShell@2
  displayName: 'Get AKS clusterName'
  inputs:
    targetType: 'inline'
    script: |
      $var=ConvertFrom-Json '$(catalogInfraOutputs)'
      $value=$var.clusterName.value
      Write-Host "AKS Cluster Name: $value"
      Write-Host "##vso[task.setvariable variable=clusterName;]$value"</pre></li> <li>The <strong class="source-inline">download</strong> task <strong class="source-inline">Download catalog helm chart</strong> retrieves <span class="No-Break">the artifact:</span><pre class="source-code">
- download: current
  displayName: 'Download catalog helm chart'
  artifact: catalog-helm-chart</pre></li> <li>The <strong class="source-inline">HelmInstaller@1</strong> task installs Helm in <span class="No-Break">the agent:</span><pre class="source-code">
- task: HelmInstaller@1
  displayName: 'Install Helm'
  inputs:
    helmVersionToInstall: 3.11.3</pre></li> <li>The <strong class="source-inline">HelmDeploy@0</strong> task <a id="_idIndexMarker469"/>performs an <strong class="source-inline">upgrade</strong> command with the <strong class="source-inline">install</strong> option set to <strong class="source-inline">true</strong>; this will guarantee that, if it’s not found, it will <span class="No-Break">be created:</span><pre class="source-code">
- task: HelmDeploy@0
  displayName: Deploy Catalog App to AKS
  inputs:
    connectionType: 'Azure Resource Manager'
    azureSubscription: ${{ parameters.azureSubscription }}
    azureResourceGroup: ${{ parameters.resourceGroupName }}
    kubernetesCluster: $(clusterName)
    releaseName: catalog
    chartType: FilePath
    chartPath: "$(Pipeline.Workspace)/catalog-helm-chart/packt-store-catalog-1.0.0.tgz"
    overrideValues: 'image.tag=$(Build.BuildNumber)'
    command: upgrade
    install: true
    waitForExecution: true</pre><p class="list-inset">Notice that, in this case, you are using the <strong class="source-inline">overrideValues</strong> property to pass in the <strong class="source-inline">BuildNumber</strong> value as the container tag to use, replacing the value of <strong class="source-inline">image.tag</strong> in the <span class="No-Break">Helm chart.</span></p><p class="list-inset">It’s worth noting the <a id="_idIndexMarker470"/>usage of a special output command in <span class="No-Break">this section:</span></p><pre class="source-code">"##vso[task.setvariable variable=name;]value"</pre><p class="list-inset">This is called a <strong class="bold">logging command</strong> in Azure Pipelines, and if a task writes this format into the console output, it<a id="_idIndexMarker471"/> will be interpreted as a command to set the value of a variable with the given <strong class="source-inline">name</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">value</strong></span><span class="No-Break">.</span></p><p class="list-inset">If the variable does not exist before running the command, then it will be created and made available <span class="No-Break">at runtime.</span></p></li> </ol>
<p>To learn more about how to work with variables<a id="_idIndexMarker472"/> in Azure Pipelines, go <span class="No-Break">to </span><a href="https://learn.microsoft.com/en-us/azure/devops/pipelines/process/set-variables-scripts"><span class="No-Break">https://learn.microsoft.com/en-us/azure/devops/pipelines/process/set-variables-scripts</span></a><span class="No-Break">.</span></p>
<p>Now let’s move on to the Node.js <span class="No-Break">cart service.</span></p>
<h3>Deploying a Node.js cart service to ACA</h3>
<p>The <a id="_idIndexMarker473"/>deployment of the cart service to ACA is a bit simpler; it just requires the use of the <strong class="source-inline">AzureResourceGroupDeployment@2</strong> task after the artifact <span class="No-Break">is downloaded:</span></p>
<pre class="source-code">
- download: current
  displayName: 'Download cart iac'
  artifact: cart-iac
- task: AzureResourceGroupDeployment@2
  name: cartInfra
  displayName: 'Deploy cart Infra'
  inputs:
    azureSubscription: ${{ parameters.azureSubscription }}
    action: 'Create Or Update Resource Group'
    resourceGroupName: ${{ parameters.resourceGroupName }}
    location: ${{ parameters.location }}
    templateLocation: 'Linked artifact'
    csmFile: '$(Pipeline.Workspace)/cart-iac/template.json'
    overrideParameters: '-environmentName ${{ parameters.envName }} -containerTag "$(Build.BuildNumber)"'
    deploymentMode: 'Incremental'
    deploymentName: 'cart-$(Build.BuildNumber)'
    deploymentOutputs: 'cartInfraOutputs'</pre> <p>Notice, in this<a id="_idIndexMarker474"/> case, the use of <strong class="source-inline">overrideParameters</strong> to pass in the value of the <strong class="source-inline">containerTag</strong> parameter <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">BuildNumber</strong></span><span class="No-Break">.</span></p>
<p>Next, you will add the deployment of the <span class="No-Break">checkout service.</span></p>
<h3>Deploying a .NET checkout service to ACI</h3>
<p>The <a id="_idIndexMarker475"/>deployment of the checkout service is very similar to the ACA deployment; the only difference is the use of the ACI service instead. See the <span class="No-Break">following steps:</span></p>
<pre class="source-code">
- download: current
  displayName: 'Download checkout iac'
  artifact: checkout-iac
- task: AzureResourceGroupDeployment@2
  name: checkoutInfra
  displayName: 'Deploy checkout Infra'
  inputs:
    azureSubscription: ${{ parameters.azureSubscription }}
    action: 'Create Or Update Resource Group'
    resourceGroupName: ${{ parameters.resourceGroupName }}
    location: ${{ parameters.location }}
    templateLocation: 'Linked artifact'
    csmFile: '$(Pipeline.Workspace)/checkout-iac/template.json'
    overrideParameters: '-environmentName ${{ parameters.envName }} -containerTag "$(Build.BuildNumber)"'
    deploymentMode: 'Incremental'
    deploymentName: 'checkout-$(Build.BuildNumber)'
    deploymentOutputs: 'checkoutInfraOutputs'</pre> <p>Just like<a id="_idIndexMarker476"/> you did in the Node.js deployment to ACA, in this section, you used <strong class="source-inline">overrideParameters</strong> to pass in the value of the <strong class="source-inline">containerTag</strong> parameter <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">BuildNumber</strong></span><span class="No-Break">.</span></p>
<p>Now let’s move on to the last application, <span class="No-Break">the frontend.</span></p>
<h3>Deploying an Angular frontend app to AAS</h3>
<p>For the <a id="_idIndexMarker477"/>frontend application, there are a few more steps necessary because of the need to gather information before being able to use the <span class="No-Break">ARM template.</span></p>
<p>You will be adding the following steps <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">deploy.yaml</strong></span><span class="No-Break">:</span></p>
<ol>
<li>The <strong class="source-inline">download</strong> task retrieves the frontend <span class="No-Break">pipeline artifact:</span><pre class="source-code">
- download: current
  displayName: 'Download frontend iac'
  artifact: frontend-iac</pre></li> <li>The <strong class="source-inline">AzureCLI@2</strong> task <strong class="source-inline">Get Catalog App IP from AKS</strong> is a script needed to retrieve the IP assigned to the exposed entry point of the catalog application. It uses the <strong class="source-inline">az</strong> CLI, the <strong class="source-inline">kubectl</strong> CLI, and the <strong class="source-inline">jq</strong> tool in Linux to parse out the information from Kubernetes. This is very specific to how this application was deployed. This script might not be reusable, but it is meant to show the <a id="_idIndexMarker478"/>flexibility of the tools <span class="No-Break">if needed:</span><pre class="source-code">
- task: AzureCLI@2
  displayName: 'Get Catalog App IP from AKS'
  inputs:
    azureSubscription: 'azure-packt-rg'
    scriptType: 'bash'
    scriptLocation: 'inlineScript'
    inlineScript: |
      az aks get-credentials -g ${{ parameters.resourceGroupName }} -n $(clusterName) --overwrite-existing
      ip=`kubectl get service catalog-packt-store-catalog -o json | jq ".status.loadBalancer.ingress[0].ip"`
      echo "Catalog App IP: $ip"
      echo «##vso[task.setvariable variable=catalogAppIp;]$ip"</pre></li> <li>The <strong class="source-inline">PowerShell@2</strong> task is used to parse out the fully qualified domain name contained in the output variables generated by the previous steps. It is used to deploy the <a id="_idIndexMarker479"/>catalog, cart, and <span class="No-Break">checkout services:</span><pre class="source-code">
- task: PowerShell@2
  displayName: 'Set App URLs'
  inputs:
    targetType: 'inline'
    script: |
      # Set the catalog app url
      $value="http://" + $(catalogAppIp) + ":5050/"
      Write-Host "Catalog App Url: $value"
      Write-Host "##vso[task.setvariable variable=catalogAppUrl;]$value"
      # Set the cart app url
      $var=ConvertFrom-Json '$(cartInfraOutputs)'
      $value=$var.containerAppFqdn.value
      $value="https://" + $var.containerAppFqdn.value + "/"
      Write-Host "Cart App Url: $value"
      Write-Host "##vso[task.setvariable variable=cartAppUrl;]$value"
      # Set the checkout app url
      $var=ConvertFrom-Json '$(checkoutInfraOutputs)'
      $value="http://" + $var.containerFQDN.value + ":5015/"
      Write-Host "Checkout App Url: $value"
      Write-Host "##vso[task.setvariable variable=checkoutAppUrl;]$value"</pre></li> <li>The <strong class="source-inline">AzureResourceGroupDeployment@2</strong> task deploys the Azure App Service instance and provides all the information necessary for the service to pull in the image, including the given <strong class="source-inline">BuildNumber</strong> as the tag. There are also the application <a id="_idIndexMarker480"/>URLs necessary to be stored in the service for the application <span class="No-Break">to work:</span><pre class="source-code">
- task: AzureResourceGroupDeployment@2
  name: frontendInfra
  displayName: 'Deploy frontend Infra'
  inputs:
    azureSubscription: ${{ parameters.azureSubscription }}
    action: 'Create Or Update Resource Group'
    resourceGroupName: ${{ parameters.resourceGroupName }}
    location: ${{ parameters.location }}
    templateLocation: 'Linked artifact'
    csmFile: '$(Pipeline.Workspace)/frontend-iac/template.json'
    overrideParameters: '-environmentName ${{ parameters.envName }} -containerTag "$(Build.BuildNumber)" -catalogAppUrl $(catalogAppUrl) -cartAppUrl $(cartAppUrl) -checkoutAppUrl $(checkoutAppUrl)'
    deploymentMode: 'Incremental'
    deploymentName: 'frontend-$(Build.BuildNumber)'
    deploymentOutputs: 'frontendInfraOutputs'</pre></li> <li>The <strong class="source-inline">PowerShell@2</strong> task <strong class="source-inline">Get Frontend URL</strong> then uses another script to parse the output of the ARM template deployment to provide it both in the logs and as a variable <a id="_idIndexMarker481"/>that could ultimately be used in additional steps, such as a web request to smoke test the endpoint. Alternatively, it could be used in automated <span class="No-Break">test execution:</span><pre class="source-code">
- task: PowerShell@2
  displayName: 'Get Frontend URL'
  inputs:
    targetType: 'inline'
    script: |
      # Get the frontend app url
      $var=ConvertFrom-Json '$(frontendInfraOutputs)'
      $value=$var.frontendUrl.value
      Write-Host "Frontend Url: $value"
      Write-Host "##vso[task.setvariable variable=frontendAppUrl;]$value"</pre></li> </ol>
<p>Wow, that was a lot of deployments, but you are not done! Once the test environment is complete, you get a chance to approve the continuation of deployment to production in the <span class="No-Break">next section.</span></p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor149"/>Approving environment deployments</h2>
<p>With the deployment<a id="_idIndexMarker482"/> to the test environment complete, you should be able to see the pipeline in the <strong class="bold">Waiting</strong> state, <span class="No-Break">as follows:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer250">
<img alt="Figure 9.17 – Stage awaiting for checks" height="466" src="image/B18875_09_17.jpg" width="815"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.17 – Stage awaiting for checks</p>
<p>This will only look like this if you are the reviewer configured for the manual approval check. Click on the <strong class="bold">Review</strong> button and a new screen will pop up with <strong class="bold">Reject</strong> and <strong class="bold">Approve</strong> options and the ability to provide a comment, as <span class="No-Break">shown here:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer251">
<img alt="Figure 9.18 – Approving an environment check" height="251" src="image/B18875_09_18.jpg" width="460"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.18 – Approving an environment check</p>
<p>If click the <strong class="bold">Approve</strong> button, the deployment will proceed. If you click the <strong class="bold">Reject</strong> button, the deployment will be canceled; also, if you don’t do anything and the timeout runs out, the pipeline will <span class="No-Break">be canceled.</span></p>
<p>Now that you have completed all the deployments, it is worth pointing out what to do if you run into issues with deployments; let’s talk now about some of the <span class="No-Break">typical ones.</span></p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor150"/>Troubleshooting deployment issues</h2>
<p>Creating<a id="_idIndexMarker483"/> a stable and reliable CI/CD pipeline takes time, especially when performing deployments to a cloud platform such as Azure. Let’s walk through some of the typical issues you can <span class="No-Break">run into.</span></p>
<h3>Issues deploying IaC</h3>
<p>You used <a id="_idIndexMarker484"/>ARM templates to deploy the infrastructure to host the services that run the applications in Azure in this chapter, which means you are relying on that infrastructure to succeed before you can deploy <span class="No-Break">the applications.</span></p>
<p>There are several situations in which the <strong class="source-inline">AzureResourceGroupDeploment</strong> task <span class="No-Break">can fail:</span></p>
<ul>
<li><strong class="bold">Internal server errors</strong>: These can occur if the Azure region you are trying to deploy is suddenly going through capacity issues or undergoing maintenance, or even if the Azure Pipelines service is going through <span class="No-Break">issues itself.</span><p class="list-inset"><em class="italic">How to fix it</em>: Usually there is no recovery from this except for attempting to run the failed pipeline again. If the region in Azure becomes unavailable, you will have to wait until it becomes available again or target a different region for deployment as part of your disaster <span class="No-Break">recovery strategy.</span></p></li>
<li><strong class="bold">Timeout</strong>: The deployment took too long, which could have been caused by the pipeline agent or the Azure deployment. The default timeout for Microsoft-hosted agents is 60 minutes in the free tier and 360 minutes when paying for <span class="No-Break">parallel jobs.</span><p class="list-inset"><em class="italic">How to fix it</em>: You have a way to increase the timeout at the job level if required, but most likely there are other reasons why your deployment is failing. You will have to analyze the errors in the pipeline to find the <span class="No-Break">root cause.</span></p></li>
</ul>
<p>For other tips regarding deployments<a id="_idIndexMarker485"/> using ARM templates, head <span class="No-Break">to </span><a href="https://learn.microsoft.com/en-us/azure/azure-resource-manager/templates/best-practices"><span class="No-Break">https://learn.microsoft.com/en-us/azure/azure-resource-manager/templates/best-practices</span></a><span class="No-Break">.</span></p>
<h3>Issues with scripts</h3>
<p>Scripts<a id="_idIndexMarker486"/> used in your pipelines need to be written in an <em class="italic">idempotent</em> manner, meaning that for every command or task to execute properly, the script must verify whether the operation is required and whether the result code is what is expected. This approach ensures that a script only performs the operations required to reach the desired state and, in doing so, checks every step of the way whether the operation is indeed required. Not following this approach leads to brittle scripts (scripts that are easily broken), especially when interacting with Azure resources where the current state might not match the <span class="No-Break">desired state.</span></p>
<p>To address this issue, always write your scripts in an idempotent way. Follow the <strong class="source-inline">if-not-then</strong> pattern for <span class="No-Break">every operation.</span></p>
<h3>Issues with Helm</h3>
<p>Here are <a id="_idIndexMarker487"/>some issues commonly observed when working <span class="No-Break">with Helm:</span></p>
<ul>
<li>Helm is a very<a id="_idIndexMarker488"/> convenient tool, but you are still responsible for the proper formatting of each of the manifests and making sure that they conform with and are valid for the Kubernetes API of your cluster. In this chapter, you learned how to use <strong class="bold">kube-linter</strong> to<a id="_idIndexMarker489"/> validate your Helm charts, but this is only a tool, and as such it can fail to detect issues. This tool only validates against the latest stable Kubernetes API, and if your cluster is not running this version, the validation will not catch issues that will arise when performing <span class="No-Break">a deployment.</span><p class="list-inset"><em class="italic">How to fix it</em>: There are other open source tools that can validate against specific Kubernetes versions and perform different checks against your Kubernetes objects. A couple of examples <a id="_idIndexMarker490"/>are <strong class="bold">kube-score</strong> (<a href="https://kube-score.com/">https://kube-score.com/</a>) and <strong class="bold">Kubeconform</strong> (<a href="https://github.com/yannh/kubeconform">https://github.com/yannh/kubeconform</a>); put <a id="_idIndexMarker491"/>each of them to the test and evaluate which works better for <span class="No-Break">your applications.</span></p></li>
<li>Another issue to expect with Helm is the deployment of Kubernetes objects and the underlying consequences of this in Azure, such as deploying additional services in the case of ingress controllers. This scenario entails the creation of other Azure resources that in turn can <span class="No-Break">sometimes fail.</span><p class="list-inset"><em class="italic">How to fix it</em>: If <a id="_idIndexMarker492"/>an operation failed due to a platform timeout or retriable error, there is nothing else to do but <span class="No-Break">deploy again.</span></p></li>
</ul>
<p>With this, we’ve finished the chapter. Let’s wrap <span class="No-Break">it up.</span></p>
<h1 id="_idParaDest-150"><a id="_idTextAnchor151"/>Winding up</h1>
<p>If you completed all the steps, you will have deployed test and production environments, so it is time to clean up! This is important because you have deployed many resources into Azure. Make sure to delete them if you do not want to keep paying for them. You can do this via the Azure portal or the following Azure <span class="No-Break">CLI command:</span></p>
<pre class="console">
az group delete -n packt -y</pre> <p>If you missed anything or got stuck and are having trouble putting the entire solution together, the complete pipeline definitions can be found in the GitHub repository mentioned in the <em class="italic">Technical requirements</em> section; look in the <strong class="source-inline">ch09/azure</strong> directory, specifically the <span class="No-Break"><strong class="bold">complete</strong></span><span class="No-Break"> branch.</span></p>
<p>Now, let’s recap what we have learned in <span class="No-Break">this chapter.</span></p>
<h1 id="_idParaDest-151"><a id="_idTextAnchor152"/>Summary</h1>
<p>In this chapter, we took a complex solution and learned how to create CI/CD pipelines in a modular way, taking advantage of stages, environments, and templates. We also learned about adding checks throughout the stages of a pipeline. In this case, we added manual approval, but we saw that there are other controls that can be put in place to implement more complex scenarios. We learned briefly about containers and how building container-based applications with Docker Compose is easy and facilitates working with different programming languages at the same time in your pipelines; it also reduces the complexities of compiling and packaging them. We learned about semantic versioning and its applicability while learning about how build numbers can be used to tag or name artifacts from your pipelines, along with the importance of tracking artifacts. Lastly, we walked through the deployment of different services in Azure using ARM templates, learning about some of the intricacies of tying them together and the flexibility of pipelines to coordinate templates, regardless of the number of services to <span class="No-Break">be deployed.</span></p>
<p>Now that we have learned how to build and deploy this complex solution to different Azure services, the next chapter will be about doing this using <strong class="bold">Amazon Web </strong><span class="No-Break"><strong class="bold">Services</strong></span><span class="No-Break"> instead.</span></p>
</div>
</div></body></html>