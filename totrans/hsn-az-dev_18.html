<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Scaling Azure Applications</h1>
                </header>
            
            <article>
                
<p class="mce-root">We cannot talk about reliable and stable applications in the cloud without scaling. While this process may have seemed a bit complicated and cumbersome in models like <strong><span>Infrastructure as a service</span></strong> (<strong>IaaS</strong>) or on-premises, Azure gives many different ways to multiply our applications quickly, and without downtime.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Autoscaling, scaling up, scaling out</li>
<li>Scaling Azure App Services</li>
<li>Scaling Azure Functions</li>
<li>Scaling Azure Service Fabric</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To perform exercises from this chapter, you will need the following:</p>
<ul>
<li>Access to an Azure subscription</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Autoscaling, scaling up, scaling out</h1>
                </header>
            
            <article>
                
<p>The cloud is all about scaling—it is one of the most important advantages of such a setup over an on-premises setup. The ability to rapidly adapt to new demands when it comes to incoming traffic, and the flexibility a cloud offers, enables you to create more stable services, which are less prone to unexpected load spikes and insufficient hardware performance. In this chapter, we will focus a little bit on diving deeper into the scaling topic, in order to build a deep understanding of how different services behave in Azure, and how you can ensure that the scaling feature is automated and requires as little attention as possible.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Autoscaling</h1>
                </header>
            
            <article>
                
<p>You can define the autoscaling feature of many services as follows:</p>
<p class="mce-root">Autoscaling is a feature that allows a service, a machine, or an application to automatically scale up or out based on predefined parameters, like CPU utilization, memory used, or artificial factors, like throughput units, or worker utilization.</p>
<p>In general, <span>you</span> can describe autoscaling as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/fa77e25e-3e0c-4897-8cc8-d8528d641cb5.png" style="width:47.67em;height:23.33em;" width="654" height="320"/></p>
<p>The preceding diagram can be described as follows:</p>
<ul>
<li>A resource accepts incoming requests as normal</li>
<li>Simultaneously there is an entity that monitors a resource—it checks it against the scaling rules and decides whether a scaling operation is required</li>
<li>An entity takes a decision regarding scaling—it can scale a resource up/down or out, depending on the settings</li>
</ul>
<p>Of course, besides pros, scaling has its downsides:</p>
<ul>
<li>It may render your application unresponsive.</li>
<li>It requires additional resources for load balancing (if scaling out).</li>
<li>It takes time, depending on the scaling characteristics. It is, therefore, crucial to plan such action at the design stage.</li>
<li>In many cases, it causes your solution to be many times more expensive.</li>
</ul>
<p>How a service scales depends solely on the service itself. Let us look at some examples:</p>
<ul>
<li>Azure Event Hub can be scaled manually/automatically (using the auto-inflate feature). You can assign more <strong>Throughput Units</strong> (<strong>TUs</strong>) to an instance to enable it to accept more messages. Automatic scaling down is not implemented.</li>
<li>Azure App Services can be scaled both manually and automatically (it depends on the tier you have chosen). You have multiple different parameters available, and scaling down is also performed automatically.</li>
<li>Azure Cosmos DB relies on the <strong>Request Unit</strong> (<strong>RU</strong>) units assigned to an instance.</li>
<li>Azure SQL has different models for scaling—you can either use <strong>Database Transaction Units</strong> (<strong>DTUs</strong>) or vCores.</li>
<li>Azure Functions scale automatically using an internal mechanism of workers and the scale controller.</li>
<li>Azure Storage does not support scaling.</li>
</ul>
<p>As you can see, there is no single solution for scaling your services in Azure—you have to implement the working solution for each component individually. The rule of thumb is, that the less control over a resource you have, the more automated the scaling will be. While for IaaS scenarios, you have to operate the number of VMs, in <strong>PaaS</strong>, you will end up with virtual cores or other units. Here you can find different cloud models ordered from the left to right in terms of the scaling complexity (where <strong>IaaS </strong>has the most complex model):</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/1d912af6-3636-4479-9bdb-161a28786647.png" style="width:28.75em;height:6.92em;" width="425" height="102"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Scaling up and scaling out</h1>
                </header>
            
            <article>
                
<p>There are two different types of scaling (at least when it comes to Azure):</p>
<ul>
<li><strong>Scaling up</strong>: Which upgrades hardware/a tier</li>
<li><strong>Scaling out</strong>: Which adds instances of a service</li>
</ul>
<p class="mce-root">Scaling up can be presented as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/1a513d79-aa6c-4a23-87d8-3cabc2869497.png" style="width:23.58em;height:10.08em;" width="359" height="153"/></p>
<p>While for comparison, scaling out is described as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/1c33d2df-b3f0-462c-bfd1-3bd650af9260.png" style="width:18.50em;height:21.08em;" width="297" height="336"/></p>
<p>So, in the first scenario (scaling up), you will get a better performance from a single instance, while scaling out will allow you to parallelize your work. The use cases are different in both options and are basically dependent on the workload you are planning to run. These are some examples:</p>
<ul>
<li>If your code is sequential and there is no option to multiply it, use scaling up</li>
<li>If your code requires much compute power in a unit of time rather than dividing it into multiple machines, use scaling up</li>
<li>If you have a way to load balance your load, use scaling out</li>
<li>If you are able to perform the same work on multiple machines without a risk of collision, use scaling out</li>
</ul>
<p>Using scaling out can be compared to multithreading<span>—</span>but of course on a much bigger scale. In fact, the problems are quite the same. If your machine has multiple cores, and they are able to execute your code at the same time, you have to introduce very similar constraints. </p>
<div class="packt_tip">The common problems of scaling out are often caused by the access to the state<span>—</span>whether it is shared via any kind of storage, or distributed amongst many machines. Make sure you are aware of these before using this feature.</div>
<p>In Azure, multiple services scale out/up differently. We will focus on three of them to get a better understanding of the topic.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Scaling Azure App Services</h1>
                </header>
            
            <article>
                
<p>We started our journey through Microsoft Azure by learning some basics of Azure App Services. This is a very common PaaS component, which is widely used amongst many Azure users, both for very simple websites and complex systems requiring high performance and reliability. To make sure that your Web App is always on, or to check if it is under pressure, you have to implement some kind of scaling rules. When it comes to this service, you have two options<span>—</span>either using manual scaling (and implementing some kind of alert, so that you know when such action should happen), or an autoscale feature, which makes things much easier in terms of maintenance. In this section, we will cover and compare both of them.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Manual scaling</h1>
                </header>
            
            <article>
                
<p>Manual scaling is a feature that is available starting from the basic tier<span>—</span>it is not available for free or shared ones. Depending on the actual tier chosen, there will be a different amount of instances that can be used for your App Service.</p>
<p class="mce-root"/>
<p>Here you can find how things look like for the B2<strong> </strong>tier:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/c2f624db-159a-4f2d-ad4b-f8d50bddc4b5.png" width="783" height="327"/></p>
<p>In the preceding configuration, the maximum number of instances available is set to three. However, if I scale up to the standard<strong> </strong>tier the result is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/1c607a76-daea-426f-9f40-85489217e93c.png" width="1191" height="391"/></p>
<p>Things look quite different—two features have changed:</p>
<ol>
<li>I can set the <span class="packt_screen">Instance count </span>to the maximum number of <span class="packt_screen">10</span></li>
<li>Autoscaling can be enabled</li>
</ol>
<div class="packt_figref packt_tip">Note that scaling up to the premium tier will allow you to set the maximum number of 20 instances for your App Service.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Autoscaling</h1>
                </header>
            
            <article>
                
<p>While manual scaling can be fine for less demanding websites and systems (as they do not require quick actions when something happens), when your application is, for example, a popular e-commerce shop, you want things to happen quickly, including scaling out. Let us try to enable autoscaling for now—it will display a form that enables you to manage these settings:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/85583c51-eef5-46d3-9a2a-134cd4acdc65.png" width="1196" height="718"/></div>
<p>In fact, you have two options here:</p>
<ol>
<li><span class="packt_screen">Scale based on a metric</span>: Allows you to select a metric, which will be a trigger for autoscaling</li>
<li><span class="packt_screen">Sc</span><span class="packt_screen">ale to a specific instance count</span>: Executed by default (so should be used along with scaling based on a metric)</li>
</ol>
<p>To configure <span class="packt_screen">scale based on a metric</span>, you will need a rule. You can add this by clicking on the <span class="packt_screen">+</span> <span class="packt_screen">Add a rule</span><strong> </strong>link. Doing so will display another form (which is far more complex than the current one), where you can select all that is interesting for you:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/1eab9c44-c38c-4d0e-a920-17ece24af5a2.png" style="width:20.00em;height:38.25em;" width="381" height="727"/></p>
<p>In the preceding screenshot, you can see a rule that will trigger autoscaling when CPU utilization exceeds 70% over a 10 minute period. Once all conditions are met, the runtime will add another instance to the App Service. What is more, if the conditions are true after another 5 minutes (<span class="packt_screen">Cool down (minutes)</span><strong> </strong>period), the scaling out operation will be triggered once more. This will happen as long as the maximum number of instances, which you have set, are hit.</p>
<div class="packt_tip">Remember that you can set more than a single rule for your application. What is more, it seems like a good idea to create a decreasing count by rule, which will remove additional instances if the load gets back to normal.</div>
<p>Once your rule is added, you can click <span class="packt_screen">Save </span>to confirm your changes—now your application will be scaled out anytime a rule is considered active. Before we go further, I would like to show you two more things. You probably noticed two additional sections on the <span class="packt_screen">Scale-out</span><strong> </strong>blade, <span class="packt_screen">JSON </span>and <span class="packt_screen">Notify</span>. They give you some additional options when it comes to managing a service:</p>
<ul>
<li><span class="packt_screen">JSON</span>:<strong> </strong>This generates a JSON template, which can be used with ARM Templates for automatic provisioning of your resource. It will automatically add scaling rules when a service is created.</li>
<li><span class="packt_screen">Notify</span>: This enables you to automatically send a notification to administrators of the resource in Azure, to notify them when something wrong happens there.</li>
</ul>
<p>Here you can find a JSON, which was generated for my rules:</p>
<pre>{<br/>    "location": "West Europe",<br/>    "tags": {<br/>        "$type": "Microsoft.WindowsAzure.Management.Common.Storage.CasePreservedDictionary, Microsoft.WindowsAzure.Management.Common.Storage"<br/>    },<br/>    "properties": {<br/>        "name": "handsonazure-euw-webapp-autoscale",<br/>        "enabled": true,<br/>        "targetResourceUri": "/subscriptions/1a2d5d1c-dee5-4deb-a93a-366cc83feb46/resourceGroups/handsonazure-euw-rg/providers/Microsoft.Web/serverfarms/handsonazure-euw-appserviceplan",<br/>        "profiles": [<br/>            {<br/>                "name": "Auto created scale condition",<br/>                "capacity": {<br/>                    "minimum": "1",<br/>                    "maximum": "10",<br/>                    "default": "1"<br/>                },<br/>                "rules": [<br/>                    {<br/>                        "scaleAction": {<br/>                            "direction": "Increase",<br/>                            "type": "ChangeCount",<br/>                            "value": "1",<br/>                            "cooldown": "PT5M"<br/>                        },<br/>                        "metricTrigger": {<br/>                            "metricName": "CpuPercentage",<br/>                            "metricNamespace": "",<br/>                            "metricResourceUri": "/subscriptions/1a2d5d1c-dee5-4deb-a93a-366cc83feb46/resourceGroups/handsonazure-euw-rg/providers/Microsoft.Web/serverFarms/handsonazure-euw-appserviceplan",<br/>                            "operator": "GreaterThan",<br/>                            "statistic": "Average",<br/>                            "threshold": 70,<br/>                            "timeAggregation": "Average",<br/>                            "timeGrain": "PT1M",<br/>                            "timeWindow": "PT10M"<br/>                        }<br/>                    }<br/>                ]<br/>            }<br/>        ],<br/>        "notifications": [],<br/>        "targetResourceLocation": "West Europe"<br/>    },<br/>    "id": "/subscriptions/1a2d5d1c-dee5-4deb-a93a-366cc83feb46/resourceGroups/handsonazure-euw-rg/providers/microsoft.insights/autoscalesettings/handsonazure-euw-webapp-autoscale",<br/>    "name": "handsonazure-euw-webapp-autoscale",<br/>    "type": "Microsoft.Insights/autoscaleSettings"<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Scaling Azure Functions</h1>
                </header>
            
            <article>
                
<p>When using PaaS services, you can configure how your application will behave when CPU utilization hits the maximum allowed value, or the number of requests exceeds the threshold. However, Azure offers services in other models—one of the most interesting is serverless architecture, which abstracts the control even more in favor of easier configuration, minimum maintenance, and ability to focus on delivering a business value.</p>
<p>In this section, you will see the differences between Azure App Services and Azure Functions when it comes to scaling, both from the technical and conceptual point of view.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Scaling serverless applications</h1>
                </header>
            
            <article>
                
<p>When you are using serverless services (such as Azure Functions, Azure Cosmos DB, or Azure Event Grid) you have limited options when it comes to configuring the feature. For example:</p>
<ul>
<li>In Azure Functions, you rely on the pricing model (consumption plan vs App Service Plan)</li>
<li>In Azure Cosmos DB you modify the number of RUs</li>
<li>In Azure Event Grid you have no way to define how the service will scale</li>
</ul>
<p>This is all caused by the fact that you do not control the application host—the underlying service engine is completely detached from your application and there is no possibility to directly modify it. What you can do is to control it indirectly, either by changing the number of processing units or via available configuration options, which can be interpreted and applied.</p>
<div class="packt_tip">Note that serverless is meant to be a model where you are isolated from the runtime (and, in some cases, even from the cloud vendor). If the lack of control does not play well for you, it is better to try PaaS or IaaS models and services.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Scaling Azure Functions</h1>
                </header>
            
            <article>
                
<p>In Azure Functions, there is no possibility to scale up, at least for the consumption plan. Of course, when using the App Service Plan, you can scale it up and get better hardware, but it does not affect the service itself. Instead it creates more resources to consume. On the other hand, you cannot scale out manually. The only possibility is to let Azure Functions scale automatically. To do so, this service implements the concept of a scale controller. This is an internal feature that constantly monitors how particular workers hosting the Function's runtime behave, and if one of them seems to be overloaded, another machine is added to the set.</p>
<div class="packt_infobox">Azure Functions scaling behavior is quite sophisticated and only partially described, as it contains parts that are either open sourced, or not available publicly. I will try to describe it in detail in this chapter, so you are aware of the exact algorithm of making a scaling decision.</div>
<p>Before your instance of Azure Functions will make a scaling decision, it will check the following:</p>
<ol>
<li><strong>Scaling interval</strong>: Scaling only happens after a specific interval has passed.</li>
<li><strong>Current workers number</strong>: If the number of workers (running the function's hosts) exceeds the configured maximum, a decision will be made to remove one from the working set.</li>
<li><strong>Load factor</strong>: If the load factor approaches the maximum value, a new worker will be added. Alternatively, if the load factor drops, one worker will be removed.</li>
<li><strong>Busy worker ratio</strong>: If the number of busy workers exceeds the configured maximum, another worker will be added to the set.</li>
<li><strong>Free workers</strong>: If the number of free workers is greater than the defined maximum, one of them will be removed from the working set.</li>
</ol>
<p>Defined values for above actions can be found as follows:</p>
<pre>public const int DefaultMaxWorkers = 100;<br/>public const int DefaultBusyWorkerLoadFactor = 80;<br/>public const double DefaultMaxBusyWorkerRatio = 0.8;<br/>public const int DefaultFreeWorkerLoadFactor = 20;<br/>public const double DefaultMaxFreeWorkerRatio = 0.3;<br/>public static readonly TimeSpan DefaultWorkerUpdateInterval = TimeSpan.FromSeconds(10);<br/>public static readonly TimeSpan DefaultWorkerPingInterval = TimeSpan.FromSeconds(300);<br/>public static readonly TimeSpan DefaultScaleCheckInterval = TimeSpan.FromSeconds(10);<br/>public static readonly TimeSpan DefaultManagerCheckInterval = TimeSpan.FromSeconds(60);<br/>public static readonly TimeSpan DefaultStaleWorkerCheckInterval = TimeSpan.FromSeconds(120);</pre>
<div class="packt_tip packt_infobox">The above values come from the GitHub repository of Azure Functions Host. They may be changed after a while, but if you are interested, take a look at the following project: <a href="https://github.com/Azure/azure-functions-host">https://github.com/Azure/azure-functions-host</a></div>
<p>Additionally, you can control the maximum number of instances by providing the <kbd>WEBSITE_MAX_DYNAMIC_APPLICATION_SCALE_OUT</kbd> value in the <span class="packt_screen">Application settings</span><strong> </strong>of your Function App:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/64803ef4-3405-4209-94bd-638630fc7e44.png" style="width:38.50em;height:21.42em;" width="656" height="364"/></div>
<p>What is more, if you connect the instance of your Function App to an instance of Azure Application Insights, you will be able to check how many workers it has by checking the <span class="packt_screen">Live Metrics Stream</span><strong> </strong>feature:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/d9d73ea1-2a92-4b52-9963-8720975ef810.png" width="1151" height="328"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Scaling Azure Service Fabric</h1>
                </header>
            
            <article>
                
<p>We have discussed two different models for scaling by working with two separate Azure services; Azure App Services and Azure Functions.</p>
<p>They are quite different when it comes to adding new instances or improving hardware performance, in that they introduce multiple concepts, and offer a different level of flexibility. In the last section of this chapter, we will cover one more service, Azure Service Fabric. This particular Azure product behaves in a slightly different manner when it comes to scaling up or out, as it requires you to manage VMs. In addition, a distinct set of skills is necessary to perform this operation seamlessly and in the right fashion.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Scaling a cluster manually</h1>
                </header>
            
            <article>
                
<p>Clusters in Azure Service Fabric can be scaled in two ways:</p>
<ul>
<li><strong>Manually</strong>: By choosing appropriate options in the cluster configuration</li>
<li><strong>Programatically</strong>: By using the Azure SDK</li>
</ul>
<p>In fact, the characteristics of your cluster are selected at the very beginning, when you are choosing node types and their configuration, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/3ea7a121-f82c-4d89-8b97-90dded7bdd1f.png" width="1201" height="577"/></p>
<p>Scaling Azure Service Fabric service is similar to scaling VMs, as it is based on nodes containing an unspecified number of virtual machines, which means you really depend on scale sets. </p>
<div class="packt_tip">It is always better to set up a cluster that will handle the planned load than scale it under pressure, especially when you require strict transactional assurances, which may impact scaling time. Take a look at the <em>Further reading</em><strong> </strong>section, where you will find an article describing efficient cluster planning.</div>
<p>When using scaling with Azure Service Fabric, remember that adding machines to the scale set always takes time. Therefore, consider planning such operations early, so the impact on the current operations will be minimized. To actually scale out your cluster, you have use the <span class="packt_screen">Scaling </span>feature of the scale set, which was created with it, <span>as shown in the following screenshot</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/f81be57a-cb32-4403-b297-27196e4748e1.png" width="1199" height="415"/></div>
<p>The other option to perform such operation is to use ARM template with the following snippet:</p>
<pre>"resources":[<br/>    {<br/>      "type":"Microsoft.Compute/virtualMachineScaleSets",<br/>      "apiVersion":"2017-03-30",<br/>      "name":"[parameters('&lt;scale-set-name&gt;')]",<br/>      "location":"[resourceGroup().location]",<br/>      "sku":{<br/>        "name":"[parameters('&lt;sku&gt;')]",<br/>        "tier":"&lt;tier&gt;",<br/>        "capacity":"[parameters('&lt;capacity&gt;')]"<br/>      }<br/>    }<br/>]</pre>
<p>By providing the <kbd>&lt;capacity&gt; </kbd>value, you may easily change the number of virtual machines powering your SF cluster.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using Azure SDK to scale your cluster</h1>
                </header>
            
            <article>
                
<p>Another option to scale your cluster is to use the Azure compute SDK. You may wonder what are the use cases for that particular feature—all in all, we already have manual/auto-scaling available. However, there are more advanced scenarios, which may be suitable for scaling using your own controller:</p>
<ul>
<li>Scaling using a custom metric, which is not available for autoscaling.</li>
<li>Performing additional operations before scaling can happen.</li>
<li>Full control over scaling operation in case of critical workloads.</li>
</ul>
<div class="packt_infobox">To get the Azure compute SDK, you have to download the following NuGet package: Microsoft.Azure.Management.Fluent available at: <a href="https://www.nuget.org/packages/Microsoft.Azure.Management.Fluent/">https://www.nuget.org/packages/Microsoft.Azure.Management.Fluent/</a>. Similar libraries can be found for other languages (like Java or Python—you can find them in the link in the <em>Further Reading</em> section).</div>
<p>To scale out your cluster, you may use the following code snippet:</p>
<pre>var vmScaleSet = AzureClient.VirtualMachineScaleSets.GetById(ScaleSetId);<br/>var capacity = (int)Math.Min(MaximumNodeCount, vmScaleSet.Capacity + 1);<br/>vmScaleSet.Update().WithCapacity(capacity).Apply(); </pre>
<p>The same can be used for Java:</p>
<pre>vmScaleSet.update().withCapacity(capacity).apply();</pre>
<p>As you can see, it is a pretty simple piece of code—you just need to obtain the current scale set ID to get a reference to it, and then change its capacity. In this example, I used a value of <kbd>1</kbd>, but there is nothing that prevents you from using other numbers.</p>
<div class="packt_tip">With the preceding example, you can also scale down your cluster. However, remember that you should not scale down below the cluster's reliability tier. If you do so, you no longer can rely on it and may destabilize it.</div>
<p>If you are using a higher reliability tier than bronze<strong>,</strong> you do not need to worry about unused machines as they will be automatically removed. Otherwise, you have to do it manually. To do so, you actually have to know which VMs are not currently used. To remove a node that is no longer required, you can use the following operations:</p>
<pre>await client.ClusterManager.DeactivateNodeAsync(node.NodeName, NodeDeactivationIntent.RemoveNode);<br/>scaleSet.Update().WithCapacity(capacity).Apply(); <br/>await client.ClusterManager.RemoveNodeStateAsync(node.NodeName);</pre>
<p>They basically do three different things:</p>
<ol>
<li>Deactivate and remove a node from a cluster</li>
<li>Decrease a scale set capacity</li>
<li>Remove a node state</li>
</ol>
<p>To find a node to be removed, you have to query a cluster and seek the most recent machine added:</p>
<pre>using (var client = new FabricClient())<br/>{<br/>    var node = (await client.QueryManager.GetNodeListAsync())<br/>        .Where(n =&gt; n.NodeType.Equals(NodeTypeToScale, StringComparison.OrdinalIgnoreCase))<br/>        .Where(n =&gt; n.NodeStatus == System.Fabric.Query.NodeStatus.Up)<br/>        .OrderByDescending(n =&gt;<br/>        {<br/>            var instanceIdIndex = n.NodeName.LastIndexOf("_");<br/>            var instanceIdString = n.NodeName.Substring(instanceIdIndex + 1);<br/>            return int.Parse(instanceIdString);<br/>        })<br/>        .FirstOrDefault();<br/>}</pre>
<div class="packt_infobox">You may wonder why the most recently added machine is selected to be the victim of the scaling operation. This is because work was delegated to it as the result of higher cluster utilization. Originally it was not a part of the set. and once it finished its job, it can be removed.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered the scaling of three completely different services—Azure App Service, Azure Functions, and Azure Service Fabric. You saw how this operation works for different application models—sometimes you scale service instances, VMs, or simply you do not control it and let the runtime do it for you. In fact, scaling services in the cloud is much easier than when using your own servers. You do not have to reconfigure load balancers, firewalls, routers, and servers. When using the scaling feature, always try to automate the process—manual scaling works only for very simple scenarios, and tends to keep your servers underutilized.</p>
<p>In the next two chapters, we will cover two additional Azure services, Azure CDN and Azure Traffic Manager, which help in keeping your applications available, even under heavy load.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is the difference between scaling up and scaling out?</li>
<li>What are the use cases for scaling out?</li>
<li>Is scaling up available in serverless services?</li>
<li>Does scaling out in Azure App Services affect the pricing of the service?</li>
<li>Why can scaling operation be dangerous in Azure Service Fabric?</li>
<li>What are the cons of manual scaling?</li>
<li>What do you do if you want to automatically scale your Azure App Service when CPU utilization reaches 80%?</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li>Service Fabric cluster planning: <a href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-cluster-capacity">https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-cluster-capacity</a></li>
<li>Service Fabric cluster scaling: <a href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-cluster-scaling">https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-cluster-scaling</a></li>
<li>Azure SDKs: <a href="https://docs.microsoft.com/en-us/azure/index#pivot=sdkstools&amp;panel=sdkstools-all">https://docs.microsoft.com/en-us/azure/index#pivot=sdkstools&amp;panel=sdkstools-all</a></li>
</ul>


            </article>

            
        </section>
    </div>



  </body></html>