- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating Multi-Container Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book guides you step by step along the path of developing your applications
    using containers. In previous chapters, we learned how to create container images,
    how to share them, and, finally, how to run application processes within containers.
    In this chapter, we will go a step further by running applications using multiple
    containers. This is the method you would probably use for developing your applications,
    running different interconnected components, sharing information, and publishing
    only the frontend processes to users. By the end of this chapter, you will be
    able to build, deliver, and run applications by using a composition of multiple
    containers managed all at once with a newly learned command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and using Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the Docker Compose file syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and sharing multi-container applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running and debugging multi-container applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing multiple environments with Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use open source tools for building, sharing, and running an application
    composed of multiple containers. The labs for this chapter will help you understand
    the content presented, and they are published at [https://github.com/PacktPublishing/Containers-for-Developers-Handbook/tree/main/Chapter5](https://github.com/PacktPublishing/Containers-for-Developers-Handbook/tree/main/Chapter5).
    The *Code In Action* video for this chapter can be found at [https://packt.link/JdOIY](https://packt.link/JdOIY).
  prefs: []
  type: TYPE_NORMAL
- en: Installing and using Docker Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Docker Compose** is a tool developed by Docker Inc. to help developers create,
    deliver, and run applications with multiple components running within containers.
    This tool may come with your Docker container runtime distribution or have to
    be installed separately. If you are using tools such as **Podman**, you will also
    have available equivalent command-line tools.'
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose, developed in 2014 as an open source project, aims to manage
    multiple containers based on YAML definitions. This command line will talk directly
    with the Docker container runtime API. This means that all containers managed
    by a `docker-compose` file will run together on top of the same container runtime,
    hence on the same host. Understanding this is key because you will need third-party
    tools and configurations if you need to provide high availability for your applications.
    We can think of Docker Compose as a single-node container orchestrator.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using Docker Desktop, you will notice that Docker Compose is already
    available for you. It should be integrated into your WSL environment if you checked
    the **Enable integration** option in your Docker Desktop (this option should be
    already checked for all previous chapters’ labs and examples in your environment).
    You can verify this by quickly accessing your Docker Desktop’s settings by navigating
    to **Settings** | **Resources** | **WSL Integration**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Docker Desktop WSL Integration settings](img/B19845_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Docker Desktop WSL Integration settings
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you can open a terminal in your WSL environment and simply execute `which
    docker-compose`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Docker Desktop installs a modern Docker CLI environment, and this includes
    a `docker-compose` built-in link. You can verify this by simply retrieving the
    related information as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, we can use either `docker-compose` or `docker compose` for running
    `compose` commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using the Docker container runtime directly on your computer and
    your client environment does not include this built-in link, you will need to
    properly install `docker-compose` binaries. You can use any of the following procedures:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker-compose` module by using the Python package installer (`pip install
    docker-compose`). This will install the latest Python-based `docker-compose` release
    (1.29.2):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'However, this method will be deprecated as newer `docker-compose` binaries
    are built using the Go language. We can check the version currently installed
    by using the `–``version` argument:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`docker-compose` package. We will show you the steps for Ubuntu 22.04, which
    provides the required package and its dependencies:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, this method also installs the latest Python-based version of
    `docker-compose`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Docker Compose v1 will be deprecated in June, 2023\. We should use at least
    Docker Compose v2 and an appropriate command-line release based on Go. This release
    may be installed automatically with Docker Desktop, as mentioned at the beginning
    of this section, or by using Docker Compose as a Docker client plugin.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`docker-compose-plugin`. We will show you the following Ubuntu process as an
    example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to install `docker-compose` directly by downloading its binary
    from the project’s GitHub repository. You can use the following link for further
    instructions: [https://docs.docker.com/compose/install/linux/#install-the-plugin-manually](https://docs.docker.com/compose/install/linux/#install-the-plugin-manually).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we install `docker-compose` by following any of the methods described,
    we are ready to quickly review the main features available:'
  prefs: []
  type: TYPE_NORMAL
- en: We can build multiple images, code blocks, and Dockerfiles, which may be separated
    into different folders. This is very useful for automating the construction of
    all application components at once.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing the applications’ container image components is easier with `docker-compose`,
    as all images will be pushed at once.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can start and stop applications based on multiple containers with `docker-compose`.
    All components will run at the same time by default, although we can define dependencies
    between components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All applications’ standard errors and output will be available from a single
    command, which means that we can access all application logs at once. This will
    be very useful when debugging interactions between multiple components at the
    same time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provisioning and decommissioning environments are very easy using `docker-compose`,
    as all required application components will be created and removed by using simple
    actions such as `docker compose create` and `docker` `compose rm`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker-compose` perfect for easily sharing data and isolating inter-process
    communication. We will publish only specific application processes, while others
    will be kept internal, hidden from the users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use `<PROJECT>-<SERVICE_NAME>` syntax. We can retrieve the list of running
    projects by using `docker-compose ls`. This command will show you all running
    `docker-compose` projects with their Compose YAML file definitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using `docker-compose --profile prod up --detach` to launch our application
    in production, while using `--profile debug` will run some additional components/services
    for debugging. We will use the `profile` key in our Compose YAML file to group
    services, which can be added to multiple profiles. We will use a string to define
    these profiles and we will use it later in the `docker-compose` command line.
    If no profile is specified, `docker-compose` will execute the actions without
    using any profile (objects with no profile will be used).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following list shows the main actions available for `docker-compose`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`config`: This action will check and show a review of the Compose YAML file.
    It can be used in combination with `--services` or `--volumes` arguments to retrieve
    only these objects. As mentioned before, `--profile` can be used to specifically
    retrieve information about a certain set or group of objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`images`: This shows the images defined in our Compose YAML file. This will
    be useful if you are wondering whether images will need to be built or may already
    be present in your environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`build`: This action makes `docker-compose` a great tool, even if you are planning
    to deploy your applications on a container orchestration cluster such as Kubernetes,
    as we are able to build all our application components’ container images with
    just one command. Images created using `docker-compose` will include the project’s
    name in its name; hence, they will be identified as `<PROJECT_NAME>-<SERVICE_NAME>`.
    A Dockerfile should be included in all component directories, although we can
    override the building of certain images by specifying an image repository directly.
    Remember all the content we learned about tagging images in [*Chapter 3*](B19845_03.xhtml#_idTextAnchor082),
    *Shipping Docker Images*. We can modify the build context and the Dockerfile filename
    using the `context` and `dockerfile` keys, respectively. If our Dockerfile contains
    various targets, we can define which one will be used for building the service’s
    image by using the `target` key. Arguments can also be passed to the build process
    to modify the environment by using the `args` key with a list of the key-value
    pairs that should be included.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pull`/`push`: The images defined can be downloaded all at once and the build
    definitions can also be pushed to remote registries once your images are created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`up`: This action is equivalent to executing `docker run` for each component/service
    defined in our Compose YAML file. By default, `docker compose up` will start all
    the containers at once and our terminal will attach to all containers’ outputs,
    which may be interesting for testing but not for production (our terminal will
    be stuck attached to the processes, and we must use *Ctrl* + *P* + *Q* to detach
    from them). To avoid this situation, we should use the `-d` or `--detach` argument
    to launch our containers in the background. `docker-compose` also supports the
    `run` action, but this is generally used for running specific services one at
    a time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`down`: This action, as expected, does the opposite of `up`; it will stop and
    remove all the containers that are running. It is important to understand that
    new containers will be created if they were previously removed by using this action.
    Any persistent data must be stored outside of the container’s life cycle. To completely
    remove your application, remember to always remove the associated volumes. We
    can add the `--volumes` argument to force the removal of any associated volume.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`create`/`run`/`start`/`stop`/`rm`: All these actions are equivalent to the
    ones we learned about in [*Chapter 4*](B19845_04.xhtml#_idTextAnchor096), *Running
    Docker Containers*, but in this case, they will apply to multiple containers at
    once.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ps`: As we are running multiple containers for a project, this action will
    list all associated containers. Containers’ performances can be reviewed by using
    `docker-compose top`, which is an extension of the `docker stats` command we learned
    in [*Chapter 4*](B19845_04.xhtml#_idTextAnchor096), *Running* *Docker Containers*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exec`: This option allows us to execute a command attached to one of the containers
    (in this case, a project’s service).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logs`: We can use `docker-compose logs` to retrieve all the project’s container
    logs. This is very useful for retrieving all application logs by using a single
    point of view and just one command. The container output will be separated by
    colors and all the filter options learned about in [*Chapter 4*](B19845_04.xhtml#_idTextAnchor096),
    *Running Docker Containers*, as well as by `--follow`, which continuously follows
    all of them. We can retrieve just one service log by adding the service name as
    an argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Although you will usually execute `docker-compose` actions against all containers,
    it is possible to specify one service at a time by adding the specific service
    name, `docker-compose <ACTION> <SERVICE>`. This option is extensible to almost
    all commands and very useful for debugging purposes when things go wrong with
    some containers.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to install `docker-compose` and what features we may expect,
    we can learn how to create applications using it.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Docker Compose file syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use `docker-compose` with a YAML file, in which we will define all the
    services, volumes, and networks that will run together and be managed as components
    of an application. The YAML file used should follow the **Compose application
    model** (more information is available at [https://github.com/compose-spec/compose-spec/blob/master/spec.md](https://github.com/compose-spec/compose-spec/blob/master/spec.md)).
    This model will distribute application components in **services** and their intercommunication
    with each other using **networks**. These networks provide the isolation and abstraction
    layers for our application containers. Services will store and share their data
    by using **volumes**.
  prefs: []
  type: TYPE_NORMAL
- en: Services may need additional configurations, and we will use **config** and
    **secret** resources to add specific information to manage the application’s behavior.
    These objects will be mounted inside our containers, and processes running inside
    them will use the provided configurations. Secrets will be used to inject sensitive
    data and the container runtime will treat them differently.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed earlier in this chapter, Compose v1 will be deprecated soon, and
    you should migrate to at least Compose v2\. Your files may need some changes.
    You can verify this by reviewing the documentation at [https://docs.docker.com/compose/compose-file/compose-versioning](https://docs.docker.com/compose/compose-file/compose-versioning).
    The Compose application model specification merges the object definitions from
    v2 and v3.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s deep dive into the Docker Compose YAML file definition keys.
  prefs: []
  type: TYPE_NORMAL
- en: YAML file definition keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, the `docker-compose` command will look for `docker-compose.yaml`
    or `compose.yaml` files in the current directory (you can use either `.yaml` or
    `.yml` extensions). Multiple Compose files can be used at the same time, and the
    order in which they appear will define the final file specification to use. Values
    will be overridden by the latest ordered file. We can also use variables that
    can be expanded in runtime by setting our environment variables. This will help
    us use a general file with variables for multiple environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic schema of a Compose YAML file will be presented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Each service will need at least a container image definition or a directory
    where its Dockerfile is located.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s review the Compose syntax with an example file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first line is used to identify the Compose syntax version used. Currently,
    the `version` key is only informative, added for backward compatibility. If some
    keys are not allowed in the current Compose release, we will be warned, and those
    keys will be ignored. At the time of writing this book, Compose YAML files do
    not require this `version` key.
  prefs: []
  type: TYPE_NORMAL
- en: 'This Compose YAML file contains three service definitions: `lb`, `db`, and
    `app`. All of them have an `image` key, which defines the image repository that
    will be used for creating each service. We also have a `build` key, which defines
    the directory that will be used for building the defined image. Having both keys
    will allow us to create the required image with the defined name before executing
    the service. As you may have noticed, we have defined dependencies for the `app`
    service. This service depends on the `lb` and `db` services; hence, their containers
    must be running and healthy before any `app` container starts. Health checks defined
    in each container image will be used to verify the healthiness of the container’s
    processes. That’s why you, as a developer, should define the appropriate health
    checks for your application’s components.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Although, in this example, we used the `depends_on` key, it is very important
    to include the management of different component dependencies in our application’s
    code. This is important because the `depends_on` key is only available in Compose
    YAML files. When you deploy your applications in Docker Swarm or Kubernetes, the
    dependencies can’t be managed in the same way. Compose manages dependencies for
    you, but this feature does not exist in orchestrated environments and your applications
    should be prepared for that. You may, for example, verify the connectivity with
    your database component before executing certain tasks, or you might manage the
    exceptions in your code related to the loss of this connection. Your application
    component may need several components, and you should decide what your application
    has to do if one of them is down. Key application components should stop your
    code in case full application functionality breaks.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we also defined one volume, `pgdata`, and a network, `simplestlab`.
    The `volumes` and `networks` sections allow us to define objects to be used by
    the containers. Each defined service should include the volumes and networks that
    should be attached to the service’s containers. Containers associated with a service
    will be named after the service name, including the project as a prefix. Each
    container is considered an instance for the service and will be numbered; hence,
    the final container will be named `<PROJECT_NAME>-<SERVICE_NAME>-<INSTANCE_NUMBER>`.
  prefs: []
  type: TYPE_NORMAL
- en: We can have more than one instance per service. This means that multiple containers
    may run for a defined service. We will use `--scale SERVICE_NAME=<NUMBER_OF_REPLICAS>`
    to define the number of replicas that should be running for a specific service.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, dynamic names will be used for the service containers,
    but we can use the `container_name` key to define a specific name. This may be
    interesting for accessing a container name from other containers, but this service
    wouldn’t be able to scale because, as you already know, container names are unique
    for each container runtime; thus, we cannot manage replicas in this situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compose YAML files allow us to overwrite all the keys defined in the container
    images. We will include them inside each `services` definition block. In the presented
    example, we have included some environment variables for all services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you may notice, these environment variables define some configurations that
    will change the application components’ behavior. Some of these configurations
    contain sensitive data, and we can use additional Compose objects such as `secrets`.
    Non-sensitive data can be written using `config` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'For these objects, an additional key will be used at the root level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we changed all the `app` component environment variables for
    a `config` object, which will be mounted inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: By default, `config` object files will be mounted in `/<source>` if no `target`
    key is used. Although there is a short version for mounting `config` object files
    inside service containers, it is recommended to use the presented long format,
    as it allows us to specify the complete paths for both `source` and `target`,
    as well as the file’s permissions and ownership.
  prefs: []
  type: TYPE_NORMAL
- en: Secret objects are only available in `swarm` mode. This means that even if you
    are just using a single node, you must execute `docker swarm init` to initialize
    a single-node Swarm cluster. This will allow us to create secrets, which are stored
    as cluster objects by the Docker container engine. Compose can manage these objects
    and present them in our service’s containers. By default, secrets will be mounted
    inside containers in the `/run/secrets/<SECRET_NAME>` path, but this can be changed,
    as we will see in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a secret with the database password, used in the `db` service,
    by using `docker` `secret create`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can change our Compose YAML file to include this new `secret`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we created the secret using the standard output and we used
    `external: true` to declare that the secret is already set and the container runtime
    must use its key store to find it. We could have used a file instead as the source.
    It is also common to integrate some files as `secrets` inside containers by adding
    them in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The main difference here is that you may be using a plain text file as a secret
    that will be encrypted by the Docker container runtime and mounted inside your
    containers. Anyone with access to this plain text file will read your secrets.
    Using the standard output increases security because only the container runtime
    will have access to the `secret` object. In fact, the Docker Swarm store can also
    be encrypted, adding a new layer of security.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the basic Compose YAML syntax, we can continue learning
    how to use these files to build and share our application’s container images.
  prefs: []
  type: TYPE_NORMAL
- en: Building and sharing multi-container applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker Compose allows you to run multi-container applications on single nodes.
    These applications will not really have high availability, as you will have a
    single point of failure and you will probably prefer to use orchestrated clusters
    by using Kubernetes or Docker Swarm. But even in these situations, `docker-compose`
    will help you build and manage the container images for your project. In this
    section, we will learn how to use these features.
  prefs: []
  type: TYPE_NORMAL
- en: Your Compose YAML file will have some service definitions, and each service’s
    container will need an image definition or a `build` directory. The `image` key
    will be used for either downloading this image from a registry (if it does not
    exist in your container runtime already) or setting the name of the service’s
    container image to be created if a `build` folder exists. As we already mentioned
    in the previous section, the project’s name will be used as a prefix for all your
    images by default, but having this `image` key overrides this. Project prefixes
    will help you identify all the images prepared for a project but may be confusing
    when a project must be executed twice (two different project instances). In such
    situations, it may be convenient to prepare and push your images for both projects
    instead of building them with default folder names.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now focus on the `build`-related keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As we mentioned, the `image` key defines the images to be downloaded but in
    this situation, the `build` key is also present with a folder string, which means
    that this folder will be used for building the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you may notice, a project name is included to avoid using the default directory
    name as a prefix, but the images created used the repository and tag strings defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s remove the `image` key lines and launch the `build` process again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'services:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'frontend:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'build:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'secrets:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- server-certificate'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'secrets:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'server-certificate:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'file: ./server.cert'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'services:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'frontend:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'build:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'secrets:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- source: server-certificate'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'target: server.cert'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'uid: "103"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'gid: "103"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'mode: 0440'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'secrets:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'server-certificate:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'file: ./server.cert'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ docker-compose --project-name test push --include-deps app
  prefs: []
  type: TYPE_NORMAL
- en: '[+] Running 0/26bc077c4d137 Layer already exists   3.6s'
  prefs: []
  type: TYPE_NORMAL
- en: '⠇ Pushing lb: 0bc077c4d137 Layer already exists    3.8s'
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: '⠧ Pushing db: a65fdf68ac5a Layer already exists    3.7s'
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: '⠧ Pushing app: 7dfc1aa4c504 Layer already exists   3.7s'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: $ docker-compose ls
  prefs: []
  type: TYPE_NORMAL
- en: NAME                STATUS              CONFIG FILES
  prefs: []
  type: TYPE_NORMAL
- en: test                running(3)          /home/frjaraur/labs/simplest-lab/docker-compose.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: $ docker-compose --project-name test \
  prefs: []
  type: TYPE_NORMAL
- en: --file /home/frjaraur/labs/simplest-lab/docker-compose.yaml ps
  prefs: []
  type: TYPE_NORMAL
- en: NAME                IMAGE                                         COMMAND                  SERVICE             CREATED             STATUS              PORTS
  prefs: []
  type: TYPE_NORMAL
- en: test-app-1          docker.io/frjaraur/simplest-lab:simplestapp   "node simplestapp.js…"   app                 25
    hours ago        Up 28 minutes       3000/tcp
  prefs: []
  type: TYPE_NORMAL
- en: test-db-1           docker.io/frjaraur/simplest-lab:simplestdb    "docker-entrypoint.s…"   db                  25
    hours ago        Up 24 minutes       5432/tcp
  prefs: []
  type: TYPE_NORMAL
- en: test-lb-1           docker.io/frjaraur/simplest-lab:simplestlb    "/entrypoint.sh
    /bin…"   lb                  25 hours ago        Up 24 minutes       0.0.0.0:8080->80/tcp
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: $ docker-compose --project-name test exec db ps -ef
  prefs: []
  type: TYPE_NORMAL
- en: PID   USER     TIME  COMMAND
  prefs: []
  type: TYPE_NORMAL
- en: 1 postgres  0:00 postgres
  prefs: []
  type: TYPE_NORMAL
- en: '53 postgres  0:00 postgres: checkpointer'
  prefs: []
  type: TYPE_NORMAL
- en: '54 postgres  0:00 postgres: background writer'
  prefs: []
  type: TYPE_NORMAL
- en: '55 postgres  0:00 postgres: walwriter'
  prefs: []
  type: TYPE_NORMAL
- en: '56 postgres  0:00 postgres: autovacuum launcher'
  prefs: []
  type: TYPE_NORMAL
- en: '57 postgres  0:00 postgres: stats collector'
  prefs: []
  type: TYPE_NORMAL
- en: '58 postgres  0:00 postgres: logical replication launcher'
  prefs: []
  type: TYPE_NORMAL
- en: 90 root      0:00 ps -ef
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'env_file:'
  prefs: []
  type: TYPE_NORMAL
- en: '- ./debug.env'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'services:'
  prefs: []
  type: TYPE_NORMAL
- en: 'lb:'
  prefs: []
  type: TYPE_NORMAL
- en: 'build:'
  prefs: []
  type: TYPE_NORMAL
- en: 'context: ./simplestlb'
  prefs: []
  type: TYPE_NORMAL
- en: 'args:'
  prefs: []
  type: TYPE_NORMAL
- en: 'alpineversion: "1.14"'
  prefs: []
  type: TYPE_NORMAL
- en: 'dockerfile: Dockerfile.${environment}'
  prefs: []
  type: TYPE_NORMAL
- en: 'labels:'
  prefs: []
  type: TYPE_NORMAL
- en: 'org.codegazers.description: "Test image"'
  prefs: []
  type: TYPE_NORMAL
- en: 'image: ${dockerhubid}/simplest-lab:simplestlb'
  prefs: []
  type: TYPE_NORMAL
- en: 'environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '- APPLICATION_ALIAS=simplestapp'
  prefs: []
  type: TYPE_NORMAL
- en: '- APPLICATION_PORT=${backend_port}'
  prefs: []
  type: TYPE_NORMAL
- en: 'networks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'simplestlab:'
  prefs: []
  type: TYPE_NORMAL
- en: 'aliases:'
  prefs: []
  type: TYPE_NORMAL
- en: '- simplestlb'
  prefs: []
  type: TYPE_NORMAL
- en: 'ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '- "${loadbalancer_port}:80"'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: environment=dev
  prefs: []
  type: TYPE_NORMAL
- en: dockerhubid=frjaraur
  prefs: []
  type: TYPE_NORMAL
- en: loadbalancer_port=8080
  prefs: []
  type: TYPE_NORMAL
- en: backend_port=3000
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: $ docker-compose --project-name test \
  prefs: []
  type: TYPE_NORMAL
- en: --file myapp-docker-compose.yaml config
  prefs: []
  type: TYPE_NORMAL
- en: 'name: test'
  prefs: []
  type: TYPE_NORMAL
- en: 'services:'
  prefs: []
  type: TYPE_NORMAL
- en: 'lb:'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 'context: /home/frjaraur/tests/dcadeg/chapter5/simplest-lab/simplestlb'
  prefs: []
  type: TYPE_NORMAL
- en: 'dockerfile: Dockerfile.dev'
  prefs: []
  type: TYPE_NORMAL
- en: 'args:'
  prefs: []
  type: TYPE_NORMAL
- en: 'alpineversion: "1.14"'
  prefs: []
  type: TYPE_NORMAL
- en: 'labels:'
  prefs: []
  type: TYPE_NORMAL
- en: 'org.codegazers.description: Test image'
  prefs: []
  type: TYPE_NORMAL
- en: 'environment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'APPLICATION_ALIAS: simplestapp'
  prefs: []
  type: TYPE_NORMAL
- en: 'APPLICATION_PORT: "3000"'
  prefs: []
  type: TYPE_NORMAL
- en: 'image: frjaraur/simplest-lab:simplestlb'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 'ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '- mode: ingress'
  prefs: []
  type: TYPE_NORMAL
- en: 'target: 80'
  prefs: []
  type: TYPE_NORMAL
- en: 'published: "8080"'
  prefs: []
  type: TYPE_NORMAL
- en: 'protocol: tcp'
  prefs: []
  type: TYPE_NORMAL
- en: 'networks:'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: $ dockerhubid=myid \
  prefs: []
  type: TYPE_NORMAL
- en: docker-compose --project-name test \
  prefs: []
  type: TYPE_NORMAL
- en: --file myapp-docker-compose.yaml config
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: 'image: myid/simplest-lab:simplestlb'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'version: "3.7"'
  prefs: []
  type: TYPE_NORMAL
- en: 'services:'
  prefs: []
  type: TYPE_NORMAL
- en: 'lb:'
  prefs: []
  type: TYPE_NORMAL
- en: 'build: simplestlb'
  prefs: []
  type: TYPE_NORMAL
- en: 'image: myregistry/simplest-lab:simplestlb'
  prefs: []
  type: TYPE_NORMAL
- en: 'environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '- APPLICATION_ALIAS=simplestapp'
  prefs: []
  type: TYPE_NORMAL
- en: '- APPLICATION_PORT=3000'
  prefs: []
  type: TYPE_NORMAL
- en: 'networks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'simplestlab:'
  prefs: []
  type: TYPE_NORMAL
- en: 'aliases:'
  prefs: []
  type: TYPE_NORMAL
- en: '- simplestlb'
  prefs: []
  type: TYPE_NORMAL
- en: 'ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '- "8080:80"'
  prefs: []
  type: TYPE_NORMAL
- en: 'db:'
  prefs: []
  type: TYPE_NORMAL
- en: 'build: simplestdb'
  prefs: []
  type: TYPE_NORMAL
- en: 'image: myregistry/simplest-lab:simplestdb'
  prefs: []
  type: TYPE_NORMAL
- en: 'environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '- "POSTGRES_PASSWORD=changeme"'
  prefs: []
  type: TYPE_NORMAL
- en: 'networks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'simplestlab:'
  prefs: []
  type: TYPE_NORMAL
- en: 'aliases:'
  prefs: []
  type: TYPE_NORMAL
- en: '- simplestdb'
  prefs: []
  type: TYPE_NORMAL
- en: 'volumes:'
  prefs: []
  type: TYPE_NORMAL
- en: '- pgdata:/var/lib/postgresql/data'
  prefs: []
  type: TYPE_NORMAL
- en: 'app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'build: simplestapp'
  prefs: []
  type: TYPE_NORMAL
- en: 'image: myregistry/simplest-lab:simplestapp'
  prefs: []
  type: TYPE_NORMAL
- en: 'environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '- dbhost=simplestdb'
  prefs: []
  type: TYPE_NORMAL
- en: '- dbname=demo'
  prefs: []
  type: TYPE_NORMAL
- en: '- dbuser=demo'
  prefs: []
  type: TYPE_NORMAL
- en: '- dbpasswd=d3m0'
  prefs: []
  type: TYPE_NORMAL
- en: 'networks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'simplestlab:'
  prefs: []
  type: TYPE_NORMAL
- en: 'aliases:'
  prefs: []
  type: TYPE_NORMAL
- en: '- simplestapp'
  prefs: []
  type: TYPE_NORMAL
- en: 'depends_on:'
  prefs: []
  type: TYPE_NORMAL
- en: '- lb'
  prefs: []
  type: TYPE_NORMAL
- en: '- db'
  prefs: []
  type: TYPE_NORMAL
- en: 'volumes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'pgdata:'
  prefs: []
  type: TYPE_NORMAL
- en: 'networks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'simplestlab:'
  prefs: []
  type: TYPE_NORMAL
- en: 'ipam:'
  prefs: []
  type: TYPE_NORMAL
- en: 'driver: default'
  prefs: []
  type: TYPE_NORMAL
- en: 'config:'
  prefs: []
  type: TYPE_NORMAL
- en: '- subnet: 172.16.0.0/16'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: $ docker-compose --file \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: simplestlab/docker-compose.yaml \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --project-name chapter5 build
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[+] Building 0.0s (0/0)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: …
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: => => writing image sha256:2d88460e20ca557fcd25907b5f026926b0e61d93fde58a8e0b854cfa0864c3bd                       0.0s
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: docker-compose run to build or pull the images and run all containers, but this
    way, we can review the process step by step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ docker image ls
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: REPOSITORY                TAG           IMAGE ID       CREATED         SIZE
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: myregistry/simplest-lab   simplestapp   2d88460e20ca   8 minutes ago   73.5MB
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: myregistry/simplest-lab   simplestdb    e872ee4e9593   8 minutes ago   243MB
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: build key exists, the build process is executed instead of pulling images directly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ docker-compose --file \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: simplestlab/docker-compose.yaml \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --project-name chapter5 create db
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[+] Running 3/3'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ':: Network chapter5_simplestlab  Created                                              0.8s'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ':: Volume "chapter5_pgdata"      Created                                                     0.0s'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ':: Container chapter5-db-1       Created                             0.2s'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ docker-compose --file \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: simplestlab/docker-compose.yaml \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --project-name chapter5 up -d db
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[+] Running 1/1'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ':: Container chapter5-db-1  Started'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ docker-compose ps
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'no configuration file provided: not found'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: $ docker-compose --file simplestlab/docker-compose.yaml ps
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: NAME                IMAGE               COMMAND             SERVICE             CREATED             STATUS              PORTS
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ docker-compose --file \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: simplestlab/docker-compose.yaml \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --project-name chapter5 ps
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: NAME                IMAGE                                COMMAND                  SERVICE             CREATED             STATUS              PORTS
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'lb and app services by using docker-compose up -d:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ docker-compose --file \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: simplestlab/docker-compose.yaml \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --project-name chapter5 ps
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: NAME                IMAGE                                 COMMAND                  SERVICE             CREATED             STATUS              PORTS
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: chapter5-app-1      myregistry/simplest-lab:simplestapp   "node simplestapp.js…"   app                 9
    minutes ago       Up 9 minutes        3000/tcp
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: chapter5-db-1       myregistry/simplest-lab:simplestdb    "docker-entrypoint.s…"   db                  16
    minutes ago      Up 15 minutes       5432/tcp
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'simplestlab application by connecting with your browser to http://127.0.0.1:8080:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ docker-compose --file \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: simplestlab/docker-compose.yaml \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --project-name chapter5 up --scale app=2 -d
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[+] Running 4/4'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ':: Container chapter5-db-1   Running                          0.0s'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ':: Container chapter5-lb-1   Running                           0.0s'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ':: Container chapter5-app-2  Created                               0.2s'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'app service’s logs. We will retrieve both containers’ logs:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ docker-compose --file \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: simplestlab/docker-compose.yaml \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --project-name newdemo create
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[+] Running 0/0'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ':: Network newdemo_simplestlab  Error    0.0s'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'docker-compose definition:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And now we try to deploy the application again:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ docker-compose --file simplestlab/docker-compose.yaml --project-name newdemo
    start
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[+] Running 1/2'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ':: Container newdemo-db-1  Started                            1.4s'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ':: Container newdemo-lb-1  Starting                                    1.4s'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: lb service. This seems fine for production, but defining a specific port in
    development, where multiple copies of an application can be expected, also breaks
    the dynamism of container-based components. For this to work, we could just simply
    change this port number, allow the system to choose a random one for us, or define
    a variable that will allow us to define a port for each project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'services:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'lb:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: …
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ports:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- "${LB_PORT}:80"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ LB_PORT=8081 docker-compose --file \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: simplestlab/docker-compose.yaml \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --project-name newdemo up lb
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[+] Running 1/1'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ':: Container newdemo-lb-1  Recreated'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ docker-compose --file simplestlab/docker-compose.yaml --project-name newdemo
    ps
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: WARN[0000] The "LB_PORT" variable is not set. Defaulting to a blank string.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: NAME                IMAGE                                COMMAND                  SERVICE             CREATED             STATUS              PORTS
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: newdemo-db-1        myregistry/simplest-lab:simplestdb   "docker-entrypoint.s…"   db                  11
    minutes ago      Up 8 minutes        5432/tcp
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: newdemo-lb-1        myregistry/simplest-lab:simplestlb   "/entrypoint.sh /bin…"   lb                  46
    seconds ago      Up 34 seconds       0.0.0.0:8081->80/tcp
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: $ docker-compose --file simplestlab/docker-compose.yaml --project-name newdemo
    up app -d
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[+] Running 3/3'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ':: Container newdemo-db-1   Running                              0.0s'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ':: Container newdemo-lb-1   Running                       0.0s'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'docker-compose.yaml file, we were able to deploy a second project using a unique
    Compose YAML file. We can list the projects deployed in our host along with their
    number of components:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ docker-compose -f  /home/frjaraur/labs/Chapter5/simplestlab/docker-compose.yaml
    --project-name chapter5 down
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: WARN[0000] The "LB_PORT" variable is not set. Defaulting to a blank string.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[+] Running 5/5'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ':: Container chapter5-app-2      Removed                          0.1s'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ':: Container chapter5-app-1      Removed                          0.1s'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ':: Container chapter5-db-1       Removed                          0.1s'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ':: Container chapter5-lb-1       Removed                          0.1s'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ':: Network chapter5_simplestlab  Removed                          0.6s'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ docker volume ls
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: DRIVER    VOLUME NAME
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: local     chapter5_pgdata
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'chapter5 project, but we will use the --volumes argument to remove all the
    volumes associated with a project:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ docker volume ls
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: DRIVER    VOLUME NAME
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: local     chapter5_pgdata
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ docker volume rm  chapter5_pgdata
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: chapter5_pgdata
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Part 2:Container Orchestration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part of the book, we will cover the **orchestration** of containers
    in cluster-wide environments. We will learn how to deploy distributed component
    applications on different hosts in a cluster, allowing users to interact with
    components and publish services.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 6*, *Fundamentals of Orchestration*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B19845_07.xhtml#_idTextAnchor147), *Orchestrating with Swarm*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B19845_08.xhtml#_idTextAnchor170), *Deploying Applications with
    the Kubernetes Orchestrator*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
