- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Running Docker Containers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行 Docker 容器
- en: Software containers are the new standard application artifacts for modern platforms.
    In the previous chapters, we learned to create software container images and share
    them with other developers or services. In this chapter, we will learn how to
    effectively work with containers. We will understand the main Docker containers’
    objects and how to manage them using the appropriate command-line actions and
    options. Understanding the container network model and how to manage persistent
    data is key for working with containers. We will also cover the concepts for managing
    both. At the end of this chapter, we will review some very important maintenance
    tasks you should know about so that you can manage your environment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 软件容器是现代平台的标准应用程序制品。在前几章中，我们学习了如何创建软件容器镜像并与其他开发者或服务共享它们。本章将学习如何有效地使用容器。我们将理解主要的
    Docker 容器对象以及如何使用适当的命令行操作和选项来管理它们。理解容器网络模型以及如何管理持久化数据是使用容器的关键。我们还将介绍管理这两者的概念。最后，本章将回顾一些你应该了解的重要维护任务，以便你能够有效地管理你的环境。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding Docker software container objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 Docker 软件容器对象
- en: Learning about using the command line to work with containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用命令行与容器互动
- en: Limiting container access to host resources
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制容器访问主机资源
- en: Managing container behavior
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理容器行为
- en: Container runtime maintenance tasks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器运行时维护任务
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This book teaches you how to use software containers to improve your application’s
    development. The labs for this chapter can be found at [https://github.com/PacktPublishing/Docker-for-Developers-Handbook/tree/main/Chapter4](https://github.com/PacktPublishing/Docker-for-Developers-Handbook/tree/main/Chapter4).
    Here, you will find some extended explanations that have been omitted in this
    chapter’s content to make it easier to follow. The *Code In Action* video for
    this chapter can be found at [https://packt.link/JdOIY](https://packt.link/JdOIY).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本书教你如何使用软件容器来提升应用程序的开发效率。本章的实验可以在[https://github.com/PacktPublishing/Docker-for-Developers-Handbook/tree/main/Chapter4](https://github.com/PacktPublishing/Docker-for-Developers-Handbook/tree/main/Chapter4)找到。在这里，你将找到本章内容中为便于理解而省略的一些扩展解释。本章的*实战视频*可以在[https://packt.link/JdOIY](https://packt.link/JdOIY)观看。
- en: Let’s begin this chapter by introducing the most important Docker container
    objects.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从介绍最重要的 Docker 容器对象开始。
- en: Understanding Docker software container objects
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 Docker 软件容器对象
- en: 'Container runtimes usually work by following a client-server model. We interact
    with the runtime by using a client command line such as `docker`, `nerdctl`, or
    `crictl`, depending on the backend. The runtime itself is responsible for managing
    different objects or resources, which can easily be manipulated by interacting
    with it. Before we learn how to interact with and manage software containers,
    we will learn about the different objects that are managed by the container runtime
    in this section. All commands or actions will be related to them, to either create,
    remove, or modify their properties. We learned about container images in [*Chapter
    1*](B19845_01.xhtml#_idTextAnchor015), *Modern Infrastructure and Applications
    with Docker*, and [*Chapter 2*](B19845_02.xhtml#_idTextAnchor036), *Building Docker
    Images*, where we also learned how to build them. Let’s start by reviewing these
    well-known objects, which are common within all container runtimes:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 容器运行时通常采用客户端-服务器模型工作。我们通过使用客户端命令行（如`docker`、`nerdctl`或`crictl`）与运行时进行交互，具体取决于后端。运行时本身负责管理不同的对象或资源，用户可以通过与其交互轻松地操作这些对象。在我们学习如何与软件容器交互并管理容器之前，本节将介绍容器运行时管理的不同对象。所有命令或操作将与这些对象相关，目的是创建、删除或修改它们的属性。我们在[*第1章*](B19845_01.xhtml#_idTextAnchor015)《使用
    Docker 的现代基础设施与应用程序》和[*第2章*](B19845_02.xhtml#_idTextAnchor036)《构建 Docker 镜像》中学习了容器镜像，并且还学会了如何构建它们。让我们从复习这些在所有容器运行时中通用的著名对象开始：
- en: '**Container images**: These objects are also referred to as **container artifacts**.
    They are the base for creating a container because they contain all the files,
    integrated into different layers, that will be included inside a container’s filesystem.
    The images also contain the meta-information required for running a container,
    such as the processes that will run internally, the ports that will be exposed
    externally, the volumes that will be used to override the container’s filesystem,
    and so on. You, as a developer, will create and use a lot of images for your applications.
    Please take the best practices for security that were reviewed in [*Chapter 2*](B19845_02.xhtml#_idTextAnchor036),
    *Building Docker Images*, into account.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器镜像**：这些对象也被称为**容器工件**。它们是创建容器的基础，因为它们包含所有文件，并集成到不同的层中，这些文件将包含在容器的文件系统内。镜像还包含运行容器所需的元信息，例如将要在内部运行的进程、将暴露到外部的端口、将用于覆盖容器文件系统的卷等。作为开发者，你将为你的应用创建并使用大量镜像。请参考在[*第二章*](B19845_02.xhtml#_idTextAnchor036)《构建
    Docker 镜像》中回顾的安全最佳实践。'
- en: '**Containers**: When we use a container image and run a container using it,
    we are telling the container runtime to execute the processes defined in the image’s
    meta-information and use the image layers to provide a base filesystem for these
    processes. Kernel features such as cgroups and namespaces are also provided to
    isolate containers. This makes it possible to run different containers in the
    same hosts in a secure way. None of them will see each other unless specifically
    declared. The container’s filesystem layer will be added on top of the image layers
    in read and write mode. All layers below the container layer will be used in read-only
    mode, and the files that have been modified or created will be managed using the
    features of CoW filesystems.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器**：当我们使用容器镜像并运行容器时，我们是在告诉容器运行时执行镜像元信息中定义的进程，并使用镜像层提供这些进程所需的基础文件系统。内核特性如
    cgroups 和命名空间也被提供，以隔离容器。这使得在同一主机上以安全的方式运行不同的容器成为可能。除非特别声明，否则它们互相无法看到。容器的文件系统层将以读写模式添加到镜像层之上，所有低于容器层的层将以只读模式使用，已修改或创建的文件将使用
    CoW 文件系统的特性进行管理。'
- en: '`docker0` bridge interface at the host level, although other network options
    and drivers can be used. The container runtime manages IP addresses with an internal
    IPAM, and a NAT is used to allow container access to the real host’s attached
    network. Network objects allow us to create different bridge interfaces and attach
    containers to them, isolating containers running within different networks.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主机级别，`docker0` 桥接接口，尽管也可以使用其他网络选项和驱动程序。容器运行时通过内部 IPAM 管理 IP 地址，并使用 NAT 允许容器访问主机附加的真实网络。网络对象允许我们创建不同的桥接接口并将容器连接到它们，隔离在不同网络中运行的容器。
- en: '**Volumes**: CoW filesystems may impact the application’s behavior. If your
    processes change a lot of files or any file must persist throughout a container’s
    life cycle, a volume must be used to override CoW filesystem management. We use
    volumes to store files outside of the container’s layers. These can be folders
    in our host system, remote filesystems, or even external block devices. Different
    drivers can be used and, by default, volumes will be locally available in each
    underlying host as folders.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卷**：CoW 文件系统可能会影响应用程序的行为。如果你的进程修改了大量文件或任何文件必须在容器的生命周期中持久化，则必须使用卷来覆盖 CoW 文件系统管理。我们使用卷来存储容器层之外的文件。这些可以是我们主机系统中的文件夹、远程文件系统，甚至是外部块设备。可以使用不同的驱动程序，并且默认情况下，卷将作为文件夹在每个底层主机中本地可用。'
- en: All these objects will be identified by unique IDs and we will use either their
    names or IDs to refer to them. Common actions for creating and removing them will
    be available in our client command line. We can also list them and inspect their
    properties, and we can use Go template formatting, as we learned in [*Chapter
    2*](B19845_02.xhtml#_idTextAnchor036), *Building* *Docker Images*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些对象将通过唯一的 ID 进行标识，我们将使用它们的名称或 ID 来引用它们。创建和删除它们的常见操作将在我们的客户端命令行中提供。我们还可以列出它们并检查它们的属性，并且我们可以使用
    Go 模板格式化，就像我们在[*第二章*](B19845_02.xhtml#_idTextAnchor036)《构建 Docker 镜像》中学到的那样。
- en: Container orchestrators will have their own set of objects or resources (in
    Kubernetes). We will review them in [*Chapter 7*](B19845_07.xhtml#_idTextAnchor147),
    *Orchestrating with Swarm*, and [*Chapter 8*](B19845_08.xhtml#_idTextAnchor170),
    *Deploying Applications with* *the* *Kubernetes* *Orchestrator*, respectively.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 容器编排器将拥有一组自己的对象或资源（如在 Kubernetes 中）。我们将在 [*第 7 章*](B19845_07.xhtml#_idTextAnchor147)《与
    Swarm 编排》以及 [*第 8 章*](B19845_08.xhtml#_idTextAnchor170)《使用 Kubernetes 编排器部署应用程序》中分别进行回顾。
- en: Before we review these new objects, let’s remember that containers are processes
    that run on top of hosts thanks to container runtimes. These processes run isolated
    from each other by using the special kernel features of the hosts. Container images
    will provide the base filesystems for these processes and we will use a client
    command line to interact with them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们回顾这些新对象之前，让我们记住，容器是通过容器运行时在主机之上运行的进程。这些进程通过使用主机的特殊内核功能相互隔离。容器镜像将为这些进程提供基础文件系统，我们将使用客户端命令行与它们进行交互。
- en: Containers are considered stateless and ephemeral, although they exist on the
    underlying host. Applications running within containers should be prepared to
    run anywhere, and their state and data should be managed out of the container’s
    life cycle. What if we need to store an application’s data or its status? We can
    use the volume objects to persist data and processes’ states when containers are
    removed or a new container is created using the same data. If we are working in
    a distributed or orchestrated environment, sharing these volumes is critical,
    and we need to use external volumes to attach the data to the containers wherever
    it’s needed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 容器被视为无状态和短暂的，尽管它们存在于底层主机上。在容器中运行的应用程序应当准备好可以在任何地方运行，并且它们的状态和数据应该管理在容器生命周期之外。如果我们需要存储应用程序的数据或其状态该怎么办？我们可以使用卷对象来持久化数据和进程状态，当容器被删除或使用相同数据创建新容器时。若我们在分布式或编排环境中工作，共享这些卷是至关重要的，我们需要使用外部卷将数据附加到任何需要它的容器上。
- en: 'Depending on the container runtime we use, the location of the files related
    to containers may change, but in the case of a Docker container runtime, we expect
    to have all images and container layers and their files under `/var/lib/docker`
    or `c:\ProgramData\docker`. This may seem completely different on new desktop
    environments, such as Docker Desktop and Rancher Desktop. In these environments,
    we will use WSL or the Windows command line to execute the client and interact
    with a container runtime. The runtime runs in a different WSL environment; hence,
    you will not be able to reach its data path. To review the current data path from
    your client, you can use `docker info` if you are using Docker as the container
    runtime:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们使用的容器运行时，相关文件的位置可能会有所不同，但在 Docker 容器运行时的情况下，我们预计所有镜像和容器层及其文件都位于 `/var/lib/docker`
    或 `c:\ProgramData\docker` 下。对于新的桌面环境，如 Docker Desktop 和 Rancher Desktop，这些路径可能看起来完全不同。在这些环境中，我们将使用
    WSL 或 Windows 命令行来执行客户端并与容器运行时交互。容器运行时运行在不同的 WSL 环境中；因此，你将无法直接访问其数据路径。若要查看客户端当前的数据路径，如果你使用的是
    Docker 作为容器运行时，可以使用 `docker info` 命令：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you use `containerd` directly, the data root path will be located under the
    `/var/lib/containerd` directory, but in both cases, you will not be able to access
    these folders in desktop environments because client access uses a pipe connection
    to access the container runtime remotely. All the objects’ meta-information will
    be stored under this `DockerRootDir` path and we will be able to retrieve the
    objects’ properties by using the container runtime client with appropriate commands.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你直接使用 `containerd`，数据根路径将位于 `/var/lib/containerd` 目录下，但在这两种情况下，你都无法在桌面环境中访问这些文件夹，因为客户端访问是通过管道连接远程访问容器运行时的。所有对象的元数据信息将存储在
    `DockerRootDir` 路径下，我们可以通过容器运行时客户端使用适当的命令来检索这些对象的属性。
- en: 'If you are using WSL2 with Docker Desktop, two WSL instances will have been
    created: `docker-desktop` and `docker-desktop-data`. The second one is used for
    mounting all data inside your own WSL instance (`ubuntu-22.04` in my case, but
    it may differ for you). This is possible thanks to the integration with Docker
    Desktop. We can find all the Docker container content inside the `\\wsl.localhost\docker-desktop-data\data\docker`
    directory. The following PowerShell screenshot shows my environment’s data:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 WSL2 与 Docker Desktop，那么两个 WSL 实例会被创建：`docker-desktop` 和 `docker-desktop-data`。第二个实例用于挂载所有数据到你自己的
    WSL 实例（在我的例子中是 `ubuntu-22.04`，但在你那里可能不同）。这一切都得益于 Docker Desktop 的集成。我们可以在 `\\wsl.localhost\docker-desktop-data\data\docker`
    目录中找到所有的 Docker 容器内容。以下是 PowerShell 截图，展示了我的环境数据：
- en: '![Figure 4.1 – Docker container runtime objects data inside the docker-desktop-data
    WSL instance](img/B19845_04_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – Docker 容器运行时对象数据在 docker-desktop-data WSL 实例中的展示](img/B19845_04_01.jpg)'
- en: Figure 4.1 – Docker container runtime objects data inside the docker-desktop-data
    WSL instance
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – Docker 容器运行时对象数据在 docker-desktop-data WSL 实例中的展示
- en: Now that we know about the main objects that are managed by the container runtime,
    we can review the command-line options we have for managing and interacting with
    them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了容器运行时管理的主要对象，我们可以回顾一下用于管理和与之交互的命令行选项。
- en: Learning about using the command line to work with containers
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习如何使用命令行与容器交互
- en: In this section, we will learn how to manage containers. We will use the Docker
    command line, provided by the Docker client (the `docker-client` package or WSL
    integrated into Docker Desktop environments). All the command-line actions we
    are going to discuss in this chapter will be similar for other clients, such as
    `nerdctl` or `podman`, although in the latter case, it does not use a `containerd`
    daemon.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何管理容器。我们将使用由 Docker 客户端提供的 Docker 命令行（`docker-client` 包或集成到 Docker
    Desktop 环境中的 WSL）。我们将在本章讨论的所有命令行操作对于其他客户端（如 `nerdctl` 或 `podman`）也类似，尽管在后者的情况下，它不使用
    `containerd` 守护进程。
- en: The Docker client sends actions to the Docker daemon via an API every time we
    retrieve information about Docker objects. Clients can use **SSH**, **HTTP/HTTPS**,
    or direct **sockets** (or **pipes** in Microsoft operating systems).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们获取关于 Docker 对象的信息时，Docker 客户端都会通过 API 将操作发送到 Docker 守护进程。客户端可以使用 **SSH**、**HTTP/HTTPS**
    或直接 **sockets**（在 Microsoft 操作系统中为 **pipes**）进行通信。
- en: 'First, we will start with the actions that are common and available to all
    container runtime objects:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从所有容器运行时对象的常见操作开始：
- en: '`create`: All the container runtime objects can be created and destroyed. This
    doesn’t apply to container images because we will use `docker image build` to
    start a building process to create them. All objects will automatically receive
    an ID, and in some cases, such as with containers, an automated random name will
    also be added. If we want to assign a defined name, we can use the `--``name`
    argument.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create`：所有容器运行时对象都可以创建和销毁。这不适用于容器镜像，因为我们将使用 `docker image build` 来启动构建过程以创建它们。所有对象都会自动接收一个
    ID，并且在某些情况下，如容器，还会自动添加一个随机名称。如果我们想要指定一个固定名称，可以使用 `--name` 参数。'
- en: '`list`: This action will show all the objects in the defined category; for
    example, `docker image list` will retrieve all the images available locally in
    our container runtime. As we learned in [*Chapter 2*](B19845_02.xhtml#_idTextAnchor036),
    *Building Docker Images*, we have options for filtering and formatting the output
    using `--all` argument. If we only need the object identifiers, we can use the
    `--quiet` option. This can be very useful for piping the output to another command.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list`：此操作将显示定义类别中的所有对象；例如，`docker image list` 将列出我们容器运行时中本地所有可用的镜像。如我们在 [*第
    2 章*](B19845_02.xhtml#_idTextAnchor036)《构建 Docker 镜像》中所学，我们可以使用 `--all` 参数来筛选和格式化输出。如果我们只需要对象标识符，可以使用
    `--quiet` 选项。这对于将输出传递给另一个命令非常有用。'
- en: Important note
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You may notice that we can also use `docker container ps` or the shorter version,
    `docker ps`, to list containers. Containers are processes that run in our host
    with kernel features providing isolation; hence, it seems appropriate to use this
    argument as if we were listing processes. By default, only running processes (or
    containers) will be listed, and we will have to use the `--all` argument to show
    stopped ones as well.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，我们也可以使用 `docker container ps` 或其简化版 `docker ps` 来列出容器。容器是运行在主机中的进程，利用内核特性提供隔离；因此，似乎将此命令作为列出进程的方式是合适的。默认情况下，只有正在运行的进程（或容器）会被列出，如果我们还希望显示已停止的容器，则需要使用
    `--all` 参数。
- en: '`inspect`: Inspecting objects will allow us to retrieve all the information
    related to the defined object. By default, all objects’ data will be presented
    in JSON format, but we can also use the `--format` argument to format the output.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inspect`：检查对象将允许我们检索与定义对象相关的所有信息。默认情况下，所有对象的数据将以 JSON 格式呈现，但我们也可以使用 `--format`
    参数来格式化输出。'
- en: '`remove`: All objects can also be removed. We will use their IDs or names to
    delete them. In some cases, internal dependencies may appear. For example, we
    can’t remove a container image if any existing container is using it. To avoid
    these dependencies, we can use the `--``force` argument.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove`：所有对象也可以被移除。我们将使用它们的 ID 或名称来删除它们。在某些情况下，可能会出现内部依赖关系。例如，如果任何现有的容器正在使用某个容器镜像，我们就无法移除该镜像。为了避免这些依赖关系，我们可以使用
    `--force` 参数。'
- en: 'These actions are common to all container runtime-managed objects, but when
    we deep dive into containers, more are available. Next, we will review the current
    actions for containers, but first, we have to understand that when we create an
    object, we prepare all the required configurations. This means that creating a
    container will prepare the container to run, but the container will be stopped.
    Let’s see this feature in action with a quick example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作是所有容器运行时管理的对象共有的，但当我们深入容器时，会发现更多的操作。接下来，我们将回顾当前容器的操作，但首先，我们必须理解，当我们创建一个对象时，我们会准备所有必要的配置。这意味着，创建一个容器会准备容器以便运行，但容器会被停止。让我们通过一个快速的示例来查看这个功能的实际操作：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our Docker container runtime has just created a container, but it is not running,
    although it is still in our host system.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Docker 容器运行时刚刚创建了一个容器，但它并未运行，尽管它仍然存在于我们的主机系统中。
- en: 'We can remove this container and check it again. We will not be able to retrieve
    any value from this object because it will now not exist:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以移除这个容器并再次检查它。我们将无法从这个对象中获取任何值，因为它现在已经不存在了：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we can continue reviewing the actions for containers, starting with the
    action for actually starting a container after its creation:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续回顾容器的操作，首先从容器创建后实际启动容器的操作开始：
- en: '`start`: This action requires a previously created container object to exist.
    The container runtime will execute the defined container object’s processes with
    its host’s isolation and defined attached resources.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`：这个操作需要一个先前创建的容器对象。容器运行时将执行定义的容器对象的进程，使用宿主机的隔离和定义的附加资源。'
- en: '`run`: This action will `--detach` argument; in this case, the container will
    run in the background and our terminal will be detached from the container. We
    can use `--interactive` and `--tty` to execute the current container in interactive
    mode and use a pseudo-terminal; this way, we can actively interact with the container’s
    main process. Containers will run using all the parameters defined in their configuration,
    such as usernames, defined kernel namespaces, volumes, networks, and so on. Some
    of these definitions may be modified by adding different arguments to our command
    line.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run`：这个操作会使用 `--detach` 参数；在这种情况下，容器将在后台运行，我们的终端会与容器分离。我们可以使用 `--interactive`
    和 `--tty` 来以交互模式执行当前容器，并使用伪终端；这样，我们就可以与容器的主进程进行主动交互。容器将使用其配置中定义的所有参数运行，例如用户名、定义的内核命名空间、卷、网络等。通过向命令行添加不同的参数，我们可以修改这些定义。'
- en: '`stop`: Containers can be stopped. This action will ask the container runtime
    to send a stop signal (`SIGTERM`) to the container’s main process and it will
    wait 10 seconds (by default) before sending a kill signal (`SIGKILL`) if the process
    is still alive.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stop`：容器可以被停止。这个操作会要求容器运行时向容器的主进程发送停止信号（`SIGTERM`），如果进程仍然存活，它会等待10秒钟（默认设置）后再发送终止信号（`SIGKILL`）。'
- en: '`kill`: Killing a container will directly ask the container runtime to send
    a `SIGKILL` signal. You, as a developer, should prepare your applications to die
    correctly in case `SIGTERM` or `SIGKILL` is received. Ensure your files are closed
    correctly and no unmanaged process continues running after the main process has
    died.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kill`：杀死容器将直接请求容器运行时发送`SIGKILL`信号。作为开发者，你应该准备好让应用程序在收到`SIGTERM`或`SIGKILL`时正确退出。确保你的文件正确关闭，且在主进程终止后没有未管理的进程继续运行。'
- en: '`restart`: This action will be used to stop and start the container. We can
    ask the container runtime to always restart our container whenever our main process
    dies.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restart`：此操作将用于停止并启动容器。我们可以要求容器运行时在主进程死亡时始终重启容器。'
- en: '`pause`/`unpause`: Containers can be paused. This will make the container runtime
    inform the kernel to remove any CPU time from the container’s processes. This
    is important because paused containers can be used to share container resources,
    such as volumes and namespaces.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pause`/`unpause`：容器可以被暂停。这将使容器运行时通知内核停止容器进程的 CPU 时间。这一点非常重要，因为暂停的容器可以用于共享容器资源，如卷和命名空间。'
- en: Important note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You may get stuck and be unable to exit the container’s main process standard
    and error output if you run certain processes in the foreground without the `--interactive`
    argument. To avoid this situation, you can use the *CTRL* + *P* + *Q* keyboard
    sequence.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在前台运行某些进程时没有使用`--interactive`参数，可能会卡住并无法退出容器的主进程标准输出和错误输出。为避免这种情况，可以使用*CTRL*
    + *P* + *Q*键盘快捷键。
- en: 'Now that have learned about the most important actions for managing containers,
    let’s review some of the arguments we can use to modify the container’s behavior:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了管理容器的最重要操作，让我们回顾一下可以用来修改容器行为的一些参数：
- en: '`--name`: Each container will be identified by a unique ID, but a name will
    always be assigned. This name will be random and composed of two strings. An internal
    database will be used to generate them and the final concatenated string will
    be unique. We can avoid this behavior by using `--name` and passing a string of
    our choice, but remember, container names must be unique and you will not be able
    to reuse this name.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--name`：每个容器都会由唯一的ID标识，但始终会分配一个名称。这个名称将是随机的，由两个字符串组成。将使用内部数据库来生成它们，最终的拼接字符串将是唯一的。我们可以通过使用`--name`并传递我们选择的字符串来避免这种行为，但请记住，容器名称必须是唯一的，且不能重复使用该名称。'
- en: '`--restart`: As mentioned before, we can ask the container runtime to manage
    the container’s life cycle for us. By default, containers will not restart if
    the main process dies, but we can use strings such as `on-failure`, `always`,
    or `unless-stopped` to define whether the container should start in case of failure
    (any exit code other than `0`), always, or just in case we didn’t effectively
    stop the container, respectively. We can also ensure that the Docker runtime does
    not manage the life cycle of the container by not using any specific string or
    command.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--restart`：如前所述，我们可以要求容器运行时为我们管理容器的生命周期。默认情况下，如果主进程死亡，容器不会重启，但我们可以使用诸如`on-failure`、`always`或`unless-stopped`的字符串来定义容器在失败时（任何退出码非`0`）、始终或仅在未有效停止容器的情况下是否应重新启动。我们还可以通过不使用任何特定的字符串或命令，确保Docker运行时不管理容器的生命周期。'
- en: '`--entrypoint`: This option will allow us to override the container image’s
    defined entry point (main process). It is very important to understand that anyone
    can change your image’s entry point, executing whatever binary or script is available
    in your image’s layers; therefore, it is critical to strictly include the files
    required by your application.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--entrypoint`：此选项允许我们覆盖容器镜像定义的入口点（主进程）。理解这一点非常重要，因为任何人都可以更改你的镜像入口点，执行镜像层中可用的任何二进制文件或脚本；因此，严格包含应用程序所需的文件是至关重要的。'
- en: '`--env`: We can add new environment variables by using this argument or `--env-file`.
    In this case, a file with a key-value format will be included to add a set of
    variables.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--env`：我们可以通过使用此参数或`--env-file`来添加新的环境变量。在这种情况下，将包含一个键值对格式的文件来添加一组变量。'
- en: '`--expose`: By default, only the ports defined in the container’s image will
    be exposed, but it is possible to add new ones if some modifications of the container’s
    behavior require new ports or protocols.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--expose`：默认情况下，仅容器镜像中定义的端口会被暴露，但如果容器行为的某些修改需要新的端口或协议，可以添加新的端口。'
- en: '`--user`: This argument allows us to modify the user who effectively executes
    the container’s main process. You must ensure that your application can run if
    you change the container’s user; this may be critical if you run your applications
    inside Kubernetes. In [*Chapter 8*](B19845_08.xhtml#_idTextAnchor170), *Deploying
    Applications with* *the* *Kubernetes Orchestrator*, we will learn whether we can
    improve our application’s security by using **security contexts**.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--user`：此参数允许我们修改实际执行容器主进程的用户。如果你更改了容器的用户，必须确保你的应用程序仍然能够运行；这在你将应用程序运行在 Kubernetes
    中时可能尤为关键。在 [*第 8 章*](B19845_08.xhtml#_idTextAnchor170)，*使用 Kubernetes 编排器部署应用程序*
    中，我们将学习是否可以通过使用 **安全上下文** 来提高应用程序的安全性。'
- en: '`--publish` and `--publish-all`: These arguments allow us to publish one port
    (we can use the arguments multiple times to add multiple ports) or all the image’s
    defined exposed ports. This will make the application accessible from outside
    of the container’s network using NAT. Random host ports will be used to publish
    your applications unless you define specific ports during container execution.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--publish` 和 `--publish-all`：这些参数允许我们发布一个端口（我们可以多次使用这些参数以添加多个端口），或者发布镜像定义的所有暴露端口。这将使应用程序可以通过
    NAT 从容器的网络外部访问。除非在容器执行期间定义了特定端口，否则将使用随机主机端口来发布应用程序。'
- en: '`--memory` and `--cpus`: These options, among others, will allow us to manage
    the amount of memory and CPU resources that will be attached to the container.
    We can also include the host’s GPUs by using `-–gpus`.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--memory` 和 `--cpus`：这些选项，和其他一些选项一起，将允许我们管理分配给容器的内存和 CPU 资源。我们还可以通过使用 `--gpus`
    来包含主机的 GPU。'
- en: 'Now that we have had an overview of the most important arguments that are used
    with containers, we will take a look at some critical options for securing our
    workloads:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经概览了与容器一起使用的最重要的参数，接下来我们将查看一些关键选项，以确保我们的工作负载安全：
- en: '`--cap-add`: This option allows us to specifically add some kernel capabilities
    to our processes inside the container’s execution. Kernel capabilities are a set
    of privileges associated with a superuser, which the system provides in a fine-grained
    way. By default, a container runtime does not allow *privileged* containers to
    run with all available capabilities. Container runtimes allow only a subset of
    all available capabilities by default (the currently available capabilities can
    be reviewed at [https://man7.org/linux/man-pages/man7/capabilities.7.xhtml](https://man7.org/linux/man-pages/man7/capabilities.7.xhtml)).
    The Docker runtime, for example, allows 14 capabilities ([https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities](https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities)),
    which will probably be enough for your applications to run, but if your applications
    need some specific capability, such as the permission to manage network interfaces
    using `NET_ADMIN`, you should add that using the `--cap-add NET_ADMIN` argument.
    Adding capabilities may be useful for modifying your current kernel behavior if
    your application needs some special features. You, as a developer, should inform
    the relevant parties about the special privileges needed by your applications
    because capabilities may be dropped in secure container orchestrator environments.
    Inform your DevOps or cluster administrator teams about your special requirements.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--cap-add`：此选项允许我们为容器内进程的执行特定地添加一些内核功能。内核功能是一组与超级用户相关的特权，系统以细粒度的方式提供这些特权。默认情况下，容器运行时不允许*特权*容器以所有可用的功能运行。容器运行时默认只允许所有可用功能的一个子集（当前可用的功能可以在[https://man7.org/linux/man-pages/man7/capabilities.7.xhtml](https://man7.org/linux/man-pages/man7/capabilities.7.xhtml)中查看）。例如，Docker
    运行时允许 14 个功能（[https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities](https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities)），这些功能可能足以让你的应用程序运行，但如果你的应用程序需要一些特定的功能，比如使用
    `NET_ADMIN` 权限管理网络接口，你应该使用 `--cap-add NET_ADMIN` 参数来添加该功能。添加功能可能对修改当前内核行为有帮助，特别是如果你的应用程序需要一些特殊的特性。作为开发人员，你应该告知相关人员你的应用程序所需的特殊权限，因为在安全的容器编排环境中，功能可能会被剥离。请告知你的
    DevOps 或集群管理员团队你的特殊需求。'
- en: '`--cap-drop`: This option, in contrast, is used to remove certain capabilities.
    This may be very useful, for example, if we need to remove the possibility of
    changing file ownership inside a container’s life cycle, which we can do using
    `--cap-drop CHWON`, or remove the ability to send raw network packets, for example,
    ICMP, which is done using `--cap-drop NET_RAW`. You may find secure environments
    where all capabilities are dropped.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--cap-drop`：此选项用于移除某些能力。例如，如果我们需要移除在容器生命周期内更改文件所有权的可能性，可以使用 `--cap-drop CHOWN`，或者移除发送原始网络数据包的能力，例如
    ICMP，可以使用 `--cap-drop NET_RAW`。你可能会在一些安全环境中看到所有能力都被丢弃的情况。'
- en: Important note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Both `--cap-drop` and `--cap-add` can be used with the `ALL` argument, which
    means that all capabilities will be dropped or added, respectively. It is very
    important for you, as a developer, to test the possible issues that may appear
    if you drop all available capabilities. This will help you prepare your applications
    for secure environments.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`--cap-drop` 和 `--cap-add` 都可以与 `ALL` 参数一起使用，这意味着所有的能力都会被丢弃或添加，具体取决于命令。作为开发者，你非常需要测试如果丢弃所有可用能力时可能出现的问题。这将帮助你为安全环境准备好应用程序。'
- en: '`--privileged`: This argument will provide all capabilities and avoid any resource
    limitations. You should avoid using this option for your application containers.
    Take time to review which capabilities and resources are required for your application
    and apply them. Overriding all the process limits in production is a bad idea
    and should be applied only to specific application containers, for example, to
    monitor your infrastructure. In these specific cases, you may need extra resources
    or be able to access all the host’s capabilities, processes, and so on to manage
    applications from the containers themselves.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--privileged`：此选项将提供所有能力，并避免任何资源限制。你应该避免在应用程序容器中使用此选项。花时间查看你的应用程序所需的能力和资源，并应用它们。在生产环境中覆盖所有进程限制是个坏主意，应仅应用于特定的应用程序容器，例如用于监控你的基础设施。在这些特定情况下，你可能需要额外的资源或能够访问主机的所有能力、进程等，以便从容器内管理应用程序。'
- en: '`--disable-content-trust`: This option will disable any Docker Content Trust
    verification; hence, any signature or image source check will be omitted.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--disable-content-trust`：此选项将禁用任何 Docker 内容信任验证；因此，任何签名或镜像来源检查都将被省略。'
- en: '`--read-only`: Executing containers in `/tmp` directory, you need to set up
    a volume attached to this path to allow this interaction.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--read-only`：在 `/tmp` 目录中执行容器时，你需要设置一个附加到此路径的卷以允许此交互。'
- en: '`--security-opt`: Some extended security measures may need extra options, for
    example, for setting up a different `seccomp` profile or specifying SELinux options.
    In general, this option allows us to modify Linux security modules’ behavior.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--security-opt`：某些扩展的安全措施可能需要额外的选项，例如设置不同的 `seccomp` 配置文件或指定 SELinux 选项。一般来说，这个选项允许我们修改
    Linux 安全模块的行为。'
- en: Now that we know how to run containers and the most important options, let’s
    review how to limit and include the underlying host’s resources.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何运行容器以及最重要的选项，让我们回顾一下如何限制和包括底层主机的资源。
- en: Limiting container access to host resources
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制容器访问主机资源
- en: In this section, we will learn how to limit hosts’ resources inside containers,
    but first, we will take a look at the container network model and how to use volumes
    to override container storage.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何限制容器内主机的资源，但首先，我们将了解容器的网络模型以及如何使用卷覆盖容器存储。
- en: Network isolation
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络隔离
- en: '`docker0` by default. This interface is created during Docker daemon installation
    and all IP containers’ interfaces will be associated with `docker0`. Different
    drivers can be used to extend this default behavior, for example, to attach network
    VLANs to containers directly.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下是 `docker0`。这个接口在 Docker 守护进程安装时创建，所有容器的 IP 接口将与 `docker0` 相关联。可以使用不同的驱动程序扩展这一默认行为，例如，直接将网络
    VLAN 附加到容器。
- en: Important note
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'By default, the following network plugins are available: `bridge`, `host`,
    `ipvlan`, `macvlan`, `null`, and `overlay`.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，以下网络插件可用：`bridge`、`host`、`ipvlan`、`macvlan`、`null` 和 `overlay`。
- en: 'By default, a fresh Docker container runtime installation creates three different
    interfaces. We can review them by listing the default network objects after installation:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，新的 Docker 容器运行时安装会创建三个不同的接口。我们可以通过列出安装后的默认网络对象来查看它们：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'All containers will run using the `bridge` interface by default. Every time
    we create a container, a virtual interface is created in the host, attached to
    `docker0`. All egress and ingress traffic will go through this interface. In this
    scenario, it is very important to understand that all containers attached to this
    common bridge will see each other. Let’s see how this happens in this example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所有容器默认将使用`bridge`接口运行。每次我们创建一个容器时，都会在主机中创建一个虚拟接口，并将其附加到`docker0`。所有的出站和入站流量都会经过这个接口。在这种情况下，理解所有附加到这个公共桥接的容器彼此之间是可见的，这一点非常重要。让我们通过这个例子来看看这是如何发生的：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This container does not receive an IP address until it runs. We can now execute
    it and review the IP address again:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个容器在运行之前不会获取IP地址。我们现在可以执行它，并再次查看IP地址：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The container runtime manages the IP assignment and we can verify the network
    segment that was used:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 容器运行时管理IP分配，我们可以验证使用的网络段：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s verify what happens when another container runs attached to the network
    bridge interface:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证当另一个容器运行并附加到网络桥接接口时发生了什么：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The second container executed three pings to the first one’s IP address and
    it was reachable. Both containers run in the same network segment, associated
    with the same bridge interface. This default behavior can be managed by setting
    certain network object’s keys during their creation, such as `com.docker.network.bridge.enable_icc`,
    which manages the isolation between containers in the same network (additional
    information can be found at [https://docs.docker.com/engine/reference/commandline/network_create](https://docs.docker.com/engine/reference/commandline/network_create)).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个容器对第一个容器的IP地址执行了三次ping操作，并且可以访问。两个容器都运行在同一网络段，关联到同一个桥接接口。此默认行为可以通过在创建网络对象时设置某些键来管理，例如`com.docker.network.bridge.enable_icc`，它管理同一网络中容器之间的隔离（更多信息请参见[https://docs.docker.com/engine/reference/commandline/network_create](https://docs.docker.com/engine/reference/commandline/network_create)））。
- en: We will use `--network` to define the networks to which containers should attach.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`--network`来定义容器应该附加到的网络。
- en: The `none` network can be used to initialize and run containers without any
    networking capabilities. This can be interesting when we run certain tasks that
    don’t require any network traffic – for example, managing data stored in a volume.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`none`网络可以用于初始化和运行没有任何网络能力的容器。当我们运行一些不需要网络流量的任务时，这会非常有用——例如，管理存储在卷中的数据。'
- en: 'We can share the host’s network namespace by using the `host` network. When
    we attach a container to this network, it will use the host’s IP interfaces. We
    can verify this behavior by executing `docker container run --rm --network=host
    alpine ip address show`. The following screenshot shows the output of this command,
    showing the interfaces inside a container using the `host` network:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`host`网络共享主机的网络命名空间。当我们将容器附加到此网络时，它将使用主机的IP接口。我们可以通过执行`docker container
    run --rm --network=host alpine ip address show`来验证这一行为。以下截图显示了该命令的输出，展示了使用`host`网络的容器内部接口：
- en: '![Figure 4.2 – The network interfaces of our host, included inside a running
    container](img/B19845_04_02.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 我们主机的网络接口，包含在一个运行中的容器内](img/B19845_04_02.jpg)'
- en: Figure 4.2 – The network interfaces of our host, included inside a running container
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 我们主机的网络接口，包含在一个运行中的容器内
- en: Here, we can see that `docker0` and the previous container’s interface are inside
    the new container. The `host` network is used for monitoring and security applications
    – when we need access to all the host interfaces to manage or retrieve their traffic
    statistics, for example.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`docker0`和前一个容器的接口都出现在新容器中。`host`网络通常用于监控和安全应用——例如，当我们需要访问所有主机接口以管理或获取它们的流量统计数据时。
- en: Important note
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We used the `--rm` argument to remove the container right after its execution.
    This option is very useful for testing and executing quick commands inside containers.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`--rm`参数，在容器执行后立即删除容器。这个选项在测试和快速执行容器内部命令时非常有用。
- en: Understanding custom networks
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解自定义网络
- en: 'We can also create custom networks, as with any other container runtime objects.
    We can use `docker network create <NETWORK_NAME>` for such tasks; a new bridge
    network interface will be created by default. These new network interfaces will
    be similar to the `docker0` interface, but some important features are added:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建自定义网络，就像其他任何容器运行时对象一样。我们可以使用 `docker network create <NETWORK_NAME>` 来执行此任务；默认情况下，将创建一个新的桥接网络接口。这些新网络接口将类似于
    `docker0` 接口，但会添加一些重要的功能：
- en: Each custom network is isolated from the others, using a completely different
    network segment. A new bridge interface will be created for each custom network
    and the network the segment will be associated with. All containers running attached
    to this network will see each other, but they won’t reach the ones attached to
    any other network, including the default bridge. This also works the opposite
    way; hence, containers attached to a network will only see those working on the
    same network.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个自定义网络与其他网络隔离，使用完全不同的网络段。每个自定义网络都会创建一个新的桥接接口，并将该网络段与之关联。所有连接到此网络的容器将彼此可见，但它们无法访问连接到任何其他网络的容器，包括默认桥接网络。反过来也是如此；因此，连接到某个网络的容器只能看到在同一网络上运行的容器。
- en: Custom networks can be dynamically attached. This means that containers can
    be attached and detached by using `docker network connect <CONTAINER>` and `docker
    network disconnect <CONTAINER>`. This behavior can’t be reproduced in the default
    bridge network.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义网络可以动态连接。这意味着可以使用 `docker network connect <CONTAINER>` 和 `docker network
    disconnect <CONTAINER>` 来连接和断开容器。这种行为无法在默认桥接网络中重现。
- en: An internal DNS is provided for each custom network. This means that all containers
    that are attached can be accessed by using their names. Hence, network discovery
    is provided, and each time a new container runs attached to this network, a new
    entry is added to the internal DNS. However, remember that DNS names will only
    be accessible internally in the defined network. Default bridge networks can also
    access containers via their names if we use the `--link` argument. This way, we
    can link containers together to make them work as if they were using a DNS, but
    this will only work for the containers included in this argument; no other containers
    will be seen by their names.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个自定义网络都提供内部 DNS。这意味着所有连接的容器都可以通过名称进行访问。因此，提供了网络发现，每次新的容器连接到此网络时，都会将一个新的条目添加到内部
    DNS。但是，请记住，DNS 名称仅在定义的网络内可访问。如果我们使用 `--link` 参数，默认桥接网络也可以通过名称访问容器。这样，我们可以将容器连接在一起，使它们像使用
    DNS 一样工作，但这只适用于包含在该参数中的容器；其他容器将无法通过名称访问。
- en: 'Let’s see a quick example by creating a new network using `docker network create`.
    We will also define a name, its scope, and the associated subnet:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用 `docker network create` 创建一个新网络来查看一个快速示例。我们还将定义名称、范围和关联的子网：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let’s try to access the container attached to the created custom network:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试访问连接到创建的自定义网络的容器：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It is accessible by its name, but let’s try this again with the container attached
    to the default network:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以通过其名称访问，但让我们再次尝试将容器连接到默认网络：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It is not accessible by the DNS name. Let’s verify whether the network is available:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 DNS 名称无法访问。让我们验证网络是否可用：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'All packets are lost. The bridge network is not accessible from the custom
    one we created, although both use the host’s interfaces. Each network is attached
    to its own bridge network, but we can attach a container to both networks using
    `docker connect <``NETWORK> <CONTAINER>`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所有数据包都丢失。自定义网络与我们创建的网络之间无法访问桥接网络，尽管它们都使用主机的接口。每个网络都连接到自己的桥接网络，但我们可以使用 `docker
    connect <NETWORK> <CONTAINER>` 将容器连接到两个网络：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we have a container attached to the custom and default bridge networks:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个容器同时连接到自定义网络和默认桥接网络：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Therefore, we can now reach the containers in the custom network:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在可以访问自定义网络中的容器：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Some options can modify the default networking behavior inside containers.
    Let’s see some of them for running containers or creating networks:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一些选项可以修改容器内部的默认网络行为。让我们看看一些用于运行容器或创建网络的选项：
- en: '`--add-host`: This option allows us to include some external hosts in `host:ip`
    format to make them available as if they were included in the DNS.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--add-host`：这个选项允许我们以 `host:ip` 格式包含一些外部主机，使它们像在 DNS 中一样可用。'
- en: '`--dns`, `--dns-search`, and `--dns-option`: These options allow us to modify
    the DNS resolution for the container. By default, the container runtime will include
    its current DNS, but we can change this behavior.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--dns`、`--dns-search` 和 `--dns-option`：这些选项允许我们修改容器的 DNS 解析。默认情况下，容器运行时会包含当前的
    DNS，但我们可以改变这一行为。'
- en: '`--domainname`: We can set the container’s domain name to something other than
    the default one.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--domainname`：我们可以将容器的域名设置为不同于默认域名的名称。'
- en: '`--ip`: Although it is quite important to use default dynamic IP address mappings,
    we may prefer to assign a specific IP address to the container. Use this option
    with care as you can’t reuse IP addresses.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--ip`：尽管使用默认的动态 IP 地址映射非常重要，但我们可能更愿意为容器分配特定的 IP 地址。请小心使用此选项，因为不能重复使用 IP 地址。'
- en: '`--hostname`: By default, each container will use the container’s ID as its
    name, but we can change this behavior by using this option.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--hostname`：默认情况下，每个容器将使用容器的 ID 作为名称，但我们可以通过使用此选项来更改此行为。'
- en: '`--link`: This option will allow us to attach two or more containers by using
    this option multiple times. It is quite similar to the `--add-host` option, but
    in this case, we will use it to attach a container to a DNS name in `CONTAINER_NAME:DNS_ALIAS`
    format to make it accessible via its DNS name.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--link`：此选项允许我们通过多次使用该选项来连接两个或更多的容器。它与 `--add-host` 选项非常相似，但在这种情况下，我们将使用它以
    `CONTAINER_NAME:DNS_ALIAS` 格式将容器连接到 DNS 名称，以便通过其 DNS 名称访问该容器。'
- en: '`--network-alias`: Sometimes, we need a container to be known in the network
    with multiple names. This option allows us to add a DNS alias to the container.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--network-alias`：有时，我们需要让容器在网络中使用多个名称。此选项允许我们为容器添加 DNS 别名。'
- en: '`--subnet` and `--ip-range`: This option is available for networks and allows
    us to modify the internal IP’s assignation. We can also modify the default gateway
    for each network by using the `--gateway` argument (by default, the lowest IP
    address will be used).'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--subnet` 和 `--ip-range`：此选项适用于网络，允许我们修改内部 IP 地址的分配。我们还可以使用 `--gateway` 参数修改每个网络的默认网关（默认情况下将使用最低的
    IP 地址）。'
- en: In the next section, we’ll learn how volumes work.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习卷的工作原理。
- en: Managing persistent data with containers
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理容器中的持久数据
- en: Applications running in containers must be prepared to run in any host. We can
    even go further and say that we should be able to run them in the cloud or on-premises
    environments. However, containers’ life cycles should not include process states
    and data. **Volumes** will help us manage data outside of containers’ life cycles
    and hosts (if we’re using remote storage solutions such as NAS). In this section,
    we will learn how container runtimes manage local volumes. Volumes will allow
    containers to access hosts’ filesystems or remote filesystems.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器中运行的应用程序必须能够在任何主机上运行。我们甚至可以进一步说，我们应该能够在云环境或本地环境中运行它们。然而，容器的生命周期不应包含进程状态和数据。**卷**将帮助我们管理容器生命周期之外的数据（如果我们使用远程存储解决方案，如
    NAS）。在本节中，我们将学习容器运行时如何管理本地卷。卷将允许容器访问主机的文件系统或远程文件系统。
- en: Local volumes will be expected to be located by default under the `DockerRootDir`
    path in the container runtime’s host. This will work for `VOLUME` key is declared
    in any image’s meta-information, and **named volumes**, which are created or declared
    by users during a container’s execution.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 本地卷默认情况下会位于容器运行时主机上的 `DockerRootDir` 路径下。这对于任何在镜像元数据中声明了 `VOLUME` 键的情况以及由用户在容器运行期间创建或声明的**命名卷**都适用。
- en: 'We can also use any local filesystem (`tmpfs` volume (this is very interesting
    when we need the fastest possible storage backend). In the case of bind mounts,
    any directory or file from the host’s filesystem can be included inside a container.
    But a problem arises here: whenever we move an application to another host, any
    expected location related to the host may be different. To avoid such a situation,
    it is recommended to use external storage, presented on other hosts at the same
    time or whenever a container needs to run. This is especially relevant for clusters,
    where a pool of nodes can run your containers. At this point, we will just discuss
    having data outside of a container’s life cycle; in [*Chapter 10*](B19845_10.xhtml#_idTextAnchor231),
    *Leveraging Application Data Management* *in Kubernetes*, we will discuss how
    to manage data in these more complicated scenarios.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用任何本地文件系统（`tmpfs`卷，这在我们需要尽可能快的存储后端时非常有趣）。在绑定挂载的情况下，任何来自主机文件系统的目录或文件都可以包含在容器内。但是这里会出现一个问题：每当我们将应用程序迁移到另一个主机时，任何与主机相关的预期位置可能会发生变化。为避免这种情况，建议使用外部存储，这些存储可以在其他主机上同时呈现或在容器需要运行时呈现。这对于集群特别相关，集群中的多个节点可以运行你的容器。在这一点上，我们仅讨论如何让数据脱离容器的生命周期；在[*第10章*](B19845_10.xhtml#_idTextAnchor231)中，*利用Kubernetes中的应用数据管理*，我们将讨论如何在这些更复杂的场景中管理数据。
- en: 'Let’s deep dive a bit and describe the local volume types:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨一下，并描述本地卷的类型：
- en: '`VOLUME` definition. These volumes are used to override the container’s filesystem,
    but we, as users, are not responsible for its content. In other terms, whenever
    a new container runs, a new volume will be created dynamically and new data will
    be used. If we need data to persist between executions, we have to define a volume
    by ourselves. The container runtime manages the unnamed volumes completely. We
    can remove them using the `docker volume rm` command but we will need to stop
    and remove the associated containers first. Let’s run a quick example with the
    `postgres:alpine` image, which uses a dynamic unnamed volume to override the container’s
    filesystem for the `/``var/lib/postgresql/data` directory:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VOLUME`定义。这些卷用于覆盖容器的文件系统，但作为用户，我们不负责其内容。换句话说，每当一个新容器运行时，一个新的卷将动态创建并使用新的数据。如果我们需要数据在执行之间持久化，我们必须自己定义一个卷。容器运行时完全管理未命名的卷。我们可以使用`docker
    volume rm`命令将其删除，但我们需要先停止并删除相关的容器。让我们用`postgres:alpine`镜像运行一个快速示例，该镜像使用动态未命名卷覆盖容器的`/var/lib/postgresql/data`目录：'
- en: '[PRE15]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: $ docker run -d -P \
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker run -d -P \
- en: -v DATA:/var/lib/postgresql/data postgres:alpine
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: -v DATA:/var/lib/postgresql/data postgres:alpine
- en: ad7dde43bfa926fb7afaa2525c7b54a089875332baced7f86cd3709f04629709
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ad7dde43bfa926fb7afaa2525c7b54a089875332baced7f86cd3709f04629709
- en: $ docker container inspect ad7dde43bf \
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker container inspect ad7dde43bf \
- en: --format="{{ .Mounts }}"
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --format="{{ .Mounts }}"
- en: '[{volume DATA /var/lib/docker/volumes/DATA/_data /var/lib/postgresql/data local
    z true }]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[{volume DATA /var/lib/docker/volumes/DATA/_data /var/lib/postgresql/data local
    z true }]'
- en: $ docker volume ls
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker volume ls
- en: DRIVER    VOLUME NAME
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: DRIVER    VOLUME NAME
- en: local     343e58f19c66d664e92a512ca2e8bb201d8787bc62bb9835d5b2d5ba46584fe2
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: local     343e58f19c66d664e92a512ca2e8bb201d8787bc62bb9835d5b2d5ba46584fe2
- en: DATA is the name of the volume, and we will be able to reuse this volume whenever
    we remove the postgresql container and create a new one.Data will be persisted
    in the volumes in both examples but the named volume will allow us to manage the
    data most conveniently.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: DATA是卷的名称，每次我们删除postgresql容器并创建一个新容器时，都可以重新使用此卷。在这两个示例中，数据都会保存在卷中，但命名卷使我们能够更方便地管理数据。
- en: '[PRE16]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Important note
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It is very important to understand that named and unnamed (dynamic) volumes
    use our host’s storage. You must take care of volumes forgotten in your filesystem;
    we will review some techniques for this in the *Container runtime maintenance
    tasks* section later in this chapter.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 理解命名卷和未命名卷（动态卷）使用主机存储非常重要。你必须小心文件系统中遗忘的卷；我们将在本章稍后的*容器运行时维护任务*部分中回顾一些处理方法。
- en: '**Bind mounts**: In this case, we will include a host’s directory or file inside
    our container. We will practice using this type of volume in the *Labs* section.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绑定挂载**：在这种情况下，我们将把主机的目录或文件包含在容器内部。在*实验室*部分，我们将练习使用这种类型的卷。'
- en: '**In-memory or tmpfs volumes**: These volumes can be used to override the container’s
    storage, providing fast storage, such as the host’s memory. This can be very useful
    for storing a small amount of data that changes quite often, such as statistics.
    It also can be very dangerous if you don’t limit the amount of memory for use.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存或tmpfs卷**：这些卷可用于覆盖容器的存储，提供快速存储，例如主机的内存。这对于存储一些经常变化的小数据（例如统计数据）非常有用。如果不限制使用的内存量，它也可能非常危险。'
- en: Important note
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Volumes can be used in read-only mode to preserve any existing data. This is
    very useful for presenting data from the host that you want to ensure remains
    unchanged, such as operating system files. We can also manipulate the ownership
    and permissions seen inside the container’s filesystem for any mounted volume.
    It is also common to use `--volumes-from` to share volumes between containers.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 卷可以以只读模式使用，以保持现有数据不变。这对于展示你希望保持不变的数据非常有用，例如操作系统文件。我们还可以操作容器文件系统中看到的任何已挂载卷的所有权和权限。通常也会使用`--volumes-from`在容器之间共享卷。
- en: 'As you have probably noticed, we used the `-v` or `--volumes` argument to add
    volumes to our container at runtime. We can use this argument multiple times and
    use the `--volume SOURCE_VOLUME:FULL_DESTINE_PATH[:ro][:Z]` format, where `SOURCE_VOLUME`
    can be any of the previously described types (you have to use the full path for
    the shared directory when using bind mounts). A volume can be mounted in read-only
    mode, which is very interesting when you provide configurations to your container,
    and we can force SELinux usage if needed with the `Z` option. However, we can
    also use volumes with the `--mount` argument, which provides an extended version
    of the volume-mounting options in key-value format:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，我们在运行时使用了`-v`或`--volumes`参数来为容器添加卷。我们可以多次使用这个参数，并使用`--volume SOURCE_VOLUME:FULL_DESTINE_PATH[:ro][:Z]`格式，其中`SOURCE_VOLUME`可以是之前描述的任何类型（使用绑定挂载时，必须使用共享目录的完整路径）。卷可以以只读模式挂载，当你向容器提供配置时，这非常有趣，如果需要，我们还可以使用`Z`选项强制启用SELinux。然而，我们也可以使用`--mount`参数来使用卷，它提供了一个扩展版的卷挂载选项，采用键值对格式：
- en: '`type`: We specify the type of the mount (`bind`, `volume`, or `tmpfs`).'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：我们指定挂载的类型（`bind`、`volume`或`tmpfs`）。'
- en: '`source` (or `src`): This key is used to define the source of the mount. The
    value can either be a name (for named volumes), a full path (for bind mounts),
    or empty (for unnamed volumes).'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`source`（或`src`）：此键用于定义挂载的源。值可以是一个名称（用于命名卷）、一个完整路径（用于绑定挂载），或为空（用于未命名卷）。'
- en: '`target` (or `dst`): This key defines the destination path where the volume
    will be presented.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target`（或`dst`）：此键定义了卷将呈现的目标路径。'
- en: We can also include the `volume-opt`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以包含`volume-opt`。
- en: Now that we have learned how to include the host’s network and filesystems inside
    containers, let’s continue by accessing the CPU and memory, among other resources.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经学习了如何将主机的网络和文件系统包含在容器内，接下来我们将继续访问CPU和内存等其他资源。
- en: Limiting access to host hardware resources
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制访问主机硬件资源
- en: Sharing host resources within containers is the key to the container model,
    but this requires being able to limit how they access these resources. In [*Chapter
    1*](B19845_01.xhtml#_idTextAnchor015), *Modern Infrastructure and Applications
    with Docker*, we learned that resource isolation is provided by cgroups.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器中共享主机资源是容器模型的关键，但这需要能够限制它们访问这些资源的方式。在[*第1章*](B19845_01.xhtml#_idTextAnchor015)，*使用Docker的现代基础设施和应用程序*中，我们了解到资源隔离是通过cgroups提供的。
- en: If our host runs out of memory or CPU, all containers running on top will be
    affected. That’s why is so important to limit access to the host’s resources.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的主机内存或CPU耗尽，所有在其上运行的容器都会受到影响。这就是为什么限制对主机资源的访问如此重要的原因。
- en: 'By default, containers run without any limits; hence, they can consume all
    the host’s resources. You, as a developer, should know the resources that are
    required by all your application components and limit the resources provided to
    them. We will now review the arguments we can pass to the container runtime to
    effectively limit the container’s access to resources:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，容器没有任何限制，因此它们可以消耗主机的所有资源。作为开发人员，你应该知道你的所有应用组件所需的资源，并限制为它们提供的资源。我们现在将回顾可以传递给容器运行时的参数，以有效地限制容器对资源的访问：
- en: '`--cpus`: This argument allows us to define the number of CPUs provided to
    the container’s main process. This value depends on the number of CPUs available
    to the host. We can use decimals to indicate a subset of the total number of CPUs.
    This value guarantees the number of CPUs that can be used to run the container’s
    process.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--cpus`：此参数允许我们定义分配给容器主进程的 CPU 数量。此值取决于主机上可用的 CPU 数量。我们可以使用小数来表示总 CPU 数量的一个子集。此值保证可以用于运行容器进程的
    CPU 数量。'
- en: '`--memory`: We can set the maximum memory available to the container’s processes.
    When this limit is reached, the host’s kernel will kill the container’s main process
    by executing a runtime called `--oom-kill-disable`; however, it is not recommended
    as you may leave your host without any protection if too much memory is consumed.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--memory`：我们可以设置分配给容器进程的最大内存。当达到此限制时，主机的内核将通过执行名为`--oom-kill-disable`的运行时杀死容器的主进程；然而，强烈不建议这样做，因为如果消耗了过多的内存，可能会使您的主机失去保护。'
- en: Important note
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Container runtimes provide more options for managing CPU and memory resources
    available for any container. It is possible to even limit the access to block
    devices’ **input/output** (**I/O**) operations or modify the default kernel’s
    scheduling behavior. We have just reviewed the most important ones to help you
    understand how we can limit access to the host’s resources. You can review the
    full options at [https://docs.docker.com/config/containers/resource_constraints/](https://docs.docker.com/config/containers/resource_constraints/).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 容器运行时提供了更多选项，用于管理容器可用的 CPU 和内存资源。甚至可以限制对块设备的**输入/输出** (**I/O**) 操作或修改默认的内核调度行为。我们刚刚回顾了最重要的选项，帮助您理解如何限制对主机资源的访问。您可以在[https://docs.docker.com/config/containers/resource_constraints/](https://docs.docker.com/config/containers/resource_constraints/)查阅完整选项。
- en: Extending access to host resources
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展对主机资源的访问
- en: 'Containers run on top of our hosts thanks to container runtimes. By default,
    the host’s CPU and memory are provided thanks to cgroups. Volumes are provided
    inside containers using different types (dynamic unnamed volumes, named volumes,
    host binds, or tmpfs volumes) and the network is provided using kernel namespaces.
    We can use other Docker client arguments to integrate or modify kernel namespaces:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 容器依赖于容器运行时在主机上运行。默认情况下，主机的 CPU 和内存是通过 cgroups 提供的。卷通过不同类型（动态无名卷、命名卷、主机绑定或 tmpfs
    卷）在容器内提供，网络通过内核命名空间提供。我们可以使用其他 Docker 客户端参数来集成或修改内核命名空间：
- en: '`--ipc`: This argument allows us to modify the IPC behavior (shared memory
    segments, semaphores, and message queues) inside containers. It is quite common
    to include the host’s IPC by using `--ipc host` for monitoring purposes.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--ipc`：此参数允许我们修改容器内的 IPC 行为（共享内存段、信号量和消息队列）。出于监控目的，使用`--ipc host`来包含主机的 IPC
    是很常见的做法。'
- en: '`--pid`: This option is intended to set the PID kernel namespace. By default,
    containers run with their own process trees, but we can include other containers’
    PIDs by using `--pid container:CONTAINER_NAME`. We can also include the underlying
    host’s PIDs tree by using `--pid host`. This can be very interesting if your application
    needs to monitor the host’s processes.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--pid`：此选项用于设置 PID 内核命名空间。默认情况下，容器会以自己的进程树运行，但我们可以通过使用`--pid container:CONTAINER_NAME`来包含其他容器的
    PID。我们还可以通过使用`--pid host`来包含底层主机的 PID 树。如果您的应用程序需要监控主机的进程，这会非常有用。'
- en: '`--userns`: We can create a different kernel user’s namespace and include it
    inside containers. This allows us to map different user IDs to the processes running
    inside the containers.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--userns`：我们可以创建一个不同的内核用户命名空间并将其包含在容器内。这允许我们将不同的用户 ID 映射到容器内运行的进程。'
- en: 'Other interesting options allow us to include different host devices:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 其他有趣的选项允许我们包括不同的主机设备：
- en: '`--device`: This option allows us to include the host’s devices inside containers.
    Processes running inside the containers will see these devices as if they were
    directly connected to the container. We can use this option to mount block devices
    (`--device=/dev/sda:/dev/xvdc`), sound devices (`--device=/dev/snd:/dev/snd`),
    and so on.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--device`：此选项允许我们将主机的设备包含在容器内。运行在容器内的进程将把这些设备视为直接连接到容器。我们可以使用此选项挂载块设备（`--device=/dev/sda:/dev/xvdc`）、声音设备（`--device=/dev/snd:/dev/snd`）等。'
- en: '`--gpus`: We can include `--``gpus all`.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--gpus`：我们可以使用`--gpus all`。'
- en: In this section, we learned how to limit access to different hosts’ resources.
    In the next section, we will learn how to manage containers running in our host
    and their behavior.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何限制对不同主机资源的访问。在下一节中，我们将学习如何管理在主机上运行的容器及其行为。
- en: Managing container behavior
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理容器行为
- en: The container runtime will help us understand containers’ behavior by providing
    a set of options for reviewing process logs, copying files to and from containers,
    executing processes inside them, and so on.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 容器运行时将通过提供一组选项来帮助我们了解容器的行为，包括查看进程日志、在容器之间复制文件、执行容器内部进程等。
- en: 'The following actions allow us to interact with container processes and filesystems:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下操作允许我们与容器进程和文件系统进行交互：
- en: '`exec`: We can attach new processes to the containers’ namespaces by using
    `docker container exec`. This option will allow us to run any script or binary
    included in the container’s filesystems or mounted columns.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exec`：我们可以通过使用`docker container exec`将新进程附加到容器的命名空间。此选项允许我们运行容器文件系统中或挂载卷中的任何脚本或二进制文件。'
- en: '`attach`: When a container is running in the background, detached from the
    container runtime client’s command line, we can attach its output by using this
    action. We will attach the Docker client to the container’s main process; hence,
    all the output and errors will be shown in our terminal. Take care with this option
    because you should detach from the container’s main process output to free your
    terminal. Do not use the *Ctrl* + *C* keyboard combination because this will send
    a `SIGNINT` signal to the container’s main process and it will probably be stopped.
    You can detach from the container’s process by using *Ctrl* + *P* + *Q*.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attach`：当容器在后台运行，且与容器运行时客户端命令行分离时，我们可以使用此操作附加到其输出。我们将把Docker客户端附加到容器的主进程；因此，所有输出和错误都会显示在我们的终端上。使用此选项时要小心，因为你应该从容器的主进程输出中分离出来，以释放你的终端。不要使用*Ctrl*
    + *C*键组合，因为这会将`SIGNINT`信号发送给容器的主进程，可能会导致容器停止。你可以通过使用*Ctrl* + *P* + *Q*来从容器的进程中分离出来。'
- en: '`cp`: Sometimes, we need to retrieve some files from the container for debugging,
    for example, certain errors. We can use the `cp` action to copy files to/from
    a container. Remember that you can use volumes to provide files or directories
    to containers; the `cp` action should be used with small files because it uses
    the container runtime and your client to retrieve the files from the containers
    or send them from the local client.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cp`：有时，我们需要从容器中获取一些文件进行调试，例如，某些错误。我们可以使用`cp`操作来复制文件到/从容器中。记住，你可以使用卷为容器提供文件或目录；`cp`操作应仅用于小文件，因为它使用容器运行时和客户端来从容器中检索文件或将文件从本地客户端发送到容器中。'
- en: '`logs`: Retrieving the logs from containers is key to understanding how your
    applications work. A container has a main process and this process’s `STDOUT`
    and `STDERR` streams are the output we receive by using the `logs` action. We
    can use `--follow` to attach to the container’s process output continuously and
    `--tail` to retrieve only a set of lines. It is possible to filter logs by dates
    by using `--since` and `--until`.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logs`：从容器中获取日志是理解应用程序工作原理的关键。每个容器都有一个主进程，通过使用`logs`操作，我们可以获取该进程的`STDOUT`和`STDERR`流作为输出。我们可以使用`--follow`来持续附加到容器的进程输出，并使用`--tail`来仅获取一定数量的行。可以使用`--since`和`--until`按日期过滤日志。'
- en: Important note
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you need to execute an interactive session within a container, it is important
    to include `--interactive` and `--tty`. These options ask the container runtime
    to prepare a pseudo-terminal and interactive session attached to the binary defined
    in the `exec` action; for example, we will use `docker container exec --ti CONTAINER
    /bin/bash` to execute a *bash* shell inside a defined container.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在容器内执行交互式会话，重要的是要加上`--interactive`和`--tty`。这些选项要求容器运行时准备一个伪终端并附加到`exec`操作中定义的二进制文件上；例如，我们可以使用`docker
    container exec --ti CONTAINER /bin/bash`在指定的容器内执行一个*bash* shell。
- en: We can also use a running container to create a container image. We learned
    about this feature in [*Chapter 2*](B19845_02.xhtml#_idTextAnchor036), *Building
    Docker Images*. Creating images from containers does not provide a reproducible
    recipe and it is not a good method for creating images, but in certain situations,
    you may need the container’s content to review the files included.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用运行中的容器创建一个容器镜像。我们在[*第2章*](B19845_02.xhtml#_idTextAnchor036)中学习了有关此功能的信息，即*构建Docker镜像*。从容器创建镜像不提供可重复使用的方法，并且不是创建镜像的好方法，但在某些情况下，您可能需要容器的内容来查看包含的文件。
- en: We can use `docker container commit` to create an image from the container’s
    layer and export all the layers by using `docker container export`. This action
    will only store the files included in the container. It does not include any meta-information
    because we are only working with the content.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`docker container commit`从容器层创建镜像，并通过`docker container export`导出所有层。此操作仅存储容器中包含的文件，不包括任何元信息，因为我们仅处理内容。
- en: 'Another action that’s quite interesting for quickly debugging the file changes
    made by the container’s processes is `diff`. This action allows us to retrieve
    the changes that are created in the container’s layer by comparing all its files
    with the image’s layers. Let’s review this action with a quick example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有趣的快速调试容器进程所做文件更改的操作是`diff`。此操作允许我们通过比较容器层的所有文件与镜像层的文件来检索创建的更改。让我们通过一个快速示例回顾这个操作：
- en: '[PRE17]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As we can see from the command’s output, the `/tmp` directory was changed (indicated
    by `C`) and a file was added, `/tmp/TESTFILE` (indicated by `A`).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从命令输出中所见，`/tmp`目录已更改（由`C`指示），并且添加了一个文件`/tmp/TESTFILE`（由`A`指示）。
- en: Now that we have had a good overview of how to interact with containers and
    obtain information for debugging our applications, let’s learn some housekeeping
    tasks that will help us maintain our container’s environment healthily.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经全面了解了如何与容器交互并获取调试应用程序信息，让我们学习一些有助于保持容器环境健康的日常任务。
- en: Container runtime maintenance tasks
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器运行时维护任务
- en: In this section, we are going to take a quick look at some housekeeping actions
    that are available for maintaining our container runtime.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将快速浏览一些用于维护我们容器运行时的日常操作。
- en: Maintaining the right amount of storage available in your host is a very important
    task. Depending on your container runtime, you may have to prune certain objects
    instead of using a general tool. This happens, for example, with the `containerd`
    client called `nerdctl`. If you are using Rancher Desktop, you will need to specifically
    remove unnecessary objects per category. Let’s review how this can be done with
    the Docker client using `docker system prune`. But before you prune your system
    and clean old objects, you should first understand where the disk space has been
    used.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 维护主机中可用存储空间的正确量是非常重要的任务。根据您的容器运行时，您可能需要修剪特定对象而不是使用通用工具。例如，使用名为`nerdctl`的`containerd`客户端时会发生这种情况。如果您使用的是Rancher
    Desktop，则需要针对每个类别专门删除不必要的对象。让我们通过Docker客户端使用`docker system prune`来回顾如何执行此操作。但是，在修剪系统并清理旧对象之前，您应首先了解磁盘空间的使用情况。
- en: 'To review the actual amount of disk that’s been allocated to different objects,
    we can use the `docker system` `df` command:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看已分配给不同对象的实际磁盘量，请使用`docker system` `df`命令：
- en: '[PRE18]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This command shows the space used by images, containers, and local volumes
    on your system. We can obtain quite descriptive information by adding the `–-verbose`
    argument, which will show us exactly the amount of space that’s used by every
    object in our host. Specific sections for each object category will show the space
    we will free up after removing those objects (only object headers and one object
    line are shown as an example; you can access the full output at [https://github.com/PacktPublishing/Docker-for-Developers-Handbook/blob/main/Chapter4/Readme.md](https://github.com/PacktPublishing/Docker-for-Developers-Handbook/blob/main/Chapter4/Readme.md)):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令显示了系统上图像、容器和本地卷使用的空间。通过添加`--verbose`参数，我们可以获取相当详细的信息，该参数将显示主机中每个对象使用的确切空间量。每个对象类别的特定部分将显示在删除这些对象后我们将释放的空间（仅作为示例显示对象标题和一个对象行；您可以访问完整输出网址[https://github.com/PacktPublishing/Docker-for-Developers-Handbook/blob/main/Chapter4/Readme.md](https://github.com/PacktPublishing/Docker-for-Developers-Handbook/blob/main/Chapter4/Readme.md)）：
- en: '[PRE19]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This output gives us a good idea of how are we running our environment. You,
    as a developer, will probably have a lot of cached layers if you are building
    your images locally. These layers will help speed up your build processes but
    all the layers that have not been used for a long time can be removed.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出给了我们一个很好的了解，关于我们的环境是如何运行的。作为开发者，如果你在本地构建镜像，你可能会有很多缓存层。这些层会帮助加速构建过程，但所有很长时间未被使用的层可以被删除。
- en: 'Let’s take a look at how images are distributed in our example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下在示例中镜像是如何分布的：
- en: '[PRE20]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: All the images based on `alpine` share `7.05MB`; hence, using common base images
    will help you save a lot of storage and is a good practice.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 所有基于`alpine`的镜像共享`7.05MB`；因此，使用共同的基础镜像将帮助你节省大量存储空间，这是一个好习惯。
- en: 'The `CONTAINERS` section will help us find possible problems because we don’t
    expect to have much space in containers. Remember that containers are intended
    to be ephemeral, and persistent data should be maintained outside of their storage.
    Application logs should be redirected to either volumes or `STDOUT`/`STDERR` (this
    is the recommended option). Therefore, the space used by containers should be
    minimal, only consisting of runtime modifications that shouldn’t persist. In our
    example, we can see a couple of containers with several megabytes of usage:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`CONTAINERS`部分将帮助我们发现可能的问题，因为我们不希望容器占用太多空间。记住，容器是为了短暂存在的，持久数据应该保存在容器存储之外。应用日志应该重定向到卷或`STDOUT`/`STDERR`（这是推荐的选项）。因此，容器占用的空间应该最小，仅包括运行时的修改，不应该持久化。在我们的示例中，我们可以看到几个容器使用了几兆字节的空间：'
- en: '[PRE21]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In both cases, the `trivy` database is probably included in the container’s
    layer (we used `trivy` and updated its database during the build process for these
    images).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，`trivy`数据库可能被包含在容器的层中（我们在构建这些镜像时使用了`trivy`并更新了它的数据库）。
- en: We also have a few volumes (dynamic and named) present, but no data was stored
    because we didn’t add any data to the database example.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也有一些卷（动态和命名卷）存在，但没有存储数据，因为我们没有向数据库示例添加任何数据。
- en: And finally, we can see the cache section in the output of the `docker system
    df –verbose` command, where we will find the shared layers used in the `buildx`
    processes.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在`docker system df –verbose`命令的输出中看到缓存部分，在这里我们将找到在`buildx`过程中使用的共享层。
- en: The objects’ disk usage shown by `docker system df` is a representation of the
    physical space distributed in `/var/lib/docker` (the default being `rootDir`).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker system df`显示的对象磁盘使用情况是对`/var/lib/docker`（默认的`rootDir`）中物理空间分布的表示。'
- en: Pruning container objects
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修剪容器对象
- en: 'Once we know how our host’s storage is distributed, we can proceed with cleaning
    unused objects. We will use `docker system prune` to clean all unused objects
    in one go. It will try to free disk space by removing objects from different categories.
    We can include the volumes by using the `--volumes` argument. The `system prune`
    command will remove the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们了解了主机存储的分布情况，就可以开始清理未使用的对象。我们将使用`docker system prune`一次性清理所有未使用的对象。它会通过删除不同类别的对象来尝试释放磁盘空间。我们可以通过使用`--volumes`参数来包括卷。`system
    prune`命令将删除以下内容：
- en: '**All dangling images (by default)**: Image layers not referenced by any container
    image.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有悬空的镜像（默认情况下）**：未被任何容器镜像引用的镜像层。'
- en: '**All unused images (using the --all argument)**: Images not referenced by
    any container (running or stopped in our system).'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有未使用的镜像（使用 --all 参数）**：未被任何容器引用的镜像（无论是正在运行的还是停止的容器）。'
- en: '**All stopped containers (by default)**: By default, all stopped containers
    will be removed (those with an *exited* status). This will remove the containers’
    layers.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有停止的容器（默认情况下）**：默认情况下，所有停止的容器（状态为*exited*的容器）都会被删除。这将移除容器的层。'
- en: '**All unused volumes (using --volumes)**: Volumes are not used by any container.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有未使用的卷（使用 --volumes）**：未被任何容器使用的卷。'
- en: '**All unused networks (by default)**: Networks with no containers attached.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有未使用的网络（默认情况下）**：没有容器附加的网络。'
- en: '**All dangling cache layers (by default)**: All layers that are not referenced
    in any build process.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有悬空的缓存层（默认情况下）**：所有未在任何构建过程中引用的层。'
- en: 'You will always be asked to confirm this action as it can’t be undone:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你将始终被要求确认此操作，因为它无法撤销：
- en: '[PRE22]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: A summary of the reclaimed space is shown after the cleaning process.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 清理过程完成后，会显示回收的空间的总结。
- en: 'For each category of objects, we can execute these pruning processes:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一类对象，我们可以执行以下修剪操作：
- en: '`docker` `container prune`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker` `container prune`'
- en: '`docker` `image prune`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker` `image prune`'
- en: '`docker` `buildx prune`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker` `buildx prune`'
- en: '`docker` `network prune`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker` `network prune`'
- en: These actions will only clean specific objects, which may be very useful if
    you don’t want to change other objects.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作只会清理特定的对象，如果你不想更改其他对象，这可能非常有用。
- en: 'All pruning options can be filtered using the appropriate `--filter` argument.
    These are some of the most common filters:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 所有修剪选项都可以使用适当的`--filter`参数进行过滤。以下是一些最常用的过滤器：
- en: '`until`: We use a timestamp argument to only remove containers that were created
    before a date.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`until`：我们使用时间戳参数来只删除在某个日期之前创建的容器。'
- en: '`label`: This will help us filter which objects from a category will only be
    removed. Multiple labels can be used, separated by commas. Labels can be filtered
    by their existence or absence and we can use keys and values for fine-grained
    selections.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`label`：这将帮助我们过滤掉某一类别中只希望删除的对象。可以使用多个标签，用逗号分隔。标签可以根据其存在或不存在进行过滤，我们还可以使用键和值进行精细选择。'
- en: Important note
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you are planning to schedule prune processes, you may need to use `--force`
    to execute them in a non-interactive way.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划安排修剪进程，你可能需要使用`--force`来以非交互方式执行它们。
- en: Before you move on to the next section, it is important to know that your containers’
    logs will also be present in your host system.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续下一个部分之前，了解容器的日志也会存在于主机系统中是非常重要的。
- en: Configuring container runtime logging
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置容器运行时日志
- en: Container logging options for your system depend on your container runtime.
    In this section, we will quickly review some of the options available for a Docker
    container runtime as this is the one that has the most advanced options. You will
    probably find options for logging using JSON format, but Docker also provides
    other logging drivers.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你的系统容器日志选项取决于你的容器运行时。在本节中，我们将快速回顾一些Docker容器运行时提供的选项，因为它是提供最先进选项的运行时。你可能会发现可以使用JSON格式进行日志记录的选项，但Docker还提供了其他日志驱动程序。
- en: By default, the Docker daemon will use the `json-file` logging driver, but we
    can change this behavior in Docker’s `daemon.json` file. This driver uses more
    disk space than others and that’s why it is recommended to use the local logging
    driver for local development. We can use our host’s system logs in Linux environments
    by configuring `syslog` or `journald` drivers, but if we need to send our containers
    logs to an external application, we will probably use `gelf` (a commonly used
    standard) or `splunk` drivers, although there are also some drivers specific for
    cloud environments.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker守护进程将使用`json-file`日志驱动程序，但我们可以在Docker的`daemon.json`文件中更改这一行为。该驱动程序比其他驱动程序使用更多的磁盘空间，因此建议在本地开发时使用本地日志驱动程序。我们可以通过配置`syslog`或`journald`驱动程序，在Linux环境中使用主机的系统日志，但如果我们需要将容器日志发送到外部应用程序，我们可能会使用`gelf`（常用标准）或`splunk`驱动程序，尽管也有一些特定于云环境的驱动程序。
- en: 'We can configure some housekeeping options by adding specific keys to the `daemon.json`
    file. Here is an example that will keep the logs’ size under 20 MB:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向`daemon.json`文件添加特定的键来配置一些维护选项。以下是一个示例，它将日志的大小保持在20MB以内：
- en: '[PRE23]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will apply this configuration and restart our Docker container runtime.
    We can make these changes in Docker Desktop:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用此配置并重启我们的Docker容器运行时。我们可以在Docker Desktop中进行这些更改：
- en: '![Figure 4.3 – The available Docker daemon settings in Docker Desktop (the
    embedded daemon.json file configured in our environment)](img/B19845_04_03.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – Docker Desktop中可用的Docker守护进程设置（我们环境中配置的嵌入式daemon.json文件）](img/B19845_04_03.jpg)'
- en: Figure 4.3 – The available Docker daemon settings in Docker Desktop (the embedded
    daemon.json file configured in our environment)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – Docker Desktop中可用的Docker守护进程设置（我们环境中配置的嵌入式daemon.json文件）
- en: 'It is possible to define a specific logging driver for each container, although
    it is preferred to define a common one for your entire environment:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为每个容器定义一个特定的日志驱动程序，尽管通常建议为整个环境定义一个通用的日志驱动程序：
- en: '[PRE24]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Before we complete this section, we should talk about the different logging
    strategies we can use in our environments:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本节内容之前，我们需要讨论一下可以在我们的环境中使用的不同日志记录策略：
- en: '**Local logging**: You will probably use local logging when developing your
    applications. These logs will be removed whenever you remove a container and will
    always be managed by the container runtime. These are only present locally on
    your computer desktop, laptop, or server.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地日志**：在开发应用程序时，你可能会使用本地日志。当你删除容器时，这些日志也会被删除，并且始终由容器运行时进行管理。这些日志只会保存在你的电脑桌面、笔记本电脑或服务器本地。'
- en: '**Volumes**: Using a container’s external storage will allow us to ensure that
    logs persist between executions; although these logs may be attached to the host’s
    storage, which will keep them locally only. If you want to keep these logs available
    in other servers just in case you move your containers (or execute new ones with
    the same attached volume), you will need to use external storage solutions such
    as NAS or SAN for your volumes.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卷**：使用容器的外部存储可以确保日志在执行之间得以保留；尽管这些日志可能会附加到主机的存储上，从而只会在本地保存。如果你希望在其他服务器上保留这些日志，以防你迁移容器（或执行带有相同附加卷的新容器），你将需要使用外部存储解决方案，如
    NAS 或 SAN。'
- en: '**External logging ingestion**: This should be your choice for production.
    Your application may send your logs directly from your code to an external logs
    ingestion solution or you may configure your container runtimes to send them directly
    for you. This will help you keep a homogeneous environment if your applications
    run in containers.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部日志接收**：这是生产环境的最佳选择。你的应用程序可以直接将日志从代码发送到外部日志接收解决方案，或者你可以配置容器运行时直接将日志发送出去。这将帮助你保持一个统一的环境，尤其是当你的应用程序在容器中运行时。'
- en: In the next section, we will review some of the content we learned about in
    this chapter by executing some labs.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过执行一些实验来回顾本章所学的内容。
- en: Labs
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验
- en: The following labs will provide examples to put the concepts and procedures
    that you learned about in this chapter into practice. We will use Docker Desktop
    as the container runtime and WSL2 (or your Linux/macOS Terminal) to execute the
    commands described.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以下实验将提供示例，帮助将本章中学到的概念和步骤付诸实践。我们将使用 Docker Desktop 作为容器运行时，并使用 WSL2（或你的 Linux/macOS
    终端）来执行文中描述的命令。
- en: Ensure you have downloaded the content of this book’s GitHub repository from
    [https://github.com/PacktPublishing/Docker-for-Developers-Handbook.git](https://github.com/PacktPublishing/Docker-for-Developers-Handbook.git).
    For this chapter’s labs, we will use the content of the `Chapter4` directory.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已从 [https://github.com/PacktPublishing/Docker-for-Developers-Handbook.git](https://github.com/PacktPublishing/Docker-for-Developers-Handbook.git)
    下载了本书的 GitHub 仓库内容。对于本章的实验，我们将使用 `Chapter4` 目录中的内容。
- en: Reviewing container networking concepts
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器网络概念回顾
- en: 'In this section, we will review some of the most important networking topics
    we learned about in this chapter:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将回顾本章中学习到的一些最重要的网络主题：
- en: 'First, we will run a container in the background, which will be used as a reference
    in other steps. We will run a simple `sleep` command:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将在后台运行一个容器，该容器将作为其他步骤中的参考。我们将运行一个简单的 `sleep` 命令：
- en: '[PRE25]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: $ docker container run -ti --rm \
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker container run -ti --rm \
- en: --name two alpine ping -c1 one
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --name two alpine ping -c1 one
- en: one can’t be resolved, but let’s verify whether communications exist. We used
    the --rm argument to delete the container right after its execution.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: one 无法解析，但让我们验证一下是否存在通信。我们使用了 --rm 参数，在容器执行完毕后立即删除它。
- en: '[PRE26]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let’s verify the container’s IP address by using the `inspect` action:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过使用 `inspect` 命令来验证容器的 IP 地址：
- en: '[PRE27]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: $ docker container run -ti --rm --name two \
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker container run -ti --rm --name two \
- en: --add-host one:172.17.0.2 alpine ping -c1 one
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --add-host one:172.17.0.2 alpine ping -c1 one
- en: 'PING one (172.17.0.2): 56 data bytes'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'PING one (172.17.0.2): 56 data bytes'
- en: '64 bytes from 172.17.0.2: seq=0 ttl=64 time=0.116 ms'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从 172.17.0.2 收到 64 字节：seq=0 ttl=64 time=0.116 ms
- en: '--- one ping statistics ---'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '--- one ping 统计信息 ---'
- en: 1 packets transmitted, 1 packets received, 0% packet loss
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1 个数据包传输，1 个数据包接收，0% 数据包丢失
- en: round-trip min/avg/max = 0.116/0.116/0.116 ms
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 往返时间最小/平均/最大 = 0.116/0.116/0.116 毫秒
- en: '[PRE28]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: $ docker container rm --force one
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker container rm --force one
- en: 'testnet network and review its IPAM configuration:'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试网网络并回顾其 IPAM 配置：
- en: '[PRE29]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And now we start our reference container attached to this network:'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们开始启动连接到这个网络的参考容器：
- en: '[PRE30]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Important note
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This can also be done by using `docker network connect NETWORK CONTAINER` if
    the container is already running (for example, if we reused the container from
    previous steps and attached it to the bridge network, we would have been able
    to also connect the new custom network).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器已经在运行，可以通过使用 `docker network connect NETWORK CONTAINER` 来完成此操作（例如，如果我们重新使用之前步骤中的容器并将其连接到桥接网络，我们也可以将其连接到新的自定义网络）。
- en: 'Now, let’s review the IP addresses that were assigned to the containers in
    this custom network:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下分配给这个自定义网络中的容器的IP地址：
- en: '[PRE32]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: $ docker container run -ti --rm --name two \
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: $ docker container run -ti --rm --name two \
- en: --net testnet alpine ping -c1 one
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: --net testnet alpine ping -c1 one
- en: 'PING one (172.18.0.2): 56 data bytes'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 'PING one (172.18.0.2): 56 data bytes'
- en: '64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.117 ms'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 从172.18.0.2收到64字节：seq=0 ttl=64 time=0.117 ms
- en: '--- one ping statistics ---'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '--- one ping统计 ---'
- en: 1 packets transmitted, 1 packets received, 0% packet loss
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 1个数据包发送，1个数据包接收，0%数据包丢失
- en: docker0 bridge interface by default).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下是docker0桥接接口）。
- en: Access to container services
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 访问容器服务
- en: 'In this lab, we will use the created custom network and run a simple NGINX
    web server:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在本实验中，我们将使用创建的自定义网络并运行一个简单的NGINX web服务器：
- en: 'Let’s run a new container using the `nginx:alpine` image, attached to the custom
    network. Notice that we didn’t use `--it` (interactive and pseudo-terminal attached)
    arguments because we will not interact with the NGINX process:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`nginx:alpine`镜像运行一个新容器，并将其连接到自定义网络。请注意，我们没有使用`--it`（交互式和伪终端附加）参数，因为我们不会与NGINX进程进行交互：
- en: '[PRE33]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: $ docker ps
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker ps
- en: CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS     NAMES
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: CONTAINER ID   IMAGE          COMMAND              CREATED         STATUS         PORTS     NAMES
- en: 1eb773889e80   nginx:alpine   "/docker-entrypoint.…"   4 minutes ago    Up 4
    minutes    80/tcp    webserver
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1eb773889e80   nginx:alpine   "/docker-entrypoint.…"   4 minutes ago    Up 4
    minutes    80/tcp    webserver
- en: 'curl package and test the connection to the web server running in the custom
    network:'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用curl包并测试与运行在自定义网络中的Web服务器的连接：
- en: '[PRE34]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now that we are executing a shell within the reference container, we can verify
    that the reference container’s hostname is the container’s ID by default before
    exiting:'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们在参考容器内执行一个shell，退出之前，我们可以验证参考容器的主机名默认是容器的ID：
- en: '[PRE35]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'data directory in the current path, and we will just create the index.xhtml
    file by using a simple echo command:'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当前路径下的data目录，我们将使用一个简单的echo命令创建index.xhtml文件：
- en: '[PRE36]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: $ docker container run -d --net testnet -v $(pwd)/data:/usr/share/nginx/html
    \
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker container run -d --net testnet -v $(pwd)/data:/usr/share/nginx/html
    \
- en: --name webserver nginx:alpine
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --name webserver nginx:alpine
- en: 'webserver service again:'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次启动webserver服务：
- en: '[PRE37]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: $ docker container run -d --net testnet -v $(pwd)/data:/usr/share/nginx/html
    \
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker container run -d --net testnet -v $(pwd)/data:/usr/share/nginx/html
    \
- en: --name webserver2 nginx:alpine
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --name webserver2 nginx:alpine
- en: $ docker container exec -ti one curl webserver2
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker container exec -ti one curl webserver2
- en: 'index.xhtml file and verify the result:'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: index.xhtml文件并验证结果：
- en: '[PRE38]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Notice that we can change the static content with the container in a running
    state. If your application manages static content, you will be able to verify
    the changes online while developing, but this may not work for your application
    if your processes read the information while they start. In these cases, you will
    need to restart/recreate your containers.
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，我们可以在容器运行状态下更改静态内容。如果您的应用程序管理静态内容，您可以在开发过程中在线验证更改，但如果您的进程在启动时读取信息，则可能无法正常工作。在这种情况下，您需要重新启动/重新创建容器。
- en: '[PRE39]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '2.  Finally, let’s remove the second web server:'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2. 最后，让我们移除第二个web服务器：
- en: '[PRE43]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: $ docker container run -d --net testnet \
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker container run -d --net testnet \
- en: –name webserver \
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: –name webserver \
- en: --mount type=bind,source=$(pwd)/data,target=/usr/share/nginx/html \
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --mount type=bind,source=$(pwd)/data,target=/usr/share/nginx/html \
- en: nginx:alpine
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: nginx:alpine
- en: b2446c4e77be587f911d141238a5a4a8c1c518b6aa2a0418e574e89dc135d23b
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b2446c4e77be587f911d141238a5a4a8c1c518b6aa2a0418e574e89dc135d23b
- en: $ docker container exec -ti one curl webserver
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker container exec -ti one curl webserver
- en: My webserver 2
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我的webserver 2
- en: '[PRE44]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '3.  Now, let’s test the behavior of a named volume:'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3. 现在，让我们测试一个命名卷的行为：
- en: '[PRE45]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let’s test this once more to verify the changes:'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们再测试一次，验证更改：
- en: '[PRE46]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As we have seen, we can manage persistent data inside containers using volumes
    and we can copy some content inside them using `docker cp` (you can use the same
    command to retrieve the container’s content). We also tested all the internal
    communications; we didn’t expose any service outside of the container runtime
    environment. Let’s remove both `webserver` containers if they still exist:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们可以使用卷在容器内管理持久数据，并且可以使用`docker cp`将一些内容复制到其中（您也可以使用相同的命令来检索容器的内容）。我们还测试了所有内部通信；我们没有将任何服务暴露到容器运行时环境之外。让我们移除仍然存在的`webserver`容器：
- en: '[PRE47]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now, let’s move on to the next lab.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续进行下一个实验。
- en: Exposing applications
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 暴露应用程序
- en: 'In this lab, we will expose the application’s containers outside of the container
    runtime’s internal networks:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在本实验中，我们将暴露应用程序的容器，允许它们在容器运行时的内部网络之外访问：
- en: 'We will use the `--publish-all` or `-P` argument to publish all the image’s
    defined exposed ports:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`--publish-all`或`-P`参数来发布镜像定义的所有暴露端口：
- en: '[PRE48]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '2.  Now, let’s check the service from our host. We can use `localhost`, `127.0.0.1`,
    or `0.0.0.0` as the IP address because we didn’t specify any of the host’s IP
    addresses:'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2. 现在，让我们从主机检查服务。我们可以使用`localhost`、`127.0.0.1`或`0.0.0.0`作为 IP 地址，因为我们没有指定任何主机的
    IP 地址：
- en: '[PRE49]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: $ docker container commit one myalpine
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker container commit one myalpine
- en: sha256:6732b418977ae171a31a86460315a83d13961387daacf5393e965921499b446e
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sha256:6732b418977ae171a31a86460315a83d13961387daacf5393e965921499b446e
- en: '[PRE50]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Important note
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you are using the `host` network in Linux directly, you will be able to connect
    directly to your container’s ports, even if they aren’t exposed. This doesn’t
    work in WSL environments directly, but you can use this behavior in cluster environments.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您直接在 Linux 中使用 `host` 网络，您将能够直接连接到容器的端口，即使它们没有暴露。在 WSL 环境中，直接这样做是行不通的，但在集群环境中，您可以使用这种行为。
- en: 'Now, we can use this new container by connecting it to the host’s network to
    verify how the network changed:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过将此新容器连接到主机网络，来验证网络的变化：
- en: '[PRE51]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: $ docker container exec \
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker container exec \
- en: -ti two ip add show|grep "inet "
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: -ti two ip add show|grep "inet "
- en: inet 127.0.0.1/8 scope host lo
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: inet 127.0.0.1/8 范围主机 lo
- en: inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: inet 172.17.0.1/16 brd 172.17.255.255 范围全局 docker0
- en: inet 192.168.65.4 peer 192.168.65.5/32 scope global eth0
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: inet 192.168.65.4 peer 192.168.65.5/32 范围全局 eth0
- en: inet 172.18.0.1/16 brd 172.18.255.255 scope global br-582fe354cf84
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: inet 172.18.0.1/16 brd 172.18.255.255 范围全局 br-582fe354cf84
- en: '[PRE52]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '2.  However, you should notice that DNS container resolution doesn’t work in
    the host network:'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2. 但是，您应该注意到，在主机网络中 DNS 容器解析不起作用：
- en: '[PRE53]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '3.  Let’s retrieve the web server’s IP address to access it via the host network
    container:'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3. 让我们获取 web 服务器的 IP 地址，以通过主机网络容器访问它：
- en: '[PRE54]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Next, we will review how to limit access to the host’s hardware resources and
    how exceeding the memory limit will trigger the execution of the OOM-Killer kernel
    process.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将回顾如何限制对主机硬件资源的访问，以及如何超出内存限制会触发 OOM-Killer 内核进程的执行。
- en: Limiting containers’ resource usage
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 限制容器的资源使用
- en: 'In this lab, we will review how to limit the host’s memory inside a container:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在本实验中，我们将回顾如何限制容器内的主机内存：
- en: 'First, we will create a custom image, including the `stress-ng` application:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个自定义镜像，包括`stress-ng`应用：
- en: '[PRE55]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: $ docker run -d --name stress stress stress-ng  \
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker run -d --name stress stress stress-ng  \
- en: --vm-bytes 1024M  --fork 1 -m 1
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --vm-bytes 1024M  --fork 1 -m 1
- en: 'docker stats to retrieve the current container’s resource usage:'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 docker stats 检索当前容器的资源使用情况：
- en: '[PRE56]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: $ docker stats --no-stream
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker stats --no-stream
- en: CONTAINER ID   NAME      CPU %     MEM USAGE / LIMIT     MEM %     NET I/O     BLOCK
    I/O   PIDS
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: CONTAINER ID   NAME      CPU %     MEM USAGE / LIMIT     MEM %     NET I/O       BLOCK
    I/O   PIDS
- en: 'stress container and run it again, limiting its access to the host’s memory:'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: stress 容器并重新运行，限制其访问主机内存：
- en: '[PRE57]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: $ docker stats --no-stream
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker stats --no-stream
- en: CONTAINER ID   NAME              CPU %     MEM USAGE / LIMIT   MEM %     NET
    I/O       BLOCK I/O   PIDS
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: CONTAINER ID   NAME              CPU %     MEM USAGE / LIMIT   MEM %     NET
    I/O       BLOCK I/O   PIDS
- en: ff3f4797af43   stress-limited   166.65%   125.1MiB / 128MiB   97.74%    1.12kB
    / 0B   0B / 0B     4
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ff3f4797af43   stress-limited   166.65%   125.1MiB / 128MiB   97.74%   1.12kB
    / 0B   0B / 0B   4
- en: '[PRE58]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: $ docker stats --no-stream
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker stats --no-stream
- en: CONTAINER ID   NAME              CPU %     MEM USAGE / LIMIT   MEM %     NET
    I/O       BLOCK I/O   PIDS
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: CONTAINER ID   NAME              CPU %     MEM USAGE / LIMIT   MEM %     NET
    I/O       BLOCK I/O   PIDS
- en: ff3f4797af43   stress-limited   142.81%   127MiB / 128MiB     99.19%    1.12kB
    / 0B   0B / 0B     5
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ff3f4797af43   stress-limited   142.81%   127MiB / 128MiB     99.19%   1.12kB
    / 0B   0B / 0B   5
- en: '[PRE59]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: $ dmesg|grep -i oom
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ dmesg|grep -i oom
- en: '[22893.337110] oom_reaper: reaped process 19232 (stress-ng), now anon-rss:0kB,
    file-rss:0kB, shmem-rss:32kB'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[22893.337110] oom_reaper: 收割进程 19232 (stress-ng)，现在 anon-rss:0kB，file-rss:0kB，shmem-rss:32kB'
- en: '[22893.915193] stress-ng invoked oom-killer: gfp_mask=0xcc0(GFP_KERNEL), order=0,
    oom_score_adj=1000'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[22893.915193] stress-ng 调用了 oom-killer：gfp_mask=0xcc0(GFP_KERNEL)，order=0，oom_score_adj=1000'
- en: '[22893.915221]  oom_kill_process.cold+0xb/0x10'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[22893.915221] oom_kill_process.cold+0xb/0x10'
- en: '[22893.915307] [  pid  ]   uid  tgid total_vm      rss pgtables_bytes swapents
    oom_score_adj name'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[22893.915307] [ pid ]   uid  tgid total_vm      rss pgtables_bytes swapents
    oom_score_adj name'
- en: stress-ng worker processes, but it launches more (this is the normal stress-ng
    behavior, but your applications may die if OOM-Killer is asked to destroy your
    processes).
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: stress-ng 工作进程，但它会启动更多进程（这是 stress-ng 的正常行为，但如果 OOM-Killer 被要求销毁您的进程，您的应用程序可能会崩溃）。
- en: '[PRE60]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '2.  We will finish this lab by simply removing the used containers:'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2. 我们将通过简单地删除使用过的容器来完成此实验：
- en: '[PRE63]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We can now move on to the next lab, in which we will learn how to limit the
    use of privileged users in our processes if they are not needed.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以进入下一个实验，在其中我们将学习如何限制如果不需要特权用户的情况下在进程中使用它们。
- en: Avoiding the use of root users inside containers
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在容器内使用 root 用户
- en: 'This quick lab will show you how to run an NGINX web server without `root`.
    But first, we will review what happens when you change the default NGINX environment:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这个快速实验将向你展示如何在没有 `root` 权限的情况下运行 NGINX web 服务器。但首先，我们将回顾更改默认 NGINX 环境时会发生什么：
- en: 'First, let’s review the user that a default `nginx:alpine` image will use by
    simply executing a new web server:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们查看默认的 `nginx:alpine` 镜像使用的用户，方法是简单地启动一个新的 web 服务器：
- en: '[PRE64]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: $ curl 0.0.0.0:8080 -I
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ curl 0.0.0.0:8080 -I
- en: HTTP/1.1 200 OK
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: HTTP/1.1 200 OK
- en: '...'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...'
- en: '[PRE65]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '2.  Now, let’s retrieve its logs:'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2. 现在，让我们检索它的日志：
- en: '[PRE66]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: $ docker logs webserver --details \
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker logs webserver --details \
- en: --timestamps --tail 2
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --timestamps --tail 2
- en: 2023-03-31T19:29:35.362006700Z  172.17.0.1 - - [31/Mar/2023:19:29:35 +0000]
    "GET / HTTP/1.1" 200 615 "-" "curl/7.81.0" "-"
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2023-03-31T19:29:35.362006700Z  172.17.0.1 - - [31/Mar/2023:19:29:35 +0000]
    "GET / HTTP/1.1" 200 615 "-" "curl/7.81.0" "-"
- en: '--timestamp to show the container runtime’s included timestamp. This can be
    very useful when the running application does not provide any timestamp.By default,
    NGINX writes to `/var/log/nginx/access.log` and `/var/log/nginx/error.log`. It
    is very interesting to learn how this container’s image developers set the processes
    up to write to `/dev/stdout` and `/dev/stderr`. You can learn more at [github.com/nginxinc/docker-nginx/blob/73a5acae6945b75b433cafd0c9318e4378e72cbb/mainline/alpine-slim/Dockerfile](http://github.com/nginxinc/docker-nginx/blob/73a5acae6945b75b433cafd0c9318e4378e72cbb/mainline/alpine-slim/Dockerfile).
    An extract of the currently important lines is shown here:'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --timestamp 用于显示容器运行时包含的时间戳。当运行的应用程序未提供任何时间戳时，这非常有用。默认情况下，NGINX 会写入 `/var/log/nginx/access.log`
    和 `/var/log/nginx/error.log`。了解该容器镜像的开发者如何设置进程，将日志写入 `/dev/stdout` 和 `/dev/stderr`，是非常有趣的。你可以在
    [github.com/nginxinc/docker-nginx/blob/73a5acae6945b75b433cafd0c9318e4378e72cbb/mainline/alpine-slim/Dockerfile](http://github.com/nginxinc/docker-nginx/blob/73a5acae6945b75b433cafd0c9318e4378e72cbb/mainline/alpine-slim/Dockerfile)
    上了解更多。以下是目前重要的行摘录：
- en: '[PRE67]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '3.  Now, let’s check the user running this instance:'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3. 现在，让我们查看运行此实例的用户：
- en: '[PRE69]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: $ docker container rm webserver --force -v
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker container rm webserver --force -v
- en: '0 user (root) to a common 1000 ID:'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 0 用户（root）到普通 1000 ID：
- en: '[PRE70]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: $ docker logs webserver
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker logs webserver
- en: '...'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...'
- en: 'nginx: [warn] the "user" directive makes sense only if the master process runs
    with super-user privileges, ignored in /etc/nginx/nginx.conf:2'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'nginx: [warn] "user" 指令仅在主进程以超级用户权限运行时才有意义，在 /etc/nginx/nginx.conf:2 中被忽略'
- en: '2023/04/01 11:36:03 [emerg] 1#1: mkdir() "/var/cache/nginx/client_temp" failed
    (13: Permission denied)'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '2023/04/01 11:36:03 [emerg] 1#1: mkdir() "/var/cache/nginx/client_temp" 失败
    (13: 权限被拒绝)'
- en: '80 because it is system-restricted; if this port must be used in your environment,
    special capabilities such as NET_BIND_SERVICE should be added. Instead of changing
    the current image behavior, we will use a new image from NGINX, Inc.:'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 80 是因为它是系统限制的；如果必须在你的环境中使用此端口，则应添加像 NET_BIND_SERVICE 这样的特殊权限。我们不会更改当前镜像的行为，而是将使用
    NGINX, Inc. 提供的新镜像：
- en: '[PRE71]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: You can find this image and its information at [https://hub.docker.com/r/nginxinc/nginx-unprivileged#!](https://hub.docker.com/r/nginxinc/nginx-unprivileged#!).
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在 [https://hub.docker.com/r/nginxinc/nginx-unprivileged#!](https://hub.docker.com/r/nginxinc/nginx-unprivileged#!)
    找到此镜像及其信息。
- en: '[PRE72]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '4.  Let’s pull the image from Docker Hub and review the ports and the user
    used:'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 4. 让我们从 Docker Hub 拉取镜像并查看端口和使用的用户：
- en: '[PRE74]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: $ docker image inspect \
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker image inspect \
- en: nginxinc/nginx-unprivileged:alpine-slim \
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: nginxinc/nginx-unprivileged:alpine-slim \
- en: --format="{{ .Config.ExposedPorts }} {{ .Config.User }}"
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --format="{{ .Config.ExposedPorts }} {{ .Config.User }}"
- en: '8080 on our host’s port 8080. Notice that we used the --publish option, which
    allows us to even use a specific IP address from our host in IP:host_port:container_port
    format:'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 8080 在我们主机的端口 8080 上。注意，我们使用了 --publish 选项，它允许我们以 IP:host_port:container_port
    格式使用主机的特定 IP 地址：
- en: '[PRE75]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '5.  Let’s test our web server again and review the logs:'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 5. 让我们再次测试我们的 web 服务器并查看日志：
- en: '[PRE77]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '6.  Now, let’s review the web server’s user:'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 6. 现在，让我们查看 web 服务器的用户：
- en: '[PRE78]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: As we expected, this `webserver` application runs using a non-privileged user
    and it’s safer than the one running as `root`. You, as the developer, must prioritize
    the usage of non-privileged users in your applications to improve the components’
    security.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们预期的那样，这个 `webserver` 应用程序是使用非特权用户运行的，比以 `root` 身份运行要更安全。作为开发者，你必须优先考虑在应用程序中使用非特权用户，以提高组件的安全性。
- en: Cleaning the container runtime
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 清理容器运行时
- en: 'To finish this chapter’s labs, we will quickly clean up all the objects that
    were created during the labs by using a combination of commands:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章的实验，我们将通过组合多个命令，快速清理实验过程中创建的所有对象：
- en: 'Kill all the running containers (we can also remove them using a single line,
    but we will kill them before using the `prune` action):'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 杀掉所有正在运行的容器（我们也可以通过一行命令将它们删除，但我们将在执行`prune`操作前先终止它们）：
- en: '[PRE79]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '2.  Now, we can use `docker system prune` to remove all the objects that were
    created. We will use `--all` to remove all the unused images and the volumes by
    adding `–-volumes` (you will be asked for confirmation):'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2.  现在，我们可以使用`docker system prune`命令删除所有已创建的对象。我们将使用`--all`删除所有未使用的镜像，并通过添加`--volumes`来删除卷（系统会要求确认）：
- en: '[PRE80]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: $ docker system df
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker system df
- en: TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型           总计       活跃       大小       可回收
- en: Images          0         0         0B        0B
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 镜像           0          0          0B         0B
- en: Containers      0         0         0B        0B
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 容器           0          0          0B         0B
- en: Local Volumes   0         0         0B        0B
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本地卷       0          0          0B         0B
- en: Build Cache     0         0         0B        0B
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构建缓存       0          0          0B         0B
- en: '[PRE81]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'In these labs, we covered almost all the content that we reviewed in this chapter.
    You may find additional information in the GitHub repository that’s been prepared
    for this chapter: [https://github.com/PacktPublishing/Docker-for-Developers-Handbook/tree/main/Chapter4](https://github.com/PacktPublishing/Docker-for-Developers-Handbook/tree/main/Chapter4).'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些实验中，我们涵盖了本章中几乎所有的内容。你可以在为本章准备的GitHub仓库中找到更多信息：[https://github.com/PacktPublishing/Docker-for-Developers-Handbook/tree/main/Chapter4](https://github.com/PacktPublishing/Docker-for-Developers-Handbook/tree/main/Chapter4)。
- en: Summary
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to run containers and manage their behavior.
    We also reviewed how we can limit access to the host’s resources by applying different
    kernel features. Different techniques allow us to interact with containers while
    they are running, and we can use them to retrieve important information about
    the applications running inside. By the end of this chapter, we also learned about
    some simple commands that will help us keep our environments free of old unused
    containers’ objects.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何运行容器并管理它们的行为。我们还回顾了如何通过应用不同的内核功能来限制对主机资源的访问。不同的技术允许我们在容器运行时与之交互，并能用它们获取关于容器内应用程序的重要信息。在本章结束时，我们还学习了一些简单的命令，帮助我们保持环境中没有旧的未使用容器对象。
- en: Now that we know how to create container images, store them, and run containers
    using them, we can move on to the next chapter, where we will learn how to run
    applications by using multiple containers that interact with each other.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何创建容器镜像、存储镜像并使用它们运行容器后，我们可以进入下一章，学习如何使用多个相互交互的容器来运行应用程序。
- en: '[PRE82]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
