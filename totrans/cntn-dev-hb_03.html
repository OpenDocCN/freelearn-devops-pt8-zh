<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer054">
<h1 class="chapter-number" id="_idParaDest-66"><a id="_idTextAnchor082"/>3</h1>
<h1 id="_idParaDest-67"><a id="_idTextAnchor083"/>Sharing Docker Images</h1>
<p>Sharing container images is key to being able to run your applications anywhere. You’ve built your application components on your workstation or laptop, and now you are ready to move them to different platform stages. This chapter will cover how images will be stored and shared with other users or orchestration platforms. We will also review various methods for signing container images to improve security in our development workflow. We will also learn how to use content scanners to find any possible security issues in our container images. By the end of this chapter, you will be ready to deliver secure and trusted images <span class="No-Break">to production.</span></p>
<p>In this chapter, we will cover the following <span class="No-Break">main topics:</span></p>
<ul>
<li>Container image registries <span class="No-Break">and repositories</span></li>
<li>Improving security by signing <span class="No-Break">container images</span></li>
<li>Analyzing container image content by using <span class="No-Break">image scanners</span></li>
</ul>
<p>This chapter will teach you about the different tools and techniques used to deliver secure images, which will really improve the use of software containers in <span class="No-Break">your projects.</span></p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor084"/>Technical requirements</h1>
<p>You can find the labs for this chapter at <a href="https://github.com/PacktPublishing/Containers-for-Developers-Handbook/tree/main/Chapter3">https://github.com/PacktPublishing/Containers-for-Developers-Handbook/tree/main/Chapter3</a>, where you will find some extended explanations, omitted in the chapter’s content to make it easier to follow. The <em class="italic">Code In Action</em> video for this chapter can be found <span class="No-Break">at </span><a href="https://packt.link/JdOIY"><span class="No-Break">https://packt.link/JdOIY</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-69"><a id="_idTextAnchor085"/>Container image registries and repositories</h1>
<p>In <a href="B19845_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Modern Infrastructure and Applications with Docker</em>, we discussed why <a id="_idIndexMarker335"/>software containers have become so popular. In <a href="B19845_02.xhtml#_idTextAnchor036"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Building Docker Images</em>, we <a id="_idIndexMarker336"/>learned how we can create containers by using them as templates and building container images. Before deep-diving into container execution, we will learn, in this chapter, how to store and manage container images by <span class="No-Break">using registries.</span></p>
<h2 id="_idParaDest-70"><a id="_idTextAnchor086"/>What is a registry?</h2>
<p>A <strong class="bold">registry</strong> is a service <a id="_idIndexMarker337"/>where container images can be stored. This storage can be delivered as a service by cloud providers or on-premises by deploying your own registry. Cloud registries require zero maintenance from you; you just need to manage the usual housekeeping of <a id="_idIndexMarker338"/>unused images. Docker Hub (<a href="http://docker.io">docker.io</a>) is probably the most common service of this kind, but we also have Google’s Container <a id="_idIndexMarker339"/>Registry (<a href="http://gcr.io">gcr.io</a>) and similar services from Red Hat, GitHub, and GitLab, among others. Container images have become the new artifacts to run applications, and nowadays, many cloud code repositories include their own image <span class="No-Break">registry services.</span></p>
<p>Nowadays, most registries can ingest and manage Docker’s Image Manifest V2 and Open Container Initiative specifications, and therefore, we can use any of these formats for our images. These image schemas specify how image layers and metadata will be associated for use in our <span class="No-Break">container runtime.</span></p>
<p>At the end of this chapter, we will run our own local registry and verify how images <span class="No-Break">are stored.</span></p>
<p>Container runtimes completely manage all the actions we do with software containers or their images; hence, your client will just tell your runtime to download images before executing a container or upload them <span class="No-Break">once built.</span></p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor087"/>Understanding how image registries work</h2>
<p>Before continuing to understand how image registries work, we should introduce here the complete <a id="_idIndexMarker340"/>container image naming convention. Images will always be referenced by using the following <span class="No-Break"><strong class="source-inline">name</strong></span><span class="No-Break">:</span><span class="No-Break"><strong class="source-inline">tag</strong></span><span class="No-Break"> format:</span></p>
<pre class="source-code">
full_FQDN_registry_name[:registry_port]/[username or team]/image_repository:image_tag</pre> <p>This means that all image references must contain the registry where they are stored. You can omit this while your container runtime works with local images, but any time you use any <a id="_idIndexMarker341"/>remote image, you should always use the registry’s <strong class="bold">Fully Qualified Domain Name</strong> (<strong class="bold">FQDN</strong>). Usually, registries are published on port <strong class="source-inline">443</strong>, using <strong class="bold">TLS/SSL</strong>. This port will be used by default by container runtimes to connect to registries, but we can use any other port by specifying it when we <a id="_idIndexMarker342"/>refer to its images. <strong class="bold">Image repository</strong> is the term we commonly use to refer to the software repository where images are stored, but it is important to understand that images follow the same nomenclature used for code repositories, and hence, different tags are used to identify images <span class="No-Break">within repositories.</span></p>
<p>Container images may be associated with the users or teams that own the images in the registries. This is common for these kinds of services, as the user is the one who pushed the image, which may be public or private. If you are part of a group, your image may be accessible to <a id="_idIndexMarker343"/>the members of the group. This role-based access may differ from one registry to another; you should ask your administrators or read the appropriate documentation for your registry. Docker images published in Docker Hub are shown as <strong class="source-inline">docker.io/library</strong>, and all their public repositories are published under this root group, similar to the schema presented at the beginning of <span class="No-Break">this subsection.</span></p>
<p>Conversely, although tags help identify images, we learned in <a href="B19845_02.xhtml#_idTextAnchor036"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Building Docker Images</em>, that one image can have multiple tags; hence, a tag does not uniquely identify a <a id="_idIndexMarker344"/>specific image. <strong class="bold">Image digests</strong>, however, uniquely identify a set of layers for each image, and these really differ between images. To ensure that we use the correct image, we should use <span class="No-Break">its </span><span class="No-Break"><strong class="bold">digest</strong></span><span class="No-Break">.</span></p>
<p>Tagging images is not always easy; you must ensure, as a developer, that anyone can follow your work by using appropriate tags that reference the release on which users are running. Remember that you can add as many labels as you need to include additional information that is relevant for users. I always try to follow the code release schema, using <strong class="source-inline">X.Y.Z</strong> to represent major versions, minor versions, and fixes. It is a good idea to include a label regarding the commit in your code that generated the image artifact. This will help you track problems and also improve the application’s life cycle. Automation will really help you to implement a workflow and follow your own tagging and labeling <span class="No-Break">logic schema.</span></p>
<p>Whenever we pull an image from a registry, we get its digest within its metadata, as we can see in the following example, by executing <strong class="source-inline">docker image </strong><span class="No-Break"><strong class="source-inline">pull alpine:3.17.2</strong></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer043">
<img alt="Figure 3.1 – An image digest can be easily recovered after pulling an image from remote registries" height="629" src="image/B19845_03_01.jpg" width="1334"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – An image digest can be easily recovered after pulling an image from remote registries</p>
<p>Depending on <a id="_idIndexMarker345"/>which container runtime you use, a default container registry can be set. The Docker container runtime will use <a href="http://docker.io">docker.io</a> by default, which is why we can execute <strong class="source-inline">docker image pull alpine:3.17.2</strong> to download an <strong class="source-inline">alpine:3.17.2</strong> image, as shown in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.1</em>. The digest in both cases is the same; hence, they are the same image. However, we can create a new image with this same name in our system. If we first delete the previously downloaded image (names are unique within a container runtime) and create a new one, it will have a completely different digest. This will happen even if we used the same Dockerfile because digests will also integrate the dates for each execution done during the <span class="No-Break">build process.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">We can download all images from a repository by using the <strong class="source-inline">--all-tags</strong> argument, as in the following example: <strong class="source-inline">docker image pull --all-tags alpine</strong>. This will download all images inside the <span class="No-Break"><strong class="source-inline">alpine</strong></span><span class="No-Break"> repository.</span></p>
<p>We can review which registries are included by default in Docker Desktop by using <strong class="source-inline">docker info</strong>. The following <a id="_idIndexMarker346"/>screenshot shows an example output using <span class="No-Break"><strong class="bold">Windows PowerShell</strong></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer044">
<img alt="Figure 3.2 – Local container image registries used by our container runtime" height="677" src="image/B19845_03_02.jpg" width="1332"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Local container image registries used by our container runtime</p>
<p>In this example, the <strong class="source-inline">localhost</strong> registry and <strong class="source-inline">hubproxy.docker.internal:5000</strong> are shown. The local <a id="_idIndexMarker347"/>registry is used to store images locally. Desktop <a id="_idIndexMarker348"/>clients such as <strong class="bold">Docker Desktop</strong> and <strong class="bold">Rancher Desktop</strong> will show local <span class="No-Break">images graphically:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer045">
<img alt="Figure 3.3 – An overview of Docker Desktop local images" height="770" src="image/B19845_03_03.jpg" width="1499"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – An overview of Docker Desktop local images</p>
<p>In fact, Docker offers <a id="_idIndexMarker349"/>integration with your Docker Hub account. You can also view your <span class="No-Break">remote images:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer046">
<img alt="Figure 3.4 – An overview of Docker Desktop Docker Hub remote images" height="884" src="image/B19845_03_04.jpg" width="1499"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – An overview of Docker Desktop Docker Hub remote images</p>
<p>This interface also allows you to download and review the vulnerabilities found in the image’s content if you pay for a Docker subscription. We will learn more about security content scanning in the <em class="italic">Scanning image content for vulnerabilities</em> section in <span class="No-Break">this chapter.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Your container runtime may require some specific configurations to allow new container registries. All container image registries are expected to use <strong class="bold">HTTPS</strong>. Insecure registries are those that don’t use secure protocols or use certificates that aren’t trusted. Please add any registry with these characteristics to the <span class="No-Break"><strong class="source-inline">insecure-registries</strong></span><span class="No-Break"> list.</span></p>
<p>Registries will <a id="_idIndexMarker350"/>usually require a login, and we will use their FQDN to access them. If you need to access private repositories, an account will <span class="No-Break">be required.</span></p>
<p>We will use <strong class="source-inline">docker search</strong> to find repositories based on <span class="No-Break">a string:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer047">
<img alt="Figure 3.5 – Searching for images using the docker search command" height="475" src="image/B19845_03_05.jpg" width="1518"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Searching for images using the docker search command</p>
<p>Note that some images are marked as <strong class="source-inline">OFFICIAL</strong> and others as <strong class="source-inline">AUTOMATED</strong>. Docker Hub provides this feature as, depending on your registry, some CI/CD integrations may build images automatically for you. These values help mark automatically built images. You can use their automation if it fits <span class="No-Break">your requirements</span><span class="No-Break">.</span></p>
<p>Docker official images are container images built and maintained by Docker following best practices. They also ensure security by providing continuous updates. All official image code is publicly available on GitHub, and you can use it directly or customize it to your needs. You can provide feedback and contact Docker if you have any issues with using them. A great example of these repositories is the one for Alpine images (<a href="https://github.com/alpinelinux/docker-alpine/">https://github.com/alpinelinux/docker-alpine/</a>), where you will find code to build all Alpine images. The <a id="_idIndexMarker351"/>following screenshot shows how can you find official images for any technology you <span class="No-Break">may need:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer048">
<img alt="Figure 3.6 – An overview of official images available in Docker Hub" height="843" src="image/B19845_03_06.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – An overview of official images available in Docker Hub</p>
<p>Software vendors and open source community projects also offer container images, prepared and maintained by them. The best method to integrate third-party projects or components in your applications will always be using images already prepared for you by Docker, a verified publisher, or sponsored open source software providers. These images are quite well documented, and you will be able to customize container behavior by using arguments and environment variables. You will avoid a lot of problems by using these images, instead of having to create your own from scratch. In the <em class="italic">Labs</em> section, we will review a very commonly used PostgreSQL database example to understand <span class="No-Break">this better.</span></p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor088"/>Searching in repositories</h2>
<p>The Docker client provides certain repository search features, but they are not sufficient when you <a id="_idIndexMarker352"/>try to find specific images. You will probably use the Docker Hub web interface to perform fine-grained searches. Image registries publish their API, and we can use <strong class="source-inline">curl</strong> or any other web interface with arguments to find these images. Alternatively, we can use <strong class="source-inline">skopeo</strong> instead. This tool allows us to filter specific tags when we search inside <span class="No-Break">a repository.</span></p>
<p>As mentioned previously in this section, registries provide an HTTP API that we can use to query specific repositories, tags, and so on, but it is not easy to use. We can use, for example, <strong class="source-inline">curl</strong> <a href="https://myregistry.com:5000/v2/_catalog">https://myregistry.com:5000/v2/_catalog</a> to list all the images in the catalog. It is recommended to use <strong class="source-inline">skopeo</strong> instead because it will give you a clear and easy command line, especially when working with authenticated registries (certificates and login are required). It is available for different Linux flavors in their package repositories. You can follow the instructions for your distribution, or WSL, <span class="No-Break">here: </span><a href="https://github.com/containers/skopeo/blob/main/install.md"><span class="No-Break">https://github.com/containers/skopeo/blob/main/install.md</span></a><span class="No-Break">.</span></p>
<p>Unfortunately, <strong class="source-inline">skopeo</strong> isn’t available in the Ubuntu 20.04 LTS package repository. We can install a newer WSL distribution by executing <strong class="source-inline">wsl --install -d Ubuntu-22.04</strong> in a Windows PowerShell terminal. Once the new Ubuntu 22.04 WSL distribution is ready, we can install the package by using <strong class="source-inline">sudo apt-get update -qq &amp;&amp; sudo apt-get install skopeo -qq</strong>. Then, we can integrate the container runtime from either Docker Desktop or Rancher Desktop by navigating to <strong class="bold">Settings</strong> | <strong class="bold">Resources</strong> | <strong class="bold">WSL Integration</strong> or <strong class="bold">File</strong> | <strong class="bold">Preferences</strong> | <strong class="bold">WSL</strong>. The following screenshot shows the interface in <span class="No-Break">Docker Desktop:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer049">
<img alt="Figure 3.7 – Enabling Docker Desktop integration in Ubuntu 22.04 LTS WSL" height="637" src="image/B19845_03_07.jpg" width="946"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – Enabling Docker Desktop integration in Ubuntu 22.04 LTS WSL</p>
<p>With <strong class="source-inline">skopeo</strong>, we can <a id="_idIndexMarker353"/>easily list all tags included in a repository, as shown in the <span class="No-Break">following example:</span></p>
<pre class="console">
$ skopeo  list-tags docker://docker.io/frjaraur/colors
{
    "Repository": "docker.io/frjaraur/colors",
    "Tags": [
        "1.0",
        "1.1",
        "1.2",
        "1.5",
        "latest"
    ]
}</pre> <p>We can even inspect remote image information by using <span class="No-Break"><strong class="source-inline">skopeo inspect</strong></span><span class="No-Break">:</span></p>
<pre class="console">
$ skopeo inspect docker://docker.io/frjaraur/colors:1.0 \
--format="{{ .Digest }}"
sha256:cb7c1e49bcac66663aafea571ce5a6e6626e387c43b4836cc4d9e4c0e5d9faff</pre> <p>Instead <a id="_idIndexMarker354"/>of installing <strong class="source-inline">skopeo</strong> locally, we can use Red Hat’s official image by using <strong class="source-inline">docker </strong><span class="No-Break"><strong class="source-inline">container run</strong></span><span class="No-Break">:</span></p>
<pre class="console">
$ docker container run --rm quay.io/skopeo/stable \
inspect docker://docker.io/frjaraur/colors:1.0 \
--format="{{ .Digest }}"
Unable to find image 'quay.io/skopeo/stable:latest' locally
latest: Pulling from skopeo/stable
1a72627e77ed: Already exists
...
Digest: sha256:23f4b378c4aff49621e90289b33daf133462824b5eba603b0834e25cb83a97ca
Status: Downloaded newer image for quay.io/skopeo/stable:latest
sha256:cb7c1e49bcac66663aafea571ce5a6e6626e387c43b4836cc4d9e4c0e5d9faff</pre> <p>Hopefully, this has given you a new perspective on using software containers. We can package tools in container images and use them instead of having to install software on <span class="No-Break">our computers.</span></p>
<p>Now that we know how to store and reference images from registries, it is time to learn how we can improve the ownership and security of our images by <span class="No-Break">signing them.</span></p>
<h1 id="_idParaDest-73"><a id="_idTextAnchor089"/>Improving security by signing container images</h1>
<p>As we mentioned in the previous section, a digest is the only way we can validate <a id="_idIndexMarker355"/>which image we are really using. In this section, we will review how we can improve this by signing images. This will really ensure we use the right images, as we can check the signature and verify the ownership of <span class="No-Break">every image.</span></p>
<p>We are going to analyze and learn about the Docker methodology used to sign images, but there are other methods available. We will use <strong class="bold">Cosign</strong> in the <em class="italic">Labs</em> section, which seems easier and integrates very well with the Kubernetes <span class="No-Break">container orchestrator.</span></p>
<p>Docker <a id="_idIndexMarker356"/>created <strong class="bold">Docker Content Trust</strong> some years ago to integrate digital signatures in the container images management workflow and associate signatures with image tags. We will be able to have repositories with signed and unsigned images, for example, for local tests before moving on to a new stage. You, as a developer, create your images and decide which ones should <span class="No-Break">be signed.</span></p>
<p>The signing process is based on a list of different keys that will be used to include meta-information in your registered image. Some of these keys are interactively managed, while others are calculated during the execution. These include <span class="No-Break">the following:</span></p>
<ul>
<li>A <strong class="source-inline">root</strong> key is always used to start the signing process. You will be asked for this key, but you can also include it in your environment as a variable. It is very important to mention that if you lose this key, you will need to re-sign all your images, as there isn’t a known process to recover them. Always have a backup of this key; losing it can be a real problem in a production environment because your old signatures will not <span class="No-Break">be valid.</span></li>
<li>Each repository will also have its <strong class="source-inline">own</strong> key. This key will be used to sign images in a specific repository, so losing it will only affect the images there. Nonetheless, you should keep it safe and have <span class="No-Break">a backup.</span></li>
<li>The <strong class="source-inline">timestamp</strong> key is added automatically to the final signature. This ensures security because each signature will always be <span class="No-Break">completely different.</span></li>
</ul>
<p>You will be asked to create a passphrase for the root key, and each repository key will be created randomly. Docker provides its own password manager under your user’s <strong class="source-inline">~/.</strong><span class="No-Break"><strong class="source-inline">docker</strong></span><span class="No-Break"> directory.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">To back up your keys, prepare a <strong class="source-inline">tar.gz</strong> file with the contents of <strong class="source-inline">~/.docker/trust/private</strong>. We can execute the following <span class="No-Break">command line:</span></p>
<p class="callout"><strong class="source-inline">$ umask 077; tar -zcvf private_keys_backup.tar.gz ~/.docker/trust/private; </strong><span class="No-Break"><strong class="source-inline">umask 022</strong></span></p>
<p>We can enable Docker Content Trust in our client by setting the <strong class="source-inline">DOCKER_CONTENT_TRUST=1</strong> environment variable. This will enable Content Trust for any new command executed, which means that only signed images will be enabled in your environment. If we just <a id="_idIndexMarker357"/>need to enable Content Trust for a specific command, we can use the <strong class="source-inline">--</strong><span class="No-Break"><strong class="source-inline">disable-content-trust=false</strong></span><span class="No-Break"> argument.</span></p>
<p>Let’s try enabling Content Trust for an image by setting the <strong class="source-inline">DOCKER_CONTENT_TRUST</strong> variable. In this example, we perform the <span class="No-Break">following steps:</span></p>
<ol>
<li>We first pull the <span class="No-Break"><strong class="source-inline">docker.io/busybox:latest</strong></span><span class="No-Break"> image:</span><pre class="source-code">
<strong class="bold">$ docker image pull busybox</strong>
<strong class="bold">Using default tag: latest</strong>
<strong class="bold">latest: Pulling from library/busybox</strong>
<strong class="bold">Digest: sha256:7b3ccabffc97de872a30dfd234fd972a66d247c8cfc69b0550f276481852627c</strong>
<strong class="bold">Status: Image is up to date for busybox:latest</strong>
<strong class="bold">docker.io/library/busybox:latest</strong></pre></li> <li>Now, we enable <strong class="source-inline">DOCKER_CONTENT_TRUST=1</strong> and download the same <span class="No-Break">image again:</span><pre class="source-code">
<strong class="bold">$ export DOCKER_CONTENT_TRUST=1</strong>
<strong class="bold">$ docker image pull busybox</strong>
<strong class="bold">Using default tag: latest</strong>
<strong class="bold">Pull (1 of 1): busybox:latest@sha256:7b3ccabffc97de872a30dfd234fd972a66d247c8cfc69b0550f276481852627c</strong>
<strong class="bold">docker.io/library/busybox@sha256:7b3ccabffc97de872a30dfd234fd972a66d247c8cfc69b0550f276481852627c: Pulling from library/busybox</strong>
<strong class="bold">Digest: sha256:7b3ccabffc97de872a30dfd234fd972a66d247c8cfc69b0550f276481852627c</strong>
<strong class="bold">Status: Image is up to date for busybox@sha256:7b3ccabffc97de872a30dfd234fd972a66d247c8cfc69b0550f276481852627c</strong>
<strong class="bold">Tagging busybox@sha256:7b3ccabffc97de872a30dfd234fd972a66d247c8cfc69b0550f276481852627c as busybox:latest</strong>
<strong class="bold">docker.io/library/busybox:latest</strong></pre></li> <li>I have prepared <a id="_idIndexMarker358"/>my own <strong class="source-inline">busybox</strong> image, <strong class="source-inline">docker.io/frjaraur/busybox-untrusted:0.1</strong>. Let’s see what happens if we try to pull an untrusted image when Docker Content Trust <span class="No-Break">is enabled:</span><pre class="source-code">
<strong class="bold">$ docker pull docker.io/frjaraur/busybox-untrusted:0.1</strong>
<strong class="bold">Error: remote trust data does not exist for docker.io/frjaraur/busybox-untrusted: notary.docker.io does not have trust data for docker.io/frjaraur/busybox-untrusted</strong></pre><p class="list-inset">This means that no valid signature is found, but if we disable Content Trust, we can pull the image without <span class="No-Break">a problem:</span></p><pre class="source-code"><strong class="bold">$ export DOCKER_CONTENT_TRUST=0</strong>
<strong class="bold">$ docker pull docker.io/frjaraur/busybox-untrusted:0.1</strong>
<strong class="bold">0.1: Pulling from frjaraur/busybox-untrusted</strong>
<strong class="bold">Digest: sha256:907ca53d7e2947e849b839b1cd258c98fd3916c60f2e6e70c30edbf741ab6754</strong>
<strong class="bold">Status: Downloaded newer image for frjaraur/busybox-untrusted:0.1</strong>
<strong class="bold">docker.io/frjaraur/busybox-untrusted:0.1</strong></pre><p class="list-inset">In fact, we can’t run any container using this untrusted image, which we can <span class="No-Break">easily verify:</span></p><pre class="source-code"><strong class="bold">$ docker run -ti --disable-content-trust=false\</strong>
<strong class="bold">docker.io/frjaraur/busybox-untrusted:0.1</strong>
<strong class="bold">docker: Error: remote trust data does not exist for docker.io/frjaraur/busybox-untrusted: notary.docker.io does not have trust data for docker.io/frjaraur/busybox-untrusted.</strong>
<strong class="bold">See 'docker run --help'.</strong></pre><p class="list-inset">Conversely, if we <a id="_idIndexMarker359"/>run a trusted image, everything works <span class="No-Break">as expected:</span></p><pre class="source-code"><strong class="bold">$ docker run -ti --disable-content-trust=false \</strong>
<strong class="bold">docker.io/busybox:latest ls -ld /tmp</strong>
<strong class="bold">drwxrwxrwt    2 root     root          4096 Jan  3 22:44 /tmp</strong></pre></li> <li>We will now review the signatures in these images by executing the <strong class="source-inline">docker trust</strong> <span class="No-Break">command line:</span><pre class="source-code">
<strong class="bold">$ docker trust inspect \</strong>
<strong class="bold">--pretty docker.io/busybox:latest</strong>
<strong class="bold">Signatures for docker.io/busybox:latest</strong>
<strong class="bold">SIGNED TAG   DIGEST</strong>
<strong class="bold">SIGNERS</strong>
<strong class="bold">latest       7b3ccabffc97de872a30dfd234fd972a66d247c8cfc69b0550f276481852627c   (Repo Admin)</strong>
<strong class="bold">Administrative keys for docker.io/busybox:latest</strong>
<strong class="bold">  Repository Key:       02d15c99120886f6e02b4b0186522bc72d21a339ec35fad8af0a1b4a47c871d2</strong>
<strong class="bold">  Root Key:     074cad59e43e13b440b11d1b5521e20aa8633fc8f3928720590268895711d0c6</strong>
<strong class="bold">$ docker trust inspect --pretty docker.io/frjaraur/busybox-untrusted:0.1</strong>
<strong class="bold">No signatures or cannot access docker.io/frjaraur/busybox-untrusted:0.1</strong></pre><p class="list-inset">No signatures are included in <strong class="source-inline">frjaraur/busybox-untrusted:0.1</strong>; hence, this image cannot be used in a container runtime in which Docker Content Trust <span class="No-Break">is enabled.</span></p></li> <li>Let’s start the <a id="_idIndexMarker360"/>signing process by creating a key for our user by using <strong class="source-inline">docker trust </strong><span class="No-Break"><strong class="source-inline">key generate</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">$ docker trust key generate frjaraur</strong>
<strong class="bold">Generating key for frjaraur...</strong>
<strong class="bold">Enter passphrase for new frjaraur key with ID ceb39cd:</strong>
<strong class="bold">Repeat passphrase for new frjaraur key with ID ceb39cd:</strong>
<strong class="bold">Successfully generated and loaded private key. Corresponding public key available: /home/frjaraur/frjaraur.pub</strong></pre><p class="list-inset">Our key is stored <span class="No-Break">under </span><span class="No-Break"><strong class="source-inline">~/.docker/trust/private/</strong></span><span class="No-Break">:</span></p><pre class="source-code"><strong class="bold">$ ls -lart ~/.docker/trust/private/</strong>
<strong class="bold">total 12</strong>
<strong class="bold">drwx------ 4 frjaraur frjaraur 4096 Mar  5 17:43 ..</strong>
<strong class="bold">-rw------- 1 frjaraur frjaraur  420 Mar  5 17:50 ceb39cd48cf78d478ffef211cc9da3e97ff9912ae60585254d6dc661076d0d2a.key</strong>
<strong class="bold">drwx------ 2 frjaraur frjaraur 4096 Mar  5 17:50 .</strong></pre></li> <li>Now, we can <a id="_idIndexMarker361"/>sign our image. We will just retag the original <strong class="source-inline">busybox</strong> image with <strong class="source-inline">docker.io/frjaraur/busybox-trusted:0.1</strong>; hence, both images are the same, but the signature is related to <span class="No-Break">the tag:</span><pre class="source-code">
<strong class="bold">$ docker image tag busybox docker.io/frjaraur/busybox-trusted:0.1</strong>
<strong class="bold">$ docker image push docker.io/frjaraur/busybox-trusted:0.1</strong>
<strong class="bold">The push refers to repository [docker.io/frjaraur/busybox-trusted]</strong>
<strong class="bold">b64792c17e4a: Mounted from frjaraur/busybox</strong>
<strong class="bold">0.1: digest: sha256:907ca53d7e2947e849b839b1cd258c98fd3916c60f2e6e70c30edbf741ab6754 size: 528</strong>
<strong class="bold">Signing and pushing trust metadata</strong>
<strong class="bold">You are about to create a new root signing key passphrase. This passphrase</strong>
<strong class="bold">will be used to protect the most sensitive key in your signing system. Please</strong>
<strong class="bold">choose a long, complex passphrase and be careful to keep the password and the</strong>
<strong class="bold">key file itself secure and backed up. It is highly recommended that you use a</strong>
<strong class="bold">password manager to generate the passphrase and keep it safe. There will be no</strong>
<strong class="bold">way to recover this key. You can find the key in your config directory.</strong>
<strong class="bold">Enter passphrase for new root key with ID dfbeee2:</strong>
<strong class="bold">Repeat passphrase for new root key with ID dfbeee2:</strong>
<strong class="bold">Enter passphrase for new repository key with ID 9cfa33d:</strong>
<strong class="bold">Repeat passphrase for new repository key with ID 9cfa33d:</strong>
<strong class="bold">Finished initializing "docker.io/frjaraur/busybox-trusted"</strong>
<strong class="bold">Successfully signed docker.io/frjaraur/busybox-trusted:0.1</strong></pre><p class="list-inset">During the <a id="_idIndexMarker362"/>signing process, the root key and repository passphrases are requested. Remember that if you lose your root key, you will need to re-sign all your images, and users will need to pull new images because your old signature will <span class="No-Break">be invalid.</span></p><p class="list-inset">We have signed and pushed the image to the Docker Hub registry, but this process can be executed using two steps. We can sign the container image by using <strong class="source-inline">docker trust sign docker.io/frjaraur/busybox-trusted:0.1</strong> and then push it with <strong class="source-inline">docker image </strong><span class="No-Break"><strong class="source-inline">push docker.io/frjaraur/busybox-trusted:0.1</strong></span><span class="No-Break">.</span></p></li> <li>Now, we can easily review our <span class="No-Break">image signature:</span><pre class="source-code">
<strong class="bold">$ docker trust inspect \</strong>
<strong class="bold">--pretty docker.io/frjaraur/busybox-trusted:0.1</strong>
<strong class="bold">Signatures for docker.io/frjaraur/busybox-trusted:0.1</strong>
<strong class="bold">SIGNED TAG   DIGEST                                                             SIGNERS</strong>
<strong class="bold">0.1          907ca53d7e2947e849b839b1cd258c98fd3916c60f2e6e70c30edbf741ab6754   (Repo Admin)</strong>
<strong class="bold">Administrative keys for docker.io/frjaraur/busybox-trusted:0.1</strong>
<strong class="bold">  Repository Key:       9cfa33df6e6b93596416b06bb82198a46befb94479bbf5b0d92e73a213a30126</strong>
<strong class="bold">  Root Key:     f802546452481df2edc8b9670d30638e079164e7dc7187b698cd275d894531f4</strong></pre></li> </ol>
<p>It is important to say here that you will need a registry server with <strong class="bold">Notary</strong>. This project is responsible for managing your signatures. It is a client-server application that runs alongside your <a id="_idIndexMarker363"/>registry to integrate the signing part. Docker Hub already integrates a Notary server with their registry, which is why we are able to integrate our signatures in our <span class="No-Break">image metadata.</span></p>
<p>If you are planning to use a local registry with Content Trust, you will need to also run and integrate a Notary server. You can learn more about Notary <span class="No-Break">at </span><a href="https://github.com/notaryproject/notary"><span class="No-Break">https://github.com/notaryproject/notary</span></a><span class="No-Break">.</span></p>
<p>We can revoke our signatures for a specific container image tag by using <strong class="source-inline">docker trust revoke</strong>. Signatures can be delegated to other users by sharing our public key. The integration of image signatures in your platform really depends on the registries you use. We have learned about the process for Docker Hub, but other solutions may implement different commands and options. We will show you how to use Cosign, which manages a different type of signature, but it also works to implement a good, secure supply chain, ensuring an image’s provenance <span class="No-Break">and ownership.</span></p>
<p>Now that we know how to ensure the uniqueness of container images by using their digests and signatures, we will continue to secure our images by implementing image content <span class="No-Break">vulnerability scanning.</span></p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor090"/>Scanning image content for vulnerabilities</h1>
<p>Container images can be securely stored in registries, and we can track their provenance and ownership <a id="_idIndexMarker364"/>by reviewing their digests and signatures. It would be great if we could trust all the files included in the image layers. There are many solutions that can check whether any of the files included inside the image layers are somehow vulnerable to any reported issues or exploits that can affect your application’s integrity. However, this requires new tools <span class="No-Break">and effort.</span></p>
<p><strong class="bold">Image scanning</strong> can be <a id="_idIndexMarker365"/>implemented in either your local development environment or the remote registries where images are eventually stored and shared. Most content scanners use well-known public and community-supported databases of <a id="_idIndexMarker366"/>known vulnerabilities and exploits. These will give us a list of <strong class="bold">Common Vulnerabilities and Exposures</strong> (<strong class="bold">CVEs</strong>) to compare against our content. Each binary or library in this list is identified by its digest, and it is easy to find out whether a file in our image layers is considered vulnerable in <span class="No-Break">this list.</span></p>
<p>The Docker container runtime scanning facility is integrated into the client command line and can be executed with either images or Dockerfiles, which is very interesting because we can get an overview of possible problems in our images even before they <span class="No-Break">are built.</span></p>
<p>All of Docker Hub’s official images provide a pretty descriptive report of the security scanner results. This is also available for <strong class="bold">verified publisher</strong> (software vendors) and <strong class="bold">sponsored OSS</strong> (open source community-supported projects) images. We can access these reports from the <strong class="bold">Tags</strong> section on any of these images. The following screenshot shows the summary report for each tag <span class="No-Break">in Postgres:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer050">
<img alt="Figure 3.8 – A review of the vulnerabilities for the official Postgres image in Docker Hub" height="653" src="image/B19845_03_08.jpg" width="1555"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – A review of the vulnerabilities for the official Postgres image in Docker Hub</p>
<p>We can deep-dive <a id="_idIndexMarker367"/>by clicking on any tag. This will show us the CVE number associated with the vulnerability detected. The following screenshot shows some CVEs found for <strong class="bold">stdlib 1.18.2</strong>, included in the <strong class="bold">postgres:latest</strong> <span class="No-Break">image layers:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer051">
<img alt="Figure 3.9 – Deep-diving inside the current vulnerabilities in the postgres:latest image" height="781" src="image/B19845_03_09.jpg" width="1527"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – Deep-diving inside the current vulnerabilities in the postgres:latest image</p>
<p>This report gives us a good idea of the health of Docker Hub’s images. It is recommended to always review the scanner report of the official images we will use in <span class="No-Break">our developments.</span></p>
<p>The Docker command-line <a id="_idIndexMarker368"/>scanning implementation uses the <strong class="bold">Snyk engine</strong>. It is accessible by executing <strong class="source-inline">docker scan</strong>. Here is an example of the execution <span class="No-Break">against </span><span class="No-Break"><strong class="bold">postgres:latest</strong></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer052">
<img alt="Figure 3.10 – Using the docker scan facility in our local environment" height="500" src="image/B19845_03_10.jpg" width="781"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10 – Using the docker scan facility in our local environment</p>
<p>In the preceding <a id="_idIndexMarker369"/>screenshot, we used the <strong class="source-inline">–-accept-license</strong> argument to use a non-interactive execution; otherwise, we would be asked to accept the agreement with the Snyk service. We also included <strong class="source-inline">--severity</strong> for filtering and only showed critical vulnerabilities. In this example, Snyk does not show any critical vulnerabilities, which differs from Docker Hub’s website. This may depend on base image scanning. The Snyk scanner only provides 10 scans a month, which probably won’t be enough. You can sign up to increase this limit or even subscribe to their service to increase the features available, avoiding any limitations. In this chapter’s <em class="italic">Labs</em> section, we will learn <a id="_idIndexMarker370"/>how to use another scanning tool, <strong class="bold">Trivy</strong>, which will be executed as a container to avoid any installation in our <span class="No-Break">working environment.</span></p>
<p>We have learned how to work with image registries and ensure security by scanning and signing images. In the next section, we will review some easy labs to put into practice the concepts <span class="No-Break">we’ve discussed.</span></p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor091"/>Labs</h1>
<p>The following labs will provide examples to put into practice the concepts and procedures learned <a id="_idIndexMarker371"/>in this chapter. We will use Docker Desktop as the container runtime and WSL 2 (or your Linux/macOS Terminal) to execute the <span class="No-Break">commands described.</span></p>
<p>The first step for all labs is always to download the most updated version of this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Containers-for-Developers-Handbook.git">https://github.com/PacktPublishing/Containers-for-Developers-Handbook.git</a>. To do this, simply execute <strong class="source-inline">git clone </strong><a href="https://github.com/PacktPublishing/Containers-for-Developers-Handbook.git">https://github.com/PacktPublishing/Containers-for-Developers-Handbook.git</a> to download all its content. If you have already downloaded it before, ensure you have the newest version by executing <strong class="source-inline">git pull</strong> inside <span class="No-Break">the directory.</span></p>
<p>All commands presented in these labs will be executed within the <span class="No-Break"><strong class="source-inline">Containers-for-Developers-Handbook/Chapter3</strong></span><span class="No-Break"> directory.</span></p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor092"/>Deploying and using your own local registry</h2>
<p>In this first lab, we will deploy a simple unauthenticated and untrusted (HTTP, not HTTPS) registry. We will <a id="_idIndexMarker372"/>use the currently available Docker official <a id="_idIndexMarker373"/>registry image, which is <strong class="source-inline">registry:2.8.1</strong> at the time of writing. We can review its vulnerabilities by navigating <span class="No-Break">to </span><a href="https://hub.docker.com/layers/library/registry/2.8.1/images/sha256-a001a2f72038b13c1cbee7cdd2033ac565636b325dfee98d8b9cc4ba749ef337?context=explore"><span class="No-Break">https://hub.docker.com/layers/library/registry/2.8.1/images/sha256-a001a2f72038b13c1cbee7cdd2033ac565636b325dfee98d8b9cc4ba749ef337?context=explore</span></a><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer053">
<img alt="Figure 3.11 – An overview of the official Docker registry:2.8.1 vulnerabilities" height="781" src="image/B19845_03_11.jpg" width="1449"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11 – An overview of the official Docker registry:2.8.1 vulnerabilities</p>
<p>We then <a id="_idIndexMarker374"/>perform <a id="_idIndexMarker375"/>the <span class="No-Break">following steps:</span></p>
<ol>
<li>Pull the <span class="No-Break"><strong class="source-inline">docker.io/registry:2.8.1</strong></span><span class="No-Break"> image:</span><pre class="source-code">
<strong class="bold">$ docker image pull docker.io/registry:2.8.1</strong>
<strong class="bold">...</strong>
<strong class="bold">Digest: sha256:3f71055ad7c41728e381190fee5c4cf9b8f7725839dcf5c0fe3e5e20dc5db1faStatus: Downloaded newer image for registry:2.8.1</strong>
<strong class="bold">docker.io/library/registry:2.8.1</strong></pre></li> <li>Now, review its <strong class="bold">CMD</strong>, <strong class="bold">ENTRYPOINT</strong>, <strong class="bold">VOLUME</strong>, and <strong class="bold">EXPOSE</strong> keys. These will show us which command will be executed, the port that will be used, and which directory will be used for <span class="No-Break">persistent data:</span><pre class="source-code">
<strong class="bold">$ docker image inspect docker.io/registry:2.8.1 \</strong>
<strong class="bold">--format="{{ .Config.Cmd }} {{.Config.Entrypoint }} {{.Config.Volumes }} {{.Config.ExposedPorts }}"</strong>
<strong class="bold">[/etc/docker/registry/config.yml] [/entrypoint.sh] map[/var/lib/registry:{}] map[5000/tcp:{}]</strong></pre><p class="list-inset">Port <strong class="source-inline">5000</strong> will be published, and a custom script will be launched with a configuration file as the argument. The <strong class="source-inline">/var/lib/registry</strong> directory will be used for our images; hence, we will map it to a local folder in <span class="No-Break">this lab.</span></p><p class="list-inset">If you’ve already downloaded this book’s GitHub repository, change to the <strong class="source-inline">Chapter3</strong> folder and follow the next steps from there. If you haven’t, please download the repository to your computer by executing <strong class="source-inline">git clone </strong><a href="https://github.com/PacktPublishing/Containers-for-Developers-Handbook.git">https://github.com/PacktPublishing/Containers-for-Developers-Handbook.git</a>. We will remove the long path in the <span class="No-Break">following prompts.</span></p></li> <li>Create a <a id="_idIndexMarker376"/>directory for registry data, and execute a container <a id="_idIndexMarker377"/>using the registry image <span class="No-Break">pulled previously:</span><pre class="source-code">
<strong class="bold">Chapter3$ mkdir registry-data</strong>
<strong class="bold">Chapter3$ docker container run -P -d \</strong>
<strong class="bold">--name myregstry \</strong>
<strong class="bold">-v $(pwd)/registry-data:/var/lib/registry \</strong>
<strong class="bold">registry:2.8.1</strong></pre><p class="list-inset">This command executed a container in the background, publishing the image’s defined port, <strong class="source-inline">5000</strong>. It also used the directory we created to store all our images, by using <strong class="source-inline">$(pwd)</strong> to get the current directory. Adding volumes to a container requires the use of the directory’s <span class="No-Break">full path.</span></p><p class="list-inset">As we identified our new container as <strong class="source-inline">myregistry</strong>, we can easily review <span class="No-Break">its status:</span></p><pre class="source-code"><strong class="bold">$ docker container ls</strong>
<strong class="bold">CONTAINER ID   IMAGE            COMMAND                  CREATED         STATUS         PORTS                     NAMES</strong>
<strong class="bold">1c7b40ed71d0   registry:2.8.1   "/entrypoint.sh /etc…"   7 minutes ago   Up 7 minutes   0.0.0.0:32768-&gt;5000/tcp   myregistry</strong></pre><p class="list-inset">From this output, we get our host’s port mapped to the container’s port, <strong class="source-inline">5000</strong>. We used <strong class="source-inline">–P</strong> to allow the container runtime to choose any port available to publish the application’s port; therefore, this port may be different in <span class="No-Break">your environment:</span></p><pre class="source-code"><strong class="bold">$ curl -I 0.0.0.0:32768</strong>
<strong class="bold">HTTP/1.1 200 OK</strong>
<strong class="bold">Cache-Control: no-cache</strong>
<strong class="bold">Date: Sat, 11 Mar 2023 09:18:53 GMT</strong></pre><p class="list-inset">We are now <a id="_idIndexMarker378"/>ready to start using this local registry, published <a id="_idIndexMarker379"/>on port <strong class="source-inline">32768</strong> (in my <span class="No-Break">example environment).</span></p></li> <li>Let’s download an <strong class="source-inline">alpine</strong> container image and upload it to our registry. First, we need to pull <span class="No-Break">this image:</span><pre class="source-code">
<strong class="bold">Chapter3$ docker pull alpine</strong>
<strong class="bold">Using default tag: latest</strong>
<strong class="bold">...</strong>
<strong class="bold">Status: Downloaded newer image for alpine:latest</strong>
<strong class="bold">docker.io/library/alpine:latest</strong></pre></li> <li>Now, we retag the image to our repository, published and accessible locally <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">localhost:32768</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">Chapter3$ docker image tag alpine localhost:32768/alpine:0.1</strong></pre></li> <li>We can list the local images before pushing them to the <span class="No-Break">local registry:</span><pre class="source-code">
<strong class="bold">Chapter3$ docker image ls |grep "alpine"</strong>
<strong class="bold">alpine                        latest      b2aa39c304c2   3 weeks ago    7.05MB</strong>
<strong class="bold">localhost:32768/alpine        0.1         b2aa39c304c2   3 weeks ago    7.05MB</strong></pre><p class="list-inset">Both images <a id="_idIndexMarker380"/>are identical; we use a second tag to name the <a id="_idIndexMarker381"/><span class="No-Break">same image.</span></p></li> <li>Now, we push it to our <span class="No-Break"><strong class="source-inline">localhost:32768</strong></span><span class="No-Break"> registry:</span><pre class="source-code">
<strong class="bold">Chapter3$ docker image push localhost:32768/alpine:0.1</strong>
<strong class="bold">The push refers to repository [localhost:32768/alpine]</strong>
<strong class="bold">7cd52847ad77: Pushed</strong>
<strong class="bold">0.1: digest: sha256:e2e16842c9b54d985bf1ef9242a313f36b856181f188de21313820e177002501 size: 528</strong></pre><p class="list-inset">As you can see, everything works as if we were pushing to the Docker Hub registry. The only difference here is that we didn’t have to log in and our registry uses HTTP. We can manage this by adding an NGINX web server as a frontend, behind the <span class="No-Break">registry server.</span></p></li> <li>Let’s now review how images are distributed in <span class="No-Break">our filesystem:</span><pre class="source-code">
<strong class="bold">Chapter3$ ls -lart registry-data/docker/registry/v2/</strong>
<strong class="bold">total 16</strong>
<strong class="bold">drwxr-xr-x 3 root root 4096 Mar  6 19:55 repositories</strong>
<strong class="bold">drwxr-xr-x 3 root root 4096 Mar  6 19:55 ..</strong>
<strong class="bold">drwxr-xr-x 3 root root 4096 Mar  6 19:55 blobs</strong>
<strong class="bold">drwxr-xr-x 4 root root 4096 Mar  6 19:55 .</strong></pre><p class="list-inset">There are two different directories. The <strong class="source-inline">repositories</strong> directory manages the metadata for each image repository, while the <strong class="source-inline">blobs</strong> directory stores all the layers from all <span class="No-Break">container images.</span></p><p class="list-inset">The <strong class="source-inline">blobs</strong> directory is distributed in many other directories to be able to manage an enormous number <span class="No-Break">of layers:</span></p><pre class="source-code"><strong class="bold">Chapter3$ ls -lart registry-data/docker/registry/v2/blobs/sha256/</strong>
<strong class="bold">total 20</strong>
<strong class="bold">drwxr-xr-x 3 root root 4096 Mar  6 19:55 63</strong>
<strong class="bold">drwxr-xr-x 3 root root 4096 Mar  6 19:55 ..</strong>
<strong class="bold">drwxr-xr-x 3 root root 4096 Mar  6 19:55 e2</strong>
<strong class="bold">drwxr-xr-x 3 root root 4096 Mar  6 19:55 b2</strong>
<strong class="bold">drwxr-xr-x 5 root root 4096 Mar  6 19:55 .</strong></pre></li> <li>Now, we will <a id="_idIndexMarker382"/>push a new image into our registry. We again <a id="_idIndexMarker383"/>retag the original <strong class="source-inline">alpine:latest</strong> image <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">localhost:32768/alpine:0.2</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">Chapter3$ docker image tag alpine localhost:32768/alpine:0.2</strong></pre><p class="list-inset">This means that we have a new tag for the original Alpine image; hence, we expect that only metadata should <span class="No-Break">be modified.</span></p></li> <li>Let’s push the image and review the <span class="No-Break">filesystem changes:</span><pre class="source-code">
<strong class="bold">$ docker image push localhost:32768/alpine:0.2</strong>
<strong class="bold">The push refers to repository [localhost:32768/alpine]</strong>
<strong class="bold">7cd52847ad77: Layer already exists</strong>
<strong class="bold">0.2: digest: sha256:e2e16842c9b54d985bf1ef9242a313f36b856181f188de21313820e177002501 size: 528</strong></pre><p class="list-inset">Note that our <strong class="source-inline">localhost:32768</strong> registry says that the image layers <span class="No-Break">already exist.</span></p></li> <li>We can list the content of the <span class="No-Break">registry again:</span><pre class="source-code">
<strong class="bold">Chapter3$ ls -lart registry-data/docker/registry/v2/blobs/sha256/</strong>
<strong class="bold">total 20</strong>
<strong class="bold">drwxr-xr-x 3 root root 4096 Mar  6 19:55 63</strong>
<strong class="bold">drwxr-xr-x 3 root root 4096 Mar  6 19:55 ..</strong>
<strong class="bold">drwxr-xr-x 3 root root 4096 Mar  6 19:55 e2</strong>
<strong class="bold">drwxr-xr-x 3 root root 4096 Mar  6 19:55 b2</strong>
<strong class="bold">drwxr-xr-x 5 root root 4096 Mar  6 19:55 .</strong></pre></li> <li>The <strong class="source-inline">blobs</strong> directory <a id="_idIndexMarker384"/>wasn’t changed, but let’s review <a id="_idIndexMarker385"/>the <strong class="source-inline">repositories</strong> directory, where the image metadata <span class="No-Break">is managed:</span><pre class="source-code">
<strong class="bold">Chapter3$ ls -lart registry-data/docker/registry/v2/repositories/alpine/_manifests/tags/</strong>
<strong class="bold">total 16</strong>
<strong class="bold">drwxr-xr-x 4 root root 4096 Mar  6 19:55 0.1</strong>
<strong class="bold">drwxr-xr-x 4 root root 4096 Mar  6 19:55 ..</strong>
<strong class="bold">drwxr-xr-x 4 root root 4096 Mar  6 19:59 0.2</strong>
<strong class="bold">drwxr-xr-x 4 root root 4096 Mar  6 19:59 .</strong></pre><p class="list-inset">A new folder was created to reference the layers already included inside the <strong class="source-inline">blobs</strong> directory for both tags <strong class="source-inline">0.1</strong> and <strong class="source-inline">0.2</strong>. Let’s now push a new image with <span class="No-Break">some changes.</span></p></li> <li>We will now create a modified version of the original <strong class="source-inline">alpine.latest</strong> image by using it as the base image in a new build process. We will use an on-the-fly build by piping <span class="No-Break">a Dockerfile:</span><pre class="source-code">
<strong class="bold">Chapter3$ cat &lt;&lt;EOF | docker build -t \</strong>
<strong class="bold">localhost:32768/alpine:0.3 -</strong>
<strong class="bold">FROM docker.io/alpine:latest</strong>
<strong class="bold">RUN apk add --update nginx</strong>
<strong class="bold">EXPOSE 80</strong>
<strong class="bold">CMD ["whatever command"]</strong>
<strong class="bold">EOF</strong></pre><p class="list-inset">This is a different <a id="_idIndexMarker386"/>way of building images using a Dockerfile. In this case, we can’t <a id="_idIndexMarker387"/>use the image content, and therefore, copying files wouldn’t work, but it is fine for this example. We create a new image using Unix pipes to avoid the creation of a file. This way, we create an image on <span class="No-Break">the fly:</span></p><pre class="source-code"><strong class="bold">Chapter3$ cat &lt;&lt;EOF | docker build -t \</strong>
<strong class="bold">localhost:32768/alpine:0.3 -</strong>
<strong class="bold">FROM&gt; FROM docker.io/alpine:latest</strong>
<strong class="bold">&gt; RUN apk add --update nginx</strong>
<strong class="bold">&gt; EXPOSE 80</strong>
<strong class="bold">&gt; CMD ["whatever command"]</strong>
<strong class="bold">&gt; EOF</strong>
<strong class="bold">[+] Building 1.3s (6/6) FINISHED</strong>
<strong class="bold">...</strong>
<strong class="bold">=&gt; [1/2] FROM docker.io/library/alpine:latest</strong>
<strong class="bold">0.0s</strong>
<strong class="bold">=&gt; [2/2] RUN apk add --update nginx</strong>
<strong class="bold">1.2s</strong>
<strong class="bold">...</strong>
<strong class="bold">=&gt; =&gt; writing image sha256:e900ec26c76b9d779bc3d6a7f828403db07daea66c85b5271ccd94e12b460ccd                                0.0s</strong>
<strong class="bold">=&gt; =&gt; naming to localhost:32768/alpine:0.3</strong></pre></li> <li>We now push this new image and review <span class="No-Break">the directories:</span><pre class="source-code">
<strong class="bold">Chapter3$ docker push localhost:32768/alpine:0.3</strong>
<strong class="bold">The push refers to repository [localhost:32768/alpine]</strong>
<strong class="bold">33593eed7b41: Pushed</strong>
<strong class="bold">7cd52847ad77: Layer already exists</strong>
<strong class="bold">0.3: digest: sha256:1bf4c7082773b616fd2247ef9758dfec9e3084ff0d23845452a1384a6e715c40 size: 739</strong></pre><p class="list-inset">As you <a id="_idIndexMarker388"/>can see, one new layer <span class="No-Break">is pushed.</span></p></li> <li>Now, we’ll review <a id="_idIndexMarker389"/>the local folders, where the image registry stores data in <span class="No-Break">our host:</span><pre class="source-code">
<strong class="bold">Chapter3$ ls -lart registry-data/docker/\</strong>
<strong class="bold">registry/v2/repositories/alpine/_manifests/tags/</strong>
<strong class="bold">total 20</strong>
<strong class="bold">drwxr-xr-x 4 root root 4096 Mar  6 19:55 0.1</strong>
<strong class="bold">drwxr-xr-x 4 root root 4096 Mar  6 19:55 ..</strong>
<strong class="bold">drwxr-xr-x 4 root root 4096 Mar  6 19:59 0.2</strong>
<strong class="bold">drwxr-xr-x 4 root root 4096 Mar  6 20:08 0.3</strong>
<strong class="bold">drwxr-xr-x 5 root root 4096 Mar  6 20:08 .</strong>
<strong class="bold"> Chapter3$ ls -lart registry-data/docker/registry/v2/blobs/sha256/</strong>
<strong class="bold">total 32</strong>
<strong class="bold">drwxr-xr-x 3 root root 4096 Mar  6 19:55 63</strong>
<strong class="bold">drwxr-xr-x 3 root root 4096 Mar  6 19:55 ..</strong>
<strong class="bold">drwxr-xr-x 3 root root 4096 Mar  6 19:55 e2</strong>
<strong class="bold">drwxr-xr-x 3 root root 4096 Mar  6 19:55 b2</strong>
<strong class="bold">drwxr-xr-x 3 root root 4096 Mar  6 20:08 c1</strong>
<strong class="bold">drwxr-xr-x 3 root root 4096 Mar  6 20:08 e9</strong>
<strong class="bold">drwxr-xr-x 3 root root 4096 Mar  6 20:08 1b</strong>
<strong class="bold">drwxr-xr-x 8 root root 4096 Mar  6 20:08 .</strong></pre><p class="list-inset">As a result of this new push, new folders are created under both the <strong class="source-inline">repositories</strong> and <span class="No-Break"><strong class="source-inline">blobs</strong></span><span class="No-Break"> locations.</span></p></li> </ol>
<p>We have seen <a id="_idIndexMarker390"/>how images are stored and managed inside our registry. Let’s now <a id="_idIndexMarker391"/>move on to a new lab, in which we will review how to sign images with a different <span class="No-Break">tool, </span><span class="No-Break"><strong class="bold">Cosign</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor093"/>Signing images with Cosign</h2>
<p>For this <a id="_idIndexMarker392"/>new lab, we will use a new tool, Cosign, which can <a id="_idIndexMarker393"/>be easily downloaded in <span class="No-Break">different formats:</span></p>
<ol>
<li>We will install Cosign by downloading <span class="No-Break">its binary:</span><pre class="source-code">
<strong class="bold">Chapter3$ mkdir bin</strong>
<strong class="bold">Chapter3$ export PATH=$PATH:$(pwd)/bin</strong>
<strong class="bold">Chapter3$ curl -sL -o bin/cosign https://github.com/sigstore/cosign/releases/download/v2.0.0/cosign-linux-amd64</strong>
<strong class="bold">Chapter3$ chmod 755 bin/*</strong>
<strong class="bold">Chapter3$ cosign --help</strong>
<strong class="bold">A tool for Container Signing, Verification and Storage in an OCI registry.</strong>
<strong class="bold">Usage:</strong>
<strong class="bold">  cosign [command]</strong>
<strong class="bold">…</strong></pre></li> <li>Once installed, we will use Cosign to create our key pair to sign images. We will use <strong class="source-inline">--output-key-prefix</strong> to ensure our keys have an <span class="No-Break">appropriate name:</span><pre class="source-code">
<strong class="bold">Chapter3$ cosign generate-key-pair \</strong>
<strong class="bold">--output-key-prefix frjaraur</strong>
<strong class="bold">Enter password for private key:</strong>
<strong class="bold">Enter password for private key again:</strong>
<strong class="bold">Private key written to frjaraur.key</strong>
<strong class="bold">Public key written to frjaraur.pub</strong></pre><p class="list-inset">Use your <a id="_idIndexMarker394"/>own name for your key. You will be asked for <a id="_idIndexMarker395"/>a password. Use your own, and remember that this will be required to sign any image. This will create your public and <span class="No-Break">private keys:</span></p><pre class="source-code"><strong class="bold">Chapter3$ ls -l</strong>
<strong class="bold">total 12</strong>
<strong class="bold">-rw------- 1 frjaraur frjaraur  649 Mar  7 19:51 frjaraur.key</strong>
<strong class="bold">-rw-r--r-- 1 frjaraur frjaraur  178 Mar  7 19:51 frjaraur.pub</strong></pre></li> <li>We will add a new name and tag to the image, and after that, we will <span class="No-Break">push it:</span><pre class="source-code">
<strong class="bold">Chapter3$ docker tag localhost:32768/alpine:0.3 \</strong>
<strong class="bold">localhost:32768/alpine:0.4-signed</strong>
<strong class="bold">Chapter3$ docker push localhost:32768/alpine:0.4-signed</strong>
<strong class="bold">The push refers to repository [localhost:32768/alpine]</strong>
<strong class="bold">dfdda8f0d335: Pushed</strong>
<strong class="bold">7cd52847ad77: Layer already exists</strong>
<strong class="bold">0.4-signed: digest: sha256:f7ffc0ab458dfa9e474f656afebb4289953bd1196022911f0b4c739705e49956 size: 740</strong></pre></li> <li>Now, we <a id="_idIndexMarker396"/>can proceed <a id="_idIndexMarker397"/>to sign <span class="No-Break">the image:</span><pre class="source-code">
<strong class="bold">Chapter3$ cosign sign --key frjaraur.key \</strong>
<strong class="bold">localhost:32768/alpine:0.4-signed</strong>
<strong class="bold">Enter password for private key:</strong>
<strong class="bold">WARNING: Image reference localhost:32768/alpine:0.4-signed uses a tag, not a digest, to identify the image to sign.</strong>
<strong class="bold">    This can lead you to sign a different image than the intended one. Please use a</strong>
<strong class="bold">    digest (example.com/ubuntu@sha256:abc123...) rather than tag</strong>
<strong class="bold">    (example.com/ubuntu:latest) for the input to cosign. The ability to refer to</strong>
<strong class="bold">    images by tag will be removed in a future release.</strong>
<strong class="bold">        Note that there may be personally identifiable information associated with this signed artifact.</strong>
<strong class="bold">        This may include the email address associated with the account with which you authenticate.</strong>
<strong class="bold">        This information will be used for signing this artifact and will be stored in public transparency logs and cannot be removed later.</strong>
<strong class="bold">By typing 'y', you attest that you grant (or have permission to grant) and agree to have this information stored permanently in transparency logs.</strong>
<strong class="bold">Are you sure you would like to continue? [y/N] y</strong>
<strong class="bold">tlog entry created with index: 14885625</strong>
<strong class="bold">Pushing signature to: localhost:32768/alpine</strong></pre><p class="list-inset">Note the warning message. As we learned in <a href="B19845_02.xhtml#_idTextAnchor036"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Building Docker Images</em>, only the image digest really ensures image uniqueness, and in this example, we use the tags to reference the image we are signing. We should use the digest to <a id="_idIndexMarker398"/>improve the signing process and ensure that <a id="_idIndexMarker399"/>we sign the right image for production, but for this example, we <span class="No-Break">can continue.</span></p></li> <li>We can now verify the signature associated with <span class="No-Break">the image:</span><pre class="source-code">
<strong class="bold">Chapter3$ cosign verify --key frjaraur.pub \</strong>
<strong class="bold">localhost:32768/alpine:0.4-signed</strong>
<strong class="bold">Verification for localhost:32768/alpine:0.4-signed --</strong>
<strong class="bold">The following checks were performed on each of these signatures:</strong>
<strong class="bold">  - The cosign claims were validated</strong>
<strong class="bold">  - Existence of the claims in the transparency log was verified offline</strong>
<strong class="bold">  - The signatures were verified against the specified public key</strong>
<strong class="bold">[{"critical":{"identity":{"docker-reference":"localhost:32768/alpine"},"image":{"docker-manifest-digest":"sha256:f7ffc0ab458dfa9e474f656afebb4289953bd1196022911f0b4c739705e49956"},"type":"cosign container image signature"},"optional":{"Bundle":{"SignedEntryTimestamp":"MEUCIQCFALeoiF8cs6zZjRCFRy//ZFujGalzoVg1ktPYFIhVqAIgI94xz+dCIVIjyAww1SUcDG22X4tjNGfbh4O4d+iSwsA=","Payload":{"body":"eyJhcGlWZXJzaW9uIjoiMC4wLjEiLCJraW5kIjoiaGFzaGVkcmVrb3JkIiwic3BlYyI....RDZz09In19fX0=","integratedTime":1678215719,"logIndex":14885625,"logID":"c0d23d6ad406973f9559f3ba2d1ca01f84147d8ffc5b8445c224f98b9591801d"}}}}]</strong></pre></li> <li>We can use <strong class="source-inline">cosign triangulate</strong> to verify whether an image <span class="No-Break">is signed:</span><pre class="source-code">
<strong class="bold">Chapter3$ cosign triangulate localhost:32768/\</strong>
<strong class="bold">alpine:0.4-signed</strong>
<strong class="bold">localhost:32768/alpine:sha256-f7ffc0ab458dfa9e474f656afebb4289953bd1196022911f0b4c739705e49956.sig</strong></pre><p class="list-inset">This hash is the <span class="No-Break">digest referenced:</span></p><pre class="source-code"><strong class="bold">Chapter3$ docker image ls --digests |grep "0.4-signed"</strong>
<strong class="bold">localhost:32768/alpine        0.4-signed   sha256:f7ffc0ab458dfa9e474f656afebb4289953bd1196022911f0b4c739705e49956   c76f61b74ae4   24 hours ago   164MB</strong></pre></li> <li>Let’s review <a id="_idIndexMarker400"/>what happens if we now remove the signature <a id="_idIndexMarker401"/>by renaming (change name and/or tag) the older original <span class="No-Break"><strong class="source-inline">localhost:32768/alpine:0.3</strong></span><span class="No-Break"> image:</span><pre class="source-code">
<strong class="bold">Chapter3$ docker tag localhost:32768/alpine:0.3 \</strong>
<strong class="bold">localhost:32768/alpine:0.4-signed</strong></pre></li> <li>Now, we push <span class="No-Break">it again:</span><pre class="source-code">
<strong class="bold">Chapter3$ docker push localhost:32768/\</strong>
<strong class="bold">alpine:0.4-signed</strong>
<strong class="bold">The push refers to repository [localhost:32768/alpine]</strong>
<strong class="bold">33593eed7b41: Layer already exists</strong>
<strong class="bold">7cd52847ad77: Layer already exists</strong>
<strong class="bold">0.4-signed: digest: sha256:1bf4c7082773b616fd2247ef9758dfec9e3084ff0d23845452a1384a6e715c40 size: 739</strong></pre></li> <li>We can now verify the newly pushed <span class="No-Break">image again:</span><pre class="source-code">
<strong class="bold">Chapter3$ cosign verify --key frjaraur.pub \</strong>
<strong class="bold">localhost:32768/alpine:0.4-signed</strong>
<strong class="bold">Error: no matching signatures:</strong>
<strong class="bold"> main.go:69: error during command execution: no matching signatures:</strong></pre><p class="list-inset">This means that the new image doesn’t have a signature. We maintained the image repository and tag, but no signature is attached. We changed the image, and this also <a id="_idIndexMarker402"/>changed the signature. Orchestrators such <a id="_idIndexMarker403"/>as Kubernetes can improve application security by validating the image signatures, by executing <strong class="source-inline">ValidatingWebHook</strong>. This will ensure that only signed images (we can also include specific signatures) will be available to <span class="No-Break">create containers.</span></p></li> </ol>
<p>Now that we know how to improve security by signing and verifying their signatures, we can go a step further by using security scanners to review any possible vulnerability in <span class="No-Break">their content.</span></p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor094"/>Improving security by using image content vulnerability scanners</h2>
<p>For this lab, we will use <strong class="bold">Trivy</strong>, from Aquasec. It is a very powerful security scanner for file content, misconfigurations, and even Kubernetes resources. It will really help you in your daily <a id="_idIndexMarker404"/>DevOps tasks as well as as a developer. We will create a custom Trivy image for offline usage by including the online database. With this example, we will also learn how to manage cached content inside <span class="No-Break">our images.</span></p>
<p>Inside the <strong class="source-inline">Chapter3</strong> folder, you will find the <strong class="source-inline">trivy</strong> directory, with a Dockerfile ready for you to build the aforementioned custom image for <span class="No-Break">this lab:</span></p>
<ol>
<li>First, we will verify the digest for the latest stable version of the <strong class="source-inline">docker.io/trivy</strong> image by <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">skopeo</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">Chapter3$ skopeo inspect \</strong>
<strong class="bold">docker://aquasec/trivy:0.38.2-amd64|grep -i digest</strong>
<strong class="bold">    "Digest": "sha256:8038205ca56f2d88b93d804d0407831056ee0e40616cb0b8d74b0770c93aaa9f",</strong></pre></li> <li>We will use this digest to ensure we have the right base image for our custom <strong class="source-inline">trivy</strong> image. We will move inside the <strong class="source-inline">trivy</strong> folder to build our new image. Review <a id="_idIndexMarker405"/>the Dockerfile’s content, and write down the appropriate hash for your <span class="No-Break">base image:</span><pre class="source-code">
FROM aquasec/trivy:0.38.2-amd64@sha256:8038205ca56f2d88b93d804d0407831056ee0e40616cb0b8d74b0770c93aaa9f
LABEL MAINTAINER "frjaraur at github.com"
LABEL TRIVY "0.38.2-amd64"
ENV TRIVY_CACHE_DIR="/cache"  \
    TRIVY_NO_PROGRESS=true
RUN TRIVY_TEMP_DIR=$(mktemp -d) \
  &amp;&amp; trivy --cache-dir $TRIVY_CACHE_DIR image --download-db-only \
  &amp;&amp; tar -cf ./db.tar.gz -C $TRIVY_CACHE_DIR/db metadata.json trivy.db
ENV TRIVY_SKIP_DB_UPDATE=true
RUN chmod 777 -R /cache
USER nobody</pre></li> <li>We will now build <span class="No-Break">our image:</span><pre class="source-code">
<strong class="bold">Chapter3/trivy$ docker build -t \</strong>
<strong class="bold">localhost:32768/trivy:custom-0.38.2 . --no-cache</strong>
<strong class="bold">[+] Building 23.5s (7/7) FINISHED</strong>
<strong class="bold">=&gt; [internal] load build definition from Dockerfile</strong>
<strong class="bold">0.1s</strong>
<strong class="bold">...</strong>
<strong class="bold">=&gt; =&gt; writing image sha256:de8c7b30b715d05ab3167f6c8d66ef47f25603d05b8392ab614e8bb8eb70d4b3             0.1s</strong>
<strong class="bold">=&gt; =&gt; naming to localhost:32768/trivy:custom-0.38.2</strong>
<strong class="bold">0.0s</strong></pre></li> <li>Now, we are ready to run a scan of any image available remotely. We will test our <a id="_idIndexMarker406"/>scanner with the latest <strong class="source-inline">python:alpine</strong> image available in Docker Hub. We will only scan for <span class="No-Break">content vulnerability:</span><pre class="source-code">
<strong class="bold">Chapter3/trivy$ docker run -ti \</strong>
<strong class="bold">localhost:32768/trivy:custom-0.38.2 \</strong>
<strong class="bold">image python:alpine --scanners vuln \</strong>
<strong class="bold">--severity HIGH,CRITICAL</strong>
<strong class="bold">2023-03-08T20:49:21.927Z        INFO    Vulnerability scanning is enabled</strong>
<strong class="bold">2023-03-08T20:49:26.865Z        INFO    Detected OS: alpine</strong>
<strong class="bold">2023-03-08T20:49:26.865Z        INFO    Detecting Alpine vulnerabilities...</strong>
<strong class="bold">2023-03-08T20:49:26.869Z        INFO    Number of language-specific files: 1</strong>
<strong class="bold">2023-03-08T20:49:26.869Z        INFO    Detecting python-pkg vulnerabilities...</strong>
<strong class="bold">python:alpine (alpine 3.17.2)</strong>
<strong class="bold">Total: 1 (HIGH: 1, CRITICAL: 0)</strong>
<strong class="bold">│  Library   │ Vulnerability │ Severity │ Installed Version │ Fixed Version │                           Title                            │</strong>
<strong class="bold">│ libcom_err │ CVE-2022-1304 │ HIGH     │ 1.46.5-r4         │ 1.46.6-r0     │ e2fsprogs: out-of-bounds read/write via crafted filesystem │</strong>
<strong class="bold"> https://avd.aquasec.com/nvd/cve-2022-1304                  │</strong></pre><p class="list-inset">We filtered on <strong class="source-inline">HIGH</strong> and <strong class="source-inline">CRITICAL</strong> severities only to avoid any non-critical output. We used the default table format for the output, but it is possible to use the JSON format, for example, to include the vulnerability scanner in <span class="No-Break">automated tasks.</span></p></li> </ol>
<p>Image <a id="_idIndexMarker407"/>scanning will really help us decide which releases to use, or even fix issues in our images by understanding the vulnerabilities included in our base images. Scanning processes will usually be included in your building pipelines to ensure that your workflow does not produce images with vulnerabilities that can be <span class="No-Break">easily managed.</span></p>
<h1 id="_idParaDest-79"><a id="_idTextAnchor095"/>Summary</h1>
<p>In this chapter, we learned how to store container images in registries, using appropriate repositories and tags for our application components. You, as a developer, must provide the logic names, tags, and required information to your images to allow users to run your applications correctly. Labels will also allow you to include any relevant information that can help you track code changes and how they apply to your <span class="No-Break">application’s processes.</span></p>
<p>In addition, it is critical to ensure a secure supply chain for our image artifacts. We learned that digests provide uniqueness, but that is not enough. We can include signatures to inform users about the provenance and ownership of the images we create, but signing does not guarantee the health of the files included inside our image layers. We will include content vulnerability scanning in our build process. This will allow us to review and verify whether the images we use to create our projects contain any security problems. Knowing the vulnerabilities in our images will help us to improve our application life cycle. Although fixing all vulnerabilities can be hard or even impossible, it is key to understand the possible issues we have to manage in <span class="No-Break">our projects.</span></p>
<p>Now that we have a good base to create and share our application images, using the best techniques and improved security, it’s time to move on to the next chapter, in which we will learn how to run software containers and the command line for different features and <span class="No-Break">container runtimes.</span></p>
</div>
</div></body></html>