- en: Writing Your First Manifests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuration management has become essential to the IT world. Faster development
    using agile methods has a huge impact on IT operations that need to keep pace
    with the faster deployment of systems. Server operations in general are hardly
    even feasible without a robust management infrastructure. Among the available
    tools, Puppet has established itself as one of the most popular and widespread
    solutions. Originally written by Luke Kanies, the tool is now distributed under
    the terms of Apache License 2.0 and maintained by Luke's company, Puppet Inc.
    It boasts a large and bustling community, rich APIs for plugins and supporting
    tools, outstanding online documentation, and a great security model based on SSL
    authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Like all configuration management systems, Puppet allows you to maintain a central
    repository of infrastructure definitions, along with a toolchain to enforce the
    desired state on the systems under management. The whole feature set is quite
    impressive. This book will guide you through some steps to quickly grasp the most
    important aspects and principles of Puppet.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing resources, parameters, and properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpreting the output of the `puppet apply` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding control structures in manifests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the order of execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing resource interaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining Puppet core resource types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installing Puppet is easy. On large Linux distributions, you can just install
    the Puppet package via `apt-get` or `yum`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The installation of Puppet can be done in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: From default operating system repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From Puppet Inc
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The former way is generally simpler. [Chapter 2](7cafeeab-0e5c-4848-9eb0-1bae38ed3525.xhtml),
    *Puppet Server and Agents*, provides simple instructions to install the Puppet
    Inc packages. A platform-independent way to install Puppet is to get the `puppet`
    Ruby gem. This is fine for testing and managing single systems, but it is not
    recommended for production use.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing Puppet, you can use it right away. Puppet is driven by manifests,
    the equivalent of scripts or programs, written in Puppet''s **Domain-Specific
    Language** (**DSL**). Let''s start with the obligatory `Hello, world!` manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Downloading the example code:'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all the Packt Publishing books you
    have purchased from your account at [http://www.packtpub.com](http://www.packtpub.com).
    If you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register yourself to have the files emailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'To put the manifest to work, use the following command (we avoided the term
    `execute` on purpose-manifests cannot be executed; more details will follow around
    the middle of this chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The package from Puppet Inc. bundles all required software components and installs
    to `/opt/puppetlabs`. In the case that the puppet command cannot be found, you
    can either specify the full path (`/opt/puppetlabs/bin/puppet`) or you can refresh
    your shell environment (`exec` bash, or log out and log in again).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we take a look at the structure of the manifest and the output from
    the `puppet apply` command, let''s do something useful, just as an example. Puppet
    comes with its own background service. Let''s assume that you want to learn the
    basics before letting it mess with your system. You can write a manifest to have
    Puppet make sure that the service is not currently running and will not be started
    at system boot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To control system processes, boot options, software installation, and the same
    as the Puppet needs to be run with `root` privileges. This is the most common
    way to invoke the tool, because Puppet will often manage OS-level facilities.
    Apply your new manifest with root access, either through `sudo` or from a root
    shell, as shown in the following transcript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, Puppet has disabled the automatic startup of its background service for
    you. Applying the same manifest again has no effect, because the necessary steps
    are already complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This reflects a standard behavior in Puppet: Puppet resources are **idempotent**,
    which means that every resource first compares the actual (system) with the desired
    (Puppet) state and only initiates actions in case there is a difference (configuration
    drift).'
  prefs: []
  type: TYPE_NORMAL
- en: You will often get this output from Puppet. It tells you that everything is
    as it should be. As such, this is a desirable outcome, like the all clean output
    from git status.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing resources, parameters, and properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each of the manifests you wrote in the previous section declared one respective
    resource. Resources are the elementary building blocks of manifests. Each has
    a type (in this case, `notify` and `service`, respectively) and a name or title
    (`Hello, world!` and `puppet`). Each resource is unique to a manifest, and can
    be referenced by the combination of its type and name, such as `Service["puppet"]`.
    Finally, a resource also comprises a list of zero or more attributes. An attribute
    is a key-value pair, such as `"enable => false"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Attribute names cannot be chosen arbitrarily. They are part of the Puppet resource
    type. Puppet differentiates between two different attributes: parameters and properties.
    Each resource type supports a specific set of attributes. Parameters describe
    the way that Puppet should deal with a resource type. Properties describe a specific
    setting of a resource. Certain parameters are available for all resource types
    (metaparameters), and some names are just very common, such as `ensure`. The `service`
    type supports the `ensure` property, which represents the status of the managed
    process. Its `enabled` property, on the other hand, relates to the system boot
    configuration (with respect to the service in question).'
  prefs: []
  type: TYPE_NORMAL
- en: We have used the terms attribute, property, and parameter in a seemingly interchangeable
    fashion. Don't be deceived-there are important distinctions. Property and parameter
    are the two different kinds of attributes that Puppet uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have already seen two properties in action. Let''s look at a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `provider` parameter tells Puppet that it needs to interact with the `upstart`
    subsystem to control its background service, as opposed to `systemd` or `init`.
    If you don't specify this parameter, Puppet makes an educated guess. There is
    quite a multitude of supported facilities to manage services on a system. You
    will learn more about providers and their automatic choosing later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference between parameters and properties is that the parameter merely
    indicates how Puppet should manage the resource, not what a desired state is.
    Puppet will only take action on property values. In this example, these are `ensure
    => ''stopped''` and `enable => false`. For each such property, Puppet will perform
    the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Test whether the resource is already in sync with the target state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the resource is not in sync, it will trigger a sync action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A property is considered to be in sync when the system entity that is managed
    by the given resource (in this case, the `upstart` service configuration for Puppet)
    is in the state that is described by the property value in the manifest. In this
    example, the `ensure` property will be in sync only if the `puppet` service is
    not running. The `enable` property is in sync if `upstart` is not configured to
    launch Puppet at system start.
  prefs: []
  type: TYPE_NORMAL
- en: As a mnemonic concerning parameters versus properties, just remember that properties
    can be out of sync, whereas parameters cannot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Puppet also allows you to read your existing system state by using the puppet
    resource command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Please note that some resource types will return read-only attributes (for example,
    the file resource type will return `mtime` and `ctime`). Refer to the appropriate
    type's documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreting output of the puppet apply command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you have already witnessed, the output presented by Puppet is rather verbose.
    As you get more experienced with the tool, you will quickly learn to spot the
    crucial pieces of information. Let''s first take a look at the informational messages,
    though. Apply the `service.pp` manifest once more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Puppet took no particular action. You only get two timings: one from the compiling
    phase of the manifest, and the other from the catalog application phase. The catalog
    is a comprehensive representation of a compiled manifest. Puppet bases all its
    efforts concerning the evaluation and syncing of resources on the content of its
    current catalog.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to quickly force Puppet to show you some more interesting output, pass
    it a one-line manifest directly from the shell. Regular users of Ruby or Perl
    will recognize the call syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We prefer double quotes in manifests that get passed as command-line arguments,
    because on the shell, the manifest should be enclosed in single quotes as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: 'You instructed Puppet to perform yet another change on the Puppet service.
    The output reflects the exact change that was performed. Let''s analyze this log
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Notice:` keyword at the beginning of the line represents the log level.
    Other levels include `Warning`, `Error`, and `Debug`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The property that changed is referenced with a whole path, starting with `Stage[main]`.
    Stages are beyond the scope of this book, so you will always just see the default
    of `main` here
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next path element is `Main`, which is another default. It denotes the class
    in which the resource was declared. You will learn about classes in [Chapter 4](daf11a18-5de2-4c3c-9880-e9a242ffb35b.xhtml),
    *Combining Resources in Classes and Defined Types*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, is the resource. You already learned that `Service[puppet]` is its unique
    reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, `enable` is the name of the property in question. When several properties
    are out of sync, there will usually be one line of output for each property that
    gets synchronized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the log line indicates the type of change that Puppet saw fit to
    apply. The wording depends on the nature of the property. It can be as simple
    as `created`, for a resource that is newly added to the managed system, or a short
    phrase, such as `changed false to true`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dry testing your manifest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another useful command-line switch for `puppet apply` is the `--noop` option.
  prefs: []
  type: TYPE_NORMAL
- en: It instructs Puppet to refrain from taking any action on unsynced resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, you only get a log output that indicates what will change without
    the switch. This is useful in determining whether a manifest would possibly break
    anything on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The output format is the same as before, with a (`noop`) marker trailing the
    notice about the sync action. This log can be considered a preview of what will
    happen when the manifest is applied without the `--noop` switch.
  prefs: []
  type: TYPE_NORMAL
- en: The additional notices about triggered refreshes will be described later, and
    can be ignored for the moment. You will have a better understanding of their significance
    after finishing this chapter and [Chapter 4](daf11a18-5de2-4c3c-9880-e9a242ffb35b.xhtml),
    *Combining Resources in Classes and Defined Types.*
  prefs: []
  type: TYPE_NORMAL
- en: Using variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Variable assignment works just like it does in most scripting languages. Any
    variable name is always prefixed with the `$` sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Also, just like most scripting languages, Puppet performs variable value substitution
    in strings that are in double quotes, but no interpolation at all in single-quoted
    strings.
  prefs: []
  type: TYPE_NORMAL
- en: Variables are useful for making your manifest more concise and comprehensible.
    They help you with the overall goal of keeping your source code free from redundancy.
    An important distinction from variables in imperative programming and scripting
    languages is the immutability of variables in Puppet manifests. Once a value has
    been assigned, it cannot be overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: Why is it called a variable at all if it is a constant? One should never look
    at Puppet as a tool that manages a single system. For a single system, a Puppet
    variable might look like a constant, but Puppet manages a multitude of systems
    with different operating systems. Across all these systems, variables will be
    different and not constants.
  prefs: []
  type: TYPE_NORMAL
- en: Variable types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As of Puppet 3.x, there are only four variable types: strings, arrays, hashes,
    and Booleans. Puppet 4 introduces a rich data type system. The new data type system
    will be explained at the end of, [Chapter 7](b38488ca-86a7-4ecf-9a69-16938576d852.xhtml),
    *New Features from Puppet 4 and 5*. The basic variable types work much like their
    respective counterparts in other languages. Depending on your background, you
    might be familiar with using associative arrays or dictionaries as semantic equivalents
    to Puppet''s hash type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Accessing the values is equally simple. Note that the `hash` syntax is similar
    to that of Ruby, not Perl:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Strings can be used as resource attribute values, but it''s worth noting that
    a resource title can also be a variable reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s intuitively clear what a string value means in this context. But you
    can also pass arrays here to declare a whole set of resources in one statement.
    The following manifest manages three packages, making sure that they are all installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You will learn how to make efficient use of hash values in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The array does not need to be stored in a variable to be used, but it is a good
    practice in some cases.
  prefs: []
  type: TYPE_NORMAL
- en: Data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data type system in Puppet 4 allows you to check and verify whether a variable
    is of a specific data type. This prevents code from behaving incorrectly when
    (for example) it expects an array but receives a Boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: The full power of data types will be explained in [Chapter 7](b38488ca-86a7-4ecf-9a69-16938576d852.xhtml),
    *New Features from Puppet 4 and 5*. Within Puppet manifests, it is possible to
    check for data types using the regexp control structure.
  prefs: []
  type: TYPE_NORMAL
- en: Puppet has core data types and abstract data types. The core data types are
    the most commonly used types of data, such as string or integer, whereas abstract
    data types allow for more sophisticated type validation, such as optional or variant.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to dealing with data types, we must understand the concept of control
    structures within Puppet manifests.
  prefs: []
  type: TYPE_NORMAL
- en: Adding control structures in manifests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you have written three simple manifests while following the instructions
    in this chapter. Each comprised only one resource, and one of them was given on
    the command line using the `-e` option. Of course, you would not want to write
    distinct manifests for each possible circumstance. Instead, just as how Ruby or
    Perl scripts branch out into different code paths, there are structures that make
    your Puppet code flexible and reusable for different circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common control element is the `if`/`else` block. It is quite similar
    to its equivalents in many programming languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The Puppet DSL also has a `case` statement, which is reminiscent of its counterparts
    in other languages as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: At the second matcher, you can see how it is possible to use regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The case statement can also be used to switch to specific code based on variable
    data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'A variation of the `case` statement is the selector. It''s an expression, not
    a statement, and can be used in a fashion similar to the ternary `if`/`else` operator
    found in C-like languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the case statement, the selector can also be used to return results,
    depending on the data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The selector should be used with caution, because in more complex manifests,
    this syntax will impede readability.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the order of execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With what you've seen this far, you might have got the impression that Puppet's
    DSL is a specialized scripting language. That is actually quite far from the truth.
    A manifest is not a script or program. The language is a tool to model a system
    state through a set of resources, including files, packages, and cron jobs, among
    others.
  prefs: []
  type: TYPE_NORMAL
- en: The whole paradigm is different from that of scripting languages. Ruby or Perl
    are imperative languages that are based around statements that will be evaluated
    in a strict order. The Puppet DSL is declarative, which means that the manifest
    declares a set of resources that are expected to have certain properties. These
    resources are put into a catalog, and Puppet then tries to build a path through
    all declared resources. The compiler parses the manifests in order, but the configurer
    applies resources in a very different way.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, the manifests should always describe what you expect to be the
    end result. The specifics of what actions need to be taken to get there are decided
    by Puppet.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this distinction more clear, let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'With this manifest, Puppet will make sure that the following state is reached:'
  prefs: []
  type: TYPE_NORMAL
- en: The `HAproxy` package is installed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `haproxy.cfg` file has specific content, which has been prepared in a file
    in `/etc/puppet/modules/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`HAproxy` is started.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To make this work, it is important that the necessary steps are performed in
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: A configuration file cannot usually be installed before the package because
    there is not yet a directory to contain it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The service cannot start before installation either. If it becomes active before
    the configuration is in place, it will use the default settings from the package
    instead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This point is being stressed because the preceding manifest does not, in fact,
    contain cues for Puppet to indicate such a strict ordering. Without explicit dependencies,
    Puppet is free to put the resources in any order it sees fit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recent versions of Puppet allow a form of local manifest-based ordering,
    so the presented example will actually work as is. The manifest-based ordering
    can be configured in the `puppet.conf` configuration file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This setting is default for Puppet 4\. It is still important to be aware of
    the ordering principles because the implicit order is difficult to determine in
    more complex manifests, and as you will learn soon, there are other factors that
    will influence the order.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The easiest way to bring order to such a straightforward manifest is resource
    chaining. The syntax for this is a simple ASCII arrow between two resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is only viable if all the related resources can be written next to each
    other. In other words, if the graphic representation of the dependencies does
    not form a straight chain, but more of a tree, star, or any other shape, this
    syntax is not sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, Puppet *will* construct an ordered graph of resources and synchronize
    them during a traversal of that graph.
  prefs: []
  type: TYPE_NORMAL
- en: A more generic and flexible way to declare dependencies is through special metaparameters-parameters
    that are eligible for use with any resource type. There are different metaparameters,
    most of which have nothing to do with ordering (you have seen `provider` in an
    earlier example). For resource ordering, Puppet offers the metaparameters require
    and before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both take one or more references to a declared resource as their value. As
    was previously mentioned, Puppet references have a special syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can only build references to resources that are declared in the catalog.
    You cannot build and use references to something that is not managed by Puppet,
    even when it exists on the managed system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `HAproxy` manifest, ordered using the `require` metaparameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following manifest is semantically identical, but relies on the `before`
    metaparameter rather than `require`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The manifest can also mix both styles of notation, of course. This is left as
    a reader exercise with no dedicated depiction.
  prefs: []
  type: TYPE_NORMAL
- en: The `require` metaparameter usually leads to more understandable code because
    it expresses the dependency of the annotated resource on another resource. The
    `before` parameter, on the other hand, implies a dependency that a referenced
    resource forms upon the current resource. This can be counter-intuitive, especially
    for frequent users of packaging systems (which usually implement a `require`-style
    dependency declaration).
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, it might be difficult to decide whether to use `require` or `before`.
    In simple cases, most people prefer `require`. In some cases, it is easier to
    use `before`. Think of services that have multiple configuration files. Keeping
    information about the configuration file and the requirement in a single place
    reduces errors caused by forgetting to also adopt changes to the service when
    adding or removing additional configuration files. Take a look at the following
    example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the example, all dependencies are declared within the file resource declarations.
    If you use the require parameter instead, you will always need to touch at least
    two resources in case of changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Will you remember to update the service resource declaration whenever you add
    a new file to be managed by Puppet? Consider another, simpler example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The file in the `preferences.d` directory only makes sense for Debian-like systems;
    that's why the package cannot safely `require` it. If the manifest is applied
    on a different OS, such as CentOS, the `apt` preferences file will not appear
    in the catalog thanks to the `if` clause. If the package had it as a requirement
    regardless, the resulting catalog would be inconsistent, and Puppet would not
    apply it. Specifying `before` in the file resource is safe, and semantically equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: The `before` metaparameter is outright necessary in situations like this one,
    and can make the manifest code more elegant and straightforward in other scenarios.
    Familiarity with both `before` and `require` is advisable.
  prefs: []
  type: TYPE_NORMAL
- en: Error propagation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Defining requirements serves another important purpose. References on declared
    resources will only be validated as successful references if the depended-upon
    resource was finished successfully. This can be seen as a kind of stop point inside
    Puppet DSL code, when a required resource is not synchronized successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a `file` resource will fail if the URL of the `source` file is
    broken:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'One path segment is missing here. Puppet will report that the file resource
    could not be synchronized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `Error` line describes the error caused by the broken URL.
    The error propagation is represented by the `Notice` and `Warning` lines below
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Puppet failed to apply changes to the configuration file; it cannot compare
    the current state to the nonexistent source. As the service depends on the configuration
    file, Puppet will not even try to start it. This is for safety: if any dependencies
    cannot be put into the defined state, Puppet must assume that the system is not
    fit for the application of the dependent resource.'
  prefs: []
  type: TYPE_NORMAL
- en: This is another important reason to make use of resource dependencies. Remember
    that both the chaining arrow and the `before` metaparameter imply error propagation
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding circular dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you learn about another way in which resources can interrelate, there
    is an issue that you should be aware of: dependencies must not form circles. Let''s
    visualize this in an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The dependency circle in this manifest is somewhat hidden (as will likely be
    the case for many such circles that you will encounter during regular use of Puppet).
  prefs: []
  type: TYPE_NORMAL
- en: 'It is formed by the following relations:'
  prefs: []
  type: TYPE_NORMAL
- en: The `File['/etc/haproxy/haproxy.cfg']` auto-requires the parent directory, `File['/etc/haproxy']`.
    This is an implicit, built-in dependency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parent directory, `File['/etc/haproxy']`, requires `Service['haproxy']`
    due to its `before` metaparameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Service['haproxy']` service requires the `File['/etc/haproxy/haproxy.cfg']`
    config
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implicit dependencies exist for the following resource combinations, among
    others:'
  prefs: []
  type: TYPE_NORMAL
- en: If a directory and a file inside the `directory` are declared, Puppet will first
    create the `directory` and then the file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a user and his/her primary group is declared, Puppet will first create the
    group and then the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a file and the owner (user) are declared, Puppet will first create the user
    and then the file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Granted, the preceding example is contrived-it will not make sense to manage
    the service before the configuration directory. Nevertheless, even a manifest
    design that is apparently sound can result in circular dependencies. This is how
    Puppet will react to such a design:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The output helps you locate the offending relation(s). For very wide dependency
    circles with lots of involved resources, the textual rendering is difficult to
    analyze. Therefore, Puppet also gives you the opportunity to get a graphical representation
    of the dependency graph through the `--graph` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do this, Puppet will include the full path to the newly created `.dot`
    file in its output. Its content looks similar to Puppet''s output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This is not helpful by itself, but it can be fed directly into tools such as
    `dotty` to produce an actual diagram.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, resource dependencies are helpful in keeping Puppet from acting
    upon resources in unexpected or uncontrolled situations. They are also useful
    in restricting the order of resource evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing resource interaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to dependencies, resources can also enter a similar yet different
    mutual relation. Remember the pieces of output that we skipped earlier. They are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Puppet mentions that **refreshes** would have been triggered for the reason
    of an **event**. Such events are emitted by resources whenever Puppet acts on
    the need for a sync action. Without explicit code to receive and react to events,
    they just get discarded.
  prefs: []
  type: TYPE_NORMAL
- en: The mechanism to set up such event receivers is named in an analogy of a generic
    publish/subscribe queue; resources get configured to react to events using the
    `subscribe` metaparameter. There is no `publish` keyword or parameter, since each
    and every resource is technically a publisher of events (messages). Instead, the
    counterpart of the `subscribe` metaparameter is called `notify`, and it explicitly
    directs generated events at referenced resources.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common practical uses of the event system is to reload service
    configurations. When a `service` resource consumes an event (usually from a change
    in a config file), Puppet invokes the appropriate action to make the service restart.
  prefs: []
  type: TYPE_NORMAL
- en: If you instruct Puppet to do this, it can result in brief service interruptions
    due to this restart operation. Note that if the new configuration causes an error,
    the service might fail to start and stay offline.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code example shows the relationships between the `haproxy` package,
    the corresponding `haproxy` configuration file, and the `haproxy` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `notify` metaparameter is to be used instead, it must be specified for
    the resource that emits the event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This will likely feel reminiscent of the `before` and `require` metaparameters,
    which offer symmetrical ways of expressing an interrelation of a pair of resources
    just as well. This is not a coincidence, these metaparameters are closely related
    to each other:'
  prefs: []
  type: TYPE_NORMAL
- en: The resource that subscribes to another resource implicitly requires it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resource that notifies another is implicitly placed before the later one
    in the dependency graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other words, `subscribe` is the same as `require`, except for the dependent
    resource receiving events from its peer. The same holds true for `notify` and
    `before`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chaining syntax is also available for signaling. To establish a signaling
    relation between neighboring resources, use an ASCII arrow with a tilde, `~>`,
    instead of the dash in `->`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `service` resource type is one of the two notable types that support refreshing
    when resources get notified (the other will be discussed in the next section).
    There are others, but they are not as ubiquitous.
  prefs: []
  type: TYPE_NORMAL
- en: Examining Puppet core resource types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete our tour of the basic elements of a manifest, let's take a closer
    look at the resource types that you have already used, and some of the more important
    ones that you have not yet encountered and are part of Puppet's base installation.
  prefs: []
  type: TYPE_NORMAL
- en: You probably already have a good feeling for the `file` type, which will ensure
    the existence of files and directories, along with their permissions. Pulling
    a file from a repository (usually, a Puppet module) using the `source` parameter
    is also a frequent use case.
  prefs: []
  type: TYPE_NORMAL
- en: 'For very short files, it is more economical to include the desired content
    right in the manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The double quotes allow expansion of escape sequences, such as `\n`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful capability is managing symbolic links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be aware that the file resource type requires an absolute path and
    filename. If a relative path is used within the title, then Puppet will produce
    an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The next type that you already know is `package`, and its typical usage is
    quite intuitive. Make sure that packages are either installed or removed. A notable
    use case that you have not yet seen is to use the basic package manager instead
    of `apt` or `yum/zypper`. This is useful if the package is not available from
    a repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Your mileage usually increases if you make the effort of setting up a simple
    repository instead, so that the main package manager can be used after all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least, there is a `service` type, the most important attributes
    of which you already know. It''s worth pointing out that it can serve as a simple
    shortcut in cases where you don''t wish to add a fully-fledged `init` script or
    something similar. With enough information, the `base` provider for the `service`
    type will manage simple background processes for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Puppet will not only restart the script if it is not running for some reason,
    but will also restart it whenever the content of the referenced configuration
    file changes.
  prefs: []
  type: TYPE_NORMAL
- en: This only works if Puppet manages the file content and all changes propagate
    through Puppet only.
  prefs: []
  type: TYPE_NORMAL
- en: If Puppet changes any other property of the script file (for example, the file
    mode), that too will lead to a restart of the process.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at some other types you will probably need.
  prefs: []
  type: TYPE_NORMAL
- en: The user and group types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Especially in the absence of central registries, such as LDAP, it is useful
    to be able to manage user accounts on each of your machines. There are providers
    for all supported platforms; however, the available attributes vary. On Linux,
    the `useradd` provider is the most common. It allows the management of all fields
    in `/etc/passwd`, such as `uid` and `shell`, and also group memberships:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As with all resources, Puppet will not only make sure that the user and group
    exist, but also fix any divergent properties, such as the `home` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though the user depends on the group: (because it cannot be added before
    the group exists), it need not be expressed in the manifest. The user automatically
    requires all necessary groups, similar to a file auto-requiring its parent directory.'
  prefs: []
  type: TYPE_NORMAL
- en: Puppet will also happily manage your LDAP user accounts.
  prefs: []
  type: TYPE_NORMAL
- en: It was mentioned earlier that there are different attributes available, depending
    on the operating system. Linux (and the `useradd` provider) support setting a
    password, whereas on HP-UX (using the `hp-ux` provider), the user password cannot
    be set via Puppet.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, Puppet will only show a warning saying that the user resource
    type is making use of an unsupported attribute, and will continue managing all
    other attributes. In other words, using an unsupported attribute in your Puppet
    DSL code will not break your Puppet run.
  prefs: []
  type: TYPE_NORMAL
- en: The exec resource type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is one oddball resource type in the Puppet core. Remember our earlier
    assertion that Puppet is not a specialized scripting engine, but a tool that allows
    you to model part of your system state in a compelling DSL, and which is capable
    of altering your system to meet the defined goal. This is why you declare `user`
    and `group`, instead of invoking `groupadd` and `useradd` in order. You can do
    this because Puppet comes with support to manage such entities. This is vastly
    beneficial because Puppet also knows that, on different platforms, other commands
    are used for account management, and that the arguments can be subtly different
    on some systems.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, Puppet does not have knowledge of all the conceivable particulars
    of any supported system. Say that you wish to manage an OpenAFS file server. There
    are no specific resource types to aid you with this. The ideal solution is to
    exploit Puppet's plugin system and to write your own types and providers so that
    your manifests can just reflect the AFS-specific configuration. This is not simple,
    though, and also not worthwhile in cases where you only need Puppet to invoke
    some exotic commands from very few places in your manifest.
  prefs: []
  type: TYPE_NORMAL
- en: For such cases, Puppet ships with the `exec` resource type, which allows the
    execution of custom commands in lieu of an abstract sync action.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, it can be used to unpack a tar ball in the absence of a proper
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `creates` parameter is important for Puppet to tell whether the command
    needs running. Once the specified path exists, the resource counts as synchronized.
    For commands that do not create a telltale file or directory, there are the alternative
    parameters, `onlyif` and `unless`, to allow Puppet to query the sync state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The query command's exit code determines the state. In the case of `unless`,
    the `exec` command runs if the query fails. This is how the `exec` type maintains
    idempotency. Puppet does this automatically for most resource types, but this
    is not possible for `exec` because synchronization is defined so arbitrarily.
    It becomes your responsibility as the user to define the appropriate queries per
    resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `exec` type resources are the second notable case of receivers
    for events using `notify` and `subscribe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: You can even chain multiple `exec` resources in this fashion so that each invocation
    triggers the next one. However, this is bad practice, and degrades Puppet to a
    (rather flawed) scripting engine. The `exec` resources should be avoided in favor
    of regular resources whenever possible. Some resource types that are not part
    of the core are available as plugins from the Puppet Forge. You will learn more
    about this topic in [Chapter 5](3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml), *Combining
    Classes, Configuration Files, and Extensions into Modules*.
  prefs: []
  type: TYPE_NORMAL
- en: Since `exec` resources can be used to perform virtually *any* operation, they
    are sometimes abused to stand in for more proper resource types. This is a typical
    antipattern in Puppet manifests. It is safer to regard `exec` resources as the
    last resort or emergency exit that is only to be used if all other alternatives
    have been exhausted.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, your `exec` resource types are built as one-time only commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'All Puppet installations have the type documentation built into the code, which
    is printable on the command line by using the puppet describe command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`puppet describe <type> [-s]`** In case you are unsure whether a type exists,
    you can tell puppet describe to return a full list of all available resource types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**puppet describe --list**`'
  prefs: []
  type: TYPE_NORMAL
- en: Let's briefly discuss two more types that are supported out of the box. They
    allow the management of cron jobs, mounted partitions, and shares respectively,
    which are all frequent requirements in server operations.
  prefs: []
  type: TYPE_NORMAL
- en: The cron resource type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A cron job mainly consists of a command and the recurring time and date at
    which to run the command. Puppet models the command and each date particle as
    a property of a resource with the `cron` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `environment` property allows you to specify one or more variable bindings
    for `cron` to add to the job.
  prefs: []
  type: TYPE_NORMAL
- en: The mount resource type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, Puppet will manage all aspects of mountable filesystems for you, including
    their basic attributes, such as the source device and mount point, the mount options,
    and the current state. A line from the `fstab` file translates quite literally
    to a Puppet manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: For this resource, Puppet will make sure that the filesystem is indeed mounted
    after the run. Ensuring the `unmounted` state is also possible, of course; Puppet
    can also just make sure the entry is `present` in the `fstab` file, or `absent`
    from the system altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After installing Puppet on your system, you can use it by writing and applying
    manifests. These manifests are written in Puppet's DSL and contain descriptions
    of the desired state of your system. Even though they resemble scripts, they should
    not be considered as such. For one thing, they consist of resources instead of
    commands. These resources are generally not evaluated in the order in which they
    have been written. An explicit ordering should be defined through the `require`
    and `before` metaparameters instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each resource has a couple of attributes: `parameters` and `properties`. Each
    property is evaluated in its own right; Puppet detects whether a change to the
    system is necessary to get any property into the state that is defined in the
    manifest. It will also perform such changes. This is referred to as synchronizing
    a resource or property.'
  prefs: []
  type: TYPE_NORMAL
- en: The ordering parameters, `require` and `before`, are of further importance because
    they establish dependency of one resource on one or more others. This allows Puppet
    to skip parts of the catalog if an important resource cannot be synchronized.
    Circular dependencies must be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Each resource in the manifest has a resource type that describes the nature
    of the system entity that is being managed. Some of the types that are used most
    frequently are file, package, and service. Puppet comes with many types for convenient
    system management, and many plugins are available to add even more. Some tasks
    require the use of `exec` resources, but this should be done sparingly.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](7cafeeab-0e5c-4848-9eb0-1bae38ed3525.xhtml), *Puppet Server and
    Agents*, we will introduce the master/agent setup.
  prefs: []
  type: TYPE_NORMAL
