<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Mobile Notifications with Notification Hub</h1>
                </header>
            
            <article>
                
<p>Push notifications are one of the main features of many mobile apps. They facilitate informing a user about a wait for action, or maybe about a temporary discount that is available only for minutes within an application. While each mobile OS vendor has its own service for such notifications, it's always nice to configure such a feature in one place, so we don't have to worry about changes in the underlying API or the parameters required. Azure Notification Hub simplifies things greatly by providing a single service that acts as a single endpoint for our mobile applications, easing both development and testing.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Notification Hub and its benefits</li>
<li>Notification architecture and the best patterns for sending a notification to mobile apps</li>
<li style="font-weight: 400;">Registering a device within Notification Hub and maintaining registrations</li>
<li style="font-weight: 400;">Sending notifications to multiple vendors</li>
<li style="font-weight: 400;">Sending a rich content notification through Notification Hub</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To perform exercises from this chapter, you will need the following:</p>
<ul>
<li>An active Azure subscription</li>
<li>Visual Studio 2017 with Tools for Universal Windows apps installed</li>
<li>A Windows Store account</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Reasons to use Notification Hub</h1>
                </header>
            
            <article>
                
<p>If you have ever had a chance to develop an application that was integrated with any notifications system, you probably know the challenges that are faced when creating such a product. In this chapter, I will try to introduce you to some basic concepts such as PNS, push notifications, and device registrations. This will ensure that we can easily start developing applications leveraging Notification Hub features and focus on learning details and hidden functionalities.</p>
<div class="packt_infobox">Exercises from this chapter are written for <strong>Universal Windows Platform</strong> (<strong>UWP</strong>) applications—however, the concepts presented are true also for other platforms such as Android or iOS.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Challenges for application design</h1>
                </header>
            
            <article>
                
<p>Let's assume you have the following architecture:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/f349f142-6d65-4104-93a8-775296a547f4.png" style="width:26.08em;height:21.75em;" width="386" height="320"/></div>
<p>Here, we have a backend that sends some messages to three different platforms:</p>
<ul>
<li>iOS</li>
<li>Android</li>
<li>Windows</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Now, if these messages are push notifications, our backend will have to communicate with three different services:</p>
<ul>
<li><span><strong>Apple Push Notification Service</strong> (<strong>APNS</strong>)</span></li>
<li><span><strong>Firebase Cloud Messaging</strong> (<strong>FCM</strong>)</span></li>
<li><span><strong>Windows Notification Service</strong></span> (<span><strong>WNS</strong></span>)</li>
</ul>
<p>Each of these services is called a <strong>Platform Notification Service</strong> (<strong>PNS</strong>). Their responsibility is to accept a request to send a notification and send it to the appropriate device. They also handle registration of the devices that want to accept notifications (for instance, by tokens in APNS). The downside of such a solution is that none of these services has a common interface—we cannot introduce a simple wrapper in our backend to handle each request in the same fashion. The solution for that kind of trouble would be altering our architecture a little bit, so it contains a service that aggregates the logic for each PNS and is able to communicate with them:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/af3659a3-656d-4b51-a9c0-925aa30c3fda.png" style="width:24.17em;height:22.50em;" width="398" height="371"/></div>
<p>Notification Hub is such a service; it's an abstraction over different PNSes and is able to handle different device registration. We can consider two more problems—scaling and routing. It is important to know that, according do the PNSes guide, the device token must be refreshed with each app launch. Now, if it is your backend responsibility, you may end up with a solution that tries to handle refresh requests instead of focusing on your business logic.</p>
<p>Additionally, if you want to send a notification to a particular device, you have to store its identifier somewhere so you are able to route a message to it. All of these responsibilities can be moved to a notification service, so this whole overhead can be taken from the backend.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Push notification architecture</h1>
                </header>
            
            <article>
                
<p>Creating a whole system that relies on push notification is not a trivial task. Besides ensuring that you are not focusing on handling each PNS logic individually and providing reliable device registration and routing systems, you have to introduce a pipeline for passing messages from one part of your system to the end device. In this section, we will focus on incorporating Notification Hub into a few reference architectures, which will help you understand its role and the connections between different cloud services.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Direct connection</h1>
                </header>
            
            <article>
                
<p>The simplest architecture we could think of would be a direct connection between a backend and notification service:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/bb7fc67a-53af-44ca-a7bd-d7cfa2c2dabb.png" style="width:35.42em;height:25.17em;" width="525" height="373"/></div>
<p>In such a scenario, each send notification request is handled by <span class="packt_screen">Notification Service</span>, which communicate with different <span class="packt_screen">PNSes</span>. Each PNS individually handles a request and sends a notification to a registered device. Device registration is handled by <span class="packt_screen">Notification Service</span>—each device has to register in it to be able to receive a notification. Note that, even in that simple scenario, <span class="packt_screen">Notification Service</span> (in our case—Notification Hub) takes responsibility for two important things:</p>
<ul>
<li>Providing a common interface for different PNSes</li>
<li>Handling device registration and routing</li>
</ul>
<p>Devices never communicate directly with the PNS itself—they only receive push notifications as a result of sending a request to <span class="packt_screen">Notification Service</span>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Queued communication</h1>
                </header>
            
            <article>
                
<p>Sometimes exposing <span class="packt_screen">Notification Service </span>to the backend is not the way to go—it could become unresponsive, have some performance issues, or just be overloaded. In such a situation, it is always good to have something that can cache messages and store them until all issues are resolved. Let's modify the previous architecture with one more service:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/fa1627e3-e404-4b0c-9d77-5f82bb24d8c4.png" style="width:35.92em;height:28.17em;" width="632" height="495"/></div>
<p>By introducing a <span class="packt_screen">Queue</span> with readers, you can absolve the backend from handling communication with <span class="packt_screen">Notification Service </span>and move the responsibility for delivering a message to them. Now <span class="packt_screen">Backend</span> does not have to know how to handle undelivered messages and will not be aware of a storage for storing them. This solution can be also scaled much more easily than the previous one, as you do not have to worry about losing a message—a queue should be able to cache them as long as needed.</p>
<div class="packt_tip">Make sure that your caching mechanism makes sense in the business domain you are working with. Caching a notification request for a day, for example, and sending a notification after that time may not make any sense in scenarios such as geolocalization, a specific time, or a short-lived discount.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Triggered communication</h1>
                </header>
            
            <article>
                
<p>Sometimes, you might like to send a notification based on some specific set of parameters or raising an event. Let's assume you would like to send it whenever a photo is uploaded to storage:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/dc74a003-82c7-4ade-a13b-09a1592e3a02.png" style="width:38.67em;height:16.17em;" width="600" height="251"/></div>
<p>In this asynchronous scenario, you have an <span class="packt_screen">Event Listener</span>, which listens to an event publication and performs an action based on the passed metadata. It sends a request to a <span class="packt_screen">Notification Service</span>, which communicates with <span class="packt_screen">PNS</span> to send a notification with the appropriate content (probable information regarding an upload status). Once more, we see the advantages of having a service acting as a proxy to PNSes—the whole communication can be made asynchronous and each component has its own responsibility.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Registering devices in Notification Hub</h1>
                </header>
            
            <article>
                
<p>To be able to actually send a notification, you have to register a device in the PNS. Without using a service such as Notification Hub, you would have to know the individual logic of each PNS and storage device data somewhere. Such a challenge would be problematic in most cases, as usually you do not want to handle external dependencies by yourself; rather, your aim is to simplify the overall system logic. In this section, you will learn how device registration is handled in Notification Hub and how to monitor it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Notification Hub device registration</h1>
                </header>
            
            <article>
                
<p>When you register a device in Notification Hub, you are actually associating it with a template of a notification and tag. To create such a link, you need a PNS handle, which can be understood as an identifier of a specific vendor (such as a token or GCM registration ID). In fact, there are two ways to register a device:</p>
<ul>
<li><strong>Use registration</strong>: Where you pass an identifier, tag, and template</li>
<li><strong>Use installation</strong>: An enhanced registration with an additional set of push-related properties</li>
</ul>
<div class="packt_infobox">Please note that, currently, if you want to use installation, there is no possibility to use a .NET SDK—you are limited to using the REST API of a service.</div>
<p>We have to also describe what tags and templates are to fully understand the process:</p>
<ul>
<li><strong>Tag</strong>: This is a way to route a notification to a particular set of (or all) registered devices. It allows you to segment users, so you can easily decide who is an addressee of a message; you can use, for example, <kbd>version_Beta</kbd> to send a notification to a limited group of devices using a preview version of your application.</li>
<li><strong>Template</strong>: This is a particular schema of data designed to be sent to a client application. It differs depending on the PNS used and varies from JSON data to XML documents. By using Notification Hub, you can create a platform-agnostic template, which can be reused between different platforms.</li>
</ul>
<p>Now we will try registering a device using both methods and understand the differences between them.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a Notification Hub</h1>
                </header>
            
            <article>
                
<p>Before we start sending notifications, we have to have a notification service provisioned and working. To create a Notification Hub instance, go to the portal and click on the <span class="packt_screen">+ Create a resource</span> button. Search for <span class="packt_screen">Notification Hub</span> and click <span class="packt_screen">Create</span>. Here, you can see a completed configuration:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/1b1e2ca5-d221-44cc-923e-b2e5da518a39.png" style="width:21.17em;height:36.58em;" width="291" height="503"/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>As you can see, there is nothing unexpected on that screen—the only things that need clarification are <span class="packt_screen">Pricing tier</span> and <span class="packt_screen">Namespace</span>:</p>
<ul>
<li><span class="packt_screen">Namespace</span>: You can have multiple Notification Hubs inside the same namespace. A namespace is a logical container for your hubs and holds the limit of available pushes for them.</li>
<li><span class="packt_screen">Pricing tier</span>: Depending on the selected tier (<span class="packt_screen">Free</span>, <span class="packt_screen">Basic</span>, or <span class="packt_screen">Standard</span>) you will have different features available and a different number of available pushes for your hubs. Additionally, it defines the price of extra pushes and the number of active devices. What is more, the <span class="packt_screen">Standard</span> tier comes with handy enterprise features such as multi-tenancy or scheduled push.</li>
</ul>
<p>For the purpose of this exercise, the <span class="packt_screen">Free</span> tier will be more than enough. Once you are satisfied with your configuration, click on the <span class="packt_screen">Create</span> button and wait a second for service creation. When it is created, you can go to its page where you will see an <span class="packt_screen">Overview</span> blade:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/0babb183-5361-404f-b38a-ac63a7739e15.png" width="1233" height="436"/></div>
<p>There, you can click on the hub you created to see its features. We will cover them later in this chapter.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Registering in an application</h1>
                </header>
            
            <article>
                
<p>In this section, we will try to perform a registration using a UWP application in Visual Studio. To get started, open the <kbd>HandsOnAzureApp</kbd> project from the source code for this chapter—you should see a blank UWP application with boilerplate code in it.</p>
<div class="packt_infobox">We will use a UWP application here because it is the easiest way to get started and work with Notification Hub. However, if you are a mobile developer, you can use any kind of project you want.</div>
<p>To get started with registration, you will have to install a package to work with <span>Notification Hub</span>—use the NuGet package manager and search for the <kbd>WindowsAzure.Messaging.Managed</kbd> package, which holds all of the components required for this particular exercise. In the <kbd>App.xaml.cs</kbd> file, you will have to add the following code:</p>
<pre>private async void RegisterADevice()<br/>{<br/>  var channel = await PushNotificationChannelManager.CreatePushNotificationChannelForApplicationAsync();<br/>  var hub = new NotificationHub("&lt;hub-name&gt;", "&lt;connection-string&gt;");<br/>  var result = await hub.RegisterNativeAsync(channel.Uri);<br/><br/>  if (result.RegistrationId == null) return;<br/><br/>  var dialog = new MessageDialog("Registration successful: " + result.RegistrationId);<br/>  dialog.Commands.Add(new UICommand("OK"));<br/>  await dialog.ShowAsync();<br/>}</pre>
<p>What we are doing here can be described as follows:</p>
<ol>
<li>We are creating a notification channel to be used for a registration</li>
<li>We are defining a hub, which we will use to handle notifications and registrations</li>
<li>We are registering a device and displaying a dialog if an operation was successful</li>
</ol>
<p>You may wonder how to obtain the connection string used for the communication; to get it, go to Azure Portal, select your Notification Hub namespace and click on the <span class="packt_screen">Access Policies </span>blade—there you will see a policy named <kbd>RootManageSharedAccessKey</kbd>, from which you can copy a connection string.</p>
<div class="packt_tip">I am using a root policy only for the purpose of this exercise. In a production environment, it is always good to create an individual policy for each application and select only those permissions that are required for it.</div>
<p>When you enter your hub name and paste a connection string, call the <kbd>RegisterADevice()</kbd>method in <kbd>OnLaunched()</kbd>. Now, you can try to start an application. If everything is successful, you should see a screen similar to mine:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/309000d1-c39b-4f6b-929b-7e5927c5010e.png" style="width:35.33em;height:5.08em;" width="646" height="93"/></div>
<p>Congratulations—you have just registered your very first device in Notification Hub!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Checking available registrations</h1>
                </header>
            
            <article>
                
<p>Once you register a device, you <span><span>need </span></span>to make sure it is really available in Notification Hub. The easiest way to do so is to check device registrations in a service itself using <span class="packt_screen">Server Explorer</span>, which can be accessed either by clicking on it in the <span class="packt_screen">View </span>menu (<span class="packt_screen">View</span> | <span class="packt_screen">Server Explorer</span>) or by using the <em>Ctrl</em> + <em>W</em> + <em>L </em>key combination:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/17ad80e0-6a21-45b5-99ad-0b2c2d1ee18c.png" style="width:19.33em;height:13.17em;" width="301" height="205"/></div>
<p>Now, when you double-click on an <span>Notification Hub</span> instance you would like to check, you will see a new screen that contains two tabs—<span class="packt_screen">Test Send </span>(which we will cover later) and <span class="packt_screen">Device Registrations</span>.</p>
<p>By clicking on the latter, you will able to verify all available registrations:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/136d5430-51ef-4687-b9a9-465b981ab6ee.png" style="width:56.83em;height:10.33em;" width="1127" height="204"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using installations</h1>
                </header>
            
            <article>
                
<p>Installations is a newer feature, which allows you to handle each device registration using a bit different syntax and tools. It has a few important advantages over registrations:</p>
<ul>
<li>While it is possible to duplicate registrations (by registering the same device twice), installations are idempotent. That means that sending the same installation multiple times will not result in the creation of more than one registration record.</li>
<li>By using <kbd>HTTP PATCH</kbd>, you are able to update a specific parameter in an installation.</li>
<li>It is easier to perform individual pushes, since each installation is automatically tagged using an installation identifier. In registrations, you would have to create such a tag by yourself and maintain it somehow to get the same functionality.</li>
</ul>
<p>As I said in a previous part of this book, it is not <span>currently </span>possible to use installations with the .NET SDK on the client side—to check this functionality, we will have to use the Notification Hub RESTful API or use SDK for the backend. Here, you can find an example request for calling an API method:</p>
<pre>PUT /&lt;hub&gt;/installations/12234?api-version=2015-01 HTTP/1.1<br/>Host: &lt;namespace&gt;.servicebus.windows.net<br/>Authorization: &lt;authorization token&gt;<br/>Content-Type: application/json<br/>Cache-Control: no-cache<br/><br/>{ <br/>    "installationId": "12234", <br/>    "platform": "wns", <br/>    "pushChannel": "&lt;push channel&gt;", <br/>    "templates": { <br/>        "myTemplate" : { <br/>            "body" : '&lt;toast&gt;&lt;visual lang="en-US"&gt;&lt;binding template="ToastTest01"&gt;&lt;text id="1"&gt;$myTextProp1&lt;/text&gt;&lt;/binding&gt;&lt;/visual&gt;&lt;/tile&gt;',<br/>            "headers": { "X-WNS-Type": "wns/toast" }, <br/>            "tags": ["foo", "bar"] <br/>            } <br/>        } <br/>} </pre>
<div class="packt_tip">To generate an authorization token you will need to generate an SAS token. You can find a guide on how to generate it here  <a href="https://msdn.microsoft.com/library/azure/dn495627.aspx">https://msdn.microsoft.com/library/azure/dn495627.aspx</a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sending a notification</h1>
                </header>
            
            <article>
                
<p>The main functionality of Notification Hub is to send a notification to a set of registered devices. You will see that, using its SDK and portal, you can easily start using that feature without knowing the internal logic of different PNSes. After this section, you should be able to use <span>Notification Hub</span> without problems and incorporate it into your applications.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sending a test notification</h1>
                </header>
            
            <article>
                
<p>While developing your application, you always need a way to test it. When using Notification Hub, you have two options when it comes to sending a test notification—either use the portal or its SDK. Both possibilities allow for similar results; however, using the SDK is a bit more flexible as it is easier to find all of the devices to which you would like to send a notification or add any kind of logic.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Test notification in Azure Portal</h1>
                </header>
            
            <article>
                
<p>When you go to the hub you created, you will see that, at the top of the page, there is a <span class="packt_screen">Test Send </span>button:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/b107f2e6-af2a-4c5a-b2c4-7f631498a28f.png" style="width:37.75em;height:15.75em;" width="527" height="219"/></div>
<p>When you click on it, you will see a screen for the <span class="packt_screen">Test Send</span> functionality. There are a few fields available and they all depend on the platform selected. In the following, you can find a sample request for the Windows platform:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/b236fe41-ffc6-46af-bea1-81580fc38334.png" style="width:33.67em;height:46.42em;" width="572" height="788"/></div>
<p>Now, if you click the <span class="packt_screen">Send</span> button, Notification Hub will select ten different registered devices, which will receive a notification. If you want, you can change both the type and the payload sent. What is more, you can send a message to a specific set of devices by specifying the <span class="packt_screen">Send to Tag Expression</span> option.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Test notification in the SDK</h1>
                </header>
            
            <article>
                
<p>It is also possible to send a test notification using the Notification Hub SDK. To use it, you will need to install the following package: <kbd>Microsoft.Azure.NotificationHubs</kbd>. Consider the following example:</p>
<pre>var hub = NotificationHubClient.CreateClientFromConnectionString(<br/>                "&lt;connection string&gt;",<br/>                "&lt;hub&gt;", true);</pre>
<p>The last parameter enables sending a test notification. That means that, each time you send a notification using the SDK, it will be sent to a maximum of ten registered devices. Additionally, you will get the outcome of each operation (whether it succeeded or failed).</p>
<div class="packt_tip">Remember that, when test mode is enabled, each request to Notification Hub is throttled. That means that you will not be able to overload your communication channel as send operations will be queued and executed in a controlled manner.</div>
<p>You can check whether test send is enabled by checking a property on the <kbd>NotificationHubClient</kbd> object:</p>
<pre>var hub = NotificationHubClient.CreateClientFromConnectionString(<br/>                "&lt;connection string&gt;",<br/>                "&lt;hub&gt;", true);<br/>if (hub.EnableTestSend)<br/>{<br/>    // Do something....<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using the SDK to send a notification</h1>
                </header>
            
            <article>
                
<p>The Notification Hub SDK brings many different methods for sending notifications, depending on the configuration and expected output. Here you can find all the methods available in the SDK:</p>
<pre>hub.SendAdmNativeNotificationAsync();<br/>hub.SendAppleNativeNotificationAsync();<br/>hub.SendBaiduNativeNotificationAsync();<br/>hub.SendDirectNotificationAsync();<br/>hub.SendNotificationAsync();<br/>hub.SendTemplateNotificationAsync();<br/>hub.SendGcmNativeNotificationAsync();<br/>hub.SendWindowsNativeNotificationAsync();</pre>
<p>As you can see, we have two different categories:</p>
<ul>
<li><strong>Native notifications</strong>: Methods for sending a notification to a specific platform only</li>
<li><strong>Generic notifications</strong>: A set of methods for sending a notification to a specific tag</li>
</ul>
<p>I strongly encourage you to experiment and test different possibilities as each method is a bit different. Here you can find the result of calling <kbd>SendAppleNativeNotificationAsync()</kbd> and serializing the output:</p>
<pre>var hub = NotificationHubClient.CreateClientFromConnectionString(<br/>                "&lt;connection string&gt;",<br/>                "&lt;hub&gt;", true);<br/>hub.SendAppleNativeNotificationAsync("{\"aps\":{\"alert\":\"Notification Hub test notification\"}}");</pre>
<p>The result will be as follows in my case:</p>
<pre>{<br/>  "Result": {<br/>    "Success": 8,<br/>    "Failure": 0,<br/>    "Results": [{<br/>      "ApplicationPlatform": "apple",<br/>      "PnsHandle": "&lt;pns handle&gt;",<br/>      "RegistrationId": "1013412858828458675-3388525925469165319-3",<br/>      "Outcome": "The Notification was successfully sent to the Push Notification System"<br/>    }, {<br/>      "ApplicationPlatform": "apple",<br/>      "PnsHandle": "&lt;pns handle&gt;",<br/>      "RegistrationId": "4629243313258036270-2338090353657828558-2",<br/>      "Outcome": "The Notification was successfully sent to the Push Notification System"<br/>    }, {<br/>      "ApplicationPlatform": "apple",<br/>      "PnsHandle": "&lt;pns handle&gt;",<br/>      "RegistrationId": "5538320565569680693-6905916546981709583-3",<br/>      "Outcome": "The Notification was successfully sent to the Push Notification System"<br/>    }, {<br/>      "ApplicationPlatform": "apple",<br/>      "PnsHandle": "&lt;pns handle&gt;",<br/>      "RegistrationId": "5711668963446635284-8967913844749790004-1",<br/>      "Outcome": "The Notification was successfully sent to the Push Notification System"<br/>    }, {<br/>      "ApplicationPlatform": "apple",<br/>      "PnsHandle": "&lt;pns handle&gt;",<br/>      "RegistrationId": "5728263539515349341-3583197654290557965-2",<br/>      "Outcome": "The Notification was successfully sent to the Push Notification System"<br/>    }, {<br/>      "ApplicationPlatform": "apple",<br/>      "PnsHandle": "&lt;pns handle&gt;",<br/>      "RegistrationId": "6986970356553456728-8953287549645821249-1",<br/>      "Outcome": "The Notification was successfully sent to the Push Notification System"<br/>    }, {<br/>      "ApplicationPlatform": "apple",<br/>      "PnsHandle": "&lt;pns handle&gt;",<br/>      "RegistrationId": "7231787013272625417-8398074035919763615-3",<br/>      "Outcome": "The Notification was successfully sent to the Push Notification System"<br/>    }, {<br/>      "ApplicationPlatform": "apple",<br/>      "PnsHandle": "&lt;pns handle&gt;",<br/>      "RegistrationId": "8026985566358875763-8860727728212773916-1",<br/>      "Outcome": "The Notification was successfully sent to the Push Notification System"<br/>    }]<br/>  },<br/>  "Id": 9,<br/>  "Exception": null,<br/>  "Status": 5,<br/>  "IsCanceled": false,<br/>  "IsCompleted": true,<br/>  "CreationOptions": 0,<br/>  "AsyncState": null,<br/>  "IsFaulted": false<br/>}</pre>
<p>As you can see, we get the complete result of sending a notification to a set of registered devices. You can leverage that output to work with your application and, for instance, display the appropriate status or report.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Rich content notifications</h1>
                </header>
            
            <article>
                
<p>In the last section of this chapter, we will talk a bit about another type of notification, which is called <strong>rich content notification</strong>. Sometimes you would like to send something more than plain text. In Notification Hub, it is possible to send, for example, an image to enhance the look and feel of an application.</p>
<div class="packt_infobox">Please note that receiving rich content notifications requires making changes on the client side. We will not cover that in this chapter but, at the end of it, you will find a link where such an operation is described in detail.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating and sending a rich content notification</h1>
                </header>
            
            <article>
                
<p>To create and send a rich content notification, you will need two things:</p>
<ul>
<li>A model of a notification</li>
<li><span>The notification payload and content</span></li>
</ul>
<p>The idea is to send it in a way that will enable a client application to fetch rich content and handle it on its side. In fact, the simplest way to do so would be to have an API that provides two operations:</p>
<ul>
<li>Send a notification</li>
<li>Fetch notification data</li>
</ul>
<p>In the following, you can find example code for both actions:</p>
<pre>public class HubController : ApiController<br/>{<br/>  public static Lazy&lt;NotificationHubClient&gt; Hub = new Lazy&lt;NotificationHubClient&gt;(() =&gt;<br/>    NotificationHubClient.CreateClientFromConnectionString("&lt;connection string&gt;", "&lt;hub&gt;"));<br/><br/>  [HttpPost]<br/>  public async Task&lt;HttpResponseMessage&gt; Send()<br/>  {<br/>    var notification = new Notification("Hey, check this out!");<br/>    var fullNotification = "{\"aps\": {\"content-available\": 1, \"sound\":\"\"}, \"richId\": \"" + notification.Id +<br/>            "\", \"richMessage\": \"" + notification.Message + "\", \"richType\": \"" +<br/>            notification.RichType + "\"}";<br/><br/>    await Hub.Value.SendAppleNativeNotificationAsync(fullNotification, "&lt;tag&gt;");<br/>    return Request.CreateResponse(HttpStatusCode.OK);<br/>  }<br/><br/>  public HttpResponseMessage Get(string id)<br/>  {<br/>    var image = Notification.ReadImage(id);<br/>    var result = new HttpResponseMessage(HttpStatusCode.OK) {Content = new StreamContent(image)};<br/>    result.Content.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue("image/{png}");<br/><br/>    return result;<br/>  }<br/>}</pre>
<p>As you can see, the only thing we have to do is to keep the correct schema for sending a notification to a particular PNS. In the previous example, I used APNS but, of course, it is possible for other vendors (as long as their software supports receiving images or audio through push notifications). You can find the example in the source code for this chapter.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you have learned what Notification Hub is and how you can use it to incorporate push notifications into your applications. We covered some reference architectures and possible scenarios, which should help you understand what the purpose of this service is and how it solves problems when sending notifications to multiple PNSes and devices.</p>
<p>This chapter ends the first part of this book. In the next one, we will focus on serverless components and architectures.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is PNS?</li>
<li>Do multiple platforms (iOS, Android, and Windows) have different PNSes?</li>
<li>What is the difference between registration and installation?</li>
<li>Can you register the same number of devices in the <span class="packt_screen">Free </span>and <span class="packt_screen">Basic </span>tiers?</li>
</ol>
<ol start="5">
<li>What is the easiest way to check registered devices in <span>Notification Hub</span>?</li>
<li>How can you send a test notification?</li>
<li>What are rich content notifications?</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li>Azure Notification Hub documentation: <a href="https://docs.microsoft.com/en-us/azure/notification-hubs/">https://docs.microsoft.com/en-us/azure/notification-hubs/</a></li>
<li>IOS push notifications: <a href="https://docs.microsoft.com/en-us/azure/notification-hubs/notification-hubs-aspnet-backend-ios-apple-push-notification-service-apns-rich">https://docs.microsoft.com/en-us/azure/notification-hubs/notification-hubs-aspnet-backend-ios-apple-push-notification-service-apns-rich</a></li>
<li>Registrations in Azure Notification Hub: <a href="https://docs.microsoft.com/en-us/azure/notification-hubs/notification-hubs-push-notification-registration-management">https://docs.microsoft.com/en-us/azure/notification-hubs/notification-hubs-push-notification-registration-management</a></li>
</ul>


            </article>

            
        </section>
    </div>



  </body></html>