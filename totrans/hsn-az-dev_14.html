<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Enterprise Integration - Azure Service Bus</h1>
                </header>
            
            <article>
                
<p>Sometimes, to integrate our applications using messaging solutions, we need something more than a simple pipeline, which offers limited capabilities when it comes to distributing data and filtering it. Topics, filters, and many more features are available in Azure Service Bus, an enterprise-level solution designed for providing a reliable, scalable, and efficient way for sending messages to multiple receivers.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Working with Azure Service Bus</li>
<li>The fundamentals—queues, topics, and relays</li>
<li>Securing Azure Service Bus</li>
<li>The advanced features like geo-replication, sessions, or dead lettering</li>
<li>Handling outages and disasters</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To perform the exercises in this chapter, you will need:</p>
<ul>
<li>Access to a Microsoft Azure subscription</li>
<li>A Visual Studio 2017 instance </li>
<li>Visual Studio Code (if you don't have a Visual Studio 2017 instance)</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Azure Service Bus fundamentals</h1>
                </header>
            
            <article>
                
<p>You have already learned about other messaging solutions, which allow you to ease communication between your services, and all are characterized by different features. In Azure Event Hub,<em> </em>you were able to process thousands of messages per second, while with Azure Storage Queues<em> </em>you were given a reliable and durable solution, which you could use to work asynchronously on ingested data. In this chapter, we will discuss Azure Service Bus, a multitenant cloud messaging service that introduces advanced concepts like first-in,first-out(FIFO) messaging, dead lettering, or transactions. It is an enterprise-class cloud component able to integrate many different services and applications.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Azure Service Bus versus other messaging services</h1>
                </header>
            
            <article>
                
<p>In the previous chapters, we discussed the following services, which allowed us to process messages:</p>
<ul>
<li>Azure Event Hub</li>
<li>Azure Storage Queue</li>
<li>Azure Event Grid</li>
</ul>
<p>They all have similarities, yet they are designed to serve different features and offer different capabilities. We often use the concepts of events<strong> </strong>and messages<strong> </strong>alternately. In fact, there is a slight difference between them and understanding this is crucial to be able to use different messaging services successfully:</p>
<ul>
<li><strong>Event</strong>: It carries the information that something happened—the fact that someone or something produced an event does not imply any expectations regarding how an event should be handled. Events, in general, are lightweight information carriers and do not bring the full data to the receiver.</li>
<li><strong>Message</strong>: As opposed to an event, when a producer sends a message, it has some expectation about how it will be handled (so there is some kind of a contract between a producer and a consumer). What is more, a message carries the raw data while an event implies that something happened; a message indicates that a component has initialized a communication, which should be handled <span>in the usual way</span>.</li>
</ul>
<p>Now you can recall what you have learned about, for example, Azure Event Grid<em> </em>or Azure Event Hub—they both have an event<em> </em>in the name, but work in quite different ways:</p>
<ul>
<li><strong>Azure Event Grid</strong>: It is designed to distribute events and react to changes. It delivers only the metadata, and the actual message has to be fetched individually; thus, it can be said, that it distributes events.</li>
<li><strong>Azure Event Hub</strong>: It works as a big data pipeline and streams events to other services. Depending on your implementation, it can stream both events<strong> </strong>and messages.</li>
</ul>
<p>Now, let's compare Service Bus:</p>
<ul>
<li><strong>Azure Service Bus</strong>: It was created to support critical processes, which have high requirements regarding the order of processing and reliability of the messaging service. You can use it when a message<strong> </strong>cannot be lost or duplicated. It does not work with the concept of events—instead, it allows you to push the whole data, which can be read by a consumer.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Azure Service Bus and Azure Storage Queues</h1>
                </header>
            
            <article>
                
<p>You may wonder what the difference between Azure Service Bus<em> </em>and Azure Storage Queues is. In fact, they are both messaging solutions, which are reliable, durable, and can handle multiple messages at once. However, looking more closely, you can see they are quite different services, built using different concepts and for a different purpose:</p>
<ul>
<li>Azure Storage Queue<em> </em>solutions are forced to poll the queue to receive a message—with Azure Service Bus<em> </em>you can establish a long-polling receive operation via TCP.</li>
<li>In Azure Storage Queue,<em> </em>you can store messages of up to 64 KB—Azure Service Bus changes that limit to 256 KB.</li>
<li>Azure Service Bus<em> </em>queues can store less data than Azure Storage Queues—up to 80 GB.</li>
<li>Azure Service Bus supports consuming batches of messages.</li>
<li>In Azure Storage Queues,<em> </em>the security model is quite basic—Azure Service Bus<em> </em>supports an RBAC model when it comes to securing queues.</li>
<li>Azure Storage Queues<em> </em>do not support transactional behaviour.</li>
</ul>
<p>As you can see, in Azure Service Bus<em> </em>there are many advanced features available, which can be very helpful in applications integrating different systems and applications, and also in third-party ones. Of course, those additional features cost extra as they require a more expensive tier. In Azure Service Bus,<em> </em>you have three tiers:</p>
<ul>
<li><strong>Basic</strong>: Supports queues and scheduled messages only.</li>
<li><strong>Standard</strong>: All features are available.</li>
<li><strong>Premium</strong>: The maximum message size is extended to 1 MB, and brokered connections are included in the price. This tier also guarantees higher throughput and better performance.</li>
</ul>
<div class="packt_tip">If you require only the basic functionality (without topics, transactions, or sessions), an Azure Service Bus<em> </em>instance can be even cheaper than using Azure Storage Queues. It all depends on your requirements regarding your system.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Azure Service Bus in Azure portal</h1>
                </header>
            
            <article>
                
<p>To create an instance of the Azure Service Bus, you have to search for the <kbd>Service Bus</kbd><strong> </strong>service in the marketplace. You will see a short form where you fill in the most crucial information, like the name of the service, the pricing tier, and its location:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/7cb2862e-d956-4578-a0e5-51bdc1db1d45.png" style="width:18.08em;height:24.58em;" width="356" height="483"/></p>
<p>For now, it is all you have to enter—just click on the <span class="packt_screen">Create</span><strong> </strong>button and wait a second until a service is created. The <span class="packt_screen">Overview</span><strong> </strong>blade shows a bit more information, but as you can see, it is very similar to the one you saw when working with Azure Event Hub:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/2f32e2b9-9097-4286-aa08-9a7abd4cecef.png" style="width:54.75em;height:28.83em;" width="1000" height="527"/></p>
<p>In the preceding screenshot, you see that the<strong> </strong><span class="packt_screen">+ Topic</span><strong> </strong>button is grayed out—this is because I selected the basic<strong> </strong>tier for this exercise. By clicking on the <span class="packt_screen">+ Queue</span><strong> </strong>button, you will be able to create a new queue:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/fb8d483d-8ca9-4ccb-833c-995abb0f4e89.png" style="width:27.42em;height:36.33em;" width="424" height="562"/></p>
<p>Here things are getting a little bit more complicated:</p>
<ul>
<li><span class="packt_screen">Name</span>: This is the unique name of a queue.</li>
<li><span class="packt_screen">Max queue size</span>: You can decide the maximum size of a queue (as opposed to a fixed size of 80 GB in Azure Storage Queue).</li>
<li><span class="packt_screen">Message time to live</span>: In Azure Storage Queues,<em> </em>the maximum lifetime of a message was 7 days. Here you can specify the custom lifetime of a message before it is deleted (or moved to a dead letter queue).</li>
<li><span class="packt_screen">Lock duration</span>: When a message is picked up by a consumer, it is locked for a fixed time period to avoid duplicated reads. Here you can customize it (up to a maximum of 5 minutes).</li>
<li><span class="packt_screen">Enable duplicate detection</span>: If you want to ensure the "exactly once" delivery model during a fixed time period, you can enable this option. It enables you to configure a duplicate detection window in which a history of processed messages will be kept.</li>
<li><span class="packt_screen">Enable dead lettering on message expiration</span>: If a message expires, it is automatically deleted. To push it to a dead letter queue instead, enable this option.</li>
<li><span class="packt_screen">Enable sessions</span>: Sessions in Azure Service Bus<em> </em>ensure FIFO message processing. To make sure that the first message pushed to a service is the one to be processed, turn this feature on.</li>
<li><span class="packt_screen">Enable partitioning</span>: This option detaches a queue from a single messaging store, so in fact you are ending with multiple queues. This option ensures that even if a store has an outage, the whole queue or a topic will not go down. There are some limitations, however, regarding this feature—one is that with partitioning you cannot send messages belonging to different sessions in a single transaction. What is more, there is a limit of 100 partitioned queues or topics per namespace.</li>
</ul>
<div class="packt_infobox">Partitioned queues and topics are not supported in the premium<strong> </strong>tier of Azure Service Bus.</div>
<p>This is how a queue looks when partitioning is enabled:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/80879d97-97b3-494a-83ba-a16583f375fe.png" style="width:54.25em;height:35.75em;" width="709" height="468"/></div>
<p>As you can see, the maximum size of a queue is displayed as 16 GB—this is because with partitioning enabled, we are ending with  16 partitions—each hosting a queue of the maximum size of 1 GB.</p>
<div class="packt_tip">Because the maximum size of a single queue is set as 5 GB, you can achieve the maximum size of 80 GB by using partitioning. With that feature enabled, the maximum size will be 5 GB * 16 partitions = 80 GB.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Queues, topics, and relays</h1>
                </header>
            
            <article>
                
<p>Azure Service Bus<em> </em>supports three different kinds of entities:</p>
<ul>
<li>Queues</li>
<li>Topics</li>
<li>Relays</li>
</ul>
<p>All three give you different options when handling communication.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Queues</h1>
                </header>
            
            <article>
                
<p>A queue is the simplest entity available in the service. You can define it as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/087852d2-cf23-4439-b557-4a794cfeb67c.png" style="width:36.58em;height:10.00em;" width="603" height="165"/></p>
<p>In the preceding sample, you can see that we have the following concepts:</p>
<ul>
<li><strong>Producer</strong>: An application or a service, which pushes a message to a queue</li>
<li><strong>Queue</strong>: A container for messages</li>
<li><strong>Consumer</strong>: An application or a service, which reads messages from a queue using a pull<em> </em>model</li>
</ul>
<p>A pull<em> </em>model means that a producer<strong> </strong>has actually to ask a queue to receive messages. Of course, there can be multiple producers and multiple consumers—this is where the lock duration<strong> </strong>feature is especially helpful as it ensures that only a single consumer reads a message at any one time.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Topics</h1>
                </header>
            
            <article>
                
<p>Topics are a slightly different model than queues as they allow you to implement a pub/sub communication model. When a queue is a point-to-point communication, topics give you an option to distribute different messages to a different queue:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/21559fcf-4dfc-4e8d-866d-39a4b4bfba69.png" style="width:38.42em;height:18.50em;" width="608" height="293"/></p>
<p>This model makes it possible to filter messages and isolate them, so a consumer reads only those, which they are interested in.</p>
<div class="packt_tip">Remember, topics are not available in the basic<strong> </strong>tier—you have to use at least the standard tier.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Relays</h1>
                </header>
            
            <article>
                
<p>Both queues and topics are models, which are designed to deliver one-way communication only—a producer sends a message and a receiver reads it. If you want to implement bidirectional communication, you have to use a relay:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/640acb15-50ca-4b4d-a9bf-56137eb57804.png" style="width:35.42em;height:7.83em;" width="587" height="130"/></p>
<p>Azure Relay<em> </em>is, in fact, a separate service, and we will not cover it in this chapter. There are, however, many great features, which you may find helpful in your applications: </p>
<ul>
<li>It is designed to expose services securely, which are hosted within a corporate network.</li>
<li>It allows different communication models like one-directional, pub/sub, andtwo-way communication.</li>
<li>It does not alter the network as a VPN does, making it more stable and scoped to a single application endpoint.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Azure Service Bus design patterns</h1>
                </header>
            
            <article>
                
<p>Azure Service Bus is often a central point of integration for many different cloud services—it can be used in a variety of scenarios, including data integration, broadcasting information, or even bidirectional communication. As the service is rich in different features, you can use it to implement various responsibilities. You can find many examples of design patterns for Azure Service Bus in the <em>Further reading</em> section in this chapter.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Developing solutions with Azure Service Bus SDK</h1>
                </header>
            
            <article>
                
<p>There is a rich database of many different examples for working with Azure Service Bus<em>, </em>available on GitHub (you can find a link in the <em>Further reading</em><strong> </strong>section), so we will cover only the basic ones in this chapter. Here you can find the most simple way to send a message to a queue:</p>
<pre>using System.Text;<br/>using System.Threading.Tasks;<br/>using Microsoft.Azure.ServiceBus;<br/><br/>namespace HandsOnAzure.ServiceBus<br/>{<br/>    internal class Program<br/>    {<br/>        private static void Main()<br/>        {<br/>            MainAsync().GetAwaiter().GetResult();<br/>        }<br/><br/>        private static async Task MainAsync()<br/>        {<br/>            var client = new QueueClient("&lt;connection-string&gt;", "&lt;queue-name&gt;");<br/>            var message = "This is my message!";<br/><br/>            await client.SendAsync(new Message(Encoding.UTF8.GetBytes(message)));<br/>        }<br/>    }<br/>}</pre>
<p>As you can see, all it requires (at least to get the basic functionality) is to use a <kbd>QueueClient</kbd><strong> </strong>instance. If you want to work with a topic, you could use <kbd>TopicClient</kbd><strong> </strong>instead:</p>
<pre>var client = new TopicClient("&lt;connection-string&gt;", "&lt;topic-name&gt;");</pre>
<p>In fact, all you need is to install the <kbd>Microsoft.Azure.ServiceBus</kbd><strong> </strong>NuGet package. After I ran the preceding code three times and checked my queue, this is what I saw in the portal:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/5ff73501-5437-45ea-b680-d232a6a75cc6.png" width="707" height="457"/></p>
<p>As you can see, there are three active messages. That means that I have successfully published them and they are ready to be pulled. There are many different options for pulling a message—here you can find an example using <kbd>PeekAsync</kbd>:</p>
<pre>using System;<br/>using System.Text;<br/>using System.Threading.Tasks;<br/>using Microsoft.Azure.ServiceBus.Core;<br/><br/>namespace HandsOnAzure.ServiceBus.Reader<br/>{<br/>    internal class Program<br/>    {<br/>        private static void Main()<br/>        {<br/>            MainAsync().GetAwaiter().GetResult();<br/><br/>            Console.ReadLine();<br/>        }<br/><br/>        private static async Task MainAsync()<br/>        {<br/>            var receiver =<br/>                new MessageReceiver(<br/>                    "&lt;connection-string&gt;",<br/>                    "&lt;queue-name&gt;");<br/><br/>            while (true)<br/>            {<br/>                var message = await receiver.PeekAsync();<br/>                if(message == null) continue;<br/><br/>                Console.WriteLine($"New message: [{message.ScheduledEnqueueTimeUtc}] {Encoding.UTF8.GetString(message.Body)}");<br/>                await Task.Delay(100);<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p>However, if you only peek messages, you will not <span>create</span> a message store. To actually do that, you have to use <kbd>ReceiveAsync</kbd>:</p>
<pre>var message = await receiver.ReceiveAsync();</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The difference will be visible when you read messages using both methods. <kbd>PeekAsync</kbd><strong> </strong>will not change the state of messages (so they will be still visible as active, even if you set the <kbd>ReceiveMode</kbd><strong> </strong>option to <kbd>ReceiveAndDelete</kbd>). <kbd>ReceiveAsync</kbd><strong> </strong>will use the value of a <kbd>ReceiveMode</kbd><strong> </strong>option and possibly act as an atomic <kbd>CompleteAsync</kbd><strong> </strong>operation.</p>
<div class="packt_tip">To mark messages as read after using <kbd>PeekAsync</kbd><strong> , </strong>you can use <kbd>CompleteAsync</kbd>.</div>
<p>We will cover more advanced scenarios later in this chapter.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Azure Service Bus security</h1>
                </header>
            
            <article>
                
<p>As Azure Service Bus<em> </em>is described as an enterprise-level cloud service designed for integrating different services, there are serious expectations regarding the security features it offers. Besides shared access tokens, there are new features in the preview, which allow much more flexible access management. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Managed Service Identity</h1>
                </header>
            
            <article>
                
<p><strong>Managed Service Identity</strong> (<strong>MSI</strong>) is a feature in Azure Cloud, which eases authentication between services, without storing credentials in your code. The whole description can be found in the link in the <em>Further reading</em><strong> </strong>section. When it comes to using it with Azure Service Bus, there is no additional blade available—what you need is just to find an identity in the access control (IAM) blade:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/13c1bfba-f1f7-491e-bbfc-507df8058109.png" style="width:30.92em;height:15.08em;" width="416" height="203"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Now, instead of using an SAS token or access policy, you can use the following code:</p>
<pre><span class="pl-k">var</span> <span class="pl-smi">tokenProvider</span> <span class="pl-k">=</span> <span class="pl-smi">TokenProvider</span>.<span class="pl-en">CreateManagedServiceIdentityTokenProvider</span>();
<span class="pl-smi">var sendClient</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">QueueClient</span>(<span class="pl-s"><span class="pl-pds">$"</span>sb://{namespace}.servicebus.windows.net/<span class="pl-pds">"</span></span>, {queue-name}, <span class="pl-smi">tokenProvider</span>);
<span class="pl-k">await</span> <span class="pl-smi">sendClient</span>.<span class="pl-en">SendAsync</span>(<span class="pl-k">new</span> <span class="pl-en">Message</span>(<span class="pl-smi">Encoding</span>.<span class="pl-smi">UTF8</span>.<span class="pl-en">GetBytes</span>(<span class="pl-smi">messageInfo</span>.<span class="pl-smi">MessageToSend</span>)));
<span class="pl-k">await</span> <span class="pl-smi">sendClient</span>.<span class="pl-en">CloseAsync</span>();</pre>
<p>As you can see, the flow becomes much simpler as you do not have to store credentials or keys, and instead let the provider handle the authentication.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">RBAC </h1>
                </header>
            
            <article>
                
<p>In Azure Service Bus,<em> </em>there is also a possibility to leverage roles defined in Azure AD to grant access to a service. The whole feature relies on the assumption that a user will be able to take responsibility for granting access to a Service Bus instance. The first step is exactly the same as with MSI authentication: you have to add a user to a service, so it gains access and can start pushing and receiving messages. The full instructions can be found in the <em>Further reading</em><strong> </strong>section.</p>
<div class="packt_tip">Note that with the ability to tell explicitly how a user or an application can access Azure Service Bus, you are given much better control over how messages are published and received. This a great improvement over Azure Storage Queues<em>, </em>where such features are not available.</div>
<p>There is also a possibility to use RBAC authentication to grant access to a service to another service (if MSI is not available). In that scenario, there will be no interactive login required as it is all handled by Azure AD. </p>
<div class="packt_infobox">Even if interactive login is required, it is not handled by an application so you can be sure that it will not handle any credentials directly.</div>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Advanced features of Azure Service Bus</h1>
                </header>
            
            <article>
                
<p>We have already covered some of the basics of the Azure Service Bus,<em> </em>like SDK, the most crucial concepts, and security considerations. Now we will focus a little bit on more advanced use cases, like dead lettering, performance, sessions, and transactions. All those topics are crucial when developing a reliable and important service integrating many different applications and systems. Also remember to take a look at the Azure Service Bus<em> </em>examples in the <em>Further reading</em><strong> </strong>section, as it points to a GitHub repository where you can find many different use cases and concepts when using this service.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Dead lettering</h1>
                </header>
            
            <article>
                
<p>In general, dead lettering<em> </em>means that there are messages in a queue considered as dead (because there was no receiver interested in pulling them) and you have two options to proceed:</p>
<ul>
<li>Either delete them permanently</li>
<li>Push them to an additional queue, named a dead letter queue</li>
</ul>
<p>In Azure Service Bus,<em> </em>you have two options to push a message to a dead letter queue:</p>
<ul>
<li>Set the maximum lifetime of a message—once it expires, it is automatically moved to a dead letter queue</li>
<li>Use the <kbd>DeadLetterAsync</kbd><strong> </strong>method on <kbd>MessageReceiver</kbd><strong> </strong>as follows:</li>
</ul>
<pre style="padding-left: 90px">await receiver.DeadLetterAsync("&lt;lock-token&gt;", "&lt;reason&gt;");</pre>
<p>Here you can find the complete example, and you can find a lock token:</p>
<pre>while (true)<br/>{<br/>  var message = await receiver.ReceiveAsync();<br/>  if(message == null) continue;<br/><br/>  Console.WriteLine($"New message: [{message.ScheduledEnqueueTimeUtc}] {Encoding.UTF8.GetString(message.Body)}");<br/><br/>  await receiver.DeadLetterAsync(message.SystemProperties.LockToken, "HandsOnAzure - test");<br/>  await Task.Delay(100);<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Once you push messages to a dead letter queue, their status will be visible in the portal:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/fa7cb48a-a2d6-44c8-9464-886de3c75dc6.png" width="704" height="451"/></p>
<p>Of course, it is possible to fetch messages from a dead letter queue. To get the name, you can use the following method:</p>
<pre>var deadLetterQueueName = EntityNameHelper.FormatDeadLetterPath("&lt;entity-path&gt;");</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Disaster recovery</h1>
                </header>
            
            <article>
                
<p>When a disaster happens, you may lose a part or all of your data. In general, a disaster is defined as a temporal or permanent loss of the whole service with no guarantees that it will become available again. Such disasters are floods, earthquakes, or fires, just to name a few. Disasters tend to occur in a single region (the probability of disasters occurring in separate regions simultaneously is very small), so in general you need two different data centers to implement disaster recovery (DR).</p>
<div class="packt_infobox">Remember, using two different data centers may not be enough if they are close to each other—you have to select two that can satisfy your requirements, but at the same time are as far from each other as possible.</div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>When it comes to implementing DR in Azure Service Bus, the flow is the same as in Azure Event Hub:</p>
<ul>
<li>Create the primary region</li>
<li>Create the secondary region</li>
<li>Create the pairing</li>
<li>Define a trigger for failover</li>
</ul>
<p>In general, to create the pairing, you need the following code snippet:</p>
<pre>var client = new ServiceBusManagementClient(creds) { SubscriptionId = subscriptionId };<br/><br/>var namespace2 = <br/>  await client.Namespaces.CreateOrUpdateAsync(<br/>  "&lt;resource-group-name&gt;", <br/>  "&lt;secondary-namespace&gt;", <br/>  new SBNamespace { ... params ... });<br/><br/>ArmDisasterRecovery drStatus = <br/>  await client.DisasterRecoveryConfigs.CreateOrUpdateAsync(<br/>            "&lt;resource-group-name&gt;",<br/>      "&lt;primary-namespace&gt;",<br/>      "&lt;alias&gt;",<br/>      new ArmDisasterRecovery { PartnerNamespace = namespace2.Id })</pre>
<div class="packt_infobox">The preceding sample uses the <kbd>Microsoft.Azure.Management.ServiceBus</kbd><strong> </strong>NuGet package for operating on a namespace.</div>
<p>Once a pairing is configured and created, it is up to you to trigger and initiate a failover. To do so, the following line is all you need:</p>
<pre><span class="pl-smi">client</span><span>.</span><span class="pl-smi">DisasterRecoveryConfigs</span><span>.</span><span class="pl-en">FailOver</span><span>(</span><span class="pl-smi">"&lt;resource-group-name&gt;"</span><span>, </span><span class="pl-smi">"&lt;secondary-namespace&gt;"</span><span>, </span><span class="pl-smi">"&lt;alias&gt;"</span><span>);</span></pre>
<div class="packt_infobox">Note that a failover is initiated against the secondary region—this is crucial as the primary region may not be available at the time of initiating an operation. </div>
<p class="mce-root"/>
<p>Once a failover is finished, you can start handling messages using your secondary region. There is, however, one important thing to remember: in case another outage happens, you want to be able to fail over again. Because of that, it is also very important to set up another secondary namespace (and make the current one your primary) and pair them to be secure again.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sessions</h1>
                </header>
            
            <article>
                
<p>In Azure Service Bus,<em> </em>sessions are used to achieve a FIFO guarantee. In general, the service does not control the relationship between messages, so even if in most cases the order is preserved, it is not guaranteed. To put a message to a session, you have to leverage a <kbd>SessionId</kbd><strong> </strong>property:</p>
<pre>await client.SendAsync(new Message(Encoding.UTF8.GetBytes(message)) { SessionId = Guid.Empty.ToString()});</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>To handle a session on the receiver side, you have to use the <kbd>RegisterSessionHandler</kbd><strong> </strong>method on a <kbd>QueueClient</kbd><strong> </strong>instance:</p>
<pre>var client = new QueueClient("&lt;connection-string&gt;", "&lt;queue-name&gt;");<br/>client.RegisterSessionHandler((session, message, ct) =&gt; Task.FromResult(new SessionHandler()), args =&gt; Task.CompletedTask);</pre>
<p>Additionally, you will have to implement <kbd>IMessageSession</kbd><strong>.</strong></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Transactions</h1>
                </header>
            
            <article>
                
<p>Transactions in Azure Service Bus<em> </em>are a wide topic referring to many different entities, which you can work with in this service:</p>
<ul>
<li>Clients (<kbd>QueueClient</kbd>, <kbd>TopicClient</kbd>)</li>
<li>Messages (by using operations like <kbd>Complete</kbd>, <kbd>Defer</kbd>, <kbd>Abandon</kbd> , and many more)</li>
<li>Sessions (<kbd>GetState</kbd>/<kbd>SetState</kbd>)</li>
</ul>
<p>As you can see, there are no receive operations listed; this is because there is an assumption that they are atomic by design.</p>
<div class="packt_infobox">In general, there is a requirement for using the <kbd>ReceiveMode.PeekLock</kbd><strong> </strong>mode when pulling messages and opening a transaction scope inside a loop or an <kbd>OnMessage</kbd><strong> </strong>callback.</div>
<p>You can refer to the following code snippet to get a better picture of what we are talking about in this section:</p>
<pre>var message = receiver.Receive();<br/>using (scope = new TransactionScope())<br/>{<br/>   var newMessage = // transfer<br/>  <br/>   sender.Send(newMessage);<br/>   message.Complete();<br/>   <br/>   scope.Complete();<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In the above example, a processor (which at the same moment is responsible for producing a message) marks a message as complete, while transferring a new message to another queue. The whole model leverages the autoforwarding feature of Azure Service Bus. The following is an example of a topic:</p>
<pre>var subscription = new SubscriptionDescription(sourceTopic, subscriptionName);<br/>subscription.ForwardTo = destinationTopic;<br/>namespaceManager.CreateSubscription(subscription);</pre>
<p>When a transaction is implemented, you can be sure that committing to a queue log will only happen if the whole transaction succeeds; otherwise, there will be simply no trace of the messages that were handled inside it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Handling outages and disasters</h1>
                </header>
            
            <article>
                
<p>If you make Azure Service Bus<em> </em>the center of your architecture—a service that is responsible for integrating dozens of services and handling the communication—you have to make sure that it is replicated and invulnerable to disasters. There are two topics to consider here: disaster recovery and handling outages. As those terms are completely different concepts, you have both to understand them and be able to implement a solution in case unexpected issues and accidents occur. In the last section of this chapter, you will learn how Azure Service Bus<em> </em>can be made into a durable cloud component, on which you and your applications can rely.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Handling outages</h1>
                </header>
            
            <article>
                
<p>While a disaster often means that some part of your data is lost, an outage may be described as a service being temporarily unavailable. This is why once it is resolved, you may want to synchronize both Service Bus namespaces. While this process is automatic, it may take a while. It is stated in the documentation that only 50-100 entities will be transferred per minute. For this reason, you may consider the concept of active/passive replication:</p>
<ul>
<li><strong>Active</strong>: In such an approach, you have two active namespaces, which actively receive messages. Then a receiver always receives both of them—you have to tag them properly with the same unique identifier used to detect duplicates (you can use either the <kbd>MessageId</kbd><strong> </strong>or <kbd>Label</kbd><strong> </strong>property for that).</li>
<li><strong>Passive</strong>: Instead of actively using both queues (or topics), you can use the second one only if a message cannot be delivered to the primary namespace. This approach has its caveats, however: it may cause a message delivery delay (or even loss) or duplicates.</li>
</ul>
<p>Here, you can find an example of passive replication:</p>
<pre>private async Task SendMessage(BrokeredMessage message1, int maxSendRetries = 10)<br/>{<br/>  do<br/>  {<br/>    var message2 = message1.Clone();<br/>    try<br/>    {<br/>      await _activeQueueClient.SendAsync(message1);<br/>      return;<br/>    }<br/>    catch<br/>    {<br/>      if (--maxSendRetries &lt;= 0)<br/>      {<br/>        throw;<br/>      }<br/><br/>      lock (_swapMutex)<br/>      {<br/>        var client = _activeQueueClient;<br/>        _activeQueueClient = _backupQueueClient;<br/>        _backupQueueClient = client;<br/>      }<br/>      <br/>      message1 = message2.Clone();<br/>    }<br/>  }<br/>  while (true);<br/>}</pre>
<p>As you can see, it clearly shows how a duplicate of a message is passed to a backup queue. An example of active replication is slightly different:</p>
<pre>var task1 = primaryQueueClient.SendAsync(m1);<br/>var task2 = secondaryQueueClient.SendAsync(m2);<br/><br/>try<br/>{<br/>  await task1;<br/>}<br/>catch (Exception e)<br/>{<br/>  exceptionCount++;<br/>}<br/><br/>try<br/>{<br/>  await task2;<br/>}<br/>catch (Exception e)<br/>{<br/>  exceptionCount++;<br/>}<br/><br/>if (exceptionCount &gt; 1)<br/>{<br/>  throw new Exception("Send Failure");<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>Here we are sending the same message to both namespaces, even if one of them fails. One more thing that should be considered to handle outages is using partitioned senders (though unavailable in the premium<strong> </strong>tier). When using them, you are safe in case of an outage of a single messaging store, and you can still use other partitions to send and receive data. The following example enables partitioning on a topic:</p>
<pre>var ns = NamespaceManager.CreateFromConnectionString(myConnectionString);<br/>var td = new TopicDescription(TopicName);<br/>td.EnablePartitioning = true;<br/>ns.CreateTopic(td);</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this short chapter, you learned the basic concepts of Azure Service Bus<em> </em>including queues, topics, SDK, and more advanced features like dead lettering, sessions, and transactions. There are still many things to learn: asynchronous messaging, <strong>Advanced Message Queuing Protocol</strong> (<strong>AMQP</strong>), and advanced transaction scenarios. In general, it is a great service for both simple and critical scenarios as it gives you enough flexibility to adjust it to most applications, and at the same time it is quite easy to learn how to get started. Remember, you can use the basic<strong> </strong>tier for the simplest use cases, which gives you a cheap and reliable solution, a much richer option than Azure Storage Queue. In the next chapter, we will focus on monitoring services with Azure Application Insights<em>.</em></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is the difference between a queue and a topic?</li>
<li>Can you use topics in the basic<strong> </strong>tier?</li>
<li>What is the reason for using a dead letter queue?</li>
<li>What are sessions for in Azure Service Bus?</li>
<li>What is the maximum size of a queue with partitioning enabled, when a single queue has the maximum size of 1 GB?</li>
<li>What is the difference between active and passive replication?</li>
<li>How is disaster recovery achieved in Azure Service Bus?</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li>MSI overview: <a href="https://docs.microsoft.com/pl-pl/azure/active-directory/managed-identities-azure-resources/overview">https://docs.microsoft.com/pl-pl/azure/active-directory/managed-identities-azure-resources/overview</a></li>
<li>RBAC authentication: <a href="https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-role-based-access-control">https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-role-based-access-control</a></li>
<li>Service Bus samples: <a href="https://github.com/Azure/azure-service-bus/tree/master/samples/DotNet">https://github.com/Azure/azure-service-bus/tree/master/samples/DotNet</a></li>
<li>Azure Service Bus design patterns: <a href="https://msdn.microsoft.com/en-us/magazine/mt845652.aspx">https://msdn.microsoft.com/en-us/magazine/mt845652.aspx</a></li>
</ul>


            </article>

            
        </section>
    </div>



  </body></html>