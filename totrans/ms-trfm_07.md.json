["```\n{\n    “Version”: “2012-10-17”,\n    “Statement”: [\n        {\n            “Effect”: “Allow”,\n            “Action”: “secretsmanager:GetSecretValue”,\n            “Resource”:\n“arn:aws:secretsmanager:region:account\nid:secret:fleetportal/*”\n        }\n    ]\n}\n```", "```\npacker {\n  required_plugins {\n    amazon = {\n      source  = “github.com/hashicorp/amazon”\n      version = “~> 1.2.6”\n    }\n  }\n}\n```", "```\ndata “amazon-ami” “ubuntu2204” {\n  filters = {\n    architecture        = “x86_64”\n    virtualization-type = “hvm”\n    root-device-type    = “ebs”\n    name                = “ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-amd64-server-*”\n  }\n  owners      = [“099720109477”]\n  most_recent = true\n  region      = var.aws_primary_region\n}\n```", "```\nsource “amazon-ebs” “vm” {\n  region        = var.aws_primary_region\n  ami_name      = “${var.image_name}-${var.image_version}”\n  instance_type = var.aws_instance_type\n  ssh_username  = “ubuntu”\n  ssh_interface = “public_ip”\n  communicator  = “ssh”\n  source_ami    = data.amazon-ami.ubuntu2204.id\n}\n```", "```\nlocals {\n  execute_command = “chmod +x {{ .Path }}; {{ .Vars }} sudo -E sh ‘{{ .Path }}’”\n}\n```", "```\nPackage: *\nPin: origin “packages.microsoft.com”\nPin-Priority: 1001\n```", "```\nprovisioner “shell” {\n  execute_command = local.execute_command\n  inline = [\n    “cp /tmp/dotnet.pref /etc/apt/preferences.d/dotnet.pref”\n  ]\n}\n```", "```\nprovisioner “shell” {\n  execute_command = local.execute_command\n  inline = [\n    “apt-get install dotnet-sdk-6.0 -y”\n  ]\n}\n```", "```\n[Unit]\nDescription=Fleet Portal\n[Service]\nWorkingDirectory=/var/www/fleet-portal\nExecStart=/usr/bin/dotnet /var/www/fleet-portal/FleetPortal.dll\nRestart=always\nRestartSec=10  # Restart service after 10 seconds if the dotnet service crashes\nSyslogIdentifier=fleet-portal\nUser=fleet-portal-svc\nEnvironment=ASPNETCORE_ENVIRONMENT=Production\nEnvironment=DOTNET_PRINT_TELEMETRY_MESSAGE=false\n[Install]\nWantedBy=multi-user.target\n```", "```\n  provisioner “shell” {\n    execute_command = local.execute_command\n    inline = [\n      “groupadd fleet-portal-svc”,\n      “useradd -g fleet-portal-svc fleet-portal-svc”,\n      “mkdir -p /var/www/fleet-portal”,\n      “chown -R fleet-portal-svc:fleet-portal-svc /var/www/fleet-portal”\n    ]\n  }\n```", "```\nprovisioner “shell” {\n  execute_command = local.execute_command\n  inline = [\n    “cp /tmp/fleet-portal.service /etc/systemd/system/fleet-portal.service”,\n    “systemctl enable fleet-portal.service”\n  ]\n}\n```", "```\nterraform {\n  required_providers {\n    aws = {\n      source  = “hashicorp/aws”\n      version = “~> 5.17”\n    }\n    cloudinit = {\n      source  = “hashicorp/cloudinit”\n      version = “~> 2.3.2”\n    }\n  }\n}\n```", "```\nprovider “aws” {\n  region = var.primary_region\n}\n```", "```\nterraform {\n  ...\n  backend “s3” {\n  }\n}\n```", "```\nresource “aws_vpc” “main” {\n  cidr_block = var.vpc_cidr_block\n  tags = {\n    Name        = “${var.application_name}-${var.environment_name}-network”\n    application = var.application_name\n    environment = var.environment_name\n  }\n}\n```", "```\nresource “aws_resourcegroups_group” “main” {\n  name = “${var.application_name}-${var.environment_name}”\n  resource_query {\n    query = jsonencode(\n      {\n        ResourceTypeFilters = [\n          “AWS::AllSupported”\n        ]\n        TagFilters = [\n          {\n            Key    = “application”\n            Values = [var.application_name]\n          },\n          {\n            Key    = “environment”\n            Values = [var.environment_name]\n          }\n        ]\n      }\n    )\n  }\n}\n```", "```\ndata “aws_availability_zones” “available” {\n  state = “available”\n}\nresource “random_shuffle” “az” {\n  input        = data.aws_availability_zones.available.names\n  result_count = var.az_count\n}\n```", "```\nlocals {\n  azs_random = random_shuffle.az.result\n  public_subnets = { for k, v in local.azs_random :\n    k => {\n      cidr_block        = cidrsubnet(var.vpc_cidr_block, var.cidr_split_bits, k)\n      availability_zone = v\n    }\n  }\n  private_subnets = { for k, v in local.azs_random :\n    k => {\n      cidr_block        = cidrsubnet(var.vpc_cidr_block, var.cidr_split_bits, k + var.az_count)\n      availability_zone = v\n    }\n  }\n}\n```", "```\npublic_subnets = {\n  “0” = {\n    “availability_zone” = “us-west-2c”\n    “cidr_block” = “10.0.0.0/24”\n  }\n  “1” = {\n    “availability_zone” = “us-west-2a”\n    “cidr_block” = “10.0.1.0/24”\n  }\n}\nprivate_subnets = {\n  “0” = {\n    “availability_zone” = “us-west-2c”\n    “cidr_block” = “10.0.2.0/24”\n  }\n  “1” = {\n    “availability_zone” = “us-west-2a”\n    “cidr_block” = “10.0.3.0/24”\n  }\n}\n```", "```\nresource “aws_subnet” “frontend” {\n  for_each = local.public_subnets\n  vpc_id            = aws_vpc.main.id\n  availability_zone = each.value.availability_zone\n  cidr_block        = each.value.cidr_block\n}\n```", "```\nresource “aws_route_table” “frontend” {\n  vpc_id = aws_vpc.main.id\n  route {\n    cidr_block = “0.0.0.0/0”\n    gateway_id = aws_internet_gateway.main.id\n  }\n}\nresource “aws_route_table_association” “frontend” {\n  for_each = aws_subnet.frontend\n  subnet_id      = each.value.id\n  route_table_id = aws_route_table.frontend.id\n}\n```", "```\nresource “aws_eip” “nat” {\n  for_each = local.private_subnets\n}\nresource “aws_nat_gateway” “nat” {\n  for_each = local.private_subnets\n  allocation_id = aws_eip.nat[each.key].id\n  subnet_id     = aws_subnet.backend[each.key].id\n  depends_on = [aws_internet_gateway.main]\n}\n```", "```\nresource “aws_route_table” “backend” {\n  for_each = local.private_subnets\n  vpc_id = aws_vpc.main.id\n  route {\n    cidr_block     = “0.0.0.0/0”\n    nat_gateway_id = aws_nat_gateway.nat[each.key].id\n  }\n}\nresource “aws_route_table_association” “backend” {\n  for_each = local.private_subnets\n  subnet_id      = aws_subnet.backend[each.key].id\n  route_table_id = aws_route_table.backend[each.key].id\n}\n```", "```\nresource “aws_lb_target_group” “frontend_http” {\n  name                          = “${var.application_name}-${var.environment_name}-frontend-http”\n  port                          = 5000\n  protocol                      = “HTTP”\n  vpc_id                        = aws_vpc.main.id\n  slow_start                    = 0\n  load_balancing_algorithm_type = “round_robin”\n  stickiness {\n    enabled = true\n    type    = “lb_cookie”\n  }\n  health_check {\n    enabled             = true\n    port                = 5000\n    interval            = 30\n    protocol            = “HTTP”\n    path                = “/”\n    matcher             = 200\n    healthy_threshold   = 3\n    unhealthy_threshold = 3\n  }\n}\n```", "```\nresource “aws_lb_target_group_attachment” “frontend_http” {\n  for_each = aws_instance.frontend\n  target_group_arn = aws_lb_target_group.frontend_http.arn\n  target_id        = each.value.id\n  port             = 5000\n}\n```", "```\nresource “aws_lb” “frontend” {\n  name               = “${var.application_name}\n${var.environment_name}-frontend”\n  internal           = false\n  load_balancer_type = “application”\n  subnets            = [for subnet in values(aws_subnet.frontend) : subnet.id]\n  security_groups    = [aws_security_group.frontend_lb.id]\n  tags = {\n    Name        = “${var.application_name}-${var.environment_name}-frontend-lb”\n    application = var.application_name\n    environment = var.environment_name\n  }\n}\n```", "```\nresource “aws_lb_listener” “frontend_http” {\n  load_balancer_arn = aws_lb.frontend.arn\n  port              = “80”\n  protocol          = “HTTP”\n  default_action {\n    type             = “forward”\n    target_group_arn =\naws_lb_target_group.frontend_http.arn\n  }\n}\n```", "```\nresource “aws_security_group” “frontend_lb” {\n  name        = “${var.application_name}-${var.environment_name}-frontend-lb-sg”\n  description = “Security group for the load balancer”\n  vpc_id      = aws_vpc.main.id\n}\n```", "```\nresource “aws_security_group_rule” “frontend_lb_ingress_http” {\n  type              = “ingress”\n  from_port         = 80\n  to_port           = 80\n  protocol          = “tcp”\n  security_group_id = aws_security_group.frontend_lb.id\n  cidr_blocks       = [“0.0.0.0/0”]\n}\nresource “aws_security_group_rule” “frontend_lb_egress_http” {\n  type                     = “egress”\n  from_port                = 5000\n  to_port                  = 5000\n  protocol                 = “tcp”\n  security_group_id        = aws_security_group.frontend_lb.id\n  source_security_group_id = aws_security_group.frontend.id\n}\n```", "```\nresource “aws_iam_role” “backend” {\n  name = “${var.application_name}-${var.environment_name}-backend”\n  assume_role_policy = jsonencode({\n    Version = “2012-10-17”\n    Statement = [\n      {\n        Action = “sts:AssumeRole”\n        Effect = “Allow”\n        Sid    = “”\n        Principal = {\n          Service = “ec2.amazonaws.com”\n        }\n      },\n    ]\n  })\n}\n```", "```\nresource “aws_iam_role_policy” “backend” {\n  name = “${var.application_name}-${var.environment_name}-backend”\n  role = aws_iam_role.backend.id\n  policy = jsonencode({\n    Version = “2012-10-17”\n    Statement = [\n      {\n        Action = [\n          “secretsmanager:GetSecretValue”,\n        ]\n        Effect   = “Allow”\n        Resource = “arn:aws:secretsmanager:secret:${var.application_name}/${var.environment_name}/*”\n      },\n    ]\n  })\n}\n```", "```\nresource “aws_network_interface” “frontend” {\n  for_each = aws_subnet.frontend\n  subnet_id = each.value.id\n}\nresource “aws_network_interface_sg_attachment” “frontend” {\n  for_each = aws_instance.frontend\n  security_group_id    = aws_security_group.frontend.id\n  network_interface_id = each.value.primary_network_interface_id\n}\n```", "```\nresource “aws_instance” “frontend” {\n  for_each = aws_subnet.frontend\n  ami           = data.aws_ami.frontend.id\n  instance_type = var.frontend_instance_type\n  key_name      = data.aws_key_pair.main.key_name\n  user_data     = data.cloudinit_config.frontend.rendered\n  monitoring    = true\n  network_interface {\n    network_interface_id = aws_network_interface.frontend[each.key].id\n    device_index         = 0\n  }\n}\n```", "```\ndata “aws_iam_policy_document” “vpc_assume_role” {\n  statement {\n    effect = “Allow”\n    principals {\n      type        = “Service”\n      identifiers = [“vpc-flow-logs.amazonaws.com”]\n    }\n    actions = [“sts:AssumeRole”]\n  }\n}\n```", "```\nresource “aws_iam_role” “vpc” {\n  name               = “${var.application_name}-${var.environment_name}-network”\n  assume_role_policy = data.aws_iam_policy_document.assume_role.json\n}\n```", "```\ndata “aws_iam_policy_document” “cloudwatch” {\n  statement {\n    effect = “Allow”\n    actions = [\n      “logs:CreateLogGroup”,\n      “logs:CreateLogStream”,\n      “logs:PutLogEvents”,\n      “logs:DescribeLogGroups”,\n      “logs:DescribeLogStreams”,\n    ]\n    resources = [“*”]\n  }\n}\n```", "```\nresource “aws_iam_role_policy” “cloudwatch” {\n  name   = “${var.application_name}-${var.environment_name}-network-cloudwatch”\n  role   = aws_iam_role.vpc.id\n  policy = data.aws_iam_policy_document.cloudwatch.json\n}\n```", "```\nresource “aws_cloudwatch_log_group” “vpc” {\n  name = “${var.application_name}-${var.environment_name}-network”\n}\n```", "```\nresource “aws_flow_log” “main” {\n  iam_role_arn    = aws_iam_role.vpc.arn\n  log_destination = aws_cloudwatch_log_group.vpc.arn\n  traffic_type    = “ALL”\n  vpc_id          = aws_vpc.main.id\n}\n```", "```\n- .github\n    - workflows\n- dotnet\n    - backend\n    - frontend\n- packer\n    - backend\n    - frontend\n- terraform\n```", "```\n- .github\n    - workflows\n        - packer-backend.yaml\n        - packer-frontend.yaml\n        - terraform-apply.yaml\n        - terraform-plan.yaml\n```", "```\non:\n  push:\n    branches: \n    - main\n    paths:\n    - ‘src/packer/frontend/**’\n    - ‘src/dotnet/frontend/**’\n```", "```\nenv:\n  DOTNET_VERSION: ‘6.0.401’ # The .NET SDK version to use\n  PACKER_VERSION: ‘1.9.4’ # The version of Packer to use\n  WORKING_DIRECTORY: “./src/packer/frontend”\n  DOTNET_WORKING_DIRECTORY: “./src/dotnet/frontend/FleetPortal”\n```", "```\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      ...\n  packer:\n    runs-on: ubuntu-latest\n    steps:\n      ...\n```", "```\n- id: image-version\n  name: Generate Version Number\n  run: |\n   echo “version=$(date +’%Y.%m’).${{ github.run_number }}” >> “$GITHUB_OUTPUT”\n```", "```\n- id: agent-ipaddress\n  name: Check Path\n  working-directory: ${{ env.WORKING_DIRECTORY }}\n  run: |\n    ipaddress=$(curl -s http://checkip.amazonaws.com)\n    echo $ipaddress\n    echo “ipaddress=$ipaddress” >> “$GITHUB_OUTPUT”\n```", "```\n- id: setup\n  name: Setup `packer`\n  uses: hashicorp/setup-packer@main\n  with:\n    version: ${{ env.PACKER_VERSION }}\n```", "```\n- id: build\n  name: Packer Build\n  env:\n    AWS_ACCESS_KEY_ID: ${{ vars.AWS_ACCESS_KEY_ID }}\n    AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n    PKR_VAR_image_version: ${{ steps.image-version.outputs.version }}\n    PKR_VAR_agent_ipaddress: ${{ steps.agent-ipaddress.outputs.ipaddress }}\n  working-directory: ${{ env.WORKING_DIRECTORY }}\n  run: |\n    packer init ./\n    packer build -var-file=variables.pkrvars.hcl ./\n```", "```\non:\n  push:\n    branches: \n    - main\n    paths:\n    - ‘src/terraform/**’\n```", "```\nenv:\n  TERRAFORM_VERSION: ‘1.5.7’\n  WORKING_DIRECTORY: “./src/terraform”\n```", "```\n    - id: setup\n      name: Setup `terraform`\n      uses: hashicorp/setup-terraform@main\n      with:\n        version: ${{ env.TERRAFORM_VERSION }}\n```", "```\n- id: apply\n  name: Terraform Apply\n  env:\n    AWS_ACCESS_KEY_ID: ${{ vars.AWS_ACCESS_KEY_ID }}\n    AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n    BACKEND_BUCKET_NAME: ${{ vars.BUCKET_NAME }}\n    BACKEND_REGION: ${{ vars.BUCKET_REGION }}\n  working-directory: ${{ env.WORKING_DIRECTORY }}\n  run: |\n    terraform init \\\n      -backend-config=’bucket=’$BACKEND_BUCKET_NAME \\\n      -backend-config=’region=’$BACKEND_REGION \\\n      -backend-config=”key=aws-vm-sample”\n    terraform apply -target “random_shuffle.az” -auto-approve\n    terraform apply -auto-approve\n```"]