<html><head></head><body>
<div id="_idContainer154">
<h1 class="chapter-number" id="_idParaDest-221"><a id="_idTextAnchor543"/><span class="koboSpan" id="kobo.1.1">12</span></h1>
<h1 id="_idParaDest-222"><a id="_idTextAnchor544"/><span class="koboSpan" id="kobo.2.1">Go Serverless on Azure – Building Solutions with Azure Functions</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Are you ready? </span><span class="koboSpan" id="kobo.3.2">We are about to turn the page on Microsoft Azure – but only after we take the final step of transitioning our application to Serverless architecture. </span><span class="koboSpan" id="kobo.3.3">Like we did on the </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">Amazon Web Services</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">AWS</span></strong><span class="koboSpan" id="kobo.7.1">) platform, in the last two chapters, we worked hard to implement our solution on Microsoft Azure using </span><strong class="bold"><span class="koboSpan" id="kobo.8.1">virtual machines</span></strong><span class="koboSpan" id="kobo.9.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.10.1">VMs</span></strong><span class="koboSpan" id="kobo.11.1">) and </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">then containers.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">We’ve taken time to do some comparisons between how things work on AWS and Microsoft Azure to help us understand the subtle and sometimes not-so-subtle differences between the </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">cloud platforms.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">We’ve noticed that while our Terraform code has been changing pretty consistently between cloud platforms, our application code and the operating system configuration – either in Packer or Docker – haven’t. </span><span class="koboSpan" id="kobo.15.2">As we take our final step with Microsoft Azure, we’ll be going through a similar process to what we went through when we transitioned our application to </span><strong class="bold"><span class="koboSpan" id="kobo.16.1">AWS Lambda</span></strong><span class="koboSpan" id="kobo.17.1">. </span><span class="koboSpan" id="kobo.17.2">We’ll have to completely refactor the </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">application code.</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">This chapter covers the </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.21.1">Laying </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">the foundation</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Designing </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">the solution</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Building </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">the solution</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">Automating </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">the deployment</span></span></li>
</ul>
<h1 id="_idParaDest-223"><a id="_idTextAnchor545"/><span class="koboSpan" id="kobo.29.1">Laying the foundation</span></h1>
<p><span class="koboSpan" id="kobo.30.1">Our story continues through the lens</span><a id="_idIndexMarker922"/><span class="koboSpan" id="kobo.31.1"> of Söze Enterprises, founded by the enigmatic Turkish billionaire Keyser Söze. </span><span class="koboSpan" id="kobo.31.2">Our team has been hard at work building the next-generation autonomous vehicle orchestration platform. </span><span class="koboSpan" id="kobo.31.3">Our initial strategy involved minimizing change to allow the team to focus on driving features into our product. </span><span class="koboSpan" id="kobo.31.4">However, our elusive CEO had other ideas and pushed us to adopt container technology to make our product more flexible and scalable going forward. </span><span class="koboSpan" id="kobo.31.5">Working with Keyser, there is never a dull moment, but managing such radical change so quickly can </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">be frustrating.</span></span></p>
<p><span class="koboSpan" id="kobo.33.1">Meanwhile, in St. </span><span class="koboSpan" id="kobo.33.2">Barts, with the sun setting over the Caribbean and the cocktail party in full swing, Keyser has a chance encounter at the bar with Mark Russinovich, the CTO of Microsoft Azure. </span><span class="koboSpan" id="kobo.33.3">They immediately hit it off, chatting over mojitos. </span><span class="koboSpan" id="kobo.33.4">When Mark gets a glimpse of Keyser’s immense vision for the autonomous vehicle platform, he casually suggests that maybe Keyser shouldn’t concern himself with infrastructure at all. </span><span class="koboSpan" id="kobo.33.5">Mark explains how leveraging Azure Functions and other serverless offerings could free him from the shackles of infrastructure management, allowing him to focus entirely on his </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">grand vision.</span></span></p>
<p><span class="koboSpan" id="kobo.35.1">Thanks to Mark’s insights and Keyser’s whimsical</span><a id="_idIndexMarker923"/><span class="koboSpan" id="kobo.36.1"> decision-making, our team veers</span><a id="_idIndexMarker924"/><span class="koboSpan" id="kobo.37.1"> deeper into Microsoft Azure, explicitly transitioning from </span><strong class="bold"><span class="koboSpan" id="kobo.38.1">Azure Kubernetes Service</span></strong><span class="koboSpan" id="kobo.39.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.40.1">AKS</span></strong><span class="koboSpan" id="kobo.41.1">) to </span><strong class="bold"><span class="koboSpan" id="kobo.42.1">Azure Functions</span></strong><span class="koboSpan" id="kobo.43.1"> for serverless computing. </span><span class="koboSpan" id="kobo.43.2">This might require a complete re-think of our application architecture, but it could free </span><a id="_idIndexMarker925"/><span class="koboSpan" id="kobo.44.1">us from the significant operational overhead of managing </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">low-level infrastructure.</span></span></p>
<h1 id="_idParaDest-224"><a id="_idTextAnchor546"/><span class="koboSpan" id="kobo.46.1">Designing the solution</span></h1>
<p><span class="koboSpan" id="kobo.47.1">In this section, we will be taking</span><a id="_idIndexMarker926"/><span class="koboSpan" id="kobo.48.1"> a look at the overall design of our solution, given the shift from VM and container-based architectures toward serverless architectures. </span><span class="koboSpan" id="kobo.48.2">As we saw in </span><a href="B21183_09.xhtml#_idTextAnchor446"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.49.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.50.1">, at its core, serverless has a quintessential objective of eliminating heavy infrastructure from the stack. </span><span class="koboSpan" id="kobo.50.2">Therefore, we will be looking for ways to shed any Azure services that require significant fixed costs, such as VMs or Kubernetes clusters, and replace them with serverless options. </span><span class="koboSpan" id="kobo.50.3">This change in our operational context and technology landscape will likely require us to rethink some things about our solution, both in terms of its design, implementation, and </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">deployment strategy:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer143">
<span class="koboSpan" id="kobo.52.1"><img alt="Figure 12.1 – Logical architecture for the autonomous vehicle platform" src="image/B21183_12_1.0.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.53.1">Figure 12.1 – Logical architecture for the autonomous vehicle platform</span></p>
<p><span class="koboSpan" id="kobo.54.1">Our application’s architecture doesn’t change significantly, but we will be using different Azure services to host it. </span><span class="koboSpan" id="kobo.54.2">In this case, we’ll be using Azure Storage to host the application’s frontend, and we’ll be using Azure Functions to host the </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">application’s backend:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer144">
<span class="koboSpan" id="kobo.56.1"><img alt="Figure 12.2 – Source control structure of our repository" src="image/B21183_12_2.0.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.57.1">Figure 12.2 – Source control structure of our repository</span></p>
<p><span class="koboSpan" id="kobo.58.1">In this solution, our code base will consist of four parts. </span><span class="koboSpan" id="kobo.58.2">First, we’ll have the Terraform code that provisions the environment</span><a id="_idIndexMarker927"/><span class="koboSpan" id="kobo.59.1"> and the GitHub Actions code that executes the deployment process. </span><span class="koboSpan" id="kobo.59.2">Then, we’ll have the two code bases for our application’s frontend </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">and backe</span><a id="_idTextAnchor547"/><span class="koboSpan" id="kobo.61.1">nd.</span></span></p>
<h2 id="_idParaDest-225"><a id="_idTextAnchor548"/><span class="koboSpan" id="kobo.62.1">Cloud architecture</span></h2>
<p><span class="koboSpan" id="kobo.63.1">In </span><a href="B21183_10.xhtml#_idTextAnchor474"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.64.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.65.1">, our cloud-hosting solution</span><a id="_idIndexMarker928"/><span class="koboSpan" id="kobo.66.1"> was a set of dedicated</span><a id="_idIndexMarker929"/><span class="koboSpan" id="kobo.67.1"> VMs, and in </span><a href="B21183_11.xhtml#_idTextAnchor509"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.68.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.69.1">, it was a set of shared VMs within our Kubernetes cluster’s node pool. </span><span class="koboSpan" id="kobo.69.2">Using VMs has the most sunk cost, whether they are standalone VMs or part of a Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">node pool.</span></span></p>
<p><span class="koboSpan" id="kobo.71.1">In </span><a href="B21183_11.xhtml#_idTextAnchor509"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.72.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.73.1">, our entire solution was executed on containers that allowed the frontend and the backend to coexist as a set of containers on the same VMs. </span><span class="koboSpan" id="kobo.73.2">This saved us some money, but we still needed servers to host the workload. </span><span class="koboSpan" id="kobo.73.3">In this chapter, we have a new objective: to take advantage of the power of the cloud by leveraging cloud-native services that abstract the underlying infrastructure from us and allow us to truly pay for only what we use. </span><span class="koboSpan" id="kobo.73.4">Azure’s serverless offerings will be crucial to us in </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">this ende</span><a id="_idTextAnchor549"/><span class="koboSpan" id="kobo.75.1">avor.</span></span></p>
<h3><span class="koboSpan" id="kobo.76.1">Frontend</span></h3>
<p><span class="koboSpan" id="kobo.77.1">In previous chapters, we hosted </span><a id="_idIndexMarker930"/><span class="koboSpan" id="kobo.78.1">our frontend on public-facing servers that returned the HTML and JavaScript that composed our web application. </span><span class="koboSpan" id="kobo.78.2">There, we still required a cloud-hosted solution to host the files and respond </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">to requests.</span></span></p>
<p><span class="koboSpan" id="kobo.80.1">However, due to the nature of the web application running within the end user’s browser, we don’t need to use cloud-hosted VMs to host what are essentially flat files. </span><span class="koboSpan" id="kobo.80.2">We can use simple cloud storage to host the frontend as a static website and rely on the cloud platform to shoulder the burden of returning the </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">web content.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">For this, we can use Azure Storage. </span><span class="koboSpan" id="kobo.82.2">This service has several different storage capabilities built into it, but for our static website, we’ll be using Azure Blob storage. </span><span class="koboSpan" id="kobo.82.3">Blob storage allows us to host static web content that is internet accessible, and Azure Storage handles all the load balancing, SSL termination, and scaling up to meet huge spikes </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">in demand:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer145">
<span class="koboSpan" id="kobo.84.1"><img alt="Figure 12.3 – Azure Storage handles web page requests, while Azure Functions handles REST API requests" src="image/B21183_12_3.0.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.85.1">Figure 12.3 – Azure Storage handles web page requests, while Azure Functions handles REST API requests</span></p>
<p><span class="koboSpan" id="kobo.86.1">To do this, we’ll need to have an </span><strong class="bold"><span class="koboSpan" id="kobo.87.1">Azure Storage</span></strong><span class="koboSpan" id="kobo.88.1"> account and enable</span><a id="_idIndexMarker931"/><span class="koboSpan" id="kobo.89.1"> the static websites feature. </span><span class="koboSpan" id="kobo.89.2">This will create</span><a id="_idIndexMarker932"/><span class="koboSpan" id="kobo.90.1"> a special storage container called </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">$web</span></strong><span class="koboSpan" id="kobo.92.1"> to where we can publish the web content. </span><span class="koboSpan" id="kobo.92.2">All Azure Storage accounts have an internet-accessible public domain. </span><span class="koboSpan" id="kobo.92.3">When we activate the static websites feature of Azure Storage, internet traffic gets routed to content hosted in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">$web</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.94.1">storage container.</span></span></p>
<p><span class="koboSpan" id="kobo.95.1">This will give us a huge advantage because Azure Storage has absolutely no sunk costs. </span><span class="koboSpan" id="kobo.95.2">When you create an Azure Storage account, it costs you absolutely zero dollars ($0) per month. </span><span class="koboSpan" id="kobo.95.3">Like other serverless offerings, it uses a set of micro-transactions to measure your activity and charge</span><a id="_idIndexMarker933"/><span class="koboSpan" id="kobo.96.1"> you for precisely what you use. </span><span class="koboSpan" id="kobo.96.2">In </span><strong class="bold"><span class="koboSpan" id="kobo.97.1">Azure Blob storage</span></strong><span class="koboSpan" id="kobo.98.1">, this can be a bit complicated as several measurements </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">incur costs.</span></span></p>
<p><span class="koboSpan" id="kobo.100.1">The following table shows all the costs you will run into when using Azure Storage to host your </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">static websites:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-3">
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.102.1">Metric</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.103.1">Unit</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.104.1">Scale</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.105.1">Price</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.106.1">Storage</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.107.1">GBs</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.108.1">1,000</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.109.1">$</span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">0.0518</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.111.1">Read transactions</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.112.1">Transactions</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.113.1">10,000</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.114.1">$</span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">0.004</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.116.1">Write transactions</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.117.1">Transactions</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.118.1">10,000</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.119.1">$</span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">0.1125</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.121.1">Other operations</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.122.1">Transactions</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.123.1">10,000</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.124.1">$</span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">0.004</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.126.1">Table 12.1 – Azure Storage micro-transactional pricing</span></p>
<p><span class="koboSpan" id="kobo.127.1">The pricing I chose is the most expensive option with geo-redundant, zone-redundant storage with additional read-only access in an alternate region. </span><span class="koboSpan" id="kobo.127.2">The prices that are listed here are for Azure’s West US 2 region, though the prices may have changed by the time you are reading this, so it’s best to check the latest prices for the most accurate </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">cost estimation.</span></span></p>
<p><span class="koboSpan" id="kobo.129.1">I included these prices to make a point. </span><span class="koboSpan" id="kobo.129.2">We can host a static website on a three-node Kubernetes cluster for approximately $300 a month or we can host a static website on Azure Storage for less than $0.01 a month on the most rock-solid storage tier that Azure has to offer. </span><span class="koboSpan" id="kobo.129.3">Which approach</span><a id="_idIndexMarker934"/><span class="koboSpan" id="kobo.130.1"> would </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">you choose?</span></span><a id="_idTextAnchor550"/></p>
<h3><span class="koboSpan" id="kobo.132.1">Backend</span></h3>
<p><span class="koboSpan" id="kobo.133.1">Like our frontend, in previous</span><a id="_idIndexMarker935"/><span class="koboSpan" id="kobo.134.1"> chapters, our backend was also hosted on VMs in two different ways: dedicated VMs and shared VMs within the node pool on our </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">Kubernetes cluster.</span></span></p>
<p><span class="koboSpan" id="kobo.136.1">Unlike the frontend, our backend doesn’t have the option of running entirely client-side inside the end user’s web browser. </span><span class="koboSpan" id="kobo.136.2">In the backend, we have custom code that needs to run on a server. </span><span class="koboSpan" id="kobo.136.3">Therefore, we need to find a solution to host these components without all the overhead of a fleet </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">of VMs.</span></span></p>
<p><span class="koboSpan" id="kobo.138.1">On Azure, we can use Azure Functions to accomplish this. </span><span class="koboSpan" id="kobo.138.2">Azure Functions is a managed service that allows you to deploy your code without paying the sunk costs for any of the underlying VMs. </span><span class="koboSpan" id="kobo.138.3">Like Azure Storage, it has a micro-transactional pricing model that charges you for precisely what </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">you use.</span></span></p>
<p><span class="koboSpan" id="kobo.140.1">The following table shows the costs that you will incur when deploying your code to </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">Azure Functions:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table002-2">
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.142.1">Metric</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.143.1">Unit</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.144.1">Scale</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.145.1">Price</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.146.1">Execution time</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.147.1">GB/s</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.148.1">1</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.149.1">$</span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">0.000016</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.151.1">Total executions</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.152.1">Transactions</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.153.1">1,000,000</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.154.1">$</span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">0.020</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.156.1">Table 12.2 – Azure Functions micro-transactional pricing</span></p>
<p><span class="koboSpan" id="kobo.157.1">The first thing that you’ll probably notice is that, like Azure Storage, these prices are extremely small but they measure a very small amount of activity on </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">the platform.</span></span></p>
<p><span class="koboSpan" id="kobo.159.1">For example, the execution time metric has a unit of GB/s, which is the amount of memory, in gigabytes, your Azure Function uses per second. </span><span class="koboSpan" id="kobo.159.2">Given that it measures at a </span><em class="italic"><span class="koboSpan" id="kobo.160.1">per-second</span></em><span class="koboSpan" id="kobo.161.1"> interval, you don’t have to be running Azure Functions very long to rack up quite a few </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">of these.</span></span></p>
<p><span class="koboSpan" id="kobo.163.1">The total executions is a rather</span><a id="_idIndexMarker936"/><span class="koboSpan" id="kobo.164.1"> simple metric that seemingly has no constraints, but Azure Functions have natural constraints built into them. </span><span class="koboSpan" id="kobo.164.2">For example, each of these executions is limited to 10 minutes. </span><span class="koboSpan" id="kobo.164.3">Now, if you are trying to respond to requests from a web application, you probably won’t want to design your Azure Function to take 10 minutes anyway, as this would be a pretty poor experience for the end user using the web browser. </span><span class="koboSpan" id="kobo.164.4">In this scenario, you want your Azure Function to return in no more than a few seconds. </span><span class="koboSpan" id="kobo.164.5">However, Azure Functions can be employed for many different tasks besides responding to HTTP requests from a browser, and sometimes, it makes sense to run long-running activities. </span><span class="koboSpan" id="kobo.164.6">For those situations, you can opt to host your Azure Functions on a Premium Azure Functions service plan. </span><span class="koboSpan" id="kobo.164.7">This removes the execution length duration because rather than paying per transaction, you are essentially </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">reserving capacity.</span></span></p>
<p><span class="koboSpan" id="kobo.166.1">Azure Functions have multiple hosting options. </span><span class="koboSpan" id="kobo.166.2">There is the </span><strong class="bold"><span class="koboSpan" id="kobo.167.1">Premium service plan</span></strong><span class="koboSpan" id="kobo.168.1"> that we discussed previously, which</span><a id="_idIndexMarker937"/><span class="koboSpan" id="kobo.169.1"> allows you to reserve capacity, connect to private networks, remove the 10-minute cap on Azure Function execution duration, and allow your Azure Functions to run up to 60 minutes. </span><span class="koboSpan" id="kobo.169.2">These Premium plans have sunk cost as you are pre-allocating Azure resources to ensure your Azure Functions operate at maximum performance. </span><span class="koboSpan" id="kobo.169.3">You can even select different hardware configurations (CPU and memory) to better fit your </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">workload’s needs:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer146">
<span class="koboSpan" id="kobo.171.1"><img alt="Figure 12.4 – Azure Functions are deployed to Function Apps, which are hosted on App Service plans" src="image/B21183_12_4.0.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.172.1">Figure 12.4 – Azure Functions are deployed to Function Apps, which are hosted on App Service plans</span></p>
<p><span class="koboSpan" id="kobo.173.1">In stark contrast, there is the </span><strong class="bold"><span class="koboSpan" id="kobo.174.1">Consumption service plan</span></strong><span class="koboSpan" id="kobo.175.1">, which has no sunk cost but more constraints</span><a id="_idIndexMarker938"/><span class="koboSpan" id="kobo.176.1"> on usage and no control over scaling and resource configuration of the host environment. </span><span class="koboSpan" id="kobo.176.2">The Consumption service plan is a good place to do development and testing, but if you’re going to run production workloads, I’d highly recommend sticking with a Premium </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">service plan.</span></span></p>
<p><span class="koboSpan" id="kobo.178.1">Previously, our ASP.NET REST API was set up using a traditional ASP.NET project that used controllers to implement the REST API endpoints. </span><span class="koboSpan" id="kobo.178.2">However, when transitioning to Azure Functions, this solution structure is incompatible with the Azure Functions framework. </span><span class="koboSpan" id="kobo.178.3">To be able to host our REST API as Azure Functions, we need to conform to the framework that Azure Functions dictates. </span><span class="koboSpan" id="kobo.178.4">This means that the ASP.NET controller classes will need to be refactored so that they conform to this standard. </span><span class="koboSpan" id="kobo.178.5">In the next section, we’ll delve into the code</span><a id="_idIndexMarker939"/><span class="koboSpan" id="kobo.179.1"> that makes </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">this possibl</span><a id="_idTextAnchor551"/><span class="koboSpan" id="kobo.181.1">e.</span></span></p>
<h2 id="_idParaDest-226"><a id="_idTextAnchor552"/><span class="koboSpan" id="kobo.182.1">Deployment architecture</span></h2>
<p><span class="koboSpan" id="kobo.183.1">Now that we have a good</span><a id="_idIndexMarker940"/><span class="koboSpan" id="kobo.184.1"> idea of what our cloud architecture is going to look like for our solution on Azure, we need to come up with a plan for how to provision our environments and deploy </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">our code.</span></span></p>
<p><span class="koboSpan" id="kobo.186.1">In </span><a href="B21183_10.xhtml#_idTextAnchor474"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.187.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.188.1">, when we deployed our application to VMs, we baked our compiled application code into a VM image using Packer. </span><span class="koboSpan" id="kobo.188.2">Similarly, in </span><a href="B21183_11.xhtml#_idTextAnchor509"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.189.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.190.1">, when we deployed our application to containers on our Kubernetes cluster, we baked our application code into container images using Docker. </span><span class="koboSpan" id="kobo.190.2">With serverless, this completely changes because Azure’s serverless offerings completely abstract away the operating system. </span><span class="koboSpan" id="kobo.190.3">This means that</span><a id="_idIndexMarker941"/><span class="koboSpan" id="kobo.191.1"> all we are responsible for is producing a compatible </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">deployment pack</span><a id="_idTextAnchor553"/><span class="koboSpan" id="kobo.193.1">age.</span></span></p>
<h3><span class="koboSpan" id="kobo.194.1">Creating the deployment package</span></h3>
<p><span class="koboSpan" id="kobo.195.1">As we discussed in the previous</span><a id="_idIndexMarker942"/><span class="koboSpan" id="kobo.196.1"> section, we have two components of our application: the frontend and the backend. </span><span class="koboSpan" id="kobo.196.2">Each has a different deployment target. </span><span class="koboSpan" id="kobo.196.3">We are going to deploy the frontend as a static website, while the backend is going to be deployed as an Azure Function. </span><span class="koboSpan" id="kobo.196.4">Since both are .NET projects, we will be using both .NET and Azure platform-specific tools to create deployment packages and deploy them to their target Azure services. </span><span class="koboSpan" id="kobo.196.5">The following diagram shows the process we’ll go through to provision our environment, package our application code, and deploy it to the target environment out </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">in Azure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer147">
<span class="koboSpan" id="kobo.198.1"><img alt="Figure 12.5 – Deployment pipeline to build our .NET application code for deployment to Azure" src="image/B21183_12_5.0.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.199.1">Figure 12.5 – Deployment pipeline to build our .NET application code for deployment to Azure</span></p>
<p><span class="koboSpan" id="kobo.200.1">For the frontend, this means enabling the feature to deploy our ASP.NET Blazor web application as a WebAssembly. </span><span class="koboSpan" id="kobo.200.2">This will allow the frontend to be hosted as a static website that can run completely client-side without any server-side rendering. </span><span class="koboSpan" id="kobo.200.3">This is only possible because of the way we have designed our frontend web application, which uses HTML, CSS, and JavaScript to interact with server-side REST APIs. </span><span class="koboSpan" id="kobo.200.4">It’s important to note that ASP.NET Blazor supports both hosting options, but we specifically chose to go down the client-side-only path and eliminate any dependency on server-side page rendering. </span><span class="koboSpan" id="kobo.200.5">As a result, when we use the .NET CLI to publish our ASP.NET Blazor project, it will emit a folder containing static web content. </span><span class="koboSpan" id="kobo.200.6">Then, using the Azure CLI, we can upload the contents of this folder to our Azure Blob storage account’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">$web</span></strong><span class="koboSpan" id="kobo.202.1"> container to complete </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">the deployment.</span></span></p>
<p><span class="koboSpan" id="kobo.204.1">For the backend, again using the .NET CLI, we need to publish our project. </span><span class="koboSpan" id="kobo.204.2">This will emit all the files needed to properly inform the Azure Functions service about our little Azure Function. </span><span class="koboSpan" id="kobo.204.3">Once this is done, we need to zip this folder up into a zip archive. </span><span class="koboSpan" id="kobo.204.4">Finally, we can use the Azure CLI to deploy this zip archive to our </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">Azure Funct</span><a id="_idTextAnchor554"/><span class="koboSpan" id="kobo.206.1">ion.</span></span></p>
<p><span class="koboSpan" id="kobo.207.1">Now that we have a solid plan for how we will implement both the cloud architecture using Azure and the deployment architecture using GitHub Actions, let’s start building! </span><span class="koboSpan" id="kobo.207.2">In the next section, we’ll break down the </span><strong class="bold"><span class="koboSpan" id="kobo.208.1">HashiCorp Configuration Language</span></strong><span class="koboSpan" id="kobo.209.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.210.1">HCL</span></strong><span class="koboSpan" id="kobo.211.1">) code we can use to implement</span><a id="_idIndexMarker943"/><span class="koboSpan" id="kobo.212.1"> the Terraform code and modify the application code so that it conforms</span><a id="_idIndexMarker944"/><span class="koboSpan" id="kobo.213.1"> to the Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">Functions framework.</span></span></p>
<h1 id="_idParaDest-227"><a id="_idTextAnchor555"/><span class="koboSpan" id="kobo.215.1">Building the solution</span></h1>
<p><span class="koboSpan" id="kobo.216.1">Now that we have a solid design</span><a id="_idIndexMarker945"/><span class="koboSpan" id="kobo.217.1"> for our solution, we can begin building it. </span><span class="koboSpan" id="kobo.217.2">As we discussed in the previous section, because we’ll be using Azure serverless offerings such as Azure Storage and Azure Functions to host our application, we will need to make some changes to our application code. </span><span class="koboSpan" id="kobo.217.3">This is something that we never had to do in </span><em class="italic"><span class="koboSpan" id="kobo.218.1">Chapters 10</span></em><span class="koboSpan" id="kobo.219.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.220.1">11</span></em><span class="koboSpan" id="kobo.221.1"> as we were able to deploy our application to the cloud by packaging it in either a VM image (using Packer) or in a container image (using Docker). </span><span class="koboSpan" id="kobo.221.2">Therefore, to build our solution, we need to write some Terraform code and update our application code</span><a id="_idTextAnchor556"/> <span class="No-Break"><span class="koboSpan" id="kobo.222.1">in C#.</span></span></p>
<h2 id="_idParaDest-228"><a id="_idTextAnchor557"/><span class="koboSpan" id="kobo.223.1">Terraform</span></h2>
<p><span class="koboSpan" id="kobo.224.1">As we discussed in our design, our solution</span><a id="_idIndexMarker946"/><span class="koboSpan" id="kobo.225.1"> is made up of two</span><a id="_idIndexMarker947"/><span class="koboSpan" id="kobo.226.1"> application components: the frontend and the backend. </span><span class="koboSpan" id="kobo.226.2">Each has a code base of application code that needs to be deployed. </span><span class="koboSpan" id="kobo.226.3">Unlike previous chapters, where we had operating system configuration as well, now that we are using serverless offerings, this is no longer our responsibility as the platform takes care of it </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">for us.</span></span></p>
<p><span class="koboSpan" id="kobo.228.1">Much of the Terraform setup is very similar to what we have done in previous chapters, so we will only focus on new resources needed for our solution. </span><span class="koboSpan" id="kobo.228.2">You can check the full source code for this book, which is available</span><a id="_idIndexMarker948"/><span class="koboSpan" id="kobo.229.1"> in this book’s GitHub repository, if you want to work with the </span><a id="_idIndexMarker949"/><span class="No-Break"><span class="koboSpan" id="kobo.230.1">complete solution.</span></span></p>
<h3><span class="koboSpan" id="kobo.231.1">Frontend</span></h3>
<p><span class="koboSpan" id="kobo.232.1">First, we need to provision</span><a id="_idIndexMarker950"/><span class="koboSpan" id="kobo.233.1"> a storage account where we can deploy our frontend to. </span><span class="koboSpan" id="kobo.233.2">The Azure Storage account is one of the most common Terraform resources to be provisioned as many other Azure services use storage accounts for different purposes. </span><span class="koboSpan" id="kobo.233.3">However, we need to configure our storage account differently by using an optional block called </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">static_website</span></strong><span class="koboSpan" id="kobo.235.1">. </span><span class="koboSpan" id="kobo.235.2">This block will enable the static website feature and will place the </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">$web</span></strong><span class="koboSpan" id="kobo.237.1"> container in our storage account </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">by default:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.239.1">
resource "azurerm_storage_account" "frontend" {
  name                     = "st${var.application_name}${var.environment_name}${random_string.main.result}"
  resource_group_name      = azurerm_resource_group.main.name
  location                 = azurerm_resource_group.main.location
  account_tier             = "Standard"
  account_replication_type = "LRS"
  static_website {
    index_document     = "index.html"
    error_404_document = "404.html"
  }
}</span></pre> <h3><span class="koboSpan" id="kobo.240.1">Backend</span></h3>
<p><span class="koboSpan" id="kobo.241.1">Azure Functions are deployed </span><a id="_idIndexMarker951"/><span class="koboSpan" id="kobo.242.1">to a resource called a function app. </span><span class="koboSpan" id="kobo.242.2">They come</span><a id="_idIndexMarker952"/><span class="koboSpan" id="kobo.243.1"> in two varieties – one for Windows and another for Linux. </span><span class="koboSpan" id="kobo.243.2">This can be quite perplexing – isn’t the whole purpose of using a serverless offering so that you don’t have to think about the operating system? </span><span class="koboSpan" id="kobo.243.3">However, the underlying operating system can impact the types of runtimes that are supported for your </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">Azure Function.</span></span></p>
<p><span class="koboSpan" id="kobo.245.1">To provide a function app, we need to have a service plan. </span><span class="koboSpan" id="kobo.245.2">As we mentioned in the previous section, there are multiple types of service plans. </span><span class="koboSpan" id="kobo.245.3">The two main types are Consumption and Premium. </span><span class="koboSpan" id="kobo.245.4">To use a Consumption service plan, you need to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">Y1</span></strong><span class="koboSpan" id="kobo.247.1"> as the SKU name, and to use a Premium service plan, you need to use either </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">EP1</span></strong><span class="koboSpan" id="kobo.249.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">EP2</span></strong><span class="koboSpan" id="kobo.251.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">EP3</span></strong><span class="koboSpan" id="kobo.253.1">. </span><span class="koboSpan" id="kobo.253.2">Each of the Premium service plan SKUs has a different set of compute and </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">memory resources:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.255.1">
resource "azurerm_service_plan" "consumption" {
  name                = "asp-${var.application_name}-${var.environment_name}-${random_string.main.result}"
  resource_group_name = azurerm_resource_group.main.name
  location            = azurerm_resource_group.main.location
  os_type             = var.function_app_os_type
  sku_name            = var.function_app_sku
}</span></pre> <p><span class="koboSpan" id="kobo.256.1">Now that we have a service plan, we can provision one or more function apps for it. </span><span class="koboSpan" id="kobo.256.2">The function apps do not need to share the same resource group, so you could have a central team manage the service plans and have each team manage its own function apps that are hosted within the </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">service plan:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.258.1">
resource "azurerm_windows_function_app" "main" {
  name                       = "func-${var.application_name}-${var.environment_name}-${random_string.main.result}"
  resource_group_name        = azurerm_resource_group.main.name
  location                   = azurerm_resource_group.main.location
  service_plan_id            = azurerm_service_plan.consumption.id
  storage_account_name       = azurerm_storage_account.function.name
  storage_account_access_key = azurerm_storage_account.function.primary_access_key
  site_config {
    application_stack {
      dotnet_version = "v6.0"
    }
    cors {
      allowed_origins     = ["https://portal.azure.com"]
      support_credentials = true
    }
  }
}</span></pre> <p><span class="koboSpan" id="kobo.259.1">The important thing</span><a id="_idIndexMarker953"/><span class="koboSpan" id="kobo.260.1"> is that the operating system of the service plan should match the function app’s Terraform resource type. </span><span class="koboSpan" id="kobo.260.2">Only </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">azurerm_windows_function_app</span></strong><span class="koboSpan" id="kobo.262.1"> resources should be provisioned to service plans with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">os_type</span></strong><span class="koboSpan" id="kobo.264.1"> value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">Windows</span></strong><span class="koboSpan" id="kobo.266.1">, and likewise, only </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">azurerm_linux_function_app</span></strong><span class="koboSpan" id="kobo.268.1"> resources should be provisioned to service plans with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">os_type</span></strong><span class="koboSpan" id="kobo.270.1"> value </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">Linux</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.274.1">The function app also needs a storage account to be provisioned. </span><span class="koboSpan" id="kobo.274.2">This should be different than the storage account that’s used to provision the frontend. </span><span class="koboSpan" id="kobo.274.3">While it’s a common practice to provision a dedicated storage account for the function app, it’s technically possible to use the same storage account for both the function app and the frontend. </span><span class="koboSpan" id="kobo.274.4">However, given that there is no additional cost for an additional storage account, you only pay for the storage. </span><span class="koboSpan" id="kobo.274.5">I recommend provisioning a dedicated storage account to keep the separation</span><a id="_idIndexMarker954"/><span class="koboSpan" id="kobo.275.1"> between the two components of </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">yo</span><a id="_idTextAnchor558"/><span class="koboSpan" id="kobo.277.1">ur architecture.</span></span></p>
<h3><span class="koboSpan" id="kobo.278.1">Secrets management</span></h3>
<p><span class="koboSpan" id="kobo.279.1">An important block</span><a id="_idIndexMarker955"/><span class="koboSpan" id="kobo.280.1"> for a function app is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">app_settings</span></strong><span class="koboSpan" id="kobo.282.1"> block. </span><span class="koboSpan" id="kobo.282.2">This is where we can pass secrets to our Azure Functions, as well as other parameters that affect our deployment strategy and other </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">runtime configurations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.284.1">
  app_settings = {
    "SCM_DO_BUILD_DURING_DEPLOYMENT" = "false"
    "WEBSITE_RUN_FROM_PACKAGE"       = "1"
    "STORAGE_CONNECTION_STRING"      = azurerm_storage_account.function.primary_connection_string
    "QUEUE_CONNECTION_STRING"        = azurerm_storage_account.function.primary_connection_string
  }</span></pre> <p><span class="koboSpan" id="kobo.285.1">Here, we are setting the connection string for the Azure Storage account that we will use to connect to blob and queue storage within the application. </span><span class="koboSpan" id="kobo.285.2">We can also use Key Vault to store these secrets using </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">special syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.287.1">
@Microsoft.KeyVault(VaultName=kv-fleetops-dev;SecretName=QUEUE_CONNECTION_STRING)</span></pre> <p><span class="koboSpan" id="kobo.288.1">If we replace the previous setting with the new one, we will no longer store the secret in the Azure Function app. </span><span class="koboSpan" id="kobo.288.2">The secret is only in </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">Key Vault:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.290.1">
  app_settings = {
    "QUEUE_CONNECTION_STRING" = "@Microsoft.KeyVault(VaultName=${azurerm_keyvault.main.name};SecretName=${azurerm_keyvault_secret.queue_connection_string.name})"
  }</span></pre> <p><span class="koboSpan" id="kobo.291.1">This also requires us to set up a role assignment to grant the Azure Function’s user-assigned identity the necessary permissions to access the secrets stored in Key Vault. </span><span class="koboSpan" id="kobo.291.2">Without this necessary role assignment, even if we use the special syntax to refer to the Key Vault secret correctly, Azure Functions will not be able to access </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">the secrets:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer148">
<span class="koboSpan" id="kobo.293.1"><img alt="Figure 12.6 – The structure of Azure Functions resources" src="image/B21183_12_6.0.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.294.1">Figure 12.6 – The structure of Azure Functions resources</span></p>
<p><span class="koboSpan" id="kobo.295.1">As you can see, the Azure function is a much more simple deployment. </span><span class="koboSpan" id="kobo.295.2">We don’t need a virtual network or any of the other surrounding resources that we provisioned in previous chapters just to get off the ground. </span><span class="koboSpan" id="kobo.295.3">For most applications, the built-in security of Azure Functions and Key Vault is sufficient. </span><span class="koboSpan" id="kobo.295.4">However, if we wanted to enable private networking because our application has to follow some regulatory </span><a id="_idIndexMarker956"/><span class="koboSpan" id="kobo.296.1">compliance, we can do that, but otherwise, it</span><a id="_idTextAnchor559"/><span class="koboSpan" id="kobo.297.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">not required.</span></span></p>
<h2 id="_idParaDest-229"><a id="_idTextAnchor560"/><span class="koboSpan" id="kobo.299.1">Application code</span></h2>
<p><span class="koboSpan" id="kobo.300.1">Azure Functions are inherently</span><a id="_idIndexMarker957"/><span class="koboSpan" id="kobo.301.1"> event-based. </span><span class="koboSpan" id="kobo.301.2">Each Azure Function</span><a id="_idIndexMarker958"/><span class="koboSpan" id="kobo.302.1"> is triggered by a different type of event, and the Azure Functions SDK provides an extensible framework for triggering based on different types of events. </span><span class="koboSpan" id="kobo.302.2">Azure Functions has implemented several different triggers for all sorts of different Azure services, which makes it easy to design Azure Functions that can respond to all sorts of different activities taking place within your Azure environment. </span><span class="koboSpan" id="kobo.302.3">For this book, we’ll only focus on the HTTP trigger, but if you are interested, I recommend checking out all the other options that Azure Functions has – it’s </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">quite extensive.tt</span></span></p>
<p><span class="koboSpan" id="kobo.304.1">In a traditional ASP.NET REST API solution, you have controller classes that embody a specific route and then methods that implement different operations at </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">that route:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer149">
<span class="koboSpan" id="kobo.306.1"><img alt="Figure 12.7 – ASP.NET MVC controller class anatomy" src="image/B21183_12_7.0.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.307.1">Figure 12.7 – ASP.NET MVC controller class anatomy</span></p>
<p><span class="koboSpan" id="kobo.308.1">The controller class needs to be decorated with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">ApiController</span></strong><span class="koboSpan" id="kobo.310.1"> attribute that informs the ASP.NET runtime that this class should be used to process incoming web requests at the route specified in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">Route</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.312.1"> attribute.</span></span></p>
<p><span class="koboSpan" id="kobo.313.1">Each method is decorated</span><a id="_idIndexMarker959"/><span class="koboSpan" id="kobo.314.1"> with an attribute that denotes which HTTP verb the method should respond to. </span><span class="koboSpan" id="kobo.314.2">In the preceding example, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">HttpGet</span></strong><span class="koboSpan" id="kobo.316.1">, but there are corresponding attributes for each of the supported HTTP verbs. </span><span class="koboSpan" id="kobo.316.2">The method can take strongly typed parameters that can either be part of the route, the query string, or the request body. </span><span class="koboSpan" id="kobo.316.3">The method returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">IActionResult</span></strong><span class="koboSpan" id="kobo.318.1"> by default, which allows us to return different data structures, depending on the outcome of </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">the request.</span></span></p>
<p><span class="koboSpan" id="kobo.320.1">To implement a REST API using Azure Functions, we need to implement a class using the Azure Function SDK. </span><span class="koboSpan" id="kobo.320.2">This requires us to slightly adjust how we implement both our class and our method. </span><span class="koboSpan" id="kobo.320.3">We will employ different class and method attributes to achieve a similar outcome: defining an endpoint that responds to web requests at a </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">specific route.</span></span></p>
<p><span class="koboSpan" id="kobo.322.1">The Azure Function class is not decorated with </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">any attributes:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer150">
<span class="koboSpan" id="kobo.324.1"><img alt="Figure 12.8 – Azure Function class anatomy" src="image/B21183_12_8.0.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.325.1">Figure 12.8 – Azure Function class anatomy</span></p>
<p><span class="koboSpan" id="kobo.326.1">Only the methods should be decorated with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">FunctionName</span></strong><span class="koboSpan" id="kobo.328.1"> attribute, which will correlate them with a named scope for the Azure Function framework. </span><span class="koboSpan" id="kobo.328.2">This attribute is similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">Route</span></strong><span class="koboSpan" id="kobo.330.1"> attribute as it informs the base route of all of the methods implemented within this named context of Azure Functions. </span><span class="koboSpan" id="kobo.330.2">Azure Function classes can be implemented as static or non-static classes. </span><span class="koboSpan" id="kobo.330.3">I recommend using non-static classes as they allow you to use dependency injection to greatly improve the testability of your </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">Azure Functions.</span></span></p>
<p><span class="koboSpan" id="kobo.332.1">The methods in an Azure Functions class are where we tie into the event-triggering framework of Azure Functions. </span><span class="koboSpan" id="kobo.332.2">When responding to a web request, we need the first parameter of our method to be of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">HttpRequest</span></strong><span class="koboSpan" id="kobo.334.1"> type, and we need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">HttpTrigger</span></strong><span class="koboSpan" id="kobo.336.1"> attribute on this method parameter. </span><span class="koboSpan" id="kobo.336.2">Since we decorated the method with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">FunctionName</span></strong><span class="koboSpan" id="kobo.338.1"> attribute already, the Azure Functions framework knows to interrogate this method for any available event triggers. </span><span class="koboSpan" id="kobo.338.2">Hence, supplying </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">HttpRequest</span></strong><span class="koboSpan" id="kobo.340.1"> with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">HttpTrigger</span></strong><span class="koboSpan" id="kobo.342.1"> attribute attached will meet the match criteria, and Azure Functions will wire up this method so that it responds to incoming web </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">traffic accordingly.</span></span></p>
<p><span class="koboSpan" id="kobo.344.1">This pattern is very similar to the traditional ASP.NET implementation using controller classes. </span><span class="koboSpan" id="kobo.344.2">However, it takes on a slightly different structure. </span><span class="koboSpan" id="kobo.344.3">All the same anatomical elements are there but just in different places: HTTP verb, route to the endpoint, input parameters (either a query string or on the request body), and the </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">response body.</span></span></p>
<p><span class="koboSpan" id="kobo.346.1">Unlike in a traditional ASP.NET project, the HTTP verb is not a method-level attribute. </span><span class="koboSpan" id="kobo.346.2">It’s a parameter of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">HttpTrigger</span></strong><span class="koboSpan" id="kobo.348.1"> attribute. </span><span class="koboSpan" id="kobo.348.2">The method does allow us to add additional input parameters as either query string or part of the route but not part of the request </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">body itself.</span></span></p>
<p><span class="koboSpan" id="kobo.350.1">As we can see, the cloud architecture radically simplifies things, but one trade-off is that our backend code needs to be adapted to the Azure Functions framework. </span><span class="koboSpan" id="kobo.350.2">This will require development and testing efforts to transform our code base into this new hosting model. </span><span class="koboSpan" id="kobo.350.3">This stands in stark contrast to what we explored in previous chapters, where we hosted on VMs or containerized and hosted on a Kubernetes cluster. </span><span class="koboSpan" id="kobo.350.4">While conforming to the Azure Functions model does take work, its benefits are two-fold: first, it allows us to take advantage of close to zero sunk cost, and second, it allows us to fully abstract the underlying infrastructure from us and let the Azure platform take care of scalability and high availability. </span><span class="koboSpan" id="kobo.350.5">This allows us to focus more on the functionality of our solutions rather than the plumbing</span><a id="_idIndexMarker960"/><span class="koboSpan" id="kobo.351.1"> required to keep the </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">lights on.</span></span></p>
<p><span class="koboSpan" id="kobo.353.1">Now that we have implemented Terraform to provision our solution and made changes to our application code so that it conforms to the Azure Functions framework, in the next section, we’ll dive into YAML and Bash and implement the necessary GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">Actions workflows.</span></span></p>
<h1 id="_idParaDest-230"><a id="_idTextAnchor561"/><span class="koboSpan" id="kobo.355.1">Automating the deployment</span></h1>
<p><span class="koboSpan" id="kobo.356.1">As we discussed in the previous section, serverless</span><a id="_idIndexMarker961"/><span class="koboSpan" id="kobo.357.1"> offerings such as Azure Functions and Azure Storage abstract away the operating system configuration. </span><span class="koboSpan" id="kobo.357.2">Therefore, when we deploy, we just need an application package that’s compatible with the target platform. </span><span class="koboSpan" id="kobo.357.3">In this section, we’ll create an automation pipeline using GitHub Actions that will provision our application to its new serverless home </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">in Azure.</span></span></p>
<h2 id="_idParaDest-231"><a id="_idTextAnchor562"/><span class="koboSpan" id="kobo.359.1">Terraform</span></h2>
<p><span class="koboSpan" id="kobo.360.1">The first thing that we need</span><a id="_idIndexMarker962"/><span class="koboSpan" id="kobo.361.1"> to do is provision our environment to Azure. </span><span class="koboSpan" id="kobo.361.2">This is going to be extremely similar to the way we did this in the previous chapters. </span><span class="koboSpan" id="kobo.361.3">In </span><a href="B21183_10.xhtml#_idTextAnchor474"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.362.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.363.1">, we needed to ensure that our VM images were built and available before we executed Terraform because the Terraform code base referenced the VM images when it provisioned the VMs. </span><span class="koboSpan" id="kobo.363.2">This means that with our VM architecture, application deployment happens before Terraform provisions </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">the environment:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer151">
<span class="koboSpan" id="kobo.365.1"><img alt="Figure 12.9 – Packer-produced VM images are a prerequisite for Terraform" src="image/B21183_12_9.0.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.366.1">Figure 12.9 – Packer-produced VM images are a prerequisite for Terraform</span></p>
<p><span class="koboSpan" id="kobo.367.1">In </span><a href="B21183_11.xhtml#_idTextAnchor509"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.368.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.369.1">, when we provisioned our Kubernetes cluster using Azure Kubernetes, we had no such prerequisite. </span><span class="koboSpan" id="kobo.369.2">The application deployment occurred after the Kubernetes cluster was online. </span><span class="koboSpan" id="kobo.369.3">This means that with container-based architecture, application deployment happens after Terraform provisions </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">the environment:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer152">
<span class="koboSpan" id="kobo.371.1"><img alt="Figure 12.10 – Docker-produced container images are provisioned to Kubernetes after Terraform executes" src="image/B21183_12_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.372.1">Figure 12.10 – Docker-produced container images are provisioned to Kubernetes after Terraform executes</span></p>
<p><span class="koboSpan" id="kobo.373.1">When using Azure’s serverless</span><a id="_idIndexMarker963"/><span class="koboSpan" id="kobo.374.1"> offerings, the deployment process mirrors that of what we saw when deploying our application as containers to Kubernetes. </span><span class="koboSpan" id="kobo.374.2">Just like with this approach, we need to build a deployment artifact for Azure’s serverless offerings. </span><span class="koboSpan" id="kobo.374.3">For the frontend, that means simply generating the static web content, and for the backend, that means generating an Azure Functions ZIP archive. </span><span class="koboSpan" id="kobo.374.4">These artifacts share a similar purpose to the Docker images in that they are a target service-compatible way of packaging our application </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">for deployment.</span></span></p>
<p><span class="koboSpan" id="kobo.376.1">As shown in the following figure, the serverless deployment looks very similar to the approach we used with the </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">container-based architecture:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer153">
<span class="koboSpan" id="kobo.378.1"><img alt="Figure 12.11 – The .NET CLI produces deployment artifacts that are provisioned to Azure after Terraform executes" src="image/B21183_12_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.379.1">Figure 12.11 – The .NET CLI produces deployment artifacts that are provisioned to Azure after Terraform executes</span></p>
<p><span class="koboSpan" id="kobo.380.1">That’s because Azure</span><a id="_idIndexMarker964"/><span class="koboSpan" id="kobo.381.1"> is fulfilling the role that Kubernetes played when using a serverless approach. </span><span class="koboSpan" id="kobo.381.2">Azure just has custom tools to facilitate the deployment</span><a id="_idTextAnchor563"/><span class="koboSpan" id="kobo.382.1"> of </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">the application.</span></span></p>
<h2 id="_idParaDest-232"><a id="_idTextAnchor564"/><span class="koboSpan" id="kobo.384.1">Deployment</span></h2>
<p><span class="koboSpan" id="kobo.385.1">Now that Terraform</span><a id="_idIndexMarker965"/><span class="koboSpan" id="kobo.386.1"> has provisioned the Azure infrastructure that we need for our serverless solution, we need to take the final step of deploying both deployment artifacts to the appropriate locations </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">in Azure.</span></span></p>
<p><span class="koboSpan" id="kobo.388.1">We will use .NET and Azure</span><a id="_idIndexMarker966"/><span class="koboSpan" id="kobo.389.1"> custom tools to produce the artifacts and deploy them to these </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">target locations.</span></span></p>
<h3><span class="koboSpan" id="kobo.391.1">Frontend</span></h3>
<p><span class="koboSpan" id="kobo.392.1">As we saw in other chapters, our .NET application</span><a id="_idIndexMarker967"/><span class="koboSpan" id="kobo.393.1"> code needs to follow a continuous integration process where the code is built and tested using automated unit testing and other built-in quality controls. </span><span class="koboSpan" id="kobo.393.2">Nothing changes here, except that we need to add some special handling to the deployment artifact that these processes produce to make sure it is available to our GitHub Action’s job that deploys the workload to the </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">appropriate location.</span></span></p>
<p><span class="koboSpan" id="kobo.395.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">dotnet publish</span></strong><span class="koboSpan" id="kobo.397.1"> command is used to output the deployment artifact of the .NET application code. </span><span class="koboSpan" id="kobo.397.2">For the ASP.NET Blazor web application, this output is a folder container, a collection of loose files containing HTML, JavaScript, and CSS. </span><span class="koboSpan" id="kobo.397.3">To pass all these files efficiently from one GitHub Actions job to another, we need to zip them up into a </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">single file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.399.1">
    - name: Generate the Deployment Package
      run: |
        zip -r ../deployment.zip ./
      working-directory: ${{ env.DOTNET_WORKING_DIRECTORY }}/publish</span></pre> <p><span class="koboSpan" id="kobo.400.1">Now that the static web content has been zipped into a ZIP archive, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">upload-artifact</span></strong><span class="koboSpan" id="kobo.402.1"> GitHub Action to save this file to GitHub Actions. </span><span class="koboSpan" id="kobo.402.2">This will make the file available for future jobs that are executed within </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">the pipeline:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.404.1">
    - name: Upload Deployment Package
      uses: actions/upload-artifact@v2
      with:
        name: dotnet-deployment
        path: ${{ env.DOTNET_WORKING_DIRECTORY }}/deployment.zip</span></pre> <p><span class="koboSpan" id="kobo.405.1">Future jobs can simply download</span><a id="_idIndexMarker968"/><span class="koboSpan" id="kobo.406.1"> the artifact using a corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">download-artifact</span></strong><span class="koboSpan" id="kobo.408.1"> GitHub Action and the same name that was used to </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">upload it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.410.1">
    - uses: actions/download-artifact@v3
      with:
        name: dotnet-deployment</span></pre> <p><span class="koboSpan" id="kobo.411.1">Because the ASP.NET Blazor web application is going to be hosted as static web content on our Azure Storage account, we need to ensure that we unzip it to upload the contents to Azure Blob storage. </span><span class="koboSpan" id="kobo.411.2">If we were to upload the zip archive to Blob storage, the web application wouldn’t work correctly because all of the web content would be trapped inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">archive file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.413.1">
    - name: Unzip Deployment Package
      run: |
        mkdir -p ${{ env.DOTNET_WORKING_DIRECTORY }}/upload-staging
        unzip ./deployment.zip -d ${{ env.DOTNET_WORKING_DIRECTORY }}/upload-staging</span></pre> <p><span class="koboSpan" id="kobo.414.1">Now that the static web content</span><a id="_idIndexMarker969"/><span class="koboSpan" id="kobo.415.1"> has been unzipped to the staging directory, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">az storage blob upload-batch</span></strong><span class="koboSpan" id="kobo.417.1"> command to deploy all of the files to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">$</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">web</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.420.1"> container:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.421.1">
    - id: deploy
      name: Upload to Blob
      env:
        ARM_SUBSCRIPTION_ID: ${{ vars.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ vars.ARM_TENANT_ID }}
        ARM_CLIENT_ID: ${{ vars.TERRAFORM_ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.TERRAFORM_ARM_CLIENT_SECRET }}
      working-directory: ${{ env.DOTNET_WORKING_DIRECTORY }}
      run: |
        az login --service-principal -u $ARM_CLIENT_ID -p $ARM_CLIENT_SECRET --tenant $ARM_TENANT_ID
        az account set --subscription $ARM_SUBSCRIPTION_ID
        az storage blob upload-batch -s ./upload-staging/wwwroot -d \$web --account-name ${{ steps.terraform.outputs.frontend_storage_account_name }}</span></pre> <p><span class="koboSpan" id="kobo.422.1">We need to make sure that we authenticate with Azure and that we are targeting the right Azure subscription that has the Azure Storage account that we want to target. </span><span class="koboSpan" id="kobo.422.2">Therefore, we need to execute the </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">az login</span></strong><span class="koboSpan" id="kobo.424.1"> command to authenticate and then use </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">az account set</span></strong><span class="koboSpan" id="kobo.426.1"> to ensure we are working on the right subscription. </span><span class="koboSpan" id="kobo.426.2">Once we’ve done that, we can execute </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">az storage blob upload-batch</span></strong><span class="koboSpan" id="kobo.428.1"> to recursively upload all the files withi</span><a id="_idTextAnchor565"/><span class="koboSpan" id="kobo.429.1">n</span><a id="_idIndexMarker970"/><span class="koboSpan" id="kobo.430.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">staging directory.</span></span></p>
<h3><span class="koboSpan" id="kobo.432.1">Azure Function</span></h3>
<p><span class="koboSpan" id="kobo.433.1">To deploy the Azure Function, the same process</span><a id="_idIndexMarker971"/><span class="koboSpan" id="kobo.434.1"> must be followed</span><a id="_idIndexMarker972"/><span class="koboSpan" id="kobo.435.1"> to pass the artifact from the GitHub Actions job that builds the deployment artifact to the job that deploys </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">the artifact.</span></span></p>
<p><span class="koboSpan" id="kobo.437.1">Like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">az storage blob upload-batch</span></strong><span class="koboSpan" id="kobo.439.1"> command, we also need to authenticate and set the right Azure subscription. </span><span class="koboSpan" id="kobo.439.2">The only difference is that we are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">az functionapp deployment source config-zip</span></strong><span class="koboSpan" id="kobo.441.1"> command to provision a ZIP archive to the </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">Azure Function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.443.1">
      - name: Deploy
        env:
          ARM_SUBSCRIPTION_ID: ${{ vars.ARM_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ vars.ARM_TENANT_ID }}
          ARM_CLIENT_ID: ${{ vars.TERRAFORM_ARM_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.TERRAFORM_ARM_CLIENT_SECRET }}
          RESOURCE_GROUP_NAME: ${{needs.terraform.outputs.resource_group_name}}
          FUNCTION_NAME: ${{needs.terraform.outputs.function_name}}
        run: |
          az login --service-principal -u $ARM_CLIENT_ID -p $ARM_CLIENT_SECRET --tenant $ARM_TENANT_ID --output none
          az account set -s $ARM_SUBSCRIPTION_ID --output none
          az functionapp deployment source config-zip -g $RESOURCE_GROUP_NAME -n $FUNCTION_NAME --src ./deployment.zip</span></pre> <p><span class="koboSpan" id="kobo.444.1">Unlike how we provisioned the frontend, we don’t need to unzip the deployment package for the Azure Function. </span><span class="koboSpan" id="kobo.444.2">Azure Functions is expecting our application code to be bundled into a </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">ZIP archive:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.446.1">
  app_settings = {
    "SCM_DO_BUILD_DURING_DEPLOYMENT" = "false"
    "WEBSITE_RUN_FROM_PACKAGE"       = "1"
  }</span></pre> <p><span class="koboSpan" id="kobo.447.1">You might remember from the previous section where we set </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">app_settings</span></strong><span class="koboSpan" id="kobo.449.1"> on the Azure Function that we set two settings – </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">SCM_DO_BUILD_DURING_DEPLOYMENT</span></strong><span class="koboSpan" id="kobo.451.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">WEBSITE_RUN_FROM_PACKAGE</span></strong><span class="koboSpan" id="kobo.453.1">. </span><span class="koboSpan" id="kobo.453.2">These two settings tell Azure Functions that our application code is already</span><a id="_idIndexMarker973"/><span class="koboSpan" id="kobo.454.1"> pre-compiled</span><a id="_idIndexMarker974"/><span class="koboSpan" id="kobo.455.1"> and bundled into a </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">ZIP archive.</span></span></p>
<p><span class="koboSpan" id="kobo.457.1">That’s it! </span><span class="koboSpan" id="kobo.457.2">With that, our application has been fully deployed to Azure</span><a id="_idTextAnchor566"/><span class="koboSpan" id="kobo.458.1"> Storage and </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">Azure Functions!</span></span></p>
<h1 id="_idParaDest-233"><a id="_idTextAnchor567"/><span class="koboSpan" id="kobo.460.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.461.1">In this chapter, we designed, built, and automated the deployment of a complete end-to-end solution using serverless architecture using Azure Functions. </span><span class="koboSpan" id="kobo.461.2">To accomplish this, we finally had to make some major changes to our application code so that it conformed to the requirements of the serverless runtime. </span><span class="koboSpan" id="kobo.461.3">When adopting serverless offerings, you must make this distinct and considerable decision as it tightly couples your application code with the target </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">cloud platform.</span></span></p>
<p><span class="koboSpan" id="kobo.463.1">Throughout this journey, we have meticulously constructed three distinct solutions on the Azure platform by utilizing VMs, Kubernetes through </span><strong class="bold"><span class="koboSpan" id="kobo.464.1">Azure Kubernetes Service</span></strong><span class="koboSpan" id="kobo.465.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.466.1">AKS</span></strong><span class="koboSpan" id="kobo.467.1">), and now, serverless with </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">Azure Functions.</span></span></p>
<p><span class="koboSpan" id="kobo.469.1">As we conclude this Azure-centric narrative, we stand on the brink of a thrilling new alternate reality. </span><span class="koboSpan" id="kobo.469.2">Guided by the enigmatic vision of our CEO, Keyser Söze, we are poised to embark on an adventurous collaboration with Google. </span><span class="koboSpan" id="kobo.469.3">This partnership is set to unfold in a realm of endless possibilities, mirroring our Azure achievements on Google Cloud. </span><span class="koboSpan" id="kobo.469.4">Our narrative will transition to exploring similar architectures on Google Cloud, so stay tuned as we venture into this </span><em class="italic"><span class="koboSpan" id="kobo.470.1">alternate universe</span></em><span class="koboSpan" id="kobo.471.1"> with Keyser Söze, delving into Google Cloud’s offerings and continuing to innovate our solutions in </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">cloud computing.</span></span></p>
</div>


<div class="Content" id="_idContainer155">
<h1 id="_idParaDest-234" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor568"/><span class="koboSpan" id="kobo.1.1">Part 5: Building Solutions on Google Cloud</span></h1>
<p><span class="koboSpan" id="kobo.2.1">Armed with the conceptual knowledge of Terraform and architectural concepts that transcend the implementation details of the major public cloud platforms, we’ll explore building solutions on Google Cloud with three cloud computing paradigms: virtual machines, containers with Kubernetes, and serverless with Google </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">Cloud Functions.</span></span></p>
<p><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.4.1">This part has the </span></span><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B21183_13.xhtml#_idTextAnchor569"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 13</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Getting Started on Google Cloud – Building Solutions with GCE</span></em></li>
<li><a href="B21183_14.xhtml#_idTextAnchor605"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 14</span></em></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Containerize on Google Cloud – Building Solutions with GKE</span></em></li>
<li><a href="B21183_15.xhtml#_idTextAnchor641"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 15</span></em></a><span class="koboSpan" id="kobo.13.1">, </span><em class="italic"><span class="koboSpan" id="kobo.14.1">Go Serverless on Google Cloud – Building Solutions with Google Cloud Functions</span></em></li>
</ul>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer156">
</div>
</div>
</body></html>