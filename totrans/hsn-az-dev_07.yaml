- en: Serverless and Azure Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器和 Azure Functions
- en: Azure Functions are the main product of serverless architecture in Azure. They
    allow for executing small pieces of code within fully managed runtime, so we don't
    have to care about performance and scalability. They are open source, open for
    extensions, and built on top of App Services, so they provide a similar experience
    to WebJobs. Microsoft pays much attention to developing new features for Azure
    Functions and, with great support from the community, it's one of the best tools
    for quickly developing both simple and serious applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 是 Azure 无服务器架构的主要产品。它们允许在完全托管的运行时内执行小段代码，因此我们不需要关心性能和可扩展性。它们是开源的，支持扩展，并建立在
    App Services 之上，因此它们提供类似于 WebJobs 的体验。微软非常重视 Azure Functions 的新特性开发，并且在社区的极大支持下，它是快速开发简单和复杂应用程序的最佳工具之一。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding Azure Functions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Azure Functions
- en: Configuring local environment for developing Azure Functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置本地开发环境以开发 Azure Functions
- en: Creating a function
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个函数
- en: Azure Functions features
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Functions 特性
- en: Workflow in Azure Functions—Durable Functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Functions 中的工作流——持久化函数
- en: Integrating functions with other services
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数与其他服务集成
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To start using Azure Functions and to perform the exercises in this chapter,
    you will need the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 Azure Functions 并执行本章中的练习，你需要以下内容：
- en: Visual Studio 2017 with Azure workload installed
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装 Azure 工作负载的 Visual Studio 2017
- en: Azure Functions and the WebJobs tools extension for Visual Studio
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Functions 和 Visual Studio 的 WebJobs 工具扩展
- en: Understanding Azure Functions
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Azure Functions
- en: Azure Functions are a part of so-called serverless components that are available
    in the Azure cloud. Before you start learning about this particular service, you
    will have to understand what serverless really means. While, initially, you may
    think that this concept implies no servers at all, you will quickly re-evaluate your
    way of thinking (as, we are still quite far away from not using any kind of machine
    for our applications and workloads).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 是 Azure 云中可用的所谓无服务器组件的一部分。在你开始学习这个特定服务之前，你需要理解无服务器究竟意味着什么。虽然最初你可能会认为这个概念意味着完全没有服务器，但你很快会重新评估自己的思维方式（毕竟，我们距离完全不使用任何类型的机器来处理我们的应用和工作负载还有一段距离）。
- en: Being "serverless"
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现“无服务器”
- en: You can easily find many different articles describing the term serverless—to
    be honest, I would like to avoid promoting a one and only correct definition,
    as this topic is currently so fuzzy, it is hard to find the best description.
    My goal, however, is to give you some hints and best practices, which will let
    you understand it in a way that makes the most sense to you.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松找到许多描述“无服务器”这一术语的不同文章——老实说，我不想推动一种唯一正确的定义，因为这个话题目前仍然模糊，很难找到最好的描述。然而，我的目标是给你一些提示和最佳实践，帮助你以最适合自己的方式理解它。
- en: Responsibilities of cloud vendors
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云供应商的责任
- en: 'We will start with the following screenshot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从以下截图开始：
- en: '![](img/b73380e1-ea4f-4fd8-a1e2-1d08c371de11.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b73380e1-ea4f-4fd8-a1e2-1d08c371de11.png)'
- en: 'In the preceding screenshot, you can see the comparison of two of the most
    popular cloud models with serverless architecture regarding vendor responsibility.
    I compared them using five different fields:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的截图中，你可以看到关于供应商责任的无服务器架构与两种最流行的云模型的比较。我使用五个不同的领域进行了对比：
- en: '**Data center**: DC infrastructure, security, maintenance, and staff'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据中心**：数据中心基础设施、安全性、维护和人员配置'
- en: '**Network security**: Implementing correct and secure solutions regarding the
    network (firewalls, pen-tests, and anti-DDoS solutions)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络安全**：实现有关网络的正确和安全的解决方案（防火墙、渗透测试和抗 DDoS 解决方案）'
- en: '**Operating systems**: Updates, maintenance, and configuration'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统**：更新、维护和配置'
- en: '**Dev tools**: Developing and delivering multiple features for programmers
    and administrators (such as extensions to IDE, management portal, and appropriate
    tools for managing services)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发工具**：为程序员和管理员开发和交付多个功能（例如 IDE 扩展、管理门户以及管理服务的相关工具）'
- en: '**Application host**: The specific runtime that hosts and runs our application
    (such as App Service Plan)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用托管**：托管和运行我们应用的特定运行时（例如应用服务计划）'
- en: As you can see, the only difference (at least when using the described characteristics)
    is the application host. When it comes to serverless components, the only thing
    that you deliver to your solution is your code (or some kind of configuration,
    which is needed to set up a service)—the rest is delivered and handled by your
    cloud vendor. Of course, this is not the only way to define this idea.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，唯一的区别（至少在使用描述的特征时）是应用主机。在涉及无服务器组件时，您向解决方案提供的唯一内容是您的代码（或某种配置，用于设置服务）—其余内容由您的云供应商提供和处理。当然，这不是定义这个想法的唯一方式。
- en: Pricing model
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定价模型
- en: 'One of the most popular features of serverless services and architectures is
    the possibility to pay for the number of executions and used computing power.
    This pricing model is the exact opposite of the most common prepaid model, where
    you pay a fixed price depending on a set of configured fields such as the number
    of used VMs or the size of a cluster. Here, you can find a table describing pricing
    for Azure Functions:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器服务和架构最受欢迎的功能之一是支付执行次数和使用的计算能力的可能性。这种定价模型与最常见的预付费模型完全相反，在预付费模型中，您根据一组配置字段（如使用的VM数量或集群大小）支付固定价格。在这里，您可以找到描述Azure
    Functions定价的表格：
- en: '| Meter | Price | Free grant (per month) |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 计量单位 | 价格 | 免费赠款（每月） |'
- en: '| --- | --- | --- |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Execution time | €0.000014/GB/s | 400.000 GB/s |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 执行时间 | €0.000014/GB/s | 400.000 GB/s |'
- en: '| Total executions | €0.169 per million executions | 1 million executions |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 总执行次数 | €0.169每百万次执行 | 100万次执行 |'
- en: 'Now, you may wonder how can you understand this so that you can calculate the
    estimated cost of your solution. There are two things you have to understand to
    make your calculation correct:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可能想知道如何理解这一点，以便计算您解决方案的预估成本。为了使您的计算正确，您必须理解两件事：
- en: '**Execution**: This is a single function execution, which lasts *N* seconds'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行**：这是一个持续*N*秒的单个函数执行'
- en: '**Consumption**: This defines how many resources (CPU and memory) your function
    consumes within a fixed time'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消耗**：这定义了您的函数在固定时间内消耗的资源（CPU和内存）'
- en: Now, if you compare the preceding terms with the table, you will see that they
    differ slightly. This is because Azure Functions, pricing does not directly define
    the price for consumption but, rather, uses execution time.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您将前述术语与表格进行比较，您将看到它们略有不同。这是因为Azure Functions的定价不直接定义消耗的价格，而是使用执行时间。
- en: You have probably noticed the free grantcolumn in the pricing table. Remember
    that it applies only to the consumption model—it will not work for the prepaid
    one.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到定价表中的免费赠款列。请记住，它仅适用于消费模型—对于预付费模型不起作用。
- en: 'Now, let''s assume that you have estimated the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设您已经估算了以下内容：
- en: You will need 10 million executions of your function per month
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您每月需要对您的函数进行1000万次执行
- en: Each execution lasts ~80 ms
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次执行持续约80毫秒
- en: You are using 145 MB of memory per execution
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次执行您使用145 MB的内存
- en: 'To calculate the whole price for using Azure Functions, you can use the following
    formula:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算使用Azure Functions的整体价格，您可以使用以下公式：
- en: '![](img/ae3ecd9e-6a48-47ed-8717-1bd3a0b92e39.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae3ecd9e-6a48-47ed-8717-1bd3a0b92e39.png)'
- en: 'In the previous formula, the following is applicable:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的公式中，适用以下内容：
- en: '**Rc**: Resource consumption defined as a product of memory consumed and execution
    time (in GB/s)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rc**：资源消耗定义为消耗的内存和执行时间的乘积（以GB/s为单位）'
- en: '**Te:** Total executions number (in millions)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Te:** 总执行次数（以百万为单位）'
- en: 'Now, if you enter the correct values and calculate the formula, you will get
    the following result:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您输入正确的值并计算公式，您将得到以下结果：
- en: '![](img/f1a9cc0a-d1c1-43f9-a24b-4c7d10ed2fed.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1a9cc0a-d1c1-43f9-a24b-4c7d10ed2fed.png)'
- en: 'This will give you the following cost: 5.19 EUR. However, you may find the
    previous formula a bit confusing—why did I use *256 *(instead of 128)as the amount
    of memory consumed and* 1 Ms*(instead of 800 Ks)as the execution time? Well, there
    is one important thing to remember when using the consumption plan: the minimum
    execution time is 100 ms and when it comes to resources consumption, it is always **rounded
    up **to the nearest 128 MBs.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为您带来以下费用：5.19欧元。然而，您可能会发现之前的公式有点令人困惑——为什么我使用*256*（而不是128）作为内存消耗量，*1 Ms*（而不是800
    Ks）作为执行时间？嗯，在使用消费计划时有一件重要的事情要记住：最小执行时间为100毫秒，而在资源消耗方面，总是**向最近的128 MB四舍五入**。
- en: In fact, when it comes to function execution, you cannot go under 100 ms and
    128 MBs of used memory. This is very important when calculating possible cost
    optimization as, often, you should not aim at optimizing functions and rather
    focus on overall algorithm changes (such as batching or better serialization methods).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在函数执行时，你无法低于100毫秒和128MB的内存使用量。这在计算可能的成本优化时非常重要，因为通常你不应专注于优化函数，而应集中精力于整体算法的改进（例如批处理或更好的序列化方法）。
- en: Azure Functions concepts
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure Functions概念
- en: 'Now that you are a bit familiar with what serverless architecture is, we can
    start learning something else about Azure Functions. To proceed, you will need
    to understand the difference between the following topics:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对无服务器架构有了些许了解，我们可以开始学习Azure Functions的其他内容。为了继续，你需要理解以下主题之间的区别：
- en: Function apps
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数应用
- en: Functions
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Triggers and bindings
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发器和绑定
- en: Function app
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数应用
- en: The logical container for multiple functions is called a function app. A function
    app can host one or more functions, which will share configuration, settings,
    and runtime version. It is possible to run functions using multiple languages
    using the same function app.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 多个函数的逻辑容器称为函数应用。一个函数应用可以托管一个或多个函数，它们将共享配置、设置和运行时版本。可以在同一个函数应用中使用多种语言运行函数。
- en: 'Here, you can see what a single function app looks like, with several individual
    functions hosted within it:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到一个单独的函数应用的样子，里面托管着多个独立的函数：
- en: '![](img/8abe2854-700b-4e08-b6dd-a0db7530a46c.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8abe2854-700b-4e08-b6dd-a0db7530a46c.png)'
- en: If you have the requirement to use both pricing plans (consumption and App Service),
    you will have to have two different functions apps, as a single one does not support
    such a scenario.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要同时使用两种定价计划（按需计费和应用服务），你必须创建两个不同的函数应用，因为单个函数应用不支持这种场景。
- en: Functions
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'A single executable part of Azure Functions that hosts your code is called a
    **function**. Each function can execute code written in different supported languages
    (one can use C#, while another can leverage Python features). The currently supported
    languages are as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 托管你代码的Azure Functions的单个可执行部分称为**函数**。每个函数都可以执行用不同支持的语言编写的代码（有的可以使用C#，而其他的则可以利用Python的特性）。目前支持的语言如下：
- en: C#
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#
- en: JavaScript
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript
- en: F#
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F#
- en: In the second version of runtime (v2), Java should also be available to use.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二版运行时（v2）中，Java也应该可以使用。
- en: Please note that, at the time of writing this book, the v1 version is the only
    one that supports production workloads.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在本书编写时，v1版本是唯一支持生产工作负载的版本。
- en: 'There is also the possibility of using a set of other languages (such as Powershell,
    PHP, or Batch), but they are in experimental mode and are not to be used in production.
    Here, you can find an example function with some boilerplate code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 还有使用其他语言（例如Powershell、PHP或Batch）的可能性，但它们处于实验模式，不应在生产环境中使用。这里，你可以看到一个包含一些模板代码的示例函数：
- en: '[PRE0]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that the previous code was generated using Visual Studio—the boilerplate
    generated in Azure Portal looks a little bit different.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，之前的代码是使用Visual Studio生成的——在Azure Portal中生成的模板代码看起来稍有不同。
- en: 'As you can see, a function consists of the following components:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，一个函数由以下组件构成：
- en: '**Function decorator**:` [FunctionName]`, which allows the runtime to find
    a function, and delivers the required metadata'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数装饰器**：`[FunctionName]`，它允许运行时找到一个函数，并提供所需的元数据'
- en: '**Trigger**: `[QueueTrigger]`—each function requires a trigger to be configured
    correctly'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**触发器**：`[QueueTrigger]`——每个函数都需要配置触发器才能正确运行'
- en: '**Additional bindings**: `TraceWriter`, which will be injected during runtime'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**附加绑定**：`TraceWriter`，将在运行时注入'
- en: '**Function code: **The actual logic that will be executed each time the function
    is called'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数代码：** 每次调用函数时将执行的实际逻辑'
- en: Of course, some parts of a function will differ depending on the features you
    use—in the previous example, we used a trigger for Azure Storage Queue, but there
    are also other possibilities (such as HTTP request, Azure Service Bus, or Azure
    CosmosDB); additionally, you can use other bindings and provide custom code each
    time. We will cover all of these topics in the following sections of this chapter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，函数的某些部分会根据你使用的功能有所不同——在之前的示例中，我们使用了Azure存储队列的触发器，但也有其他可能性（例如HTTP请求、Azure服务总线或Azure
    CosmosDB）；此外，你可以使用其他绑定，并在每次调用时提供自定义代码。我们将在本章的后续部分介绍所有这些主题。
- en: Triggers and bindings
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发器和绑定
- en: 'The power of Azure Functions comes when you consider all possible integrations,
    which can be used seamlessly and without much additional effort. In fact, the
    list of available triggers and bindings are quite impressive:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions的强大之处在于考虑到所有可能的集成，它们可以无缝地使用，并且几乎无需额外的工作。事实上，可用的触发器和绑定的列表相当令人印象深刻：
- en: Azure Storage
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Storage
- en: Azure CosmosDB
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure CosmosDB
- en: Azure Event Grid
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Event Grid
- en: Azure Event Hub
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Event Hub
- en: HTTP
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP
- en: Microsoft Graph
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Graph
- en: Azure Mobile Apps
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Mobile Apps
- en: Azure Notification Hub
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Notification Hub
- en: Azure Service Bus
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Service Bus
- en: Timer
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时器
- en: Twilio
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Twilio
- en: SendGrid
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SendGrid
- en: Additionally, you have access to some experimental triggers and bindings, which
    may not be officially supported, but can be used in your application if you decide
    to do so (such as external files and external tables).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以访问一些实验性的触发器和绑定，虽然这些可能不被官方支持，但如果你决定使用，它们可以在你的应用程序中使用（例如外部文件和外部表）。
- en: Remember that some experimental triggers and bindings will never reach GA status
    as there are specific recommendations (such as using Azure Logic Apps), which
    should be followed in most cases.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，一些实验性的触发器和绑定永远不会达到GA（正式发布）状态，因为有一些特定的建议（例如使用**Azure Logic Apps**），在大多数情况下应遵循这些建议。
- en: 'Of course, it is possible to introduce custom triggers and bindings since Azure
    Functions provides a full SDK, which can be used to extend runtime. However, this
    is an advanced topic that will be not covered in this book—you will find a reference
    to the appropriate tutorials in the *Further reading*section. Here, you can find
    an example of a custom binding, which I used for authorizing a user:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以引入自定义触发器和绑定，因为Azure Functions提供了完整的SDK，可以用于扩展运行时。但是，这属于高级主题，本书中不会涉及——你可以在*进一步阅读*部分找到相关教程的参考。在这里，你可以找到一个自定义绑定的示例，供我用于用户授权：
- en: '![](img/51163900-ab4e-4954-8200-e54f00e0c037.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51163900-ab4e-4954-8200-e54f00e0c037.png)'
- en: Pricing models
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定价模型
- en: 'In Azure Functions, there are two pricing models available:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure Functions中，有两种定价模型可供选择：
- en: '**Consumption model**: This wasdescribed in the previous sections, where you
    pay for the number of executions of your functions and the computing power used'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消费模型**：在前面部分已经描述过，你按函数的执行次数和使用的计算能力付费'
- en: '**App Service Plan ****model**: This is where you select an App Service Plan
    version, which has a fixed price, no matter how many times you execute your functions'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用服务计划模型**：在这里，你选择一个应用服务计划版本，无论你执行多少次函数，都有固定的价格'
- en: Scaling
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展
- en: One of the most important features of serverless components and architectures
    is their ability to scale out as they are loaded more and more. While in traditional
    PaaS services, you often have to worry about available instances or scaling configuration.
    Serverless allows for the seamless handling of incoming requests, even if a service
    is hit by an unexpectedly high traffic. In this section, we will talk about the
    scaling capabilities of Azure Functions, with a focus on differences between consumption
    and App Service models.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器无状态组件和架构最重要的特点之一是，它们能够随着负载的增加而扩展。与传统的PaaS服务不同，你通常需要担心可用实例或扩展配置。无服务器架构允许无缝处理传入的请求，即使服务遭遇意外的高流量。在这一部分中，我们将讨论Azure
    Functions的扩展能力，重点讲解消费模式和应用服务模型之间的差异。
- en: Scaling in the consumption model
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消费模型下的扩展
- en: When you use the consumption model in Azure Functions, you are not defining
    any available instances for your service and are unable to configure auto-scaling
    settings. In fact, in this model, you are completely unaware of the number of
    machines running your workloads (however, if you integrate your functions with
    Azure Application Insights, you will be able to see how many instances have been
    created by taking a look at the **Live Stream** blade).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在Azure Functions中使用消费模型时，你并未为服务定义任何可用实例，也无法配置自动扩展设置。事实上，在该模型中，你完全无法知道有多少台机器在运行你的工作负载（不过，如果你将函数与Azure
    Application Insights集成，你将能够查看通过查看**实时流**面板，了解创建了多少实例）。
- en: In the consumption model, you have a fixed limit when it comes to the memory
    available for each execution of your function—this is 1.536 MBs. Whether your
    functions will scale or not depends on the current utilization of both memory
    and CPU.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在消费模型下，每次执行函数时，内存有固定的限制——为1.536 MB。函数是否能扩展，取决于当前内存和CPU的利用率。
- en: The advantage of this plan is the ability to easily scale to hundreds of functions
    while running the same code concurrently. Of course, it all depends on the actual
    trigger used in a function—while, with the HTTP trigger, you have to scale out
    to be able to handle multiple requests at once, using the event hub trigger, for
    instance, will automatically increase the number of working instances for each
    partition used. On the other hand, you cannot always rely on the consumption plan
    to be sure that you will not expect delays in responses or temporary unavailability—immediate
    scaling out is not guaranteed by any means, so this particular pricing plan is
    not always the best solution when your application has to face quick peaks of
    traffic.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 该计划的优势在于能够轻松扩展到数百个函数，同时并行运行相同的代码。当然，这一切都取决于函数使用的实际触发器——例如，使用HTTP触发器时，必须扩展才能处理多个请求，而使用事件中心触发器时，则会自动增加每个分区使用的工作实例数量。另一方面，你不能总是依赖消费计划来确保不会出现响应延迟或暂时不可用的情况——即使是即时扩展，也不一定能得到保证，因此，当你的应用需要应对快速流量高峰时，这种定价计划并不总是最好的解决方案。
- en: Remember that the current maximum for scaling a function app is limited to 200\.
    Also worth noting is the fact that the runtime will allocate new instances no
    often than every 10 seconds.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当前扩展函数应用的最大限制为200。此外，还值得注意的是，运行时将在每10秒内分配新的实例。
- en: Scaling in the App Service model
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用服务模型中的扩展
- en: Using the App Service model has its benefits, especially when it comes to covering
    some cases of scaling that are not covered in the consumption plan. As mentioned
    in the previous section, if you have to be sure that you are able to handle the
    incoming load, it is often a better idea to use this particular model, as it ensures
    that some fixed resources will be available for your function app. Additionally,
    you are 100% sure that the provided hardware is provisioned for your application—this
    is not always the case in the consumption model since you have no guarantees when
    it comes to delivered machines and their characteristics. What's more, you are
    sure that your runtime is always running—since, in the consumption model, when
    a function is not used, its resources will be de-allocated, you can face quite
    common issues such as cold starts.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用应用服务模型有其优势，尤其是在处理消费计划未涵盖的某些扩展情况时。如前所述，如果你必须确保能够处理传入的负载，通常使用这种特定模型是一个更好的选择，因为它确保为你的函数应用提供某些固定资源。此外，你可以100%确保为你的应用提供的硬件是经过预配的——这在消费模型中并不总是如此，因为你无法获得有关所提供的机器及其特性的保证。更重要的是，你可以确保你的运行时始终运行——因为在消费模型中，当函数未被使用时，其资源将被解除分配，你可能会遇到如冷启动等常见问题。
- en: Configuring the local environment for developing Azure Functions
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置本地开发环境以开发Azure函数
- en: To get started with Azure Functions, we will need an environment that will allow
    us to test our functions and start developing them quickly and seamlessly. Fortunately,
    this particular Azure service comes with multiple tools that help us during programming
    and running them locally. I will describe some extra applications as well, which
    should help you analyze and debug possible problems and test triggers before deploying
    to the cloud.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Azure Functions，我们需要一个环境，它能让我们测试函数并快速、无缝地开始开发。幸运的是，这项Azure服务配备了多种工具，帮助我们在本地编程和运行函数。我还将描述一些额外的应用程序，它们应有助于你分析和调试可能的问题，并在部署到云端之前测试触发器。
- en: Starting with Azure Functions locally
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地开始使用Azure Functions
- en: If you have installed all of the required software mentioned at the beginning
    of this chapter, you should be able to start developing them without any additional
    configuration. To get started, we will create a simple function that we will try
    to run to make sure that everything is set and ready.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经安装了本章开头提到的所有必需软件，你应该能够在无需额外配置的情况下开始开发。为了开始，我们将创建一个简单的函数，并尝试运行它，以确保一切都已设置好并准备就绪。
- en: 'When you open your Visual Studio instance, click on File | New Project. In
    the new screen, search for the Cloud | Azure Functions template:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的Visual Studio实例后，点击文件 | 新建项目。在新屏幕中，搜索 Cloud | Azure Functions 模板：
- en: '![](img/66b6c426-c55a-4ad6-a632-e2b42063db37.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66b6c426-c55a-4ad6-a632-e2b42063db37.png)'
- en: 'This is the first step that will ensure that everything on your side is configured
    correctly. When you click OK, you will see another screen that lets you select
    a few different things:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是确保你这边一切配置正确的第一步。当你点击OK时，你将看到另一个屏幕，允许你选择一些不同的选项：
- en: '**Runtime version**: You can choose between v1 and v2\. In this book, we will
    focus on v1 as v2 is still in preview.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时版本**：你可以选择 v1 或 v2。在本书中，我们将专注于 v1，因为 v2 仍处于预览阶段。'
- en: '**Trigger type**: Depending on the SDK version you have, you will have different
    options available. Of course, this is not the full list of available triggers
    for Azure Functions.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**触发器类型**：根据你所拥有的 SDK 版本，你将会有不同的选项。当然，这不是 Azure Functions 可用触发器的完整列表。'
- en: '**Storage Account**: Most functions require a storage account to work. Fortunately,
    you can use Storage Emulator locally, which is a simple database running under
    the `LocalDB` instance that''s installed on your computer.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储账户**：大多数函数都需要一个存储账户才能正常工作。幸运的是，你可以在本地使用 Storage Emulator，它是一个在你计算机上安装的
    `LocalDB` 实例下运行的简单数据库。'
- en: A new version of SDK for Azure should install Storage Emulator automatically.
    If, for some reason, you are missing it, go to the following page and install
    the missing component: [https://docs.microsoft.com/en-us/azure/storage/common/storage-use-emulator#get-the-storage-emulator](https://docs.microsoft.com/en-us/azure/storage/common/storage-use-emulator#get-the-storage-emulator).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 的新版本 SDK 应该会自动安装 Storage Emulator。如果由于某些原因你没有安装它，可以访问以下页面并安装缺失的组件：[https://docs.microsoft.com/en-us/azure/storage/common/storage-use-emulator#get-the-storage-emulator](https://docs.microsoft.com/en-us/azure/storage/common/storage-use-emulator#get-the-storage-emulator)。
- en: 'For the purpose of this exercise, I chose Http trigger and left all of the
    fields with their default values:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本练习的目的，我选择了 HTTP 触发器，并将所有字段保持为默认值：
- en: '![](img/a69ed484-e1fd-4fef-b1ae-c886c111d8b3.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a69ed484-e1fd-4fef-b1ae-c886c111d8b3.png)'
- en: 'When you click OK and wait for a second, you will see that a new function file
    has been created with some boilerplate code already inserted. Since I will explain
    both creating a function and its features in the next section, I will not explain
    this in detail at this moment. To make sure that everything is working correctly,
    press *F5* and wait until the project is compiled. You will notice two things:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击OK并稍等片刻，你将看到一个新的函数文件已被创建，并且一些模板代码已插入。由于我将在下一节解释如何创建函数及其特性，所以此时我不会详细解释。为了确保一切正常工作，按下
    *F5* 并等待项目编译完成。你将注意到两点：
- en: Storage Emulator will be started in the background to handle function requests
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Storage Emulator 将在后台启动以处理函数请求。
- en: A new window with the console application will open, displaying some diagnostic
    messages regarding Azure Functions
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将打开一个带有控制台应用程序的新窗口，显示一些关于 Azure Functions 的诊断消息。
- en: 'The former is the actual Azure Functions runtime, which handles the whole work
    when you communicate with your functions. Here, you can see how it looks on my
    computer:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 前者是实际的 Azure Functions 运行时，它在你与函数通信时处理所有工作。在这里，你可以看到它在我的计算机上的样子：
- en: '![](img/537df9e0-59dd-469e-9cd4-94bf0c08334e.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/537df9e0-59dd-469e-9cd4-94bf0c08334e.png)'
- en: 'It''s important to notice a few things:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意几点：
- en: It displays under which port the runtime listens to incoming requests
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它显示了运行时监听传入请求的端口。
- en: It tells you from which location the configuration file is fetched and loaded
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它告诉你配置文件是从哪个位置获取和加载的。
- en: It notifies you about loaded custom extensions (as I said, it is possible to
    introduce custom bindings, which will be loaded in the runtime)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会通知你已加载的自定义扩展（正如我所说，确实可以引入自定义绑定，它们将在运行时加载）。
- en: It displays the names (and URLs, in the case of HTTP triggers) of all found
    functions
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它显示了所有找到的函数的名称（以及在 HTTP 触发器的情况下，URL）。
- en: 'When you scroll down, you should be able to see an endpoint to the function
    you have just created:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向下滚动时，你应该能看到你刚刚创建的函数的端点：
- en: '![](img/c0971696-735a-4461-9df1-742013c0a1e7.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0971696-735a-4461-9df1-742013c0a1e7.png)'
- en: 'Now, we will try to call it to see whether it works (I am using Postman, but
    you can use any kind of tool you are familiar with):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将尝试调用它，看看它是否能正常工作（我正在使用 Postman，但你可以使用任何你熟悉的工具）：
- en: '![](img/69fc6484-6342-4b32-87a4-2b0f8ebfaefa.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69fc6484-6342-4b32-87a4-2b0f8ebfaefa.png)'
- en: 'As you can see, it works—it returned a result (though the result itself is
    not a success—we are missing a required field, but that is not an issue right
    now). If you send the same request, you should be able to see the same result.
    If, for some reason, you are unable to do so, do the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，它工作正常——它返回了一个结果（尽管结果本身不是成功的——我们缺少一个必需的字段，但现在这不是问题）。如果你发送相同的请求，你应该能够看到相同的结果。如果由于某种原因你无法这样做，请按照以下步骤操作：
- en: Make sure that your function's host is still working and that it displays no
    error
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你的函数主机仍在工作并且没有显示错误
- en: Make sure that the port under which the runtime listens for incoming requests
    is open
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保运行时监听传入请求的端口是开放的
- en: Make sure that the Azure Functions CLI is not blocked by your firewall
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保 Azure Functions CLI 没有被防火墙阻塞
- en: Make sure that you are calling the correct endpoint
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你正在调用正确的端点
- en: In the next section, I will describe the function's structure in detail so that
    you will be able to proceed with more advanced scenarios and features.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我将详细描述函数的结构，这样你就能继续进行更高级的场景和功能。
- en: Creating a function
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个函数
- en: We discussed the overall serverless approach and went through local configuration
    to make sure that we have some basic understanding of what Azure Functions are
    and how we can start working with them. In the following of this chapter, I will
    show you what exactly this service offers and how to work with it on daily basis.
    This will help you start developing full projects with Functions—from the simplest
    to the most advanced ones.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了整体的无服务器（serverless）方法，并通过本地配置来确保我们对 Azure Functions 有一些基本的了解，并知道如何开始使用它们。在本章的接下来的部分，我将向你展示这个服务究竟提供了什么，以及如何在日常工作中使用它。这将帮助你开始开发完整的项目，涵盖从最简单到最先进的功能。
- en: Using Visual Studio
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Visual Studio
- en: 'In the previous section, you created a function using a wizard in Visual Studio.
    If you go back to this particular project and open its file, you will see some
    common code, which is always created with this particular template. Here, you
    can find the same code but without the custom code introduced by it:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，你使用 Visual Studio 的向导创建了一个函数。如果你返回到这个特定的项目并打开它的文件，你会看到一些常见的代码，这些代码是使用这个特定模板创建的。在这里，你可以找到相同的代码，但没有它所引入的自定义代码：
- en: '[PRE1]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, I deleted the whole function body—this is the only part that
    is not a part of the service (remember our IaaS versus PaaS versus serverless
    comparison?). We can see some attributes, which decorate both a C# method and
    its parameters—they all are a part of the runtime that runs your functions. Let''s
    compare it with a function that is triggered by Azure Storage Queue:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我删除了整个函数体——这是唯一不属于服务的部分（还记得我们的 IaaS、PaaS 与无服务器的对比吗？）。我们可以看到一些属性，它们装饰了
    C# 方法及其参数——这些都是运行你函数的运行时的一部分。让我们将其与一个由 Azure 存储队列触发的函数进行比较：
- en: '[PRE2]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, you can see that still we have the `[FunctionName]` attribute and some
    kind of trigger attribute. What differs is, in fact, the type of trigger parameter—in
    HTTP, we had `HttpRequestMessage`, while in Queue, we have a simple `string` parameter.
    This parameter (and its type) directly define the type of message delivered to
    a function. In general, it is pretty clear—each HTTP request is deserialized and
    delivered as `HttpRequestMessage `(as in Web API, for example), and each in-queue
    service and each message is a string. However, how about the following signature:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们仍然有`[FunctionName]`属性和某种触发器属性。不同之处在于触发器参数的类型——在 HTTP 中，我们使用的是`HttpRequestMessage`，而在队列中，我们使用一个简单的`string`参数。这个参数（及其类型）直接定义了传递给函数的消息类型。总的来说，这是很清楚的——每个
    HTTP 请求都会被反序列化并作为`HttpRequestMessage`（例如在 Web API 中）传递，而每个队列服务和每个消息都是一个字符串。然而，以下签名又如何呢：
- en: '[PRE3]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the preceding example introduced one more parameter—`name`, which
    is a string, though the whole function is triggered by an HTTP request. This particular
    parameter will be used during the binding procedure, which will find that this
    function's route contains it in its URL template. This is the very same model
    as in traditional MVC/Web API frameworks, which provide the same feature.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，前面的示例引入了一个额外的参数——`name`，它是一个字符串，尽管整个函数是由 HTTP 请求触发的。这个特定的参数将在绑定过程中使用，绑定过程会发现该函数的路由在其
    URL 模板中包含它。这与传统的 MVC/Web API 框架中的模型是完全一样的，它们提供相同的功能。
- en: The binding procedure itself is quite complicated and mostly depends on the
    type of used trigger. Unfortunately, it is out of the scope of this book, so I
    will not cover it in detail—fortunately, Azure Functions are OSS, so you can check
    how the host works directly in the code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定过程本身相当复杂，主要取决于使用的触发器类型。不幸的是，这超出了本书的范围，所以我不会详细介绍——幸运的是，Azure Functions 是开源的，因此您可以直接查看主机是如何工作的。
- en: 'If you want to quickly add a new function to your project, perform the following
    steps:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想快速将新函数添加到您的项目中，请执行以下步骤：
- en: Right-click on your project in Visual Studio and search for the Add | New Azure
    Function... menu item.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中右键单击您的项目，然后搜索**添加 | 新建 Azure 函数...**菜单项。
- en: This will display a screen where you can enter new function name.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将显示一个屏幕，您可以在其中输入新的函数名称。
- en: 'When you click Add, you will see another screen, which allows you to select
    a function type with far more options than we initially saw:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您点击**添加**时，您将看到另一个屏幕，允许您选择函数类型，比我们最初看到的选项更多：
- en: '![](img/961c2e9b-c583-4b55-a88e-c241900fabd2.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/961c2e9b-c583-4b55-a88e-c241900fabd2.png)'
- en: Using Azure Portal
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Azure 门户
- en: 'As with all other Azure services, it is also possible to create a function
    app instance by creating it directly in Azure Portal:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有其他 Azure 服务一样，您也可以通过直接在 Azure 门户中创建来创建一个函数应用实例：
- en: When you log in, click on + Create a resourceand search for Function App.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录后，点击**+ 创建资源**并搜索**函数应用**。
- en: 'When you click Create, you will see a screen with a couple of fields that need
    to be filled in before processing occurs:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您点击**创建**时，您将看到一个屏幕，里面有几个字段需要在处理之前填写：
- en: '![](img/22559cc8-25f6-48b3-af0c-678a98446a35.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22559cc8-25f6-48b3-af0c-678a98446a35.png)'
- en: As you can see, the preceding form is familiar to the one we used when creating
    an App Service instance. This is because, under the hood, Azure Functions is powered
    by this particular service and multiple available features are shared between
    them. As you can see, you are able to select OS, which defines the runtime you
    will be able to use.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，前面的表单与我们在创建应用服务实例时使用的表单相似。这是因为，从底层上讲，Azure Functions 由这个特定服务提供支持，多个可用功能在它们之间共享。如您所见，您可以选择**操作系统**，这决定了您将能够使用的运行时。
- en: If you are interested in using .NET Core, you can start working with Linux as
    your OS. This is currently in preview, but allows for using the v2 version of
    the runtime. It has many enhancements and uses the newest .NET stack so, in many
    cases, it can be quicker than v1.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有兴趣使用 .NET Core，您可以将操作系统设置为 Linux。目前这是预览版，但它允许使用 v2 版本的运行时。它有许多增强功能，并使用最新的
    .NET 技术栈，因此在许多情况下，它比 v1 更快。
- en: In the Hosting Plan drop-down menu, you are able to select whether you want
    to use the Consumption Plan or App Service model for pricing. We discussed the
    differences between these in the previous part of this chapter, so you should
    be able to decide on which one to use by yourself. Remember that you will have
    to select the B1 tier at least.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在**托管计划**下拉菜单中，您可以选择是否使用**按需计划**或**应用服务**模型进行定价。我们在本章前面部分讨论了这两者的区别，所以您应该能够自己决定使用哪一个。记住，您至少需要选择**B1**等级。
- en: Azure Portal disallows you from using Shared or Free tiers as Azure Functions requires
    the Always Onfeature to be enabled—you probably remember that it is available
    only for Basic and higher tiers. While it is possible to create a function app with,
    for example, Free tier (using, for instance, ARM templates), it will not work
    correctly.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 门户不允许您使用**共享**或**免费**等级，因为 Azure Functions 需要启用**始终在线**功能——您可能还记得，只有基本等级及更高级别才可用。虽然可以使用，例如，**免费**等级（通过
    ARM 模板等）创建函数应用，但它不会正常工作。
- en: This wizard also gives you the possibility to enable Application Insights integration.
    Since we have not discussed this particular service yet, I will skip it in this
    chapter. However, if you are interested in monitoring your functions, it is a
    much better option than the integrated Monitor feature—it gives you much more
    detail and is much more intuitive in daily work.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个向导还为您提供了启用**应用程序洞察**集成的选项。由于我们尚未讨论这个特定服务，我将在本章中跳过它。不过，如果您有兴趣监控您的函数，它比集成的**监视**功能要好得多——它能提供更多细节，并且在日常工作中更加直观。
- en: Enabling Application Insightsfor your function app can drastically change the
    overall price of the whole service as, initially, each function produces many
    different traces and logs. For production, it is always a good idea to the lower
    logged severity of messages—you can find more information about configuration
    at: [https://docs.microsoft.com/en-us/azure/azure-functions/functions-monitoring](https://docs.microsoft.com/en-us/azure/azure-functions/functions-monitoring).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are satisfied with your settings, you can click Create. Azure Portal
    will validate all of the fields and initiate the service provisioning procedure.
    After several seconds, your function app should be ready for work. When you go
    to it, you will see the dashboard, which is the starting point for accessing all
    of the features of Azure Functions:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/088ace13-4f61-49d8-a20a-44081da782b3.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
- en: 'Now, if you want to create a function, move your mouse cursor over the Functions section
    and click on the plus sign (+). It will display a new wizard screen, where you
    can choose to either start with a premade function or create a custom one. For
    the purpose of this exercise, I decided to go with a timer function written in
    JavaScript:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a15974d-efbb-41b9-81b0-76ae63037882.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: 'After clicking on the Create this functionbutton, you will see that some function
    code has been generated. Azure Portal allows also you to edit a function directly
    in your browser window, so if you want to try out some custom code, there is nothing
    preventing you from doing so:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54e8d4f8-3c6e-4ccf-b781-7fb7276f2d53.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: 'Additionally, you can click Run—this is the so-called **manual trigger** and
    enables you to start a function immediately. The result of running a function
    will be visible in the Logs window:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Congratulations—you have learned how to create a function using both Visual
    Studio and Azure Portal. In the next section, I will describe more advanced scenarios
    and will focus on understanding further Azure Functions features.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Azure Functions features
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Functions is not only about providing executable code, which will be handled
    by the runtime. It allows for even more advanced scenarios, which make this service
    an excellent choice when you want to start developing quickly and with minimal
    configuration required. In this section, I will show you how to leverage more
    advanced features of functionsand how to progress with your skill in using this
    Azure component.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Platform features
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you may remember, Azure Functions is built on top App Service, which allows
    you to use multiple already known features, such as Custom domains, Application
    settings, and Authentication/Authorization. To access all available Platform features,go
    to your function app in Azure Portal and click on the appropriate tab:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca997ca5-430f-46be-843a-4259c00fcae5.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
- en: As you can see, we have a variety of different features available—what you are
    interested in depends solely on your specific requirements. There is, however,
    one function-specific feature that I would like to describe: Function app settings.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click on this link, a new tab will open, with some crucial options
    that can be set:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7dd59cbc-7818-4ed9-99d7-5f56b92b5057.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, you can see that most of the features are either
    not enabled or unavailable. This depends on the state of your function app—by
    design, all problematic functionalities are opt-out, so they will not interfere
    with your functions. Anyway, I will describe them here so that you can decide
    whether you need them or not:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Daily Usage Quota (GB-Sec): If you want to set a hard limit for function app usage,
    you can set it here. Thanks to this, you can ensure that it will not exceed some
    predefined quota you are aiming at.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Runtime version: This setting defines the current runtime version your function
    app uses. Note that it is not possible to change v1 to beta (v2, in this case),
    as it is possible that the newer version introduces some changes that would break
    your application.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Function app edit mode: If you decide to deploy your functions with any kind
    of CI/CD pipeline, this setting will be automatically set to Read Only. This ensures
    that it is not possible to introduce changes while in runtime without going through
    the automated process.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Slots (preview): If you want to perform blue/green deployment (to perform a
    rapid rollback if something goes wrong), this enables you to deploy a new version
    as a new instance and immediately swap it with the existing one.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have not covered another important topic yet—Azure Functionsecurity. While
    it is possible to use, for example, Azure Active Directory or social providers
    as identity sources (and—as a result—add authentication to a function app), by
    default, functions are secured by their keys. You can check the available keys
    when you click on the Manage tab:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21bd3666-5676-4f2d-a401-84df75b1b134.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: 'Depending on the way a function is triggered, different options may be available.
    Here, you can see what another function app looks like when it is triggered by
    an HTTP trigger instead of a timer:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f00e9a65-5c87-4b97-a581-1661cdd873c5.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we have two types of keys available:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'Function Keys: These are designed for this particular function'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Host Keys: These allow for calling any function within a function app
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use keys as an easy way to implement authorization in your function
    app. You can generate a new one for each client, revoke them, and set a particular
    value.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Note that function keys are designed for functions that are triggered by HTTP
    requests—there is no possibility to use them for other kinds of triggers.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways of using function keys to authorize a request. You can put
    them in the query string:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Or you can use headers and introduce the `x-functions-key`header, which will
    contain a key inside it:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Monitor
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each call and each execution of a function is monitored and saved. When you
    click on the Monitor tab, you will see a screen that contains the next execution
    with some diagnostics data.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: If you do not see a list, you will probably be asked to enable the Application
    Insights integration. To access standard view, click on the Switch to classic
    viewbutton.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can see the log of executions of my function, triggered by a timer:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/879c8038-c6ce-4489-b3fb-60603cb35f12.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: As you can see, it contains information about each particular execution, the
    success and error count, and invocation details. When you select a specific item,
    you will also see all of the logs from a function.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: The Monitor feature is quite useful for quickly analyzing issues. For more detailed
    errors and logs, you will have to enable Application Insights and use its features.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Host.json
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you create a function, you will see that a `host.json`file is  automatically
    created. While initially empty, it is a global configuration file that defines
    how triggers and function will behave. Here, you can find an example file with
    most features, such as bindings'' configuration and generic features, available:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, it contains things such as logger settings, function timeout
    value, and particular triggers configuration. In the *Further reading*section,
    you will find a link where each section of the `host.json` file is described in
    detail.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Publish
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Azure Functions are published the very same way as App Service, since they
    share many common parts. If you right-click on your functions project in Visual
    Studio and select Publish, you will see a screen that''s similar to the one we
    saw when working with App Services:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6aea865a-9775-42d3-8585-103a8d20c47f.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
- en: 'Traditionally, you have the possibility to select to either create a new function
    app or use an existing one. When you use the existing one and click on the Publish button,
    you will be able to find a function app in a specific Resource Group:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05452f09-82d6-4e51-afa0-ea910913fa3a.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: Now, when you click OK, a new publish profile will be created and the whole
    application will be deployed.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Workflow in Azure Functions – Durable Functions
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most cases, the best idea for working with functionsis to keep them stateless.
    This makes things much easier as you do not have to worry about sharing resources
    and storing state. However, there are cases where you will like to access it and
    distribute between different instances of your functions. In such scenarios (such
    as orchestrating a workflow or scheduling a task to be done), a better option
    to start with would be to leverage the capabilities of Durable Functions, an extension
    to the main runtime, which changes the way you work a little bit.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: It changes the way Azure Functions works as it lets you resume from where the
    execution was paused or stopped and introduces the possibility to take the output
    of one function and pass it as input. We will not cover this in detail, as this
    book is not only about Azure Functions, but you will get a glimpse of this feature,
    which will help you start it on your own.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: To get started, you don't need any extra extensions—the only thing you will
    need is an additional NuGet package named `Microsoft.Azure.WebJobs.Extensions.DurableTask`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Orchestrations and activities
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main elements of Durable Functions are orchestrations and activities. There
    are some significant differences between them:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '`Orchestrations`: These are designed to orchestrate different activities. They
    should be single-threaded and idempotent, and they can use only a very limited
    set of asynchronous methods. They are scaled based on the number of internal queues.
    What''s more, they control the flow of one or more activities.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Activities`: These should contain most of the logic of your application. They
    work as typical functions (without the limits of orchestrations). They are scaled
    to multiple VMs.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, you can find the code for both types of functions:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, they are both decorated with the `[FunctionName]`attribute as
    a typical function—the difference comes from the trigger that's used.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Orchestration client
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started with an orchestration, you need a host for it. In Durable Functions,
    that host is the orchestration client, which enables you to perform the following
    actions on an orchestration:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Start it
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminate it
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get its status
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raise an event and pass it to an orchestration
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The basic code for a client is pretty simple:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see from the preceding code, we started an orchestration by providing
    its name and passing some payload, which will be deserialized and decoded. Here,
    you can find an example of a client that has been hosted to terminate an instance
    by passing its identifier:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Orchestration history
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The way Durable Functions work ensures that, if any activity is replayed, its
    result will not be evaluated again (this is why orchestrations have to be idempotent).
    Here, you can find a diagram that shows how the framework works in detail:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d497554-936a-4975-8053-f65635e6301b.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: 'To make a long story short, I divided the process into four parts:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '**Dispatcher**: This is the internal part of the framework, which is responsible
    for calling orchestrations, performing replays, and saving the state'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Orchestrator function**: This is an orchestration that calls activities'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage**:This is a place where the orchestration history is stored'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Queue**: This is an internal queue (implemented using Azure Storage Queues),
    which is used to control the flow of execution of an orchestration'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The way Durable Functions works is as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Dispatchers run an orchestration, which calls `Activity1` and awaits its result
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The control is returned to a dispatcher, which commits the state in the orchestration
    history and pushes a message to a queue
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the meantime, orchestration is deallocated, saving memory and processor
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After fetching a message from a queue and finishing a task, the dispatcherrecreates
    an orchestration and replays all activities
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it finds that this particular activity has been finished, it gets only its
    result and proceeds to another activity
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding process lasts until all of the activities are processed. Information
    about execution history can be found in a table called `DurableFunctionsHubHistory`,
    which you can find inside the Azure Table Storage used by your function app.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Timers
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, you might want to schedule work after a specific delay. While using
    traditional functions, you have to create a custom solution that will somehow
    trigger a workflow at a specific time. In Durable Functions, it is as easy as
    writing one line of code. Consider the following example:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding example, I used the `context.CreateTimer()`method, which allows
    for creating a delay in function execution. If the previous orchestration is executed,
    it will return control to the dispatcher after awaiting a timer. Thanks to this,
    you will not be charged for this particular function execution as it will be deallocated
    and recreated later, after waiting for a specific interval.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: External events
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Durable Functions, it is possible to wait for an external event before proceeding
    with a workflow. This is especially helpful if you want to create an interactive
    flow, where you initiate a process in one place and have a requirement to wait
    for someone''s decision. To raise an event, you can use the following function:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, you can find an example of waiting for an event:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The way this works can be described as follows: the first functions allows
    you to raise a custom event by passing the appropriate parameters. The second
    function is paused while waiting for the `context.WaitForExternalEvent()` function.
    If you send an event with the `Approved` type, a function will be resumed and
    will continue. Additionally, you can pass a payload of an event, which will be
    passed as a result of `WaitForExternalEvent()`. This method works in the same
    way as timers and other Durable Functions functions, which are available in `DurableOrchestrationType`—while
    awaiting, control is returned to the dispatcher and the function itself is deallocated.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Integrating functions with other services
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last part of this chapter, we will focus a little bit on understanding
    how Azure Functions integrate with other Azure services. We will take a look at
    the available triggers and bindings and try to figure out the best use cases for
    them and how they really work. This section is designed in a way that enables
    you to explore more by yourself, thanks to a common understanding of how Azure
    Functions work.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Function file
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you take a look at your `bin `directory, where compiled functions are available,
    you will find a bit of a different structure than in traditional applications.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can find my folder from the exercise from this chapter:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a09935d-9b0f-4893-914a-9014868582d0.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, it contains the `Function1` directory, which contains one file
    named `function. json`. Here, you can find its content:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It defines some metadata, which is further used by the function''s runtime
    and the `bindings` field, which is a definition of used triggers. If you compare
    it with a code attribute, you will see that it is quite similar:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When you compile your project, a compiler will produce a `function.json`file
    for each function defined in your code. Here, you can find the output for the
    event hub trigger:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, it has the same structure and only the `bindings` field differs,
    so it reflects another trigger type.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Note that the content and structure of `function.json` may differ depending
    on the SDK version used. Do not use it in your application directly to avoid problems
    that have a lack of backward compatibility.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Input/output bindings
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some bindings are bi-directional,  while some can be used only one way. What''s
    more, not every binding can be used as a trigger. An example of both bi-directional
    and trigger binding is Azure Blob Storage*.* Here, you can find an example of
    how it works as a trigger:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Compare it with an example of a function triggered by a queue, but accepting
    blob as input:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you can see, I used the same syntax in both cases besides one thing—I declared
    `FileAccess.Read`to tell the runtime that this is not a trigger. Here is another
    example of output:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, the syntax is still similar—the only thing that has changed
    is the `FileAccess` value. There are also other possibilities for using the return
    value of a function. Here, you can find out how to define the result by using
    an attribute:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Custom bindings
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While Azure Functions offer a variety of different bindings for many different
    scenarios, sometimes, you want a custom functionality that is not available. In
    such cases, it is possible to create a custom binding, which I mentioned earlier
    in this chapter. To generate it, you need the following things:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: An attribute decorated with the `[Binding]`attribute
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An implementation of the `IBindingProvider` interface
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An implementation of the `IBinding` interface
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An implementation of the `IExtensionConfigProvider` interface
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By providing all of the preceding implementations, your binding will be automatically
    fetched by the runtime and enabled. If everything is set correctly, you will be
    notified of this during runtime start:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b70e3ea1-aced-41b4-8e88-8b89ccda9112.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you can see that the runtime extracted `IdentityExtensionConfig
    Provider` from my code, which will be used later when resolving my custom binding.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned a lot about Azure Functions and how to work
    with this serverless component. You read about the differences in pricing models,
    scalability concerns, and basic triggers and bindings. We worked on some simple
    scenarios regarding monitoring, deploying, and developing this Azure service.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapters in this book, you will learn even more about serverless services.
    We will then come back to work even more with functions, as this is one of the
    most popular Azure components that can be easily integrated with other tools and
    products.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between App Service and the consumption pricing model?
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is GB/s?
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you create stateful services with Azure Functions?
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the name of a container that's used for functions?
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you use Python in Azure Functions?
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can a binding act both as a trigger and output? Can you provide an example?
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is a function app mode sometimes set as read-only?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you use the Application Settingsfeature in the same way as in App Services?
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Azure Functions overview: [https://docs.microsoft.com/en-us/azure/azure-functions/functions-overview](https://docs.microsoft.com/en-us/azure/azure-functions/functions-overview)'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`host.json` description: [https://docs.microsoft.com/en-us/azure/azure-functions/functions-host-json](https://docs.microsoft.com/en-us/azure/azure-functions/functions-host-json)'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The schema of the `functions.json` file: [http://json.schemastore.org/function](http://json.schemastore.org/function)'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Triggers and bindings for Azure Functions: [https://docs.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings](https://docs.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings)'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Durable Functions: [https://docs.microsoft.com/en-us/azure/azure-functions/durable-functions-overview](https://docs.microsoft.com/en-us/azure/azure-functions/durable-functions-overview)'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
