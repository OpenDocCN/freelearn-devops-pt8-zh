- en: Serverless and Azure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Functions are the main product of serverless architecture in Azure. They
    allow for executing small pieces of code within fully managed runtime, so we don't
    have to care about performance and scalability. They are open source, open for
    extensions, and built on top of App Services, so they provide a similar experience
    to WebJobs. Microsoft pays much attention to developing new features for Azure
    Functions and, with great support from the community, it's one of the best tools
    for quickly developing both simple and serious applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Azure Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring local environment for developing Azure Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Functions features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Workflow in Azure Functions—Durable Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating functions with other services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start using Azure Functions and to perform the exercises in this chapter,
    you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2017 with Azure workload installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Functions and the WebJobs tools extension for Visual Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Azure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Functions are a part of so-called serverless components that are available
    in the Azure cloud. Before you start learning about this particular service, you
    will have to understand what serverless really means. While, initially, you may
    think that this concept implies no servers at all, you will quickly re-evaluate your
    way of thinking (as, we are still quite far away from not using any kind of machine
    for our applications and workloads).
  prefs: []
  type: TYPE_NORMAL
- en: Being "serverless"
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can easily find many different articles describing the term serverless—to
    be honest, I would like to avoid promoting a one and only correct definition,
    as this topic is currently so fuzzy, it is hard to find the best description.
    My goal, however, is to give you some hints and best practices, which will let
    you understand it in a way that makes the most sense to you.
  prefs: []
  type: TYPE_NORMAL
- en: Responsibilities of cloud vendors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start with the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b73380e1-ea4f-4fd8-a1e2-1d08c371de11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, you can see the comparison of two of the most
    popular cloud models with serverless architecture regarding vendor responsibility.
    I compared them using five different fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data center**: DC infrastructure, security, maintenance, and staff'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network security**: Implementing correct and secure solutions regarding the
    network (firewalls, pen-tests, and anti-DDoS solutions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operating systems**: Updates, maintenance, and configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dev tools**: Developing and delivering multiple features for programmers
    and administrators (such as extensions to IDE, management portal, and appropriate
    tools for managing services)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application host**: The specific runtime that hosts and runs our application
    (such as App Service Plan)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the only difference (at least when using the described characteristics)
    is the application host. When it comes to serverless components, the only thing
    that you deliver to your solution is your code (or some kind of configuration,
    which is needed to set up a service)—the rest is delivered and handled by your
    cloud vendor. Of course, this is not the only way to define this idea.
  prefs: []
  type: TYPE_NORMAL
- en: Pricing model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most popular features of serverless services and architectures is
    the possibility to pay for the number of executions and used computing power.
    This pricing model is the exact opposite of the most common prepaid model, where
    you pay a fixed price depending on a set of configured fields such as the number
    of used VMs or the size of a cluster. Here, you can find a table describing pricing
    for Azure Functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Meter | Price | Free grant (per month) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Execution time | €0.000014/GB/s | 400.000 GB/s |'
  prefs: []
  type: TYPE_TB
- en: '| Total executions | €0.169 per million executions | 1 million executions |'
  prefs: []
  type: TYPE_TB
- en: 'Now, you may wonder how can you understand this so that you can calculate the
    estimated cost of your solution. There are two things you have to understand to
    make your calculation correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Execution**: This is a single function execution, which lasts *N* seconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consumption**: This defines how many resources (CPU and memory) your function
    consumes within a fixed time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, if you compare the preceding terms with the table, you will see that they
    differ slightly. This is because Azure Functions, pricing does not directly define
    the price for consumption but, rather, uses execution time.
  prefs: []
  type: TYPE_NORMAL
- en: You have probably noticed the free grantcolumn in the pricing table. Remember
    that it applies only to the consumption model—it will not work for the prepaid
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s assume that you have estimated the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You will need 10 million executions of your function per month
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each execution lasts ~80 ms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are using 145 MB of memory per execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To calculate the whole price for using Azure Functions, you can use the following
    formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae3ecd9e-6a48-47ed-8717-1bd3a0b92e39.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the previous formula, the following is applicable:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rc**: Resource consumption defined as a product of memory consumed and execution
    time (in GB/s)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Te:** Total executions number (in millions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, if you enter the correct values and calculate the formula, you will get
    the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1a9cc0a-d1c1-43f9-a24b-4c7d10ed2fed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will give you the following cost: 5.19 EUR. However, you may find the
    previous formula a bit confusing—why did I use *256 *(instead of 128)as the amount
    of memory consumed and* 1 Ms*(instead of 800 Ks)as the execution time? Well, there
    is one important thing to remember when using the consumption plan: the minimum
    execution time is 100 ms and when it comes to resources consumption, it is always **rounded
    up **to the nearest 128 MBs.'
  prefs: []
  type: TYPE_NORMAL
- en: In fact, when it comes to function execution, you cannot go under 100 ms and
    128 MBs of used memory. This is very important when calculating possible cost
    optimization as, often, you should not aim at optimizing functions and rather
    focus on overall algorithm changes (such as batching or better serialization methods).
  prefs: []
  type: TYPE_NORMAL
- en: Azure Functions concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you are a bit familiar with what serverless architecture is, we can
    start learning something else about Azure Functions. To proceed, you will need
    to understand the difference between the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Function apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Triggers and bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The logical container for multiple functions is called a function app. A function
    app can host one or more functions, which will share configuration, settings,
    and runtime version. It is possible to run functions using multiple languages
    using the same function app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can see what a single function app looks like, with several individual
    functions hosted within it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8abe2854-700b-4e08-b6dd-a0db7530a46c.png)'
  prefs: []
  type: TYPE_IMG
- en: If you have the requirement to use both pricing plans (consumption and App Service),
    you will have to have two different functions apps, as a single one does not support
    such a scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A single executable part of Azure Functions that hosts your code is called a
    **function**. Each function can execute code written in different supported languages
    (one can use C#, while another can leverage Python features). The currently supported
    languages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: F#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second version of runtime (v2), Java should also be available to use.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that, at the time of writing this book, the v1 version is the only
    one that supports production workloads.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also the possibility of using a set of other languages (such as Powershell,
    PHP, or Batch), but they are in experimental mode and are not to be used in production.
    Here, you can find an example function with some boilerplate code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that the previous code was generated using Visual Studio—the boilerplate
    generated in Azure Portal looks a little bit different.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, a function consists of the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Function decorator**:` [FunctionName]`, which allows the runtime to find
    a function, and delivers the required metadata'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trigger**: `[QueueTrigger]`—each function requires a trigger to be configured
    correctly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Additional bindings**: `TraceWriter`, which will be injected during runtime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Function code: **The actual logic that will be executed each time the function
    is called'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, some parts of a function will differ depending on the features you
    use—in the previous example, we used a trigger for Azure Storage Queue, but there
    are also other possibilities (such as HTTP request, Azure Service Bus, or Azure
    CosmosDB); additionally, you can use other bindings and provide custom code each
    time. We will cover all of these topics in the following sections of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Triggers and bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The power of Azure Functions comes when you consider all possible integrations,
    which can be used seamlessly and without much additional effort. In fact, the
    list of available triggers and bindings are quite impressive:'
  prefs: []
  type: TYPE_NORMAL
- en: Azure Storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure CosmosDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Event Grid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Event Hub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft Graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Mobile Apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Notification Hub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Service Bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Twilio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SendGrid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, you have access to some experimental triggers and bindings, which
    may not be officially supported, but can be used in your application if you decide
    to do so (such as external files and external tables).
  prefs: []
  type: TYPE_NORMAL
- en: Remember that some experimental triggers and bindings will never reach GA status
    as there are specific recommendations (such as using Azure Logic Apps), which
    should be followed in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, it is possible to introduce custom triggers and bindings since Azure
    Functions provides a full SDK, which can be used to extend runtime. However, this
    is an advanced topic that will be not covered in this book—you will find a reference
    to the appropriate tutorials in the *Further reading*section. Here, you can find
    an example of a custom binding, which I used for authorizing a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51163900-ab4e-4954-8200-e54f00e0c037.png)'
  prefs: []
  type: TYPE_IMG
- en: Pricing models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Azure Functions, there are two pricing models available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Consumption model**: This wasdescribed in the previous sections, where you
    pay for the number of executions of your functions and the computing power used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**App Service Plan ****model**: This is where you select an App Service Plan
    version, which has a fixed price, no matter how many times you execute your functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important features of serverless components and architectures
    is their ability to scale out as they are loaded more and more. While in traditional
    PaaS services, you often have to worry about available instances or scaling configuration.
    Serverless allows for the seamless handling of incoming requests, even if a service
    is hit by an unexpectedly high traffic. In this section, we will talk about the
    scaling capabilities of Azure Functions, with a focus on differences between consumption
    and App Service models.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling in the consumption model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you use the consumption model in Azure Functions, you are not defining
    any available instances for your service and are unable to configure auto-scaling
    settings. In fact, in this model, you are completely unaware of the number of
    machines running your workloads (however, if you integrate your functions with
    Azure Application Insights, you will be able to see how many instances have been
    created by taking a look at the **Live Stream** blade).
  prefs: []
  type: TYPE_NORMAL
- en: In the consumption model, you have a fixed limit when it comes to the memory
    available for each execution of your function—this is 1.536 MBs. Whether your
    functions will scale or not depends on the current utilization of both memory
    and CPU.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of this plan is the ability to easily scale to hundreds of functions
    while running the same code concurrently. Of course, it all depends on the actual
    trigger used in a function—while, with the HTTP trigger, you have to scale out
    to be able to handle multiple requests at once, using the event hub trigger, for
    instance, will automatically increase the number of working instances for each
    partition used. On the other hand, you cannot always rely on the consumption plan
    to be sure that you will not expect delays in responses or temporary unavailability—immediate
    scaling out is not guaranteed by any means, so this particular pricing plan is
    not always the best solution when your application has to face quick peaks of
    traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the current maximum for scaling a function app is limited to 200\.
    Also worth noting is the fact that the runtime will allocate new instances no
    often than every 10 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling in the App Service model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the App Service model has its benefits, especially when it comes to covering
    some cases of scaling that are not covered in the consumption plan. As mentioned
    in the previous section, if you have to be sure that you are able to handle the
    incoming load, it is often a better idea to use this particular model, as it ensures
    that some fixed resources will be available for your function app. Additionally,
    you are 100% sure that the provided hardware is provisioned for your application—this
    is not always the case in the consumption model since you have no guarantees when
    it comes to delivered machines and their characteristics. What's more, you are
    sure that your runtime is always running—since, in the consumption model, when
    a function is not used, its resources will be de-allocated, you can face quite
    common issues such as cold starts.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the local environment for developing Azure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started with Azure Functions, we will need an environment that will allow
    us to test our functions and start developing them quickly and seamlessly. Fortunately,
    this particular Azure service comes with multiple tools that help us during programming
    and running them locally. I will describe some extra applications as well, which
    should help you analyze and debug possible problems and test triggers before deploying
    to the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with Azure Functions locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have installed all of the required software mentioned at the beginning
    of this chapter, you should be able to start developing them without any additional
    configuration. To get started, we will create a simple function that we will try
    to run to make sure that everything is set and ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you open your Visual Studio instance, click on File | New Project. In
    the new screen, search for the Cloud | Azure Functions template:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66b6c426-c55a-4ad6-a632-e2b42063db37.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the first step that will ensure that everything on your side is configured
    correctly. When you click OK, you will see another screen that lets you select
    a few different things:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Runtime version**: You can choose between v1 and v2\. In this book, we will
    focus on v1 as v2 is still in preview.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trigger type**: Depending on the SDK version you have, you will have different
    options available. Of course, this is not the full list of available triggers
    for Azure Functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage Account**: Most functions require a storage account to work. Fortunately,
    you can use Storage Emulator locally, which is a simple database running under
    the `LocalDB` instance that''s installed on your computer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new version of SDK for Azure should install Storage Emulator automatically.
    If, for some reason, you are missing it, go to the following page and install
    the missing component: [https://docs.microsoft.com/en-us/azure/storage/common/storage-use-emulator#get-the-storage-emulator](https://docs.microsoft.com/en-us/azure/storage/common/storage-use-emulator#get-the-storage-emulator).
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purpose of this exercise, I chose Http trigger and left all of the
    fields with their default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a69ed484-e1fd-4fef-b1ae-c886c111d8b3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you click OK and wait for a second, you will see that a new function file
    has been created with some boilerplate code already inserted. Since I will explain
    both creating a function and its features in the next section, I will not explain
    this in detail at this moment. To make sure that everything is working correctly,
    press *F5* and wait until the project is compiled. You will notice two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Storage Emulator will be started in the background to handle function requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new window with the console application will open, displaying some diagnostic
    messages regarding Azure Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The former is the actual Azure Functions runtime, which handles the whole work
    when you communicate with your functions. Here, you can see how it looks on my
    computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/537df9e0-59dd-469e-9cd4-94bf0c08334e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s important to notice a few things:'
  prefs: []
  type: TYPE_NORMAL
- en: It displays under which port the runtime listens to incoming requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It tells you from which location the configuration file is fetched and loaded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It notifies you about loaded custom extensions (as I said, it is possible to
    introduce custom bindings, which will be loaded in the runtime)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It displays the names (and URLs, in the case of HTTP triggers) of all found
    functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you scroll down, you should be able to see an endpoint to the function
    you have just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0971696-735a-4461-9df1-742013c0a1e7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we will try to call it to see whether it works (I am using Postman, but
    you can use any kind of tool you are familiar with):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69fc6484-6342-4b32-87a4-2b0f8ebfaefa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, it works—it returned a result (though the result itself is
    not a success—we are missing a required field, but that is not an issue right
    now). If you send the same request, you should be able to see the same result.
    If, for some reason, you are unable to do so, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that your function's host is still working and that it displays no
    error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that the port under which the runtime listens for incoming requests
    is open
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that the Azure Functions CLI is not blocked by your firewall
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that you are calling the correct endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, I will describe the function's structure in detail so that
    you will be able to proceed with more advanced scenarios and features.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed the overall serverless approach and went through local configuration
    to make sure that we have some basic understanding of what Azure Functions are
    and how we can start working with them. In the following of this chapter, I will
    show you what exactly this service offers and how to work with it on daily basis.
    This will help you start developing full projects with Functions—from the simplest
    to the most advanced ones.
  prefs: []
  type: TYPE_NORMAL
- en: Using Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, you created a function using a wizard in Visual Studio.
    If you go back to this particular project and open its file, you will see some
    common code, which is always created with this particular template. Here, you
    can find the same code but without the custom code introduced by it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, I deleted the whole function body—this is the only part that
    is not a part of the service (remember our IaaS versus PaaS versus serverless
    comparison?). We can see some attributes, which decorate both a C# method and
    its parameters—they all are a part of the runtime that runs your functions. Let''s
    compare it with a function that is triggered by Azure Storage Queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can see that still we have the `[FunctionName]` attribute and some
    kind of trigger attribute. What differs is, in fact, the type of trigger parameter—in
    HTTP, we had `HttpRequestMessage`, while in Queue, we have a simple `string` parameter.
    This parameter (and its type) directly define the type of message delivered to
    a function. In general, it is pretty clear—each HTTP request is deserialized and
    delivered as `HttpRequestMessage `(as in Web API, for example), and each in-queue
    service and each message is a string. However, how about the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the preceding example introduced one more parameter—`name`, which
    is a string, though the whole function is triggered by an HTTP request. This particular
    parameter will be used during the binding procedure, which will find that this
    function's route contains it in its URL template. This is the very same model
    as in traditional MVC/Web API frameworks, which provide the same feature.
  prefs: []
  type: TYPE_NORMAL
- en: The binding procedure itself is quite complicated and mostly depends on the
    type of used trigger. Unfortunately, it is out of the scope of this book, so I
    will not cover it in detail—fortunately, Azure Functions are OSS, so you can check
    how the host works directly in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to quickly add a new function to your project, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on your project in Visual Studio and search for the Add | New Azure
    Function... menu item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will display a screen where you can enter new function name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you click Add, you will see another screen, which allows you to select
    a function type with far more options than we initially saw:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/961c2e9b-c583-4b55-a88e-c241900fabd2.png)'
  prefs: []
  type: TYPE_IMG
- en: Using Azure Portal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with all other Azure services, it is also possible to create a function
    app instance by creating it directly in Azure Portal:'
  prefs: []
  type: TYPE_NORMAL
- en: When you log in, click on + Create a resourceand search for Function App.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you click Create, you will see a screen with a couple of fields that need
    to be filled in before processing occurs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/22559cc8-25f6-48b3-af0c-678a98446a35.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the preceding form is familiar to the one we used when creating
    an App Service instance. This is because, under the hood, Azure Functions is powered
    by this particular service and multiple available features are shared between
    them. As you can see, you are able to select OS, which defines the runtime you
    will be able to use.
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in using .NET Core, you can start working with Linux as
    your OS. This is currently in preview, but allows for using the v2 version of
    the runtime. It has many enhancements and uses the newest .NET stack so, in many
    cases, it can be quicker than v1.
  prefs: []
  type: TYPE_NORMAL
- en: In the Hosting Plan drop-down menu, you are able to select whether you want
    to use the Consumption Plan or App Service model for pricing. We discussed the
    differences between these in the previous part of this chapter, so you should
    be able to decide on which one to use by yourself. Remember that you will have
    to select the B1 tier at least.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Portal disallows you from using Shared or Free tiers as Azure Functions requires
    the Always Onfeature to be enabled—you probably remember that it is available
    only for Basic and higher tiers. While it is possible to create a function app with,
    for example, Free tier (using, for instance, ARM templates), it will not work
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: This wizard also gives you the possibility to enable Application Insights integration.
    Since we have not discussed this particular service yet, I will skip it in this
    chapter. However, if you are interested in monitoring your functions, it is a
    much better option than the integrated Monitor feature—it gives you much more
    detail and is much more intuitive in daily work.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling Application Insightsfor your function app can drastically change the
    overall price of the whole service as, initially, each function produces many
    different traces and logs. For production, it is always a good idea to the lower
    logged severity of messages—you can find more information about configuration
    at: [https://docs.microsoft.com/en-us/azure/azure-functions/functions-monitoring](https://docs.microsoft.com/en-us/azure/azure-functions/functions-monitoring).
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are satisfied with your settings, you can click Create. Azure Portal
    will validate all of the fields and initiate the service provisioning procedure.
    After several seconds, your function app should be ready for work. When you go
    to it, you will see the dashboard, which is the starting point for accessing all
    of the features of Azure Functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/088ace13-4f61-49d8-a20a-44081da782b3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if you want to create a function, move your mouse cursor over the Functions section
    and click on the plus sign (+). It will display a new wizard screen, where you
    can choose to either start with a premade function or create a custom one. For
    the purpose of this exercise, I decided to go with a timer function written in
    JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a15974d-efbb-41b9-81b0-76ae63037882.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After clicking on the Create this functionbutton, you will see that some function
    code has been generated. Azure Portal allows also you to edit a function directly
    in your browser window, so if you want to try out some custom code, there is nothing
    preventing you from doing so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54e8d4f8-3c6e-4ccf-b781-7fb7276f2d53.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Additionally, you can click Run—this is the so-called **manual trigger** and
    enables you to start a function immediately. The result of running a function
    will be visible in the Logs window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations—you have learned how to create a function using both Visual
    Studio and Azure Portal. In the next section, I will describe more advanced scenarios
    and will focus on understanding further Azure Functions features.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Functions features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Functions is not only about providing executable code, which will be handled
    by the runtime. It allows for even more advanced scenarios, which make this service
    an excellent choice when you want to start developing quickly and with minimal
    configuration required. In this section, I will show you how to leverage more
    advanced features of functionsand how to progress with your skill in using this
    Azure component.
  prefs: []
  type: TYPE_NORMAL
- en: Platform features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you may remember, Azure Functions is built on top App Service, which allows
    you to use multiple already known features, such as Custom domains, Application
    settings, and Authentication/Authorization. To access all available Platform features,go
    to your function app in Azure Portal and click on the appropriate tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca997ca5-430f-46be-843a-4259c00fcae5.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we have a variety of different features available—what you are
    interested in depends solely on your specific requirements. There is, however,
    one function-specific feature that I would like to describe: Function app settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click on this link, a new tab will open, with some crucial options
    that can be set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7dd59cbc-7818-4ed9-99d7-5f56b92b5057.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, you can see that most of the features are either
    not enabled or unavailable. This depends on the state of your function app—by
    design, all problematic functionalities are opt-out, so they will not interfere
    with your functions. Anyway, I will describe them here so that you can decide
    whether you need them or not:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Daily Usage Quota (GB-Sec): If you want to set a hard limit for function app usage,
    you can set it here. Thanks to this, you can ensure that it will not exceed some
    predefined quota you are aiming at.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Runtime version: This setting defines the current runtime version your function
    app uses. Note that it is not possible to change v1 to beta (v2, in this case),
    as it is possible that the newer version introduces some changes that would break
    your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Function app edit mode: If you decide to deploy your functions with any kind
    of CI/CD pipeline, this setting will be automatically set to Read Only. This ensures
    that it is not possible to introduce changes while in runtime without going through
    the automated process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Slots (preview): If you want to perform blue/green deployment (to perform a
    rapid rollback if something goes wrong), this enables you to deploy a new version
    as a new instance and immediately swap it with the existing one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have not covered another important topic yet—Azure Functionsecurity. While
    it is possible to use, for example, Azure Active Directory or social providers
    as identity sources (and—as a result—add authentication to a function app), by
    default, functions are secured by their keys. You can check the available keys
    when you click on the Manage tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21bd3666-5676-4f2d-a401-84df75b1b134.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Depending on the way a function is triggered, different options may be available.
    Here, you can see what another function app looks like when it is triggered by
    an HTTP trigger instead of a timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f00e9a65-5c87-4b97-a581-1661cdd873c5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we have two types of keys available:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Function Keys: These are designed for this particular function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Host Keys: These allow for calling any function within a function app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use keys as an easy way to implement authorization in your function
    app. You can generate a new one for each client, revoke them, and set a particular
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Note that function keys are designed for functions that are triggered by HTTP
    requests—there is no possibility to use them for other kinds of triggers.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways of using function keys to authorize a request. You can put
    them in the query string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can use headers and introduce the `x-functions-key`header, which will
    contain a key inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Monitor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each call and each execution of a function is monitored and saved. When you
    click on the Monitor tab, you will see a screen that contains the next execution
    with some diagnostics data.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not see a list, you will probably be asked to enable the Application
    Insights integration. To access standard view, click on the Switch to classic
    viewbutton.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can see the log of executions of my function, triggered by a timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/879c8038-c6ce-4489-b3fb-60603cb35f12.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, it contains information about each particular execution, the
    success and error count, and invocation details. When you select a specific item,
    you will also see all of the logs from a function.
  prefs: []
  type: TYPE_NORMAL
- en: The Monitor feature is quite useful for quickly analyzing issues. For more detailed
    errors and logs, you will have to enable Application Insights and use its features.
  prefs: []
  type: TYPE_NORMAL
- en: Host.json
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you create a function, you will see that a `host.json`file is  automatically
    created. While initially empty, it is a global configuration file that defines
    how triggers and function will behave. Here, you can find an example file with
    most features, such as bindings'' configuration and generic features, available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it contains things such as logger settings, function timeout
    value, and particular triggers configuration. In the *Further reading*section,
    you will find a link where each section of the `host.json` file is described in
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: Publish
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Azure Functions are published the very same way as App Service, since they
    share many common parts. If you right-click on your functions project in Visual
    Studio and select Publish, you will see a screen that''s similar to the one we
    saw when working with App Services:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6aea865a-9775-42d3-8585-103a8d20c47f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Traditionally, you have the possibility to select to either create a new function
    app or use an existing one. When you use the existing one and click on the Publish button,
    you will be able to find a function app in a specific Resource Group:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05452f09-82d6-4e51-afa0-ea910913fa3a.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, when you click OK, a new publish profile will be created and the whole
    application will be deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Workflow in Azure Functions – Durable Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most cases, the best idea for working with functionsis to keep them stateless.
    This makes things much easier as you do not have to worry about sharing resources
    and storing state. However, there are cases where you will like to access it and
    distribute between different instances of your functions. In such scenarios (such
    as orchestrating a workflow or scheduling a task to be done), a better option
    to start with would be to leverage the capabilities of Durable Functions, an extension
    to the main runtime, which changes the way you work a little bit.
  prefs: []
  type: TYPE_NORMAL
- en: It changes the way Azure Functions works as it lets you resume from where the
    execution was paused or stopped and introduces the possibility to take the output
    of one function and pass it as input. We will not cover this in detail, as this
    book is not only about Azure Functions, but you will get a glimpse of this feature,
    which will help you start it on your own.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, you don't need any extra extensions—the only thing you will
    need is an additional NuGet package named `Microsoft.Azure.WebJobs.Extensions.DurableTask`.
  prefs: []
  type: TYPE_NORMAL
- en: Orchestrations and activities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main elements of Durable Functions are orchestrations and activities. There
    are some significant differences between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Orchestrations`: These are designed to orchestrate different activities. They
    should be single-threaded and idempotent, and they can use only a very limited
    set of asynchronous methods. They are scaled based on the number of internal queues.
    What''s more, they control the flow of one or more activities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Activities`: These should contain most of the logic of your application. They
    work as typical functions (without the limits of orchestrations). They are scaled
    to multiple VMs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, you can find the code for both types of functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, they are both decorated with the `[FunctionName]`attribute as
    a typical function—the difference comes from the trigger that's used.
  prefs: []
  type: TYPE_NORMAL
- en: Orchestration client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started with an orchestration, you need a host for it. In Durable Functions,
    that host is the orchestration client, which enables you to perform the following
    actions on an orchestration:'
  prefs: []
  type: TYPE_NORMAL
- en: Start it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminate it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get its status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raise an event and pass it to an orchestration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The basic code for a client is pretty simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the preceding code, we started an orchestration by providing
    its name and passing some payload, which will be deserialized and decoded. Here,
    you can find an example of a client that has been hosted to terminate an instance
    by passing its identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Orchestration history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The way Durable Functions work ensures that, if any activity is replayed, its
    result will not be evaluated again (this is why orchestrations have to be idempotent).
    Here, you can find a diagram that shows how the framework works in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d497554-936a-4975-8053-f65635e6301b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To make a long story short, I divided the process into four parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dispatcher**: This is the internal part of the framework, which is responsible
    for calling orchestrations, performing replays, and saving the state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Orchestrator function**: This is an orchestration that calls activities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage**:This is a place where the orchestration history is stored'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Queue**: This is an internal queue (implemented using Azure Storage Queues),
    which is used to control the flow of execution of an orchestration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The way Durable Functions works is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Dispatchers run an orchestration, which calls `Activity1` and awaits its result
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The control is returned to a dispatcher, which commits the state in the orchestration
    history and pushes a message to a queue
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the meantime, orchestration is deallocated, saving memory and processor
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After fetching a message from a queue and finishing a task, the dispatcherrecreates
    an orchestration and replays all activities
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it finds that this particular activity has been finished, it gets only its
    result and proceeds to another activity
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding process lasts until all of the activities are processed. Information
    about execution history can be found in a table called `DurableFunctionsHubHistory`,
    which you can find inside the Azure Table Storage used by your function app.
  prefs: []
  type: TYPE_NORMAL
- en: Timers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, you might want to schedule work after a specific delay. While using
    traditional functions, you have to create a custom solution that will somehow
    trigger a workflow at a specific time. In Durable Functions, it is as easy as
    writing one line of code. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, I used the `context.CreateTimer()`method, which allows
    for creating a delay in function execution. If the previous orchestration is executed,
    it will return control to the dispatcher after awaiting a timer. Thanks to this,
    you will not be charged for this particular function execution as it will be deallocated
    and recreated later, after waiting for a specific interval.
  prefs: []
  type: TYPE_NORMAL
- en: External events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Durable Functions, it is possible to wait for an external event before proceeding
    with a workflow. This is especially helpful if you want to create an interactive
    flow, where you initiate a process in one place and have a requirement to wait
    for someone''s decision. To raise an event, you can use the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can find an example of waiting for an event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The way this works can be described as follows: the first functions allows
    you to raise a custom event by passing the appropriate parameters. The second
    function is paused while waiting for the `context.WaitForExternalEvent()` function.
    If you send an event with the `Approved` type, a function will be resumed and
    will continue. Additionally, you can pass a payload of an event, which will be
    passed as a result of `WaitForExternalEvent()`. This method works in the same
    way as timers and other Durable Functions functions, which are available in `DurableOrchestrationType`—while
    awaiting, control is returned to the dispatcher and the function itself is deallocated.'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating functions with other services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last part of this chapter, we will focus a little bit on understanding
    how Azure Functions integrate with other Azure services. We will take a look at
    the available triggers and bindings and try to figure out the best use cases for
    them and how they really work. This section is designed in a way that enables
    you to explore more by yourself, thanks to a common understanding of how Azure
    Functions work.
  prefs: []
  type: TYPE_NORMAL
- en: Function file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you take a look at your `bin `directory, where compiled functions are available,
    you will find a bit of a different structure than in traditional applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can find my folder from the exercise from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a09935d-9b0f-4893-914a-9014868582d0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, it contains the `Function1` directory, which contains one file
    named `function. json`. Here, you can find its content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It defines some metadata, which is further used by the function''s runtime
    and the `bindings` field, which is a definition of used triggers. If you compare
    it with a code attribute, you will see that it is quite similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When you compile your project, a compiler will produce a `function.json`file
    for each function defined in your code. Here, you can find the output for the
    event hub trigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it has the same structure and only the `bindings` field differs,
    so it reflects another trigger type.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the content and structure of `function.json` may differ depending
    on the SDK version used. Do not use it in your application directly to avoid problems
    that have a lack of backward compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Input/output bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some bindings are bi-directional,  while some can be used only one way. What''s
    more, not every binding can be used as a trigger. An example of both bi-directional
    and trigger binding is Azure Blob Storage*.* Here, you can find an example of
    how it works as a trigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare it with an example of a function triggered by a queue, but accepting
    blob as input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, I used the same syntax in both cases besides one thing—I declared
    `FileAccess.Read`to tell the runtime that this is not a trigger. Here is another
    example of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the syntax is still similar—the only thing that has changed
    is the `FileAccess` value. There are also other possibilities for using the return
    value of a function. Here, you can find out how to define the result by using
    an attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Custom bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While Azure Functions offer a variety of different bindings for many different
    scenarios, sometimes, you want a custom functionality that is not available. In
    such cases, it is possible to create a custom binding, which I mentioned earlier
    in this chapter. To generate it, you need the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: An attribute decorated with the `[Binding]`attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An implementation of the `IBindingProvider` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An implementation of the `IBinding` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An implementation of the `IExtensionConfigProvider` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By providing all of the preceding implementations, your binding will be automatically
    fetched by the runtime and enabled. If everything is set correctly, you will be
    notified of this during runtime start:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b70e3ea1-aced-41b4-8e88-8b89ccda9112.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you can see that the runtime extracted `IdentityExtensionConfig
    Provider` from my code, which will be used later when resolving my custom binding.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned a lot about Azure Functions and how to work
    with this serverless component. You read about the differences in pricing models,
    scalability concerns, and basic triggers and bindings. We worked on some simple
    scenarios regarding monitoring, deploying, and developing this Azure service.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapters in this book, you will learn even more about serverless services.
    We will then come back to work even more with functions, as this is one of the
    most popular Azure components that can be easily integrated with other tools and
    products.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between App Service and the consumption pricing model?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is GB/s?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you create stateful services with Azure Functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the name of a container that's used for functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you use Python in Azure Functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can a binding act both as a trigger and output? Can you provide an example?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is a function app mode sometimes set as read-only?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you use the Application Settingsfeature in the same way as in App Services?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Azure Functions overview: [https://docs.microsoft.com/en-us/azure/azure-functions/functions-overview](https://docs.microsoft.com/en-us/azure/azure-functions/functions-overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`host.json` description: [https://docs.microsoft.com/en-us/azure/azure-functions/functions-host-json](https://docs.microsoft.com/en-us/azure/azure-functions/functions-host-json)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The schema of the `functions.json` file: [http://json.schemastore.org/function](http://json.schemastore.org/function)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Triggers and bindings for Azure Functions: [https://docs.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings](https://docs.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Durable Functions: [https://docs.microsoft.com/en-us/azure/azure-functions/durable-functions-overview](https://docs.microsoft.com/en-us/azure/azure-functions/durable-functions-overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
