<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Introduction to OpenStack Networking</h1>
                </header>
            
            <article>
                
<p>In today's data centers, networks are composed of more devices than ever before. Servers, switches, routers, storage systems, and security appliances that once consumed rows and rows of data center space now exist as virtual machines and virtual network appliances. These devices place a large strain on traditional network management systems, as they are unable to provide a scalable and automated approach to managing next-generation networks. Users now expect more control and flexibility of the infrastructure with quicker provisioning, all of which OpenStack promises to deliver.</p>
<p>This chapter will introduce many features that OpenStack Networking provides, as well as various network architectures supported by OpenStack. Some topics that will be covered include the following:</p>
<ul>
<li>Features of OpenStack Networking</li>
<li>Physical infrastructure requirements</li>
<li>Service separation</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is OpenStack Networking?</h1>
                </header>
            
            <article>
                
<p>OpenStack Networking is a pluggable, scalable, and API-driven system to manage networks in an OpenStack-based cloud. Like other core OpenStack components, OpenStack Networking can be used by administrators and users to increase the value and maximize the utilization of existing data center resources.</p>
<p>Neutron, the project name for the OpenStack Networking service, complements other core OpenStack services such as Compute (Nova), Image (Glance), Identity (Keystone), Block (Cinder), Object (Swift), and Dashboard (Horizon) to provide a complete cloud solution.</p>
<p>OpenStack Networking exposes an application programmable interface (API) to users and passes requests to the configured network plugins for additional processing. Users are able to define network connectivity in the cloud, and cloud operators are allowed to leverage different networking technologies to enhance and power the cloud.</p>
<p>OpenStack Networking services can be split between multiple hosts to provide resiliency and redundancy, or they can be configured to operate on a single node. Like many other OpenStack services, Neutron requires access to a database for persistent storage of the network configuration. A simplified example of the architecture can be seen here:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b0e53890-f596-464d-89e3-686ed1c77c1f.png" style="width:29.83em;height:22.75em;"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Figure 1.1</div>
<p>In figure 1.1, the <span class="packt_screen">Neutron server</span> connects to a <span class="packt_screen">database</span> where the logical network configuration persists. The Neutron server can take API requests from users and services and communicate with agents via a <span class="packt_screen">message queue</span>. In a typical environment, network agents will be scattered across controller and compute nodes and perform duties on their respective node.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Features of OpenStack Networking</h1>
                </header>
            
            <article>
                
<p>OpenStack Networking includes many technologies you would find in the data center, including switching, routing, load balancing, firewalling, and virtual private networks.</p>
<p>These features can be configured to leverage open source or commercial software and provide a cloud operator with all the tools necessary to build a functional and self-contained cloud networking stack. OpenStack Networking also provides a framework for third-party vendors to build on and enhance the capabilities of the cloud.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Switching</h1>
                </header>
            
            <article>
                
<p>A <strong>virtual switch</strong> is defined as a software application or service that connects virtual machines to virtual networks at the data link layer of the OSI model, also known as layer 2. Neutron supports multiple virtual switching platforms, including Linux bridges provided by the <kbd>bridge</kbd> kernel module and Open vSwitch. Open vSwitch, also known as OVS, is an open source virtual switch that supports standard management interfaces and protocols, including NetFlow, SPAN, RSPAN, LACP, and 802.1q VLAN tagging. However, many of these features are not exposed to the user through the OpenStack API. In addition to VLAN tagging, users can build overlay networks in software using L2-in-L3 tunneling protocols, such as GRE or VXLAN. Virtual switches can be used to facilitate communication between instances and devices outside the control of OpenStack, which include hardware switches, network firewalls, storage devices, bare-metal servers, and more.</p>
<p>Additional information on the use of Linux bridges and Open vSwitch as switching platforms for OpenStack can be found in <em><a href="05786c3c-b24e-40dc-82a7-ed6072eca14f.xhtml"><span class="ChapterrefPACKT">Chapter 4</span></a>,</em> <em>Virtual Network Infrastructure Using Linux Bridges,</em> and <em><a href="0763a131-4ab9-4b3e-8854-8646feae7937.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>,</em> <em>Building a Virtual Switching Infrastructure Using Open vSwitch,</em> respectively.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Routing</h1>
                </header>
            
            <article>
                
<p>OpenStack Networking provides routing and NAT capabilities through the use of IP forwarding, iptables, and network namespaces. Each network namespace has its own routing table, interfaces, and iptables processes that provide filtering and network address translation. By leveraging network namespaces to separate networks, there is no need to worry about overlapping subnets between networks created by users. Configuring a router within Neutron enables instances to interact and communicate with outside networks or other networks in the cloud.</p>
<p>More information on routing within OpenStack can be found in <em><span class="ChapterrefPACKT"><a href="371886b8-4c2a-49e9-90b8-8fe79217adb4.xhtml">Chapter 10</a></span>, Creating Standalone Routers with Neutron</em>, <em><a href="bb8e64d5-76d5-4be8-b6b3-8ee9a520a439.xhtml"><span class="ChapterrefPACKT">Chapter 11</span></a><a href="bb8e64d5-76d5-4be8-b6b3-8ee9a520a439.xhtml"/>,</em> <em>Router Redundancy Using VRRP</em>, and <em><a href="b441728b-4377-43cf-b675-166266fef6c9.xhtml"><span class="ChapterrefPACKT">Chapter 12</span></a>, Distributed Virtual Routers</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Load balancing</h1>
                </header>
            
            <article>
                
<p>First introduced in the Grizzly release of OpenStack, <strong>Load Balancing as a Service (</strong><strong>LBaaS v2)</strong> provides users with the ability to distribute client requests across multiple instances or servers. Users can create monitors, set connection limits, and apply persistence profiles to traffic traversing a virtual load balancer. OpenStack Networking is equipped with a plugin for LBaaS v2 that utilizes HAProxy in the open source reference implementation, but plugins are available that manage virtual and physical load-balancing appliances from third-party network vendors.</p>
<p>More information on the use of load balancers within Neutron can be found in <em><a href="71145e1b-825c-43ac-9993-24eceb7a0a26.xhtml"><span class="ChapterrefPACKT">Chapter 13</span></a>,</em> <em>Load Balancing Traffic to Instances</em><span class="ChapterrefPACKT">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Firewalling</h1>
                </header>
            
            <article>
                
<p>OpenStack Networking provides two API-driven methods of securing network traffic to instances: security groups and <strong>Firewall as a Service (FWaaS)</strong>. Security groups find their roots in nova-network, the original networking stack for OpenStack built in to the Compute service, and are based on Amazon's EC2 security groups. When using security groups in OpenStack, instances are placed into groups that share common functionality and rule sets. In a reference implementation, security group rules are implemented at the instance port level using drivers that leverage iptables or OpenFlow. Security policies built using FWaaS are also implemented at the port level, but can be applied to ports of routers as well as instances. The original FWaaS v1 API implemented firewall rules inside Neutron router namespaces, but that behavior has been removed in the v2 API.</p>
<p>More information on securing instance traffic can be found in <em><span class="ChapterrefPACKT"><a href="240902fd-5108-446e-afa5-8122de12f0af.xhtml">Chapter 8</a></span>, Managing Security Groups</em>. The use of FWaaS is outside the scope of this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Virtual private networks</h1>
                </header>
            
            <article>
                
<p>A <strong>virtual private network (VPN)</strong> extends a private network across a public network such as the internet. A VPN enables a computer to send and receive data across public networks as if it were directly connected to the private network. Neutron provides a set of APIs to allow users to create IPSec-based VPN tunnels from Neutron routers to remote gateways when using the open source reference implementation. The use of VPN as a Service is outside the scope of this book.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Network functions virtualization</h1>
                </header>
            
            <article>
                
<p><strong>Network functions virtualization (</strong><strong>NFV)</strong> is a network architecture concept that proposes virtualizing network appliances used for various network functions. These functions include intrusion detection, caching, gateways, WAN accelerators, firewalls, and more. Using SR-IOV, instances are no longer required to use para-virtualized drivers or to be connected to virtual bridges within the host. Instead, the instance is attached to a Neutron port that is associated with a <strong>virtual function</strong> (<strong>VF</strong>) in the NIC, allowing the instance to access the NIC hardware directly. Configuring and implementing SR-IOV with Neutron is outside the scope of this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">OpenStack Networking resources</h1>
                </header>
            
            <article>
                
<p>OpenStack gives users the ability to create and configure networks and subnets and instruct other services, such as Compute, to attach virtual devices to ports on these networks. The Identity service gives cloud operators the ability to segregate users into projects. OpenStack Networking supports project-owned resources, including each project having multiple private networks and routers. Projects can be left to choose their own IP addressing scheme, even if those addresses overlap with other project networks, or administrators can place limits on the size of subnets and addresses available for allocation.</p>
<p>There are two types of networks that can be expressed in OpenStack:</p>
<ul>
<li><strong>Project/tenant network</strong>: A virtual network created by a project or administrator on behalf of a project. The physical details of the network are not exposed to the project.</li>
<li><strong>Provider network</strong>: A virtual network created to map to a physical network. Provider networks are typically created to enable access to physical network resources outside of the cloud, such as network gateways and other services, and usually map to VLANs. Projects can be given access to provider networks.</li>
</ul>
<div class="packt_infobox">The terms <em>project</em> and <em>tenant</em> are used interchangeably within the OpenStack community, with the former being the newer and preferred nomenclature.</div>
<p>A <strong>project network</strong> provides connectivity to resources in a project. Users can create, modify, and delete project networks. Each project network is isolated from other project networks by a boundary such as a VLAN or other segmentation ID. A <strong>provider network</strong>, on the other hand, provides connectivity to networks outside of the cloud and is typically created and managed by a cloud administrator.</p>
<p>The primary differences between project and provider networks can be seen during the network provisioning process. Provider networks are created by administrators on behalf of projects and can be dedicated to a particular project, shared by a subset of projects, or shared by all projects. Project networks are created by projects for use by their instances and cannot be shared with all projects, though sharing with certain projects may be accomplished using role-based access control (<strong>RBAC</strong>) policies. When a provider network is created, the administrator can provide specific details that aren't available to ordinary users, including the network type, the physical network interface, and the network segmentation identifier, such as a VLAN ID or VXLAN VNI. Project networks have these same attributes, but users cannot specify them. Instead, they are automatically determined by Neutron.</p>
<p>There are other foundational network resources that will be covered in further detail later in this book, but are summarized in the following table for your convenience:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td style="width: 15.3524%">
<p class="CDPAlignCenter CDPAlign"><strong>Resource</strong></p>
</td>
<td style="width: 83.8383%">
<p class="CDPAlignCenter CDPAlign"><strong>Description</strong></p>
</td>
</tr>
<tr>
<td style="width: 15.3524%">
<p>Subnet</p>
</td>
<td style="width: 83.8383%">
<p>A block of IP addresses used to allocate ports created on the network.</p>
</td>
</tr>
<tr>
<td style="width: 15.3524%">
<p>Port</p>
</td>
<td style="width: 83.8383%">
<p>A connection point for attaching a single device, such as the virtual network interface card (vNIC) of a virtual instance, to a virtual network. Port attributes include the MAC address and the fixed IP address on the subnet.</p>
</td>
</tr>
<tr>
<td style="width: 15.3524%">
<p>Router</p>
</td>
<td style="width: 83.8383%">
<p>A virtual device that provides routing between self-service networks and provider networks.</p>
</td>
</tr>
<tr>
<td style="width: 15.3524%">
<p>Security group</p>
</td>
<td style="width: 83.8383%">
<p>A set of virtual firewall rules that control ingress and egress traffic at the port level.</p>
</td>
</tr>
<tr>
<td style="width: 15.3524%">
<p>DHCP</p>
</td>
<td style="width: 83.8383%">
<p>An agent that manages IP addresses for instances on provider and self-service networks.</p>
</td>
</tr>
<tr>
<td style="width: 15.3524%">
<p>Metadata</p>
</td>
<td style="width: 83.8383%">
<p>A service that provides data to instances during boot.</p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Virtual network interfaces</h1>
                </header>
            
            <article>
                
<p>OpenStack deployments are most often configured to use the libvirt KVM/QEMU driver to provide platform virtualization. When an instance is booted for the first time, OpenStack creates a port for each network interface attached to the instance. A virtual network interface called a <strong>tap interface</strong> is created on the compute node hosting the instance. The tap interface corresponds directly to a network interface within the guest instance and has the properties of the port created in Neutron, including the MAC and IP address. Through the use of a bridge, the host can expose the guest instance to the physical network. Neutron allows users to specify alternatives to the standard tap interface, such as Macvtap and SR-IOV, by defining special attributes on ports and attaching them to instances.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Virtual network switches</h1>
                </header>
            
            <article>
                
<p>OpenStack Networking supports many types of virtual and physical switches, and includes built-in support for Linux bridges and Open vSwitch virtual switches. This book will cover both technologies and their respective drivers and agents.</p>
<div class="packt_infobox">The terms <em>bridge</em> and <em>switch</em> are often used interchangeably in the context of OpenStack Networking, and may be used in the same way throughout this book.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overlay networks</h1>
                </header>
            
            <article>
                
<p>Neutron supports overlay networking technologies that provide network isolation at scale with little to no modification of the underlying physical infrastructure. To accomplish this, Neutron leverages L2-in-L3 overlay networking technologies such as GRE, VXLAN, and GENEVE. When configured accordingly, Neutron builds point-to-point tunnels between all network and compute nodes in the cloud using a predefined interface. These point-to-point tunnels create what is called a <strong>mesh network</strong>, where every host is connected to every other host. A cloud consisting of one combined controller and network node, and three compute nodes, would have a fully meshed overlay network that resembles figure 1.2:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e7047532-54da-4781-b1b8-9f7dab00435c.png" style="width:26.83em;height:23.83em;"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Figure 1.2</div>
<p>Using the overlay network pictured in figure 1.2, traffic between instances or other virtual devices on any given host will travel between layer 3 endpoints on each of the underlying hosts without regard for the layer 2 network beneath them. Due to encapsulation, Neutron routers may be needed to facilitate communication between different project networks as well as networks outside of the cloud.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Virtual Extensible Local Area Network (VXLAN)</h1>
                </header>
            
            <article>
                
<p>This book focuses primarily on VXLAN, an overlay technology that helps address scalability issues with VLANs. VXLAN encapsulates layer 2 Ethernet frames inside layer 4 UDP packets that can be forwarded or routed between hosts. This means that a virtual network can be transparently extended across a large network without any changes to the end hosts. In the case of OpenStack Networking, however, a VXLAN mesh network is commonly constructed only between nodes that exist in the same cloud.</p>
<p>Rather than use VLAN IDs to differentiate between networks, VXLAN uses a VXLAN Network Identifier (VNI) to serve as the unique identifier on a link that potentially carries traffic for tens of thousands of networks, or more. An 802.1q VLAN header supports up to 4,096 unique IDs, whereas a VXLAN header supports approximately 16 million unique IDs. Within an OpenStack cloud, virtual machine instances are unaware that VXLAN is used to forward traffic between hosts. The VXLAN Tunnel Endpoint (VTEP) on the physical node handles the encapsulation and decapsulation of traffic without the instance ever knowing.</p>
<p>Because VXLAN network traffic is encapsulated, many network devices cannot participate in these networks without additional configuration, if at all. As a result, VXLAN networks are effectively isolated from other networks in the cloud and require the use of a Neutron router to provide access to connected instances. More information on creating Neutron routers begins in <em><a href="371886b8-4c2a-49e9-90b8-8fe79217adb4.xhtml"><span class="ChapterrefPACKT">Chapter 10</span></a>, Creating Standalone Routers with Neutron</em>.</p>
<p>While not as performant as VLAN or flat networks on some hardware, the use of VXLAN is becoming more popular in cloud network architectures where scalability and self-service are major drivers. Newer networking hardware that offers VXLAN offloading capabilities should be leveraged if you are considering implementing VXLAN-based overlay networks in your cloud.</p>
<p>More information on how VXLAN encapsulation works is described in RFC 7348, available at the following URL: <a href="https://tools.ietf.org/html/rfc7348"><span class="URLPACKT">https://tools.ietf.org/html/rfc7348</span></a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generic Router Encapsulation (GRE)</h1>
                </header>
            
            <article>
                
<p>A <strong>GRE network</strong> is similar to a VXLAN network in that traffic from one instance to another is encapsulated and sent over a layer 3 network. A unique segmentation ID is used to differentiate traffic from other GRE networks. Rather than use UDP as the transport mechanism, GRE uses IP protocol 47. For various reasons, the use of GRE for encapsulating tenant network traffic has fallen out of favor now that VXLAN is supported by both Open vSwitch and Linux Bridge network agents.</p>
<p>More information on how GRE encapsulation works is described in RFC 2784 available at the following URL: <span class="URLPACKT"><a href="https://tools.ietf.org/html/rfc278">https://tools.ietf.org/html/rfc278</a><a href="https://tools.ietf.org/html/rfc278">4</a></span></p>
<div class="packt_infobox">As of the Pike release of OpenStack, the Open vSwitch mechanism driver is the only commonly used driver that supports GRE.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generic Network Virtualization Encapsulation (GENEVE)</h1>
                </header>
            
            <article>
                
<p>GENEVE is an emerging overlay technology that resembles VXLAN and GRE, in that packets between hosts are designed to be transmitted using standard networking equipment without having to modify the client or host applications. Like VXLAN, GENEVE encapsulates packets with a unique header and uses UDP as its transport mechanism. GENEVE leverages the benefits of multiple overlay technologies such as VXLAN, NVGRE, and STT, and may supplant those technologies over time. The Open Virtual Networking (OVN) mechanism driver relies on GENEVE as its overlay technology, which may speed up the adoption of GENEVE in later releases of OpenStack.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preparing the physical infrastructure</h1>
                </header>
            
            <article>
                
<p>Most OpenStack clouds are made up of physical infrastructure nodes that fit into one of the following four categories:</p>
<ul>
<li><strong>Controller node</strong>: Controller nodes traditionally run the API services for all of the OpenStack components, including Glance, Nova, Keystone, Neutron, and more. In addition, controller nodes run the database and messaging servers, and are often the point of management of the cloud via the Horizon dashboard. Most OpenStack API services can be installed on multiple controller nodes and can be load balanced to scale the OpenStack control plane.</li>
<li><strong>Network node</strong>: Network nodes traditionally run DHCP and metadata services and can also host virtual routers when the Neutron L3 agent is installed. In smaller environments, it is not uncommon to see controller and network node services collapsed onto the same server or set of servers. As the cloud grows in size, most network services can be broken out between other servers or installed on their own server for optimal performance.</li>
<li><strong>Compute node</strong>: Compute nodes traditionally run a hypervisor such as KVM, Hyper-V, or Xen, or container software such as LXC or Docker. In some cases, a compute node may also host virtual routers, especially when Distributed Virtual Routing (DVR) is configured. In proof-of-concept or test environments, it is not uncommon to see controller, network, and compute node services collapsed onto the same machine. This is especially common when using DevStack, a software package designed for developing and testing OpenStack code. All-in-one installations are not recommended for production use.</li>
<li><strong>Storage node</strong>: Storage nodes are traditionally limited to running software related to storage such as Cinder, Ceph, or Swift. Storage nodes do not usually host any type of Neutron networking service or agent and will not be discussed in this book.</li>
</ul>
<p class="mce-root"/>
<p>When Neutron services are broken out between many hosts, the layout of services will often resemble the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/468a9df6-164e-4bd6-bd7e-7b5bb65b9f78.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Figure 1.3</div>
<p>In figure 1.3, the neutron API service <kbd>neutron-server</kbd> is installed on the <span class="packt_screen">Controller node</span>, while Neutron agents responsible for implementing certain virtual networking resources are installed on a dedicated network node. Each compute node hosts a network plugin agent responsible for implementing the network plumbing on that host. Neutron supports a highly available API service with a shared database backend, and it is recommended that the cloud operator load balances traffic to the Neutron API service when possible. Multiple DHCP, metadata, L3, and LBaaS agents should be implemented on separate network nodes whenever possible. Virtual networks, routers, and load balancers can be scheduled to one or more agents to provide a basic level of redundancy when an agent fails. Neutron even includes a built-in scheduler that can detect failure and reschedule certain resources when a failure is detected.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring the physical infrastructure</h1>
                </header>
            
            <article>
                
<p>Before the installation of OpenStack can begin, the physical network infrastructure must be configured to support the networks needed for an operational cloud. In a production environment, this will likely include a dedicated management VLAN used for server management and API traffic, a VLAN dedicated to overlay network traffic, and one or more VLANs that will be used for provider and VLAN-based project networks. Each of these networks can be configured on separate interfaces, or they can be collapsed onto a single interface if desired.</p>
<p>The reference architecture for OpenStack Networking defines at least four distinct types of traffic that will be seen on the network:</p>
<ul>
<li>Management</li>
<li>API</li>
<li>External</li>
<li>Guest</li>
</ul>
<p>These traffic types are often categorized as control plane or data plane, depending on the purpose, and are terms used in networking to describe the purpose of the traffic. In this case, <strong>control plane</strong> traffic is used to describe traffic related to management, API, and other non-VM related traffic. <strong>Data plane</strong> traffic, on the other hand, represents traffic generated by, or directed to, virtual machine instances.</p>
<p>Although I have taken the liberty of splitting out the network traffic onto dedicated interfaces in this book, it is not necessary to do so to create an operational OpenStack cloud. In fact, many administrators and distributions choose to collapse multiple traffic types onto single or bonded interfaces using VLAN tagging. Depending on the chosen deployment model, the administrator may spread networking services across multiple nodes or collapse them onto a single node. The security requirements of the enterprise deploying the cloud will often dictate how the cloud is built. The various network and service configurations will be discussed in the upcoming sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Management network</h1>
                </header>
            
            <article>
                
<p>The <strong>management network</strong>, also referred to as the <strong>internal network</strong> in some distributions, is used for internal communication between hosts for services such as the messaging service and database service, and can be considered as part of the control plane.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>All hosts will communicate with each other over this network. In many cases, this same interface may be used to facilitate image transfers between hosts or some other bandwidth-intensive traffic. The management network can be configured as an isolated network on a dedicated interface or combined with another network as described in the following section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">API network</h1>
                </header>
            
            <article>
                
<p>The <strong>API network</strong> is used to expose OpenStack APIs to users of the cloud and services within the cloud and can be considered as part of the control plane. Endpoint addresses for API services such as Keystone, Neutron, Glance, and Horizon are procured from the API network.</p>
<p>It is common practice to utilize a single interface and IP address for API endpoints and management access to the host itself over SSH. A diagram of this configuration is provided later in this chapter.</p>
<div class="packt_tip">It is recommended, though not required, that you physically separate management and API traffic from other traffic types, such as storage traffic, to avoid issues with network congestion that may affect operational stability.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">External network</h1>
                </header>
            
            <article>
                
<p>An <strong>external network</strong> is a provider network that provides Neutron routers with external network access. Once a router has been configured and attached to the external network, the network becomes the source of floating IP addresses for instances and other network resources attached to the router. IP addresses in an external network are expected to be routable and reachable by clients on a corporate network or the internet. Multiple external provider networks can be segmented using VLANs and trunked to the same physical interface. Neutron is responsible for tagging the VLAN based on the network configuration provided by the administrator. Since external networks are utilized by VMs, they can be considered as part of the data plane.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Guest network</h1>
                </header>
            
            <article>
                
<p>The <strong>guest network</strong> is a network dedicated to instance traffic. Options for guest networks include local networks restricted to a particular node, flat, or VLAN-tagged networks, or virtual overlay networks made possible with GRE, VXLAN, or GENEVE encapsulation. For more information on guest networks, refer to <em><a href="5a3df5cf-aebb-4c57-9f48-fa5419a5b2ae.xhtml"><span class="ChapterrefPACKT">Chapter 6</span></a>, Building Networks with Neutron</em>. Since guest networks provide connectivity to VMs, they can be considered part of the data plane.</p>
<p>The physical interfaces used for external and guest networks can be dedicated interfaces or ones that are shared with other types of traffic. Each approach has its benefits and drawbacks, and they are described in more detail later in this chapter. In the next few chapters, I will define networks and VLANs that will be used throughout the book to demonstrate the various components of OpenStack Networking. Generic information on the configuration of switch ports, routers, or firewalls will also be provided.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Physical server connections</h1>
                </header>
            
            <article>
                
<p>The number of interfaces needed per host is dependent on the purpose of the cloud, the security and performance requirements of the organization, and the cost and availability of hardware. A single interface per server that results in a combined control and data plane is all that is needed for a fully operational OpenStack cloud. Many organizations choose to deploy their cloud this way, especially when port density is at a premium, the environment is simply used for testing, or network failure at the node level is a non-impacting event. When possible, however, it is recommended that you split control and data traffic across multiple interfaces to reduce the chances of network failure.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Single interface</h1>
                </header>
            
            <article>
                
<p>For hosts using a single interface, all traffic to and from instances as well as internal OpenStack, SSH management, and API traffic traverse the same physical interface. This configuration can result in severe performance penalties, as a service or guest can potentially consume all available bandwidth. A single interface is recommended only for non-production clouds.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The following table demonstrates the networks and services traversing a single interface over multiple VLANs:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 167px">
<p><strong>Service/function</strong></p>
</td>
<td class="CDPAlignCenter CDPAlign" style="width: 523.476px">
<p><strong>Purpose</strong></p>
</td>
<td class="CDPAlignCenter CDPAlign" style="width: 85.5243px">
<p><strong>Interface</strong></p>
</td>
<td class="CDPAlignCenter CDPAlign" style="width: 68px">
<p><strong>VLAN</strong></p>
</td>
</tr>
<tr>
<td style="width: 167px">
<p>SSH</p>
</td>
<td style="width: 523.476px">
<p>Host management</p>
</td>
<td style="width: 85.5243px">
<p>eth0</p>
</td>
<td style="width: 68px">
<p>10</p>
</td>
</tr>
<tr>
<td style="width: 167px">
<p>APIs</p>
</td>
<td style="width: 523.476px">
<p>Access to OpenStack APIs</p>
</td>
<td style="width: 85.5243px">
<p>eth0</p>
</td>
<td style="width: 68px">
<p>15</p>
</td>
</tr>
<tr>
<td style="width: 167px">
<p>Overlay network</p>
</td>
<td style="width: 523.476px">
<p>Used to tunnel overlay (VXLAN, GRE, GENEVE) traffic between hosts</p>
</td>
<td style="width: 85.5243px">
<p>eth0</p>
</td>
<td style="width: 68px">
<p>20</p>
</td>
</tr>
<tr>
<td style="width: 167px">
<p>Guest/external network(s)</p>
</td>
<td style="width: 523.476px">
<p>Used to provide access to external cloud resources and for VLAN-based project networks</p>
</td>
<td style="width: 85.5243px">
<p>eth0</p>
</td>
<td style="width: 68px">
<p>Multiple</p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Multiple interfaces</h1>
                </header>
            
            <article>
                
<p>To reduce the likelihood of guest traffic impacting management traffic, segregation of traffic between multiple physical interfaces is recommended. At a minimum, two interfaces should be used: one that serves as a dedicated interface for management and API traffic (control plane), and another that serves as a dedicated interface for external and guest traffic (data plane). Additional interfaces can be used to further segregate traffic, such as storage.</p>
<p>The following table demonstrates the networks and services traversing two interfaces with multiple VLANs:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td style="width: 172px">
<p class="CDPAlignCenter CDPAlign"><strong>Service/function</strong></p>
</td>
<td class="CDPAlignCenter CDPAlign" style="width: 526.274px">
<p><strong>Purpose</strong></p>
</td>
<td class="CDPAlignCenter CDPAlign" style="width: 75.7256px">
<p><strong>Interface</strong></p>
</td>
<td style="width: 68px">
<p class="CDPAlignCenter CDPAlign"><strong>VLAN</strong></p>
</td>
</tr>
<tr>
<td style="width: 172px">
<p>SSH</p>
</td>
<td style="width: 526.274px">
<p>Host management</p>
</td>
<td style="width: 75.7256px">
<p>eth0</p>
</td>
<td style="width: 68px">
<p>10</p>
</td>
</tr>
<tr>
<td style="width: 172px">
<p>APIs</p>
</td>
<td style="width: 526.274px">
<p>Access to OpenStack APIs</p>
</td>
<td style="width: 75.7256px">
<p>eth0</p>
</td>
<td style="width: 68px">
<p>15</p>
</td>
</tr>
<tr>
<td style="width: 172px">
<p>Overlay network</p>
</td>
<td style="width: 526.274px">
<p>Used to tunnel overlay (VXLAN, GRE, GENEVE) traffic between hosts</p>
</td>
<td style="width: 75.7256px">
<p>eth1</p>
</td>
<td style="width: 68px">
<p>20</p>
</td>
</tr>
<tr>
<td style="width: 172px">
<p>Guest/external network(s)</p>
</td>
<td style="width: 526.274px">
<p>Used to provide access to external cloud resources and for VLAN-based project networks</p>
</td>
<td style="width: 75.7256px">
<p>eth1</p>
</td>
<td style="width: 68px">
<p>Multiple</p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bonding</h1>
                </header>
            
            <article>
                
<p>The use of multiple interfaces can be expanded to utilize bonds instead of individual network interfaces. The following common bond modes are supported:</p>
<ul>
<li><strong>Mode 1 (active-backup)</strong>: Mode 1 bonding sets all interfaces in the bond to a backup state while one interface remains active. When the active interface fails, a backup interface replaces it. The same MAC address is used upon failover to avoid issues with the physical network switch. Mode 1 bonding is supported by most switching vendors, as it does not require any special configuration on the switch to implement.</li>
<li><strong>Mode 4 (active-active)</strong>: Mode 4 bonding involves the use of <strong>aggregation groups</strong>, a group in which all interfaces share an identical configuration and are grouped together to form a single logical interface. The interfaces are aggregated using the IEEE 802.3ad Link Aggregation Control Protocol (LACP). Traffic is load balanced across the links using methods negotiated by the physical node and the connected switch or switches. The physical switching infrastructure <em>must</em> be capable of supporting this type of bond. While some switching platforms require that multiple links of an LACP bond be connected to the same switch, others support technology known as <strong>Multi-Chassis Link Aggregation (MLAG)</strong> that allows multiple physical switches to be configured as a single logical switch. This allows links of a bond to be connected to multiple switches that provide hardware redundancy while allowing users the full bandwidth of the bond under normal operating conditions, all with no additional changes to the server configuration.</li>
</ul>
<p>Bonding can be configured within the Linux operating system using tools such as iproute2, ifupdown, and Open vSwitch, among others.The configuration of bonded interfaces is outside the scope of OpenStack and this book.</p>
<div class="packt_infobox">Bonding configurations vary greatly between Linux distributions. Refer to the respective documentation of your Linux distribution for assistance in configuring bonding.</div>
<p>The following table demonstrates the use of two bonds instead of two individual interfaces:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 168px">
<p><strong>Service/function</strong></p>
</td>
<td class="CDPAlignCenter CDPAlign" style="width: 490.427px">
<p><strong>Purpose</strong></p>
</td>
<td class="CDPAlignCenter CDPAlign" style="width: 117.573px">
<p><strong>Interface</strong></p>
</td>
<td class="CDPAlignCenter CDPAlign" style="width: 68px">
<p><strong>VLAN</strong></p>
</td>
</tr>
<tr>
<td style="width: 168px">
<p>SSH</p>
</td>
<td style="width: 490.427px">
<p>Host management</p>
</td>
<td style="width: 117.573px">
<p>bond0</p>
</td>
<td style="width: 68px">
<p>10</p>
</td>
</tr>
<tr>
<td style="width: 168px">
<p>APIs</p>
</td>
<td style="width: 490.427px">
<p>Access to OpenStack APIs</p>
</td>
<td style="width: 117.573px">
<p>bond0</p>
</td>
<td style="width: 68px">
<p>15</p>
</td>
</tr>
<tr>
<td style="width: 168px">
<p>Overlay network</p>
</td>
<td style="width: 490.427px">
<p>Used to tunnel overlay (VXLAN, GRE, GENEVE) traffic between hosts</p>
</td>
<td style="width: 117.573px">
<p>bond1</p>
</td>
<td style="width: 68px">
<p>20</p>
</td>
</tr>
<tr>
<td style="width: 168px">
<p>Guest/external network(s)</p>
</td>
<td style="width: 490.427px">
<p>Used to provide access to external cloud resources and for VLAN-based project networks</p>
</td>
<td style="width: 117.573px">
<p>bond1</p>
</td>
<td style="width: 68px">
<p>Multiple</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>In this book, an environment will be built using three non-bonded interfaces: one for management and API traffic, one for VLAN-based provider or project networks, and another for overlay network traffic. The following interfaces and VLAN IDs will be used:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr style="height: 53px">
<td class="CDPAlignCenter CDPAlign" style="width: 162px;height: 53px">
<p><strong>Service/function</strong></p>
</td>
<td class="CDPAlignCenter CDPAlign" style="width: 409.368px;height: 53px">
<p><strong>Purpose</strong></p>
</td>
<td class="CDPAlignCenter CDPAlign" style="width: 212.632px;height: 53px">
<p><strong>Interface</strong></p>
</td>
<td class="CDPAlignCenter CDPAlign" style="width: 58px;height: 53px">
<p><strong>VLAN</strong></p>
</td>
</tr>
<tr style="height: 72.0801px">
<td style="width: 162px;height: 72.0801px">
<p>SSH and APIs</p>
</td>
<td style="width: 409.368px;height: 72.0801px">
<p>Host management and access to OpenStack APIs</p>
</td>
<td style="width: 212.632px;height: 72.0801px">
<p>eth0 / ens160</p>
</td>
<td style="width: 58px;height: 72.0801px">
<p>10</p>
</td>
</tr>
<tr style="height: 92px">
<td style="width: 162px;height: 92px">
<p>Overlay network</p>
</td>
<td style="width: 409.368px;height: 92px">
<p>Used to tunnel overlay (VXLAN, GRE, GENEVE) traffic between hosts</p>
</td>
<td style="width: 212.632px;height: 92px">
<p>eth1 / ens192</p>
</td>
<td style="width: 58px;height: 92px">
<p>20</p>
</td>
</tr>
<tr style="height: 92px">
<td style="width: 162px;height: 92px">
<p>Guest/external network(s)</p>
</td>
<td style="width: 409.368px;height: 92px">
<p>Used to provide access to external cloud resources and for VLAN-based project networks</p>
</td>
<td style="width: 212.632px;height: 92px">
<p>eth2 / ens224</p>
</td>
<td style="width: 58px;height: 92px">
<p>30,40-43</p>
</td>
</tr>
</tbody>
</table>
<div class="packt_infobox">When an environment is virtualized in VMware, interface names may differ from the standard eth0, eth1, ethX naming convention. The interface names provided in the table reflect the interface naming convention seen on controller and compute nodes that exist as virtual machines, rather than bare-metal machines.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Separating services across nodes</h1>
                </header>
            
            <article>
                
<p>Like other OpenStack services, cloud operators can split OpenStack Networking services across multiple nodes. Small deployments may use a single node to host all services, including networking, compute, database, and messaging. Others might find benefit in using a dedicated controller node and a dedicated network node to handle guest traffic routed through software routers and to offload Neutron DHCP and metadata services. The following sections describe a few common service deployment models.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using a single controller node</h1>
                </header>
            
            <article>
                
<p>In an environment consisting of a single controller and one or more compute nodes, the controller will likely handle all networking services and other OpenStack services while the compute nodes strictly provide compute resources.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The following diagram demonstrates a <span class="packt_screen">controller node</span> hosting all OpenStack management and networking services where the Neutron layer 3 agent is not utilized. Two physical interfaces are used to separate management (control plane) and instance (data plane) network traffic:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/f21a4d7e-97ff-43ce-8703-dce66fd92435.png" style="width:34.08em;height:36.17em;"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Figure 1.3</div>
<p>The preceding diagram reflects the use of a single combined controller/network node and one or more compute nodes, with Neutron providing only layer 2 connectivity between instances and external gateway devices. An external router is needed to handle routing between network segments.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The following diagram demonstrates a controller node hosting all OpenStack management and networking services, including the Neutron L3 agent. Three physical interfaces are used to provide separate control and data planes:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4cc9d21e-6620-49fd-9b02-c8bec95dd0fe.png" style="width:34.50em;height:40.92em;"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Figure 1.4</div>
<p>The preceding diagram reflects the use of a single combined controller/network node and one or more compute nodes in a network configuration that utilizes the Neutron L3 agent. Software routers created with Neutron reside on the controller node, and handle routing between connected project networks and external provider networks.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using a dedicated network node</h1>
                </header>
            
            <article>
                
<p>A network node is dedicated to handling most or all the OpenStack networking services, including the L3 agent, DHCP agent, metadata agent, and more. The use of a dedicated <span class="packt_screen">network node</span> provides additional security and resilience, as the <span class="packt_screen">controller node</span> will be at less risk of network and resource saturation. Some Neutron services, such as the L3 and DHCP agents and the Neutron API service, can be scaled out across multiple nodes for redundancy and increased performance, especially when distributed virtual routers are used.</p>
<p>The following diagram demonstrates a <span class="packt_screen">network node</span> hosting all OpenStack networking services, including the Neutron L3, DHCP, metadata, and LBaaS agents. The Neutron API service, however, remains installed on the controller node. Three physical interfaces are used where necessary to provide separate control and data planes:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9788b045-b94f-4a20-90ee-85a5afa1db3d.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Figure 1.5</div>
<p>The environment built out in this book will be composed of five hosts, including the following:</p>
<ul>
<li>A single controller node running all OpenStack network services and the Linux bridge network agent</li>
<li>A single compute node running the Nova compute service and the Linux bridge network agent</li>
<li>Two compute nodes running the Nova compute service and the Open vSwitch network agent</li>
<li>A single network node running the Open vSwitch network agent and the L3 agent</li>
</ul>
<p>Not all hosts are required should you choose not to complete the exercises described in the upcoming chapters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>OpenStack Networking offers the ability to create and manage different technologies found in a data center in a virtualized and programmable manner. If the built-in features and reference implementations are not enough, the pluggable architecture of OpenStack Networking allows for additional functionality to be provided by third-party commercial and open source vendors. The security requirements of the organization building the cloud as well as the use cases of the cloud, will ultimately dictate the physical layout and separation of services across the infrastructure nodes.</p>
<p>To successfully deploy Neutron and harness all it has to offer, it is important to have a strong understanding of core networking concepts. In this book, we will cover some fundamental network concepts around Neutron and build a foundation for deploying instances.</p>
<p>In the next chapter, we will begin a package-based installation of OpenStack on the Ubuntu 16.04 LTS operating system. Topics covered include the installation, configuration, and verification of many core OpenStack projects, including Identity, Image, Dashboard, and Compute. The installation and configuration of base OpenStack Networking services, including the Neutron API, can be found in <em><a href="bf508e37-ce8a-4116-89db-e8f8a6abf0f4.xhtml"><span class="ChapterrefPACKT">Chapter 3</span></a>,</em> <em>Installing Neutron</em>.</p>


            </article>

            
        </section>
    </body></html>