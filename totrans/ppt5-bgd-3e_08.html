<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Classes, roles, and profiles"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Classes, roles, and profiles</h1></div></div></div><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><span class="emphasis"><em>Our life is frittered away by detail. Simplify, simplify!</em></span></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<span class="attribution"><span class="emphasis"><em>Henry David Thoreau</em></span></span></td></tr></table></div><p>In this chapter you will explore the details of Puppet classes, the distinction between defining a class and including the class, how to supply parameters to classes, and how to declare classes with parameters and specify appropriate data types for them. You'll learn how to create defined resource types, and how they differ from classes. You'll also see how to organize your Puppet code using the concepts of nodes, roles, and profiles.</p><div class="mediaobject"><img src="graphics/8880_08_01.jpg" alt="Classes, roles, and profiles"/></div><div class="section" title="Classes"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec42"/>Classes</h1></div></div></div><p>We've come across the <a id="id367" class="indexterm"/>
<span class="strong"><strong>class</strong></span> concept a few times so far in this book, without really explaining it. Let's explore a little further now and see how to use this key Puppet language building block.</p><div class="section" title="The class keyword"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec127"/>The class keyword</h2></div></div></div><p>You may have noticed <a id="id368" class="indexterm"/>that in the code for our example NTP module in <a class="link" href="ch07.html" title="Chapter 7. Mastering modules">Chapter 7,</a> <span class="emphasis"><em>Mastering modules</em></span> (in the <span class="emphasis"><em>Writing the module code</em></span> section), we used the <code class="literal">class</code> keyword:</p><div class="informalexample"><pre class="programlisting">class pbg_ntp {
  ...
}</pre></div><p>If you're wondering what the <code class="literal">class</code> keyword does, the surprising answer is nothing at all. Nothing, that is, except inform Puppet that the resources it contains should be grouped together and given a name (<code class="literal">pbg_ntp</code>), and that these resources should not be applied yet.</p><p>You can then use this name elsewhere to tell Puppet to apply all the resources in the class together. We declared our example module by using the <code class="literal">include</code> keyword:</p><div class="informalexample"><pre class="programlisting">include ntp</pre></div><p>The following example shows a class <span class="strong"><strong>definition</strong></span>, which makes the class available to Puppet, but does not (yet) apply any of its contained resources:</p><div class="informalexample"><pre class="programlisting">class CLASS_NAME {
  ...
}</pre></div><p>The following example shows a <span class="strong"><strong>declaration</strong></span> of the <code class="literal">CLASS_NAME</code> class. A declaration tells Puppet to apply all the resources in that class (and the class must have already been defined):</p><div class="informalexample"><pre class="programlisting">include CLASS_NAME</pre></div><p>You may recall from <a class="link" href="ch07.html" title="Chapter 7. Mastering modules">Chapter 7,</a> <span class="emphasis"><em>Mastering modules</em></span>, that we used Hiera's automatic parameter lookup mechanism to supply parameters to classes. We'll find out more about this shortly, but first, how do we write a class that accepts parameters?</p></div><div class="section" title="Declaring parameters to classes"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec128"/>Declaring parameters to classes</h2></div></div></div><p>If all a class does is <a id="id369" class="indexterm"/>group together related resources, that's still <a id="id370" class="indexterm"/>useful, but a class becomes much more powerful if we can use <span class="strong"><strong>parameters</strong></span>. Parameters are just like resource attributes: they let you pass data to the class to change how it's applied.</p><p>The following example shows how to define a class that takes parameters. It's a simplified version of the <code class="literal">pbg_ntp</code> class we developed for our NTP module (<code class="literal">class_params.pp</code>):</p><div class="informalexample"><pre class="programlisting"># Manage NTP
class pbg_ntp_params (
  String $version = 'installed',
) {
  ensure_packages(['ntp'],
    {
      'ensure' =&gt; $version,
    }
  )
}</pre></div><p>The important part to look at is in parentheses after the start of the class definition. This specifies the parameters that the class accepts:</p><div class="informalexample"><pre class="programlisting">String $version = 'installed',</pre></div><p>
<code class="literal">String</code> tells Puppet that we expect this value to be a String, and it will raise an error if we try to pass it anything else, such as an Integer. <code class="literal">$version</code> is the name of the parameter. Finally, the <code class="literal">'installed'</code> part specifies a <span class="strong"><strong>default value</strong></span> for the parameter. If someone declares this class without supplying the <code class="literal">pbg_ntp_params::version</code> parameter, Puppet will fill it in automatically using this default value.</p><p>If you don't supply a default value for a parameter, that makes the parameter <span class="strong"><strong>mandatory</strong></span>, so Puppet will not let you declare the class without supplying a value for that parameter.</p><p>When you declare this class, you do it in exactly the same way that we did previously with the Puppet Forge modules, using the <code class="literal">include</code> keyword and the name of the class:</p><div class="informalexample"><pre class="programlisting">include pbg_ntp_params</pre></div><p>There are no mandatory parameters for this class, so you need not supply any, but if you do, add a value like the following to your Hiera data, and Puppet will look it up automatically when the class is included:</p><div class="informalexample"><pre class="programlisting">pbg_ntp_params::version: 'latest'</pre></div><p>Classes can take more than one parameter, of course, and the following (contrived) example shows how to <a id="id371" class="indexterm"/>declare multiple parameters of various types (<code class="literal">class_params2.pp</code>):</p><div class="informalexample"><pre class="programlisting"># Manage NTP
class pbg_ntp_params2 (
  Boolean $start_at_boot,
  String[1] $version                        = 'installed',
  Enum['running', 'stopped'] $service_state = 'running',
) {
  ensure_packages(['ntp'],
    {
      'ensure' =&gt; $version,
    }
  )

  service { 'ntp':
    ensure =&gt; $service_state,
    enable =&gt; $start_at_boot,
  }
}</pre></div><p>To pass parameters to this <a id="id372" class="indexterm"/>class, add Hiera data like the following:</p><div class="informalexample"><pre class="programlisting">pbg_ntp_params2::start_at_boot: true
pbg_ntp_params2::version: 'latest'
pbg_ntp_params2::service_state: 'running'</pre></div><p>Let's look closely at the parameter list:</p><div class="informalexample"><pre class="programlisting">  Boolean $start_at_boot,
  String[1] $version                        = 'installed',
  Enum['running', 'stopped'] $service_state = 'running',</pre></div><p>The first parameter is of <code class="literal">Boolean</code> type and named <code class="literal">$start_at_boot</code>. There's no default value, so this parameter is mandatory. Mandatory parameters must be declared first, before any optional parameters (that is, parameters with a default value).</p><p>The <code class="literal">$version</code> parameter we saw in the previous example, but now it's a <code class="literal">String[1]</code> instead of a <code class="literal">String</code>. What's the difference? A <code class="literal">String[1]</code> is a String with at least one character. This means that you can't pass the empty string to such a parameter, for example. It's a good idea to specify a minimum length for String parameters, if appropriate, to catch the case where an empty string is accidentally passed to the class.</p><p>The final parameter, <code class="literal">$service_state</code> is of a new type, <code class="literal">Enum</code>, which we haven't come across before. With an <span class="strong"><strong>Enum parameter</strong></span>, we can specify exactly the list of allowed values it can take.</p><p>If your class expects a String parameter which can only take one of a handful of values, you can list them all in an <code class="literal">Enum</code> parameter declaration, and Puppet will not allow any value to be passed to that parameter unless it is in that list. In our example, if you try to declare the <code class="literal">pbg_ntp_params2</code> <a id="id373" class="indexterm"/>class and pass the value <code class="literal">bogus</code> to the <code class="literal">$service_state</code> <a id="id374" class="indexterm"/>parameter, you'll get this error:</p><div class="informalexample"><pre class="programlisting">Error: Evaluation Error: Error while evaluating a Resource Statement, Class[Pbg_ntp_params2]: parameter 'service_state' expects a match for Enum['running', 'stopped'], got String at /examples/class_params2.pp:22:1 on node ubuntu-xenial</pre></div><p>Just like any other parameter, an <code class="literal">Enum</code> parameter can take a default value, as it does in our example.</p></div><div class="section" title="Automatic parameter lookup from Hiera data"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec129"/>Automatic parameter lookup from Hiera data</h2></div></div></div><p>We've seen in this <a id="id375" class="indexterm"/>chapter, and the previous <a id="id376" class="indexterm"/>one that we can use Hiera data to pass parameters to classes. If we include a class named <code class="literal">ntp</code>, which accepts a parameter <code class="literal">version</code>, and a key exists in Hiera named <code class="literal">ntp::version</code>, its value will be passed to the <code class="literal">ntp</code> class as the value of <code class="literal">version</code>. For example, if the Hiera data looks like the following:</p><div class="informalexample"><pre class="programlisting">ntp::version: 'latest'</pre></div><p>Puppet will automatically find this value and pass it to the <code class="literal">ntp</code> class when it's declared.</p><p>In general, Puppet determines parameter values in the following order of priority, highest first:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Literal parameters specified in a class declaration (you may see older code which does this)</li><li class="listitem">Automatic parameter lookup from Hiera (the key must be named <code class="literal">CLASS_NAME::PARAMETER_NAME</code>)</li><li class="listitem">Default values specified in a class definition</li></ol></div></div></div></div>
<div class="section" title="Parameter data types"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec43"/>Parameter data types</h1></div></div></div><p>You should always specify <a id="id377" class="indexterm"/>types for your class parameters, as it makes it easier to catch errors where the wrong parameters or values are being supplied to the class. If you're using a String parameter, for example, if possible, make it an Enum parameter with an exact list of the values your class accepts. If you can't restrict it to a set of allowed values, specify a minimum length with <code class="literal">String[x]</code>. (If you need to specify a maximum <a id="id378" class="indexterm"/>length too, the syntax is <code class="literal">String[min, max]</code>.)</p><div class="section" title="Available data types"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec130"/>Available data types</h2></div></div></div><p>So far in this chapter, we've <a id="id379" class="indexterm"/>encountered the data types String, Enum, and Boolean. Here are the others:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Integer (whole numbers)</li><li class="listitem" style="list-style-type: disc">Float (floating-point numbers, which have optional decimal fractions)</li><li class="listitem" style="list-style-type: disc">Numeric (matches either integers or floats)</li><li class="listitem" style="list-style-type: disc">Array</li><li class="listitem" style="list-style-type: disc">Hash</li><li class="listitem" style="list-style-type: disc">Regexp</li><li class="listitem" style="list-style-type: disc">Undef (matches a variable or parameter which hasn't been assigned a value)</li><li class="listitem" style="list-style-type: disc">Type (data type of literal values which represent Puppet data types, such as String, Integer, and Array)</li></ul></div><p>There are also <span class="emphasis"><em>abstract</em></span> data types, which are more general:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Optional (matches a value which may be undefined, or not supplied)</li><li class="listitem" style="list-style-type: disc">Pattern (matches Strings which conform to a specified regular expression)</li><li class="listitem" style="list-style-type: disc">Scalar (matches Numeric, String, Boolean, or Regexp values, but not Array, Hash, or Undef)</li><li class="listitem" style="list-style-type: disc">Data (matches Scalar values, but also Array, Hash, and Undef)</li><li class="listitem" style="list-style-type: disc">Collection (matches Array or Hash)</li><li class="listitem" style="list-style-type: disc">Variant (matches one of a specified list of data types)</li><li class="listitem" style="list-style-type: disc">Any (matches any data type)</li></ul></div><p>In general, you should use as specific a data type as possible. For example, if you know that a parameter will always be an integer number, use <code class="literal">Integer</code>. If it needs to accept floating-point values as well, use <code class="literal">Numeric</code>. If it could be a String as well as a Number, use <code class="literal">Scalar</code>.</p></div><div class="section" title="Content type parameters"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec131"/>Content type parameters</h2></div></div></div><p>Types which represent a <a id="id380" class="indexterm"/>collection of values, such as <code class="literal">Array</code> and <code class="literal">Hash</code> (or their parent type, <code class="literal">Collection</code>) can also take a parameter indicating the type of values they contain. For example, <code class="literal">Array[Integer]</code> matches an array of Integer values.</p><p>If you declare a content type parameter to a collection, then all the values in that collection must match the declared type. If you don't specify a content type, the default is <code class="literal">Data</code>, which matches (almost) any type of value. The content type parameter can itself take parameters:  <code class="literal">Array[Integer[1]]</code> declares an array of positive Integers.</p><p>Hash takes two content type parameters, the first indicating the data type of its keys, the second the data type of its values. <code class="literal">Hash[String, Integer]</code> declares a hash whose keys are Strings, each of which is associated with an Integer value (this would match, for example, the hash <code class="literal">{'eggs' =&gt; 61}</code>).</p></div><div class="section" title="Range parameters"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec132"/>Range parameters</h2></div></div></div><p>Most types can also <a id="id381" class="indexterm"/>accept parameters in square brackets, which make the type declaration more specific. For example, we've already seen that <code class="literal">String</code> can take a pair of parameters indicating the minimum and maximum length of the string.</p><p>Most types can take <span class="strong"><strong>range </strong></span>
<a id="id382" class="indexterm"/>
<span class="strong"><strong>parameters</strong></span>: <code class="literal">Integer[0]</code> matches any Integer greater than or equal to zero, while <code class="literal">Float[1.0, 2.0]</code> matches any Float between 1.0 and 2.0 inclusive.</p><p>If either range parameter is the special value <code class="literal">default</code>, the default minimum or maximum value for the type will be used. For example, <code class="literal">Integer[default, 100]</code> matches any Integer less than or equal to 100.</p><p>For arrays and hashes, the range parameters specify the minimum and maximum number of elements or keys: <code class="literal">Array[Any, 16]</code> specifies an array of no less than 16 elements of <code class="literal">Any</code> type. <code class="literal">Hash[Any, Any, 5, 5]</code> specifies a hash containing exactly five key-value pairs.</p><p>You can specify both range and content type parameters at once: <code class="literal">Array[String, 1, 10]</code> matches an array of between one and ten strings. <code class="literal">Hash[String, Hash, 1]</code> specifies a hash with String keys and Hash values, containing at least one key-value pair with String keys and values of type Hash.</p></div><div class="section" title="Flexible data types"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec133"/>Flexible data types</h2></div></div></div><p>If you don't know exactly <a id="id383" class="indexterm"/>what type the values may be, you can use one of Puppet's more flexible <span class="strong"><strong>abstract types</strong></span>, such as <code class="literal">Variant</code>, which specifies a list of allowed types. For example, <code class="literal">Variant[String, Integer]</code> allows its value to be either a String or an Integer.</p><p>Similarly, <code class="literal">Array[Variant[Enum['true', 'false'], Boolean]]</code> declares an array of values which can be either the String values <code class="literal">'true'</code> or <code class="literal">'false'</code> or the Boolean values <code class="literal">true</code> and <code class="literal">false</code>.</p><p>The <code class="literal">Optional</code> type is very useful when a value may be undefined. For example, <code class="literal">Optional[String]</code> specifies a String parameter which may or may not be passed to the class. Normally, if a parameter is declared without a default value, Puppet will give an error when it is not supplied. If it is declared <code class="literal">Optional</code>, however, it may be omitted, or set to <code class="literal">Undef</code> (meaning that the identifier is defined, but has no value).</p><p>The <code class="literal">Pattern</code> type allows you to specify a regular expression. All Strings matching that regular expression will be allowed values for the parameter. For example, <code class="literal">Pattern[/a/]</code> will match any String which contains the lowercase letter a. In fact, you can specify as many regular expressions as you like. <code class="literal">Pattern[/a/, /[0-9]/]</code> matches any String which contains the letter <code class="literal">a</code>, or any string which contains a digit.</p></div></div>
<div class="section" title="Defined resource types"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec44"/>Defined resource types</h1></div></div></div><p>Whereas a class lets you <a id="id384" class="indexterm"/>group together related resources, a <span class="strong"><strong>defined resource type</strong></span> lets you create new kinds of resources and declare as many instances of them as you like. A defined resource type definition looks a lot like a class (<code class="literal">defined_resource_type.pp</code>):</p><div class="informalexample"><pre class="programlisting"># Manage user and SSH key together
define user_with_key(
  Enum[
    'ssh-dss',
    'dsa',
    'ssh-rsa',
    'rsa',
    'ecdsa-sha2-nistp256',
    'ecdsa-sha2-nistp384',
    'ecdsa-sha2-nistp521',
    'ssh-ed25519',
    'ed25519'
  ] $key_type,
  String $key,
) {
  user { $title:
    ensure     =&gt; present,
    managehome =&gt; true,
  }

  file { "/home/${title}/.ssh":
    ensure =&gt; directory,
    owner  =&gt; $title,
    group  =&gt; $title,
    mode   =&gt; '0700',
  }

  ssh_authorized_key { $title:
    user =&gt; $title,
    type =&gt; $key_type,
    key  =&gt; $key,
  }
}</pre></div><p>You can see that instead of the <code class="literal">class</code> keyword, we use the <code class="literal">define</code> keyword. This tells Puppet that we are creating a <a id="id385" class="indexterm"/>defined resource type instead of a class. The type is called <code class="literal">user_with_key</code>, and once it's defined, we can declare as many instances of it as we want, just like any other Puppet resource:</p><div class="informalexample"><pre class="programlisting">user_with_key { 'john':
  key_type =&gt; 'ssh-rsa',
  key      =&gt; 'AAAA...AcZik=',
}</pre></div><p>When we do this, Puppet applies all the resources inside <code class="literal">user_with_key</code>: a user, a <code class="literal">.ssh</code> directory for that user, and an <code class="literal">ssh_authorized_key</code> for the user, containing the specified key.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip37"/>Tip</h3><p>Wait, we seem to be referring to a parameter called <code class="literal">$title</code> in the example code. Where does that come from? <code class="literal">$title</code> is a special parameter which is always available in classes and defined resource types, and its value is the title of this particular declaration of the class or type. In the example, that's <code class="literal">john</code>, because we gave the declaration of <code class="literal">user_with_key</code> the title <code class="literal">john</code>.</p></div></div><p>So what's the difference between defined resource types and classes? They look pretty much the same. They seem to act the same. Why would you use one rather than the other? The most important difference is that you can only have <span class="strong"><strong>one declaration</strong></span> of a given class on a given node, whereas you can have as many different instances of a defined resource type as you like. The only restriction is that, like all Puppet resources, the title of each instance of the defined resource type must be unique.</p><p>Recall our example <code class="literal">ntp</code> class, which installs and runs the NTP daemon. Usually, you would only want one NTP service per node. There's very little point in running two. So we declare the class once, which is all we need.</p><p>Contrast this with the <code class="literal">user_with_key</code> defined resource type. It's quite likely that you'll want more than one <code class="literal">user_with_key</code> on a given node, perhaps several. In this case, a defined resource type is the <a id="id386" class="indexterm"/>right choice.</p><p>Defined resource types are ideal in modules when you want to make a resource available to users of the module. For example, in the <code class="literal">puppetlabs/apache</code> module, the <code class="literal">apache::vhost</code> resource is a defined resource type, provided by the <code class="literal">apache</code> class. You can think of a defined resource type as being a wrapper for a collection of multiple resources.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip38"/>Tip</h3><p>Remember this rule of thumb when deciding whether to create a class or a defined resource type: if it's reasonable to have more than one instance on a given node, it should be a defined resource type, but if there will only ever be one instance, it should be a class.</p></div></div><div class="section" title="Type aliases"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec134"/>Type aliases</h2></div></div></div><p>It's straightforward to define new <a id="id387" class="indexterm"/>
<a id="id388" class="indexterm"/>
<span class="strong"><strong>type aliases</strong></span>, using the <code class="literal">type</code> keyword (<code class="literal">type_alias.pp</code>):</p><div class="informalexample"><pre class="programlisting">type ServiceState = Enum['running', 'stopped']

define myservice(ServiceState $state) {
  service { $name:
    ensure =&gt; $state,
  }
}

myservice { 'ntp':
  state =&gt; 'running',
}</pre></div><p>Creating a type alias can be very useful when you want to ensure, for example, that parameter values match a complex pattern, which would be tiresome to duplicate. You can define the pattern in one place and declare multiple parameters of that type (<code class="literal">type_alias_pattern.pp</code>):</p><div class="informalexample"><pre class="programlisting">type IPAddress = Pattern[/\A([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}\z/]

define socket_server(
  IPAddress $listen_address,
  IPAddress $public_address,
) {
  # ...
}

socket_server { 'myserver':
  listen_address =&gt; '0.0.0.0',
  public_address =&gt; $facts['networking']['ip'],
}</pre></div><p>When creating a type <a id="id389" class="indexterm"/>alias in a module, it should be in a file named after <a id="id390" class="indexterm"/>the type in the <code class="literal">types</code> subdirectory of the module. For example, a type named <code class="literal">IPAddress</code> should be defined in the file <code class="literal">types/ipaddress.pp</code>.</p></div></div>
<div class="section" title="Managing classes with Hiera"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec45"/>Managing classes with Hiera</h1></div></div></div><p>In <a class="link" href="ch03.html" title="Chapter 3. Managing your Puppet code with Git">Chapter 3</a>, <span class="emphasis"><em>Managing your Puppet code with Git</em></span>, we saw how to set up your Puppet repo on multiple <a id="id391" class="indexterm"/>nodes and auto-apply the manifest using a cron job <a id="id392" class="indexterm"/>and the <code class="literal">run-puppet</code> script. The <code class="literal">run-puppet</code> script runs the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cd /etc/puppetlabs/code/environments/production &amp;&amp; git pull/opt/puppetlabs/bin/puppet apply manifests/</strong></span>
</pre></div><p>You can see that everything in the <code class="literal">manifests/</code> directory will be applied on every node. Clearly, Puppet is much more useful when we can apply different manifests on each node; some nodes will be web servers, others database servers, and so on. In fact, we would like to include some classes on all nodes, for general administration, such as managing user accounts, and other classes only on specific nodes. So how do we do that?</p><div class="section" title="Using include with lookup()"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec135"/>Using include with lookup()</h2></div></div></div><p>Previously, when <a id="id393" class="indexterm"/>including classes in our manifest, we've used the <code class="literal">include</code> keyword with a literal class name, as in the following example:</p><div class="informalexample"><pre class="programlisting">include postgresql
include apache</pre></div><p>However, <code class="literal">include</code> can also be used as a function, which takes an array of class names to include:</p><div class="informalexample"><pre class="programlisting">include(['postgresql', 'apache'])</pre></div><p>We already know that we can use Hiera to return different values for a query based on the node name (or anything else defined in the hierarchy), so let's define a suitable array in Hiera data, as in the following example:</p><div class="informalexample"><pre class="programlisting">classes:
- postgresql
- apache</pre></div><p>Now we can simply use <code class="literal">lookup()</code> to get this Hiera value, and pass the result to the <code class="literal">include()</code> function:</p><div class="informalexample"><pre class="programlisting">include(lookup('classes'), Array[String], 'unique')</pre></div><p>In effect, this is your entire Puppet manifest. Every node will apply this manifest, and thus include the classes assigned to it by the Hiera data. Since the top-level manifest file is traditionally named <code class="literal">site.pp</code>, you can put this <code class="literal">include</code> line in <code class="literal">manifests/site.pp</code>, and the <code class="literal">papply</code> or <code class="literal">run-puppet</code> scripts will apply it because they apply everything in the <code class="literal">manifests/</code> directory.</p></div><div class="section" title="Common and per-node classes"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec136"/>Common and per-node classes</h2></div></div></div><p>We can <a id="id394" class="indexterm"/>specify a set of classes in <code class="literal">common.yaml</code> which will be applied to all nodes: things such as user accounts, SSH and <code class="literal">sudoers</code> config, time zone, NTP setup, and so on. The complete example repo outlined in <a class="link" href="ch12.html" title="Chapter 12. Putting it all together">Chapter 12,</a> <span class="emphasis"><em>Putting it all together</em></span> has a typical set of such classes defined in <code class="literal">common.yaml</code>.</p><p>However, some classes will only be needed on particular nodes. Add these to the per-node Hiera data file. For example, our <code class="literal">pbg</code> environment on the Vagrant box contains the following in <code class="literal">hiera.yaml</code>:</p><div class="informalexample"><pre class="programlisting">  - name: "Host-specific data"
    path: "nodes/%{facts.hostname}.yaml"</pre></div><p>So per-node data for a node named <code class="literal">node1 </code>will live in the <code class="literal">nodes/node1.yaml</code> file under the <code class="literal">data/</code> directory.</p><p>Let's see a <a id="id395" class="indexterm"/>complete example. Suppose your <code class="literal">common.yaml</code> file contains the following:</p><div class="informalexample"><pre class="programlisting">classes:
- postgresql
- apache</pre></div><p>And suppose your per-node file (<code class="literal">nodes/node1.yaml</code>) also contains:</p><div class="informalexample"><pre class="programlisting">classes:
- tomcat
- my_app</pre></div><p>Now, what happens when you apply the following manifest in <code class="literal">manifests/site.pp </code>on <code class="literal">node1</code>?</p><div class="informalexample"><pre class="programlisting">include(lookup('classes'), Array[String], 'unique')</pre></div><p>Which classes will be applied? You may recall from <a class="link" href="ch06.html" title="Chapter 6. Managing data with Hiera">Chapter 6,</a> <span class="emphasis"><em>Managing data with Hiera</em></span> that the <code class="literal">unique</code> merge strategy finds all values for the given key throughout the hierarchy, merges them together, and returns them as a flattened array, with duplicates removed. So the result of this <code class="literal">lookup()</code> call will be the following array:</p><div class="informalexample"><pre class="programlisting">[apache, postgresql, tomcat, my_app]</pre></div><p>This is the complete list of classes that Puppet will apply to the node. Of course, you can add classes at any other level of the hierarchy, if you need to, but you will probably find the common and per-node levels to be the most useful for including classes.</p><p>Naturally, even though some nodes may include the same classes as others, they may need different configuration values for the classes. You can use Hiera in the same way to supply different parameters for the included classes, as described in the <span class="emphasis"><em>Automatic parameter lookup from Hiera data</em></span> section earlier in this chapter.</p></div></div>
<div class="section" title="Roles and profiles"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec46"/>Roles and profiles</h1></div></div></div><p>Now that we know how to <a id="id396" class="indexterm"/>include different sets of classes on a given node, depending on the job the node is supposed to do, let's think more about how to name those classes in the most helpful way. For example, consider the following list of included classes for a certain node:</p><div class="informalexample"><pre class="programlisting">classes:
- postgresql
- apache
- java
- tomcat
- my_app</pre></div><p>The class names give some clues as to what this node might be doing. It looks like it's probably an app server running a <a id="id397" class="indexterm"/>Java app named <code class="literal">my_app</code> served by Tomcat behind Apache, and backed by a PostgreSQL database. That's a good start, but we can do even better than this, and we'll see how in the next section.</p><div class="section" title="Roles"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec137"/>Roles</h2></div></div></div><p>To make it obvious that the node <a id="id398" class="indexterm"/>is an app server, why don't we create a class called <code class="literal">role::app_server</code>, which exists only to encapsulate the node's included classes? That class definition might look like this (<code class="literal">role_app_server.pp</code>):</p><div class="informalexample"><pre class="programlisting"># Be an app server
class role::app_server {
  include postgresql
  include apache
  include java
  include tomcat
  include my_app
}</pre></div><p>We call this idea a <span class="strong"><strong>role class</strong></span>. A role class could simply be a module in its own right, or to make it clear that this is a role class, we could organize it into a special <code class="literal">role</code> module. If you keep all your role classes in a single module, then they will all be named <code class="literal">role::something</code>, depending on the role they implement.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip39"/>Tip</h3><p>It's important to note that role classes are not special to Puppet in any way. They're just ordinary classes; we call them role classes only to remind ourselves that they are for expressing the roles assigned to a particular node.</p></div></div><p>The value of <code class="literal">classes</code> in Hiera is now reduced to just the following:</p><div class="informalexample"><pre class="programlisting">classes:
- role::app_server</pre></div><p>Looking at the Hiera data, it's now very easy to see what the node's job is—what its <span class="emphasis"><em>role</em></span> is—and all app servers now just need to include <code class="literal">role::app_server</code>. When or if the list of classes required for app servers <a id="id399" class="indexterm"/>changes, you don't need to find and update the Hiera <code class="literal">classes</code> <a id="id400" class="indexterm"/>value for every app server; you just need to edit the <code class="literal">role::app_server</code> class.</p></div><div class="section" title="Profiles"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec138"/>Profiles</h2></div></div></div><p>We can tidy up our <a id="id401" class="indexterm"/>manifest quite a bit by adopting the rule of thumb that, apart from common configuration in <code class="literal">common.yaml</code>, <span class="strong"><strong>nodes should only include role classes</strong></span>. This makes the Hiera data more self-documenting, and our role classes are all neatly organized in the <code class="literal">role</code> module, each of them encapsulating all the functionality required for that role. It's a big improvement. But can we do even better?</p><p>Let's look at a role class such as <code class="literal">role::app_server</code>. It contains lots of lines including modules, like the following:</p><div class="informalexample"><pre class="programlisting">  include tomcat</pre></div><p>If all you need to do is include a module and have the parameters automatically looked up from Hiera data, then there's no problem. This is the kind of simple, encouraging, unrealistic example you'll see in product documentation or on a conference slide.</p><p>Real-life Puppet code is often more complicated, however, with logic and conditionals and special cases, and extra resources that need to be added, and so forth. We don't want to duplicate all this code when we use Tomcat as part of another role (for example, serving another Tomcat-based app). How can we neatly encapsulate it at the right level of abstraction and avoid duplication?</p><p>We could, of course, create a custom module for each app, which hides away all that messy support code. However, it's a big overhead to create a new module just for a few lines of code, so it seems like there should be a niche for a small layer of code which bridges the gap between roles and modules.</p><p>We call this a <span class="strong"><strong>profile class</strong></span>. A profile encapsulates some specific piece of software or functionality which is required for a role. In our example, the <code class="literal">app_server</code> role requires several pieces of software: PostgreSQL, Tomcat, Apache, and so on. Each of these can now have its own profile.</p><p>Let's rewrite the <code class="literal">app_server</code> role to include profiles, instead of modules (<code class="literal">role_app_server_profiles.pp</code>):</p><div class="informalexample"><pre class="programlisting"># Be an app server
class role::app_server {
  include profile::postgresql
  include profile::apache
  include profile::java
  include profile::tomcat
  include profile::my_app
}</pre></div><p>What would be in these profile classes? The <code class="literal">profile::tomcat</code> class, for example, would set up the specific configuration of Tomcat required, along with any app-specific or site-specific resources required, such as firewall rules, <code class="literal">logrotate</code> config, file and directory permissions, and so on. The <a id="id402" class="indexterm"/>profile wraps the module, configures it, and provides everything the module does not, in order to support this particular application or site.</p><p>The <code class="literal">profile::tomcat</code> class might look something like the following example, adapted from a real production manifest (<code class="literal">profile_tomcat.pp</code>):</p><div class="informalexample"><pre class="programlisting"># Site-specific Tomcat configuration
class profile::tomcat {
  tomcat::install { '/usr/share/tomcat7':
    install_from_source =&gt; false,
    package_ensure      =&gt; present,
    package_name        =&gt; ['libtomcat7-java','tomcat7-common','tomcat7'],
  }

  exec { 'reload-tomcat':
    command     =&gt; '/usr/sbin/service tomcat7 restart',
    refreshonly =&gt; true,
  }

  lookup('tomcat_allowed_ips', Array[String[7]]).each |String $source_ip| {
    firewall { "100 Tomcat access from ${source_ip}":
      proto  =&gt; 'tcp',
      dport  =&gt; '8080',
      source =&gt; $source_ip,
      action =&gt; 'accept',
    }
  }

  file { '/usr/share/tomcat7/logs':
    ensure  =&gt; directory,
    owner   =&gt; 'tomcat7',
    require =&gt; Tomcat::Install['/usr/share/tomcat7'],
  }

  file { '/etc/logrotate.d/tomcat7':
    source =&gt; 'puppet:///site-modules/profile/tomcat/tomcat7.logrotate',
  }
}</pre></div><p>The exact contents of this class don't really matter here, but the point you should take away is that this kind of site-specific 'glue' code, wrapping third-party modules and connecting them with particular applications, should live in a profile class.</p><p>In general, a profile class should include everything needed to make that particular software component or service work, including other profiles if necessary. For example, every profile which requires a specific configuration of Java should include that Java profile. You can include a profile from multiple other profiles without any conflicts.</p><p>Using profile classes in this way both makes your role classes neater, tidier, and easier to maintain, but it also allows you to <a id="id403" class="indexterm"/>reuse the profiles for different roles. The <code class="literal">app_server</code> role includes these profiles, and other roles can include them as well. This way, our code is organized to reduce duplication and encourage re-use. The second rule of thumb is, <span class="strong"><strong>roles should only include profiles</strong></span>.</p><p>If you're still confused about the exact distinction between roles and profiles, don't worry: you're in good company. Let's try and define them as succinctly as possible:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Roles</strong></span> identify a particular function for a node, such as being an app server or a database server. A role exists to document what a node is for. Roles should only include profiles, but they can include any number of profiles.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Profiles</strong></span> identify a particular piece of software or functionality which contributes to a role; for example, the <code class="literal">tomcat</code> profile is required for the <code class="literal">app_server</code> role. Profiles generally install and configure a specific software component or service, its associated business logic, and any other Puppet resources needed. Profiles are the 'glue layer' which sits between roles and modules.</li></ul></div><p>It's possible that your manifest may be so simple that you can organize it using only roles or only profiles. That's fine, but when things start getting more complex and you find yourself duplicating code, consider refactoring it to use the roles-and-profiles pattern in the way we've seen here.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec47"/>Summary</h1></div></div></div><p>In this chapter, we've looked at a range of different ways of organizing your Puppet code. We've covered classes in detail, explaining how to define them using the <code class="literal">class</code> keyword to define a new class, using the <code class="literal">include</code> keyword to declare the class, and using Hiera's automatic parameter lookup mechanism to supply parameters for included classes.</p><p>Declaring parameters involves specifying the allowable data types for parameters, and we've had a brief overview of Puppet's data types, including scalars, collections, content types and range parameters, abstract types, flexible types, and introduced creating your own type aliases. We've also introduced the defined resource type, and explained the difference between defined resource types and classes, and when you would use one or the other.</p><p>We've also looked at how to use the <code class="literal">classes</code> array in Hiera to include common classes on all nodes, and other classes only on particular nodes. We've introduced the idea of the role class, which encapsulates everything needed for a node to fulfil a particular role, such as an app server.</p><p>Finally, we've seen how to use profile classes to configure and support a particular software package or service, and how to compose several profile classes into a single role class. Between them, roles and profiles bridge the gap between the Hiera <code class="literal">classes</code> array, at the top level, and modules and configuration data (at the lowest level). We can summarize the rules by saying that <span class="emphasis"><em>nodes should only include roles, and roles should only include profiles</em></span>.</p><p>In the next chapter we'll look at using Puppet to create files using templates, iteration, and Hiera data.</p></div></body></html>