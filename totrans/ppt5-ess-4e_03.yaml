- en: A Peek into the Ruby Part of Puppet - Facts, Types, and Providers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一窥 Puppet 中的 Ruby 部分——Facts、Types 和 Providers
- en: So far in this book, you have primarily done practical things - writing manifests,
    setting up a master, assigning agents, signing certificates, and so forth. Before
    you are introduced to the missing language concepts that you will need to use
    Puppet effectively for bigger projects, there is some background that we should
    cover. Don't worry, it won't be all dry theory - most of the important parts of
    Puppet are relevant to your daily business.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，你主要做了一些实际操作——编写清单、设置主机、分配代理、签署证书等等。在介绍你需要掌握的缺失语言概念之前，这些概念将帮助你在更大的项目中有效地使用
    Puppet，我们需要先了解一些背景知识。别担心，这不会全是枯燥的理论——Puppet 的大部分重要部分与你的日常工作密切相关。
- en: The topics of this chapter have been hinted at earlier; [Chapter 1](8a22dc0e-3fe2-4153-b60e-935b7e6d9f94.xhtml),
    *Writing Your First Manifests*, contained a brief description of the type and
    provider. This and some adjacent topics will be thoroughly explored in the sections
    collecting system information with Facter, understanding the type system, and
    command execution control with providers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主题在之前已有所提及；[第 1 章](8a22dc0e-3fe2-4153-b60e-935b7e6d9f94.xhtml)，*编写你的第一个清单*，简要描述了类型和提供者的概念。接下来的一些相关主题将通过“使用
    Facter 收集系统信息”、“理解类型系统”和“使用提供者控制命令执行”这些部分深入探讨。
- en: Putting it all together - collecting system information with Facter
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起——使用 Facter 收集系统信息
- en: Configuration management is quite a dynamic problem. In other words, the systems
    that need configuration are mostly moving targets. In some situations, system
    administrators or operators get lucky and work with large quantities of 100 percent
    uniform hardware and software. In most cases, however, the landscape of servers
    and other computing nodes is rather heterogeneous, at least in subtle ways. Even
    in unified networks, there are likely multiple generations of machines or operating
    systems, with smaller or larger differences required for their respective configurations.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理是一个相当动态的问题。换句话说，需要配置的系统大多是不断变化的目标。在某些情况下，系统管理员或操作员会很幸运，能与大量 100% 一致的硬件和软件进行工作。然而，在大多数情况下，服务器和其他计算节点的环境是相当异质的，至少在某些微妙的方面是这样。即使在统一的网络中，也可能有多代机器或操作系统，它们在各自的配置要求上会有更大或更小的差异。
- en: For example, a common task for Puppet is to handle the configuration of system
    monitoring. Your business logic will likely dictate warning thresholds for gauges
    such as the system load value. However, those thresholds can rarely be static.
    On a two-processor virtual machine, a system load of `10` represents a crippling
    overload, while the same value can be absolutely acceptable for a busy DBMS server
    that has cutting edge hardware of the largest dimensions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Puppet 的一个常见任务是处理系统监控的配置。你的业务逻辑可能会为仪表盘设置警告阈值，比如系统负载值。然而，这些阈值很少是固定的。在一台双处理器的虚拟机上，系统负载值为
    `10` 表示系统严重过载，而同样的值对一台硬件配置最先进的大型数据库管理系统（DBMS）服务器来说是完全可以接受的。
- en: Another important factor can be software platforms. Your infrastructure might
    span multiple distributions of Linux or alternate operating systems, such as BSD,
    Solaris, or Windows, each with different ways of handling certain scenarios. Imagine,
    for example, that you want Puppet to manage some content from the `fstab` file.
    On your rare Solaris system, you would have to make sure that Puppet targets the
    `/etc/vfstab` file instead of `/etc/fstab`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的因素是软件平台。你的基础设施可能跨越多个 Linux 发行版或其他操作系统，如 BSD、Solaris 或 Windows，每种操作系统在处理某些场景时都有不同的方法。例如，假设你想让
    Puppet 管理来自 `fstab` 文件的一些内容。在你那台罕见的 Solaris 系统上，你必须确保 Puppet 目标指向的是 `/etc/vfstab`
    文件，而不是 `/etc/fstab`。
- en: It is usually not a good idea to interact directly with the `fstab` file in
    your manifest. This example will be rounded off in the section concerning providers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通常不建议直接在清单中与 `fstab` 文件进行交互。这个例子将在涉及提供者的章节中进一步完善。
- en: Puppet strives to present you with a unified way of managing all your infrastructure.
    It therefore needs a means to allow your manifests to adapt to different kinds
    of circumstances on the agent machines. This includes their operating system,
    hardware layout, and many other details. Keep in mind that, generally, the manifests
    have to be compiled on the master machine.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 力求为你提供一种统一的方式来管理你的所有基础设施。因此，它需要一种方法，使你的清单能够适应代理机器上不同的情况。这包括它们的操作系统、硬件布局以及许多其他细节。请记住，通常情况下，清单需要在主机上进行编译。
- en: There are several conceivable ways to implement a solution for this particular
    problem. A direct approach would be to use a language construct that allows the
    master to send a piece of shell script (or other code) to the agent and receive
    its output in return.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种可行的方式可以为这个特定问题实现解决方案。一种直接的方法是使用一种语言结构，允许主机将一段Shell脚本（或其他代码）发送给代理并接收其输出。
- en: 'The following is pseudocode; however, there are no back tick expressions in
    the Puppet DSL:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是伪代码；然而，Puppet DSL中并没有反引号表达式：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This solution would be powerful but expensive. The master would need to call
    back to the agent whenever the compilation process encountered such an expression.
    Writing manifests that were able to cope with such a command returning an error
    code would be strenuous, and Puppet would likely end up resembling a quirky scripting
    engine.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案会非常强大，但也很昂贵。当编译过程遇到这样的表达式时，主机需要回调代理。编写能够应对这种命令返回错误代码的清单会非常繁琐，Puppet可能最终会变成一个奇怪的脚本引擎。
- en: 'Puppet uses a different approach. It relies on a secondary system called Facter,
    which has the sole purpose of examining the machine on which it is run. It serves
    a list of well-known variable names and values, all according to the system on
    which it runs. For example, an actual Puppet manifest that needs to form a condition
    upon the number of processors on the agent will use this expression:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet使用不同的方法。它依赖于一个名为Facter的二级系统，Facter的唯一目的是检查其运行所在的机器。它提供了一组根据运行系统生成的已知变量名称和值。例如，一个实际的Puppet清单，如果需要根据代理上的处理器数量形成条件，将使用以下表达式：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Facter's variables are called **facts**, and `processors` is one such fact.
    With Facter version 3 or later, most data will be gathered and presented as structured
    facts (JSON). In the example, we accessed the `'count'` element from 'processors'
    data. The older key-value pairs are still available. The fact values are gathered
    by the agent and sent to the master, who will use these facts to compile a catalog.
    All fact names are available in the manifests as variables.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Facter的变量被称为**事实**，`processors`就是其中之一。使用Facter 3或更高版本时，大多数数据将以结构化事实（JSON）的形式收集和呈现。在这个示例中，我们访问了`processors`数据中的`'count'`元素。旧的键值对仍然可用。事实值由代理收集并发送到主机，主机会使用这些事实来编译目录。所有事实名称都可以作为变量在清单中使用。
- en: 'Facts are also available to manifests that are used with `puppet apply`, of
    course. You can test this very simply with the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 事实（Facts）也可以用于与`puppet apply`一起使用的清单。你可以通过以下简单的方式来测试：
- en: '`puppet apply -e ''notify { "I am ${::networking[''fqdn'']} and have ${::processors[''count]}
    CPUs": }''`'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`puppet apply -e ''notify { "I am ${::networking[''fqdn'']} and have ${::processors[''count'']}
    CPUs": }''`'
- en: Accessing and using fact values
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问和使用事实值
- en: You have already seen the use of the `processors` fact in an example. In the
    manifest, each fact value is available as a global variable value. That is why
    you can just use the `::processors` expression where you need it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在一个示例中看到过`processors`事实的使用。在清单中，每个事实值都作为全局变量值可用。这就是为什么你可以在需要的地方直接使用`::processors`表达式的原因。
- en: You will often see conventional uses such as `$::processors['count']` or `$::networking[‘ip’]`.
    Prefixing the fact name with double colons is highly recommended. The official
    style guide at [https://docs.puppetlabs.com/guides/style_guide.html#namespacing-variables](https://docs.puppetlabs.com/guides/style_guide.html#namespacing-variables) recommends
    this. The prefix indicates that you are referring to a variable delivered from
    Facter. Facter variables are put into the Puppet master's top scope.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会看到类似`$::processors['count']`或`$::networking['ip']`的常规用法。强烈建议在事实名称前加上双冒号。官方风格指南在[https://docs.puppetlabs.com/guides/style_guide.html#namespacing-variables](https://docs.puppetlabs.com/guides/style_guide.html#namespacing-variables)中推荐了这一做法。这个前缀表明你正在引用来自Facter的变量。Facter变量被放入Puppet主机的顶级作用域中。
- en: 'Some helpful facts have already been mentioned. The `processors` fact might
    play a role for your configuration. When configuring some services, you will want
    to use the machine''s `networking [''ip'']` value in a configuration file or as
    an argument value:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一些有用的事实已经提到过了。`processors`事实可能在你的配置中起着作用。当配置某些服务时，你可能希望在配置文件中或作为参数值使用机器的`networking['ip']`值：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Apart from the hostname, your manifest can also make use of the **Fully Qualified
    Domain Name** (**FQDN**) of the agent machine.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了主机名外，你的清单还可以利用代理机器的**完全限定域名**（**FQDN**）。
- en: 'The agent will use the value of its `fqdn` fact as the name of its certificate
    (`clientcert`) by default. The master receives both these values. Note that the
    agent can override the `fqdn` value of any name, whereas the `clientcert` value
    is tied to the signed certificate that the agent uses. Sometimes, you will want
    the master to pass sensitive information to individual nodes. The manifest must
    identify the agent by its `clientcert` fact and never use `fqdn` or `hostname`
    instead, for the reason mentioned. An example is shown in the following code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 代理默认使用其 `fqdn` 事实的值作为其证书的名称（`clientcert`）。主机会收到这两个值。注意，代理可以覆盖 `fqdn` 的值，但 `clientcert`
    的值与代理所使用的签名证书绑定。有时，你希望主机将敏感信息传递给单独的节点。清单必须通过 `clientcert` 事实来标识代理，而不能使用 `fqdn`
    或 `hostname`，原因如上所述。以下代码给出了一个示例：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There is a whole group of facts that are used to describe the operating system.
    Each fact is useful in different situations. The `os[‘name’]` fact takes values
    such as `Debian` or `CentOS`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有一组专门用于描述操作系统的事实。每个事实在不同的情况下都很有用。`os[‘name’]` 事实的值可以是 `Debian` 或 `CentOS` 等：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If your manifest will behave identically on RHEL, CentOS, and Fedora (but not
    on Debian and Ubuntu), you should make use of the `osfamily` fact instead:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的清单在 RHEL、CentOS 和 Fedora 上的行为完全相同（但在 Debian 和 Ubuntu 上不同），你应该使用 `osfamily`
    事实：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `os[‘release’][‘full’]` fact allows you to tailor your manifests to the
    different versions of your OS:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`os[‘release’][‘full’]` 事实允许你根据不同的操作系统版本来定制你的清单：'
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Facts such as mac address, the different SSH host keys, fingerprints, and others
    make it easy to use Puppet for keeping an inventory of your hardware. There are
    a slew of other useful facts. Of course, the collection will not suit every possible
    need of every user out there. That is why Facter comes readily extendible.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 事实如 MAC 地址、不同的 SSH 主机密钥、指纹等使得使用 Puppet 来管理硬件清单变得非常简单。当然，还有许多其他有用的事实。当然，这些集合并不能满足每个用户的所有需求。这就是为什么
    Facter 是可扩展的原因。
- en: Extending Facter with custom facts
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展 Facter 以添加自定义事实
- en: Technically, nothing is stopping you from adding your own fact code right next
    to the core facts, either by maintaining your own Facter package, or even by deploying
    the Ruby code files to your agents directly through Puppet management. However,
    Puppet offers a much more convenient alternative in the form of custom facts.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，除了维护你自己的 Facter 包，或者通过 Puppet 管理直接将 Ruby 代码文件部署到代理上外，什么都不会阻止你在核心事实旁边添加你自己的事实代码。不过，Puppet
    提供了一种更方便的替代方案——自定义事实。
- en: We have still not covered Puppet modules yet. They will be thoroughly introduced
    in [Chapter 5](3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml), *Combining Classes,
    Configuration Files, and Extensions into Modules*. For now, just create a Ruby
    file at `/etc/puppetlabs/code/environments/production/modules/hello_world/lib/facter/hello.rb`
    on the master machine. Puppet will recognize this as a custom fact of the name,
    `hello`. (For Puppet 3 or older versions, the path should be `/etc/puppet/modules/hello_world/lib/facter/hello.rb.`)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有涉及 Puppet 模块的内容。它们将在[第五章](3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml)《将类、配置文件和扩展结合成模块》中进行详细介绍。目前，只需在主机上创建一个
    Ruby 文件 `/etc/puppetlabs/code/environments/production/modules/hello_world/lib/facter/hello.rb`。Puppet
    会将其识别为名为 `hello` 的自定义事实。（对于 Puppet 3 或更早版本，路径应该是 `/etc/puppet/modules/hello_world/lib/facter/hello.rb`。）
- en: The inner workings of Facter are very straightforward and goal oriented. There
    is one block of Ruby code for each fact, and the return value of the block becomes
    the fact value. Many facts are self-sufficient, but others will rely on the values
    of one or more basic facts. For example, the method to determine the IP address(es)
    of the local machine is highly dependent upon the operating system.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Facter 的内部工作原理非常简单且目标明确。每个事实都有一块 Ruby 代码，代码的返回值即为事实值。许多事实是自足的，但也有一些会依赖于一个或多个基础事实的值。例如，确定本地机器的
    IP 地址的方法在很大程度上依赖于操作系统。
- en: 'The `hello` fact is very simple, though:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`hello` 事实非常简单：'
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The return value of the `setcode` block is the string `Hello, world!`, and you
    can use this fact as `$::hello` in a Puppet manifest.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`setcode` 块的返回值是字符串 `Hello, world!`，你可以在 Puppet 清单中使用这个事实作为 `$::hello`。'
- en: Before Facter version 2.0, each fact had a string value. If a code block returns
    another value, such as an array or hash, Facter 1.x will convert it to a string.
    The result is not useful in many cases. For this historic reason, there are facts
    such as `ipaddress_eth0` and `ipaddress_lo` instead of (or in addition to) a proper
    hash structure with interface names and addresses.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在Facter 2.0版本之前，每个事实都有一个字符串值。如果代码块返回另一个值，例如数组或哈希，Facter 1.x会将其转换为字符串。许多情况下，这样的结果并不有用。出于这个历史原因，存在像`ipaddress_eth0`和`ipaddress_lo`这样的事实，而不是（或者说除了）带有接口名称和地址的正确哈希结构。
- en: 'It is important for the `pluginsync` option to be enabled on the agent side.
    This has been the default for a long time and should not require any customization.
    The agent will synchronize all custom facts whenever checking in to the master.
    They are permanently available on the agent machine after that. You can then retrieve
    the `hello` fact from the command line using the following line:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在代理端启用`pluginsync`选项非常重要。这已成为默认设置，并且不需要任何定制。代理在每次与主机连接时都会同步所有自定义事实。之后，它们将永久保留在代理机器上。然后，你可以使用以下命令行从命令行检索`hello`事实：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Just by invoking the following command without an argument, you can request
    a list of all fact names and values.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 只需调用以下命令而不带参数，你就可以请求列出所有事实名称和值。
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There is also a `facter` command. It does roughly the same as puppet facts,
    but will only show built-in facts, not your custom facts.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`facter`命令。它的功能大致与`puppet facts`相同，但只会显示内置事实，而不是自定义事实。
- en: In Puppet 3 and earlier, there was no puppet facts subcommand. You had to rely
    on the Facter CLI (from Facter version 2.x or older) and call `facter -p`, to
    include custom facts. Some versions of Facter 3.0 removed this parameter; newer
    versions support it again.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在Puppet 3及更早版本中，没有`puppet facts`子命令。你必须依赖Facter CLI（Facter 2.x或更早版本），并调用`facter
    -p`来包括自定义事实。一些Facter 3.0版本移除了这个参数；新版本又重新支持了它。
- en: 'This book will not cover all aspects of Facter''s API, but there is one facility
    that is quite essential. Many of your custom facts will only be useful on Unix-like
    systems, and others will only be useful on your Windows boxes. You can retrieve
    such facts using a construct the same as the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不会涵盖Facter API的所有方面，但有一个功能非常重要。你的许多自定义事实仅在类Unix系统上有用，另一些则只在Windows主机上有用。你可以使用与以下类似的结构来检索这些事实：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This would be quite tedious and repetitive, though. Instead, you can invoke
    the `confine` method within the `Facter.add(name) { ... }` block:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这会相当繁琐和重复。不过，你可以在`Facter.add(name) { ... }`块内调用`confine`方法：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can confine a fact to several alternative values as well:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将一个事实限制为多个替代值：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, if a fact does make sense in different circumstances, but requires
    drastically different code in each respective case, you can add the same fact
    several times, each with a different set of `confine` values. Core facts such
    as `ipaddress` use this often:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果某个事实在不同情况下是合理的，但每个情况下需要完全不同的代码，你可以多次添加相同的事实，每次使用不同的`confine`值。像`ipaddress`这样的核心事实经常这样做：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can confine facts based on any combination of other facts, not just `kernel`.
    It is a very popular choice though. The `operatingsystem` or `osfamily` facts
    can be more appropriate in certain situations. Technically, you can even confine
    some of your facts to certain `processorcount` values, and so forth.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以基于其他事实的任何组合来限制事实，而不仅仅是`kernel`。不过，这种方式非常流行。在某些情况下，`operatingsystem`或`osfamily`事实可能更合适。从技术上讲，你甚至可以将一些事实限制为某些`processorcount`值，等等。
- en: Simplifying things using external facts
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用外部事实简化操作
- en: If writing and maintaining Ruby code is not desirable in your team for any reason,
    you might prefer to use an alternative that allows shell scripts, or really any
    kind of programming language, or even static data with no programming involved
    at all. Facter allows this in the form of **external facts**.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某些原因你团队中不希望编写和维护Ruby代码，你可能更倾向于使用其他方式，比如允许使用Shell脚本，或者任何编程语言，甚至完全不涉及编程的静态数据。Facter支持这种方式，即**外部事实**。
- en: 'Creating an external fact is similar to the process used for regular custom
    facts, with the following distinctions:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 创建外部事实与常规自定义事实的过程类似，但有以下区别：
- en: External facts are produced by standalone executables or files with static data,
    which the agent must find in `/etc/puppetlabs/facter/facts.d/`
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部事实由独立的可执行文件或带有静态数据的文件生成，代理必须在`/etc/puppetlabs/facter/facts.d/`目录下找到它们。
- en: The data is not just a string value, but an arbitrary number of `key=value`
    pairs instead
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据不仅仅是一个字符串值，而是一个任意数量的 `key=value` 键值对
- en: 'The data need not use the `ini` file notation style; the key/value pairs can
    also be in the YAML or JSON format. The following external facts hold the same
    data:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 数据不必使用 `ini` 文件表示法；键/值对也可以采用 YAML 或 JSON 格式。以下外部事实包含相同的数据：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The facts can be written in the YAML format in the following way:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 事实可以按以下方式以 YAML 格式编写：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the JSON format, facts can be written as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JSON 格式中，事实可以如下编写：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The deployment of the external facts works simply through `file` resources
    in your Puppet manifest:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 外部事实的部署通过你的 Puppet 清单中的 `file` 资源简单地实现：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With newer versions of Puppet and Facter, external facts will be automatically
    synchronized, just as custom facts, if they are found in `facts.d/*` in any module
    (for example, `/etc/puppetlabs/code/environments/production/modules/hello_world/facts.d/hello.sh`).
    This is not only more convenient, but has a large benefit: when Puppet must fetch
    an external fact through a `file` resource instead, as its fact value(s) are not
    available while the catalog is being compiled. The `pluginsync` mechanism, on
    the other hand, makes sure that all synced facts are available before manifest
    compilation starts.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在较新的 Puppet 和 Facter 版本中，外部事实将像自定义事实一样自动同步，只要它们在任何模块的 `facts.d/*` 中被发现（例如，`/etc/puppetlabs/code/environments/production/modules/hello_world/facts.d/hello.sh`）。这不仅更加方便，而且有一个重要的好处：当
    Puppet 必须通过 `file` 资源获取外部事实时，它的事实值在清单编译时不可用。而 `pluginsync` 机制确保所有同步的事实在清单编译开始之前就可用。
- en: 'When facts are not static and cannot be placed in a `txt` or `YAML` file, you
    can make the file executable and add a shebang instead. It will usually be a shell
    script, but the implementation is of no consequence; it is just important that
    properly formatted data is written to the standard output. You can simplify the
    `hello` fact this way, in `/etc/puppetlabs/code/environments/production/modules/hello_world/facts.d/hello.sh`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当事实不是静态的，无法放置在 `txt` 或 `YAML` 文件中时，你可以将文件设为可执行并添加一个 shebang。它通常是一个 shell 脚本，但实现方式无关紧要；重要的是确保正确格式化的数据写入标准输出。你可以通过这种方式简化
    `/etc/puppetlabs/code/environments/production/modules/hello_world/facts.d/hello.sh`
    中的 `hello` 事实：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For executable facts, the `ini` styled `key=value` format is the only supported
    format. YAML or JSON are not eligible in this context.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可执行的事实，`ini` 风格的 `key=value` 格式是唯一支持的格式。在此上下文中，YAML 或 JSON 格式不适用。
- en: Facter 2 introduced structured facts. Structured facts return an array or a
    hash. In older Puppet versions (prior to 3.4), structured facts have to be enabled
    in `puppet.conf` by setting `stringify_facts` to false. This is the default setting
    for Puppet 4.0 and later versions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Facter 2 引入了结构化事实。结构化事实返回一个数组或哈希。在较旧版本的 Puppet（3.4 之前）中，结构化事实必须通过在 `puppet.conf`
    中将 `stringify_facts` 设置为 false 来启用。这是 Puppet 4.0 及以后版本的默认设置。
- en: Goals of Facter
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Facter 的目标
- en: The whole structure and philosophy of Facter serves the goal of allowing for
    platform-agnostic usage and development. The same collection of facts (roughly)
    is available on all supported platforms. This allows Puppet users to keep a coherent
    development style throughout their manifests for all those different systems.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Facter 的整体结构和理念服务于实现平台无关的使用和开发目标。相同的事实集合（大致）在所有支持的平台上都可以使用。这使得 Puppet 用户能够在所有不同系统的清单中保持一致的开发风格。
- en: Facter forms a layer of abstraction over the characteristics of both hardware
    and software. It is an important piece of Puppet's platform-independent architecture.
    Another feature that was mentioned before is the type and provider subsystem.
    Types and providers are explored in greater detail in the following sections.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Facter 对硬件和软件的特征形成了一个抽象层。它是 Puppet 平台无关架构中的一个重要组成部分。之前提到的另一个特性是类型和提供者子系统。类型和提供者将在接下来的章节中详细探讨。
- en: Understanding the type system
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解类型系统
- en: Being one of the cornerstones of the Puppet model, resources were introduced
    quite early in [Chapter 1](8a22dc0e-3fe2-4153-b60e-935b7e6d9f94.xhtml), *Writing
    Your First Manifests*. Remember how each resource represents a piece of state
    on the agent system. It has a resource type, a name (or a title), and a list of
    attributes. An attribute can either be `property` or `parameter`. Between the
    two of them, properties represent distinct pieces of state, and parameters merely
    influence Puppet's actions upon the `property` values.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Puppet 模型的基石之一，资源在[第1章](8a22dc0e-3fe2-4153-b60e-935b7e6d9f94.xhtml) *编写你的第一个清单*中很早就引入了。记住，每个资源表示代理系统上的一部分状态。它有一个资源类型、一个名称（或标题）和一组属性。属性可以是`property`或`parameter`。在这两者之间，属性代表了独立的状态，而参数仅影响
    Puppet 对`property`值的操作。
- en: Let's examine resource types in more detail and understand their inner workings.
    This is not only important when extending Puppet with resource types of your own
    (which will be demonstrated in [Chapter 5](3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml),
    *Combining Classes, Configuration Files, and Extensions into Modules*). It also
    helps you anticipate the action that Puppet will take, given your manifest, and
    get a better understanding of both the master and the agent.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解资源类型，并理解它们的内部工作原理。这不仅在用你自己的资源类型扩展 Puppet 时非常重要（将在[第5章](3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml)
    *将类、配置文件和扩展结合成模块*中演示）。它还帮助你根据清单预测 Puppet 将采取的操作，并更好地理解主节点和代理的工作原理。
- en: 'First, we take a closer look at the operational structure of Puppet, with its
    pieces and phases. The agent performs all its work in discreet **transactions**.
    A transaction is started under any of the following circumstances:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们更深入地了解 Puppet 的操作结构，了解它的组成部分和阶段。代理在独立的**事务**中执行所有工作。事务在以下任何情况下开始：
- en: The background agent process activates and checks in to the master
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背景代理进程激活并向主节点检查。
- en: An agent process is started with the `--onetime` or `--test` options
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动代理进程时使用`--onetime`或`--test`选项。
- en: A local manifest is compiled using `puppet apply`
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`puppet apply`编译本地清单。
- en: 'The transaction always passes several stages. They are as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 事务总是经过多个阶段。它们如下：
- en: Gathering fact values to form the actual catalog request.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集事实值以形成实际的目录请求。
- en: Receiving the compiled catalog from the master.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主节点接收已编译的目录。
- en: Prefetching of current resource states.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预取当前资源状态。
- en: Validation of the catalog's content.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目录内容的验证。
- en: Synchronization of the system with the `property` values from the catalog.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统与目录中的`property`值进行同步。
- en: Facter was explained in the previous section. The resource types become important
    during compilation and then throughout the rest of the agent transaction. The
    master loads all resource types to perform some basic checking; it basically makes
    sure that the types of resources it finds in the manifests do exist and that the
    attribute names fit the respective type.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Facter 在前一节中已有解释。资源类型在编译过程中及之后的代理事务中变得非常重要。主节点加载所有资源类型以执行一些基本检查；它基本上确保在清单中找到的资源类型确实存在，并且属性名称与相应的类型匹配。
- en: The resource type's life cycle on the agent side
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源类型在代理端的生命周期
- en: 'Once the compilation has succeeded, the master hands out the catalog and the
    agent enters the catalog validation phase. Each resource type can define some
    Ruby methods that ensure that the passed values make sense. This happens on two
    levels of granularity: Each attribute can validate its input value, and then the
    resource as a whole can be checked for consistency.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编译成功，主节点会发出目录，代理进入目录验证阶段。每个资源类型可以定义一些 Ruby 方法，以确保传递的值是合理的。这发生在两个层次上：每个属性可以验证其输入值，然后整个资源可以检查一致性。
- en: One example of attribute value validation can be found in the `ssh_authorized_key`
    resource type. A resource of this type fails if its `key` value contains a whitespace
    character because SSH keys cannot comprise multiple strings.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关于属性值验证的例子可以在`ssh_authorized_key`资源类型中找到。如果此类型的资源的`key`值包含空格字符，则验证失败，因为 SSH
    密钥不能包含多个字符串。
- en: 'Validation of whole resources happens with the `cron` type, for example. It
    makes sure that the `time` fields make sense together. The following resource
    would not pass, because special times, such as `midgnight`, cannot be combined
    with numeric fields:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 整个资源的验证是通过`cron`类型进行的，例如。它确保`time`字段能够一起合理地配合。以下资源将无法通过验证，因为特殊时间（如`midnight`）不能与数字字段组合：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Another task during this phase is the transformation of input values to more
    suitable internal representations. The resource type code refers to this as a
    `munge` action. Typical examples of munging are the removal of leading and trailing
    whitespace from string values, or the conversion of array values to an appropriate
    string format-this can be a comma-separated list, but for search paths, the separator
    should be a colon instead. Other kinds of values will use different representations.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段的另一个任务是将输入值转换为更合适的内部表示。资源类型代码称之为`munge`操作。`munge`的典型例子包括去除字符串值的前后空格，或将数组值转换为适当的字符串格式——这可以是以逗号分隔的列表，但对于搜索路径，分隔符应该是冒号。其他类型的值会使用不同的表示方式。
- en: Next up is the prefetching phase. Some resource types allow the agent to create
    an internal list of resource instances that are present on the system. These types
    are referred to as being enumerable types. For example, this is possible (and
    makes sense) for installed packages-Puppet can just invoke the package manager
    to produce the list. For other types, such as `file`, this would not be prudent.
    Creating a list of all reachable paths in the whole filesystem can be arbitrarily
    expensive, depending on the system on which the agent is running.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是预取阶段。某些资源类型允许代理创建系统中存在的资源实例的内部列表。这些类型被称为可枚举类型。例如，对于已安装的软件包，这是可能的（且有意义的）——Puppet可以直接调用包管理器来生成该列表。对于其他类型，如`file`，这就不太合适了。创建整个文件系统中所有可访问路径的列表可能会非常耗费资源，具体取决于代理所在的系统。
- en: 'The prefetching can be simulated by running `puppet resource <resource type>
    <title>` on the command line as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在命令行中运行`puppet resource <resource type> <title>`来模拟预取，如下所示：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Finally, the agent starts walking through its internal graph of interdependent
    resources. Each resource is brought in sync, if necessary. This happens separately
    for each individual property, for the most part.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代理开始遍历其内部的相互依赖资源图。如果有必要，每个资源都会同步。大多数情况下，这是分别针对每个单独的属性进行的。
- en: The `ensure` property, for types that support it, is a notable exception. It
    is expected to manage all other properties on its own; when a resource is changed
    from `absent` to `present` through its `ensure` property (in other words, the
    resource is getting newly created), this action should bring all other properties
    in sync as well.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于支持的类型，`ensure`属性是一个显著的例外。它应该自行管理所有其他属性；当通过`ensure`属性将资源从`absent`更改为`present`时（换句话说，资源正在被创建），此操作还应同步所有其他属性。
- en: There are some notable aspects of the whole agent process. For one, attributes
    are handled independently. Each can define its own methods for the different phases.
    There are quite a number of hooks, which allow a resource type author to add a
    lot of flexibility to the model.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 整个代理过程有一些值得注意的方面。首先，属性是独立处理的。每个属性可以为不同的阶段定义自己的方法。有相当多的钩子，允许资源类型作者为模型添加大量的灵活性。
- en: For aspiring type authors, skimming through the core types can be quite inspirational.
    You will be familiar with many attributes; using them in your manifests and studying
    their hooks will offer quite some insight.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有志成为类型作者的人来说，浏览核心类型可以是非常有启发性的。你会对许多属性很熟悉；在你的清单中使用它们并研究它们的钩子会带来不少见解。
- en: It is also worth noting that the whole validation process is performed by the
    agent, not the master. This is beneficial in terms of performance. The master
    saves a lot of work, which gets distributed to the network of agents (which scales
    with your needs automatically).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，整个验证过程是由代理执行的，而不是主节点。这在性能上是有益的。主节点节省了大量的工作，这些工作被分配到代理网络中（并且网络会根据需求自动扩展）。
- en: Command execution control with providers
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供者的命令执行控制
- en: At the start of this chapter, you learned about Facter and how it works as a
    layer of abstraction over the supported platforms. This unified information base
    is one of Puppet's most important means of achieving its goal of operating system
    independence. Another one is the DSL, of course. Finally, Puppet also needs a
    method to transparently adapt its behavior to the respective platform on which
    each agent runs.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开始时，你了解了 Facter 以及它如何作为支持平台上的一层抽象。这一统一的信息库是 Puppet 实现操作系统独立性的最重要手段之一。另一个手段当然是
    DSL。最后，Puppet 还需要一种方法，能够透明地根据每个代理运行的平台来调整其行为。
- en: In other words, depending on the characteristics of the computing environment,
    the agent needs to switch between different implementations for its resources.
    This is not unlike object oriented programming-the type system provides a unified
    interface, not unlike an abstract base class. The programmer need not worry what
    specific class is being referenced, as long as it correctly implements all the
    required methods. In this analogy, Puppet's providers are the concrete classes
    that implement the abstract interface.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，根据计算环境的特性，代理需要在不同的资源实现之间切换。这与面向对象编程类似——类型系统提供了一个统一的接口，类似于抽象基类。程序员不必担心具体引用的是哪个类，只要它正确实现了所有必需的方法。在这个类比中，Puppet
    的提供者就像是实现了抽象接口的具体类。
- en: For a practical example, look at package management. Different flavors of Unix-like
    operating systems have their own implementation. The most prevalent Puppet platforms
    use `apt` and `yum`, respectively, but can (and sometimes must) also manage their
    packages through `dpkg` and `rpm`. Other platforms use tools such as `emerge`,
    `zypper`, `fink`, and a slew of other things. There are even packages that exist
    apart from the operating system software base, handled through `gem`, `pip`, and
    other language-specific package management tools. For each of these management
    tools, there is a provider for the package type.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 举个实际的例子，看看软件包管理。不同版本的类 Unix 操作系统有各自的实现。最常见的 Puppet 平台分别使用 `apt` 和 `yum`，但也可以（有时必须）通过
    `dpkg` 和 `rpm` 来管理它们的软件包。其他平台则使用像 `emerge`、`zypper`、`fink` 等工具，甚至还有很多其他工具。甚至有一些软件包，它们存在于操作系统软件库之外，由
    `gem`、`pip` 等特定语言的软件包管理工具处理。每个管理工具都有一个对应的 package 类型提供者。
- en: Many of these tools allow the same set of operations-installing and uninstalling
    a package, and updating a package to a specific version. However, the latter is
    not universally possible. For example, `dpkg` can only ever install the local
    package that is specified on the command line, with no other version to choose.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具中的许多允许执行相同的一组操作——安装和卸载软件包，以及将软件包更新到特定版本。然而，后者并不是普遍可行的。例如，`dpkg` 只能安装命令行中指定的本地软件包，无法选择其他版本。
- en: There are also some distinct features that are unique to specific tools, or
    are supported by only a few. Some management systems can hold packages at specific
    versions. Some use different states for uninstalled versus purged packages. Some
    have a concept of virtual packages. The list of examples can go on and on.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一些独特的功能，这些功能是特定工具的专有，或者只有少数工具支持。某些管理系统可以将软件包锁定在特定版本。某些系统使用不同的状态来区分未安装的和已清除的软件包。某些系统有虚拟软件包的概念。这样的例子还可以继续列举下去。
- en: 'Because of this potential diversity (which is not limited to package management
    systems), Puppet providers can opt for **features**. The set of features is resource-type
    specific. All providers for a type can support one or more of the same group of
    features. For the `package` type, there are features such as `versionable`, `purgeable`,
    `holdable`, and so forth. You can set `ensure => purged` on any package resource
    as so:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正因为这种潜在的多样性（不仅限于软件包管理系统），Puppet 提供者可以选择 **功能**。这些功能集是特定于资源类型的。所有同类型的提供者可以支持同一组功能中的一个或多个。对于
    `package` 类型，功能包括 `versionable`、`purgeable`、`holdable` 等等。你可以像下面这样为任何软件包资源设置 `ensure
    => purged`：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: However, if you are managing the `HAproxy` package through `rpm`, Puppet will
    fail to make any sense of it because `rpm` has no notion of a `purged` state,
    and therefore, the `purgeable` feature is missing from the `rpm` provider. Trying
    to use an unsupported feature will usually produce an error message. Some attributes,
    such as `install_options`, might just result in a warning by Puppet instead.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: The official documentation on the Puppet Labs website holds a complete list
    of the core resource types and all their built-in providers, along with the respective
    feature matrices. It is very easy to find suitable providers and their capabilities.
    The documentation can be found at [https://docs.puppetlabs.com/references/latest/type.html.](https://docs.puppetlabs.com/references/latest/type.html)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Resource types with generic providers
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some resource types that use no providers, but they are rare among
    the core types. Most of the interesting management tasks that Puppet makes easy
    just work differently among operating systems, and providers enable this in a
    most elegant fashion.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Even for straightforward tasks that are the same on all platforms, there might
    be a provider. For example, there is a `host` type to manage entries in the `/etc/hosts`
    file. Its syntax is universal, so the code can technically just be implemented
    in the type. However, there are actual abstract base classes for certain kinds
    of providers in the Puppet code base. One of them makes it very easy to build
    providers that edit files, if those files consist of single-line records with
    ordered fields. Therefore, it makes sense to implement a provider for the `host`
    type and base it on this provider class.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'For the curious, this is what a host resource looks like:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Summarizing types and providers
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Puppet's resource types and their providers work together to form a solid abstraction
    layer over software configuration details. The type system is an extendable basis
    for Puppet's powerful DSL. It forms an elaborate interface for the polymorphous
    provider layer.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The providers flexibly implement the actual management actions that Puppet is
    supposed to perform. They map the necessary synchronization steps to commands
    and system interactions. Many providers cannot satisfy every nuance that the resource
    type models. The feature system takes care of these disparities in a transparent
    fashion.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reading this far, you might have gotten the impression that this chapter is
    a rather odd mix of topics. While types and providers do belong closely together,
    the whole introduction to Facter might seem out of place in this context. However,
    this is deceptive; facts do play a vital role in the type/provider structure.
    They are essential for Puppet to make good choices between the providers.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example from the *Extending Facter with custom facts* section
    once more. It was about `fstab` entries and the difference of Solaris, which uses
    `/etc/vfstab` instead of `/etc/fstab`. That section suggested a manifest that
    adapts according to a fact value. As you have learned, Puppet has a resource type
    to manage `fstab` content: the `mount` type. However, for the small deviation
    of a different file path, there is no dedicated `mount` provider for Solaris.
    There is actually just one provider for all platforms, but on Solaris, it behaves
    differently. It does this by resolving Facter''s `os[''family'']` value. The following
    code example was adapted from the actual provider code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再来看一个来自*扩展 Facter 自定义事实*部分的例子。内容涉及`fstab`条目和Solaris的区别，Solaris使用`/etc/vfstab`而非`/etc/fstab`。该部分建议使用一个根据事实值自适应的清单。如你所学，Puppet有一个资源类型来管理`fstab`内容：`mount`类型。然而，对于路径有所不同的小差异，Solaris并没有专门的`mount`提供者。实际上，所有平台只有一个提供者，但在Solaris上，它的行为有所不同。它通过解析Facter的`os['family']`值来实现这一点。以下代码示例来自实际的提供者代码：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In other cases, however, Puppet should use thoroughly different providers on
    different platforms. Package management is a classic example. On a Red Hat-like
    platform, you will want Puppet to use the `yum` provider in virtually all cases.
    It can be sensible to use `rpm`, and even `apt` might be available. However, if
    you tell Puppet to make sure a package is installed, you expect it to install
    it using `yum`, if necessary.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在其他情况下，Puppet应在不同的平台上使用完全不同的提供者。包管理就是一个经典的例子。在类似Red Hat的平台上，你几乎希望Puppet在所有情况下都使用`yum`提供者。也可以使用`rpm`，甚至`apt`可能也可用。然而，如果你告诉Puppet确保安装某个包，你期望它在必要时使用`yum`来安装该包。
- en: 'This is obviously a common theme. Certain management tasks need to be performed
    in different environments, with very different toolchains. In such cases, it is
    quite clear which provider would be best suited. To make this happen, a provider
    can declare itself the default if a condition is met. In the case of `yum`, it
    is the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是一个常见主题。某些管理任务需要在不同的环境中执行，且使用的工具链完全不同。在这种情况下，显而易见哪个提供者最适合。为了实现这一点，如果条件满足，提供者可以声明自己是默认的。对于`yum`来说，条件如下：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The conditions are based around fact values. If the `operatingsystem` value
    for a given agent is among the listed, `yum` will consider itself the default
    package provider.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些条件基于事实值。如果某个特定代理的`operatingsystem`值在列出的范围内，`yum`会认为自己是默认的包管理提供者。
- en: The operating system and os family facts are the most popular choices for such
    queries in providers, but any fact is eligible.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统和操作系统家族的事实是提供者中最常见的查询选项，但任何事实都是可用的。
- en: 'In addition to marking themselves as default, there is more filtering of providers
    that rely on fact values. Providers can also confine themselves to certain combinations
    of values. For example, the `yum` alternative, `zypper`, confines itself to SUSE
    Linux distributions:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标记自己为默认外，还有更多依赖事实值的提供者过滤。提供者还可以限制自己只能在某些值的组合下使用。例如，`yum`的替代者`zypper`限制自己只适用于SUSE
    Linux发行版：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This provider method works just as the `confine` method in Facter, which was
    discussed earlier in this chapter. The provider will not even be seen as valid
    if the respective facts on the agent machine have none of the white-listed values.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这种提供者方法与本章前面讨论的Facter中的`confine`方法相同。如果代理机器上的相应事实没有任何白名单值，提供者甚至不会被视为有效。
- en: 'If you find yourself looking through code for some core providers, you will
    notice confinement (and even the declaration of default providers) on feature
    values, although there is no Facter fact of that name. These features are not
    related to provider features either. They are from another layer of introspection
    similar to Facter, but hardcoded into the Puppet agent. These agent features are
    a number of flags that identify some system properties that need not be made available
    to manifests in the form of facts. For example, the `posix` provider for the `exec`
    type becomes the default in the presence of the corresponding feature: `defaultfor
    :feature => :posix`'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看核心提供者的代码，会发现限制（甚至默认提供者的声明）基于功能值，尽管没有该名称的Facter事实。这些功能与提供者功能无关，它们来自与Facter类似的另一层反射机制，但它们是硬编码到Puppet代理中的。这些代理功能是一些标志，用于标识某些系统属性，这些属性无需以事实的形式向清单提供。例如，`exec`类型的`posix`提供者在存在相应功能时成为默认提供者：`defaultfor
    :feature => :posix`
- en: 'You will find that some providers forgo the `confine` method altogether, as
    it is not mandatory for correct agent operation. Puppet will also identify unsuitable
    providers when looking for their necessary operating system commands. For example,
    the `pw` provider for certain BSD flavors does not bother with a `confine` statement.
    It only declares its one required command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现某些提供者完全放弃了 `confine` 方法，因为它并非正确操作代理所必需的。Puppet 在查找所需的操作系统命令时，也会识别不合适的提供者。例如，某些
    BSD 版本的 `pw` 提供者不会使用 `confine` 声明。它只声明其一个必需的命令：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Agents that find no `pw` binary in their search path will not try and use this
    provider at all.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索路径中找不到 `pw` 二进制文件的代理将完全不尝试使用此提供者。
- en: This concludes the little tour of the inner workings of types and providers
    with the help of Facter. For a complete example of building a provider for a type,
    and using the internal tools that you have now learned about, you can refer to
    [Chapter 5](3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml), *Combining Classes, Configuration
    Files, and Extensions into Modules*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是通过 Facter 探索类型和提供者内部工作原理的简短介绍。有关构建类型提供者的完整示例，并使用您现在已学习的内部工具，您可以参考[第 5 章](3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml)，*将类、配置文件和扩展结合成模块*。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Puppet gathers information about all agent systems using Facter. The information
    base consists of a large number of independent bits, called facts. Manifests can
    query the values of those facts to adapt to the respective agents that trigger
    their compilation. Puppet also uses facts to choose among providers, the work
    horses that make the abstract resource types functional across the wide range
    of supported platforms.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 使用 Facter 收集所有代理系统的信息。信息库由大量独立的部分组成，称为事实（facts）。清单可以查询这些事实的值，以适应触发其编译的相应代理。Puppet
    还使用事实来选择提供者，这些工作马使得抽象的资源类型在广泛支持的平台上可用。
- en: The resource types not only completely define the interface that Puppet exposes
    in the DSL, they also take care of all the validation of input values, transformations
    that must be performed before handing values to the providers, and other related
    tasks.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 资源类型不仅完全定义了 Puppet 在 DSL 中暴露的接口，它们还负责所有输入值的验证、在将值交给提供者之前必须执行的转换，以及其他相关任务。
- en: The providers encapsulate all knowledge of actual operating systems and their
    respective toolchains. They implement the functionality that the resource types
    describe. The Puppet model's configurations apply to platforms, which vary from
    one another, so not every facet of every resource type can make sense for all
    agents. By exposing only the supported features, a provider can express such limitations.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者封装了实际操作系统及其相应工具链的所有知识。它们实现了资源类型所描述的功能。Puppet 模型的配置适用于不同的平台，而平台之间有所不同，因此并非每个资源类型的每个方面都适用于所有代理。通过仅暴露受支持的特性，提供者可以表达此类限制。
- en: After this in-depth look at the internal details, let's tackle more practical
    concerns again. The following chapters will cover the tools needed to build complex
    and advanced manifests of all scales.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解内部细节后，我们将再次关注更实际的问题。接下来的章节将涵盖构建各类规模复杂和高级清单所需的工具。
