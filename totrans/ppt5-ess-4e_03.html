<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">A Peek into the Ruby Part of Puppet - Facts, Types, and Providers</h1>
                </header>
            
            <article>
                
<p>So far in this book, you have primarily done practical things - writing manifests, setting up a master, assigning agents, signing certificates, and so forth. Before you are introduced to the missing language concepts that you will need to use Puppet effectively for bigger projects, there is some background that we should cover. Don't worry, it won't be all dry theory - most of the important parts of Puppet are relevant to your daily business.</p>
<p>The topics of this chapter have been hinted at earlier; <a href="8a22dc0e-3fe2-4153-b60e-935b7e6d9f94.xhtml"><span class="ChapterrefPACKT">Chapter 1</span></a>, <em>Writing Your First Manifests</em>, contained a brief description of the type and provider. This and some adjacent topics will be thoroughly explored in the sections collecting system information with Facter, understanding the type system, and command execution control with providers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Putting it all together - collecting system information with Facter</h1>
                </header>
            
            <article>
                
<p>Configuration management is quite a dynamic problem. In other words, the systems that need configuration are mostly moving targets. In some situations, system administrators or operators get lucky and work with large quantities of 100 percent uniform hardware and software. In most cases, however, the landscape of servers and other computing nodes is rather heterogeneous, at least in subtle ways. Even in unified networks, there are likely multiple generations of machines or operating systems, with smaller or larger differences required for their respective configurations.</p>
<p>For example, a common task for Puppet is to handle the configuration of system monitoring. Your business logic will likely dictate warning thresholds for gauges such as the system load value. However, those thresholds can rarely be static. On a two-processor virtual machine, a system load of <kbd>10</kbd> represents a crippling overload, while the same value can be absolutely acceptable for a busy DBMS server that has cutting edge hardware of the largest dimensions.</p>
<p>Another important factor can be software platforms. Your infrastructure might span multiple distributions of Linux or alternate operating systems, such as BSD, Solaris, or Windows, each with different ways of handling certain scenarios. Imagine, for example, that you want Puppet to manage some content from the <kbd>fstab</kbd> file. On your rare Solaris system, you would have to make sure that Puppet targets the <kbd>/etc/vfstab</kbd> file instead of <kbd>/etc/fstab</kbd>.</p>
<p>It is usually not a good idea to interact directly with the <kbd>fstab</kbd> file in your manifest. This example will be rounded off in the section concerning providers.</p>
<p>Puppet strives to present you with a unified way of managing all your infrastructure. It therefore needs a means to allow your manifests to adapt to different kinds of circumstances on the agent machines. This includes their operating system, hardware layout, and many other details. Keep in mind that, generally, the manifests have to be compiled on the master machine.</p>
<p>There are several conceivable ways to implement a solution for this particular problem. A direct approach would be to use a language construct that allows the master to send a piece of shell script (or other code) to the agent and receive its output in return.</p>
<p class="mce-root">The following is pseudocode; however, there are no back tick expressions in the Puppet DSL:</p>
<pre>if `grep -c ^processor /proc/cpuinfo` &gt; 2 {<br/>  $load_warning = 4<br/>}<br/>else {<br/>  $load_warning = 2<br/>} </pre>
<p>This solution would be powerful but expensive. The master would need to call back to the agent whenever the compilation process encountered such an expression. Writing manifests that were able to cope with such a command returning an error code would be strenuous, and Puppet would likely end up resembling a quirky scripting engine.</p>
<p>Puppet uses a different approach. It relies on a secondary system called Facter, which has the sole purpose of examining the machine on which it is run. It serves a list of well-known variable names and values, all according to the system on which it runs. For example, an actual Puppet manifest that needs to form a condition upon the number of processors on the agent will use this expression:</p>
<pre>if $::processors['count'] &gt; 4 { … } </pre>
<p>Facter's variables are called <strong>facts</strong>, and <kbd>processors</kbd> is one such fact. With Facter version 3 or later, most data will be gathered and presented as structured facts (JSON). In the example, we accessed the <kbd>'count'</kbd> element from 'processors' data. The older key-value pairs are still available. The fact values are gathered by the agent and sent to the master, who will use these facts to compile a catalog. All fact names are available in the manifests as variables.</p>
<div class="packt_infobox">Facts are also available to manifests that are used with <kbd>puppet apply</kbd>, of course. You can test this very simply with the following:<br/>
<kbd>puppet apply -e 'notify { "I am ${::networking['fqdn']} and have ${::processors['count]} CPUs": }'</kbd></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing and using fact values</h1>
                </header>
            
            <article>
                
<p>You have already seen the use of the <kbd>processors</kbd> fact in an example. In the manifest, each fact value is available as a global variable value. That is why you can just use the <kbd>::processors</kbd> expression where you need it.</p>
<p>You will often see conventional uses such as <kbd>$::processors['count']</kbd> or <kbd>$::networking[‘ip’]</kbd>. Prefixing the fact name with double colons is highly recommended. The official style guide at <a href="https://docs.puppetlabs.com/guides/style_guide.html#namespacing-variables">https://docs.puppetlabs.com/guides/style_guide.html#namespacing-variables</a> recommends this. The prefix indicates that you are referring to a variable delivered from Facter. Facter variables are put into the Puppet master's top scope.</p>
<p>Some helpful facts have already been mentioned. The <kbd>processors</kbd> fact might play a role for your configuration. When configuring some services, you will want to use the machine's <kbd>networking ['ip']</kbd> value in a configuration file or as an argument value:</p>
<pre>file { '/etc/mysql/conf.d/bind-address':<br/>  ensure  =&gt; 'file',<br/>  mode    =&gt; '0644',<br/>  content =&gt; "[mysqld]\nbind-address=${::networking['ip']}\n",<br/>}</pre>
<p>Apart from the hostname, your manifest can also make use of the <strong>Fully Qualified Domain Name</strong> (<strong>FQDN</strong>) of the agent machine.</p>
<p>The agent will use the value of its <kbd>fqdn</kbd> fact as the name of its certificate (<kbd>clientcert</kbd>) by default. The master receives both these values. Note that the agent can override the <kbd>fqdn</kbd> value of any name, whereas the <kbd>clientcert</kbd> value is tied to the signed certificate that the agent uses. Sometimes, you will want the master to pass sensitive information to individual nodes. The manifest must identify the agent by its <kbd>clientcert</kbd> fact and never use <kbd>fqdn</kbd> or <kbd>hostname</kbd> instead, for the reason mentioned. An example is shown in the following code:</p>
<pre>file { '/etc/my-secret': 
  ensure =&gt; 'file', 
  mode   =&gt; '0600', 
  owner  =&gt; 'root', 
  source =&gt; <br/>  "puppet:///modules/secrets/${::clientcert}/key", 
} </pre>
<p>There is a whole group of facts that are used to describe the operating system. Each fact is useful in different situations. The <kbd>os[‘name’]</kbd> fact takes values such as <kbd>Debian</kbd> or <kbd>CentOS</kbd>:</p>
<pre>if $::os['name'] != 'Ubuntu' {<br/>  package { 'avahi-daemon':<br/>    ensure =&gt; absent<br/>  }<br/>}</pre>
<p>If your manifest will behave identically on RHEL, CentOS, and Fedora (but not on Debian and Ubuntu), you should make use of the <kbd>osfamily</kbd> fact instead:</p>
<pre>if $::os['family'] == 'RedHat' {<br/>  $kernel_package = 'kernel'<br/>}</pre>
<p>The <kbd>os[‘release’][‘full’]</kbd> fact allows you to tailor your manifests to the different versions of your OS:</p>
<pre>if $::so['name'] == 'Debian' {<br/>  if versioncmp($::os['release']['full'], '7.0') &gt;= 0 {<br/>    $ssh_ecdsa_support = true<br/>  }<br/>}</pre>
<p>Facts such as mac address, the different SSH host keys, fingerprints, and others make it easy to use Puppet for keeping an inventory of your hardware. There are a slew of other useful facts. Of course, the collection will not suit every possible need of every user out there. That is why Facter comes readily extendible.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extending Facter with custom facts</h1>
                </header>
            
            <article>
                
<p>Technically, nothing is stopping you from adding your own fact code right next to the core facts, either by maintaining your own Facter package, or even by deploying the Ruby code files to your agents directly through Puppet management. However, Puppet offers a much more convenient alternative in the form of custom facts.</p>
<p>We have still not covered Puppet modules yet. They will be thoroughly introduced in <a href="3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>Combining Classes, Configuration Files, and Extensions into Modules</em>. For now, just create a Ruby file at <kbd>/etc/puppetlabs/code/environments/production/modules/hello_world/lib/facter/hello.rb</kbd> on the master machine. Puppet will recognize this as a custom fact of the name, <kbd>hello</kbd>. (For Puppet 3 or older versions, the path should be <kbd>/etc/puppet/modules/hello_world/lib/facter/hello.rb.</kbd>)</p>
<p>The inner workings of Facter are very straightforward and goal oriented. There is one block of Ruby code for each fact, and the return value of the block becomes the fact value. Many facts are self-sufficient, but others will rely on the values of one or more basic facts. For example, the method to determine the IP address(es) of the local machine is highly dependent upon the operating system.</p>
<p>The <kbd>hello</kbd> fact is very simple, though:</p>
<pre>Facter.add(:hello) do<br/>  setcode { "Hello, world!" }<br/>end</pre>
<p>The return value of the <kbd>setcode</kbd> block is the string <kbd>Hello, world!</kbd>, and you can use this fact as <kbd>$::hello</kbd> in a Puppet manifest.</p>
<p>Before Facter version 2.0, each fact had a string value. If a code block returns another value, such as an array or hash, Facter 1.x will convert it to a string. The result is not useful in many cases. For this historic reason, there are facts such as <kbd>ipaddress_eth0</kbd> and <kbd>ipaddress_lo</kbd> instead of (or in addition to) a proper hash structure with interface names and addresses.</p>
<p>It is important for the <kbd>pluginsync</kbd> option to be enabled on the agent side. This has been the default for a long time and should not require any customization. The agent will synchronize all custom facts whenever checking in to the master. They are permanently available on the agent machine after that. You can then retrieve the <kbd>hello</kbd> fact from the command line using the following line:</p>
<pre><strong># puppet facts | grep hello </strong></pre>
<p>Just by invoking the following command without an argument, you can request a list of all fact names and values.</p>
<pre><strong># puppet facts</strong></pre>
<p>There is also a <kbd>facter</kbd> command. It does roughly the same as puppet facts, but will only show built-in facts, not your custom facts.</p>
<div class="packt_tip">In Puppet 3 and earlier, there was no puppet facts subcommand. You had to rely on the Facter CLI (from Facter version 2.x or older) and call <kbd>facter -p</kbd>, to include custom facts. Some versions of Facter 3.0 removed this parameter; newer versions support it again.</div>
<p>This book will not cover all aspects of Facter's API, but there is one facility that is quite essential. Many of your custom facts will only be useful on Unix-like systems, and others will only be useful on your Windows boxes. You can retrieve such facts using a construct the same as the following:</p>
<pre>if Facter.value(:kernel) != "windows"<br/>  nil<br/>else<br/>  # actual fact code here<br/>end</pre>
<p>This would be quite tedious and repetitive, though. Instead, you can invoke the <kbd>confine</kbd> method within the <kbd>Facter.add(name) { ... }</kbd> block:</p>
<pre>Facter.add(:msvs_version) do<br/>  confine :kernel =&gt; :windows<br/>  setcode do<br/>    # …<br/>  end<br/>end</pre>
<p>You can confine a fact to several alternative values as well:</p>
<pre>confine :kernel =&gt; [ :linux, :sunos ]<strong> </strong></pre>
<p>Finally, if a fact does make sense in different circumstances, but requires drastically different code in each respective case, you can add the same fact several times, each with a different set of <kbd>confine</kbd> values. Core facts such as <kbd>ipaddress</kbd> use this often:</p>
<pre>Facter.add(:ipaddress) do<br/>  confine :kernel =&gt; :linux<br/>  …<br/>end<br/>Facter.add(:ipaddress) do<br/>  confine :kernel =&gt; %w{FreeBSD OpenBSD Darwin DragonFly}<br/>  …<br/>end<br/>… </pre>
<p>You can confine facts based on any combination of other facts, not just <kbd>kernel</kbd>. It is a very popular choice though. The <kbd>operatingsystem</kbd> or <kbd>osfamily</kbd> facts can be more appropriate in certain situations. Technically, you can even confine some of your facts to certain <kbd>processorcount</kbd> values, and so forth.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Simplifying things using external facts</h1>
                </header>
            
            <article>
                
<p>If writing and maintaining Ruby code is not desirable in your team for any reason, you might prefer to use an alternative that allows shell scripts, or really any kind of programming language, or even static data with no programming involved at all. Facter allows this in the form of <strong>external facts</strong>.</p>
<p>Creating an external fact is similar to the process used for regular custom facts, with the following distinctions:</p>
<ul>
<li>External facts are produced by standalone executables or files with static data, which the agent must find in <kbd>/etc/puppetlabs/facter/facts.d/</kbd></li>
<li>The data is not just a string value, but an arbitrary number of <kbd>key=value</kbd> pairs instead</li>
</ul>
<p>The data need not use the <kbd>ini</kbd> file notation style; the key/value pairs can also be in the YAML or JSON format. The following external facts hold the same data:</p>
<pre># site-facts.txt<br/>workgroup='CT4Site2'<br/>domain_psk='nm56DxLp%' </pre>
<p>The facts can be written in the YAML format in the following way:</p>
<pre># site-facts.yaml<br/>workgroup: 'CT4Site2'<br/>domain_psk: 'nm56DxLp%'</pre>
<p>In the JSON format, facts can be written as follows:</p>
<pre># site-facts.json<br/>{ 'workgroup': 'CT4Site2', 'domain_psk': 'nm56DxLp%' } </pre>
<p>The deployment of the external facts works simply through <kbd>file</kbd> resources in your Puppet manifest:</p>
<pre>file { '/etc/puppetlabs/facter/facts.d/site-facts.yaml':<br/>  ensure =&gt; 'file',<br/>  source =&gt; 'puppet:///…',<br/>}   </pre>
<div class="packt_tip">With newer versions of Puppet and Facter, external facts will be automatically synchronized, just as custom facts, if they are found in <kbd>facts.d/*</kbd> in any module (for example, <kbd>/etc/puppetlabs/code/environments/production/modules/hello_world/facts.d/hello.sh</kbd>). This is not only more convenient, but has a large benefit: when Puppet must fetch an external fact through a <kbd>file</kbd> resource instead, as its fact value(s) are not available while the catalog is being compiled. The <kbd>pluginsync</kbd> mechanism, on the other hand, makes sure that all synced facts are available before manifest compilation starts.</div>
<p>When facts are not static and cannot be placed in a <kbd>txt</kbd> or <kbd>YAML</kbd> file, you can make the file executable and add a shebang instead. It will usually be a shell script, but the implementation is of no consequence; it is just important that properly formatted data is written to the standard output. You can simplify the <kbd>hello</kbd> fact this way, in <kbd>/etc/puppetlabs/code/environments/production/modules/hello_world/facts.d/hello.sh</kbd>:</p>
<pre class="mce-root">#!/bin/sh<br/>echo hello=Hello, world\!</pre>
<p>For executable facts, the <kbd>ini</kbd> styled <kbd>key=value</kbd> format is the only supported format. YAML or JSON are not eligible in this context.</p>
<div class="packt_tip">Facter 2 introduced structured facts. Structured facts return an array or a hash. In older Puppet versions (prior to 3.4), structured facts have to be enabled in <kbd>puppet.conf</kbd> by setting <kbd>stringify_facts</kbd> to false. This is the default setting for Puppet 4.0 and later versions.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Goals of Facter</h1>
                </header>
            
            <article>
                
<p>The whole structure and philosophy of Facter serves the goal of allowing for platform-agnostic usage and development. The same collection of facts (roughly) is available on all supported platforms. This allows Puppet users to keep a coherent development style throughout their manifests for all those different systems.</p>
<p>Facter forms a layer of abstraction over the characteristics of both hardware and software. It is an important piece of Puppet's platform-independent architecture. Another feature that was mentioned before is the type and provider subsystem. Types and providers are explored in greater detail in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the type system</h1>
                </header>
            
            <article>
                
<p>Being one of the cornerstones of the Puppet model, resources were introduced quite early in <a href="8a22dc0e-3fe2-4153-b60e-935b7e6d9f94.xhtml"><span class="ChapterrefPACKT">Chapter 1</span></a>, <em>Writing Your First Manifests</em>. Remember how each resource represents a piece of state on the agent system. It has a resource type, a name (or a title), and a list of attributes. An attribute can either be <kbd>property</kbd> or <kbd>parameter</kbd>. Between the two of them, properties represent distinct pieces of state, and parameters merely influence Puppet's actions upon the <kbd>property</kbd> values.</p>
<p>Let's examine resource types in more detail and understand their inner workings. This is not only important when extending Puppet with resource types of your own (which will be demonstrated in <a href="3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>Combining Classes, Configuration Files, and Extensions into Modules</em>). It also helps you anticipate the action that Puppet will take, given your manifest, and get a better understanding of both the master and the agent.</p>
<p>First, we take a closer look at the operational structure of Puppet, with its pieces and phases. The agent performs all its work in discreet <strong>transactions</strong>. A transaction is started under any of the following circumstances:</p>
<ul>
<li>The background agent process activates and checks in to the master</li>
<li>An agent process is started with the <kbd>--onetime</kbd> or <kbd>--test</kbd> options</li>
<li>A local manifest is compiled using <kbd>puppet apply</kbd></li>
</ul>
<p>The transaction always passes several stages. They are as follows:</p>
<ol>
<li>Gathering fact values to form the actual catalog request.</li>
<li>Receiving the compiled catalog from the master.</li>
<li>Prefetching of current resource states.</li>
<li>Validation of the catalog's content.</li>
<li>Synchronization of the system with the <kbd>property</kbd> values from the catalog.</li>
</ol>
<p>Facter was explained in the previous section. The resource types become important during compilation and then throughout the rest of the agent transaction. The master loads all resource types to perform some basic checking; it basically makes sure that the types of resources it finds in the manifests do exist and that the attribute names fit the respective type.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The resource type's life cycle on the agent side</h1>
                </header>
            
            <article>
                
<p>Once the compilation has succeeded, the master hands out the catalog and the agent enters the catalog validation phase. Each resource type can define some Ruby methods that ensure that the passed values make sense. This happens on two levels of granularity: Each attribute can validate its input value, and then the resource as a whole can be checked for consistency.</p>
<p>One example of attribute value validation can be found in the <kbd>ssh_authorized_key</kbd> resource type. A resource of this type fails if its <kbd>key</kbd> value contains a whitespace character because SSH keys cannot comprise multiple strings.</p>
<p>Validation of whole resources happens with the <kbd>cron</kbd> type, for example. It makes sure that the <kbd>time</kbd> fields make sense together. The following resource would not pass, because special times, such as <kbd>midgnight</kbd>, cannot be combined with numeric fields:</p>
<pre>cron { 'invalid-resource':<br/>  command =&gt; 'apt-get update',<br/>  special =&gt; 'midnight',<br/>  weekday =&gt; [ '2', '5' ],<br/>}</pre>
<p>Another task during this phase is the transformation of input values to more suitable internal representations. The resource type code refers to this as a <kbd>munge</kbd> action. Typical examples of munging are the removal of leading and trailing whitespace from string values, or the conversion of array values to an appropriate string format-this can be a comma-separated list, but for search paths, the separator should be a colon instead. Other kinds of values will use different representations.</p>
<p>Next up is the prefetching phase. Some resource types allow the agent to create an internal list of resource instances that are present on the system. These types are referred to as being enumerable types. For example, this is possible (and makes sense) for installed packages-Puppet can just invoke the package manager to produce the list. For other types, such as <kbd>file</kbd>, this would not be prudent. Creating a list of all reachable paths in the whole filesystem can be arbitrarily expensive, depending on the system on which the agent is running.</p>
<div class="packt_tip">The prefetching can be simulated by running <kbd>puppet resource &lt;resource type&gt; &lt;title&gt;</kbd> on the command line as follows:</div>
<pre># puppet resource user root<br/>   user { 'root':<br/>     ensure           =&gt; 'present',<br/>     comment          =&gt; 'root',<br/>     gid              =&gt; '0',<br/>     home             =&gt; '/root',<br/>     password         =&gt; '$6$17[...]o.rLdk/9MZANEGt/',<br/>     password_max_age =&gt; '99999',<br/>     password_min_age =&gt; '0',<br/>     shell            =&gt; '/bin/bash',<br/>     uid              =&gt; '0',<br/>  }</pre>
<p>Finally, the agent starts walking through its internal graph of interdependent resources. Each resource is brought in sync, if necessary. This happens separately for each individual property, for the most part.</p>
<p>The <kbd>ensure</kbd> property, for types that support it, is a notable exception. It is expected to manage all other properties on its own; when a resource is changed from <kbd>absent</kbd> to <kbd>present</kbd> through its <kbd>ensure</kbd> property (in other words, the resource is getting newly created), this action should bring all other properties in sync as well.</p>
<p>There are some notable aspects of the whole agent process. For one, attributes are handled independently. Each can define its own methods for the different phases. There are quite a number of hooks, which allow a resource type author to add a lot of flexibility to the model.</p>
<p>For aspiring type authors, skimming through the core types can be quite inspirational. You will be familiar with many attributes; using them in your manifests and studying their hooks will offer quite some insight.</p>
<p>It is also worth noting that the whole validation process is performed by the agent, not the master. This is beneficial in terms of performance. The master saves a lot of work, which gets distributed to the network of agents (which scales with your needs automatically).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Command execution control with providers</h1>
                </header>
            
            <article>
                
<p>At the start of this chapter, you learned about Facter and how it works as a layer of abstraction over the supported platforms. This unified information base is one of Puppet's most important means of achieving its goal of operating system independence. Another one is the DSL, of course. Finally, Puppet also needs a method to transparently adapt its behavior to the respective platform on which each agent runs.</p>
<p>In other words, depending on the characteristics of the computing environment, the agent needs to switch between different implementations for its resources. This is not unlike object oriented programming-the type system provides a unified interface, not unlike an abstract base class. The programmer need not worry what specific class is being referenced, as long as it correctly implements all the required methods. In this analogy, Puppet's providers are the concrete classes that implement the abstract interface.</p>
<p>For a practical example, look at package management. Different flavors of Unix-like operating systems have their own implementation. The most prevalent Puppet platforms use <kbd>apt</kbd> and <kbd>yum</kbd>, respectively, but can (and sometimes must) also manage their packages through <kbd>dpkg</kbd> and <kbd>rpm</kbd>. Other platforms use tools such as <kbd>emerge</kbd>, <kbd>zypper</kbd>, <kbd>fink</kbd>, and a slew of other things. There are even packages that exist apart from the operating system software base, handled through <kbd>gem</kbd>, <kbd>pip</kbd>, and other language-specific package management tools. For each of these management tools, there is a provider for the package type.</p>
<p>Many of these tools allow the same set of operations-installing and uninstalling a package, and updating a package to a specific version. However, the latter is not universally possible. For example, <kbd>dpkg</kbd> can only ever install the local package that is specified on the command line, with no other version to choose.</p>
<p>There are also some distinct features that are unique to specific tools, or are supported by only a few. Some management systems can hold packages at specific versions. Some use different states for uninstalled versus purged packages. Some have a concept of virtual packages. The list of examples can go on and on.</p>
<p>Because of this potential diversity (which is not limited to package management systems), Puppet providers can opt for <strong>features</strong>. The set of features is resource-type specific. All providers for a type can support one or more of the same group of features. For the <kbd>package</kbd> type, there are features such as <kbd>versionable</kbd>, <kbd>purgeable</kbd>, <kbd>holdable</kbd>, and so forth. You can set <kbd>ensure =&gt; purged</kbd> on any package resource as so:</p>
<pre>package { 'haproxy':<br/>  ensure =&gt; 'purged'<br/>} </pre>
<p>However, if you are managing the <kbd>HAproxy</kbd> package through <kbd>rpm</kbd>, Puppet will fail to make any sense of it because <kbd>rpm</kbd> has no notion of a <kbd>purged</kbd> state, and therefore, the <kbd>purgeable</kbd> feature is missing from the <kbd>rpm</kbd> provider. Trying to use an unsupported feature will usually produce an error message. Some attributes, such as <kbd>install_options</kbd>, might just result in a warning by Puppet instead.</p>
<div class="packt_tip">The official documentation on the Puppet Labs website holds a complete list of the core resource types and all their built-in providers, along with the respective feature matrices. It is very easy to find suitable providers and their capabilities. The documentation can be found at <a href="https://docs.puppetlabs.com/references/latest/type.html">https://docs.puppetlabs.com/references/latest/type.html.</a></div>
<p><a href="https://docs.puppetlabs.com/references/latest/type.html"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Resource types with generic providers</h1>
                </header>
            
            <article>
                
<p>There are some resource types that use no providers, but they are rare among the core types. Most of the interesting management tasks that Puppet makes easy just work differently among operating systems, and providers enable this in a most elegant fashion.</p>
<p>Even for straightforward tasks that are the same on all platforms, there might be a provider. For example, there is a <kbd>host</kbd> type to manage entries in the <kbd>/etc/hosts</kbd> file. Its syntax is universal, so the code can technically just be implemented in the type. However, there are actual abstract base classes for certain kinds of providers in the Puppet code base. One of them makes it very easy to build providers that edit files, if those files consist of single-line records with ordered fields. Therefore, it makes sense to implement a provider for the <kbd>host</kbd> type and base it on this provider class.</p>
<p class="mce-root">For the curious, this is what a host resource looks like:</p>
<pre>host { 'puppet':<br/>  ip           =&gt; '10.144.12.100',<br/>  host_aliases =&gt; [ 'puppet.example.net', 'master' ],<br/>} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summarizing types and providers</h1>
                </header>
            
            <article>
                
<p>Puppet's resource types and their providers work together to form a solid abstraction layer over software configuration details. The type system is an extendable basis for Puppet's powerful DSL. It forms an elaborate interface for the polymorphous provider layer.</p>
<p>The providers flexibly implement the actual management actions that Puppet is supposed to perform. They map the necessary synchronization steps to commands and system interactions. Many providers cannot satisfy every nuance that the resource type models. The feature system takes care of these disparities in a transparent fashion.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Putting it all together</h1>
                </header>
            
            <article>
                
<p>Reading this far, you might have gotten the impression that this chapter is a rather odd mix of topics. While types and providers do belong closely together, the whole introduction to Facter might seem out of place in this context. However, this is deceptive; facts do play a vital role in the type/provider structure. They are essential for Puppet to make good choices between the providers.</p>
<p>Let's look at an example from the <em>Extending Facter with custom facts</em> section once more. It was about <kbd>fstab</kbd> entries and the difference of Solaris, which uses <kbd>/etc/vfstab</kbd> instead of <kbd>/etc/fstab</kbd>. That section suggested a manifest that adapts according to a fact value. As you have learned, Puppet has a resource type to manage <kbd>fstab</kbd> content: the <kbd>mount</kbd> type. However, for the small deviation of a different file path, there is no dedicated <kbd>mount</kbd> provider for Solaris. There is actually just one provider for all platforms, but on Solaris, it behaves differently. It does this by resolving Facter's <kbd>os['family']</kbd> value. The following code example was adapted from the actual provider code:</p>
<pre>case Facter.value(:os['family'])<br/>when"Solaris"<br/>  fstab = "/etc/vfstab"<br/>else<br/>  fstab = "/etc/fstab"<br/>end </pre>
<p>In other cases, however, Puppet should use thoroughly different providers on different platforms. Package management is a classic example. On a Red Hat-like platform, you will want Puppet to use the <kbd>yum</kbd> provider in virtually all cases. It can be sensible to use <kbd>rpm</kbd>, and even <kbd>apt</kbd> might be available. However, if you tell Puppet to make sure a package is installed, you expect it to install it using <kbd>yum</kbd>, if necessary.</p>
<p>This is obviously a common theme. Certain management tasks need to be performed in different environments, with very different toolchains. In such cases, it is quite clear which provider would be best suited. To make this happen, a provider can declare itself the default if a condition is met. In the case of <kbd>yum</kbd>, it is the following:</p>
<pre>defaultfor :os['name'] =&gt; [:fedora, :centos, :redhat] </pre>
<p>The conditions are based around fact values. If the <kbd>operatingsystem</kbd> value for a given agent is among the listed, <kbd>yum</kbd> will consider itself the default package provider.</p>
<p>The operating system and os family facts are the most popular choices for such queries in providers, but any fact is eligible.</p>
<p>In addition to marking themselves as default, there is more filtering of providers that rely on fact values. Providers can also confine themselves to certain combinations of values. For example, the <kbd>yum</kbd> alternative, <kbd>zypper</kbd>, confines itself to SUSE Linux distributions:</p>
<pre>confine :os['name'] =&gt; [:suse, :sles, :sled, :opensuse] </pre>
<p>This provider method works just as the <kbd>confine</kbd> method in Facter, which was discussed earlier in this chapter. The provider will not even be seen as valid if the respective facts on the agent machine have none of the white-listed values.</p>
<div class="packt_infobox">If you find yourself looking through code for some core providers, you will notice confinement (and even the declaration of default providers) on feature values, although there is no Facter fact of that name. These features are not related to provider features either. They are from another layer of introspection similar to Facter, but hardcoded into the Puppet agent. These agent features are a number of flags that identify some system properties that need not be made available to manifests in the form of facts. For example, the <kbd>posix</kbd> provider for the <kbd>exec</kbd> type becomes the default in the presence of the corresponding feature: <kbd>defaultfor :feature =&gt; :posix</kbd></div>
<p>You will find that some providers forgo the <kbd>confine</kbd> method altogether, as it is not mandatory for correct agent operation. Puppet will also identify unsuitable providers when looking for their necessary operating system commands. For example, the <kbd>pw</kbd> provider for certain BSD flavors does not bother with a <kbd>confine</kbd> statement. It only declares its one required command:</p>
<pre><strong>commands :pw =&gt; "pw"</strong>  </pre>
<p>Agents that find no <kbd>pw</kbd> binary in their search path will not try and use this provider at all.</p>
<p>This concludes the little tour of the inner workings of types and providers with the help of Facter. For a complete example of building a provider for a type, and using the internal tools that you have now learned about, you can refer to <a href="3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>Combining Classes, Configuration Files, and Extensions into Modules</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Puppet gathers information about all agent systems using Facter. The information base consists of a large number of independent bits, called facts. Manifests can query the values of those facts to adapt to the respective agents that trigger their compilation. Puppet also uses facts to choose among providers, the work horses that make the abstract resource types functional across the wide range of supported platforms.</p>
<p>The resource types not only completely define the interface that Puppet exposes in the DSL, they also take care of all the validation of input values, transformations that must be performed before handing values to the providers, and other related tasks.</p>
<p>The providers encapsulate all knowledge of actual operating systems and their respective toolchains. They implement the functionality that the resource types describe. The Puppet model's configurations apply to platforms, which vary from one another, so not every facet of every resource type can make sense for all agents. By exposing only the supported features, a provider can express such limitations.</p>
<p>After this in-depth look at the internal details, let's tackle more practical concerns again. The following chapters will cover the tools needed to build complex and advanced manifests of all scales.</p>


            </article>

            
        </section>
    </body></html>