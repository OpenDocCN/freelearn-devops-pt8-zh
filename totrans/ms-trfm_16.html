<html><head></head><body>
<div id="_idContainer197">
<h1 class="chapter-number" id="_idParaDest-277"><a id="_idTextAnchor665"/><span class="koboSpan" id="kobo.1.1">16</span></h1>
<h1 id="_idParaDest-278"><a id="_idTextAnchor666"/><span class="koboSpan" id="kobo.2.1">Already Provisioned? </span><span class="koboSpan" id="kobo.2.2">Strategies for Importing Existing Environments</span></h1>
<p><span class="koboSpan" id="kobo.3.1">The previous nine chapters of this book have focused on implementing new cloud architectures across multiple clouds using multiple cloud computing paradigms. </span><span class="koboSpan" id="kobo.3.2">Now, we’re going to shift gears a bit and focus on how to work with existing environments. </span><span class="koboSpan" id="kobo.3.3">Unfortunately, sometimes (actually, a lot of the time), the cloud environments that you will manage weren’t </span><a id="_idIndexMarker1146"/><span class="koboSpan" id="kobo.4.1">originally provisioned using </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">Infrastructure-as-Code</span></strong><span class="koboSpan" id="kobo.6.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.7.1">IaC</span></strong><span class="koboSpan" id="kobo.8.1">) using via Terraform. </span><span class="koboSpan" id="kobo.8.2">They could’ve been provisioned using other tools, or even manually provisioned, and now you’re trying to consolidate your cloud operations </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">using Terraform.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">The chapter covers the </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.12.1">Importing </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">individual resources</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Identifying resources </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">to import</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Importing </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">existing environments</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.18.1">Best practices</span></span><a id="_idTextAnchor667"/></li>
</ul>
<h1 id="_idParaDest-279"><a id="_idTextAnchor668"/><span class="koboSpan" id="kobo.19.1">Importing individual resources</span></h1>
<p><span class="koboSpan" id="kobo.20.1">Terraform supports two ways of importing resources into state. </span><span class="koboSpan" id="kobo.20.2">One is inherently imperative and </span><a id="_idIndexMarker1147"/><span class="koboSpan" id="kobo.21.1">procedural and is typically executed outside of a GitOps process using Terraform’s </span><strong class="bold"><span class="koboSpan" id="kobo.22.1">Command Line Interface</span></strong><span class="koboSpan" id="kobo.23.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.24.1">CLI</span></strong><span class="koboSpan" id="kobo.25.1">). </span><span class="koboSpan" id="kobo.25.2">There is </span><a id="_idIndexMarker1148"/><span class="koboSpan" id="kobo.26.1">also another, newer option that allows us to declare import operations in code and follow our standard GitFlow process to shepherd these changes </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">into productio</span><a id="_idTextAnchor669"/><span class="koboSpan" id="kobo.28.1">n.</span></span></p>
<h2 id="_idParaDest-280"><a id="_idTextAnchor670"/><span class="koboSpan" id="kobo.29.1">The import command</span></h2>
<p><span class="koboSpan" id="kobo.30.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.31.1">import</span></strong><span class="koboSpan" id="kobo.32.1"> command </span><a id="_idIndexMarker1149"/><span class="koboSpan" id="kobo.33.1">allows you to import an existing resource </span><a id="_idIndexMarker1150"/><span class="koboSpan" id="kobo.34.1">that has already been provisioned outside of Terraform by some </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">other means:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.36.1">
terraform import [options] ADDRESS ID</span></pre> <p><span class="koboSpan" id="kobo.37.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">Terraform import</span></strong><span class="koboSpan" id="kobo.39.1"> command (</span><a href="https://developer.hashicorp.com/terraform/cli/commands/import"><span class="koboSpan" id="kobo.40.1">https://developer.hashicorp.com/terraform/cli/commands/import</span></a><span class="koboSpan" id="kobo.41.1">) takes two key parameters. </span><span class="koboSpan" id="kobo.41.2">The </span><a id="_idIndexMarker1151"/><span class="koboSpan" id="kobo.42.1">various options fall outside of the scope of this book. </span><span class="koboSpan" id="kobo.42.2">I recommend that you check the documentation for more details on all of the </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">available options.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">The first parameter, the address of the resource within the Terraform code base, is crucial. </span><span class="koboSpan" id="kobo.44.2">It’s the </span><a id="_idIndexMarker1152"/><span class="koboSpan" id="kobo.45.1">same reference that we use to access resources in our Terraform workspace. </span><span class="koboSpan" id="kobo.45.2">Unlike when we’re in the HashiCorp Configuration Language code base, we’re not limited by the current Terraform module’s scope. </span><span class="koboSpan" id="kobo.45.3">The address follows your Terraform provider’s naming convention. </span><span class="koboSpan" id="kobo.45.4">For instance, you’d need the resource type and object reference to import a </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">virtual machine.</span></span></p>
<p><span class="koboSpan" id="kobo.47.1">The second parameter is the resource’s unique identifier on the target cloud platform. </span><span class="koboSpan" id="kobo.47.2">This unique identifier will look very different between different clouds. </span><span class="koboSpan" id="kobo.47.3">In the next section, we’ll look at how this differs for each </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">cloud platform.</span></span></p>
<p><span class="koboSpan" id="kobo.49.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">import</span></strong><span class="koboSpan" id="kobo.51.1"> command is great for individual resources that might have failed due to transient issues during a </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">terraform apply</span></strong><span class="koboSpan" id="kobo.53.1">. </span><span class="koboSpan" id="kobo.53.2">If you had to import an entire solution, it would be extremely tedious to put together an </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">import</span></strong><span class="koboSpan" id="kobo.55.1"> command for every resource. </span><span class="koboSpan" id="kobo.55.2">Even a simple virtual machine might consist of a dozen or </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">so reso</span><a id="_idTextAnchor671"/><span class="koboSpan" id="kobo.57.1">urces.</span></span></p>
<h2 id="_idParaDest-281"><a id="_idTextAnchor672"/><span class="koboSpan" id="kobo.58.1">Import block</span></h2>
<p><span class="koboSpan" id="kobo.59.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">import</span></strong><span class="koboSpan" id="kobo.61.1"> command is useful and available, but it requires you to introduce change to your IaC </span><a id="_idIndexMarker1153"/><span class="koboSpan" id="kobo.62.1">code base through outside influence from a human operator through the command line. </span><span class="koboSpan" id="kobo.62.2">The import block was introduced </span><a id="_idIndexMarker1154"/><span class="koboSpan" id="kobo.63.1">in version 1.5.0 of Terraform to allow these changes to be made through source code changes, which is important to maintaining a GitFlow process. </span><span class="koboSpan" id="kobo.63.2">This, in turn, is a key component of a </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">GitOps model.</span></span></p>
<p><span class="koboSpan" id="kobo.65.1">Rather than executing a command using the Terraform CLI, you’ll need to embed an import block in your code base that looks </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.67.1">
import {
  to = ADDRESS
  id = ID
}</span></pre> <p><span class="koboSpan" id="kobo.68.1">It looks very similar to the parameters of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">import</span></strong><span class="koboSpan" id="kobo.70.1"> command but it utilizes the existing context in which you execute Terraform. </span><span class="koboSpan" id="kobo.70.2">It also uses HashiCorp Configuration Language to define the </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">import action</span></span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">This technique </span><a id="_idIndexMarker1155"/><span class="koboSpan" id="kobo.74.1">not only allows us to perform state management operations </span><a id="_idIndexMarker1156"/><span class="koboSpan" id="kobo.75.1">as part of our GitOps process but also streamlines the process. </span><span class="koboSpan" id="kobo.75.2">Importing resources only requires two pull requests: the first to introduce the import blocks for the resources we wish to import, and the second to remove the import blocks after a successful </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">Terraform Apply</span></strong><span class="koboSpan" id="kobo.77.1">, when the resources are imported into </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">Terraf</span><a id="_idTextAnchor673"/><span class="koboSpan" id="kobo.79.1">orm state.</span></span></p>
<h2 id="_idParaDest-282"><a id="_idTextAnchor674"/><span class="koboSpan" id="kobo.80.1">Importing multiple resources</span></h2>
<p><span class="koboSpan" id="kobo.81.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">Import</span></strong><span class="koboSpan" id="kobo.83.1"> command </span><a id="_idIndexMarker1157"/><span class="koboSpan" id="kobo.84.1">and the import block support importing resources using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">for_each</span></strong><span class="koboSpan" id="kobo.86.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">count</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.88.1"> meta-arguments.</span></span></p>
<p><span class="koboSpan" id="kobo.89.1">To import resources provisioned with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">for_each</span></strong><span class="koboSpan" id="kobo.91.1"> block, you simply need to define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">map</span></strong><span class="koboSpan" id="kobo.93.1"> with the unique identifiers for the resources you wish </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">to import:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.95.1">
locals {
  resources = {
    "zone1" = "ID-for-zone1"
    "zone2" = "ID-for-zone2"
  }
}</span></pre> <p><span class="koboSpan" id="kobo.96.1">The import block’s unique identifier will come from this </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">map</span></strong><span class="koboSpan" id="kobo.98.1"> that you define. </span><span class="koboSpan" id="kobo.98.2">Then, use a matching </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">for_each</span></strong><span class="koboSpan" id="kobo.100.1"> in the import block, which references your resource block using the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">map</span></strong><span class="koboSpan" id="kobo.102.1"> and references the corresponding resource </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">each.key</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.106.1">
import {
  for_each = local.resources
  to = ADDRESS[each.key]
  id = each.value
}</span></pre> <p><span class="koboSpan" id="kobo.107.1">Likewise, when </span><a id="_idIndexMarker1158"/><span class="koboSpan" id="kobo.108.1">importing resources provisioned using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">count</span></strong><span class="koboSpan" id="kobo.110.1"> meta-argument, we must declare an array with </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">unique identifiers:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.112.1">
locals { resources = [ "ID-for-zone1", "ID-for-zone2" ] }</span></pre> <p><span class="koboSpan" id="kobo.113.1">Finally, we can </span><a id="_idIndexMarker1159"/><span class="koboSpan" id="kobo.114.1">use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">count</span></strong><span class="koboSpan" id="kobo.116.1"> meta-argument on the import block and iterate across it just as we do with the </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">resource block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.118.1">
import {
  count = length(local.resources)
  to = ADDRESS[count.index]
  id = local.resources[count.index]
}</span></pre> <p><span class="koboSpan" id="kobo.119.1">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">import</span></strong><span class="koboSpan" id="kobo.121.1"> command is a bit more difficult. </span><span class="koboSpan" id="kobo.121.2">You’ll need to execute a </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">terraform import</span></strong><span class="koboSpan" id="kobo.123.1"> command for each item within the map, referencing the correct </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">key</span></strong><span class="koboSpan" id="kobo.125.1"> and mapping it to the </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">corresponding value:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.127.1">
terraform import 'ADDRESS["key"]' ID</span></pre> <p><span class="koboSpan" id="kobo.128.1">A similar technique is used for importing resources that are provisioned </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">count</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.132.1">
terraform import 'ADDRESS[index]' ID</span></pre> <p><span class="koboSpan" id="kobo.133.1">When working with </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">for_each</span></strong><span class="koboSpan" id="kobo.135.1"> provisioned resources, we need to execute the </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">terraform import</span></strong><span class="koboSpan" id="kobo.137.1"> command for each item within the array and manually correlate the index with the correct </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">unique identifier.</span></span></p>
<p><span class="koboSpan" id="kobo.139.1">Although it is technically possible through some pretty advanced bash scripting, the recommended approach is to use the import block within the HashiCorp Configuration Language, as this is much easier and less error-prone </span><a id="_idTextAnchor675"/><span class="No-Break"><span class="koboSpan" id="kobo.140.1">to implement.</span></span></p>
<p><span class="koboSpan" id="kobo.141.1">We have examined the imperative and declarative ways of importing existing resources into Terraform using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">import</span></strong><span class="koboSpan" id="kobo.143.1"> command and the import block, respectively. </span><span class="koboSpan" id="kobo.143.2">Now, let’s examine how to identify the correct unique identifier for each of our existing resources </span><a id="_idIndexMarker1160"/><span class="koboSpan" id="kobo.144.1">across the three cloud platforms we have covered in this book: </span><strong class="bold"><span class="koboSpan" id="kobo.145.1">Amazon Web Services</span></strong><span class="koboSpan" id="kobo.146.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.147.1">AWS</span></strong><span class="koboSpan" id="kobo.148.1">), Microsoft Azure, and Google </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">Cloud Platform.</span></span></p>
<h1 id="_idParaDest-283"><a id="_idTextAnchor676"/><span class="koboSpan" id="kobo.150.1">Identifying resources to import</span></h1>
<p><span class="koboSpan" id="kobo.151.1">Just as there </span><a id="_idIndexMarker1161"/><span class="koboSpan" id="kobo.152.1">were subtle differences in each of </span><a id="_idIndexMarker1162"/><span class="koboSpan" id="kobo.153.1">the cloud architectures we developed in the previous chapters of this book, the way in which existing resources are imported into Terraform is affected by the structural and not-so-subtle differences between the </span><a id="_idTextAnchor677"/><span class="No-Break"><span class="koboSpan" id="kobo.154.1">cloud platforms.</span></span></p>
<h2 id="_idParaDest-284"><a id="_idTextAnchor678"/><span class="koboSpan" id="kobo.155.1">AWS</span></h2>
<p><span class="koboSpan" id="kobo.156.1">The naming </span><a id="_idIndexMarker1163"/><span class="koboSpan" id="kobo.157.1">convention used by AWS for EC2 instances tends to look like this: </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">i-abcd1234</span></strong><span class="koboSpan" id="kobo.159.1">. </span><span class="koboSpan" id="kobo.159.2">It typically consists of two components: the prefix and the identifier, with the prefix varying across </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">AWS services.</span></span></p>
<p><span class="koboSpan" id="kobo.161.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">i-</span></strong><span class="koboSpan" id="kobo.163.1"> prefix indicates </span><a id="_idIndexMarker1164"/><span class="koboSpan" id="kobo.164.1">that this is an </span><strong class="bold"><span class="koboSpan" id="kobo.165.1">Elastic Compute Cloud</span></strong><span class="koboSpan" id="kobo.166.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.167.1">EC2</span></strong><span class="koboSpan" id="kobo.168.1">) instance. </span><span class="koboSpan" id="kobo.168.2">Other prefixes might be used for different types of resources, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">vol-</span></strong><span class="koboSpan" id="kobo.170.1"> for volumes or </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">sg-</span></strong><span class="koboSpan" id="kobo.172.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">security groups.</span></span></p>
<p><span class="koboSpan" id="kobo.174.1">In this case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">abcd1234</span></strong><span class="koboSpan" id="kobo.176.1"> identifier is a unique identifier for the instance. </span><span class="koboSpan" id="kobo.176.2">AWS usually assigns a hexadecimal string to each instance to differentiate it from other resources. </span><span class="koboSpan" id="kobo.176.3">This naming convention helps users and AWS services identify and reference resources within the AWS ecosystem. </span><span class="koboSpan" id="kobo.176.4">You’ll need to recognize the correct unique identifier for whatever resource you are trying to import into Terraform from AWS and the other </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">cloud platforms.</span></span></p>
<p><span class="koboSpan" id="kobo.178.1">When using the import command on AWS, it would look </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">like this:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.180.1">
terraform import aws_instance.foo i-abcd1234</span></pre> <p><span class="koboSpan" id="kobo.181.1">The corresponding import block would look </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.183.1">
import {
  to = aws_instance.foo
  id = i-abcd1234
}</span></pre> <p><span class="koboSpan" id="kobo.184.1">It’s important to understand the distinction between the address, which is the internal object reference within Terraform, and the unique identifier, which is the external reference to the resource on the target cloud platform. </span><span class="koboSpan" id="kobo.184.2">This understanding will help you navigate the import process</span><a id="_idTextAnchor679"/> <span class="No-Break"><span class="koboSpan" id="kobo.185.1">more effectively.</span></span></p>
<h2 id="_idParaDest-285"><a id="_idTextAnchor680"/><span class="koboSpan" id="kobo.186.1">Azure</span></h2>
<p><span class="koboSpan" id="kobo.187.1">In Azure, the unique </span><a id="_idIndexMarker1165"/><span class="koboSpan" id="kobo.188.1">identifier is called the </span><strong class="bold"><span class="koboSpan" id="kobo.189.1">Azure resource ID</span></strong><span class="koboSpan" id="kobo.190.1">. </span><span class="koboSpan" id="kobo.190.2">It takes </span><a id="_idIndexMarker1166"/><span class="koboSpan" id="kobo.191.1">on a radically different format that is composed using several different landmarks in a cloud resource’s location within Azure. </span><span class="koboSpan" id="kobo.191.2">It follows a </span><a id="_idIndexMarker1167"/><span class="koboSpan" id="kobo.192.1">structured format that includes several components: the subscription, the resource group, the resource provider, a resource type, and a localized </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">resource name:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.194.1">
/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}/providers/{resource-provider}/{resource-type}/{resource-name}</span></pre> <p><span class="koboSpan" id="kobo.195.1">For example, the Azure resource ID for an Azure virtual machine would look </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.197.1">
/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-foo/providers/Microsoft.Compute/virtualMachines/vmfoo001</span></pre> <p><span class="koboSpan" id="kobo.198.1">In this </span><a id="_idIndexMarker1168"/><span class="koboSpan" id="kobo.199.1">example, we can see the concrete values for each component of the resource </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">ID’s path:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.201.1">Subscription ID</span></strong><span class="koboSpan" id="kobo.202.1">: This is the </span><a id="_idIndexMarker1169"/><span class="koboSpan" id="kobo.203.1">unique identifier for your Azure subscription: a </span><strong class="bold"><span class="koboSpan" id="kobo.204.1">Globally Unique Identifier</span></strong><span class="koboSpan" id="kobo.205.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.206.1"> GUID</span></strong><span class="koboSpan" id="kobo.207.1">). </span><span class="koboSpan" id="kobo.207.2">In our example, we just use an empty </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">00000000-0000-0000-0000-000000000000</span></strong><span class="koboSpan" id="kobo.209.1"> GUID for </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">the subscription.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.211.1">Resource group</span></strong><span class="koboSpan" id="kobo.212.1">: This is the name of the resource group that contains the resource. </span><span class="koboSpan" id="kobo.212.2">Resource groups are used to organize related resources. </span><span class="koboSpan" id="kobo.212.3">In our example, the resource group </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">rg-foo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.216.1">Resource provider</span></strong><span class="koboSpan" id="kobo.217.1">: This indicates the type of service or resource in Azure. </span><span class="koboSpan" id="kobo.217.2">In our example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">Microsoft.Compute</span></strong><span class="koboSpan" id="kobo.219.1"> is the resource provider for Azure compute services, which includes Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">virtual machines.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.221.1">Resource type</span></strong><span class="koboSpan" id="kobo.222.1">: This specifies the specific resource type within the service. </span><span class="koboSpan" id="kobo.222.2">In our example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">virtualMachines</span></strong><span class="koboSpan" id="kobo.224.1"> is used for an Azure virtual machine. </span><span class="koboSpan" id="kobo.224.2">Together, the </span><a id="_idIndexMarker1170"/><span class="koboSpan" id="kobo.225.1">resource provider and the resource type create a fully qualified Azure resource </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">type: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">Microsoft.Compute\virtualMachines</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.229.1">Resource name</span></strong><span class="koboSpan" id="kobo.230.1">: This is the resource’s name. </span><span class="koboSpan" id="kobo.230.2">In our example, the virtual machine is </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">vmfoo001</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.234.1">Each resource type within a resource provider has subtypes as well. </span><span class="koboSpan" id="kobo.234.2">These are delimited with additional slashes (such as a virtual machine extension: </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">Microsoft.Compute/virtualMachines/{vm-name}/extensions/{extension-name}</span></strong><span class="koboSpan" id="kobo.236.1">). </span><span class="koboSpan" id="kobo.236.2">This naming convention for Azure resource ID uses a resource path strategy instead of AWS’s prefix and unique identifier strategy. </span><span class="koboSpan" id="kobo.236.3">As a result, Azure resource IDs can get rather long, but they do have a sensible way in which </span><a id="_idIndexMarker1171"/><span class="koboSpan" id="kobo.237.1">they can be deconstructed to gather valuable information about the </span><a id="_idIndexMarker1172"/><span class="koboSpan" id="kobo.238.1">deployment context of a particular resource, making additional </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">lookups unnecessary.</span></span></p>
<p><span class="koboSpan" id="kobo.240.1">When using the import command on Azure, it would look </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">like this:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.242.1">
terraform import azurerm_linux_virtual_machine.foo "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-foo/providers/Microsoft.Compute/virtualMachines/vmfoo001"</span></pre> <p><span class="koboSpan" id="kobo.243.1">The corresponding import block would look </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.245.1">
import {
  to = azurerm_linux_virtual_machine.foo
  id = "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-foo/providers/Microsoft.Compute/virtualMachines/vmfoo001"
}</span></pre> <p><span class="koboSpan" id="kobo.246.1">It’s important to remember that the address is the internal object reference within Terraform. </span><span class="koboSpan" id="kobo.246.2">The unique identifier is the external reference to the resource on </span><a id="_idTextAnchor681"/><span class="koboSpan" id="kobo.247.1">the target </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">cloud platform.</span></span></p>
<h2 id="_idParaDest-286"><a id="_idTextAnchor682"/><span class="koboSpan" id="kobo.249.1">Google Cloud Platform</span></h2>
<p><span class="koboSpan" id="kobo.250.1">In Google Cloud, the unique </span><a id="_idIndexMarker1173"/><span class="koboSpan" id="kobo.251.1">identifier for a resource is called the </span><strong class="bold"><span class="koboSpan" id="kobo.252.1">resource path</span></strong><span class="koboSpan" id="kobo.253.1">, and like Azure, it is composed of some important landmarks in the cloud resource’s </span><a id="_idIndexMarker1174"/><span class="koboSpan" id="kobo.254.1">location within Google Cloud. </span><span class="koboSpan" id="kobo.254.2">These landmarks differ from Azure’s due to the structural differences between the two </span><a id="_idIndexMarker1175"/><span class="koboSpan" id="kobo.255.1">platforms and other </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">design considerations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.257.1">
projects/{{project}}/zones/{{zone}}/instances/{{name}}</span></pre> <p><span class="koboSpan" id="kobo.258.1">For example, the Google resource path for a Google compute instance would look </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.260.1">
projects/proj-foo/zones/us-central1-a/instances/vmfoo001</span></pre> <p><span class="koboSpan" id="kobo.261.1">In this example, we see the concrete values for each component of the </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">resource path:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.263.1">Project ID</span></strong><span class="koboSpan" id="kobo.264.1">: This is the name of the resource group that contains the resource. </span><span class="koboSpan" id="kobo.264.2">Resource groups are used to organize related resources. </span><span class="koboSpan" id="kobo.264.3">In our example, the resource group </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">proj-foo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.268.1">Zone</span></strong><span class="koboSpan" id="kobo.269.1">: This indicates the physical location of the resource within a Google Cloud region </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">and zone.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.271.1">Resource Name</span></strong><span class="koboSpan" id="kobo.272.1">: This is the resource’s name. </span><span class="koboSpan" id="kobo.272.2">In our example, the virtual machine is </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">vmfoo001</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.276.1">While Google Cloud does have higher-level organizational structures, such as the Google Cloud organization and the folders within that organization, a resource path only includes the Google Cloud project ID. </span><span class="koboSpan" id="kobo.276.2">This is similar to Azure’s resource ID, which includes the Azure subscription and resource group, as these are logical containers of the resource within the platform. </span><span class="koboSpan" id="kobo.276.3">Google opted for a more simplistic path by only including the project ID. </span><span class="koboSpan" id="kobo.276.4">A major difference between Google Cloud’s resource path and Azure’s resource ID is the inclusion of the zone within the resource path. </span><span class="koboSpan" id="kobo.276.5">The zone indicates the resource’s physical location within one of Google Cloud’s regions. </span><span class="koboSpan" id="kobo.276.6">Azure’s resource ID only includes logical structures such as subscription, resource group, resource provider, and type, not physical locations such as Azure regions or </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">availability zones.</span></span></p>
<p><span class="koboSpan" id="kobo.278.1">When using the import command on Google Cloud Platform, it would look </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">like this:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.280.1">
terraform import google_compute_instance.foo "projects/proj-foo/zones/us-central1-a/instances/vmfoo001"</span></pre> <p><span class="koboSpan" id="kobo.281.1">The corresponding import block would look </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.283.1">
import {
  to = google_compute_instance.foo
  id = "projects/proj-foo/zones/us-central1-a/instances/vmfoo001"
}</span></pre> <p><span class="koboSpan" id="kobo.284.1">It’s important </span><a id="_idIndexMarker1176"/><span class="koboSpan" id="kobo.285.1">to remember that the address is the internal </span><a id="_idIndexMarker1177"/><span class="koboSpan" id="kobo.286.1">object reference within Terraform and the unique identifier is the external reference to the resource on the target </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">cloud platform.</span></span></p>
<p><span class="koboSpan" id="kobo.288.1">Now that we know a bit about how to identify the existing resources and the unique identifiers that we need to map to the resources defined within our code base, we are fully equipped to start manually importing resources into our Terraform code. </span><span class="koboSpan" id="kobo.288.2">However, is this the only way? </span><span class="koboSpan" id="kobo.288.3">Is there potentially a more cost-effective or time-sensitive approach that would allow us to import resources en masse? </span><span class="koboSpan" id="kobo.288.4">In the next section, we’ll explore some tools that allow us to find and import existing resources and generate their corresponding </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">Terraform code.</span></span></p>
<h1 id="_idParaDest-287"><a id="_idTextAnchor683"/><span class="koboSpan" id="kobo.290.1">Importing existing environments</span></h1>
<p><span class="koboSpan" id="kobo.291.1">As we saw in the previous sections of this chapter, Terraform contains extensive import mechanisms </span><a id="_idIndexMarker1178"/><span class="koboSpan" id="kobo.292.1">that allow us to import individuals and a multitude of existing resources into our Terraform code base. </span><span class="koboSpan" id="kobo.292.2">These tools can help us overcome transient errors that result in orphaned resources that need to be managed with an existing Terraform code base and Terraform </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">state file.</span></span></p>
<p><span class="koboSpan" id="kobo.294.1">However, what happens when we don’t have any Terraform code written and many existing resources already provisioned within our cloud landscape? </span><span class="koboSpan" id="kobo.294.2">Manually reverse engineering all the Terraform code from scratch doesn’t seem like a useful way to spend our days. </span><span class="koboSpan" id="kobo.294.3">That’s why there are tools that help automate </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">this process!</span></span></p>
<p><span class="koboSpan" id="kobo.296.1">In this section, we’ll examine a couple of the most popular open-source</span><a id="_idTextAnchor684"/><span class="koboSpan" id="kobo.297.1"> tools for solving </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">this problem.</span></span></p>
<h2 id="_idParaDest-288"><a id="_idTextAnchor685"/><span class="koboSpan" id="kobo.299.1">Terraformer</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.300.1">Terraformer</span></strong><span class="koboSpan" id="kobo.301.1"> is an </span><a id="_idIndexMarker1179"/><span class="koboSpan" id="kobo.302.1">open-source tool developed by Google that helps with the process of importing existing cloud infrastructure </span><a id="_idIndexMarker1180"/><span class="koboSpan" id="kobo.303.1">into Terraform configuration and state. </span><span class="koboSpan" id="kobo.303.2">It supports various cloud providers, including the ones we’ve explored in this book. </span><span class="koboSpan" id="kobo.303.3">Naturally, Google Cloud is well-supported, including its main competitors (AWS and Azure), but a myriad of other Terraform providers also have support. </span><span class="koboSpan" id="kobo.303.4">Unlike the built-in capabilities of Terraform, this tool was designed to generate Terraform code and state based on the existing resources spread across your </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">cloud landscape.</span></span></p>
<p><span class="koboSpan" id="kobo.305.1">This tool, and others like it, works by leveraging the cloud provider’s REST APIs in order to gather information about the various resources that have already been provisioned. </span><span class="koboSpan" id="kobo.305.2">You just need to point it in the right direction and give it some guardrails in order to narrow its field of vision. </span><span class="koboSpan" id="kobo.305.3">You simply pick up the resources that you want to bundle together into the same Terraform workspace and </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">state file.</span></span></p>
<p><span class="koboSpan" id="kobo.307.1">The key command line arguments that allow you to scope Terraformer to just the resources you are interested in are resource types, regions, and tags. </span><span class="koboSpan" id="kobo.307.2">Depending on the provider, there may be limitations in resource type support, so it is best to check the current list of supported resources by using the </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.309.1">
terraformer list --provider=aws</span></pre> <p><span class="koboSpan" id="kobo.310.1">This will help you inform how you will query the particular cloud platform. </span><span class="koboSpan" id="kobo.310.2">For example, when importing resources from AWS, we can determine that </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">s3</span></strong><span class="koboSpan" id="kobo.312.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">ec2_instance</span></strong><span class="koboSpan" id="kobo.314.1"> are supported </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">resource types:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.316.1">
terraformer import aws --resources=s3,ec2_instance --regions=us-west-1</span></pre> <p><span class="koboSpan" id="kobo.317.1">On Azure, we’ll be using Azure-specific resource types and will often use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">--resource-group</span></strong><span class="koboSpan" id="kobo.319.1"> argument to specify this Azure-specific logical structure to </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">import resources:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.321.1">
terraformer import azure --resources=resource_group,vm --resource-group=your-resource-group</span></pre> <p><span class="koboSpan" id="kobo.322.1">Likewise, on Google Cloud, we’ll use the Google Cloud Project, which is the logical structure that corresponds to Azure resource groups, to narrow </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">the field:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.324.1">
terraformer import google --resources=gcs,compute_instance --projects=your-project-id --regions=your-region</span></pre> <p><span class="koboSpan" id="kobo.325.1">Tags play </span><a id="_idIndexMarker1181"/><span class="koboSpan" id="kobo.326.1">an important role, as they provide a very fine-grained way to import </span><a id="_idIndexMarker1182"/><span class="koboSpan" id="kobo.327.1">exactly what we want into our </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">Terraform workspaces:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.329.1">
terraformer import google --filter="Name=tags.Environment;Value=Production"</span></pre> <p><span class="koboSpan" id="kobo.330.1">We can specify a very specific collection of tags that we pre-seed in our environments to get the most e</span><a id="_idTextAnchor686"/><span class="koboSpan" id="kobo.331.1">fficiency during the </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">import process.</span></span></p>
<h2 id="_idParaDest-289"><a id="_idTextAnchor687"/><span class="koboSpan" id="kobo.333.1">The Azure Export Tool</span></h2>
<p><span class="koboSpan" id="kobo.334.1">There are </span><a id="_idIndexMarker1183"/><span class="koboSpan" id="kobo.335.1">other commercial and platform-specific </span><a id="_idIndexMarker1184"/><span class="koboSpan" id="kobo.336.1">tools that might do a better job than general-purpose tools like Google’s Terraformer. </span><span class="koboSpan" id="kobo.336.2">One example of this is the </span><strong class="bold"><span class="koboSpan" id="kobo.337.1">Azure Export Tool</span></strong><span class="koboSpan" id="kobo.338.1"> for Terraform. </span><span class="koboSpan" id="kobo.338.2">This tool provides greater query-ability to the Azure platform and allows you to customize code generation to leverage both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">azurerm</span></strong><span class="koboSpan" id="kobo.340.1"> provider and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">azapi</span></strong><span class="koboSpan" id="kobo.342.1"> provider, which are two Terraform providers that can be used to provision and manage </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">Azure resources.</span></span></p>
<p><span class="koboSpan" id="kobo.344.1">Like Terraformer, the Azure Export Tool has several mechanisms for querying existing resources that should be included in the code generation process. </span><span class="koboSpan" id="kobo.344.2">It supports additional import options, such as a subscription-wide import, and eliminates the need to specify resource types. </span><span class="koboSpan" id="kobo.344.3">This can help speed up the process for Azure code generation by using a combination of </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">azurerm</span></strong><span class="koboSpan" id="kobo.346.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">azapi</span></strong><span class="koboSpan" id="kobo.348.1"> providers. </span><span class="koboSpan" id="kobo.348.2">Since the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">azapi</span></strong><span class="koboSpan" id="kobo.350.1"> provider enables full support of every Azure resource, there are no resource type-based compatibility concerns that can’t be filled by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">azapi</span></strong><span class="koboSpan" id="kobo.352.1"> provider as a poly-fill when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">azurerm</span></strong><span class="koboSpan" id="kobo.354.1"> resources </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">are unavailable.</span></span></p>
<p><span class="koboSpan" id="kobo.356.1">The command to import all the resources within a given Azure resource group would simply be </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.358.1">
aztfexport resource-group rg-foo</span></pre> <p><span class="koboSpan" id="kobo.359.1">It can be run in an interactive or non-interactive mode. </span><span class="koboSpan" id="kobo.359.2">The interactive mode allows the end user to review the resources that will be imported and mapped to their corresponding references in the </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">Terraform code.</span></span></p>
<p><span class="koboSpan" id="kobo.361.1">While the </span><a id="_idIndexMarker1185"/><span class="koboSpan" id="kobo.362.1">Azure Export Tool isn’t as widely known as the Terraformer </span><a id="_idIndexMarker1186"/><span class="koboSpan" id="kobo.363.1">project, it does have some interesting features that are useful within the context of Azure and the broader Terraform community as well. </span><span class="koboSpan" id="kobo.363.2">One example is the </span><strong class="bold"><span class="koboSpan" id="kobo.364.1">append</span></strong><span class="koboSpan" id="kobo.365.1"> feature that allows you to perform targeted code generation and append existing resourc</span><a id="_idTextAnchor688"/><span class="koboSpan" id="kobo.366.1">es into an existing </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">Terraform workspace.</span></span></p>
<h2 id="_idParaDest-290"><a id="_idTextAnchor689"/><span class="koboSpan" id="kobo.368.1">Limitations</span></h2>
<p><span class="koboSpan" id="kobo.369.1">The allure of an efficient code generation tool for IaC and Terraform is very real. </span><span class="koboSpan" id="kobo.369.2">However, it is not </span><a id="_idIndexMarker1187"/><span class="koboSpan" id="kobo.370.1">without its limitations and common pitfalls that you should be aware of when venturing into </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">this territory.</span></span></p>
<p><span class="koboSpan" id="kobo.372.1">The biggest challenges with code generation tools for Terraform are not unique problems within the realm of Terraform and IaC, but ones that affect the approach of reverse engineering or code generation in general. </span><span class="koboSpan" id="kobo.372.2">Code that is generated using reverse engineering tools often lacks the craftsmanship that handwritten code has engrained within it from day one. </span><span class="koboSpan" id="kobo.372.3">This can result in not only functional defects that need to be ferreted out but also countless occurrences of code quality and readability issues that need to be resolved before the code base can really be used for its intended purpose: to maintain cloud environments </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">via IaC.</span></span></p>
<p><span class="koboSpan" id="kobo.374.1">One functional problem that often crops up in imported Terraform code bases is over-zealously defined explicit dependencies using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">depends_on</span></strong><span class="koboSpan" id="kobo.376.1"> meta-argument. </span><span class="koboSpan" id="kobo.376.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">depends_on</span></strong><span class="koboSpan" id="kobo.378.1"> clause is a valuable tool for resolving implicit dependencies between resources that Terraform can’t otherwise pick up automatically. </span><span class="koboSpan" id="kobo.378.2">However, in most cases, an explicit definition of these dependencies between resources is unnecessary, adds additional bloat and complexity to the code base, and can be detrimental </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">to readability.</span></span></p>
<p><span class="koboSpan" id="kobo.380.1">Another example is that when the resource configuration is extracted from the cloud platform, its values are largely imported as hard-coded values that are scattered across all the resources declared. </span><span class="koboSpan" id="kobo.380.2">This creates an immediate backlog of technical debt to rationalize related constant values and extract a sane and then desirable set of input variables that can be used to define relevant </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">configuration settings.</span></span></p>
<p><span class="koboSpan" id="kobo.382.1">Lastly, there are often write-only attributes on Terraform resources that will not be returned by the cloud platform’s REST APIs because they contain sensitive or secret information. </span><span class="koboSpan" id="kobo.382.2">This is by design to protect against secret leakage and would not be a problem if the resource was originally provisioned from Terraform, as those sensitive values would be stored in the state. </span><span class="koboSpan" id="kobo.382.3">However, this creates a bit of a refactoring process because it means that in most cases, your Terraform code base will not pass </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">terraform validate</span></strong><span class="koboSpan" id="kobo.384.1">, let alone </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">terraform plan</span></strong><span class="koboSpan" id="kobo.386.1">, without errors that need to </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">be resolved.</span></span></p>
<p><span class="koboSpan" id="kobo.388.1">Running </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">plan</span></strong><span class="koboSpan" id="kobo.390.1"> immediately after you generate the code and import the resources can help you pick up on subtle differences and irregularities in the import process. </span><span class="koboSpan" id="kobo.390.2">This can happen, as the terraform code generation is far from </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">100% accurate.</span></span></p>
<p><span class="koboSpan" id="kobo.392.1">As we can see, there are some pretty good options in the realm of tools that can automate </span><a id="_idIndexMarker1188"/><span class="koboSpan" id="kobo.393.1">the code generation and terraform state file creation of large landscapes of cloud resources across the multitude of Terraform providers available, including the three major cloud platforms that we focused on in this book. </span><span class="koboSpan" id="kobo.393.2">However, while code generation can expedite some parts of the process, it can also bring its own challenges that need to be addressed. </span><span class="koboSpan" id="kobo.393.3">In the next section, we’ll weigh the tradeoffs and discuss some best practices and alternatives for bringing existing environments under </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">Terraform management.</span></span></p>
<h1 id="_idParaDest-291"><a id="_idTextAnchor690"/><span class="koboSpan" id="kobo.395.1">Best practices</span></h1>
<p><span class="koboSpan" id="kobo.396.1">We’ve looked at the built-in capabilities within Terraform to import individual resources and at how we can identify the existing resources that we want to import on different cloud platforms. </span><span class="koboSpan" id="kobo.396.2">We recognized some of the limitations of the built-in capabilities and looked at 3rd party alternatives that offer options of importing entire environments en masse, as well as the current limitations of such options. </span><span class="koboSpan" id="kobo.396.3">Now, we’ll look at best practices for how and when to use these different approaches to import existing resources and environments to bri</span><a id="_idTextAnchor691"/><span class="koboSpan" id="kobo.397.1">ng them under the management </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">of Terraform.</span></span></p>
<h2 id="_idParaDest-292"><a id="_idTextAnchor692"/><span class="koboSpan" id="kobo.399.1">Blast radius</span></h2>
<p><span class="koboSpan" id="kobo.400.1">When importing </span><a id="_idIndexMarker1189"/><span class="koboSpan" id="kobo.401.1">existing resources and bringing them under management using Terraform, it’s important to think carefully about the organization of those resources and how you want to compartmentalize them into working IaC solutions in the long term. </span><span class="koboSpan" id="kobo.401.2">This is the design principle of minimizing the </span><strong class="bold"><span class="koboSpan" id="kobo.402.1">blast radius</span></strong><span class="koboSpan" id="kobo.403.1"> of your Terraform modules. </span><span class="koboSpan" id="kobo.403.2">When we are importing resources, we are essentially establishing the boundaries of our root modules or </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">Terraform workspaces.</span></span></p>
<p><span class="koboSpan" id="kobo.405.1">This is the ideal time to perform this design, as the workspaces have yet to be organized. </span><span class="koboSpan" id="kobo.405.2">It’s important to think this through, as it will affect how easy it is to manage, update, and replicate parts of your infrastructure, depending on how you group </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">resources together.</span></span></p>
<p><span class="koboSpan" id="kobo.407.1">You should </span><a id="_idIndexMarker1190"/><span class="koboSpan" id="kobo.408.1">consider the function that the resources will play and who will be responsible for managing them. </span><span class="koboSpan" id="kobo.408.2">Suppose a central team is responsible for maintaining a certain part of the architecture. </span><span class="koboSpan" id="kobo.408.3">In that case, you may want to consider organizing these resources together within the same Terraform workspace to make it easier to control access and reduce friction </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">between teams.</span></span></p>
<p><span class="koboSpan" id="kobo.410.1">Use tags to narrow your resource filter as you use Terraformer or other tools to generate code within your Terraform workspaces. </span><span class="koboSpan" id="kobo.410.2">Pre-seeding the cloud resources with tags that are fit for purpose will help you maximize the effectiveness of the Terraform import tools you use. </span><span class="koboSpan" id="kobo.410.3">This is especially important in AWS, where you lack logical containers for resources like those that are present on Azure and Google Cloud with</span><a id="_idTextAnchor693"/><span class="koboSpan" id="kobo.411.1"> resource groups and </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">projects, respectively.</span></span></p>
<h2 id="_idParaDest-293"><a id="_idTextAnchor694"/><span class="koboSpan" id="kobo.413.1">Sometimes moving slowly is moving fast</span></h2>
<p><span class="koboSpan" id="kobo.414.1">As an alternative to using an import tool to import resources on masse, you could use a lightweight technique using built-in import tools. </span><span class="koboSpan" id="kobo.414.2">This process is a bit tedious, but moving slowly </span><a id="_idIndexMarker1191"/><span class="koboSpan" id="kobo.415.1">sometimes allows you to be more purposeful and thoughtful. </span><span class="koboSpan" id="kobo.415.2">This process involves simply using querying techniques to identify the resources that you plan on importing and then scaffolding them using the most bare-bones Terraform resource definition. </span><span class="koboSpan" id="kobo.415.3">This resource definition is merely a placeholder and is very unlikely to match the configuration of the previously provisioned resource—but that’s not </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">the point.</span></span></p>
<p><span class="koboSpan" id="kobo.417.1">The point is to import the existing resource into the state and then run a </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">terraform plan</span></strong><span class="koboSpan" id="kobo.419.1"> to determine the configuration differences. </span><span class="koboSpan" id="kobo.419.2">You can then use the resulting plan to adjust the resource definition’s configuration in code to match the output from the plan until there are no more </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">changes required.</span></span></p>
<p><span class="koboSpan" id="kobo.421.1">With this approach, you are taking the opposite approach to bulk tool-based import. </span><span class="koboSpan" id="kobo.421.2">Rather than wielding a machete and traipsing through the jungle, you wield a scalpel and make extremely thoughtful cuts. </span><span class="koboSpan" id="kobo.421.3">You will have to manually configure it, but it will give you a more systematic and step-by-step understanding of the components you are importing and bringing under management. </span><span class="koboSpan" id="kobo.421.4">This deeper understanding can help you identify dependencies and flaws in your design that might get swept under </span><a id="_idTextAnchor695"/><span class="koboSpan" id="kobo.422.1">the rug when following a bulk </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">import process.</span></span></p>
<h2 id="_idParaDest-294"><a id="_idTextAnchor696"/><span class="koboSpan" id="kobo.424.1">Blue/green deployment</span></h2>
<p><span class="koboSpan" id="kobo.425.1">Another option is to consider alternatives to importation. </span><span class="koboSpan" id="kobo.425.2">Importing is a messy and very error-prone business. </span><span class="koboSpan" id="kobo.425.3">If you have critical infrastructure that was manually provisioned, you might </span><a id="_idIndexMarker1192"/><span class="koboSpan" id="kobo.426.1">want to consider replacing it with newly provisioned environments that are already under </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">Terraform management.</span></span></p>
<p><span class="koboSpan" id="kobo.428.1">This approach is called a </span><strong class="bold"><span class="koboSpan" id="kobo.429.1">blue/green deployment</span></strong><span class="koboSpan" id="kobo.430.1">. </span><span class="koboSpan" id="kobo.430.2">It is a well-known release management strategy </span><a id="_idIndexMarker1193"/><span class="koboSpan" id="kobo.431.1">whereby the existing </span><strong class="bold"><span class="koboSpan" id="kobo.432.1">blue</span></strong><span class="koboSpan" id="kobo.433.1"> environment is replaced </span><a id="_idIndexMarker1194"/><span class="koboSpan" id="kobo.434.1">through the construction of a new </span><strong class="bold"><span class="koboSpan" id="kobo.435.1">green</span></strong><span class="koboSpan" id="kobo.436.1"> environment. </span><span class="koboSpan" id="kobo.436.2">After the green environment is fully tested and ready to go, we perform a cutover operation to transition from the blue environment to the </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">green environment.</span></span></p>
<p><span class="koboSpan" id="kobo.438.1">You can set up new environments and transition workloads and applications into those. </span><span class="koboSpan" id="kobo.438.2">This will allow you to have a clean separation between environments that were provisioned manually without proper governance in place and those for which you followed best practices. </span><span class="koboSpan" id="kobo.438.3">Slowly transition your workloads, a piece at a time, to the new well-organized environment until the legacy environment is simply </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">shut off.</span></span></p>
<p><span class="koboSpan" id="kobo.440.1">Using code generators will likely produce code of extremely poor quality that will require extensive refactoring. </span><span class="koboSpan" id="kobo.440.2">While some of this will be simple input variable extraction, moving resources into modules will become extremely tedious as the complexity of the environment increases. </span><span class="koboSpan" id="kobo.440.3">The effort to perform an import, refactor, and transform process might actually be greater than writing from scratch and cutting </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">over gradually.</span></span></p>
<p><span class="koboSpan" id="kobo.442.1">When you weigh the cost of putting the legacy environment into a “keep the lights on” mode while you build out the new world order, this allows your organization to maintain some normalcy and slowly adapt to the change of using IaC-managed envir</span><a id="_idTextAnchor697"/><span class="koboSpan" id="kobo.443.1">onments over time rather than in one </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">fell swoop.</span></span></p>
<p><span class="koboSpan" id="kobo.445.1">In this section, we discussed some important rules of thumb for importing existing resources and environments under Terraform management. </span><span class="koboSpan" id="kobo.445.2">If you plan on performing bulk imports, first recognize the limitations of the tool that you will use and build in ample time for refactoring. </span><span class="koboSpan" id="kobo.445.3">Most importantly, make sure that you narrow the focus by defining a focused blast radius around </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">your deployments.</span></span></p>
<p><span class="koboSpan" id="kobo.447.1">If combing through a mountain of junk code and cleaning it all up through extensive refactoring doesn’t sound like your cup of tea, consider moving slowly by either reconstructing the environment through a highly focused step-by-step import process or going all the way </span><a id="_idIndexMarker1195"/><span class="koboSpan" id="kobo.448.1">and planning a blue/green deployment. </span><span class="koboSpan" id="kobo.448.2">My preferred method is blue/green, but you must carefully assess the impact on production environments to d</span><a id="_idTextAnchor698"/><span class="koboSpan" id="kobo.449.1">etermine whether this is the best option </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">for you.</span></span></p>
<h1 id="_idParaDest-295"><a id="_idTextAnchor699"/><span class="koboSpan" id="kobo.451.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.452.1">In this chapter, we looked at Terraform’s built-in capabilities for importing existing resources into Terraform state using imperative and declarative approaches. </span><span class="koboSpan" id="kobo.452.2">While the built-in import capabilities lack any sort of code generation, we looked at a few open source tools that analyzed existing environments and generated HashiCorp Configuration Language code to manage the resources and provide for them to be imported into the state. </span><span class="koboSpan" id="kobo.452.3">We discussed the relevant trade-offs between these different import techniques and when to consider each, which should help you decide the best course of action for your organization and teams. </span><span class="koboSpan" id="kobo.452.4">In the next chapter, we’ll look at how to manage and operate existing environments </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">using Terraform.</span></span></p>
</div>
</body></html>