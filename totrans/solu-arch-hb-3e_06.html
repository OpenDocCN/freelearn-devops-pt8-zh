<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer116">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 class="chapterTitle" id="_idParaDest-184"><span class="koboSpan" id="kobo.2.1">Performance Considerations</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">Experiments show that every second of application load delay causes a significant loss in an organization’s revenue. </span><span class="koboSpan" id="kobo.3.2">Therefore, an application’s performance is one of the most critical attributes of solution design that can impact the growth of your product’s adoption.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4.1">In the previous chapter, we discussed various solution architecture design patterns that can be used to solve a complex business problem. </span><span class="koboSpan" id="kobo.4.2">In this chapter, we will explore some best practices to optimize the performance of your application that need to be done at every layer and with every architecture component. </span><span class="koboSpan" id="kobo.4.3">You will learn how to choose the right technology for the various layers of your architecture to continuously improve your application’s performance. </span><span class="koboSpan" id="kobo.4.4">We will focus on the following topics in this chapter:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.5.1">Design principles for high-performance architecture</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.6.1">Technology selection for performance optimization</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.7.1">Performance considerations for mobile applications </span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.8.1">Performance testing</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.9.1">Managing performance monitoring</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.10.1">By the end of the chapter, you will understand important attributes of performance improvement, such as latency, throughput, and concurrency. </span><span class="koboSpan" id="kobo.10.2">You will be able to make better decisions regarding your choice of technology, which will help you improve performance at the various layers of architecture, such as compute, storage, database, and networking.</span></p>
<h1 class="heading-1" id="_idParaDest-185"><span class="koboSpan" id="kobo.11.1">Design principles for high-performance architecture</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.12.1">Architectural performance efficiency focuses on using application infrastructure and resources </span><a id="_idIndexMarker681"/><span class="koboSpan" id="kobo.13.1">to meet increasing demand and technological evolution. </span><span class="koboSpan" id="kobo.13.2">Performance efficiency guides architects to create systems that not only meet current needs but are also agile enough to scale and evolve, ensuring that performance remains robust and responsive as user expectations and technological landscapes shift. </span><span class="koboSpan" id="kobo.13.3">Let’s examine some vital design principles for your workload performance optimization.</span></p>
<h2 class="heading-2" id="_idParaDest-186"><span class="koboSpan" id="kobo.14.1">Reducing latency</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.15.1">Latency can significantly affect your product adoption because users are looking for the fastest applications. </span><span class="koboSpan" id="kobo.15.2">It doesn’t matter where your users are located; you need to provide an efficient </span><a id="_idIndexMarker682"/><span class="koboSpan" id="kobo.16.1">and reliable service for your product to grow. </span><span class="koboSpan" id="kobo.16.2">Latency is a measure of the time taken for a packet of data to get from one designated point to another. </span><span class="koboSpan" id="kobo.16.3">In simpler terms, it’s the delay or lag you experience between initiating an action and seeing the response on your device or system. </span><span class="koboSpan" id="kobo.16.4">This delay can be influenced by various factors, including the physical distance between the client and server, the speed of the transmission medium (such as fiber-optic cables or wireless signals), and how busy the network is.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.17.1">For example, consider you’re browsing a website. </span><span class="koboSpan" id="kobo.17.2">When you click a link or press a button, a request is sent from your device to the website’s server. </span><span class="koboSpan" id="kobo.17.3">This server could be located in the same city as you, or it might be halfway around the world. </span><span class="koboSpan" id="kobo.17.4">The time it takes for your request to travel to the server, for the server to process that request, and then to send back a response, is what we call latency. </span><span class="koboSpan" id="kobo.17.5">You may not achieve zero latency, but the goal should be for the response time to be within the users’ tolerance limit.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.18.1">As shown in the following diagram, imagine a scenario where it takes 600 </span><strong class="keyWord"><span class="koboSpan" id="kobo.19.1">milliseconds</span></strong><span class="koboSpan" id="kobo.20.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.21.1">ms</span></strong><span class="koboSpan" id="kobo.22.1">) for a message to travel from your device to the server (this could be because of the physical distance the data needs to travel or because the data packets are being routed through multiple intermediary devices, such as routers and switches). </span><span class="koboSpan" id="kobo.22.2">If the server takes another 900 ms to process the request and send back a response, the total latency experienced would be 1.5 seconds (1,500 ms). </span><span class="koboSpan" id="kobo.22.3">During this time, you might notice a delay in the web page loading.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.23.1"><img alt="" role="presentation" src="../Images/B21336_06_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.24.1">Figure 6.1: Request-response latency in a client-server model</span></p>
<p class="normal"><span class="koboSpan" id="kobo.25.1">Now, any application needs to access the internet to have a diverse set of global users around the world as consumers. </span><span class="koboSpan" id="kobo.25.2">These users expect consistency in performance, regardless </span><a id="_idIndexMarker683"/><span class="koboSpan" id="kobo.26.1">of their geographical location. </span><span class="koboSpan" id="kobo.26.2">It is sometimes challenging because moving data over the network from one part of the world to another takes time.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.27.1">Various factors, such as the </span><strong class="keyWord"><span class="koboSpan" id="kobo.28.1">network transmission medium</span></strong><span class="koboSpan" id="kobo.29.1">, </span><strong class="keyWord"><span class="koboSpan" id="kobo.30.1">router hops</span></strong><span class="koboSpan" id="kobo.31.1">, and </span><strong class="keyWord"><span class="koboSpan" id="kobo.32.1">propagation, </span></strong><span class="koboSpan" id="kobo.33.1">can cause network latency. </span><span class="koboSpan" id="kobo.33.2">Enterprises commonly use a fiber-optic line to set up connectivity between their corporate network and the cloud, which helps to prevent inconsistency. </span><span class="koboSpan" id="kobo.33.3">Organizations can also utilize a </span><strong class="keyWord"><span class="koboSpan" id="kobo.34.1">content distribution network</span></strong><span class="koboSpan" id="kobo.35.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.36.1">CDN</span></strong><span class="koboSpan" id="kobo.37.1">) to store </span><a id="_idIndexMarker684"/><span class="koboSpan" id="kobo.38.1">heavy image and video data near user locations to reduce network latency and improve performance. </span><span class="koboSpan" id="kobo.38.2">With edge locations, it is easier to deploy workloads close to the user base.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.39.1">In addition to the problems caused by the network, latency can occur in various architecture components. </span><span class="koboSpan" id="kobo.39.2">Your compute server can have latency issues at the infrastructure level due to memory and processor problems, where the data transfer between the </span><a id="_idIndexMarker685"/><span class="koboSpan" id="kobo.40.1">CPU and RAM is </span><em class="italic"><span class="koboSpan" id="kobo.41.1">slow</span></em><span class="koboSpan" id="kobo.42.1">. </span><span class="koboSpan" id="kobo.42.2">The disk can have latency due to slow read and write processes. </span><span class="koboSpan" id="kobo.42.3">Latency in a </span><strong class="keyWord"><span class="koboSpan" id="kobo.43.1">hard disk drive</span></strong><span class="koboSpan" id="kobo.44.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.45.1">HDD</span></strong><span class="koboSpan" id="kobo.46.1">) depends on the time it takes to select a disk memory sector and for that sector to position itself under the head of the disk for reading and writing. </span><span class="koboSpan" id="kobo.46.2">The disk memory sector is the physical location of data in the memory disk. </span><span class="koboSpan" id="kobo.46.3">In an HDD, data is distributed in memory sectors during write operations. </span><span class="koboSpan" id="kobo.46.4">Since the disk is continuously rotating, data can be written randomly. </span><span class="koboSpan" id="kobo.46.5">During read operations, the head needs to wait for the rotation to bring it to the appropriate disk memory sector.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.47.1">At the database level, latency can be caused by slow data reads and writes due to hardware bottlenecks or slow query processing. </span><span class="koboSpan" id="kobo.47.2">Reducing the database load by distributing </span><a id="_idIndexMarker686"/><span class="koboSpan" id="kobo.48.1">the data with partitioning and sharding can reduce latency.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.49.1">Low latency means </span><em class="italic"><span class="koboSpan" id="kobo.50.1">higher throughput</span></em><span class="koboSpan" id="kobo.51.1">, as latency and throughput are directly related, so let’s learn more about throughput.</span></p>
<h2 class="heading-2" id="_idParaDest-187"><span class="koboSpan" id="kobo.52.1">Improving throughput</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.53.1">Network throughput refers to the amount of data that is successfully transferred over a network in a given period of time. </span><span class="koboSpan" id="kobo.53.2">This measure is crucial for understanding how well a network </span><a id="_idIndexMarker687"/><span class="koboSpan" id="kobo.54.1">performs under specific conditions and loads. </span><span class="koboSpan" id="kobo.54.2">Throughput can be influenced by various factors, including the network’s capacity (bandwidth), the quality of the connection, and the protocols used for data transfer. </span><span class="koboSpan" id="kobo.54.3">Bandwidth determines the maximum amount of data that can be transferred over the network.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.55.1">Throughput and latency have a direct relationship. </span><span class="koboSpan" id="kobo.55.2">Low latency means high throughput because more data can be transferred in less time. </span><span class="koboSpan" id="kobo.55.3">To understand this better, let’s use the analogy of a country’s transportation infrastructure.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.56.1">Let’s say that highways with lanes are network pipelines and cars are data packets. </span><span class="koboSpan" id="kobo.56.2">Suppose a highway has 16 lanes between 2 cities. </span><span class="koboSpan" id="kobo.56.3">Not all vehicles can reach their destination at the desired time; they may get delayed because of traffic congestion, lanes closing, or accidents. </span><span class="koboSpan" id="kobo.56.4">Here, latency determines how fast a car can travel from one city to another, while throughput tells us how many cars can reach their destinations. </span><span class="koboSpan" id="kobo.56.5">Using full bandwidth is challenging for a network because of errors and traffic congestion.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.57.1">Network throughput is measured by the amount of data sent over the network in bits per second (bps). </span><span class="koboSpan" id="kobo.57.2">Network bandwidth is the maximum size of the network’s pipeline that can be processed. </span><span class="koboSpan" id="kobo.57.3">The following diagram illustrates the amount of data transferred between the client and the server:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.58.1"><img alt="" role="presentation" src="../Images/B21336_06_02.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.59.1">Figure 6.2: Throughput in a network</span></p>
<p class="normal"><span class="koboSpan" id="kobo.60.1">In addition to the network, throughput is applicable at the disk level. </span><span class="koboSpan" id="kobo.60.2">Disk throughput is a crucial </span><a id="_idIndexMarker688"/><span class="koboSpan" id="kobo.61.1">metric that describes how fast data can be read from or written to a storage device. </span><span class="koboSpan" id="kobo.61.2">It’s measured in terms of </span><strong class="keyWord"><span class="koboSpan" id="kobo.62.1">megabytes per second</span></strong><span class="koboSpan" id="kobo.63.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.64.1">MB/s</span></strong><span class="koboSpan" id="kobo.65.1">) and is influenced by two main factors: the </span><strong class="keyWord"><span class="koboSpan" id="kobo.66.1">Input/Output Operations Per Second</span></strong><span class="koboSpan" id="kobo.67.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.68.1">IOPS</span></strong><span class="koboSpan" id="kobo.69.1">) and the size of each I/O operation (average I/O size).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.70.1">The formula to calculate disk throughput is:</span></p>
<p class="center"><span class="koboSpan" id="kobo.71.1"><img alt="" role="presentation" src="../Images/B21336_06_001.png"/></span></p>
<p class="normal"><span class="koboSpan" id="kobo.72.1">Here’s a breakdown of the formula:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.73.1">Average I/O Size</span></strong><span class="koboSpan" id="kobo.74.1"> is the average size of each read or write operation, measured in bytes. </span><span class="koboSpan" id="kobo.74.2">This can vary depending on the workload; for instance, database operations might have smaller I/O sizes compared to streaming large video files.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.75.1">IOPS</span></strong><span class="koboSpan" id="kobo.76.1"> (Input/Output Operations Per Second) measures how many read or write operations the storage can handle in one second. </span><span class="koboSpan" id="kobo.76.2">A high IOPS value indicates a fast storage system capable of handling a lot of operations in parallel.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.77.1">Throughput in MB/s</span></strong><span class="koboSpan" id="kobo.78.1"> provides a measure of the actual data transfer rate of the storage device. </span><span class="koboSpan" id="kobo.78.2">It combines the IOPS and the average I/O size to reflect how much data can be moved in and out of the storage system per second.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.79.1">To convert the result into MB/s, we divide the product of average I/O size and IOPS by 1,024*1,024 (since there are 1,024 bytes in a kilobyte and 1,024 kilobytes in a megabyte).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.80.1">Given a disk IOPS of 20,000 and an I/O size of 4 KB (which is 4 * 1,024 bytes = 4,096 bytes), you can calculate the throughput as follows:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.81.1">First, convert the I/O size from bytes to megabytes:</span><ul>
<li class="bulletList"><span class="koboSpan" id="kobo.82.1"><img alt="" role="presentation" src="../Images/B21336_06_002.png"/></span></li>
</ul>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.83.1">Then, multiply by the IOPS to get the throughput in MB/s:</span><ul>
<li class="bulletList"><span class="koboSpan" id="kobo.84.1">Throughput = I/O size in MB × IOPS</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.85.1">Throughput = 0.00390625 MB × 20,000</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.86.1">Throughput = 78.125 MB/s</span></li>
</ul>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.87.1">So, with a disk IOPS of 20,000 and an I/O size of 4 KB, the throughput is approximately 78.125 MB/s. </span><span class="koboSpan" id="kobo.87.2">This calculation shows the total amount of data that can be read from or written to the disk per second under these conditions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.88.1">At </span><a id="_idIndexMarker689"/><span class="koboSpan" id="kobo.89.1">the operating system level, throughput is determined by the amount of data transferred between the CPU and RAM per second. </span><span class="koboSpan" id="kobo.89.2">At the database level, throughput is determined by the number of transactions a database can process per second. </span><span class="koboSpan" id="kobo.89.3">At the application level, your code needs to handle transactions that can be processed every second by managing the application memory with the help of garbage collection handling and efficient use of the memory cache.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.90.1">When you look at latency, throughput, and bandwidth, there is another factor called concurrency, which applies to the various architecture components and helps improve application performance. </span><span class="koboSpan" id="kobo.90.2">Let’s learn more about concurrency.</span></p>
<h2 class="heading-2" id="_idParaDest-188"><span class="koboSpan" id="kobo.91.1">Handling concurrency</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.92.1">Concurrency </span><a id="_idIndexMarker690"/><span class="koboSpan" id="kobo.93.1">plays a vital role in designing scalable and efficient applications. </span><span class="koboSpan" id="kobo.93.2">It allows an application to perform multiple tasks simultaneously, making better use of system resources and improving overall application performance. </span><span class="koboSpan" id="kobo.93.3">By implementing concurrency, developers can ensure that their applications can handle multiple operations at the same time without waiting for one task to complete before starting another. </span><span class="koboSpan" id="kobo.93.4">This is particularly important in web applications that serve thousands of users and in data processing tasks that need to handle large volumes of data efficiently. </span><span class="koboSpan" id="kobo.93.5">Implementing concurrency can lead to significant improvements in response times and throughput, enhancing the user experience and the application’s ability to scale. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.94.1">Parallelism is another crucial concept in software design, complementing concurrency by executing multiple operations simultaneously across different processors or cores. </span><span class="koboSpan" id="kobo.94.2">While concurrency involves dealing with many tasks at once (for example, multitasking on a </span><a id="_idIndexMarker691"/><span class="koboSpan" id="kobo.95.1">single-core CPU, where tasks are switched rapidly to give the appearance of simultaneous execution), parallelism takes this a step further by truly performing multiple operations at the same time via multi-core processors or distributed systems. </span><span class="koboSpan" id="kobo.95.2">This approach significantly speeds up processing times for compute-intensive tasks by dividing the work into small chunks that can be processed in parallel. </span><span class="koboSpan" id="kobo.95.3">Applications that process large datasets, complex calculations, or tasks that can be divided into independent units benefit greatly from parallelism, achieving higher throughput and efficiency.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.96.1">As illustrated in the following diagram, concurrency is like a traffic light signal that controls where traffic flows between all four lanes. </span><span class="koboSpan" id="kobo.96.2">As there is a single thread along which you should pass all traffic, processing in other lanes must stop while traffic in one lane is in the </span><em class="italic"><span class="koboSpan" id="kobo.97.1">clearing process</span></em><span class="koboSpan" id="kobo.98.1">. </span><span class="koboSpan" id="kobo.98.2">In the case of parallelism, there is a parallel lane available, and all cars can run in parallel without interrupting each other, as shown in the following diagram:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.99.1"><img alt="" role="presentation" src="../Images/B21336_06_05.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.100.1">Figure 6.3: Concurrency versus parallelism</span></p>
<p class="normal"><span class="koboSpan" id="kobo.101.1">A database is always the central point of architectural design. </span><span class="koboSpan" id="kobo.101.2">Concurrency plays an essential role in data handling, as the database should have the ability to respond to multiple requests simultaneously. </span><span class="koboSpan" id="kobo.101.3">Database concurrency is more complicated as one user </span><a id="_idIndexMarker692"/><span class="koboSpan" id="kobo.102.1">might be trying to read a record while another user is updating it simultaneously. </span><span class="koboSpan" id="kobo.102.2">The database should only allow data to be viewed when it is fully saved. </span><span class="koboSpan" id="kobo.102.3">Ensure the data is completely committed before another user tries to update it.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.103.1">Caching can improve performance significantly; let’s learn about some different cache types in architecture.</span></p>
<h2 class="heading-2" id="_idParaDest-189"><span class="koboSpan" id="kobo.104.1">Applying caching</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.105.1">In </span><em class="chapterRef"><span class="koboSpan" id="kobo.106.1">Chapter 4</span></em><span class="koboSpan" id="kobo.107.1">, </span><em class="italic"><span class="koboSpan" id="kobo.108.1">Solution Architecture Design Patterns</span></em><span class="koboSpan" id="kobo.109.1">, you learned how to apply caching at various </span><a id="_idIndexMarker693"/><span class="koboSpan" id="kobo.110.1">levels of architecture in the </span><em class="italic"><span class="koboSpan" id="kobo.111.1">Cache-based architecture</span></em><span class="koboSpan" id="kobo.112.1"> section. </span><span class="koboSpan" id="kobo.112.2">Caching helps to improve application performance significantly. </span><span class="koboSpan" id="kobo.112.3">Although you have learned about the different design patterns to apply to the cache by adding an external caching engine and technology </span><a id="_idIndexMarker694"/><span class="koboSpan" id="kobo.113.1">such as a </span><strong class="keyWord"><span class="koboSpan" id="kobo.114.1">content delivery network</span></strong><span class="koboSpan" id="kobo.115.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.116.1">CDN</span></strong><span class="koboSpan" id="kobo.117.1">), it’s essential to understand that almost every application component and infrastructure has a cache mechanism. </span><span class="koboSpan" id="kobo.117.2">Utilizing the caching mechanism at each layer can help reduce latency and improve the application’s performance.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.118.1">The CPU has its hardware cache at the server level, which reduces the latency when accessing data from the main memory. </span><span class="koboSpan" id="kobo.118.2">The CPU cache includes the instruction and data cache; the data cache stores copies of frequently used data. </span><span class="koboSpan" id="kobo.118.3">The cache is also used at the disk level, but it is </span><a id="_idIndexMarker695"/><span class="koboSpan" id="kobo.119.1">managed by operating system software (known as the </span><strong class="keyWord"><span class="koboSpan" id="kobo.120.1">page cache</span></strong><span class="koboSpan" id="kobo.121.1">); however, the CPU cache is entirely managed by hardware. </span><span class="koboSpan" id="kobo.121.2">The disk cache originates from secondary storage, such as the HDD or </span><strong class="keyWord"><span class="koboSpan" id="kobo.122.1">solid-state drive</span></strong><span class="koboSpan" id="kobo.123.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.124.1">SSD</span></strong><span class="koboSpan" id="kobo.125.1">). </span><span class="koboSpan" id="kobo.125.2">Frequently </span><a id="_idIndexMarker696"/><span class="koboSpan" id="kobo.126.1">used data is stored in an unused portion of the main memory (that is, the RAM as the page cache, which results in quicker access to content).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.127.1">Often, databases have a cache mechanism that saves the results from the database in order to respond more quickly. </span><span class="koboSpan" id="kobo.127.2">They have an internal cache that gets data ready in the cache based </span><a id="_idIndexMarker697"/><span class="koboSpan" id="kobo.128.1">on your usage patterns. </span><span class="koboSpan" id="kobo.128.2">They also have a query cache that saves data in the main server memory (RAM) if you make a query more than once. </span><span class="koboSpan" id="kobo.128.3">The query cache gets cleared in case any data changes inside the table. </span><span class="koboSpan" id="kobo.128.4">If the server runs out of memory, the oldest query result gets deleted to make space.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.129.1">You have a DNS cache at the network level that stores the web domain name and corresponding IP address locally on the server. </span><span class="koboSpan" id="kobo.129.2">If you revisit the same website domain name, DNS caching allows a quick DNS lookup. </span><span class="koboSpan" id="kobo.129.3">The operating system manages the DNS cache and contains all recent website visits. </span><span class="koboSpan" id="kobo.129.4">You learned about client-side cache mechanisms such as the </span><strong class="keyWord"><span class="koboSpan" id="kobo.130.1">browser cache</span></strong><span class="koboSpan" id="kobo.131.1"> and caching engines such as </span><strong class="keyWord"><span class="koboSpan" id="kobo.132.1">Memcached</span></strong><span class="koboSpan" id="kobo.133.1"> and </span><strong class="keyWord"><span class="koboSpan" id="kobo.134.1">Redis</span></strong><span class="koboSpan" id="kobo.135.1"> in </span><em class="chapterRef"><span class="koboSpan" id="kobo.136.1">Chapter 4</span></em><span class="koboSpan" id="kobo.137.1">, </span><em class="italic"><span class="koboSpan" id="kobo.138.1">Solution Architecture Design Patterns</span></em><span class="koboSpan" id="kobo.139.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.140.1">In this section on design principles for high-performance architecture, you learned about the original design factors, such as latency, throughput, concurrency, and caching, that need to be addressed in order to optimize architecture performance. </span><span class="koboSpan" id="kobo.140.2">Each component of the architecture (whether it is a network at the server level or an application at the database level) has a certain degree of latency and a concurrency issue that needs to be handled.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.141.1">You should design your application for the desired performance because improving performance comes at a cost. </span><span class="koboSpan" id="kobo.141.2">The specifics of performance optimization may differ from application to application. </span><span class="koboSpan" id="kobo.141.3">The solution architecture needs to direct the effort accordingly—for example, a stock-trading application cannot tolerate even sub-millisecond </span><a id="_idIndexMarker698"/><span class="koboSpan" id="kobo.142.1">latency. </span><span class="koboSpan" id="kobo.142.2">On the other hand, an e-commerce website can live with a couple of seconds’ latency. </span><span class="koboSpan" id="kobo.142.3">To overcome performance challenges, let’s learn about selecting technology for various architecture levels.</span></p>
<h1 class="heading-1" id="_idParaDest-190"><span class="koboSpan" id="kobo.143.1">Technology selection for performance optimization</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.144.1">In </span><em class="chapterRef"><span class="koboSpan" id="kobo.145.1">Chapter 4</span></em><span class="koboSpan" id="kobo.146.1"> and </span><em class="chapterRef"><span class="koboSpan" id="kobo.147.1">Chapter 5</span></em><span class="koboSpan" id="kobo.148.1">, you learned about various design patterns, including microservice, event-driven, cached-based, and stateless patterns. </span><span class="koboSpan" id="kobo.148.2">An organization may choose a combination </span><a id="_idIndexMarker699"/><span class="koboSpan" id="kobo.149.1">of these design patterns depending on their solution’s design needs. </span><span class="koboSpan" id="kobo.149.2">You can have multiple approaches to architecture design, depending on your workload. </span><span class="koboSpan" id="kobo.149.3">Once you have finalized your strategy and start to implement your solution, the next step is to optimize your application. </span><span class="koboSpan" id="kobo.149.4">To optimize your application, you must collect data by performing load testing and defining benchmarking as per your application’s performance requirements.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.150.1">Performance optimization is a continuous improvement process in which you need to be cognizant of optimal resource utilization from the beginning of solution design until after the application’s launch. </span><span class="koboSpan" id="kobo.150.2">You need to choose the right resources as per the workload or tune the application and infrastructure configuration. </span><span class="koboSpan" id="kobo.150.3">For example, you might select a NoSQL database to store your application’s session state and store transactions in a relational database.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.151.1">For analytics and reporting purposes, you can offload your production database by loading data from the application database into data warehousing solutions and creating reports from there.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.152.1">In the case of servers, you can choose a virtual machine or containers. </span><span class="koboSpan" id="kobo.152.2">You can take an entirely serverless approach to build and deploy your application code. </span><span class="koboSpan" id="kobo.152.3">Regardless of your approach and application workload, you need to choose the primary resource type: compute, storage, database, or network. </span><span class="koboSpan" id="kobo.152.4">Let’s look in more detail at selecting these resource types for performance optimization.</span></p>
<h2 class="heading-2" id="_idParaDest-191"><span class="koboSpan" id="kobo.153.1">Making a computational choice</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.154.1">In this section, you will see the use of the term </span><em class="italic"><span class="koboSpan" id="kobo.155.1">compute</span></em><span class="koboSpan" id="kobo.156.1"> instead of </span><em class="italic"><span class="koboSpan" id="kobo.157.1">server</span></em><span class="koboSpan" id="kobo.158.1">, as software deployments are not limited to servers nowadays. </span><span class="koboSpan" id="kobo.158.2">A public cloud provider such as AWS has </span><a id="_idIndexMarker700"/><span class="koboSpan" id="kobo.159.1">serverless offerings, where you don’t need a server to run your application. </span><span class="koboSpan" id="kobo.159.2">One of the most popular FaaS offerings is AWS Lambda. </span><span class="koboSpan" id="kobo.159.3">Like AWS Lambda, other popular public cloud providers provide solutions in the FaaS space—for example, Microsoft Azure has Azure Functions, and GCP has Google Cloud Functions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.160.1">However, organizations still make the default choice to go for servers with virtual machines. </span><span class="koboSpan" id="kobo.160.2">Containers are also becoming popular as the need for automation and resource utilization </span><a id="_idIndexMarker701"/><span class="koboSpan" id="kobo.161.1">has increased. </span><span class="koboSpan" id="kobo.161.2">Containers are becoming the preferred choice, especially in the area of microservice application deployment.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.162.1">The optimal choice of computing—whether you want to choose server instances, containers, or go serverless—depends upon your application’s use case. </span><span class="koboSpan" id="kobo.162.2">Let’s look at the various computing choices.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.163.1">The following </span><a id="_idIndexMarker702"/><span class="koboSpan" id="kobo.164.1">table provides a snapshot of the differences </span><a id="_idIndexMarker703"/><span class="koboSpan" id="kobo.165.1">between CPUs, </span><strong class="keyWord"><span class="koboSpan" id="kobo.166.1">Graphics Processing Units</span></strong><span class="koboSpan" id="kobo.167.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.168.1">GPUs</span></strong><span class="koboSpan" id="kobo.169.1">), </span><strong class="keyWord"><span class="koboSpan" id="kobo.170.1">Field Programmable Gate Arrays</span></strong><span class="koboSpan" id="kobo.171.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.172.1">FPGAs</span></strong><span class="koboSpan" id="kobo.173.1">), and </span><strong class="keyWord"><span class="koboSpan" id="kobo.174.1">Application-Specific Integrated Circuits</span></strong><span class="koboSpan" id="kobo.175.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.176.1">ASICs</span></strong><span class="koboSpan" id="kobo.177.1">), focusing on their primary uses, ease of programming, core </span><a id="_idIndexMarker704"/><span class="koboSpan" id="kobo.178.1">structures, cost implications, and their suitability for parallel processing, among other features. </span><span class="koboSpan" id="kobo.178.2">Let’s first define each of these terms:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.179.1">CPU</span></strong><span class="koboSpan" id="kobo.180.1">: The primary processor within a computer that performs most of the data processing operations, often referred to as the “brain” of the computer</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.181.1">GPU</span></strong><span class="koboSpan" id="kobo.182.1">: A specialized electronic circuit designed to rapidly manipulate and alter memory to accelerate the creation of images in a frame buffer intended for output to a display</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.183.1">FPGA</span></strong><span class="koboSpan" id="kobo.184.1">: An integrated circuit designed to be configured by a customer or a designer after manufacturing – hence “field-programmable”</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.185.1">ASIC</span></strong><span class="koboSpan" id="kobo.186.1">: A chip customized for a particular use, rather than intended for general-purpose use</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.187.1">You might use one or more of these processing unit choices as your workload varies.</span></p>
<table class="table-container" id="table001-2">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.188.1">Feature</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.189.1">CPU</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.190.1">GPU</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.191.1">FPGA</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.192.1">ASIC</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.193.1">Primary Use</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.194.1">General-purpose applications</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.195.1">Graphics processing, large data use cases</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.196.1">Programmable hardware for specific tasks</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.197.1">Custom integrated circuits for specific applications</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.198.1">Programming Ease</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.199.1">Easy</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.200.1">Requires knowledge of specific libraries (e.g., CUDA)</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.201.1">Complex, requires hardware programming</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.202.1">N/A (hardware is custom-designed)</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.203.1">Multitasking</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.204.1">Yes</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.205.1">Limited by design focus on parallelism</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.206.1">Yes, with reconfiguration</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.207.1">No, single-purpose</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.208.1">Versatility</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.209.1">High</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.210.1">Moderate</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.211.1">Moderate, reconfigurable for tasks</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.212.1">Low, application-specific</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.213.1">Performance Measurement</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.214.1">GHz (billions of cycles per second)</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.215.1">TFLOP (trillions of floating-point operations per second)</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.216.1">Not typically measured in Flops (floating point operations per second)</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.217.1">Optimized for power consumption and performance</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.218.1">Core Structure</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.219.1">Few large cores</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.220.1">Thousands of small cores</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.221.1">Logic elements that can be reconfigured</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.222.1">N/A (custom-designed)</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.223.1">Parallel Processing</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.224.1">Limited</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.225.1">High, with </span><strong class="keyWord"><span class="koboSpan" id="kobo.226.1">Massively Parallel Processing </span></strong><span class="koboSpan" id="kobo.227.1">(</span><strong class="keyWord"><span class="koboSpan" id="kobo.228.1">MPP</span></strong><span class="koboSpan" id="kobo.229.1">)</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.230.1">Accommodates MPP, configurable as CPU</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.231.1">Optimized for specific applications</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.232.1">Cost</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.233.1">Low</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.234.1">Higher than CPUs</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.235.1">Higher than CPUs and GPUs, requires customization</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.236.1">Highest, due to custom design and long development cycle</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.237.1">Power Consumption</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.238.1">Moderate</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.239.1">High</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.240.1">Low</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.241.1">Optimized for the application</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.242.1">Flexibility</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.243.1">Versatile for a range of applications</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.244.1">Specific to compute-intensive applications</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.245.1">Reconfigurable but requires development</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.246.1">Fixed, requires redesign for changes</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.247.1">Development Cycle</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.248.1">Short</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.249.1">Short to moderate</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.250.1">Long, due to the need for customization</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.251.1">Longest, hardware-level redesign needed</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.252.1">Table 6.1: Comparison of the various processor types</span></p>
<p class="normal"><span class="koboSpan" id="kobo.253.1">The </span><a id="_idIndexMarker705"/><span class="koboSpan" id="kobo.254.1">preceding table compares the types of processing. </span><span class="koboSpan" id="kobo.254.2">The ASIC is the most efficient but has a long development cycle to implement. </span><span class="koboSpan" id="kobo.254.3">ASICs provide the most optimal performance but have the least flexibility to reutilize, while CPUs are very flexible and can fit many use cases.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.255.1">Today, the </span><a id="_idIndexMarker706"/><span class="koboSpan" id="kobo.256.1">CPU has become a commodity and is used everywhere for general-purpose devices to keep costs low. </span><span class="koboSpan" id="kobo.256.2">The GPU has become famous for compute-intensive applications, and the FPGA has become the first choice where more customized performance is required. </span><span class="koboSpan" id="kobo.256.3">These processing choices are available from public cloud providers, such as AWS.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.257.1">In this section, you learned about the most popular computing choices. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.258.1">You may </span><a id="_idIndexMarker707"/><span class="koboSpan" id="kobo.259.1">also hear about other types of processors, such as the </span><strong class="keyWord"><span class="koboSpan" id="kobo.260.1">accelerated processing unit</span></strong><span class="koboSpan" id="kobo.261.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.262.1">APU</span></strong><span class="koboSpan" id="kobo.263.1">). </span><span class="koboSpan" id="kobo.263.2">The APU combines </span><a id="_idIndexMarker708"/><span class="koboSpan" id="kobo.264.1">the CPU, GPU, and </span><strong class="keyWord"><span class="koboSpan" id="kobo.265.1">digital signal processor</span></strong><span class="koboSpan" id="kobo.266.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.267.1">DSP</span></strong><span class="koboSpan" id="kobo.268.1">), which is optimized to analyze analog signals and requires high-speed real-time data processing.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.269.1">Let’s learn more about other popular compute-type containers that are rapidly gaining popularity because of their ability to optimize the use of resources within the virtual machine.</span></p>
<h3 class="heading-3" id="_idParaDest-192"><span class="koboSpan" id="kobo.270.1">Working with containers</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.271.1">In </span><em class="chapterRef"><span class="koboSpan" id="kobo.272.1">Chapter 4</span></em><span class="koboSpan" id="kobo.273.1">, </span><em class="italic"><span class="koboSpan" id="kobo.274.1">Solution Architecture Design Patterns</span></em><span class="koboSpan" id="kobo.275.1">, you learned about the benefits of container deployment in the section titled </span><em class="italic"><span class="koboSpan" id="kobo.276.1">Deploying an application with a container</span></em><span class="koboSpan" id="kobo.277.1">. </span><span class="koboSpan" id="kobo.277.2">The use of </span><a id="_idIndexMarker709"/><span class="koboSpan" id="kobo.278.1">containers is becoming the norm for deploying complex microservice applications because of the ease of automation and resource utilization efficiency. </span><span class="koboSpan" id="kobo.278.2">There are various platforms available for container deployment.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.279.1">Because of their </span><a id="_idIndexMarker710"/><span class="koboSpan" id="kobo.280.1">popularity and platform-independent capabilities, containers have become the first choice for building cloud-agnostic platforms. </span><span class="koboSpan" id="kobo.280.2">You can deploy containers in your on-premises data center and manage them through your cloud. </span><span class="koboSpan" id="kobo.280.3">Also, you can take a relocation approach and move a container from on-premises to the cloud without having to make any changes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.281.1">You can build a multi-cloud platform with a container, and now, each major public cloud vendor provides tools for managing a container environment spread over multiple platforms. </span><span class="koboSpan" id="kobo.281.2">For </span><a id="_idIndexMarker711"/><span class="koboSpan" id="kobo.282.1">example, AWS provides </span><strong class="keyWord"><span class="koboSpan" id="kobo.283.1">Elastic Container Service</span></strong><span class="koboSpan" id="kobo.284.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.285.1">ECS</span></strong><span class="koboSpan" id="kobo.286.1">) </span><strong class="keyWord"><span class="koboSpan" id="kobo.287.1">Anywhere</span></strong><span class="koboSpan" id="kobo.288.1">, enabling you to run and manage container workloads on customer-managed infrastructure easily. </span><span class="koboSpan" id="kobo.288.2">Similarly, GCP provides </span><strong class="keyWord"><span class="koboSpan" id="kobo.289.1">Google Anthos</span></strong><span class="koboSpan" id="kobo.290.1">, which gives </span><a id="_idIndexMarker712"/><span class="koboSpan" id="kobo.291.1">you container management across on-premises and other cloud platforms. </span><span class="koboSpan" id="kobo.291.2">Let’s learn about some of the most popular choices in the container area, their differences, and how they work together.</span></p>
<h4 class="heading-4"><span class="koboSpan" id="kobo.292.1">Docker</span></h4>
<p class="normal"><span class="koboSpan" id="kobo.293.1">Docker is one </span><a id="_idIndexMarker713"/><span class="koboSpan" id="kobo.294.1">of the most in-demand technologies. </span><span class="koboSpan" id="kobo.294.2">It allows you to package an application and its related dependencies together as a container and deploy it to any operating system platform. </span><span class="koboSpan" id="kobo.294.3">Docker provides platform-independent capabilities to a software application, making the overall software development, testing, and deployment process simple and accessible.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.295.1">Docker containers help you to build a more complex multilayer application. </span><span class="koboSpan" id="kobo.295.2">For example, you need to run the application server, database, and message queue together. </span><span class="koboSpan" id="kobo.295.3">In that case, you can run them side by side using different Docker images and establish communication between them. </span><span class="koboSpan" id="kobo.295.4">Each of these layers may have modified library versions, and Docker allows them to run on the same computing machine without conflicts.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.296.1">Docker container images are portable from one system to another over a local network or across the internet using Docker Hub. </span><span class="koboSpan" id="kobo.296.2">You can manage and distribute your container using a Docker Hub container repository. </span><span class="koboSpan" id="kobo.296.3">Suppose you make changes in the Docker image that cause environmental issues. </span><span class="koboSpan" id="kobo.296.4">In that case, it’s easy to revert to the working version of the container image, making overall troubleshooting easier.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.297.1">When using Docker, the development team builds an application and packages it with the required dependencies into a container image. </span><span class="koboSpan" id="kobo.297.2">This application image is run in a container on </span><a id="_idIndexMarker714"/><span class="koboSpan" id="kobo.298.1">the Docker host. </span><span class="koboSpan" id="kobo.298.2">Just as you manage code in a code repository such as GitHub, in the same way, a Docker image should be stored in a registry. </span><span class="koboSpan" id="kobo.298.3">Docker </span><a id="_idIndexMarker715"/><span class="koboSpan" id="kobo.299.1">Hub is a public registry, and other public </span><a id="_idIndexMarker716"/><span class="koboSpan" id="kobo.300.1">cloud vendors provide their own registries, such as </span><strong class="keyWord"><span class="koboSpan" id="kobo.301.1">AWS</span></strong> <strong class="keyWord"><span class="koboSpan" id="kobo.302.1">Elastic Container Registry</span></strong><span class="koboSpan" id="kobo.303.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.304.1">ECR</span></strong><span class="koboSpan" id="kobo.305.1">) and </span><strong class="keyWord"><span class="koboSpan" id="kobo.306.1">Azure Container Registry</span></strong><span class="koboSpan" id="kobo.307.1">. </span><span class="koboSpan" id="kobo.307.2">In addition, you can have a private registry on-premises for your Docker images.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.308.1">Public cloud providers like AWS provide container management platforms, such as </span><strong class="keyWord"><span class="koboSpan" id="kobo.309.1">Amazon ECS</span></strong><span class="koboSpan" id="kobo.310.1">. </span><span class="koboSpan" id="kobo.310.2">Container </span><a id="_idIndexMarker717"/><span class="koboSpan" id="kobo.311.1">management manages Docker containers on top of the cloud virtual machine, Amazon EC2. </span><span class="koboSpan" id="kobo.311.2">AWS also provides a serverless option of container deployment using Amazon Fargate, where you can deploy containers without provisioning virtual machines.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.312.1">Complex enterprise applications are built based on microservices that may span multiple containers. </span><span class="koboSpan" id="kobo.312.2">Managing various Docker containers as a part of one application can be complicated. </span><span class="koboSpan" id="kobo.312.3">Kubernetes helps solve the multi-container environment’s challenges; let’s learn more about Kubernetes.</span></p>
<h4 class="heading-4"><span class="koboSpan" id="kobo.313.1">Kubernetes</span></h4>
<p class="normal"><span class="koboSpan" id="kobo.314.1">Kubernetes excels in managing and orchestrating multiple containers in production settings, functioning </span><a id="_idIndexMarker718"/><span class="koboSpan" id="kobo.315.1">as a comprehensive container orchestration system. </span><span class="koboSpan" id="kobo.315.2">It supports hosting Docker containers on either physical servers or virtual machine nodes, which are commonly referred to as worker nodes. </span><span class="koboSpan" id="kobo.315.3">Kubernetes efficiently coordinates operations across a cluster of these nodes, automating tasks such as deployment, scaling, and the management of containerized applications, thus ensuring smooth and reliable application performance across the infrastructure.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.316.1">Kubernetes makes your application self-healing by replacing unresponsive containers in the case of any application error. </span><span class="koboSpan" id="kobo.316.2">It also provides horizontal scaling capabilities and a blue-green deployment ability to prevent downtime. </span><span class="koboSpan" id="kobo.316.3">Kubernetes distributes incoming user traffic load between the containers and manages the storage shared by various containers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.317.1">The following diagram shows that Kubernetes and Docker work well together to orchestrate your </span><a id="_idIndexMarker719"/><span class="koboSpan" id="kobo.318.1">software application. </span><span class="koboSpan" id="kobo.318.2">Kubernetes handles network communication between worker nodes and Docker containers:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.319.1"><img alt="" role="presentation" src="../Images/B21336_06_06.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.320.1">Figure 6.4: Docker and Kubernetes</span></p>
<p class="normal"><span class="koboSpan" id="kobo.321.1">Docker works as an individual piece of the application, and Kubernetes takes care of the orchestration to make sure all these pieces work together as designed. </span><span class="koboSpan" id="kobo.321.2">It’s easy to automate overall application deployment and scaling with Kubernetes. </span><span class="koboSpan" id="kobo.321.3">In Docker, containers are hosted in nodes, and each Docker container in a single node shares the same IP space. </span><span class="koboSpan" id="kobo.321.4">In Docker, you must manage the connections between containers by handling any IP conflict. </span><span class="koboSpan" id="kobo.321.5">Kubernetes solves this problem by having a primary instance that keeps track of all nodes hosting Pods.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.322.1">Kubernetes’s primary node assigns an IP address and hosts a key-value store for container configuration and a </span><strong class="keyWord"><span class="koboSpan" id="kobo.323.1">kubelet</span></strong><span class="koboSpan" id="kobo.324.1"> to manage the containers. </span><span class="koboSpan" id="kobo.324.2">The kubelet is the primary “node agent” that </span><a id="_idIndexMarker720"/><span class="koboSpan" id="kobo.325.1">runs on each node and ensures that the containers defined in the Pods are started and continue running. </span><span class="koboSpan" id="kobo.325.2">Docker containers are grouped into </span><strong class="keyWord"><span class="koboSpan" id="kobo.326.1">Pods</span></strong><span class="koboSpan" id="kobo.327.1"> that share the same IP address. </span><span class="koboSpan" id="kobo.327.2">This </span><a id="_idIndexMarker721"/><span class="koboSpan" id="kobo.328.1">entire setup is called a </span><strong class="keyWord"><span class="koboSpan" id="kobo.329.1">Kubernetes cluster</span></strong><span class="koboSpan" id="kobo.330.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.331.1">Kubernetes is </span><a id="_idIndexMarker722"/><span class="koboSpan" id="kobo.332.1">complex to maintain. </span><span class="koboSpan" id="kobo.332.2">Cloud providers supply their own management tools for it. </span><span class="koboSpan" id="kobo.332.3">For example, AWS provides Amazon </span><strong class="keyWord"><span class="koboSpan" id="kobo.333.1">Elastic Kubernetes Service</span></strong><span class="koboSpan" id="kobo.334.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.335.1">EKS</span></strong><span class="koboSpan" id="kobo.336.1">) to simplify </span><a id="_idIndexMarker723"/><span class="koboSpan" id="kobo.337.1">the management of the Kubernetes cluster. </span><span class="koboSpan" id="kobo.337.2">OpenShift is another Kubernetes distribution managed by Red Hat and is </span><a id="_idIndexMarker724"/><span class="koboSpan" id="kobo.338.1">offered as a </span><strong class="keyWord"><span class="koboSpan" id="kobo.339.1">Platform as a Service</span></strong><span class="koboSpan" id="kobo.340.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.341.1">PaaS</span></strong><span class="koboSpan" id="kobo.342.1">). </span><span class="koboSpan" id="kobo.342.2">Similarly, Microsoft </span><a id="_idIndexMarker725"/><span class="koboSpan" id="kobo.343.1">Azure provides </span><strong class="keyWord"><span class="koboSpan" id="kobo.344.1">Azure Kubernetes Service</span></strong><span class="koboSpan" id="kobo.345.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.346.1">AKS</span></strong><span class="koboSpan" id="kobo.347.1">), and </span><a id="_idIndexMarker726"/><span class="koboSpan" id="kobo.348.1">GCP provides </span><strong class="keyWord"><span class="koboSpan" id="kobo.349.1">Google Kubernetes Engine</span></strong><span class="koboSpan" id="kobo.350.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.351.1">GKE</span></strong><span class="koboSpan" id="kobo.352.1">), offering a simple way to deploy, scale, and manage Kubernetes automatically.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.353.1">Overall, containers add a layer of virtualization to the whole application infrastructure. </span><span class="koboSpan" id="kobo.353.2">While they are helpful in resource utilization, choose a bare-metal physical machine for your application deployment if it requires ultra-low latency.</span></p>
<h3 class="heading-3" id="_idParaDest-193"><span class="koboSpan" id="kobo.354.1">Going serverless</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.355.1">In recent years, serverless computing has become possible because of the popularity of public cloud </span><a id="_idIndexMarker727"/><span class="koboSpan" id="kobo.356.1">solutions from cloud providers such as Amazon, Google, and Microsoft. </span><span class="koboSpan" id="kobo.356.2">Serverless computing allows developers to focus on their code and application development without worrying about underlying provisioning, configuring, and scaling infrastructure. </span><span class="koboSpan" id="kobo.356.3">Serverless solutions abstract server </span><a id="_idIndexMarker728"/><span class="koboSpan" id="kobo.357.1">management and infrastructure decisions from developers and let them focus on their area of expertise and the business problem they are trying </span><a id="_idIndexMarker729"/><span class="koboSpan" id="kobo.358.1">to solve. </span><span class="koboSpan" id="kobo.358.2">Serverless computing brings the relatively new </span><strong class="keyWord"><span class="koboSpan" id="kobo.359.1">Function as a Service</span></strong><span class="koboSpan" id="kobo.360.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.361.1">FaaS</span></strong><span class="koboSpan" id="kobo.362.1">) concept.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.363.1">FaaS offerings are available from AWS Lambda, Microsoft Azure Functions, and Google Cloud Functions. </span><span class="koboSpan" id="kobo.363.2">For example, you can write your code in the cloud editor, and AWS Lambda handles the computing infrastructure underneath to run and scale your function. </span><span class="koboSpan" id="kobo.363.3">You can design event-based architecture or RESTful microservices by adding an API endpoint using Amazon API Gateway and AWS Lambda functions. </span><span class="koboSpan" id="kobo.363.4">Amazon API Gateway is a maintained cloud system that adds RESTful APIs and WebSocket APIs as frontends for the Lambda functions and enables real-time communication between applications. </span><span class="koboSpan" id="kobo.363.5">You can further break down your microservice into small tasks that can be scaled automatically and independently.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.364.1">In addition to focusing on your code, you never have to pay for idle resources with the FaaS model. </span><span class="koboSpan" id="kobo.364.2">Rather than scaling your entire service, you can scale the required functions independently with built-in availability and fault tolerance. </span><span class="koboSpan" id="kobo.364.3">However, this could be daunting if you have thousands of features to orchestrate, and predicting the auto-scaling cost can be tricky. </span><span class="koboSpan" id="kobo.364.4">It is perfect for scheduling jobs, processing web requests, and queuing messages.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.365.1">In this section, you have learned about the various computing choices you can make for performance </span><a id="_idIndexMarker730"/><span class="koboSpan" id="kobo.366.1">optimization. </span><span class="koboSpan" id="kobo.366.2">We looked at server instances, containers, and serverless options. </span><span class="koboSpan" id="kobo.366.3">You need to select the right computing </span><a id="_idIndexMarker731"/><span class="koboSpan" id="kobo.367.1">services for your application’s requirements. </span><span class="koboSpan" id="kobo.367.2">No rule forces you to choose a particular type of computing; it is all about your organization’s choice of technology, the pace of innovation, and the nature of the software application.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.368.1">However, you can generally stick to a virtual or bare-metal machine for a monolithic application, and for complex microservices, you can choose containers. </span><span class="koboSpan" id="kobo.368.2">For simple task scheduling or events-based applications, serverless functions are an obvious choice. </span><span class="koboSpan" id="kobo.368.3">Many organizations have built complex applications entirely on serverless computing, which helped them reduce costs and achieve high availability without managing any infrastructure.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.369.1">Let’s learn about another important aspect of your infrastructure and how it can help you to optimize performance.</span></p>
<h2 class="heading-2" id="_idParaDest-194"><span class="koboSpan" id="kobo.370.1">Making a storage choice</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.371.1">Storage plays </span><a id="_idIndexMarker732"/><span class="koboSpan" id="kobo.372.1">a pivotal role in the performance of any software </span><a id="_idIndexMarker733"/><span class="koboSpan" id="kobo.373.1">application, and the </span><a id="_idIndexMarker734"/><span class="koboSpan" id="kobo.374.1">concept of </span><strong class="keyWord"><span class="koboSpan" id="kobo.375.1">data affinity</span></strong><span class="koboSpan" id="kobo.376.1"> is crucial when discussing storage for an application. </span><span class="koboSpan" id="kobo.376.2">Data affinity refers to the strategic placement of data in proximity to the application consuming it, with the aim of reducing latency, improving performance, and ensuring efficient data retrieval.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.377.1">In a multi-cloud or hybrid cloud environment, the notion that all storage must be in immediate proximity to the application server doesn’t always hold true. </span><span class="koboSpan" id="kobo.377.2">Modern distributed systems are designed to allow data to reside in multiple locations, whether on-premises or on different cloud providers, while still maintaining acceptable levels of latency and performance. </span><span class="koboSpan" id="kobo.377.3">This flexibility is crucial for organizations that use various cloud services or for those with data residency requirements mandating certain data to remain within </span><a id="_idIndexMarker735"/><span class="koboSpan" id="kobo.378.1">specific geographical or jurisdictional boundaries.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.379.1">However, deciding </span><a id="_idIndexMarker736"/><span class="koboSpan" id="kobo.380.1">where to store data—whether close to the application service or in a different location—requires careful consideration of several factors:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.381.1">Latency requirements</span></strong><span class="koboSpan" id="kobo.382.1">: The acceptable delay between a request and a response can significantly influence where data should be stored. </span><span class="koboSpan" id="kobo.382.2">Applications requiring real-time access to data might necessitate storage solutions with minimal latency, often implying close physical or network proximity.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.383.1">Data sovereignty and compliance</span></strong><span class="koboSpan" id="kobo.384.1">: Legal and regulatory requirements might dictate where data can be stored and processed, which means the architecture will need to align with compliance mandates.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.385.1">Cost considerations</span></strong><span class="koboSpan" id="kobo.386.1">: Storing and accessing data across different locations or clouds can incur additional costs. </span><span class="koboSpan" id="kobo.386.2">It’s essential to balance performance needs with budget constraints, especially when considering data egress fees in cloud environments.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.387.1">Bandwidth and throughput</span></strong><span class="koboSpan" id="kobo.388.1">: The available network bandwidth and throughput between the application server and the data storage location can affect performance. </span><span class="koboSpan" id="kobo.388.2">High bandwidth and throughput can mitigate some latency issues, allowing for more flexible data storage options.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.389.1">Data access patterns</span></strong><span class="koboSpan" id="kobo.390.1">: Understanding how your application accesses data (e.g., frequently accessed vs. </span><span class="koboSpan" id="kobo.390.2">rarely accessed data) can help you choose the right storage location. </span><span class="koboSpan" id="kobo.390.3">Frequently accessed data might benefit from being closer to the application to speed up access times.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.391.1">Disaster recovery and availability</span></strong><span class="koboSpan" id="kobo.392.1">: Data resilience strategies might require data to be replicated across different geographical locations to ensure availability in case of failures.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.393.1">In multi-cloud strategies, implementing caching, data replication, or edge computing solutions can help maintain performance standards by keeping a synchronized copy of critical data close to the application, regardless of the primary data storage location. </span><span class="koboSpan" id="kobo.393.2">These approaches allow applications to access data with minimal latency, even if the primary data source is geographically distant.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.394.1">Selecting the </span><a id="_idIndexMarker737"/><span class="koboSpan" id="kobo.395.1">appropriate storage depends on a thorough analysis </span><a id="_idIndexMarker738"/><span class="koboSpan" id="kobo.396.1">of these factors. </span><span class="koboSpan" id="kobo.396.2">You should aim to strike a balance between operational requirements, performance, cost, and compliance. </span><span class="koboSpan" id="kobo.396.3">The ultimate goal is to architect a solution that meets the application’s performance needs while adhering to organizational, legal, and budgetary constraints.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.397.1">You first need to decide whether your data will be stored in block, file, or object storage. </span><span class="koboSpan" id="kobo.397.2">These are storage formats that store and present data differently. </span><span class="koboSpan" id="kobo.397.3">Let’s look at this in more detail.</span></p>
<h3 class="heading-3" id="_idParaDest-195"><span class="koboSpan" id="kobo.398.1">Working with block storage and storage area network</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.399.1">Block storage divides data into blocks and stores them as chunks of data. </span><span class="koboSpan" id="kobo.399.2">Each block has a unique </span><a id="_idIndexMarker739"/><span class="koboSpan" id="kobo.400.1">ID that allows the system to place data wherever it is most easily accessible, as blocks don’t store any metadata about files. </span><span class="koboSpan" id="kobo.400.2">Hence, a </span><a id="_idIndexMarker740"/><span class="koboSpan" id="kobo.401.1">server-based operating </span><a id="_idIndexMarker741"/><span class="koboSpan" id="kobo.402.1">system manages and uses these blocks in the hard drive. </span><span class="koboSpan" id="kobo.402.2">Whenever the system requests data, the storage system collects the blocks and gives the result back to the user. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.403.1">Block </span><a id="_idIndexMarker742"/><span class="koboSpan" id="kobo.404.1">storage deployed in a </span><strong class="keyWord"><span class="koboSpan" id="kobo.405.1">storage area network</span></strong><span class="koboSpan" id="kobo.406.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.407.1">SAN</span></strong><span class="koboSpan" id="kobo.408.1">) stores data efficiently and reliably. </span><span class="koboSpan" id="kobo.408.2">It works well when a large amount of data needs to be stored and accessed frequently—for example, database deployment, email servers, application deployment, and virtual machines.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.409.1">SAN storage is sophisticated and supports </span><em class="italic"><span class="koboSpan" id="kobo.410.1">complex, mission-critical applications</span></em><span class="koboSpan" id="kobo.411.1">. </span><span class="koboSpan" id="kobo.411.2">It is a high-performance storage system that communicates block-level data between the server and storage; however, SANs are expensive and should be used for large-scale enterprise applications where low latency is required.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.412.1">To configure your block-based storage, you must choose between an SSD and an HDD. </span><span class="koboSpan" id="kobo.412.2">HDDs are the legacy data storage system for servers and enterprise storage arrays. </span><span class="koboSpan" id="kobo.412.3">HDDs are cheap but slow and need a lot of power and cooling. </span><span class="koboSpan" id="kobo.412.4">SSDs use semiconductor chips and are faster than HDDs. </span><span class="koboSpan" id="kobo.412.5">They are much more costly; however, SSDs have become more affordable and popular as technology evolves because of their efficiency and lower power and cooling requirements.</span></p>
<h3 class="heading-3" id="_idParaDest-196"><span class="koboSpan" id="kobo.413.1">Working with file storage and network area storage</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.414.1">File storage has been around for a long time and is widely used. </span><span class="koboSpan" id="kobo.414.2">In file storage, data is stored </span><a id="_idIndexMarker743"/><span class="koboSpan" id="kobo.415.1">as a single piece of information and is </span><a id="_idIndexMarker744"/><span class="koboSpan" id="kobo.416.1">organized inside folders. </span><span class="koboSpan" id="kobo.416.2">When you need to access the data, you provide the file path and get the data files; however, a file path can grow </span><a id="_idIndexMarker745"/><span class="koboSpan" id="kobo.417.1">complicated as files become nested under multiple folder hierarchies.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.418.1">Each </span><a id="_idIndexMarker746"/><span class="koboSpan" id="kobo.419.1">record has limited metadata, including the filename, time of creation, and up-to-date timestamps. </span><span class="koboSpan" id="kobo.419.2">Consider the analogy of a library, where you store books on shelves and keep a log with the location of each book.</span></p>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.420.1">Network area storage</span></strong><span class="koboSpan" id="kobo.421.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.422.1">NAS</span></strong><span class="koboSpan" id="kobo.423.1">) is a file storage system that is attached to the network and displays to </span><a id="_idIndexMarker747"/><span class="koboSpan" id="kobo.424.1">the user where they can store and access their files. </span><span class="koboSpan" id="kobo.424.2">NAS </span><a id="_idIndexMarker748"/><span class="koboSpan" id="kobo.425.1">also manages user privilege, file locking, and other security mechanisms that protect the data. </span><span class="koboSpan" id="kobo.425.2">NAS works well for file-sharing systems and local archives; however, there are better solutions for storing billions of files than NAS, given that it has limited metadata information and a complex folder hierarchy. </span><span class="koboSpan" id="kobo.425.3">To store billions of files, you need to use object storage. </span><span class="koboSpan" id="kobo.425.4">Let’s learn more about object storage and its benefits compared to file storage.</span></p>
<h3 class="heading-3" id="_idParaDest-197"><span class="koboSpan" id="kobo.426.1">Working with object storage and cloud data storage</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.427.1">Object storage bundles data with a unique identifier and metadata that is customizable. </span><span class="koboSpan" id="kobo.427.2">Object </span><a id="_idIndexMarker749"/><span class="koboSpan" id="kobo.428.1">storage uses a flat address space, in </span><a id="_idIndexMarker750"/><span class="koboSpan" id="kobo.429.1">contrast to the hierarchical addresses in file storage or addresses distributed over a chunk of blocks in block </span><a id="_idIndexMarker751"/><span class="koboSpan" id="kobo.430.1">storage. </span><span class="koboSpan" id="kobo.430.2">A flat address space makes it easier to </span><a id="_idIndexMarker752"/><span class="koboSpan" id="kobo.431.1">locate and retrieve data quickly, regardless of the data storage location. </span><span class="koboSpan" id="kobo.431.2">Object storage also helps the user to achieve unlimited scalability of storage.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.432.1">Object storage metadata can have many details, such as object name, size, timestamp, and so on, and users can customize it to add more information than you get with tagging in file storage. </span><span class="koboSpan" id="kobo.432.2">A simple API call can access data, and it is very cost-effective to store. </span><span class="koboSpan" id="kobo.432.3">Object storage performs best for high-volume, unstructured data; however, objects cannot be modified but only replaced, making it not a good use case for a database.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.433.1">Cloud data </span><a id="_idIndexMarker753"/><span class="koboSpan" id="kobo.434.1">storage, such as </span><strong class="keyWord"><span class="koboSpan" id="kobo.435.1">Amazon Simple Storage Service</span></strong><span class="koboSpan" id="kobo.436.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.437.1">S3</span></strong><span class="koboSpan" id="kobo.438.1">), provides unlimited scalable object data storage with high availability and durability. </span><span class="koboSpan" id="kobo.438.2">You can access data with a unique global identifier and metadata file prefix.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.439.1">The following diagram shows all three storage systems in a nutshell:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.440.1"><img alt="" role="presentation" src="../Images/B21336_06_07.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.441.1">Figure 6.5: Data storage systems</span></p>
<p class="normal"><span class="koboSpan" id="kobo.442.1">As shown in </span><a id="_idIndexMarker754"/><span class="koboSpan" id="kobo.443.1">the preceding diagram, block storage stores data in blocks. </span><span class="koboSpan" id="kobo.443.2">Block storage is ideal for scenarios where a single instance requires exclusive access to the storage, such as databases or applications that demand high performance and fast access to data. </span><span class="koboSpan" id="kobo.443.3">File storage stores data in a hierarchical folder structure with little overhead latency. </span><span class="koboSpan" id="kobo.443.4">You should use a file storage system when your data needs to be accessed by multiple instances simultaneously, much like how various people might need to access files in a shared room. </span><span class="koboSpan" id="kobo.443.5">Object storage stores data in buckets with a unique identifier for each object. </span><span class="koboSpan" id="kobo.443.6">It provides access over the web to reduce latency and increase throughput. </span><span class="koboSpan" id="kobo.443.7">You should use object storage to store and access static content, such as images and videos. </span><span class="koboSpan" id="kobo.443.8">You can store a high volume of data in object stores and perform big data processing and analysis.</span></p>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.444.1">Direct-attached storage</span></strong><span class="koboSpan" id="kobo.445.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.446.1">DAS</span></strong><span class="koboSpan" id="kobo.447.1">) is another kind of data storage that is directly attached </span><a id="_idIndexMarker755"/><span class="koboSpan" id="kobo.448.1">to the host server; however, it has very limited scalability and storage capacity.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.449.1">The magnetic tape drive is another popular back up and archiving storage system. </span><span class="koboSpan" id="kobo.449.2">Because of its low cost and high availability, magnetic tape drives are used for archival purposes but have high latency, making them unsuitable for use in direct applications.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.450.1">Often, you will need to increase throughput and data protection for a mission-critical application, such as a transactional database, where data is stored in SAN storage.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.451.1">Select the storage solution that matches your access pattern to maximize performance. </span><span class="koboSpan" id="kobo.451.2">Various options are available with a cloud offering for your block, file, and object storage method. </span><span class="koboSpan" id="kobo.451.3">For </span><a id="_idIndexMarker756"/><span class="koboSpan" id="kobo.452.1">example, the AWS public cloud provides </span><strong class="keyWord"><span class="koboSpan" id="kobo.453.1">Amazon Elastic Block Store</span></strong><span class="koboSpan" id="kobo.454.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.455.1">EBS</span></strong><span class="koboSpan" id="kobo.456.1">) as SAN storage in the cloud and </span><strong class="keyWord"><span class="koboSpan" id="kobo.457.1">Amazon Elastic File System</span></strong><span class="koboSpan" id="kobo.458.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.459.1">EFS</span></strong><span class="koboSpan" id="kobo.460.1">) as NAS </span><a id="_idIndexMarker757"/><span class="koboSpan" id="kobo.461.1">storage in the cloud. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.462.1">Amazon S3 is very popular for object storage. </span><span class="koboSpan" id="kobo.462.2">Similarly, Microsoft Azure provides Azure Disk Storage for SAN, Azure Files for NAS, and Azure Blob Storage for block storage.</span></p>
<h3 class="heading-3" id="_idParaDest-198"><span class="koboSpan" id="kobo.463.1">Storage for databases</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.464.1">Choosing the right type of storage for database performance is crucial to ensure optimal operation </span><a id="_idIndexMarker758"/><span class="koboSpan" id="kobo.465.1">and efficiency. </span><span class="koboSpan" id="kobo.465.2">The selection often depends on the </span><a id="_idIndexMarker759"/><span class="koboSpan" id="kobo.466.1">specific requirements of the database workload, such as IOPS, database size, the geographical location of data access, and the nature of the </span><a id="_idIndexMarker760"/><span class="koboSpan" id="kobo.467.1">database operations (</span><strong class="keyWord"><span class="koboSpan" id="kobo.468.1">Online Transaction Processing</span></strong><span class="koboSpan" id="kobo.469.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.470.1">OLTP</span></strong><span class="koboSpan" id="kobo.471.1">) versus </span><strong class="keyWord"><span class="koboSpan" id="kobo.472.1">Online Analytical Processing</span></strong><span class="koboSpan" id="kobo.473.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.474.1">OLAP</span></strong><span class="koboSpan" id="kobo.475.1">)). </span><span class="koboSpan" id="kobo.475.2">Below is a comparative </span><a id="_idIndexMarker761"/><span class="koboSpan" id="kobo.476.1">table that outlines the selection criteria and the suitability of various storage types for databases.</span></p>
<table class="table-container" id="table002">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.477.1">Storage Type</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.478.1">IOPS Capability</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.479.1">Suitable DB Size</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.480.1">Location Consideration</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.481.1">Best Use Case</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.482.1">Suitability</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.483.1">SSD</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.484.1">High</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.485.1">Small to large</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.486.1">Near to application server</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.487.1">OLTP and OLAP</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.488.1">Highly suitable for most databases, especially where high IOPS and low latency are critical.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.489.1">HDD</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.490.1">Moderate to low</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.491.1">Large</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.492.1">Near to application server</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.493.1">Large OLAP</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.494.1">Suitable for large, infrequently accessed databases or where cost is a concern, but not recommended for high-performance OLTP systems.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.495.1">NAS</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.496.1">Low to moderate</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.497.1">Small to medium</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.498.1">Flexible, can be off-premises</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.499.1">OLAP and backup</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.500.1">Suitable for databases with moderate performance requirements or for backup/archival purposes.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.501.1">SAN</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.502.1">High</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.503.1">Large</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.504.1">Flexible, preferably nearby</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.505.1">OLTP and OLAP</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.506.1">Very suitable for large databases requiring high IOPS, throughput, and scalability. </span><span class="koboSpan" id="kobo.506.2">Can be on-premises or cloud-based.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.507.1">Cloud storage</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.508.1">Variable</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.509.1">Variable</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.510.1">On-premises or cloud</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.511.1">OLTP and OLAP</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.512.1">Suitable for a wide range of database sizes and types. </span><span class="koboSpan" id="kobo.512.2">Performance and suitability depend on specific cloud service offerings.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.513.1">Table 6.2: Comparison of various storage types</span></p>
<p class="normal"><span class="koboSpan" id="kobo.514.1">In scenarios </span><a id="_idIndexMarker762"/><span class="koboSpan" id="kobo.515.1">involving multi-cloud or hybrid setups, additional factors, such as data sovereignty and compliance (which dictate where data </span><a id="_idIndexMarker763"/><span class="koboSpan" id="kobo.516.1">can be stored based on regulations), access patterns (whether the data is read or write-heavy), network latency, bandwidth, and cost considerations, also play a critical role. </span><span class="koboSpan" id="kobo.516.2">These aspects are especially crucial when databases </span><a id="_idIndexMarker764"/><span class="koboSpan" id="kobo.517.1">are accessed over </span><strong class="keyWord"><span class="koboSpan" id="kobo.518.1">Wide Area Networks</span></strong><span class="koboSpan" id="kobo.519.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.520.1">WANs</span></strong><span class="koboSpan" id="kobo.521.1">), where delays can impede performance.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.522.1">Now that you have learned about the compute and storage choices required to achieve optimal performance, let’s look at the next critical component of application development: the database. </span><span class="koboSpan" id="kobo.522.2">Choosing the right database for the right need will improve your application’s performance and reduce overall application latency. </span><span class="koboSpan" id="kobo.522.3">Different types of databases are available, and choosing the correct one is critical.</span></p>
<h2 class="heading-2" id="_idParaDest-199"><span class="koboSpan" id="kobo.523.1">Making a database choice</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.524.1">Often, you will want to standardize a common platform and use a database for ease of management; however, consider using a different database solution as per your data requirements. </span><span class="koboSpan" id="kobo.524.2">Selecting </span><a id="_idIndexMarker765"/><span class="koboSpan" id="kobo.525.1">the incorrect database solution can impact system latency and performance.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.526.1">The </span><a id="_idIndexMarker766"/><span class="koboSpan" id="kobo.527.1">database you choose will depend on your application’s availability, scalability, data structure, throughput, and durability requirements. </span><span class="koboSpan" id="kobo.527.2">There are multiple factors to consider when choosing which database to use. </span><span class="koboSpan" id="kobo.527.3">For example, the access pattern can significantly impact database technology selection, depending on the number of users and data access frequency. </span><span class="koboSpan" id="kobo.527.4">It would be best if you optimized your database based on the access pattern.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.528.1">Databases generally have a configuration option for workload optimization. </span><span class="koboSpan" id="kobo.528.2">You should consider the configuration for memory, cache, storage optimization, and so on. </span><span class="koboSpan" id="kobo.528.3">You should also explore the operational aspects of database technologies regarding scalability, backup, recovery, and maintenance. </span><span class="koboSpan" id="kobo.528.4">Let’s look at the different database technologies that can be used to fulfill the database requirements of applications.</span></p>
<h3 class="heading-3" id="_idParaDest-200"><span class="koboSpan" id="kobo.529.1">Online transactional processing</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.530.1">Most of the </span><a id="_idIndexMarker767"/><span class="koboSpan" id="kobo.531.1">traditional relational </span><a id="_idIndexMarker768"/><span class="koboSpan" id="kobo.532.1">databases are considered to use </span><strong class="keyWord"><span class="koboSpan" id="kobo.533.1">online transactional processing</span></strong><span class="koboSpan" id="kobo.534.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.535.1">OLTP</span></strong><span class="koboSpan" id="kobo.536.1">). </span><span class="koboSpan" id="kobo.536.2">The transactional database is the oldest and most popular method of storing and handling application data. </span><span class="koboSpan" id="kobo.536.3">Some examples of relational OLTP databases are Oracle, Microsoft SQL Server, MySQL, PostgreSQL, and Amazon RDS. </span><span class="koboSpan" id="kobo.536.4">The data access pattern for OLTP involves fetching a small dataset by looking up its ID. </span><span class="koboSpan" id="kobo.536.5">A database transaction means that either all related database updates were completed or none of them were.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.537.1">The relational model allows the processing of complex business transactions in an application, such as banking, trading, and e-commerce. </span><span class="koboSpan" id="kobo.537.2">It enables you to aggregate data and create complex queries using multiple joins across tables.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.538.1">While optimizing your relational database, you need to consider including the following optimizations:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.539.1">A database server that includes computing, memory, storage, and networking</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.540.1">Operating system-level settings, such as the storage volume, volume management, and block size</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.541.1">Database engine configuration and partition as required</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.542.1">Database-related options, such as schema, index, and view</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.543.1">Scaling can be tricky for relational databases as they can scale vertically and hit the upper limit of system capacity. </span><span class="koboSpan" id="kobo.543.2">Utilize read replicas to distribute the read load. </span><span class="koboSpan" id="kobo.543.3">This allows you to offload the read queries from the primary database to one or more replicas, enhancing the system’s read capacity. </span><span class="koboSpan" id="kobo.543.4">Implement partitioning (sharding) for scaling writes. </span><span class="koboSpan" id="kobo.543.5">By dividing a larger database into smaller, more manageable pieces (partitions or shards), each with a subset of the data, you can distribute the write load across multiple servers or instances, improving write performance. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.544.1">In the previous chapter, you learned how to scale a relational database in the </span><em class="italic"><span class="koboSpan" id="kobo.545.1">Database handling in the application architecture</span></em><span class="koboSpan" id="kobo.546.1"> section.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.547.1">OLTP databases are suitable for large and complex transactional applications; however, they need to scale better when a massive amount of data must be aggregated and queried. </span><span class="koboSpan" id="kobo.547.2">Also, with the internet boom, a lot of unstructured data is coming from everywhere, and relational databases cannot handle unstructured data efficiently out of the box. </span><span class="koboSpan" id="kobo.547.3">In this case, a nonrelational, or NoSQL database, comes to the rescue. </span><span class="koboSpan" id="kobo.547.4">Let’s learn more about how to handle them.</span></p>
<h3 class="heading-3" id="_idParaDest-201"><span class="koboSpan" id="kobo.548.1">Nonrelational databases</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.549.1">A lot of unstructured </span><a id="_idIndexMarker769"/><span class="koboSpan" id="kobo.550.1">and semi-structured data is produced by applications such as social media programs, the </span><strong class="keyWord"><span class="koboSpan" id="kobo.551.1">Internet of Things</span></strong><span class="koboSpan" id="kobo.552.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.553.1">IoT</span></strong><span class="koboSpan" id="kobo.554.1">), clickstream data, and logs, where you have very dynamic schemas. </span><span class="koboSpan" id="kobo.554.2">These data types may have </span><a id="_idIndexMarker770"/><span class="koboSpan" id="kobo.555.1">different schemas for each set of records. </span><span class="koboSpan" id="kobo.555.2">Storing this data in a relational database could be a very tedious task. </span><span class="koboSpan" id="kobo.555.3">Everything has to be filed in a </span><a id="_idIndexMarker771"/><span class="koboSpan" id="kobo.556.1">fixed schema, which can either cause lots of null values or data loss. </span><span class="koboSpan" id="kobo.556.2">Nonrelational databases, commonly referred to as NoSQL (“Not Only SQL” or “Non-SQL”), provide a flexible approach to data storage and management. </span><span class="koboSpan" id="kobo.556.3">Unlike traditional relational databases, which require a fixed schema before data can be stored, NoSQL databases allow you to store and manage data without predefined schema constraints. </span><span class="koboSpan" id="kobo.556.4">Records with a variable number of columns can be stored in the same table.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.557.1">NoSQL databases can store a large amount of data and provide </span><em class="italic"><span class="koboSpan" id="kobo.558.1">low-access latency</span></em><span class="koboSpan" id="kobo.559.1">. </span><span class="koboSpan" id="kobo.559.2">They are easy to scale by adding more nodes when required and can support horizontal scaling out of the box. </span><span class="koboSpan" id="kobo.559.3">They are an excellent choice for storing user session data and making your application stateless in order to achieve horizontal scaling without compromising user experience. </span><span class="koboSpan" id="kobo.559.4">You can develop a distributed application on top of the NoSQL database, which provides good latency and scaling, but query joining must be handled at the application layer because NoSQL databases don’t support complex queries such as joining tables and entities.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.560.1">There are various NoSQL database options available, such as Cassandra, HBase, and MongoDB, which you can install in a cluster of virtual machines. </span><span class="koboSpan" id="kobo.560.2">AWS provides a managed NoSQL </span><a id="_idIndexMarker772"/><span class="koboSpan" id="kobo.561.1">database called </span><strong class="keyWord"><span class="koboSpan" id="kobo.562.1">Amazon DynamoDB</span></strong><span class="koboSpan" id="kobo.563.1">, which provides high-throughput sub-millisecond latency with unlimited scaling.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.564.1">You can use OLTP for a relational database, but it has limited storage capacity. </span><span class="koboSpan" id="kobo.564.2">It needs to respond better to queries for large amounts of data and perform aggregations as required for data warehouses. </span><span class="koboSpan" id="kobo.564.3">Data warehousing needs are more analytical than transactional. </span><strong class="keyWord"><span class="koboSpan" id="kobo.565.1">OLAP</span></strong><span class="koboSpan" id="kobo.566.1"> fills the gaps in OLTP’s capabilities to query large datasets. </span><span class="koboSpan" id="kobo.566.2">Let’s learn more about OLAP.</span></p>
<h3 class="heading-3" id="_idParaDest-202"><span class="koboSpan" id="kobo.567.1">Online analytical processing</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.568.1">OLTP and </span><a id="_idIndexMarker773"/><span class="koboSpan" id="kobo.569.1">NoSQL databases are helpful for application </span><a id="_idIndexMarker774"/><span class="koboSpan" id="kobo.570.1">deployment but have limited capabilities for large-scale analysis. </span><span class="koboSpan" id="kobo.570.2">OLAP is primarily used in data warehouse technology. </span><span class="koboSpan" id="kobo.570.3">A query for a large volume of structured data for analytics purposes is better served by a data warehouse platform designed for faster access to structured </span><a id="_idIndexMarker775"/><span class="koboSpan" id="kobo.571.1">data. </span><span class="koboSpan" id="kobo.571.2">Modern data warehouses leverage columnar storage formats and </span><strong class="keyWord"><span class="koboSpan" id="kobo.572.1">Massively Parallel Processing</span></strong><span class="koboSpan" id="kobo.573.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.574.1">MPP</span></strong><span class="koboSpan" id="kobo.575.1">) architecture to significantly enhance data retrieval and analysis speeds. </span><span class="koboSpan" id="kobo.575.2">Unlike traditional row-oriented databases, where data is stored in rows, columnar storage organizes data in columns.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.576.1">The columnar </span><a id="_idIndexMarker776"/><span class="koboSpan" id="kobo.577.1">format means you don’t need to scan the </span><a id="_idIndexMarker777"/><span class="koboSpan" id="kobo.578.1">entire table when you need to aggregate only one column for data—for example, if you want to determine your inventory sales in a given month. </span><span class="koboSpan" id="kobo.578.2">There may be hundreds of columns in the order table, but you only need to aggregate data from the purchase column. </span><span class="koboSpan" id="kobo.578.3">With a columnar format, you will only scan the purchase column, which reduces the amount of data scanned compared to the row format and increases the query performance.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.579.1">With MPP, you store data in a distributed manner between child nodes and submit a query to the leader nodes. </span><span class="koboSpan" id="kobo.579.2">Based on your partition key, the leader node will distribute queries to the child nodes. </span><span class="koboSpan" id="kobo.579.3">Each node then picks up part of a query to perform parallel processing. </span><span class="koboSpan" id="kobo.579.4">The leader node then collects the subquery result from each child node and returns your aggregated result. </span><span class="koboSpan" id="kobo.579.5">This parallel processing helps you to execute the query faster and process a large amount of data quickly.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.580.1">You can use this kind of processing by installing software such as IBM Netezza or Microsoft SQL Server on a virtual machine, or you can go for a more cloud-native solution, such as Snowflake. </span><span class="koboSpan" id="kobo.580.2">AWS, as a public cloud, provides the petabyte-scale data warehousing solution Amazon Redshift, which uses the columnar format and MPP. </span><span class="koboSpan" id="kobo.580.3">You will learn more about data processing and analytics in </span><em class="chapterRef"><span class="koboSpan" id="kobo.581.1">Chapter 12</span></em><span class="koboSpan" id="kobo.582.1">, </span><em class="italic"><span class="koboSpan" id="kobo.583.1">Data Engineering for Solution Architecture</span></em><span class="koboSpan" id="kobo.584.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.585.1">You need to store and search a large amount of data, especially when you want to find a specific error in your logs or build a document search engine. </span><span class="koboSpan" id="kobo.585.2">For this kind of capability, your application needs to create a data search functionality. </span><span class="koboSpan" id="kobo.585.3">Let’s learn about data search functionality.</span></p>
<h3 class="heading-3" id="_idParaDest-203"><span class="koboSpan" id="kobo.586.1">Building a data search functionality</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.587.1">Often, you </span><a id="_idIndexMarker778"/><span class="koboSpan" id="kobo.588.1">need to search a large volume </span><a id="_idIndexMarker779"/><span class="koboSpan" id="kobo.589.1">of data to solve issues quickly or get business insights. </span><span class="koboSpan" id="kobo.589.2">Searching your applications’ data will help you access and analyze detailed information from different views. </span><span class="koboSpan" id="kobo.589.3">To search for data with low latency and high throughput, you need search engines.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.590.1">Elasticsearch is </span><a id="_idIndexMarker780"/><span class="koboSpan" id="kobo.591.1">one of the most popular search engine platforms; it is built on top of the </span><strong class="keyWord"><span class="koboSpan" id="kobo.592.1">Apache Lucene</span></strong><span class="koboSpan" id="kobo.593.1"> library. </span><span class="koboSpan" id="kobo.593.2">Apache Lucene is a free and open-source </span><a id="_idIndexMarker781"/><span class="koboSpan" id="kobo.594.1">software library that is the foundation of many popular search engines. </span><span class="koboSpan" id="kobo.594.2">The </span><strong class="keyWord"><span class="koboSpan" id="kobo.595.1">ELK</span></strong><span class="koboSpan" id="kobo.596.1"> (short for </span><strong class="keyWord"><span class="koboSpan" id="kobo.597.1">Elasticsearch</span></strong><span class="koboSpan" id="kobo.598.1">, </span><strong class="keyWord"><span class="koboSpan" id="kobo.599.1">Logstash</span></strong><span class="koboSpan" id="kobo.600.1">, </span><strong class="keyWord"><span class="koboSpan" id="kobo.601.1">and Kibana</span></strong><span class="koboSpan" id="kobo.602.1">) Stack is easy to use to discover large-scale data and index it for searching automatically. </span><span class="koboSpan" id="kobo.602.2">Because </span><a id="_idIndexMarker782"/><span class="koboSpan" id="kobo.603.1">of its properties, multiple </span><a id="_idIndexMarker783"/><span class="koboSpan" id="kobo.604.1">tools have been developed around Elasticsearch for visualization and analysis. </span><span class="koboSpan" id="kobo.604.2">For example, </span><strong class="keyWord"><span class="koboSpan" id="kobo.605.1">Logstash</span></strong><span class="koboSpan" id="kobo.606.1"> works with </span><a id="_idIndexMarker784"/><span class="koboSpan" id="kobo.607.1">Elasticsearch to collect, transform, and analyze a large amount of an application’s log data. </span><strong class="keyWord"><span class="koboSpan" id="kobo.608.1">Kibana</span></strong><span class="koboSpan" id="kobo.609.1"> has an </span><a id="_idIndexMarker785"/><span class="koboSpan" id="kobo.610.1">in-built connector with Elasticsearch that provides a simple solution for creating dashboards and analyzing indexed data. </span><span class="koboSpan" id="kobo.610.2">Elasticsearch can be deployed in virtual machines and scaled horizontally to increase </span><a id="_idIndexMarker786"/><span class="koboSpan" id="kobo.611.1">capacity by adding new nodes to the cluster. </span><span class="koboSpan" id="kobo.611.2">The AWS public cloud provides the managed </span><strong class="keyWord"><span class="koboSpan" id="kobo.612.1">Amazon OpenSearch Service</span></strong><span class="koboSpan" id="kobo.613.1">, making it cost-effective and simple to scale and manage the Elasticsearch cluster in the cloud.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.614.1">In this section, you learned about the various database technologies and where they are used. </span><span class="koboSpan" id="kobo.614.2">Your applications can use a combination of database technologies for their different components to achieve optimal performance. </span><span class="koboSpan" id="kobo.614.3">For complex transactions, you need to use a relational OLTP database, and to store and process unstructured or semi-structured data, you need to use a nonrelational NoSQL database. </span><span class="koboSpan" id="kobo.614.4">You should use a NoSQL database when very low latency is required over multiple geographical regions and when you need to handle complex queries at the application layer, such as in a gaming application. </span><span class="koboSpan" id="kobo.614.5">If you need to perform large-scale analytics on structured data, use a data warehouse OLAP database.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.615.1">Let’s look at another </span><a id="_idIndexMarker787"/><span class="koboSpan" id="kobo.616.1">critical component of your architecture: </span><strong class="keyWord"><span class="koboSpan" id="kobo.617.1">Networking</span></strong><span class="koboSpan" id="kobo.618.1">. </span><span class="koboSpan" id="kobo.618.2">Networking is the backbone of the entire application and establishes communication between the servers and the outside world. </span><span class="koboSpan" id="kobo.618.3">Let’s learn about networking as it relates to application performance.</span></p>
<h2 class="heading-2" id="_idParaDest-204"><span class="koboSpan" id="kobo.619.1">Improving network performance</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.620.1">In this era </span><a id="_idIndexMarker788"/><span class="koboSpan" id="kobo.621.1">of fast internet availability in almost every corner </span><a id="_idIndexMarker789"/><span class="koboSpan" id="kobo.622.1">of the world, applications are expected to have a global user reach. </span><span class="koboSpan" id="kobo.622.2">Any delay in the system’s response time depends upon the request load and the distance of the end-user from the server. </span><span class="koboSpan" id="kobo.622.3">If the system is not able to respond to user requests promptly, it can have a ripple effect by continuing to engage all the system’s resources and pile up a considerable request backlog, which will degrade the overall system performance.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.623.1">To reduce latency, you should simulate the user’s location and environment to identify any gaps. </span><span class="koboSpan" id="kobo.623.2">Using your findings, you should design the server’s physical location and caching mechanism to reduce network latency; however, the network solution choice for </span><a id="_idIndexMarker790"/><span class="koboSpan" id="kobo.624.1">an application </span><a id="_idIndexMarker791"/><span class="koboSpan" id="kobo.625.1">depends upon the networking speed, throughput, and latency requirements. </span><span class="koboSpan" id="kobo.625.2">An application to handle a global user base needs fast connectivity with its customers, and location plays an important role. </span><span class="koboSpan" id="kobo.625.3">Edge locations provided by the CDN help to localize the rich content and reduce overall latency.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.626.1">In </span><em class="chapterRef"><span class="koboSpan" id="kobo.627.1">Chapter 4</span></em><span class="koboSpan" id="kobo.628.1">, </span><em class="italic"><span class="koboSpan" id="kobo.629.1">Solution Architecture Design Patterns</span></em><span class="koboSpan" id="kobo.630.1">, you learned how to use a CDN to put data near your user’s location in the section titled </span><em class="italic"><span class="koboSpan" id="kobo.631.1">Cache-based architecture</span></em><span class="koboSpan" id="kobo.632.1">. </span><span class="koboSpan" id="kobo.632.2">There are various CDN solutions available with an extensive network of edge locations. </span><span class="koboSpan" id="kobo.632.3">You can use a CDN if your application is static-content-heavy, for example, if you need to deliver a large amount of image and video content to your end-user. </span><span class="koboSpan" id="kobo.632.4">Some of the more popular CDN solutions are Akamai, Cloudflare, and Amazon CloudFront (provided by the AWS cloud).</span></p>
<h3 class="heading-3" id="_idParaDest-205"><span class="koboSpan" id="kobo.633.1">Using edge computing</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.634.1">Edge computing is a distributed computing paradigm that brings computation and data storage </span><a id="_idIndexMarker792"/><span class="koboSpan" id="kobo.635.1">closer to the location where it is needed to improve response times and save bandwidth. </span><span class="koboSpan" id="kobo.635.2">These are the mini data centers </span><a id="_idIndexMarker793"/><span class="koboSpan" id="kobo.636.1">providing IT infrastructure near to the location at which they are used. </span><span class="koboSpan" id="kobo.636.2">Edge computing has emerged as a game-changing strategy for optimizing software application performance, mainly when latency, bandwidth, and real-time data processing are critical. </span><span class="koboSpan" id="kobo.636.3">You can leverage edge computing to boost your application’s performance, which has a globally distributed user base.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.637.1">Consider a scenario where a renowned global social media website such as Facebook, X, or TikTok experiences a surge in user activity due to a live event, such as a major sports game or a celebrity announcement. </span><span class="koboSpan" id="kobo.637.2">In the traditional model, centralized servers may need help to handle the massive influx of requests, resulting in slower load times and potential disruptions. </span><span class="koboSpan" id="kobo.637.3">This is where </span><strong class="keyWord"><span class="koboSpan" id="kobo.638.1">Content Delivery Networks</span></strong><span class="koboSpan" id="kobo.639.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.640.1">CDNs</span></strong><span class="koboSpan" id="kobo.641.1">) come into play, with industry </span><a id="_idIndexMarker794"/><span class="koboSpan" id="kobo.642.1">giants such as Akamai, Cloudflare, Imperva, and Amazon CloudFront leading the way.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.643.1">Akamai, one of the pioneers in the CDN space, boasts a vast network of edge servers strategically located in numerous countries and cities worldwide. </span><span class="koboSpan" id="kobo.643.2">Akamai’s edge servers in Tokyo spring into action when a user from, say, Tokyo, Japan, accesses their global social media site during a high-traffic event. </span><span class="koboSpan" id="kobo.643.3">These servers cache and deliver frequently accessed content, such as images, videos, and static files, from a location much closer to the user than the centralized data centers. </span><span class="koboSpan" id="kobo.643.4">As a result, the user experiences lightning-fast load times, reduced latency, and smooth content delivery.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.644.1">Moreover, Akamai’s </span><a id="_idIndexMarker795"/><span class="koboSpan" id="kobo.645.1">edge servers also provide </span><a id="_idIndexMarker796"/><span class="koboSpan" id="kobo.646.1">advanced security features, such as </span><strong class="keyWord"><span class="koboSpan" id="kobo.647.1">Distributed Denial of Service</span></strong><span class="koboSpan" id="kobo.648.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.649.1">DDoS</span></strong><span class="koboSpan" id="kobo.650.1">) protection and </span><strong class="keyWord"><span class="koboSpan" id="kobo.651.1">Web Application Firewall</span></strong><span class="koboSpan" id="kobo.652.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.653.1">WAF</span></strong><span class="koboSpan" id="kobo.654.1">) capabilities, ensuring that the social media website remains resilient against cyberattacks </span><a id="_idIndexMarker797"/><span class="koboSpan" id="kobo.655.1">and unauthorized access. </span><span class="koboSpan" id="kobo.655.2">Amazon CloudFront, tightly integrated with </span><strong class="keyWord"><span class="koboSpan" id="kobo.656.1">Amazon Web Services</span></strong><span class="koboSpan" id="kobo.657.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.658.1">AWS</span></strong><span class="koboSpan" id="kobo.659.1">), also offers a robust edge computing solution for businesses of all sizes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.660.1">Beyond </span><a id="_idIndexMarker798"/><span class="koboSpan" id="kobo.661.1">social media, edge computing is transforming various industries. </span><span class="koboSpan" id="kobo.661.2">In autonomous vehicles, for example, edge devices </span><a id="_idIndexMarker799"/><span class="koboSpan" id="kobo.662.1">process data from sensors in real time to make split-second decisions, ensuring safety on the road. </span><span class="koboSpan" id="kobo.662.2">In the IoT realm, edge computing enables smart devices to analyze data locally, reducing latency and conserving bandwidth. </span><span class="koboSpan" id="kobo.662.3">For instance, a smart thermostat can adjust temperature settings based on local sensor data without the need for constant communication with centralized servers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.663.1">In healthcare, edge computing is utilized for remote patient monitoring. </span><span class="koboSpan" id="kobo.663.2">Wearable devices equipped with edge processing capabilities can analyze health data in real time and send alerts to healthcare providers or patients themselves if anomalies occur, allowing for timely interventions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.664.1">By bringing computation closer to data sources and end-users, edge computing enhances performance, responsiveness, and scalability, making it an important technology for improving application performance.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.665.1">Let’s look at some DNS routing strategies to achieve low latency if your application is deployed globally.</span></p>
<h3 class="heading-3" id="_idParaDest-206"><span class="koboSpan" id="kobo.666.1">Defining a DNS routing strategy</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.667.1">You may deploy your application in multiple geographical regions to have a global reach. </span><span class="koboSpan" id="kobo.667.2">When it comes to user request routing, you need to route user requests to the nearest and fastest </span><a id="_idIndexMarker800"/><span class="koboSpan" id="kobo.668.1">available server for a quick response from your application. </span><span class="koboSpan" id="kobo.668.2">The DNS router provides the mapping between the domain names and </span><a id="_idIndexMarker801"/><span class="koboSpan" id="kobo.669.1">the IP addresses. </span><span class="koboSpan" id="kobo.669.2">It ensures that the requests are served by the correct server when the user types in the domain name—for example, when you type </span><a href="http://amazon.com"><span class="url"><span class="koboSpan" id="kobo.670.1">amazon.com</span></span></a><span class="koboSpan" id="kobo.671.1"> in your browser to do some shopping, your request is always routed to the Amazon application server DNS service.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.672.1">AWS provides a </span><a id="_idIndexMarker802"/><span class="koboSpan" id="kobo.673.1">DNS service called </span><strong class="keyWord"><span class="koboSpan" id="kobo.674.1">Amazon Route 53</span></strong><span class="koboSpan" id="kobo.675.1">, where you can define a different kind of routing policy as per your application’s needs. </span><span class="koboSpan" id="kobo.675.2">Amazon Route 53 provides DNS services to simplify domain management. </span><span class="koboSpan" id="kobo.675.3">The following are the most common routing policies:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.676.1">Simple routing policy</span></strong><span class="koboSpan" id="kobo.677.1">: As the name suggests, this is the most straightforward </span><a id="_idIndexMarker803"/><span class="koboSpan" id="kobo.678.1">routing policy and doesn’t involve any complications. </span><span class="koboSpan" id="kobo.678.2">It is helpful to route traffic to a single resource—for example, a web server that is used to deliver information to a specific website.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.679.1">Failover routing policy</span></strong><span class="koboSpan" id="kobo.680.1">: This routing policy requires you to achieve high availability </span><a id="_idIndexMarker804"/><span class="koboSpan" id="kobo.681.1">by configuring active-passive failover. </span><span class="koboSpan" id="kobo.681.2">If your application goes down in one region, all the traffic can automatically be routed to another region.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.682.1">Geolocation routing policy</span></strong><span class="koboSpan" id="kobo.683.1">: If the user belongs to a particular location, you can use </span><a id="_idIndexMarker805"/><span class="koboSpan" id="kobo.684.1">a geolocation policy. </span><span class="koboSpan" id="kobo.684.2">A geolocation routing policy routes traffic to a specific region.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.685.1">Geoproximity routing policy</span></strong><span class="koboSpan" id="kobo.686.1">: This is like a geolocation policy, but you can shift traffic </span><a id="_idIndexMarker806"/><span class="koboSpan" id="kobo.687.1">to nearby locations when needed.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.688.1">Latency routing policy</span></strong><span class="koboSpan" id="kobo.689.1">: If your application runs in multiple regions, you can use a </span><a id="_idIndexMarker807"/><span class="koboSpan" id="kobo.690.1">latency policy to serve traffic from the region where the lowest latency can be achieved.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.691.1">Weighted routing policy</span></strong><span class="koboSpan" id="kobo.692.1">: A </span><a id="_idIndexMarker808"/><span class="koboSpan" id="kobo.693.1">weighted routing policy is used for A/B testing, where you want to send a certain amount of traffic to one region and increase this traffic as your trial proves more and more successful.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.694.1">Additionally, Amazon Route 53 can detect anomalies in the source and volume of DNS queries </span><a id="_idIndexMarker809"/><span class="koboSpan" id="kobo.695.1">and prioritize requests from users that are known to be </span><em class="italic"><span class="koboSpan" id="kobo.696.1">reliable</span></em><span class="koboSpan" id="kobo.697.1">. </span><span class="koboSpan" id="kobo.697.2">It also protects your application from a DDoS attack.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.698.1">Once traffic </span><a id="_idIndexMarker810"/><span class="koboSpan" id="kobo.699.1">passes through the DNS server, in most cases, the next stop will be a load balancer, which will distribute traffic among a cluster of servers. </span><span class="koboSpan" id="kobo.699.2">Let’s learn some more about load balancers.</span></p>
<h3 class="heading-3" id="_idParaDest-207"><span class="koboSpan" id="kobo.700.1">Applying a load balancer</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.701.1">Load balancers distribute network traffic across servers to improve concurrency, reliability, and application latency. </span><span class="koboSpan" id="kobo.701.2">Load balancers can be </span><em class="italic"><span class="koboSpan" id="kobo.702.1">physical</span></em><span class="koboSpan" id="kobo.703.1"> or </span><em class="italic"><span class="koboSpan" id="kobo.704.1">virtual</span></em><span class="koboSpan" id="kobo.705.1">. </span><span class="koboSpan" id="kobo.705.2">It would be best to </span><a id="_idIndexMarker811"/><span class="koboSpan" id="kobo.706.1">choose a load balancer that suits </span><a id="_idIndexMarker812"/><span class="koboSpan" id="kobo.707.1">your application’s needs. </span><span class="koboSpan" id="kobo.707.2">Commonly, two types of load balancers can be utilized by an application:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.708.1">Layer 4 or network load balancer</span></strong><span class="koboSpan" id="kobo.709.1">: Layer 4 load balancing routes packets based </span><a id="_idIndexMarker813"/><span class="koboSpan" id="kobo.710.1">on information in the packet header—for example, source/destination IP addresses and ports. </span><span class="koboSpan" id="kobo.710.2">Layer 4 </span><a id="_idIndexMarker814"/><span class="koboSpan" id="kobo.711.1">load balancing does not inspect a packet’s contents, making it less compute-intensive than Layer 7 or application load balancing, and, therefore, faster. </span><span class="koboSpan" id="kobo.711.2">A network load balancer can handle millions of requests per second.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.712.1">Layer 7 or application load balancer</span></strong><span class="koboSpan" id="kobo.713.1">: Layer 7 load balancing inspects and routes </span><a id="_idIndexMarker815"/><span class="koboSpan" id="kobo.714.1">packets based on the full contents of the packet. </span><span class="koboSpan" id="kobo.714.2">Layer 7 is used in conjunction with HTTP requests. </span><span class="koboSpan" id="kobo.714.3">The </span><a id="_idIndexMarker816"/><span class="koboSpan" id="kobo.715.1">materials that inform routing decisions are factors such as HTTP headers, URI path, and content type. </span><span class="koboSpan" id="kobo.715.2">It allows for more robust routing rules but requires more compute time to route packets. </span><span class="koboSpan" id="kobo.715.3">An application load balancer can route requests to containers in your cluster based on their distinctive port number.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.716.1">Depending on the environment, you can choose hardware-based load balancers, such as an F5 load balancer </span><a id="_idIndexMarker817"/><span class="koboSpan" id="kobo.717.1">or a Cisco load balancer. </span><span class="koboSpan" id="kobo.717.2">You can also select a software-based load balancer, such as </span><strong class="keyWord"><span class="koboSpan" id="kobo.718.1">Nginx</span></strong><span class="koboSpan" id="kobo.719.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.720.1">AWS provides a managed virtual load balancer called Amazon </span><strong class="keyWord"><span class="koboSpan" id="kobo.721.1">Elastic Load Balancing</span></strong><span class="koboSpan" id="kobo.722.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.723.1">ELB</span></strong><span class="koboSpan" id="kobo.724.1">). </span><span class="koboSpan" id="kobo.724.2">ELB can be </span><a id="_idIndexMarker818"/><span class="koboSpan" id="kobo.725.1">applied at Layer 7 as an application load balancer and Layer 4 as a network load balancer.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.726.1">A load balancer is an excellent way of securing your application, making it highly available by sending requests to healthy instances. </span><span class="koboSpan" id="kobo.726.2">It works together with auto-scaling to add or remove instances as required. </span><span class="koboSpan" id="kobo.726.3">Let’s look at auto-scaling and learn how it helps to improve overall performance and ensure the high availability of your application.</span></p>
<h3 class="heading-3" id="_idParaDest-208"><span class="koboSpan" id="kobo.727.1">Applying auto-scaling</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.728.1">You learned about auto-scaling in </span><em class="chapterRef"><span class="koboSpan" id="kobo.729.1">Chapter 2</span></em><span class="koboSpan" id="kobo.730.1">, </span><em class="italic"><span class="koboSpan" id="kobo.731.1">Principles of Solution Architecture Design</span></em><span class="koboSpan" id="kobo.732.1">. </span><span class="koboSpan" id="kobo.732.2">You learned </span><a id="_idIndexMarker819"/><span class="koboSpan" id="kobo.733.1">about predictive and reactive auto-scaling in the </span><em class="italic"><span class="koboSpan" id="kobo.734.1">Design for scale</span></em><span class="koboSpan" id="kobo.735.1"> section. </span><span class="koboSpan" id="kobo.735.2">The concept of auto-scaling became popular with the agility provided by </span><a id="_idIndexMarker820"/><span class="koboSpan" id="kobo.736.1">cloud computing platforms. </span><span class="koboSpan" id="kobo.736.2">Cloud infrastructure allows you to quickly scale up or scale down your server fleet based on user or resource demand.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.737.1">With a public cloud platform such as AWS, you can apply auto-scaling at every layer of your architecture. </span><span class="koboSpan" id="kobo.737.2">You can scale the web server fleet based on the number of requests in the presentation layer, and scale the application layer based on the server’s memory and CPU utilization. </span><span class="koboSpan" id="kobo.737.3">You can also perform scheduled scaling if you know the traffic pattern when the server load increases. </span><span class="koboSpan" id="kobo.737.4">At the database level, auto-scaling is available for relational databases such as Amazon Aurora Serverless and Microsoft Azure SQL Database. </span><span class="koboSpan" id="kobo.737.5">A NoSQL database such as Amazon DynamoDB can be auto-scaled based on throughput capacity.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.738.1">When auto-scaling, you need to define the number of desired server instances. </span><span class="koboSpan" id="kobo.738.2">You need to determine the maximum and minimum server capacity as per your application’s scaling needs. </span><span class="koboSpan" id="kobo.738.3">The following screenshot illustrates the auto-scaling configuration in the AWS cloud as an example:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.739.1"><img alt="" role="presentation" src="../Images/B21336_06_08.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.740.1">Figure 6.6: Auto-scaling configuration</span></p>
<p class="normal"><span class="koboSpan" id="kobo.741.1">In the </span><a id="_idIndexMarker821"/><span class="koboSpan" id="kobo.742.1">preceding auto-scaling configuration </span><a id="_idIndexMarker822"/><span class="koboSpan" id="kobo.743.1">setting, if three web server instances are running, it can scale up to five instances if the CPU utilization of servers goes above 50% and scale down to two instances if the CPU utilization goes below 20%. </span><span class="koboSpan" id="kobo.743.2">If an instance becomes unhealthy in a standard scenario, the total number of instances will fall below the desired capacity. </span><span class="koboSpan" id="kobo.743.3">In this case, the load balancer will monitor the instance’s health and use auto-scaling to provide new instances. </span><span class="koboSpan" id="kobo.743.4">The load balancer monitors instance health and triggers auto-scaling to provision new instances as required.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.744.1">Auto-scaling is a good feature to have, but make sure you set up the appropriate configuration to limit the cost of a change in CPU usage. </span><span class="koboSpan" id="kobo.744.2">Auto-scaling can significantly increase costs in the case of unforeseen traffic due to a </span><strong class="keyWord"><span class="koboSpan" id="kobo.745.1">distributed denial of service</span></strong><span class="koboSpan" id="kobo.746.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.747.1">DDoS</span></strong><span class="koboSpan" id="kobo.748.1">) attack. </span><span class="koboSpan" id="kobo.748.2">It will help to protect your system from such events. </span><span class="koboSpan" id="kobo.748.3">You will learn more about this in </span><em class="chapterRef"><span class="koboSpan" id="kobo.749.1">Chapter 7</span></em><span class="koboSpan" id="kobo.750.1">, </span><em class="italic"><span class="koboSpan" id="kobo.751.1">Security Considerations</span></em><span class="koboSpan" id="kobo.752.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.753.1">In this </span><a id="_idIndexMarker823"/><span class="koboSpan" id="kobo.754.1">section, you have learned about </span><a id="_idIndexMarker824"/><span class="koboSpan" id="kobo.755.1">various networking components that can help to improve application performance. </span><span class="koboSpan" id="kobo.755.2">You can optimize your application network traffic according to your user location and application demand. </span><span class="koboSpan" id="kobo.755.3">Since mobile is becoming the go-to user interface for many applications, you should do proactive performance monitoring of mobile apps to improve the customer experience. </span><span class="koboSpan" id="kobo.755.4">Let’s learn more about performance considerations for mobile apps next.</span></p>
<h1 class="heading-1" id="_idParaDest-209"><span class="koboSpan" id="kobo.756.1">Performance considerations for mobile applications</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.757.1">Mobile applications have now become an essential part of many digital platforms. </span><span class="koboSpan" id="kobo.757.2">Nowadays, users </span><a id="_idIndexMarker825"/><span class="koboSpan" id="kobo.758.1">often first check out the mobile application before visiting the desktop website. </span><span class="koboSpan" id="kobo.758.2">Moreover, a significant portion of user traffic is driven via mobile applications, making it crucial to ensure these apps are highly performant. </span><span class="koboSpan" id="kobo.758.3">As mobile apps increasingly become a staple of our digital interactions, it’s paramount to guarantee their performance, security, and usability. </span><span class="koboSpan" id="kobo.758.4">Let’s delve into some best practices for building efficient mobile applications.</span></p>
<h2 class="heading-2" id="_idParaDest-210"><span class="koboSpan" id="kobo.759.1">Optimization of load times</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.760.1">In mobile applications, load times are a critical factor that can either augment user engagement </span><a id="_idIndexMarker826"/><span class="koboSpan" id="kobo.761.1">or serve as a deterrent. </span><span class="koboSpan" id="kobo.761.2">Quick and efficient load times are indispensable, especially considering users often utilize applications on the go and require immediate responses. </span><span class="koboSpan" id="kobo.761.3">Some ways to enhance load times are to optimize image sizes, employ lazy loading for elements, and ensure that the initially visible content loads promptly.</span></p>
<h2 class="heading-2" id="_idParaDest-211"><span class="koboSpan" id="kobo.762.1">Efficient use of resources</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.763.1">Limited resources, such as CPU, memory, and battery, constrain mobile devices. </span><span class="koboSpan" id="kobo.763.2">To ensure an </span><a id="_idIndexMarker827"/><span class="koboSpan" id="kobo.764.1">app runs smoothly without draining the device’s resources, developers need to prioritize minimizing the usage of these resources. </span><span class="koboSpan" id="kobo.764.2">Strategies include using efficient algorithms, reducing memory leaks by properly managing memory allocation, and optimizing queries to fetch only the necessary data.</span></p>
<h2 class="heading-2" id="_idParaDest-212"><span class="koboSpan" id="kobo.765.1">Responsive user interface (UI)</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.766.1">The UI should be intuitive and highly responsive, ensuring that user inputs yield immediate </span><a id="_idIndexMarker828"/><span class="koboSpan" id="kobo.767.1">feedback. </span><span class="koboSpan" id="kobo.767.2">To achieve this, any computationally intensive process, such as data retrieval or image processing, should be executed in the background, preventing it from interfering with UI interactions. </span><span class="koboSpan" id="kobo.767.3">Using asynchronous programming and multithreading can keep the UI agile and responsive.</span></p>
<h2 class="heading-2" id="_idParaDest-213"><span class="koboSpan" id="kobo.768.1">Network efficiency</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.769.1">Considering the potential for unstable or slow network connections in mobile environments, an application should proficiently manage network requests. </span><span class="koboSpan" id="kobo.769.2">Implementing </span><a id="_idIndexMarker829"/><span class="koboSpan" id="kobo.770.1">caching for data that does not change frequently, optimizing API calls, and gracefully handling network failures by providing appropriate user feedback can significantly enhance user experience and app performance.</span></p>
<h2 class="heading-2" id="_idParaDest-214"><span class="koboSpan" id="kobo.771.1">Battery consumption</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.772.1">An app that excessively drains the battery will quickly fall out of favor with users. </span><span class="koboSpan" id="kobo.772.2">You should be </span><a id="_idIndexMarker830"/><span class="koboSpan" id="kobo.773.1">mindful of optimizing processes and managing background tasks to minimize power consumption. </span><span class="koboSpan" id="kobo.773.2">Ensuring that GPS, Bluetooth, and other power-intensive processes are used judiciously and turned off when not needed is crucial.</span></p>
<h2 class="heading-2" id="_idParaDest-215"><span class="koboSpan" id="kobo.774.1">Cross-platform compatibility</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.775.1">With a </span><a id="_idIndexMarker831"/><span class="koboSpan" id="kobo.776.1">multitude of devices, operating </span><a id="_idIndexMarker832"/><span class="koboSpan" id="kobo.777.1">systems, and screen sizes available, an app should maintain high performance across various platforms. </span><span class="koboSpan" id="kobo.777.2">Utilizing cross-platform development frameworks and thoroughly testing the app on diverse devices ensures a consistent and optimal user experience.</span></p>
<h2 class="heading-2" id="_idParaDest-216"><span class="koboSpan" id="kobo.778.1">User experience (UX) design</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.779.1">Ensuring the UX is seamless and intuitive is central to any application’s success. </span><span class="koboSpan" id="kobo.779.2">This involves </span><a id="_idIndexMarker833"/><span class="koboSpan" id="kobo.780.1">crafting a user-friendly </span><a id="_idIndexMarker834"/><span class="koboSpan" id="kobo.781.1">design, ensuring ease of navigation, and maintaining a logical flow throughout the app, ensuring users can perform their desired actions with minimal effort.</span></p>
<h2 class="heading-2" id="_idParaDest-217"><span class="koboSpan" id="kobo.782.1">Effective data management</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.783.1">Managing data efficiently by utilizing local storage for frequently used data and ensuring smooth </span><a id="_idIndexMarker835"/><span class="koboSpan" id="kobo.784.1">synchronization </span><a id="_idIndexMarker836"/><span class="koboSpan" id="kobo.785.1">between local and remote data is essential for providing users with up-to-date information without compromising performance.</span></p>
<h2 class="heading-2" id="_idParaDest-218"><span class="koboSpan" id="kobo.786.1">Testing and quality assurance</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.787.1">Implementing rigorous testing protocols, which include performance testing under various conditions and on diverse devices, ensures that the app can maintain optimal performance </span><a id="_idIndexMarker837"/><span class="koboSpan" id="kobo.788.1">even under strain. </span><span class="koboSpan" id="kobo.788.2">Employing automated testing and continuous integration can assist in identifying and rectifying issues promptly during the development phase.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.789.1">Constructing a </span><a id="_idIndexMarker838"/><span class="koboSpan" id="kobo.790.1">high-performance mobile application involves a harmonious </span><a id="_idIndexMarker839"/><span class="koboSpan" id="kobo.791.1">blend of user-centric </span><a id="_idIndexMarker840"/><span class="koboSpan" id="kobo.792.1">design and technical proficiency. </span><span class="koboSpan" id="kobo.792.2">By meticulously optimizing every facet of an application, from the interface and load times to data management and security features, developers can ensure it performs optimally in varied conditions and across numerous devices. </span><span class="koboSpan" id="kobo.792.3">While you are implementing various strategies to improve application performance, it’s always recommended to test it as well. </span><span class="koboSpan" id="kobo.792.4">Let’s learn more about performance testing.</span></p>
<h1 class="heading-1" id="_idParaDest-219"><span class="koboSpan" id="kobo.793.1">Performance testing</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.794.1">Performance testing is a critical subset of software testing that aims to ensure that a software application will perform well under expected workloads. </span><span class="koboSpan" id="kobo.794.2">It revolves around gauging an </span><a id="_idIndexMarker841"/><span class="koboSpan" id="kobo.795.1">application’s stability, speed, responsiveness, and scalability under various circumstances. </span><span class="koboSpan" id="kobo.795.2">Rather than identifying bugs or defects, performance testing determines how an application will react to different demand levels. </span><span class="koboSpan" id="kobo.795.3">Given the fact that today’s users expect seamless and swift functionality, performance testing has never been more crucial.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.796.1">The significance of a well-performing application can’t be overstated in today’s digital age. </span><span class="koboSpan" id="kobo.796.2">Primarily, it directly affects user satisfaction. </span><span class="koboSpan" id="kobo.796.3">Users are accustomed to swift and seamless interactions on their devices; thus, a sluggish or frequently crashing app can be a major turn-off. </span><span class="koboSpan" id="kobo.796.4">Nobody wants to waste time on an application that doesn’t deliver promptly, especially during moments of high demand or peak usage. </span><span class="koboSpan" id="kobo.796.5">The frustration from such experiences can lead users to abandon the app entirely, favoring competitors that provide a smoother experience.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.797.1">Consider a popular e-commerce website gearing up for a Black Friday sale. </span><span class="koboSpan" id="kobo.797.2">With thousands, if not millions, expected to visit the site, it’s imperative to ensure the system won’t crash, transactions will process swiftly, and the user experience will remain smooth, even with the surge of users. </span><span class="koboSpan" id="kobo.797.3">Performance testing, in this case, is not just helpful but essential.</span></p>
<h2 class="heading-2" id="_idParaDest-220"><span class="koboSpan" id="kobo.798.1">Types of performance testing</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.799.1">There are several types of performance testing, each designed to address specific aspects of an application’s performance. </span><span class="koboSpan" id="kobo.799.2">Here’s a brief overview of the main types of performance testing:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.800.1">Load testing</span></strong><span class="koboSpan" id="kobo.801.1">: This type </span><a id="_idIndexMarker842"/><span class="koboSpan" id="kobo.802.1">of testing is about </span><a id="_idIndexMarker843"/><span class="koboSpan" id="kobo.803.1">understanding how a system behaves under expected, real-world loads. </span><span class="koboSpan" id="kobo.803.2">It’s the equivalent of testing a bridge by gradually adding weight until it carries the anticipated maximum number of vehicles. </span><span class="koboSpan" id="kobo.803.3">For example, if an e-commerce website expects 10,000 visitors during a holiday sale, load testing will simulate these 10,000 users to ensure the site works smoothly under such conditions.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.804.1">Stress testing</span></strong><span class="koboSpan" id="kobo.805.1">: Imagine </span><a id="_idIndexMarker844"/><span class="koboSpan" id="kobo.806.1">cramming too many </span><a id="_idIndexMarker845"/><span class="koboSpan" id="kobo.807.1">people into an elevator, beyond its capacity, to see if it still operates or breaks down; that’s the essence of stress testing. </span><span class="koboSpan" id="kobo.807.2">It’s designed to push systems to their breaking point, ensuring that even in worst-case </span><a id="_idIndexMarker846"/><span class="koboSpan" id="kobo.808.1">scenarios, failures don’t lead to catastrophic results. </span><span class="koboSpan" id="kobo.808.2">For instance, a banking app might be stress tested to see how it </span><a id="_idIndexMarker847"/><span class="koboSpan" id="kobo.809.1">behaves if a million users tried to log in simultaneously, far exceeding its regular traffic.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.810.1">Endurance testing</span></strong><span class="koboSpan" id="kobo.811.1">: The question endurance testing answers is “Can the system run </span><a id="_idIndexMarker848"/><span class="koboSpan" id="kobo.812.1">efficiently when subjected </span><a id="_idIndexMarker849"/><span class="koboSpan" id="kobo.813.1">to an expected load for an extended period of time?” </span><span class="koboSpan" id="kobo.813.2">For example, a streaming service might be endurance tested to ensure it can stream movies and shows to users continuously over a weekend without any degradation in quality or speed.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.814.1">Spike testing</span></strong><span class="koboSpan" id="kobo.815.1">: In the real world, user traffic can be unpredictable. </span><span class="koboSpan" id="kobo.815.2">Spike testing is </span><a id="_idIndexMarker850"/><span class="koboSpan" id="kobo.816.1">like observing how a power grid </span><a id="_idIndexMarker851"/><span class="koboSpan" id="kobo.817.1">reacts when everyone suddenly turns on their air conditioners simultaneously during a heatwave. </span><span class="koboSpan" id="kobo.817.2">An example might be testing a news website during a major event, like the Olympics, where sudden influxes of users might want to check results or updates.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.818.1">Volume testing</span></strong><span class="koboSpan" id="kobo.819.1">: Here, the emphasis is on data. </span><span class="koboSpan" id="kobo.819.2">It’s analogous to checking how well </span><a id="_idIndexMarker852"/><span class="koboSpan" id="kobo.820.1">a library can organize and lend millions of books. </span><span class="koboSpan" id="kobo.820.2">For a database-driven application, volume testing might </span><a id="_idIndexMarker853"/><span class="koboSpan" id="kobo.821.1">involve seeing how the system behaves when the database has billions of entries. </span><span class="koboSpan" id="kobo.821.2">A practical example is a global email service testing its system’s responsiveness when searching through vast numbers of stored emails.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.822.1">Many performance </span><a id="_idIndexMarker854"/><span class="koboSpan" id="kobo.823.1">testing tools are available, such as </span><strong class="keyWord"><span class="koboSpan" id="kobo.824.1">JMeter</span></strong><span class="koboSpan" id="kobo.825.1">, </span><strong class="keyWord"><span class="koboSpan" id="kobo.826.1">LoadRunner</span></strong><span class="koboSpan" id="kobo.827.1">, and </span><strong class="keyWord"><span class="koboSpan" id="kobo.828.1">WebLoad</span></strong><span class="koboSpan" id="kobo.829.1">. </span><span class="koboSpan" id="kobo.829.2">These tools </span><a id="_idIndexMarker855"/><span class="koboSpan" id="kobo.830.1">simulate various scenarios and loads to </span><a id="_idIndexMarker856"/><span class="koboSpan" id="kobo.831.1">test the application’s performance.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.832.1">Performance testing plays a crucial role in the software development lifecycle. </span><span class="koboSpan" id="kobo.832.2">Ensuring an application’s robustness, reliability, and speed are vital for its success in the real world.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.833.1">Performance testing and performance monitoring are two critical aspects of ensuring an application’s efficiency and reliability, but they serve different purposes throughout the development and deployment lifecycle. </span><span class="koboSpan" id="kobo.833.2">Performance testing is about identifying potential performance issues before they affect users, while performance monitoring is about keeping an eye on the system’s performance and quickly reacting to any issues that occur after deployment. </span><span class="koboSpan" id="kobo.833.3">Let’s learn more about performance monitoring in the next section.</span></p>
<h1 class="heading-1" id="_idParaDest-221"><span class="koboSpan" id="kobo.834.1">Managing performance monitoring</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.835.1">Performance monitoring is essential when you are trying to keep an eye on performance issues and proactively reduce end-user impact.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.836.1">You should </span><a id="_idIndexMarker857"/><span class="koboSpan" id="kobo.837.1">define your performance baseline and raise the alarm to the team in the case of a threshold breach—for example, an application’s mobile app load time should not be more than three seconds. </span><span class="koboSpan" id="kobo.837.2">Your alarm should be able to trigger an automated action to handle poorly performing components—for example, adding more nodes to a web application cluster to reduce the request load.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.838.1">There are multiple monitoring tools that measure application performance and overall infrastructure. </span><span class="koboSpan" id="kobo.838.2">You can use a third-party tool like Splunk or the AWS-provided Amazon CloudWatch to monitor any application.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.839.1">Monitoring solutions can be categorized into </span><strong class="keyWord"><span class="koboSpan" id="kobo.840.1">active monitoring</span></strong><span class="koboSpan" id="kobo.841.1"> and </span><strong class="keyWord"><span class="koboSpan" id="kobo.842.1">passive monitoring</span></strong><span class="koboSpan" id="kobo.843.1"> solutions:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.844.1">With active </span><a id="_idIndexMarker858"/><span class="koboSpan" id="kobo.845.1">monitoring, you must simulate user activity and identify performance gaps up front. </span><span class="koboSpan" id="kobo.845.2">Application data and workload situations constantly change, requiring continuous proactive monitoring. </span><span class="koboSpan" id="kobo.845.3">Active monitoring works alongside passive monitoring as you run the known possible scenarios to replicate the user experience. </span><span class="koboSpan" id="kobo.845.4">You should run active monitoring across all dev, test, and prod environments to catch any issue before reaching the user.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.846.1">Passive </span><a id="_idIndexMarker859"/><span class="koboSpan" id="kobo.847.1">monitoring tries to identify unknown patterns in real time. </span><span class="koboSpan" id="kobo.847.2">For a web-based application, passive monitoring needs to collect essential metrics from the browser that can cause performance issues. </span><span class="koboSpan" id="kobo.847.3">You can gather metrics from users regarding their geolocation, browser types, and device types to understand your application’s user experience and geographic performance. </span><span class="koboSpan" id="kobo.847.4">Monitoring is all about data, including the ingestion, processing, and visualization of lots of data.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.848.1">Performance always comes at a cost, and, as a solution architect, you need to think about the trade-offs to take the right approach. </span><span class="koboSpan" id="kobo.848.2">For example, an organization’s internal applications, such as the timesheet and HR programs, may not need as high performance as external products, such as e-commerce applications. </span><span class="koboSpan" id="kobo.848.3">An application that deals with trading (for example) needs very high performance, which requires more investment. </span><span class="koboSpan" id="kobo.848.4">You should balance durability, consistency, cost, and performance to suit your application’s needs. </span><span class="koboSpan" id="kobo.848.5">You will continue to learn about the various monitoring methods and </span><a id="_idIndexMarker860"/><span class="koboSpan" id="kobo.849.1">tools in upcoming chapters and dive deep into monitoring and alerts in </span><em class="chapterRef"><span class="koboSpan" id="kobo.850.1">Chapter 8</span></em><span class="koboSpan" id="kobo.851.1">, </span><em class="italic"><span class="koboSpan" id="kobo.852.1">Architectural Reliability Considerations</span></em><span class="koboSpan" id="kobo.853.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.854.1">Tracking and improving performance are complex tasks where you need to collect lots of data and analyze patterns. </span><span class="koboSpan" id="kobo.854.2">An access pattern helps you to make the right choice for performance optimization. </span><span class="koboSpan" id="kobo.854.3">Applying continuous active monitoring in combination with passive monitoring helps you to maintain consistent performance for your application.</span></p>
<h1 class="heading-1" id="_idParaDest-222"><span class="koboSpan" id="kobo.855.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.856.1">In this chapter, you learned about the various architecture design principles that impact the performance of applications. </span><span class="koboSpan" id="kobo.856.2">You learned about latency and throughput at different layers of architecture and how they relate to each other.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.857.1">For highly performant applications, you need to have low latency and high throughput at every architecture layer. </span><span class="koboSpan" id="kobo.857.2">Concurrency helps to process a large number of requests. </span><span class="koboSpan" id="kobo.857.3">You also learned the differences between parallelism and concurrency and gained insights into how caching can help improve overall application performance.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.858.1">Then, you learned about choosing your technology and its working models, which can help achieve your desired application performance. </span><span class="koboSpan" id="kobo.858.2">While looking at the compute options, you learned about the various processor types and the differences between them to help you make the right choice when selecting server instances. </span><span class="koboSpan" id="kobo.858.3">You learned about containers and how they can help you to utilize resources efficiently and, at the same time, help to improve performance. </span><span class="koboSpan" id="kobo.858.4">You also learned how Docker and Kubernetes work well with each other and fit into your architecture.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.859.1">In the section on choosing storage, you learned about different kinds of storage, such as block, file, and object storage, and the differences between them. </span><span class="koboSpan" id="kobo.859.2">You also learned about the available storage choices in on-premises and cloud environments. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.860.1">In the section on choosing a database, you learned about the various database types, including relational databases, nonrelational databases and data warehouses. </span><span class="koboSpan" id="kobo.860.2">You also learned about the different request routing strategies that can help you improve network latency for your globally distributed users, and you learned how load balancers and auto-scaling can help you manage many user requests without compromising application performance. </span><span class="koboSpan" id="kobo.860.3">As mobile apps are critical for any application, you learned about performance considerations for mobile applications. </span><span class="koboSpan" id="kobo.860.4">You also learned about the importance of performance testing and monitoring your application for performance.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.861.1">In the next chapter, you will learn how to secure your application by applying authentication and authorization, which will help you to secure your data both at rest and in transit and ensure your application is protected from threats and attacks. </span><span class="koboSpan" id="kobo.861.2">You will also learn about compliance requirements and how to satisfy them when designing your application. </span><span class="koboSpan" id="kobo.861.3">You will learn about security audits, alerts, monitoring, and automation.</span></p>
<h1 class="heading-1" id="_idParaDest-223"><span class="koboSpan" id="kobo.862.1">Join our book’s Discord space</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.863.1">Join the book’s Discord workspace to ask questions and interact with the authors and other solution architecture professionals: </span><a href="Chapter_6.xhtml"><span class="url"><span class="koboSpan" id="kobo.864.1">https://packt.link/SAHandbook</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.865.1"><img alt="" role="presentation" src="../Images/QR_Code930022060277868125.png"/></span></p>
</div>
</body></html>