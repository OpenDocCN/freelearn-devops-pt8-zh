<html><head></head><body>
  <div id="_idContainer073">
   <h1 class="chapter-number" id="_idParaDest-101">
    <a id="_idTextAnchor146">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     5
    </span>
   </h1>
   <h1 id="_idParaDest-102">
    <a id="_idTextAnchor147">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     OpenStack Storage – Block, Object, and File Shares
    </span>
   </h1>
   <p class="author-quote">
    <span class="koboSpan" id="kobo.3.1">
     “Perseverance, secret of all triumphs.”
    </span>
   </p>
   <p class="author-quote">
    <span class="koboSpan" id="kobo.4.1">
     – Victor Hugo
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     The wide adoption of OpenStack services has increased user demand and, in turn, its array of capabilities, as demonstrated in the previous chapter with the compute service.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     This feature variation has also extended the OpenStack storage offering.
    </span>
    <span class="koboSpan" id="kobo.5.3">
     Users running workloads on top of an OpenStack environment would require more than one storage type in addition to a robust and reliable storage solution out of the box.
    </span>
    <span class="koboSpan" id="kobo.5.4">
     The spread of the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.6.1">
      software-defined storage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.7.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.8.1">
      SDS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.9.1">
     ) approach has enabled the OpenStack
    </span>
    <a id="_idIndexMarker455">
    </a>
    <span class="koboSpan" id="kobo.10.1">
     community to adopt more storage projects in which data storage is abstracted from physical storage.
    </span>
    <span class="koboSpan" id="kobo.10.2">
     Storage systems can be built on top of commodity hardware, but that would require a good understanding of each storage project’s purpose and the architecture behind it before exposing the service to cloud users so that they can
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.11.1">
      run workloads.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.12.1">
     In this chapter, an overwhelming array of storage services in OpenStack will be discussed and enabled in our existing OpenStack environment.
    </span>
    <span class="koboSpan" id="kobo.12.2">
     Throughout this chapter, we will cover the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.13.1">
      following topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.14.1">
      Reviewing the Cinder Block Storage service
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.15.1">
       in OpenStack
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.16.1">
      Expanding the Block Storage setup by configuring the three most used driver backends, using Kolla-Ansible for LVM, NFS,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.17.1">
       and Ceph
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.18.1">
      Uncovering the state of scheduling in Cinder and enabling a weighing mechanism in the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.19.1">
       existing cluster
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.20.1">
      Discussing the Swift Object Storage service
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.21.1">
       in OpenStack
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.22.1">
      Deploying an Object Storage cluster
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.23.1">
       using kolla-ansible
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.24.1">
      Exploring the latest updates on the file-sharing
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.25.1">
       service, Manila
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.26.1">
      Integrating the Manila service and deploying it
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.27.1">
       using
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.28.1">
        kolla-ansible
       </span>
      </strong>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-103">
    <a id="_idTextAnchor148">
    </a>
    <span class="koboSpan" id="kobo.29.1">
     Defining Block Storage – Cinder
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.30.1">
     Cinder provides persistent
    </span>
    <a id="_idIndexMarker456">
    </a>
    <span class="koboSpan" id="kobo.31.1">
     storage for instances.
    </span>
    <span class="koboSpan" id="kobo.31.2">
     The Block Storage
    </span>
    <a id="_idIndexMarker457">
    </a>
    <span class="koboSpan" id="kobo.32.1">
     service has been extensively developed through each OpenStack release to support more features and vendors’ backend drivers, allowing for a variety of storage devices to be used.
    </span>
    <span class="koboSpan" id="kobo.32.2">
     Most
    </span>
    <a id="_idIndexMarker458">
    </a>
    <span class="koboSpan" id="kobo.33.1">
     of the used storage backends include
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.34.1">
      logical volume management
     </span>
    </strong>
    <span class="koboSpan" id="kobo.35.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.36.1">
      LVM
     </span>
    </strong>
    <span class="koboSpan" id="kobo.37.1">
     ), IBM storage drivers, NetApp, and Dell storage.
    </span>
    <span class="koboSpan" id="kobo.37.2">
     Within the latest OpenStack releases, new backend drivers have been supported, such as Yadro, TOYOU, and Pure
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.38.1">
      Storage FlashArray.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.39.1">
     The storage device is reached by Cinder via its management access API and grants direct access to the instances to access and attach volumes.
    </span>
    <span class="koboSpan" id="kobo.39.2">
     A volume attached to an instance is shown as an additional hard drive can be partitioned and mounted onto the filesystem of a virtual machine.
    </span>
    <span class="koboSpan" id="kobo.39.3">
     The volumes are generally accessed by the defined storage path, which could use iSCSI, NFS, and Fiber Channels to do so.
    </span>
    <span class="koboSpan" id="kobo.39.4">
     It is important to bear in mind that Block Storage is persistent, which means it grants no data loss when an instance is terminated, unlike an
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.40.1">
      ephemeral disk.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.41.1">
     In our multi-node environment layout, the latest novelty of the Cinder service can be illustrated
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.42.1">
      as follows:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer066">
     <span class="koboSpan" id="kobo.43.1">
      <img alt="Figure 5.1 – Block Storage core architecture" src="image/B21716_05_01.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.44.1">
     Figure 5.1 – Block Storage core architecture
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.45.1">
     The core Cinder components
    </span>
    <a id="_idIndexMarker459">
    </a>
    <span class="koboSpan" id="kobo.46.1">
     can be summarized
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.47.1">
      as follows:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.48.1">
       cinder-api
      </span>
     </strong>
     <span class="koboSpan" id="kobo.49.1">
      : Processes block storage REST API requests
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.50.1">
       and responses
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.51.1">
       cinder-scheduler
      </span>
     </strong>
     <span class="koboSpan" id="kobo.52.1">
      : Like
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.53.1">
       nova-scheduler
      </span>
     </strong>
     <span class="koboSpan" id="kobo.54.1">
      in the Compute service, it redirects after filtering step requests to the appropriate
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.55.1">
       cinder-volume
      </span>
     </strong>
     <span class="koboSpan" id="kobo.56.1">
      server that will handle and provision the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.57.1">
       requested volume
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.58.1">
       cinder-volume
      </span>
     </strong>
     <span class="koboSpan" id="kobo.59.1">
      : Acts as a volume manager and runs in each
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.60.1">
       storage node
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.61.1">
       cinder-backup
      </span>
     </strong>
     <span class="koboSpan" id="kobo.62.1">
      : Enables volume backups to different
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.63.1">
       storage systems
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.64.1">
     The default OpenStack deployment would
    </span>
    <a id="_idIndexMarker460">
    </a>
    <span class="koboSpan" id="kobo.65.1">
     come with a Block Storage backend based on LVM.
    </span>
    <span class="koboSpan" id="kobo.65.2">
     The other very common
    </span>
    <a id="_idIndexMarker461">
    </a>
    <span class="koboSpan" id="kobo.66.1">
     use case of the backend is the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.67.1">
      Network File System
     </span>
    </strong>
    <span class="koboSpan" id="kobo.68.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.69.1">
      NFS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.70.1">
     ), which leverages existing shared storage.
    </span>
    <span class="koboSpan" id="kobo.70.2">
     Here, the only thing that you need to do is configure the Cinder service so that it can use the NFS driver.
    </span>
    <span class="koboSpan" id="kobo.70.3">
     It is important to keep up to date with the latest supported backend drivers by checking
    </span>
    <a id="_idIndexMarker462">
    </a>
    <span class="koboSpan" id="kobo.71.1">
     out the Cinder driver features matrix, available
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.72.1">
      here:
     </span>
    </span>
    <a href="https://docs.openstack.org/cinder/latest/reference/support-matrix.html">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.73.1">
       https://docs.openstack.org/cinder/latest/reference/support-matrix.html
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.74.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.75.1">
     The driver’s storage backends should support the minimum required volume functions, such as volume attachment, detachment, creation, deletion, extension, migration, and the creation of an image from a volume.
    </span>
    <span class="koboSpan" id="kobo.75.2">
     The drivers should also provide snapshot management features such as creation, deletion, and volume creation from a snapshot or a cloned volume.
    </span>
    <span class="koboSpan" id="kobo.75.3">
     A more extensive list of features can be considered optional within the latest OpenStack releases, depending on each backend driver, such as thin volume
    </span>
    <a id="_idIndexMarker463">
    </a>
    <span class="koboSpan" id="kobo.76.1">
     provisioning, live migration, multi-attach support, and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.77.1">
      quality of service
     </span>
    </strong>
    <span class="koboSpan" id="kobo.78.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.79.1">
      QoS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.80.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.80.2">
     Make sure you scan the existing storage backends and reflect the features supported in the matrix before moving to a full-block
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.81.1">
      storage deployment.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.82.1">
     In addition to the aforementioned drivers’ capabilities, Cinder supports a variety of configurable drivers for different storage vendors, such as NetApp, IBM, VMware, Dell, and Synology.
    </span>
    <span class="koboSpan" id="kobo.82.2">
     Bear in mind that not all backend products support all Cinder driver features.
    </span>
    <span class="koboSpan" id="kobo.82.3">
     On the other hand, the aforementioned Cinder operations are considered
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.83.1">
      must-haves
     </span>
    </em>
    <span class="koboSpan" id="kobo.84.1">
     when including a new driver storage backend in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.85.1">
      Cinder code.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.86.1">
     Security in Block Storage has been also tweaked by elaborating more on encryption in transit and at rest.
    </span>
    <span class="koboSpan" id="kobo.86.2">
     The Antelope release supports most of the Cinder driver’s TLS, which was a blocker in old releases for security teams when they dealt with traffic initiated from different service endpoints, as well as end users.
    </span>
    <span class="koboSpan" id="kobo.86.3">
     Encryption at rest has also reached a milestone, allowing data in volumes to be encrypted using the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.87.1">
      Cinder API.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.88.1">
     Another recent Cinder addition
    </span>
    <a id="_idIndexMarker464">
    </a>
    <span class="koboSpan" id="kobo.89.1">
     is the Block Storage backup capability.
    </span>
    <span class="koboSpan" id="kobo.89.2">
     It has become easier to simply fire a command line and instruct Cinder to either make a full backup of the volume or an incremental one if the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.90.1">
      backup exists.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-104">
    <a id="_idTextAnchor149">
    </a>
    <span class="koboSpan" id="kobo.91.1">
     Expanding storage with multiple backends
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.92.1">
     Our initial deployment highlighted
    </span>
    <a id="_idIndexMarker465">
    </a>
    <span class="koboSpan" id="kobo.93.1">
     the usage of a dedicated node
    </span>
    <a id="_idIndexMarker466">
    </a>
    <span class="koboSpan" id="kobo.94.1">
     to deal with storage and volume management in the OpenStack environment.
    </span>
    <span class="koboSpan" id="kobo.94.2">
     In the next section, we will expand the initial deployment highlighted in
    </span>
    <a href="B21716_02.xhtml#_idTextAnchor089">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.95.1">
        Chapter 2
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.96.1">
     ,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.97.1">
      Kicking Off the OpenStack Setup – The Right Way (DevSecOps)
     </span>
    </em>
    <span class="koboSpan" id="kobo.98.1">
     .
    </span>
    <span class="koboSpan" id="kobo.98.2">
     Depending on which storage backends will be used, additional nodes will be dedicated to hosting Cinder volumes as part of the data plane.
    </span>
    <span class="koboSpan" id="kobo.98.3">
     Cloud controller nodes host the Cinder API and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.99.1">
      scheduling services.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.100.1">
     Deploying with LVM
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.101.1">
     OpenStack’s default block storage
    </span>
    <a id="_idIndexMarker467">
    </a>
    <span class="koboSpan" id="kobo.102.1">
     backend is LVM.
    </span>
    <span class="koboSpan" id="kobo.102.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.103.1">
      cinder-volume
     </span>
    </strong>
    <span class="koboSpan" id="kobo.104.1">
     service uses the iSCSI target to operate and manage access to the logical volumes in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.105.1">
      storage node.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.106.1">
     On the storage nodes, we will create an LVM physical volume group.
    </span>
    <span class="koboSpan" id="kobo.106.2">
     In this example, we assume that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.107.1">
      /dev/sdb
     </span>
    </strong>
    <span class="koboSpan" id="kobo.108.1">
     is an available block device on the target
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.109.1">
      storage node:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.110.1">
$ pvcreate /dev/sdb</span></pre>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.111.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.112.1">
     Depending on the operating system, disk partitions might have different name listings.
    </span>
    <span class="koboSpan" id="kobo.112.2">
     You can check these out by using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.113.1">
      fdisk
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.114.1">
      command line.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.115.1">
     Next, create a new volume group
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.116.1">
      named
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.117.1">
       cinder-volumes
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.118.1">
      :
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.119.1">
$ vgcreate –f cinder-volumes /dev/sdb</span></pre>
   <p>
    <span class="koboSpan" id="kobo.120.1">
     In the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.121.1">
      kolla-ansible
     </span>
    </strong>
    <span class="koboSpan" id="kobo.122.1">
     code repository, add the new storage hostname to the inventory file located under
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.123.1">
      /ansible/inventory
     </span>
    </strong>
    <span class="koboSpan" id="kobo.124.1">
     , named
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.125.1">
      multi_packtpub_prod
     </span>
    </strong>
    <span class="koboSpan" id="kobo.126.1">
     .
    </span>
    <span class="koboSpan" id="kobo.126.2">
     In this example, we will use
    </span>
    <a id="_idIndexMarker468">
    </a>
    <span class="koboSpan" id="kobo.127.1">
     the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.128.1">
      storage02.os
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.129.1">
      storage node:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.130.1">
…
[storage]
storage02.os.packtpub
[cinder-volume:children]
storage
…</span></pre>
   <p>
    <span class="koboSpan" id="kobo.131.1">
     Enable the LVM backend in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.132.1">
      /
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.133.1">
       etc/kolla/globals.yml
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.134.1">
      file:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.135.1">
…
enable_cinder_backend_lvm: "yes"
…</span></pre>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.136.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.137.1">
     Once the LVM backend has been enabled,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.138.1">
      kolla-ansible
     </span>
    </strong>
    <span class="koboSpan" id="kobo.139.1">
     activates the iSCSI module that comes with the Ubuntu operating system and is configured by default in the Cinder role, located in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.140.1">
      /kolla-ansible/ansible/roles/cinder/defaults/main.yml
     </span>
    </strong>
    <span class="koboSpan" id="kobo.141.1">
     file.
    </span>
    <span class="koboSpan" id="kobo.141.2">
     For CentOS distributions, make sure that the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.142.1">
      LioAdm iSCSI
     </span>
    </strong>
    <span class="koboSpan" id="kobo.143.1">
     target helper is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.144.1">
      installed beforehand.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.145.1">
     Configure the name of the Cinder volume group created previously in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.146.1">
      /
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.147.1">
       etc/kolla/globals.yml
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.148.1">
      file:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.149.1">
…
cinder_volume_group: "cinder-volumes"
…</span></pre>
   <p>
    <span class="koboSpan" id="kobo.150.1">
     Run the job CI/CD pipeline in your staging environment before promoting the additional node to the production one.
    </span>
    <span class="koboSpan" id="kobo.150.2">
     Once deployed, a new kolla container running
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.151.1">
      cinder-volume
     </span>
    </strong>
    <span class="koboSpan" id="kobo.152.1">
     should be running
    </span>
    <a id="_idIndexMarker469">
    </a>
    <span class="koboSpan" id="kobo.153.1">
     in the target
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.154.1">
      storage node.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.155.1">
     Deploying with NFS
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.156.1">
     NFS is another commonly
    </span>
    <a id="_idIndexMarker470">
    </a>
    <span class="koboSpan" id="kobo.157.1">
     used storage backend.
    </span>
    <span class="koboSpan" id="kobo.157.2">
     Within existing NFS storage, cloud operators can smoothly manage volumes via the NFS protocol.
    </span>
    <span class="koboSpan" id="kobo.157.3">
     Created shares will be available and mounted by the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.158.1">
      cinder-volume
     </span>
    </strong>
    <span class="koboSpan" id="kobo.159.1">
     service to compute nodes.
    </span>
    <span class="koboSpan" id="kobo.159.2">
     The Cinder NFS driver enables access to file images on the shared NFS server and takes care of mapping the files to instances as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.160.1">
      block storage.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.161.1">
     In the following example, an NFS server named
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.162.1">
      nfs-host-pp
     </span>
    </strong>
    <span class="koboSpan" id="kobo.163.1">
     with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.164.1">
      nfs-host-pp:/nfs/share/cinder
     </span>
    </strong>
    <span class="koboSpan" id="kobo.165.1">
     share file path
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.166.1">
      is available.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.167.1">
     Create a share file in the target storage node by running the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.168.1">
      following command:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.169.1">
 $ echo "nfs-host-pp:/nfs/share/cinder" &gt; /etc/cinder/nfs_share</span></pre>
   <p>
    <span class="koboSpan" id="kobo.170.1">
     Make sure the NFS client is installed in both the compute and storage nodes.
    </span>
    <span class="koboSpan" id="kobo.170.2">
     You can do this by using Ansible or the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.171.1">
      command-line tool:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.172.1">
 $ apt-get install nfs-common</span></pre>
   <p>
    <span class="koboSpan" id="kobo.173.1">
     Enable
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.174.1">
      cinder-volume
     </span>
    </strong>
    <span class="koboSpan" id="kobo.175.1">
     in the Block Storage node to access the share file by adjusting the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.176.1">
      file permissions:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.177.1">
$ chown root:cinder /etc/cinder/nfs_share
$ chmod 640 /etc/cinder/nfs_share</span></pre>
   <p>
    <span class="koboSpan" id="kobo.178.1">
     In the NFS backend, make sure you specify the path of the share directory on the storage node, the storage network, and the access modes, including share, read-write, and non-root remote user access in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.179.1">
      /
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.180.1">
       etc/exports
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.181.1">
      file:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.182.1">
/nfs/share/cinder 10.30.0.0/24(rw,sync,no_root_squash)</span></pre>
   <p>
    <span class="koboSpan" id="kobo.183.1">
     For custom NFS deployment settings, you can create a new configuration file under
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.184.1">
      /etc/kolla/config
     </span>
    </strong>
    <span class="koboSpan" id="kobo.185.1">
     that will take precedence when running
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.186.1">
      kolla-ansible
     </span>
    </strong>
    <span class="koboSpan" id="kobo.187.1">
     .
    </span>
    <span class="koboSpan" id="kobo.187.2">
     The following example configuration file, named
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.188.1">
      nfs_shares
     </span>
    </strong>
    <span class="koboSpan" id="kobo.189.1">
     , will include a target storage node,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.190.1">
      storage02.os
     </span>
    </strong>
    <span class="koboSpan" id="kobo.191.1">
     , with custom NFS-mounted
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.192.1">
      file shares:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.193.1">
…
storage02.os:/nfs/share/cinder
…</span></pre>
   <p>
    <span class="koboSpan" id="kobo.194.1">
     Enable the NFS backend in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.195.1">
      /
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.196.1">
       etc/kolla/globals.yml
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.197.1">
      file:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.198.1">
…
enable_cinder_backend_nfs: "yes"
…</span></pre>
   <p>
    <span class="koboSpan" id="kobo.199.1">
     Running the job CI/CD pipeline with a newly configured NFS share will restart the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.200.1">
      cinder-volume
     </span>
    </strong>
    <span class="koboSpan" id="kobo.201.1">
     service in the target storage node.
    </span>
    <span class="koboSpan" id="kobo.201.2">
     Once deployed and running, the new NFS share directory should be mounted and visible in the storage node.
    </span>
    <span class="koboSpan" id="kobo.201.3">
     On the storage node, run the following command line
    </span>
    <a id="_idIndexMarker471">
    </a>
    <span class="koboSpan" id="kobo.202.1">
     to validate the mapped
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.203.1">
      NFS mount:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.204.1">
 # mount | grep nfs
nfs-host-pp:/nfs/share/cinder on /etc/cinder/nfs_share 223af296419e436d9142928374d8e57e
type nfs4
(rw,relatime,vers=4.1,rsize=81921,wsize=81921,namlen=255,hard,proto
=tcp,port=0,clientaddr=10.30.255.1,local_lock=none,addr=10.30.255.1
)</span></pre>
   <p>
    <span class="koboSpan" id="kobo.205.1">
     Each NFS share uses a mount point under
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.206.1">
      /etc/cinder/nfs_share
     </span>
    </strong>
    <span class="koboSpan" id="kobo.207.1">
     with a hashed directory,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.208.1">
      223af296419e436d9142928374d8e57e
     </span>
    </strong>
    <span class="koboSpan" id="kobo.209.1">
     , that will host any newly created volume.
    </span>
    <span class="koboSpan" id="kobo.209.2">
     You can check this by running the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.210.1">
      command line:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.211.1">
# openstack volume create --size 10 nfs-volume</span></pre>
   <p>
    <span class="koboSpan" id="kobo.212.1">
     The new volume should be located under the hashed directory of the NFS
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.213.1">
      mount point:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.214.1">
# ls /etc/cinder/nfs_share/223af296419e436d9142928374d8e57e
volume-b2be4de1-6e42-e3de-15e8-a72b60ca91ef</span></pre>
   <p>
    <span class="koboSpan" id="kobo.215.1">
     NFS storage is quite a popular storage
    </span>
    <a id="_idIndexMarker472">
    </a>
    <span class="koboSpan" id="kobo.216.1">
     backend in OpenStack.
    </span>
    <span class="koboSpan" id="kobo.216.2">
     Another type of backend is based on SDS, which will be covered in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.217.1">
      next section.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.218.1">
     Deploying with Ceph
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.219.1">
     Ceph’s SDS system gained significant
    </span>
    <a id="_idIndexMarker473">
    </a>
    <span class="koboSpan" id="kobo.220.1">
     success since its early days.
    </span>
    <span class="koboSpan" id="kobo.220.2">
     Ceph is designed to scale massively to exabytes of storage pools that can run on commodity x86 hardware architecture.
    </span>
    <span class="koboSpan" id="kobo.220.3">
     On top of that, Ceph interfaces support most storage types, including object, block, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.221.1">
      file shares.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.222.1">
     The OpenStack Foundation has committed to ensuring the integration of Ceph, and it can be incorporated and utilized within an existing OpenStack environment.
    </span>
    <span class="koboSpan" id="kobo.222.2">
     At its core is the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.223.1">
      Reliable Autonomic Distributed Object Store
     </span>
    </strong>
    <span class="koboSpan" id="kobo.224.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.225.1">
      RADOS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.226.1">
     ), which deals with the distribution, replication, and management
    </span>
    <a id="_idIndexMarker474">
    </a>
    <span class="koboSpan" id="kobo.227.1">
     of objects within the Ceph storage cluster.
    </span>
    <span class="koboSpan" id="kobo.227.2">
     Based on Ceph’s RADOS design, operators can define Ceph storage pools to be used as block storage and provide volumes to OpenStack instances.
    </span>
    <span class="koboSpan" id="kobo.227.3">
     This can be achieved by another mature
    </span>
    <a id="_idIndexMarker475">
    </a>
    <span class="koboSpan" id="kobo.228.1">
     Cinder backend driver known as a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.229.1">
      RADOS Block
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.230.1">
       Device
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.231.1">
      (
     </span>
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.232.1">
       RBD
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.233.1">
      ).
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.234.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.235.1">
     Ceph’s official documentation provides a complete description
    </span>
    <a id="_idIndexMarker476">
    </a>
    <span class="koboSpan" id="kobo.236.1">
     of the Ceph cluster setup using cephadm, available
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.237.1">
      at
     </span>
    </span>
    <a href="https://docs.ceph.com/en/latest/cephadm/install/">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.238.1">
       https://docs.ceph.com/en/latest/cephadm/install/
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.239.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.240.1">
     Ceph defines a set of core
    </span>
    <a id="_idIndexMarker477">
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.241.1">
      logical components:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.242.1">
       Object Storage Devices
      </span>
     </strong>
     <span class="koboSpan" id="kobo.243.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.244.1">
       OSDs
      </span>
     </strong>
     <span class="koboSpan" id="kobo.245.1">
      ): These correspond to the physical
     </span>
     <a id="_idIndexMarker478">
     </a>
     <span class="koboSpan" id="kobo.246.1">
      disks
     </span>
     <a id="_idIndexMarker479">
     </a>
     <span class="koboSpan" id="kobo.247.1">
      within
     </span>
     <a id="_idIndexMarker480">
     </a>
     <span class="koboSpan" id="kobo.248.1">
      a filesystem, such as
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.249.1">
       XFS
      </span>
     </strong>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.250.1">
       or
      </span>
     </span>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.251.1">
        Btrfs
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.252.1">
       .
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.253.1">
       Monitor daemon server
      </span>
     </strong>
     <span class="koboSpan" id="kobo.254.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.255.1">
       MON
      </span>
     </strong>
     <span class="koboSpan" id="kobo.256.1">
      ): Watches the state of data consistency
     </span>
     <a id="_idIndexMarker481">
     </a>
     <span class="koboSpan" id="kobo.257.1">
      and other metrics in each
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.258.1">
       OSD node.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.259.1">
       Pool
      </span>
     </strong>
     <span class="koboSpan" id="kobo.260.1">
      : Provides mapping for stored objects in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.261.1">
       an OSD.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.262.1">
       Placement groups
      </span>
     </strong>
     <span class="koboSpan" id="kobo.263.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.264.1">
       PGs
      </span>
     </strong>
     <span class="koboSpan" id="kobo.265.1">
      ): Maps of each object stored
     </span>
     <a id="_idIndexMarker482">
     </a>
     <span class="koboSpan" id="kobo.266.1">
      and OSDs.
     </span>
     <span class="koboSpan" id="kobo.266.2">
      Replicates objects across multiple
     </span>
     <a id="_idIndexMarker483">
     </a>
     <span class="koboSpan" id="kobo.267.1">
      OSDs within
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.268.1">
       a pool.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.269.1">
     If you have an existing Ceph cluster or are willing to deploy a new one, the following walk-through will guide you through the required steps for a basic Ceph integration in OpenStack.
    </span>
    <span class="koboSpan" id="kobo.269.2">
     In the following example, a dedicated cluster of three Ceph nodes runs
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.270.1">
      ceph-osd
     </span>
    </strong>
    <span class="koboSpan" id="kobo.271.1">
     .
    </span>
    <span class="koboSpan" id="kobo.271.2">
     Optionally,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.272.1">
      ceph-mon
     </span>
    </strong>
    <span class="koboSpan" id="kobo.273.1">
     will be running in the Cloud Controller node, as shown in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.274.1">
      following figure:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer067">
     <span class="koboSpan" id="kobo.275.1">
      <img alt="Figure 5.2 – Ceph storage integration in OpenStack" src="image/B21716_05_02.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.276.1">
     Figure 5.2 – Ceph storage integration in OpenStack
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.277.1">
     Make sure you have the Ceph client
    </span>
    <a id="_idIndexMarker484">
    </a>
    <span class="koboSpan" id="kobo.278.1">
     and Python
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.279.1">
      rbd
     </span>
    </strong>
    <span class="koboSpan" id="kobo.280.1">
     library packages installed on each controller, compute, and storage node.
    </span>
    <span class="koboSpan" id="kobo.280.2">
     Run the following command line if the Ceph client hasn’t
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.281.1">
      been installed:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.282.1">
$ apt-get install ceph-common python-rbd</span></pre>
   <p>
    <span class="koboSpan" id="kobo.283.1">
     On a Ceph node, create a storage pool to be used
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.284.1">
      by Cinder:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.285.1">
$ ceph osd pool create cinder-volumes 256</span></pre>
   <p>
    <span class="koboSpan" id="kobo.286.1">
     Initialize the created pool using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.287.1">
      rbd
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.288.1">
      command-line interface:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.289.1">
$ rbd pool init cinder-volumes</span></pre>
   <p>
    <span class="koboSpan" id="kobo.290.1">
     Create a Ceph user and keyring for Cinder to access the created
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.291.1">
       cinder-volumes
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.292.1">
      pool:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.293.1">
$ ceph auth get-or-create client.cinder mon 'profile rbd' osd 'profile rbd pool=cinder-volumes' mgr 'profile rbd pool=volumes' &gt; ceph.client.cinder.keyring
[client.cinder]
key = QA7sduw73dx83ks02210dj9Lmfj00sdju3ndoy==</span></pre>
   <p>
    <span class="koboSpan" id="kobo.294.1">
     Copy the created keyring to the OpenStack deployer, storage, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.295.1">
      compute nodes:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.296.1">
# ceph auth get-or-create client.cinder | ssh storage02.os sudo tee /etc/kolla/config/cinder/cinder-volume/ceph.client.cinder.keyring
# ceph auth get-or-create client.cinder | ssh cc01.os sudo tee /etc/ceph/ceph.client.cinder.keyring
# ceph auth get-or-create client.cinder | ssh cn01.os sudo tee /etc/ceph/ceph.client.cinder.keyring</span></pre>
   <p>
    <span class="koboSpan" id="kobo.297.1">
     Verify that the Cinder client
    </span>
    <a id="_idIndexMarker485">
    </a>
    <span class="koboSpan" id="kobo.298.1">
     can access the Ceph cluster by running the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.299.1">
      command line:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.300.1">
# ceph –s --name client.cinder --keyring /etc/ceph/ceph.client.cinder.keyring</span></pre>
   <p>
    <span class="koboSpan" id="kobo.301.1">
     Enable the Ceph backend in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.302.1">
      /
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.303.1">
       etc/kolla/globals.yml
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.304.1">
      file:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.305.1">
…
cinder_backend_ceph: "yes"
…</span></pre>
   <p>
    <span class="koboSpan" id="kobo.306.1">
     Additionally, make sure you specify the Ceph cinder user, the name of the pool, and the keyring in the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.307.1">
       globals.yml
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.308.1">
      file:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.309.1">
…
ceph_cinder_keyring: "ceph.client.cinder.keyring"
ceph_cinder_user: "cinder"
ceph_cinder_pool_name: "cinder-volumes"
…</span></pre>
   <p>
    <span class="koboSpan" id="kobo.310.1">
     Set the RBD Cinder UUID secret from the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.311.1">
      /
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.312.1">
       etc/kolla/passwords.yml
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.313.1">
      file:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.314.1">
# cat /etc/kolla/passwords.yml |grep cinder_rbd_secret_uuid cinder_rbd_secret_uuid: 612271b2-4537-3e21-65fa-a2e2523d3e421</span></pre>
   <p>
    <span class="koboSpan" id="kobo.315.1">
     From a Ceph node, copy the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.316.1">
      ceph.conf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.317.1">
     file to the custom
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.318.1">
      /etc/kolla/config/cinder
     </span>
    </strong>
    <span class="koboSpan" id="kobo.319.1">
     directory.
    </span>
    <span class="koboSpan" id="kobo.319.2">
     An example of a Ceph configuration extract is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.320.1">
      shown here:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.321.1">
[DEFAULT]
enabled_backends=rbd-1
[rbd-1]
rbd_ceph_conf=/etc/ceph/ceph.conf
rbd_user=cinder
backend_host=rbd:volumes
rbd_pool=cinder-volumes
volume_backend_name=rbd-1
volume_driver=cinder.volume.drivers.rbd.RBDDriver
rbd_secret_uuid = 612271b2-4537-3e21-65fa-a2e2523d3e421
[client]
rbd_cache = True
rbd_cache_size = 335544320
auth_cluster_required = cephx
auth_service_required = cephx
auth_client_required = cephx
...
</span><span class="koboSpan" id="kobo.321.2">fsid = 83baa63b-c421-480a-be24-0e2c59a70e17
mon_host = 10.30.0.22
mon_initial_members = ceph-1
cluster_network = 10.30.0.0/24
...</span></pre>
   <p>
    <span class="koboSpan" id="kobo.322.1">
     Roll the new changes by running the job CI/CD pipeline.
    </span>
    <span class="koboSpan" id="kobo.322.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.323.1">
      kolla-ansible
     </span>
    </strong>
    <span class="koboSpan" id="kobo.324.1">
     playbook will restart the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.325.1">
      cinder-volume
     </span>
    </strong>
    <span class="koboSpan" id="kobo.326.1">
     container with a new configuration.
    </span>
    <span class="koboSpan" id="kobo.326.2">
     The storage node should have a Ceph RBD driver enabled and working access to the Ceph cluster.
    </span>
    <span class="koboSpan" id="kobo.326.3">
     A new volume request should trigger
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.327.1">
      cinder-volume
     </span>
    </strong>
    <span class="koboSpan" id="kobo.328.1">
     to create the volume in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.329.1">
      cinder-volume
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.330.1">
      Ceph pool.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.331.1">
     OpenStack operators could leverage
    </span>
    <a id="_idIndexMarker486">
    </a>
    <span class="koboSpan" id="kobo.332.1">
     the usage of multiple storage backends simultaneously.
    </span>
    <span class="koboSpan" id="kobo.332.2">
     To enable such a capability efficiently, Cinder supports a special scheduling mechanism.
    </span>
    <span class="koboSpan" id="kobo.332.3">
     We’ll explore this in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.333.1">
      next section.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-105">
    <a id="_idTextAnchor150">
    </a>
    <span class="koboSpan" id="kobo.334.1">
     Storage filtering and scheduling
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.335.1">
     As demonstrated in the previous section, a variety
    </span>
    <a id="_idIndexMarker487">
    </a>
    <span class="koboSpan" id="kobo.336.1">
     of storage backends are supported
    </span>
    <a id="_idIndexMarker488">
    </a>
    <span class="koboSpan" id="kobo.337.1">
     by Cinder.
    </span>
    <span class="koboSpan" id="kobo.337.2">
     The block storage requests and their associated storage backend types are handled by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.338.1">
      cinder-scheduler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.339.1">
     .
    </span>
    <span class="koboSpan" id="kobo.339.2">
     Similar to the Compute scheduler service, the Block Storage scheduler service takes care of assigning each volume to be created to a specific backend available in the storage pool.
    </span>
    <span class="koboSpan" id="kobo.339.3">
     The Cinder scheduler uses filter policies to select the best backend fit for a new volume creation request.
    </span>
    <span class="koboSpan" id="kobo.339.4">
     A few filtering criteria will be evaluated based on the storage information capabilities, such as the state, available space, and drive state.
    </span>
    <span class="koboSpan" id="kobo.339.5">
     Afterward,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.340.1">
      cinder-scheduler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.341.1">
     uses a weighing mechanism that assigns each filtered backend a weight and sorts them out, as illustrated in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.342.1">
      following figure:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer068">
     <span class="koboSpan" id="kobo.343.1">
      <img alt="Figure 5.3 – Cinder’s scheduling and filtering mechanism" src="image/B21716_05_03.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.344.1">
     Figure 5.3 – Cinder’s scheduling and filtering mechanism
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.345.1">
     The scheduler periodically checks the state of the listed backends and continuously updates the storage backend
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.346.1">
      candidate list.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.347.1">
     By default, Cinder uses
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.348.1">
      CapacityFilter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.349.1">
     and, for weighing,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.350.1">
      CapacityWeigher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.351.1">
     , which filters
    </span>
    <a id="_idIndexMarker489">
    </a>
    <span class="koboSpan" id="kobo.352.1">
     the volume backends
    </span>
    <a id="_idIndexMarker490">
    </a>
    <span class="koboSpan" id="kobo.353.1">
     based on the storage size utilization.
    </span>
    <span class="koboSpan" id="kobo.353.2">
     The latest Cinder scheduler filters and weighers, at least up until
    </span>
    <a id="_idIndexMarker491">
    </a>
    <span class="koboSpan" id="kobo.354.1">
     the Bobcat release, can be found at
    </span>
    <a href="https://docs.openstack.org/cinder/latest/configuration/block-storage/scheduler-filters.html">
     <span class="koboSpan" id="kobo.355.1">
      https://docs.openstack.org/cinder/latest/configuration/block-storage/scheduler-filters.html
     </span>
    </a>
    <span class="koboSpan" id="kobo.356.1">
     and
    </span>
    <a href="https://docs.openstack.org/cinder/latest/configuration/block-storage/scheduler-weights.html">
     <span class="koboSpan" id="kobo.357.1">
      https://docs.openstack.org/cinder/latest/configuration/block-storage/scheduler-weights.html
     </span>
    </a>
    <span class="koboSpan" id="kobo.358.1">
     , respectively.
    </span>
    <span class="koboSpan" id="kobo.358.2">
     The following Cinder scheduler
    </span>
    <a id="_idIndexMarker492">
    </a>
    <span class="koboSpan" id="kobo.359.1">
     weighers list has changed over OpenStack releases, which lists the most adopted weighers in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.360.1">
      large deployments:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.361.1">
       CapacityWeigher
      </span>
     </strong>
     <span class="koboSpan" id="kobo.362.1">
      : Storage backend(s) are assigned the highest weight based on the most available and free
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.363.1">
       storage capacity.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.364.1">
       VolumeNumberWeigher
      </span>
     </strong>
     <span class="koboSpan" id="kobo.365.1">
      : Balances the volume allocation between different storage backends filtered by the scheduler.
     </span>
     <span class="koboSpan" id="kobo.365.2">
      This is the best option to spread multiple volume creation requests evenly across different backends that share the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.366.1">
       same name.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.367.1">
       GoodnessWeigher
      </span>
     </strong>
     <span class="koboSpan" id="kobo.368.1">
      : A more fine-grained weigher that places volumes based on specific storage properties.
     </span>
     <span class="koboSpan" id="kobo.368.2">
      It uses a formula that evaluates a storage backend, using a rating function, denoted as
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.369.1">
       goodness_function
      </span>
     </strong>
     <span class="koboSpan" id="kobo.370.1">
      , with the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.371.1">
       "(property_rule )?challengeVal1 : challengeVal2"
      </span>
     </strong>
     <span class="koboSpan" id="kobo.372.1">
      format.
     </span>
     <span class="koboSpan" id="kobo.372.2">
      The attribution of weights varies between
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.373.1">
       0
      </span>
     </strong>
     <span class="koboSpan" id="kobo.374.1">
      (the lowest) and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.375.1">
       100
      </span>
     </strong>
     <span class="koboSpan" id="kobo.376.1">
      (the highest), based on the evaluation of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.377.1">
       property_rule
      </span>
     </strong>
     <span class="koboSpan" id="kobo.378.1">
      ,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.379.1">
       as follows:
      </span>
     </span>
     <ul>
      <li>
       <span class="koboSpan" id="kobo.380.1">
        If
       </span>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.381.1">
         property_rule
        </span>
       </strong>
       <span class="koboSpan" id="kobo.382.1">
        returns
       </span>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.383.1">
         true
        </span>
       </strong>
       <span class="koboSpan" id="kobo.384.1">
        , then the storage backend is assigned the weight of the
       </span>
       <span class="No-Break">
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.385.1">
          challengeVal1
         </span>
        </strong>
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.386.1">
         value
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.387.1">
        If
       </span>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.388.1">
         property_rule
        </span>
       </strong>
       <span class="koboSpan" id="kobo.389.1">
        returns
       </span>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.390.1">
         false
        </span>
       </strong>
       <span class="koboSpan" id="kobo.391.1">
        , then the storage backend is assigned the weight of the
       </span>
       <span class="No-Break">
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.392.1">
          challengeVal2
         </span>
        </strong>
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.393.1">
         value
        </span>
       </span>
      </li>
     </ul>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.394.1">
     The following step-by-step configuration
    </span>
    <a id="_idIndexMarker493">
    </a>
    <span class="koboSpan" id="kobo.395.1">
     will demonstrate the usage of Cinder scheduling, by enabling default filters
    </span>
    <a id="_idIndexMarker494">
    </a>
    <span class="koboSpan" id="kobo.396.1">
     and using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.397.1">
      GoodWeigher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.398.1">
     to choose an ideal storage backend for each volume request.
    </span>
    <span class="koboSpan" id="kobo.398.2">
     In this setup, two of the storage backends we configured in previous sections will be used for LVM and Ceph, respectively.
    </span>
    <span class="koboSpan" id="kobo.398.3">
     We can continue to add a custom scheduling configuration by creating a new file,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.399.1">
      /etc/kolla/config/cinder/cinder.conf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.400.1">
     .
    </span>
    <span class="koboSpan" id="kobo.400.2">
     Running
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.401.1">
      kolla-ansible
     </span>
    </strong>
    <span class="koboSpan" id="kobo.402.1">
     will merge any configuration file under the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.403.1">
      /etc/kolla/config/cinder
     </span>
    </strong>
    <span class="koboSpan" id="kobo.404.1">
     directory with the one in the main template defined in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.405.1">
      /kolla-ansible/ansible/roles/cinder/templates/cinder.conf.j2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.406.1">
     file.
    </span>
    <span class="koboSpan" id="kobo.406.2">
     The new file will be configured with the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.407.1">
      following settings:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.408.1">
      Enable the list of schedulers in a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.409.1">
       new section:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.410.1">
[default]
scheduler_default_filters = DriverFilter,CapacityFilter,CapabilitiesFilter</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.411.1">
      Add
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.412.1">
       GoodnessWeigher
      </span>
     </strong>
     <span class="koboSpan" id="kobo.413.1">
      as a main weigher mechanism,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.414.1">
       as follows:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.415.1">
scheduler_default_weighers = GoodnessWeigher</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.416.1">
      For each backend section, add
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.417.1">
       goodness_function
      </span>
     </strong>
     <span class="koboSpan" id="kobo.418.1">
      to define a rating based on the storage provider’s capability.
     </span>
     <span class="koboSpan" id="kobo.418.2">
      The next simple configuration evaluates the volume size and checks whether both backends’ utilization of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.419.1">
       lvm-1
      </span>
     </strong>
     <span class="koboSpan" id="kobo.420.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.421.1">
       rbd
      </span>
     </strong>
     <span class="koboSpan" id="kobo.422.1">
      is less than 50%.
     </span>
     <span class="koboSpan" id="kobo.422.2">
      If so,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.423.1">
       50
      </span>
     </strong>
     <span class="koboSpan" id="kobo.424.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.425.1">
       80
      </span>
     </strong>
     <span class="koboSpan" id="kobo.426.1">
      weights will be assigned, respectively.
     </span>
     <span class="koboSpan" id="kobo.426.2">
      In this case,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.427.1">
       rbd
      </span>
     </strong>
     <span class="koboSpan" id="kobo.428.1">
      is the best candidate to place the volume.
     </span>
     <span class="koboSpan" id="kobo.428.2">
      If the backend utilization on
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.429.1">
       lvm-1
      </span>
     </strong>
     <span class="koboSpan" id="kobo.430.1">
      is greater than 50% and less than 50% for
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.431.1">
       rbd
      </span>
     </strong>
     <span class="koboSpan" id="kobo.432.1">
      , the weigher will assign
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.433.1">
       80
      </span>
     </strong>
     <span class="koboSpan" id="kobo.434.1">
      to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.435.1">
       rbd
      </span>
     </strong>
     <span class="koboSpan" id="kobo.436.1">
      and a weight of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.437.1">
       30
      </span>
     </strong>
     <span class="koboSpan" id="kobo.438.1">
      to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.439.1">
       lvm-1
      </span>
     </strong>
     <span class="koboSpan" id="kobo.440.1">
      .
     </span>
     <span class="koboSpan" id="kobo.440.2">
      The last case of weight logic is when both backends’ utilization is more than 50% – in this case,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.441.1">
       lvm-1
      </span>
     </strong>
     <span class="koboSpan" id="kobo.442.1">
      will be selected with
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.443.1">
       30
      </span>
     </strong>
     <span class="koboSpan" id="kobo.444.1">
      compared to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.445.1">
       rbd
      </span>
     </strong>
     <span class="koboSpan" id="kobo.446.1">
      , which is assigned a weight
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.447.1">
       of
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.448.1">
        20
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.449.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.450.1">
[lvm-1]
...
</span><span class="koboSpan" id="kobo.450.2">goodness_function = "(capabilities.utilization &lt; 50.0)?50:30"
...
</span><span class="koboSpan" id="kobo.450.3">[rbd]
...
</span><span class="koboSpan" id="kobo.450.4">goodness _function = "(capabilities.utilization &lt; 50.0)?80:20"</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.451.1">
      Run the same job’s CI/CD pipeline, and make sure that
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.452.1">
       kolla-ansible
      </span>
     </strong>
     <span class="koboSpan" id="kobo.453.1">
      will restart the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.454.1">
       cinder-volume
      </span>
     </strong>
     <span class="koboSpan" id="kobo.455.1">
      container with a new configuration.
     </span>
     <span class="koboSpan" id="kobo.455.2">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.456.1">
       cinder.conf
      </span>
     </strong>
     <span class="koboSpan" id="kobo.457.1">
      file should have an extended configuration list of the configured schedulers
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.458.1">
       and weighers.
      </span>
     </span>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.459.1">
     Cinder provides constructs
    </span>
    <a id="_idIndexMarker495">
    </a>
    <span class="koboSpan" id="kobo.460.1">
     to request volumes
    </span>
    <a id="_idIndexMarker496">
    </a>
    <span class="koboSpan" id="kobo.461.1">
     with a specific storage backend, using volume types.
    </span>
    <span class="koboSpan" id="kobo.461.2">
     The following example shows how to define two volume types for LVM and Ceph, based on each backend name to be used when
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.462.1">
      creating volumes:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.463.1">
$ openstack volume type create lvm_standard
$ openstack volume type set lvm_standard --property volume_backend_name=lvm-1
$ openstack volume type create rbd_large
$ openstack volume type set rbd_large --property volume_backend_name=rbd-1</span></pre>
   <p>
    <span class="koboSpan" id="kobo.464.1">
     Users should be able to create volumes transparently based on storage types, as defined in the preceding command lines.
    </span>
    <span class="koboSpan" id="kobo.464.2">
     The storage pool offer can be classified as large block storage with replication capabilities, defined as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.465.1">
      rbd_large
     </span>
    </strong>
    <span class="koboSpan" id="kobo.466.1">
     , and a second standard storage capability for general purposes, defined
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.467.1">
      as
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.468.1">
       lvm_standard
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.469.1">
      :
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.470.1">
$ openstack volume create --size 10 --type lvm_standard general_volume
$ openstack volume create --size 50 --type rbd_large large_volume</span></pre>
   <p>
    <span class="koboSpan" id="kobo.471.1">
     In this scenario, the Cinder scheduler will assign each volume request to the designated backend storage –
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.472.1">
      lvm-1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.473.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.474.1">
      rbd
     </span>
    </strong>
    <span class="koboSpan" id="kobo.475.1">
     , respectively.
    </span>
    <span class="koboSpan" id="kobo.475.2">
     In other cases, two or more storage backends can share the same volume backend name,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.476.1">
      volume_backend_name
     </span>
    </strong>
    <span class="koboSpan" id="kobo.477.1">
     – in this case, the scheduler will promote the storage backend type based on its scheduling and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.478.1">
      weighing filters.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.479.1">
     With the integration of various
    </span>
    <a id="_idIndexMarker497">
    </a>
    <span class="koboSpan" id="kobo.480.1">
     storage solutions
    </span>
    <a id="_idIndexMarker498">
    </a>
    <span class="koboSpan" id="kobo.481.1">
     and advanced scheduling mechanisms, cloud operators can take advantage of an array of features in each storage solution, managed through a single Cinder interface.
    </span>
    <span class="koboSpan" id="kobo.481.2">
     Besides the Block Storage option, OpenStack offers another storage service focused on objects, code named Swift.
    </span>
    <span class="koboSpan" id="kobo.481.3">
     We will cover this in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.482.1">
      next section.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-106">
    <a id="_idTextAnchor151">
    </a>
    <span class="koboSpan" id="kobo.483.1">
     Revisiting object storage – Swift
    </span>
   </h1>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.484.1">
      Swift
     </span>
    </strong>
    <span class="koboSpan" id="kobo.485.1">
     is a service tailored to store large volumes
    </span>
    <a id="_idIndexMarker499">
    </a>
    <span class="koboSpan" id="kobo.486.1">
     of unstructured object data, such as text or binary data.
    </span>
    <span class="koboSpan" id="kobo.486.2">
     It enables OpenStack operators to build distributed object storage systems by using commodity storage.
    </span>
    <span class="koboSpan" id="kobo.486.3">
     The hallmark of the Swift service is the way it is designed, which ensures data availability and durability.
    </span>
    <span class="koboSpan" id="kobo.486.4">
     Several workloads that can run in an OpenStack cloud environment, such as web applications, can leverage object storage by enjoying the advantages of this simple service’s usage and management, as well as its transparent data replication and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.487.1">
      horizontal scaling.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-107">
    <a id="_idTextAnchor152">
    </a>
    <span class="koboSpan" id="kobo.488.1">
     Revisiting Swift
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.489.1">
     Swift’s logical core components
    </span>
    <a id="_idIndexMarker500">
    </a>
    <span class="koboSpan" id="kobo.490.1">
     consist mainly of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.491.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.492.1">
       Account server
      </span>
     </strong>
     <span class="koboSpan" id="kobo.493.1">
      : Represents a namespace for a list of containers associated with a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.494.1">
       Swift account.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.495.1">
       Container server
      </span>
     </strong>
     <span class="koboSpan" id="kobo.496.1">
      : Refers to the user-defined storage area within a Swift account where it stores a list
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.497.1">
       of objects.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.498.1">
       Object server
      </span>
     </strong>
     <span class="koboSpan" id="kobo.499.1">
      : Manages an actual object within a container.
     </span>
     <span class="koboSpan" id="kobo.499.2">
      Object storage defines where the actual data and its metadata are stored.
     </span>
     <span class="koboSpan" id="kobo.499.3">
      Each object must belong to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.500.1">
       a container.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.501.1">
       Proxy server
      </span>
     </strong>
     <span class="koboSpan" id="kobo.502.1">
      : Handles different types of incoming object API or HTTP requests, such as container creation, object uploads,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.503.1">
       and deletion.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.504.1">
       Partition
      </span>
     </strong>
     <span class="koboSpan" id="kobo.505.1">
      : Manages the location of objects, containers, and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.506.1">
       account databases.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.507.1">
       Zones
      </span>
     </strong>
     <span class="koboSpan" id="kobo.508.1">
      : Separate objects within physical zone isolation to prevent wider data loss during a zonal failure in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.509.1">
       a cluster.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.510.1">
       Rings
      </span>
     </strong>
     <span class="koboSpan" id="kobo.511.1">
      : Defines a logical mapping
     </span>
     <a id="_idIndexMarker501">
     </a>
     <span class="koboSpan" id="kobo.512.1">
      of objects, accounts, and containers to a physical location in a Swift cluster.
     </span>
     <span class="koboSpan" id="kobo.512.2">
      Swift uses a ring per storage construct.
     </span>
     <span class="koboSpan" id="kobo.512.3">
      It also uses
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.513.1">
       swift-ring-builder
      </span>
     </strong>
     <span class="koboSpan" id="kobo.514.1">
      to create an inventory of the cluster and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.515.1">
       create partitions.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.516.1">
     As shown in the following figure, each partition will have three replicas that reflect three copies of the same object, container, or account to maintain high availability
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.517.1">
      of data:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer069">
     <span class="koboSpan" id="kobo.518.1">
      <img alt="Figure 5.4 – Swift rings and replication in a three-zone layout" src="image/B21716_05_04.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.519.1">
     Figure 5.4 – Swift rings and replication in a three-zone layout
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.520.1">
     As well as the previous core components, Swift uses additional background daemons to manage objects’ indexing, updates,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.521.1">
      and replications.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-108">
    <a id="_idTextAnchor153">
    </a>
    <span class="koboSpan" id="kobo.522.1">
     Building a Swift cluster
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.523.1">
     There are a variety of parameters
    </span>
    <a id="_idIndexMarker502">
    </a>
    <span class="koboSpan" id="kobo.524.1">
     that should be considered when preparing an object storage cluster before integrating it with an existing OpenStack environment.
    </span>
    <span class="koboSpan" id="kobo.524.2">
     The focus should be on the hardware requirements to achieve a highly available, standalone, and expandable cluster.
    </span>
    <span class="koboSpan" id="kobo.524.3">
     The following is a starting point for deploying a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.525.1">
      Swift cluster:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.526.1">
       Object Storage capacity
      </span>
     </strong>
     <span class="koboSpan" id="kobo.527.1">
      :
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.528.1">
       100 TB
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.529.1">
       Number of hard drive slots per
      </span>
     </strong>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.530.1">
        chassis
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.531.1">
       : 50
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.532.1">
       Hard drive storage capacity
      </span>
     </strong>
     <span class="koboSpan" id="kobo.533.1">
      :
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.534.1">
       3 TB
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.535.1">
       Recommended cluster
      </span>
     </strong>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.536.1">
        replicas
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.537.1">
       : 3
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.538.1">
       Supported
      </span>
     </strong>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.539.1">
        filesystem
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.540.1">
       : XFS
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.541.1">
     As we intend to keep three replicas, as recommended, the total storage capacity should be three times the recommended size, giving us
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.542.1">
      3 * 100 =
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.543.1">
       300 TB
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.544.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.545.1">
     The usage of XFS as a filesystem requires a metadata overhead in storage with a factor of 1.0526.
    </span>
    <span class="koboSpan" id="kobo.545.2">
     The rounded required storage space, in this case, will be calculated
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.546.1">
      as follows:
     </span>
    </span>
   </p>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.547.1">
      300 * 1.0526 =
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.548.1">
       316 TB
      </span>
     </strong>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.549.1">
     Using the total space required will help you find the number of hard drives required,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.550.1">
      as follows:
     </span>
    </span>
   </p>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.551.1">
      316/3 =
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.552.1">
       106 drives
      </span>
     </strong>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.553.1">
     The number of storage nodes will be determined
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.554.1">
      as follows:
     </span>
    </span>
   </p>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.555.1">
      106 / 50 =
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.556.1">
       3 nodes
      </span>
     </strong>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.557.1">
     Our initial cluster will be composed of three storage nodes that will host containers, accounts, and objects.
    </span>
    <span class="koboSpan" id="kobo.557.2">
     To manage the Swift requests, in our initial draft, we have assigned the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.558.1">
      swift-proxy
     </span>
    </strong>
    <span class="koboSpan" id="kobo.559.1">
     server to run on the controller node.
    </span>
    <span class="koboSpan" id="kobo.559.2">
     One of the caveats of keeping the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.560.1">
      swift-proxy
     </span>
    </strong>
    <span class="koboSpan" id="kobo.561.1">
     role on the controller node is the performance risk that could overload the cloud controller resources.
    </span>
    <span class="koboSpan" id="kobo.561.2">
     As a cloud operator, it is recommended to monitor the object API requests reaching the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.562.1">
      swift-proxy
     </span>
    </strong>
    <span class="koboSpan" id="kobo.563.1">
     service and start to move it to dedicated hardware when the storage cluster continues to expand, in terms of size
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.564.1">
      and usage.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.565.1">
     Another critical consideration
    </span>
    <a id="_idIndexMarker503">
    </a>
    <span class="koboSpan" id="kobo.566.1">
     when dealing with an extended Swift storage system is the networking layout.
    </span>
    <span class="koboSpan" id="kobo.566.2">
     In our initial design draft, a network interface is dedicated to handling storage.
    </span>
    <span class="koboSpan" id="kobo.566.3">
     As per the Swift architecture, more interfaces can be assigned for different networking purposes.
    </span>
    <span class="koboSpan" id="kobo.566.4">
     These are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.567.1">
      listed here:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.568.1">
       Storage interface
      </span>
     </strong>
     <span class="koboSpan" id="kobo.569.1">
      : A proxy server that interfaces
     </span>
     <a id="_idIndexMarker504">
     </a>
     <span class="koboSpan" id="kobo.570.1">
      the storage nodes running the object, container, and account servers.
     </span>
     <span class="koboSpan" id="kobo.570.2">
      The associated configuration in
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.571.1">
       kolla-ansible
      </span>
     </strong>
     <span class="koboSpan" id="kobo.572.1">
      is defined in the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.573.1">
       globals.yml
      </span>
     </strong>
     <span class="koboSpan" id="kobo.574.1">
      file
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.575.1">
       as
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.576.1">
        swift_storage_interface
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.577.1">
       .
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.578.1">
       Replication interface
      </span>
     </strong>
     <span class="koboSpan" id="kobo.579.1">
      : Optionally, an additional interface
     </span>
     <a id="_idIndexMarker505">
     </a>
     <span class="koboSpan" id="kobo.580.1">
      in each storage node can be dedicated to handling Swift storage replication between the storage nodes.
     </span>
     <span class="koboSpan" id="kobo.580.2">
      The associated configuration in
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.581.1">
       kolla-ansible
      </span>
     </strong>
     <span class="koboSpan" id="kobo.582.1">
      is defined in the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.583.1">
       globals.yml
      </span>
     </strong>
     <span class="koboSpan" id="kobo.584.1">
      file as
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.585.1">
       swift_replication_interface
      </span>
     </strong>
     <span class="koboSpan" id="kobo.586.1">
      .
     </span>
     <span class="koboSpan" id="kobo.586.2">
      This option is not considered in the current setup and will use the storage interface to handle the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.587.1">
       replication traffic.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.588.1">
       Internal API interface
      </span>
     </strong>
     <span class="koboSpan" id="kobo.589.1">
      : This can be defined to allow users
     </span>
     <a id="_idIndexMarker506">
     </a>
     <span class="koboSpan" id="kobo.590.1">
      access to the proxy server internally.
     </span>
     <span class="koboSpan" id="kobo.590.2">
      The same interface can be used by HAProxy to establish load balancing between two or more swift-proxy services for high availability.
     </span>
     <span class="koboSpan" id="kobo.590.3">
      The associated configuration in
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.591.1">
       kolla-ansible
      </span>
     </strong>
     <span class="koboSpan" id="kobo.592.1">
      is defined in the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.593.1">
       globals.yml
      </span>
     </strong>
     <span class="koboSpan" id="kobo.594.1">
      file as
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.595.1">
       api_interface
      </span>
     </strong>
     <span class="koboSpan" id="kobo.596.1">
      .
     </span>
     <span class="koboSpan" id="kobo.596.2">
      This option is not considered in the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.597.1">
       current setup.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.598.1">
       External API interface
      </span>
     </strong>
     <span class="koboSpan" id="kobo.599.1">
      : Optionally, Swift can be accessed externally
     </span>
     <a id="_idIndexMarker507">
     </a>
     <span class="koboSpan" id="kobo.600.1">
      when workloads require public API access.
     </span>
     <span class="koboSpan" id="kobo.600.2">
      The associated configuration in
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.601.1">
       kolla-ansible
      </span>
     </strong>
     <span class="koboSpan" id="kobo.602.1">
      is defined in the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.603.1">
       globals.yml
      </span>
     </strong>
     <span class="koboSpan" id="kobo.604.1">
      file as
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.605.1">
       kolla_external_vip_interface
      </span>
     </strong>
     <span class="koboSpan" id="kobo.606.1">
      .
     </span>
     <span class="koboSpan" id="kobo.606.2">
      This option is not considered in the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.607.1">
       current setup.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.608.1">
     Swift can easily expand exponentially due to its common use cases; thus, cloud operators should expect possible growth of the underlying infrastructure.
    </span>
    <span class="koboSpan" id="kobo.608.2">
     A common pain point is to get locked in a limited hardware configuration and not be prepared for it beforehand.
    </span>
    <span class="koboSpan" id="kobo.608.3">
     Having additional network interfaces will prove a big advantage when operators realize there’s a degradation
    </span>
    <a id="_idIndexMarker508">
    </a>
    <span class="koboSpan" id="kobo.609.1">
     in network performance.
    </span>
    <span class="koboSpan" id="kobo.609.2">
     Separating the traffic types in a dedicated interface will avoid the burden of operational overhead
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.610.1">
      and firefighting.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-109">
    <a id="_idTextAnchor154">
    </a>
    <span class="koboSpan" id="kobo.611.1">
     Running Swift
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.612.1">
     Before deploying the Swift cluster
    </span>
    <a id="_idIndexMarker509">
    </a>
    <span class="koboSpan" id="kobo.613.1">
     using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.614.1">
      kolla-ansible
     </span>
    </strong>
    <span class="koboSpan" id="kobo.615.1">
     , we will need to prepare the storage node filesystem.
    </span>
    <span class="koboSpan" id="kobo.615.2">
     The following shell script will create partitions on each available disk –
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.616.1">
      sdc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.617.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.618.1">
      sdd
     </span>
    </strong>
    <span class="koboSpan" id="kobo.619.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.620.1">
      sde
     </span>
    </strong>
    <span class="koboSpan" id="kobo.621.1">
     – that should run in each
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.622.1">
      storage node:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.623.1">
for i in sdc sdd sde; do
     parted /dev/${i} -s -- mklabel gpt mkpart KOLLA_SWIFT_DATA 1 -1
done</span></pre>
   <p>
    <span class="koboSpan" id="kobo.624.1">
     For each created partition, create an XFS file system using the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.625.1">
      shell script:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.626.1">
loop=0
for i in sdc sdd sde; do
     sudo mkfs.xfs -f -L i${loop} /dev/${i}1
    (( loop++ ))
done</span></pre>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.627.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.628.1">
     The filesystem label is referred to as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.629.1">
      KOLLA_SWIFT_DATA
     </span>
    </strong>
    <span class="koboSpan" id="kobo.630.1">
     , which should be visible in the storage node.
    </span>
    <span class="koboSpan" id="kobo.630.2">
     The name of the device should match the configuration settings in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.631.1">
      globals
     </span>
    </strong>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.632.1">
      .yml
     </span>
    </strong>
    <span class="koboSpan" id="kobo.633.1">
     file, defined by the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.634.1">
       swift_devices_name
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.635.1">
      setting.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.636.1">
     Next, generate the rings to prepare mapping objects in the Swift cluster.
    </span>
    <span class="koboSpan" id="kobo.636.2">
     At the time of writing, the Object Storage playbook does not automate the ring generation process.
    </span>
    <span class="koboSpan" id="kobo.636.3">
     Start by generating the object ring, and then run the following script from the deployer node.
    </span>
    <span class="koboSpan" id="kobo.636.4">
     The first part of the script defines the cluster storage IP addresses, the Swift Kolla image, and a new directory for a custom Swift Kolla configuration
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.637.1">
      path, respectively:
     </span>
    </span>
   </p>
   <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.638.1">$ STORAGE_NODES=(10.30.0.81 10.30.0.82 10.30.0.83) </span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.639.1">$ KOLLA_SWIFT_BASE_IMAGE="kolla/ubuntu-source-swift-base:8.0.5" </span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.640.1">$ sudo mkdir -p /etc/kolla/config/swift</span></strong></pre>
   <p>
    <span class="koboSpan" id="kobo.641.1">
     Swift uses the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.642.1">
      swift-ring-builder
     </span>
    </strong>
    <span class="koboSpan" id="kobo.643.1">
     tool to generate
    </span>
    <a id="_idIndexMarker510">
    </a>
    <span class="koboSpan" id="kobo.644.1">
     an object ring.
    </span>
    <span class="koboSpan" id="kobo.644.2">
     The generic format of the ring builder command is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.645.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.646.1">
swift-ring-builder &lt;builder_file&gt; create &lt;part_power&gt; &lt;replicas&gt; &lt;min_part_hours&gt;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.647.1">
     Here, we have
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.648.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.649.1">
       &lt;builder_file&gt;
      </span>
     </strong>
     <span class="koboSpan" id="kobo.650.1">
      : This can be one of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.651.1">
       account.builder
      </span>
     </strong>
     <span class="koboSpan" id="kobo.652.1">
      ,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.653.1">
       container.builder
      </span>
     </strong>
     <span class="koboSpan" id="kobo.654.1">
      ,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.655.1">
       or
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.656.1">
        object.builder
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.657.1">
       .
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.658.1">
       &lt;part_power&gt;
      </span>
     </strong>
     <span class="koboSpan" id="kobo.659.1">
      : The number of partitions is approximated to the closest power of 2 to get the part power of the cluster.
     </span>
     <span class="koboSpan" id="kobo.659.2">
      For example, for 50 hard disks, the recommended part power is 11, which gives us a value of 2,048 on average for all partitions.
     </span>
     <span class="koboSpan" id="kobo.659.3">
      It is recommended that the approximation is
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.660.1">
       rounded up.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.661.1">
       &lt;replicas&gt;
      </span>
     </strong>
     <span class="koboSpan" id="kobo.662.1">
      : A choice of three replicas will be the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.663.1">
       recommended value.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.664.1">
       &lt;min_part_hours&gt;
      </span>
     </strong>
     <span class="koboSpan" id="kobo.665.1">
      : This determines the time in an hour during which only one replica of a partition can
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.666.1">
       be moved.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.667.1">
     Rackspace Lab provides an online easy tool to calculate
    </span>
    <a id="_idIndexMarker511">
    </a>
    <span class="koboSpan" id="kobo.668.1">
     the swift ring.
    </span>
    <span class="koboSpan" id="kobo.668.2">
     It can be found
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.669.1">
      at
     </span>
    </span>
    <a href="https://rackerlabs.github.io/swift-ppc/">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.670.1">
       https://rackerlabs.github.io/swift-ppc/
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.671.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.672.1">
     The next part of the script will build the ring for the objects and iterate through each storage node by adding available devices to the ring on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.673.1">
      port
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.674.1">
       6000
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.675.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.676.1">
docker run \
  --rm \
  -v /etc/kolla/config/swift/:/etc/kolla/config/swift/ \
  $KOLLA_SWIFT_BASE_IMAGE \
  swift-ring-builder \
    /etc/kolla/config/swift/</span><strong class="bold"><span class="koboSpan" id="kobo.677.1">object.builder</span></strong><span class="koboSpan" id="kobo.678.1"> create </span><strong class="bold"><span class="koboSpan" id="kobo.679.1">11 3 1</span></strong><span class="koboSpan" id="kobo.680.1">
for node in ${STORAGE_NODES[@]}; do
    for i in {0..2}; do
      docker run \
        --rm \
        -v /etc/kolla/config/swift/:/etc/kolla/config/swift/ \
        $KOLLA_SWIFT_BASE_IMAGE \
        swift-ring-builder \
          /etc/kolla/config/swift/object.builder add \
          r1z1-${node}:6000/d${i} 1;
    done
done</span></pre>
   <p>
    <span class="koboSpan" id="kobo.681.1">
     The following section of the script
    </span>
    <a id="_idIndexMarker512">
    </a>
    <span class="koboSpan" id="kobo.682.1">
     will generate a ring file for the account and add available devices to the ring for each storage node on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.683.1">
      port
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.684.1">
       6001
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.685.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.686.1">
docker run \
  --rm \
  -v /etc/kolla/config/swift/:/etc/kolla/config/swift/ \
  $KOLLA_SWIFT_BASE_IMAGE \
  swift-ring-builder \
    /etc/kolla/config/swift/</span><strong class="bold"><span class="koboSpan" id="kobo.687.1">account.builder</span></strong><span class="koboSpan" id="kobo.688.1"> create </span><strong class="bold"><span class="koboSpan" id="kobo.689.1">11 3 1</span></strong><span class="koboSpan" id="kobo.690.1">
for node in ${STORAGE_NODES[@]}; do
    for i in {0..2}; do
      docker run \
        --rm \
        -v /etc/kolla/config/swift/:/etc/kolla/config/swift/ \
        $KOLLA_SWIFT_BASE_IMAGE \
        swift-ring-builder \
          /etc/kolla/config/swift/account.builder add \
          r1z1-${node}:6001/d${i} 1;
    done
done</span></pre>
   <p>
    <span class="koboSpan" id="kobo.691.1">
     The next part of the script generates a ring for the container and adds available devices to the ring for each storage
    </span>
    <a id="_idIndexMarker513">
    </a>
    <span class="koboSpan" id="kobo.692.1">
     node on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.693.1">
      port
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.694.1">
       6002
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.695.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.696.1">
docker run \
  --rm \
  -v /etc/kolla/config/swift/:/etc/kolla/config/swift/ \
  $KOLLA_SWIFT_BASE_IMAGE \
  swift-ring-builder \
    /etc/kolla/config/swift/</span><strong class="bold"><span class="koboSpan" id="kobo.697.1">container.builder</span></strong><span class="koboSpan" id="kobo.698.1"> create </span><strong class="bold"><span class="koboSpan" id="kobo.699.1">11 3 1</span></strong><span class="koboSpan" id="kobo.700.1">
for node in ${STORAGE_NODES[@]}; do
    for i in {0..2}; do
      docker run \
        --rm \
        -v /etc/kolla/config/swift/:/etc/kolla/config/swift/ \
        $KOLLA_SWIFT_BASE_IMAGE \
        swift-ring-builder \
          /etc/kolla/config/swift/container.builder add \
          r1z1-${node}:6002/d${i} 1;
    done
done</span></pre>
   <p>
    <span class="koboSpan" id="kobo.701.1">
     Optionally, to distribute the partitions within the available drives in the ring, add the last section in the script by firing the rebalance option, using the same
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.702.1">
      swift-ring-builder
     </span>
    </strong>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.703.1">
      rebalance
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.704.1">
      command-line tool:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.705.1">
for ring in object account container; do
  docker run \
    --rm \
    -v /etc/kolla/config/swift/:/etc/kolla/config/swift/ \
    $KOLLA_SWIFT_BASE_IMAGE \
    swift-ring-builder \
      /etc/kolla/config/swift/${ring}.builder rebalance;
done</span></pre>
   <p>
    <span class="koboSpan" id="kobo.706.1">
     This will iterate through each generated
    </span>
    <a id="_idIndexMarker514">
    </a>
    <span class="koboSpan" id="kobo.707.1">
     ring file and ensure each ring is balanced upon each partition move.
    </span>
    <span class="koboSpan" id="kobo.707.2">
     After running the ring preparation script, make sure no errors are generated and that all three ring files are located under the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.708.1">
      /etc/kolla/config/swift/
     </span>
    </strong>
    <span class="koboSpan" id="kobo.709.1">
     directory.
    </span>
    <span class="koboSpan" id="kobo.709.2">
     The next step is to make sure the object storage hostnames are added to the inventory file, located under
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.710.1">
      /ansible/inventory
     </span>
    </strong>
    <span class="koboSpan" id="kobo.711.1">
     ,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.712.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.713.1">
…
[storage]
storage03.os.packtpub
storage04.os.packtpub
storage05.os.packtpub
[swift-account-server:children]
storage
[swift-container-server:children]
storage
[swift-object-server:children]
storage</span></pre>
   <p>
    <span class="koboSpan" id="kobo.714.1">
     We will keep the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.715.1">
      swift-proxy
     </span>
    </strong>
    <span class="koboSpan" id="kobo.716.1">
     role on the cloud
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.717.1">
      controller node:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.718.1">
…
[swift:children]
control
[swift-proxy-server:children]
swift</span></pre>
   <p>
    <span class="koboSpan" id="kobo.719.1">
     Edit the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.720.1">
      globals.yml
     </span>
    </strong>
    <span class="koboSpan" id="kobo.721.1">
     file by enabling the Swift service,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.722.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.723.1">
enable_swift : "yes"</span></pre>
   <p>
    <span class="koboSpan" id="kobo.724.1">
     If the storage partition label uses a different name than the default
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.725.1">
      KOLLA_SWIFT_DATA
     </span>
    </strong>
    <span class="koboSpan" id="kobo.726.1">
     defined in the disk partition preparation previously, make sure you adjust it accordingly by setting the following configuration line in the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.727.1">
       globals.yml
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.728.1">
      file:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.729.1">
swift_devices_name: "KOLLA_SWIFT_DATA"</span></pre>
   <p>
    <span class="koboSpan" id="kobo.730.1">
     Triggering the pipeline job
    </span>
    <a id="_idIndexMarker515">
    </a>
    <span class="koboSpan" id="kobo.731.1">
     should run each target node in the Kolla Swift containers.
    </span>
    <span class="koboSpan" id="kobo.731.2">
     Create a container in one of the cluster nodes,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.732.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.733.1">$ openstack container create pp_container</span></strong></pre>
   <p>
    <span class="koboSpan" id="kobo.734.1">
     Create a simple object in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.735.1">
      created container:
     </span>
    </span>
   </p>
   <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.736.1">$ openstack object create pp_container obj1.txt obj2.txt</span></strong></pre>
   <p>
    <span class="koboSpan" id="kobo.737.1">
     You can show the container details, including the number of objects and the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.738.1">
      associated account:
     </span>
    </span>
   </p>
   <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.739.1">$ openstack container show mycontainer</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.740.1">+--------------+---------------------------------------+</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.741.1">| Field        | Value                                 |</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.742.1">+--------------+---------------------------------------+</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.743.1">| account      | AUTH_4c32445a3d2e431f3ab3347e522556a9 |</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.744.1">| bytes_used   | 6778                                  |</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.745.1">| container    | pp_container                          |</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.746.1">| object_count | 2                                     |</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.747.1">+--------------+---------------------------------------+</span></strong></pre>
   <p>
    <span class="koboSpan" id="kobo.748.1">
     As demonstrated in this section, the Swift architecture comes with a simple API that makes it easy to store unstructured data in redundant clusters with less operational burden.
    </span>
    <span class="koboSpan" id="kobo.748.2">
     Swift is also often used for backup, archiving, and disaster recovery purposes.
    </span>
    <span class="koboSpan" id="kobo.748.3">
     The last facet of storage options in OpenStack
    </span>
    <a id="_idIndexMarker516">
    </a>
    <span class="koboSpan" id="kobo.749.1">
     is the file share storage code known as Manila, which will be covered in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.750.1">
      next section.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-110">
    <a id="_idTextAnchor155">
    </a>
    <span class="koboSpan" id="kobo.751.1">
     Exploring file share services – Manila
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.752.1">
     The next storage service
    </span>
    <a id="_idIndexMarker517">
    </a>
    <span class="koboSpan" id="kobo.753.1">
     in OpenStack
    </span>
    <a id="_idIndexMarker518">
    </a>
    <span class="koboSpan" id="kobo.754.1">
     is the file share code named Manila.
    </span>
    <span class="koboSpan" id="kobo.754.2">
     The service offers simultaneous access to a storage-based file share for a variety of clients and storage backends.
    </span>
    <span class="koboSpan" id="kobo.754.3">
     Multiple sharing protocols are supported by Manila, at least until the Bobcat release, including NFS, GlusterFS, CephFS, CIFS, HDFS, and, most recently, MapRFS.
    </span>
    <span class="koboSpan" id="kobo.754.4">
     Note that the storage backends use drivers that must support one of the previously
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.755.1">
      listed protocols.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-111">
    <a id="_idTextAnchor156">
    </a>
    <span class="koboSpan" id="kobo.756.1">
     Manila under the hood
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.757.1">
     As illustrated in the following figure, the core components
    </span>
    <a id="_idIndexMarker519">
    </a>
    <span class="koboSpan" id="kobo.758.1">
     that orchestrate file shares and manage their life cycle in Manila are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.759.1">
      as follows:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.760.1">
       Manila share server
      </span>
     </strong>
     <span class="koboSpan" id="kobo.761.1">
      : A unit of storage that hosts
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.762.1">
       the shares
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.763.1">
       API server
      </span>
     </strong>
     <span class="koboSpan" id="kobo.764.1">
      : Exposes a REST API interface for client
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.765.1">
       request handling
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.766.1">
       Scheduler
      </span>
     </strong>
     <span class="koboSpan" id="kobo.767.1">
      : Selects the best share server to suit a file
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.768.1">
       share request
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.769.1">
       Data service
      </span>
     </strong>
     <span class="koboSpan" id="kobo.770.1">
      : Handles data backups, recovery,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.771.1">
       and
      </span>
     </span>
     <span class="No-Break">
      <a id="_idIndexMarker520">
      </a>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.772.1">
       migration
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.773.1">
     Manila interacts
    </span>
    <a id="_idIndexMarker521">
    </a>
    <span class="koboSpan" id="kobo.774.1">
     with a few OpenStack core services, including
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.775.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.776.1">
       Nova
      </span>
     </strong>
     <span class="koboSpan" id="kobo.777.1">
      : To create instances that run the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.778.1">
       share servers
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.779.1">
       Neutron
      </span>
     </strong>
     <span class="koboSpan" id="kobo.780.1">
      : To provide access to the file shares through the tenant
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.781.1">
       instance network
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.782.1">
       Cinder
      </span>
     </strong>
     <span class="koboSpan" id="kobo.783.1">
      : To create file shares in a block storage pool
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.784.1">
       as volumes:
      </span>
     </span>
    </li>
   </ul>
   <div>
    <div class="IMG---Figure" id="_idContainer070">
     <span class="koboSpan" id="kobo.785.1">
      <img alt="Figure 5.5 – File share service core architecture" src="image/B21716_05_05.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.786.1">
     Figure 5.5 – File share service core architecture
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.787.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.788.1">
     At the time of writing, Manila supports more than 25 share drivers’ backends, including CephFS, GlusterFS, LVM, and other vendors, such as EMC and Hitachi NAS.
    </span>
    <span class="koboSpan" id="kobo.788.2">
     A fully updated
    </span>
    <a id="_idIndexMarker522">
    </a>
    <span class="koboSpan" id="kobo.789.1">
     list can be found
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.790.1">
      at
     </span>
    </span>
    <a href="https://docs.openstack.org/manila/latest/configuration/shared-file-systems/drivers.html">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.791.1">
       https://docs.openstack.org/manila/latest/configuration/shared-file-systems/drivers.html
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.792.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.793.1">
     The additional extended list of new features and drivers in Manila allows it to use multiple storage backends and handle them simultaneously.
    </span>
    <span class="koboSpan" id="kobo.793.2">
     Similar to the Block Storage multi-backend setup, the latest versions of Manila
    </span>
    <a id="_idIndexMarker523">
    </a>
    <span class="koboSpan" id="kobo.794.1">
     introduced the filtering and weighing mechanisms to select a shared backend, based on specific properties.
    </span>
    <span class="koboSpan" id="kobo.794.2">
     By default,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.795.1">
      manila-scheduler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.796.1">
     uses
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.797.1">
      DriverFilter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.798.1">
     for filtering and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.799.1">
      GoodnessWeigher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.800.1">
     as a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.801.1">
      weigher mechanism.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.802.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.803.1">
     Filters and function weighers should be configured in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.804.1">
      manila.conf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.805.1">
     file, similar to Cinder’s filtering function syntax.
    </span>
    <span class="koboSpan" id="kobo.805.2">
     The filter function defines capability checks at both the share and host levels.
    </span>
    <span class="koboSpan" id="kobo.805.3">
     The available share types of properties can be listed by running
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.806.1">
      manila extra-specs-list
     </span>
    </strong>
    <span class="koboSpan" id="kobo.807.1">
     on the command line.
    </span>
    <span class="koboSpan" id="kobo.807.2">
     A full list of the latest properties supported
    </span>
    <a id="_idIndexMarker524">
    </a>
    <span class="koboSpan" id="kobo.808.1">
     by the filter function, up until the Antelope and Bobcat releases, is available
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.809.1">
      at
     </span>
    </span>
    <a href="https://docs.openstack.org/manila/latest/contributor/driver_filter_goodness_weigher.html">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.810.1">
       https://docs.openstack.org/manila/latest/contributor/driver_filter_goodness_weigher.html
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.811.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.812.1">
     For the next deployment, the default scheduling configuration will be used, which filters the best backend based on the free
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.813.1">
      available capacity.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-112">
    <a id="_idTextAnchor157">
    </a>
    <span class="koboSpan" id="kobo.814.1">
     Running Manila
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.815.1">
     Deploying the Manila service
    </span>
    <a id="_idIndexMarker525">
    </a>
    <span class="koboSpan" id="kobo.816.1">
     in our existing OpenStack environment is straightforward.
    </span>
    <span class="koboSpan" id="kobo.816.2">
     In the following setup, we will use a generic backend that leverages Cinder to create a share as a volume.
    </span>
    <span class="koboSpan" id="kobo.816.3">
     The attached volume to the instance can live within a Cinder pool storage backend that was configured in the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.817.1">
      Expanding storage with multiple backends
     </span>
    </em>
    <span class="koboSpan" id="kobo.818.1">
     section for LVM or
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.819.1">
      Ceph, respectively.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.820.1">
     Enabling the Cinder service in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.821.1">
      kolla-ansible
     </span>
    </strong>
    <span class="koboSpan" id="kobo.822.1">
     code is a requirement to run Manila with a generic storage backend.
    </span>
    <span class="koboSpan" id="kobo.822.2">
     In the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.823.1">
      globals.yml
     </span>
    </strong>
    <span class="koboSpan" id="kobo.824.1">
     file, enable the Manila service,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.825.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.826.1">
enable_manila: "yes"</span></pre>
   <p>
    <span class="koboSpan" id="kobo.827.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.828.1">
      globals.yml
     </span>
    </strong>
    <span class="koboSpan" id="kobo.829.1">
     file exposes another backend for Manila that includes NFS in Ceph and HNAS.
    </span>
    <span class="koboSpan" id="kobo.829.2">
     For the generic backend, bear in mind that NFS and CIFS shares will be used.
    </span>
    <span class="koboSpan" id="kobo.829.3">
     Proceed by enabling the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.830.1">
      generic share:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.831.1">
enable_manila_backend_generic: "yes"</span></pre>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.832.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.833.1">
     At the time of writing, enabling the Manila service will automatically add the Horizon panel for Manila to manage file shares through the dashboard.
    </span>
    <span class="koboSpan" id="kobo.833.2">
     If the Manila service is not visible in the dashboard after deployment, make sure the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.834.1">
      enable_horizon_manila
     </span>
    </strong>
    <span class="koboSpan" id="kobo.835.1">
     setting is set
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.836.1">
      to
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.837.1">
       true
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.838.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.839.1">
     More Manila settings can be configured in the custom Manila configuration file, which is not controlled directly via the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.840.1">
      globals.yml
     </span>
    </strong>
    <span class="koboSpan" id="kobo.841.1">
     file.
    </span>
    <span class="koboSpan" id="kobo.841.2">
     Create a new configuration file, named
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.842.1">
      /etc/kolla/config/manila-share.conf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.843.1">
     , to customize the Manila share settings.
    </span>
    <span class="koboSpan" id="kobo.843.2">
     One considerable setting is the size of the instance share required.
    </span>
    <span class="koboSpan" id="kobo.843.3">
     You can create the instance flavor in Nova in advance or use the default ones, which can be listed using the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.844.1">
      command line:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.845.1">
$ openstack flavor list</span></pre>
   <p>
    <span class="koboSpan" id="kobo.846.1">
     For example, we can instruct
    </span>
    <a id="_idIndexMarker526">
    </a>
    <span class="koboSpan" id="kobo.847.1">
     the file share instance to use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.848.1">
      m1.medium
     </span>
    </strong>
    <span class="koboSpan" id="kobo.849.1">
     flavor, referenced with an ID of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.850.1">
      3
     </span>
    </strong>
    <span class="koboSpan" id="kobo.851.1">
     from
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.852.1">
      the list:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.853.1">
[generic]
service_instance_flavor_id = 3</span></pre>
   <p>
    <span class="koboSpan" id="kobo.854.1">
     Other settings can be customized, such as the Manila shared backend name if you intend to have more than one backend.
    </span>
    <span class="koboSpan" id="kobo.854.2">
     To reflect the name of the generic backend, add the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.855.1">
      configuration setting:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.856.1">
[generic]
…
share_backend_name = GENERIC_SHARE</span></pre>
   <p>
    <span class="koboSpan" id="kobo.857.1">
     As it’s a Nova instance, the file share server will need a Glance image.
    </span>
    <span class="koboSpan" id="kobo.857.2">
     By default, the Manila playbook uses
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.858.1">
      manila-service-image
     </span>
    </strong>
    <span class="koboSpan" id="kobo.859.1">
     as a reference name.
    </span>
    <span class="koboSpan" id="kobo.859.2">
     If you intend to change it, make sure it has the same name as the one configured in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.860.1">
      the file.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.861.1">
     The next part of preparing the Manila deployment is to make sure the Manila services are assigned to the cluster roles.
    </span>
    <span class="koboSpan" id="kobo.861.2">
     Set the hostname, and ensure the Manila services are added to the inventory file located under
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.862.1">
      /ansible/inventory/multi_packtpub_prod
     </span>
    </strong>
    <span class="koboSpan" id="kobo.863.1">
     ,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.864.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.865.1">
…
[manila]
control
[manila-api:children]
manila
[manila-scheduler:children]
manila
[manila-data:children]
manila</span></pre>
   <p>
    <span class="koboSpan" id="kobo.866.1">
     As highlighted in
    </span>
    <a href="B21716_03.xhtml#_idTextAnchor108">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.867.1">
        Chapter 3
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.868.1">
     ,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.869.1">
      OpenStack Control Plane – Shared Services
     </span>
    </em>
    <span class="koboSpan" id="kobo.870.1">
     , the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.871.1">
      manila-share
     </span>
    </strong>
    <span class="koboSpan" id="kobo.872.1">
     service uses the Neutron plugin to provide network access to the file
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.873.1">
      share resources:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.874.1">
…
[manila-share:children]
network</span></pre>
   <p>
    <span class="koboSpan" id="kobo.875.1">
     Launch the pipeline job
    </span>
    <a id="_idIndexMarker527">
    </a>
    <span class="koboSpan" id="kobo.876.1">
     so that you can deploy the Manila service in cross-target nodes.
    </span>
    <span class="koboSpan" id="kobo.876.2">
     Manila service containers should be running in the cloud controller and network node.
    </span>
    <span class="koboSpan" id="kobo.876.3">
     Make sure that the Manila tasks complete without failure, as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.877.1">
      shown here:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer071">
     <span class="koboSpan" id="kobo.878.1">
      <img alt="Figure 5.6 – The kolla-ansible Manila deployment’s service output" src="image/B21716_05_06.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.879.1">
     Figure 5.6 – The kolla-ansible Manila deployment’s service output
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.880.1">
     Verify the Manila services in the cloud
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.881.1">
      controller node:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.882.1">
$ openstack share service list</span></pre>
   <p>
    <span class="koboSpan" id="kobo.883.1">
     The output of the previous command
    </span>
    <a id="_idIndexMarker528">
    </a>
    <span class="koboSpan" id="kobo.884.1">
     line shows that the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.885.1">
      manila-scheduler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.886.1">
     service has been enabled on the cloud controller host and that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.887.1">
      manila-share
     </span>
    </strong>
    <span class="koboSpan" id="kobo.888.1">
     is running as part of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.889.1">
      network node:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer072">
     <span class="koboSpan" id="kobo.890.1">
      <img alt="Figure 5.7 – The OpenStack Manila services list" src="image/B21716_05_07.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.891.1">
     Figure 5.7 – The OpenStack Manila services list
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.892.1">
     The file-sharing service has seen great improvements in the latest OpenStack releases, including Bobcat, such as the introduction of file-share control access.
    </span>
    <span class="koboSpan" id="kobo.892.2">
     This way, file shares can be locked to protect them against
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.893.1">
      accidental deletion.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.894.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.895.1">
     Starting from the Antelope release, the Manila CLI is planned to be deprecated, and it is highly recommended to use the OpenStack CLI to interact with the Manila
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.896.1">
      REST API.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-113">
    <a id="_idTextAnchor158">
    </a>
    <span class="koboSpan" id="kobo.897.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.898.1">
     This chapter has explored the most trending OpenStack storage services.
    </span>
    <span class="koboSpan" id="kobo.898.2">
     The expansion of each storage service feature and capability, including Swift, Cinder, and Manila, is almost
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.899.1">
      unstoppable
     </span>
    </em>
    <span class="koboSpan" id="kobo.900.1">
     .
    </span>
    <span class="koboSpan" id="kobo.900.2">
     This is confirmed by the vast array of supported backend drivers, either with the open source world ones, such as Ceph, or with a specific storage vendor.
    </span>
    <span class="koboSpan" id="kobo.900.3">
     The latest OpenStack releases, including Antelope and Bobcat, have also introduced more stable advanced features, mainly for Cinder and Manila, through the scheduling and filtering mechanisms.
    </span>
    <span class="koboSpan" id="kobo.900.4">
     Bear in mind that understanding each storage use case and its respective architecture are the keys to comfortably running a storage solution in an OpenStack environment, based on your requirements.
    </span>
    <span class="koboSpan" id="kobo.900.5">
     The challenge of picking the right option to satisfy specific requirements is not limited to storage topics.
    </span>
    <span class="koboSpan" id="kobo.900.6">
     It also applies to the networking paradigm in OpenStack.
    </span>
    <span class="koboSpan" id="kobo.900.7">
     Connecting the different elements of the compute and storage services will be discussed in the next chapter of our
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.901.1">
      OpenStack journey.
     </span>
    </span>
   </p>
  </div>
 </body></html>