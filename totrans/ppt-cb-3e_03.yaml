- en: Chapter 3. Writing Better Manifests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"Measuring programming progress by lines of code is like measuring aircraft
    building progress by weight."* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Bill Gates* |'
  prefs: []
  type: TYPE_TB
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Using arrays of resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using resource defaults
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using defined types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using run stages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using roles and profiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing parameters to classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing parameters from Hiera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing reusable, cross-platform manifests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting information about the environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing dynamic information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing arguments to shell commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Your Puppet manifests are the living documentation for your entire infrastructure.
    Keeping them tidy and well organized is a great way to make it easier to maintain
    and understand. Puppet gives you a number of tools to do this, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defaults
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defined types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll see how to use all of these and more. As you read through the chapter,
    try out the examples and look through your own manifests to see where these features
    might help you simplify and improve your Puppet code.
  prefs: []
  type: TYPE_NORMAL
- en: Using arrays of resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Anything that you can do to a resource, you can do to an array of resources.
    Use this idea to refactor your manifests to make them shorter and clearer.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps to refactor using arrays of resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Identify a class in your manifest where you have several instances of the same
    kind of resource, for example, packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Group them together and replace them with a single package resource using an
    array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of Puppet's resource types can accept an array instead of a single name,
    and will create one instance for each of the elements in the array. All the parameters
    you provide for the resource (for example, `ensure => installed`) will be assigned
    to each of the new resource instances. This shorthand will only work when all
    the resources have the same attributes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Iterating over multiple items* recipe in [Chapter 1](ch01.html "Chapter 1. Puppet
    Language and Style"), *Puppet Language and Style*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using resource defaults
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Puppet module is a group of related resources, usually grouped to configure
    a specific service. Within a module, you may define multiple resources; resource
    defaults allow you to specify the default attribute values for a resource. In
    this example, we'll show you how to specify a resource default for the `File`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To show you how to use resource defaults, we''ll create an apache module. Within
    this module we will specify that the default owner and group are the `apache`
    user as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an apache module and create a resource default for the `File` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create html files within the `/var/www/html` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add this class to your default node definition, or use `puppet apply` to apply
    the module to your node. I will use the method we configured in the previous chapter,
    pushing our code to the Git repository and using a Git hook to have the code deployed
    to the Puppet master as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Apply the module to a node or run Puppet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The resource default we defined specifies the owner, group, and mode for all
    file resources within this class (also known as within this scope). Unless you
    specifically override a resource default, the value for an attribute will be taken
    from the default.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can specify resource defaults for any resource type. You can also specify
    resource defaults in `site.pp`. I find it useful to specify the default action
    for `Package` and `Service` resources as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With these defaults, whenever you specify a package, the package will be installed.
    Whenever you specify a service, the service will be started and enabled to run
    at boot. These are the usual reasons you specify packages and services, most of
    the time these defaults will do what you prefer and your code will be cleaner.
    When you need to disable a service, simply override the defaults.
  prefs: []
  type: TYPE_NORMAL
- en: Using defined types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example, we saw how to reduce redundant code by grouping identical
    resources into arrays. However, this technique is limited to resources where all
    the parameters are the same. When you have a set of resources that have some parameters
    in common, you need to use a defined type to group them together.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps will show you how to create a definition:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your manifest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run Puppet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can think of a defined type (introduced with the `define` keyword) as a
    cookie-cutter. It describes a pattern that Puppet can use to create lots of similar
    resources. Any time you declare a `tmpfile` instance in your manifest, Puppet
    will insert all the resources contained in the `tmpfile` definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, the definition of `tmpfile` contains a single `file` resource
    whose content is `Hello, world\n` and whose path is `/tmp/${name}`. If you declared
    an instance of `tmpfile` with the name `foo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Puppet will create a file with the path `/tmp/foo`. In other words, `${name}`
    in the definition will be replaced by the `name` of any actual instance that Puppet
    is asked to create. It''s almost as though we created a new kind of resource:
    `tmpfile`, which has one parameter—its `name`.'
  prefs: []
  type: TYPE_NORMAL
- en: Just like with regular resources, we don't have to pass just one title; as in
    the preceding example, we can provide an array of titles and Puppet will create
    as many resources as required.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A word on name, the namevar: Every resource you create must have a unique name,
    the namevar. This is different than the title, which is how puppet refers to the
    resource internally (although they are often the same).'
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the example, we created a definition where the only parameter that varies
    between instances is the `name` parameter. But we can add whatever parameters
    we want, so long as we declare them in the definition in parentheses after the
    `name` parameter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, pass values to them when we declare an instance of the resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can declare multiple parameters as a comma-separated list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also declare default values for any parameters that aren''t supplied,
    thus making them optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a powerful technique for abstracting out everything that''s common
    to certain resources, and keeping it in one place so that you *don''t repeat yourself*.
    In the preceding example, there might be many individual resources contained within
    `webapp`: packages, config files, source code checkouts, virtual hosts, and so
    on. But all of them are the same for every instance of `webapp` except the parameters
    we provide. These might be referenced in a template, for example, to set the domain
    for a virtual host.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Passing parameters to classes* recipe, in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes one Puppet class needs to know about another or at least to know whether
    or not it's present. For example, a class that manages the firewall may need to
    know whether or not the node is a web server.
  prefs: []
  type: TYPE_NORMAL
- en: Puppet's `tagged` function will tell you whether a named class or resource is
    present in the catalog for this node. You can also apply arbitrary tags to a node
    or class and check for the presence of these tags. Tags are another metaparameter,
    similar to `require` and `notify` we introduced in [Chapter 1](ch01.html "Chapter 1. Puppet
    Language and Style"), *Puppet Language and Style*. Metaparameters are used in
    the compilation of the Puppet catalog but are not an attribute of the resource
    to which they are attached.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To help you find out if you''re running on a particular node or class of nodes
    all nodes are automatically tagged with the node name and the names of any classes
    they include. Here''s an example that shows you how to use `tagged` to get this
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your `site.pp` file (replacing `cookbook` with your
    machine''s `hostname`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run Puppet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Nodes are also automatically tagged with the names of all the classes they include
    in addition to several other automatic tags. You can use `tagged` to find out
    what classes are included on the node.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You''re not just limited to checking the tags automatically applied by Puppet.
    You can also add your own. To set an arbitrary tag on a node, use the `tag` function,
    as in the following example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify your `site.pp` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `tag_test` module with the following `init.pp` (or be lazy and add the
    following definition to your `site.pp`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run Puppet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also use tags to determine which parts of the manifest to apply. If
    you use the `--tags` option on the Puppet command line, Puppet will apply only
    those classes or resources tagged with the specific tags you include. For example,
    we can define our `cookbook` class with two classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now when we run `puppet agent` on the `cookbook` node, we see both notifies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now apply the `first_class` and `add --tags` function to the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use tags to create a collection of resources, and then make the collection
    a dependency for some other resource. For example, say some service depends on
    a config file that is built from a number of file snippets, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've specified that the `firewall` service should be notified if any
    file resource tagged `firewall-snippet` is updated. All we need to do to add a
    `firewall` config snippet for any particular application or service is to tag
    it `firewall-snippet`, and Puppet will do the rest.
  prefs: []
  type: TYPE_NORMAL
- en: Although we could add a `notify => Service["firewall"]` function to each snippet
    resource if our definition of the `firewall` service were ever to change, we would
    have to hunt down and update all the snippets accordingly. The tag lets us encapsulate
    the logic in one place, making future maintenance and refactoring much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What''s `<| tag == ''firewall-snippet'' |> syntax`? This is called a resource
    collector, and it''s a way of specifying a group of resources by searching for
    some piece of data about them; in this case, the value of a tag. You can find
    out more about resource collectors and the `<| |>` operator (sometimes known as
    the spaceship operator) on the Puppet Labs website: [http://docs.puppetlabs.com/puppet/3/reference/lang_collectors.html](http://docs.puppetlabs.com/puppet/3/reference/lang_collectors.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Using run stages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common requirement is to apply a certain group of resources before other groups
    (for example, installing a package repository or a custom Ruby version), or after
    others (for example, deploying an application once its dependencies are installed).
    Puppet's run stages feature allows you to do this.
  prefs: []
  type: TYPE_NORMAL
- en: By default, all resources in your manifest are applied in a single stage named
    `main`. If you need a resource to be applied before all others, you can assign
    it to a new run stage that is specified to come before `main`. Similarly, you
    could define a run stage that comes after `main`. In fact, you can define as many
    run stages as you need and tell Puppet which order they should be applied in.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we'll use stages to ensure one class is applied first and another
    last.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps to create an example of using run `stages`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the file `modules/admin/manifests/stages.pp` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify your `site.pp` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run Puppet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s examine this code in detail to see what''s happening. First, we declare
    the run stages `first` and `last`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: For the `first` stage, we've specified that it should come before `main`. That
    is, every resource marked as being in the `first` stage will be applied before
    any resource in the `main` stage (the default stage).
  prefs: []
  type: TYPE_NORMAL
- en: The `last` stage requires the `main` stage, so no resource in the `last` stage
    can be applied until after every resource in the `main` stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then declare some classes that we''ll later assign to these run stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now put it all together and include these classes on the node, specifying
    the run stages for each as we do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the `class` declarations for `me_first` and `me_last`, we didn't
    have to specify that they take a `stage` parameter. The `stage` parameter is another
    metaparameter, which means it can be applied to any class or resource without
    having to be explicitly declared. When we ran `puppet agent` on our Puppet node,
    the notify from the `me_first` class was applied before the notifies from `first_class`
    and `second_class`. The notify from `me_last` was applied after the `main` stage,
    so it comes after the two notifies from `first_class` and `second_class`. If you
    run `puppet agent` multiple times, you will see that the notifies from `first_class`
    and `second_class` may not always appear in the same order but the `me_first`
    class will always come first and the `me_last` class will always come last.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can define as many run stages as you like, and set up any ordering for them.
    This can greatly simplify a complicated manifest that would otherwise require
    lots of explicit dependencies between resources. Beware of accidentally introducing
    dependency cycles, though; when you assign something to a run stage you're automatically
    making it dependent on everything in prior stages.
  prefs: []
  type: TYPE_NORMAL
- en: You may like to define your stages in the `site.pp` file instead, so that at
    the top level of the manifest, it's easy to see what stages are available.
  prefs: []
  type: TYPE_NORMAL
- en: '*Gary Larizza* has written a helpful introduction to using run stages, with
    some real-world examples, on his website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://garylarizza.com/blog/2011/03/11/using-run-stages-with-puppet/](http://garylarizza.com/blog/2011/03/11/using-run-stages-with-puppet/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'A caveat: many people don''t like to use run stages, feeling that Puppet already
    provides sufficient resource ordering control, and that using run stages indiscriminately
    can make your code very hard to follow. The use of run stages should be kept to
    a minimum wherever possible. There are a few key examples where the use of stages
    creates less complexity. The most notable is when a resource modifies the system
    used to install packages on the system. It helps to have a package management
    stage that comes before the main stage. When packages are defined in the `main`
    (default) stage, your manifests can count on the updated package management configuration
    information being present. For instance, for a Yum-based system, you would create
    a `yumrepos` stage that comes before `main`. You can specify this dependency using
    chaining arrows as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then create a class that creates a Yum repository (`yumrepo`) resource
    and assign it to the `yumrepos` stage as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: For Apt-based systems, the same example would be a stage where Apt sources are
    defined. The key with stages is to keep their definitions in your `site.pp` file
    where they are highly visible and to only use them sparingly where you can guarantee
    that you will not introduce dependency cycles.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using tags* recipe, in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Drawing dependency graphs* recipe in [Chapter 10](ch10.html "Chapter 10. Monitoring,
    Reporting, and Troubleshooting"), *Monitoring, Reporting, and Troubleshooting*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using roles and profiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well organized Puppet manifests are easy to read; the purpose of a module should
    be evident in its name. The purpose of a node should be defined in a single class.
    This single class should include all classes that are required to perform that
    purpose. Craig Dunn wrote a post about such a classification system, which he
    dubbed "roles and profiles" ([http://www.craigdunn.org/2012/05/239/](http://www.craigdunn.org/2012/05/239/)).
    In this model, roles are the single purpose of a node, a node may only have one
    role, a role may contain more than one profile, and a profile contains all the
    resources related to a single service. In this example, we will create a web server
    role that uses several profiles.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll create two modules to store our roles and profiles. Roles will contain
    one or more profiles. Each role or profile will be defined as a subclass, such
    as `profile::base`
  prefs: []
  type: TYPE_NORMAL
- en: 'Decide on a naming strategy for your roles and profiles. In our example, we
    will create two modules, `roles` and `profiles` that will contain our roles and
    profiles respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Begin defining the constituent parts of our `webserver` role as profiles. To
    keep this example simple, we will create two profiles. First, a `base` profile
    to include our basic server configuration classes. Second, an `apache` class to
    install and configure the apache web server (`httpd`) as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a `roles::webserver` class for our `webserver` role as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Apply the `roles::webserver` class to a node. In a centralized installation,
    you would use either an **External Node Classifier** (**ENC**) to apply the class
    to the node, or you would use Hiera to define the role:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Breaking down the parts of the web server configuration into different profiles
    allows us to apply those parts independently. We created a base profile that we
    can expand to include all the resources we would like applied to all nodes. Our
    `roles::webserver` class simply includes the `base` and `apache` classes.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we''ll see in the next section, we can pass parameters to classes to alter
    how they work. In our `roles::webserver` class, we can use the class instantiation
    syntax instead of `include`, and override it with `parameters` in the classes.
    For instance, to pass a parameter to the `base` class, we would use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'where we previously used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In previous versions of this book, node and class inheritance were used to achieve
    a similar goal, code reuse. Node inheritance is deprecated in Puppet Version 3.7
    and higher. Node and class inheritance should be avoided. Using roles and profiles
    achieves the same level of readability and is much easier to follow.
  prefs: []
  type: TYPE_NORMAL
- en: Passing parameters to classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes it's very useful to parameterize some aspect of a class. For example,
    you might need to manage different versions of a `gem` package, and rather than
    making separate classes for each that differ only in the version number, you can
    pass in the version number as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we''ll create a definition that accepts parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare the parameter as a part of the class definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the following syntax to include the class on a node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The class definition `class eventmachine($version) {` is just like a normal
    class definition except it specifies that the class takes one parameter: `$version`.
    Inside the class, we''ve defined a `package` resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This is a `gem` package, and we're requesting to install version `$version`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the class on a node, instead of the usual `include` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'On doing so, there will be a `class` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This has the same effect but also sets a value for the parameter as `version`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can specify multiple parameters for a class as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then supply them in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Specifying default values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also give default values for some of your parameters. When you include
    the class without setting a parameter, the default value will be used. For instance,
    if we created a `mysql` class with three parameters, we could provide default
    values for any or all of the parameters as shown in the code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'or all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Defaults allow you to use a default value and override that default where you
    need it.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike a definition, only one instance of a parameterized class can exist on
    a node. So where you need to have several different instances of the resource,
    use `define` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Passing parameters from Hiera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like the parameter `defaults` we introduced in the previous chapter, Hiera may
    be used to provide default values to classes. This feature requires Puppet Version
    3 and higher.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Install and configure `hiera` as we did in [Chapter 2](ch02.html "Chapter 2. Puppet
    Infrastructure"), *Puppet Infrastructure*. Create a global or common `yaml` file;
    this will serve as the default for all values.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a class with parameters and no default values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update your common `.yaml` file in Hiera with the default values for the `mysql`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Apply the class to a node, you can add the mysql class to your default node
    for now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run `puppet agent` and verify the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we instantiate the `mysql` class in our manifest, we provided no values
    for any of the attributes. Puppet knows to look for a value in Hiera that matches
    `class_name::parameter_name:` or `::class_name::parameter_name:`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When Puppet finds a value, it uses it as the parameter for the class. If Puppet
    fails to find a value in Hiera and no default is defined, a catalog failure will
    result in the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This error indicates that Puppet would like a value for the parameter `package`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can define a Hiera hierarchy and supply different values for parameters
    based on facts. You could, for instance, have `%{::osfamily}` in your hierarchy
    and have different `yaml` files based on the `osfamily` parameter (RedHat, Suse,
    and Debian).
  prefs: []
  type: TYPE_NORMAL
- en: Writing reusable, cross-platform manifests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every system administrator dreams of a unified, homogeneous infrastructure of
    identical machines all running the same version of the same OS. As in other areas
    of life, however, the reality is often messy and doesn't conform to the plan.
  prefs: []
  type: TYPE_NORMAL
- en: You are probably responsible for a bunch of assorted servers of varying age
    and architecture running different kernels from different OS distributions, often
    scattered across different data centers and ISPs.
  prefs: []
  type: TYPE_NORMAL
- en: This situation should strike terror into the hearts of the sysadmins of the
    SSH in a `for` loop persuasion, because executing the same commands on every server
    can have different, unpredictable, and even dangerous results.
  prefs: []
  type: TYPE_NORMAL
- en: We should certainly strive to bring older servers up to date and get working
    as far as possible on a single reference platform to make administration simpler,
    cheaper, and more reliable. But until we get there, Puppet makes coping with heterogeneous
    environments slightly easier.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some examples of how to make your manifests more portable:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Where you need to apply the same manifest to servers with different OS distributions,
    the main differences will probably be the names of packages and services, and
    the location of config files. Try to capture all these differences into a single
    class by using selectors to set global variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You needn''t worry about the differences in any other part of the manifest;
    when you refer to something, use the variable with confidence that it will point
    to the right thing in each environment:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Often we need to cope with mixed architectures; this can affect the paths to
    shared libraries, and also may require different versions of packages. Again,
    try to encapsulate all the required settings in a single architecture class that
    sets global variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then you can use these wherever an architecture-dependent value is required
    in your manifests or even in templates:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The advantage of this approach (which could be called top-down) is that you
    only need to make your choices once. The alternative, bottom-up approach would
    be to have a selector or `case` statement everywhere a setting is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This not only results in lots of duplication, but makes the code harder to read.
    And when a new operating system is added to the mix, you'll need to make changes
    throughout the whole manifest, instead of just in one place.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are writing a module for public distribution (for example, on Puppet
    Forge), making your module as cross-platform as possible will make it more valuable
    to the community. As far as you can, test it on many different distributions,
    platforms, and architectures, and add the appropriate variables so that it works
    everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: If you use a public module and adapt it to your own environment, consider updating
    the public version with your changes if you think they might be helpful to other
    people.
  prefs: []
  type: TYPE_NORMAL
- en: Even if you are not thinking of publishing a module, bear in mind that it may
    be in production use for a long time and may have to adapt to many changes in
    the environment. If it's designed to cope with this from the start, it'll make
    life easier for you or whoever ends up maintaining your code.
  prefs: []
  type: TYPE_NORMAL
- en: '|   | *"Always code as if the guy who ends up maintaining your code will be
    a violent psychopath who knows where you live."* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Dave Carhart* |'
  prefs: []
  type: TYPE_TB
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using public modules* recipe in [Chapter 7](ch07.html "Chapter 7. Managing
    Applications"), *Managing Applications*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Configuring Hiera* recipe in [Chapter 2](ch02.html "Chapter 2. Puppet Infrastructure"),
    *Puppet Infrastructure*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting information about the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often in a Puppet manifest, you need to know some local information about the
    machine you''re on. Facter is the tool that accompanies Puppet to provide a standard
    way of getting information (facts) from the environment about things such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: Operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processor count
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To see a complete list of the facts available on your system, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While it can be handy to get this information from the command line, the real
    power of Facter lies in being able to access these facts in your Puppet manifests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some modules define their own facts; to see any facts that have been defined
    locally, add the `-p (pluginsync)` option to facter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s an example of using Facter facts in a manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reference a Facter fact in your manifest like any other variable. Facts are
    global variables in Puppet, so they should be prefixed with a double colon (`::`),
    as in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When Puppet runs, it will fill in the appropriate values for the current node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Facter provides a standard way for manifests to get information about the nodes
    to which they are applied. When you refer to a fact in a manifest, Puppet will
    query Facter to get the current value and insert it into the manifest. Facter
    facts are top scope variables.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Always refer to facts with leading double colons to ensure that you are using
    the fact and not a local variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$::hostname` NOT `$hostname`'
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also use facts in ERB templates. For example, you might want to insert
    the node''s hostname into a file, or change a configuration setting for an application
    based on the memory size of the node. When you use fact names in templates, remember
    that they don''t need a dollar sign because this is Ruby, not Puppet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'When referring to facts, use the `@` syntax. Variables that are defined at
    the same scope as the function call to template can also be referenced with the
    `@` syntax. Out of scope variables should use the `scope` function. For example,
    to reference the `mysql::port` variable we defined earlier in the `mysql` modules,
    use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Applying this template results in the following file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating custom facts* recipe in [Chapter 9](ch09.html "Chapter 9. External
    Tools and the Puppet Ecosystem"), *External Tools and the Puppet Ecosystem*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing dynamic information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though some system administrators like to wall themselves off from the
    rest of the office using piles of old printers, we all need to exchange information
    with other departments from time to time. For example, you may want to insert
    data into your Puppet manifests that is derived from some outside source. The
    generate function is ideal for this. Functions are executed on the machine compiling
    the catalog (the master for centralized deployments); an example like that shown
    here will only work in a masterless configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to prepare to run the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the script `/usr/local/bin/message.rb` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make the script executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This example calls the external script we created previously and gets its output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `message.pp` manifest containing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run Puppet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `generate` function runs the specified script or program and returns the
    result, in this case, a cheerful message from Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: This isn't terribly useful as it stands but you get the idea. Anything a script
    can do, print, fetch, or calculate, for example, the results of a database query,
    can be brought into your manifest using `generate`. You can also, of course, run
    standard UNIX utilities such as `cat` and `grep`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need to pass arguments to the executable called by generate, add them
    as extra arguments to the function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Puppet will try to protect you from malicious shell calls by restricting the
    characters you can use in a call to generate, so shell pipes and redirection aren't
    allowed, for example. The simplest and safest thing to do is to put all your logic
    into a script and then call that script.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating custom facts* recipe in [Chapter 9](ch09.html "Chapter 9. External
    Tools and the Puppet Ecosystem"), *External Tools and the Puppet Ecosystem*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Configuring Hiera* recipe in [Chapter 2](ch02.html "Chapter 2. Puppet Infrastructure"),
    *Puppet Infrastructure*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing arguments to shell commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to insert values into a command line (to be run by an `exec` resource,
    for example), they often need to be quoted, especially if they contain spaces.
    The `shellquote` function will take any number of arguments, including arrays,
    and quote each of the arguments and return them all as a space-separated string
    that you can pass to commands.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we would like to set up an `exec` resource that will rename
    a file; but both the source and the target name contain spaces, so they need to
    be correctly quoted in the command line.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s an example of using the `shellquote` function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `shellquote.pp` manifest with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run Puppet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First we define the `$source` and `$target` variables, which are the two filenames
    we want to use in the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we call `shellquote` to concatenate these variables into a quoted, space-separated
    string as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we put together the final command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This command line can now be run with an exec resource. What would happen if
    we didn't use `shellquote`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This won't work because `mv` expects space-separated arguments, so it will interpret
    this as a request to move three files `Hello`, `Jerry`, and `Hello...` into a
    directory named `Newman`, which probably isn't what we want.
  prefs: []
  type: TYPE_NORMAL
