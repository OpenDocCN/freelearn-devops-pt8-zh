- en: Chapter 3. Writing Better Manifests
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。编写更好的清单
- en: '|   | *"Measuring programming progress by lines of code is like measuring aircraft
    building progress by weight."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *“通过代码行数衡量编程进展，就像通过重量衡量飞机建造进展一样。”* |   |'
- en: '|   | --*Bill Gates* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*比尔·盖茨* |'
- en: 'In this chapter, we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Using arrays of resources
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用资源数组
- en: Using resource defaults
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用资源默认值
- en: Using defined types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用定义类型
- en: Using tags
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标签
- en: Using run stages
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用运行阶段
- en: Using roles and profiles
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用角色和配置文件
- en: Passing parameters to classes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向类传递参数
- en: Passing parameters from Hiera
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Hiera 传递参数
- en: Writing reusable, cross-platform manifests
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写可重用的跨平台清单
- en: Getting information about the environment
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取有关环境的信息
- en: Importing dynamic information
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入动态信息
- en: Passing arguments to shell commands
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 shell 命令传递参数
- en: Introduction
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'Your Puppet manifests are the living documentation for your entire infrastructure.
    Keeping them tidy and well organized is a great way to make it easier to maintain
    and understand. Puppet gives you a number of tools to do this, as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 Puppet 清单是你整个基础设施的活文档。保持它们整洁和有序是维护和理解的好方法。Puppet 为你提供了以下工具来实现这一点：
- en: Arrays
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Defaults
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认值
- en: Defined types
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义类型
- en: Dependencies
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖关系
- en: Class parameters
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类参数
- en: We'll see how to use all of these and more. As you read through the chapter,
    try out the examples and look through your own manifests to see where these features
    might help you simplify and improve your Puppet code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何使用这些工具以及更多内容。在阅读本章时，尝试运行示例并查看你自己的清单，看看这些功能如何帮助你简化和改进 Puppet 代码。
- en: Using arrays of resources
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用资源数组
- en: Anything that you can do to a resource, you can do to an array of resources.
    Use this idea to refactor your manifests to make them shorter and clearer.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对资源做的任何事，也可以对资源数组做。利用这个思路来重构你的清单，使它们更简洁明了。
- en: How to do it…
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Here are the steps to refactor using arrays of resources:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用资源数组重构的步骤：
- en: 'Identify a class in your manifest where you have several instances of the same
    kind of resource, for example, packages:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的清单中找出一个包含多个相同类型资源实例的类，例如，软件包：
- en: '[PRE0]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Group them together and replace them with a single package resource using an
    array:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们组合在一起，并用一个数组替换为单个软件包资源：
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works…
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Most of Puppet's resource types can accept an array instead of a single name,
    and will create one instance for each of the elements in the array. All the parameters
    you provide for the resource (for example, `ensure => installed`) will be assigned
    to each of the new resource instances. This shorthand will only work when all
    the resources have the same attributes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 的大多数资源类型可以接受一个数组，而不是单个名称，并会为数组中的每个元素创建一个实例。你为资源提供的所有参数（例如，`ensure =>
    installed`）都会分配给每个新的资源实例。这个简写方法只有在所有资源具有相同属性时才有效。
- en: See also
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Iterating over multiple items* recipe in [Chapter 1](ch01.html "Chapter 1. Puppet
    Language and Style"), *Puppet Language and Style*
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 1 章](ch01.html "第 1 章。Puppet 语言与风格")中的 *迭代多个项目* 配方，*Puppet 语言与风格*'
- en: Using resource defaults
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用资源默认值
- en: A Puppet module is a group of related resources, usually grouped to configure
    a specific service. Within a module, you may define multiple resources; resource
    defaults allow you to specify the default attribute values for a resource. In
    this example, we'll show you how to specify a resource default for the `File`
    type.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 模块是一组相关的资源，通常用于配置特定服务。在模块中，你可以定义多个资源；资源默认值允许你为资源指定默认属性值。在此示例中，我们将展示如何为
    `File` 类型指定资源默认值。
- en: How to do it...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'To show you how to use resource defaults, we''ll create an apache module. Within
    this module we will specify that the default owner and group are the `apache`
    user as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示如何使用资源默认值，我们将创建一个 apache 模块。在这个模块中，我们将指定默认的拥有者和组是 `apache` 用户，如下所示：
- en: 'Create an apache module and create a resource default for the `File` type:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 apache 模块并为 `File` 类型创建一个资源默认值：
- en: '[PRE2]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create html files within the `/var/www/html` directory:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/var/www/html` 目录下创建 html 文件：
- en: '[PRE3]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add this class to your default node definition, or use `puppet apply` to apply
    the module to your node. I will use the method we configured in the previous chapter,
    pushing our code to the Git repository and using a Git hook to have the code deployed
    to the Puppet master as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此类添加到你的默认节点定义中，或者使用`puppet apply`将模块应用到你的节点。我将使用我们在上一章中配置的方法，将代码推送到 Git 仓库，并使用
    Git 钩子将代码部署到 Puppet 主节点，如下所示：
- en: '[PRE4]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Apply the module to a node or run Puppet:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模块应用到节点或运行 Puppet：
- en: '[PRE5]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The resource default we defined specifies the owner, group, and mode for all
    file resources within this class (also known as within this scope). Unless you
    specifically override a resource default, the value for an attribute will be taken
    from the default.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的资源默认值指定了此类中的所有文件资源的所有者、组和模式（也称为此范围内的所有者、组和模式）。除非你特别覆盖资源默认值，否则属性的值将从默认值中获取。
- en: There's more...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'You can specify resource defaults for any resource type. You can also specify
    resource defaults in `site.pp`. I find it useful to specify the default action
    for `Package` and `Service` resources as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为任何资源类型指定资源默认值。你还可以在`site.pp`中指定资源默认值。我发现指定`Package`和`Service`资源的默认操作非常有用，如下所示：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With these defaults, whenever you specify a package, the package will be installed.
    Whenever you specify a service, the service will be started and enabled to run
    at boot. These are the usual reasons you specify packages and services, most of
    the time these defaults will do what you prefer and your code will be cleaner.
    When you need to disable a service, simply override the defaults.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些默认值时，每当你指定一个软件包时，该软件包将被安装。每当你指定一个服务时，该服务将启动并启用在启动时运行。这些是你指定软件包和服务的常见原因，大多数时候这些默认值会做你希望的事情，你的代码也会更加简洁。当你需要禁用一个服务时，只需覆盖默认值。
- en: Using defined types
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用定义类型
- en: In the previous example, we saw how to reduce redundant code by grouping identical
    resources into arrays. However, this technique is limited to resources where all
    the parameters are the same. When you have a set of resources that have some parameters
    in common, you need to use a defined type to group them together.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们看到如何通过将相同的资源分组到数组中来减少冗余代码。然而，这种技术仅限于所有参数相同的资源。当你有一组共享一些参数的资源时，你需要使用定义类型将它们组合在一起。
- en: How to do it…
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'The following steps will show you how to create a definition:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将向你展示如何创建定义：
- en: 'Add the following code to your manifest:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的清单中：
- en: '[PRE7]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Run Puppet:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Puppet：
- en: '[PRE8]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works…
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: You can think of a defined type (introduced with the `define` keyword) as a
    cookie-cutter. It describes a pattern that Puppet can use to create lots of similar
    resources. Any time you declare a `tmpfile` instance in your manifest, Puppet
    will insert all the resources contained in the `tmpfile` definition.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把定义类型（通过`define`关键字引入）看作一个模具。它描述了一个模式，Puppet 可以用来创建许多相似的资源。每次你在清单中声明一个`tmpfile`实例时，Puppet
    会插入所有包含在`tmpfile`定义中的资源。
- en: 'In our example, the definition of `tmpfile` contains a single `file` resource
    whose content is `Hello, world\n` and whose path is `/tmp/${name}`. If you declared
    an instance of `tmpfile` with the name `foo`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`tmpfile`的定义包含一个`file`资源，其内容为`Hello, world\n`，路径为`/tmp/${name}`。如果你声明了一个名为`foo`的`tmpfile`实例：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Puppet will create a file with the path `/tmp/foo`. In other words, `${name}`
    in the definition will be replaced by the `name` of any actual instance that Puppet
    is asked to create. It''s almost as though we created a new kind of resource:
    `tmpfile`, which has one parameter—its `name`.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 会创建一个路径为`/tmp/foo`的文件。换句话说，定义中的`${name}`将被 Puppet 被要求创建的任何实际实例的`name`替换。它几乎就像我们创建了一种新类型的资源：`tmpfile`，它有一个参数——它的`name`。
- en: Just like with regular resources, we don't have to pass just one title; as in
    the preceding example, we can provide an array of titles and Puppet will create
    as many resources as required.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 就像常规资源一样，我们不必仅传递一个标题；如前面的示例所示，我们可以提供一个标题数组，Puppet 将创建所需数量的资源。
- en: Tip
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'A word on name, the namevar: Every resource you create must have a unique name,
    the namevar. This is different than the title, which is how puppet refers to the
    resource internally (although they are often the same).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 关于名称，namevar：你创建的每个资源必须有一个唯一的名称，namevar。这与标题不同，标题是 Puppet 在内部引用资源的方式（尽管它们通常是相同的）。
- en: There's more…
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'In the example, we created a definition where the only parameter that varies
    between instances is the `name` parameter. But we can add whatever parameters
    we want, so long as we declare them in the definition in parentheses after the
    `name` parameter, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个定义，其中唯一在实例之间变化的参数是`name`参数。但我们可以添加任何我们想要的参数，只要我们在`name`参数后面的括号中声明它们，如下所示：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, pass values to them when we declare an instance of the resource:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在声明资源实例时为其传递值：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can declare multiple parameters as a comma-separated list:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将多个参数声明为逗号分隔的列表：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can also declare default values for any parameters that aren''t supplied,
    thus making them optional:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为任何未提供的参数声明默认值，从而使它们成为可选参数：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is a powerful technique for abstracting out everything that''s common
    to certain resources, and keeping it in one place so that you *don''t repeat yourself*.
    In the preceding example, there might be many individual resources contained within
    `webapp`: packages, config files, source code checkouts, virtual hosts, and so
    on. But all of them are the same for every instance of `webapp` except the parameters
    we provide. These might be referenced in a template, for example, to set the domain
    for a virtual host.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种强大的技术，用于抽象出某些资源的共同部分，并将其保存在一个地方，以便你*不要重复自己*。在前面的例子中，`webapp`中可能包含许多独立的资源：软件包、配置文件、源代码检出、虚拟主机等。但它们对于每个`webapp`实例都是相同的，除了我们提供的参数。这些参数可能会在模板中引用，例如，用于设置虚拟主机的域名。
- en: See also
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Passing parameters to classes* recipe, in this chapter
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*将参数传递给类*示例
- en: Using tags
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标签
- en: Sometimes one Puppet class needs to know about another or at least to know whether
    or not it's present. For example, a class that manages the firewall may need to
    know whether or not the node is a web server.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个Puppet类需要了解另一个类，或者至少需要知道它是否存在。例如，一个管理防火墙的类可能需要知道该节点是否为Web服务器。
- en: Puppet's `tagged` function will tell you whether a named class or resource is
    present in the catalog for this node. You can also apply arbitrary tags to a node
    or class and check for the presence of these tags. Tags are another metaparameter,
    similar to `require` and `notify` we introduced in [Chapter 1](ch01.html "Chapter 1. Puppet
    Language and Style"), *Puppet Language and Style*. Metaparameters are used in
    the compilation of the Puppet catalog but are not an attribute of the resource
    to which they are attached.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet的`tagged`函数会告诉你一个命名的类或资源是否出现在该节点的目录中。你还可以向节点或类应用任意标签，并检查这些标签的存在。标签是另一个元参数，类似于我们在[第1章](ch01.html
    "第1章 Puppet语言与风格")中介绍的`require`和`notify`，*Puppet语言与风格*。元参数用于Puppet目录的编译，但不是附加到资源上的属性。
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'To help you find out if you''re running on a particular node or class of nodes
    all nodes are automatically tagged with the node name and the names of any classes
    they include. Here''s an example that shows you how to use `tagged` to get this
    information:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你发现自己是否在特定节点或节点类上运行，所有节点都会自动被标记为节点名称及其包含的任何类的名称。以下是一个例子，展示如何使用`tagged`获取这些信息：
- en: 'Add the following code to your `site.pp` file (replacing `cookbook` with your
    machine''s `hostname`):'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的`site.pp`文件中（将`cookbook`替换为你机器的`hostname`）：
- en: '[PRE14]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Run Puppet:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Puppet：
- en: '[PRE15]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Nodes are also automatically tagged with the names of all the classes they include
    in addition to several other automatic tags. You can use `tagged` to find out
    what classes are included on the node.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 节点也会自动标记它们所包含的所有类的名称，以及其他一些自动标签。你可以使用`tagged`来查找节点上包含了哪些类。
- en: 'You''re not just limited to checking the tags automatically applied by Puppet.
    You can also add your own. To set an arbitrary tag on a node, use the `tag` function,
    as in the following example:'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你不仅仅限于检查Puppet自动应用的标签。你还可以添加自己的标签。要在节点上设置任意标签，请使用`tag`函数，如以下示例所示：
- en: 'Modify your `site.pp` file as follows:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式修改你的`site.pp`文件：
- en: '[PRE16]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add a `tag_test` module with the following `init.pp` (or be lazy and add the
    following definition to your `site.pp`):'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`tag_test`模块，并提供以下`init.pp`（或者懒惰一些，将以下定义添加到你的`site.pp`中）：
- en: '[PRE17]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run Puppet:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Puppet：
- en: '[PRE18]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can also use tags to determine which parts of the manifest to apply. If
    you use the `--tags` option on the Puppet command line, Puppet will apply only
    those classes or resources tagged with the specific tags you include. For example,
    we can define our `cookbook` class with two classes:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还可以使用标签来确定应用清单的哪些部分。如果你在 Puppet 命令行中使用 `--tags` 选项，Puppet 将仅应用那些带有你指定标签的类或资源。例如，我们可以用两个类来定义
    `cookbook` 类：
- en: '[PRE19]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now when we run `puppet agent` on the `cookbook` node, we see both notifies:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当我们在 `cookbook` 节点上运行 `puppet agent` 时，我们会看到两个通知：
- en: '[PRE20]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now apply the `first_class` and `add --tags` function to the command line:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将 `first_class` 和 `add --tags` 函数应用于命令行：
- en: '[PRE21]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There's more…
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can use tags to create a collection of resources, and then make the collection
    a dependency for some other resource. For example, say some service depends on
    a config file that is built from a number of file snippets, as in the following
    example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用标签创建一个资源集合，然后将该集合作为其他资源的依赖。例如，假设某个服务依赖于由多个文件片段构建的配置文件，如下所示：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we've specified that the `firewall` service should be notified if any
    file resource tagged `firewall-snippet` is updated. All we need to do to add a
    `firewall` config snippet for any particular application or service is to tag
    it `firewall-snippet`, and Puppet will do the rest.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定如果任何标记为 `firewall-snippet` 的文件资源被更新，`firewall` 服务应收到通知。我们只需要将特定应用或服务的配置片段标记为
    `firewall-snippet`，Puppet 就会完成其余工作。
- en: Although we could add a `notify => Service["firewall"]` function to each snippet
    resource if our definition of the `firewall` service were ever to change, we would
    have to hunt down and update all the snippets accordingly. The tag lets us encapsulate
    the logic in one place, making future maintenance and refactoring much easier.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以为每个片段资源添加一个 `notify => Service["firewall"]` 函数，但如果 `firewall` 服务的定义发生变化，我们将不得不逐一查找并更新所有片段。标签允许我们将逻辑封装在一个地方，使得将来的维护和重构变得更容易。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'What''s `<| tag == ''firewall-snippet'' |> syntax`? This is called a resource
    collector, and it''s a way of specifying a group of resources by searching for
    some piece of data about them; in this case, the value of a tag. You can find
    out more about resource collectors and the `<| |>` operator (sometimes known as
    the spaceship operator) on the Puppet Labs website: [http://docs.puppetlabs.com/puppet/3/reference/lang_collectors.html](http://docs.puppetlabs.com/puppet/3/reference/lang_collectors.html).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`<| tag == ''firewall-snippet'' |>` 语法是什么？这是所谓的资源收集器，它通过搜索关于资源的一些数据来指定一组资源；在这个例子中，是标签的值。你可以在
    Puppet Labs 网站上了解更多关于资源收集器和 `<| |>` 运算符（有时称为飞船操作符）的信息：[http://docs.puppetlabs.com/puppet/3/reference/lang_collectors.html](http://docs.puppetlabs.com/puppet/3/reference/lang_collectors.html)。'
- en: Using run stages
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用运行阶段
- en: A common requirement is to apply a certain group of resources before other groups
    (for example, installing a package repository or a custom Ruby version), or after
    others (for example, deploying an application once its dependencies are installed).
    Puppet's run stages feature allows you to do this.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的需求是在其他组之前应用某一组资源（例如，安装软件包仓库或自定义 Ruby 版本），或者在其他组之后应用（例如，在安装完依赖项后部署应用）。Puppet
    的运行阶段功能使你能够实现这一点。
- en: By default, all resources in your manifest are applied in a single stage named
    `main`. If you need a resource to be applied before all others, you can assign
    it to a new run stage that is specified to come before `main`. Similarly, you
    could define a run stage that comes after `main`. In fact, you can define as many
    run stages as you need and tell Puppet which order they should be applied in.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，清单中的所有资源都应用于一个名为 `main` 的单一阶段。如果你需要某个资源在其他资源之前应用，你可以将其分配到一个新的运行阶段，该阶段指定在
    `main` 之前运行。类似地，你也可以定义一个在 `main` 之后运行的阶段。实际上，你可以根据需要定义任意数量的运行阶段，并告诉 Puppet 它们应该按什么顺序应用。
- en: In this example, we'll use stages to ensure one class is applied first and another
    last.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用阶段来确保一个类首先应用，另一个类最后应用。
- en: How to do it…
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here are the steps to create an example of using run `stages`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用运行 `stages` 的示例步骤：
- en: 'Create the file `modules/admin/manifests/stages.pp` with the following contents:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文件 `modules/admin/manifests/stages.pp`，内容如下：
- en: '[PRE23]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Modify your `site.pp` file as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改你的 `site.pp` 文件，如下所示：
- en: '[PRE24]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run Puppet:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Puppet：
- en: '[PRE25]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works…
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Let''s examine this code in detail to see what''s happening. First, we declare
    the run stages `first` and `last`, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细检查一下这段代码，看看发生了什么。首先，我们声明了运行阶段 `first` 和 `last`，如下所示：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: For the `first` stage, we've specified that it should come before `main`. That
    is, every resource marked as being in the `first` stage will be applied before
    any resource in the `main` stage (the default stage).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`first`阶段，我们已经指定它应该在`main`之前执行。也就是说，标记为`first`阶段的每个资源将在任何`main`阶段的资源之前应用（`main`是默认阶段）。
- en: The `last` stage requires the `main` stage, so no resource in the `last` stage
    can be applied until after every resource in the `main` stage.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`last`阶段需要`main`阶段，因此在`main`阶段的每个资源都应用后，才能应用`last`阶段的资源。'
- en: 'We then declare some classes that we''ll later assign to these run stages:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们声明一些类，稍后将为这些类分配运行阶段：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can now put it all together and include these classes on the node, specifying
    the run stages for each as we do so:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将所有内容结合起来，并在节点上包含这些类，同时为每个类指定运行阶段：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that in the `class` declarations for `me_first` and `me_last`, we didn't
    have to specify that they take a `stage` parameter. The `stage` parameter is another
    metaparameter, which means it can be applied to any class or resource without
    having to be explicitly declared. When we ran `puppet agent` on our Puppet node,
    the notify from the `me_first` class was applied before the notifies from `first_class`
    and `second_class`. The notify from `me_last` was applied after the `main` stage,
    so it comes after the two notifies from `first_class` and `second_class`. If you
    run `puppet agent` multiple times, you will see that the notifies from `first_class`
    and `second_class` may not always appear in the same order but the `me_first`
    class will always come first and the `me_last` class will always come last.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`me_first`和`me_last`的`class`声明中，我们不需要指定它们采用`stage`参数。`stage`参数是另一个元参数，意味着它可以应用于任何类或资源，而无需显式声明。当我们在Puppet节点上运行`puppet
    agent`时，`me_first`类中的通知会在`first_class`和`second_class`中的通知之前应用。`me_last`类的通知会在`main`阶段之后应用，因此它会在`first_class`和`second_class`的两个通知之后应用。如果你多次运行`puppet
    agent`，你会看到`first_class`和`second_class`的通知可能不会总是按相同的顺序出现，但`me_first`类将始终最先出现，`me_last`类将始终最后出现。
- en: There's more…
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: You can define as many run stages as you like, and set up any ordering for them.
    This can greatly simplify a complicated manifest that would otherwise require
    lots of explicit dependencies between resources. Beware of accidentally introducing
    dependency cycles, though; when you assign something to a run stage you're automatically
    making it dependent on everything in prior stages.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义任意数量的运行阶段，并为它们设置任何顺序。这可以大大简化一个复杂的清单，否则需要在资源之间设置大量显式依赖关系。然而要小心，避免意外引入依赖循环；当你将某个资源分配到一个运行阶段时，你自动将它与之前阶段中的所有内容关联起来。
- en: You may like to define your stages in the `site.pp` file instead, so that at
    the top level of the manifest, it's easy to see what stages are available.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望在`site.pp`文件中定义阶段，这样在清单的顶部就能清楚地看到哪些阶段是可用的。
- en: '*Gary Larizza* has written a helpful introduction to using run stages, with
    some real-world examples, on his website:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*Gary Larizza* 在他的网站上写了一个有用的关于使用运行阶段的介绍，包含一些现实世界的示例：'
- en: '[http://garylarizza.com/blog/2011/03/11/using-run-stages-with-puppet/](http://garylarizza.com/blog/2011/03/11/using-run-stages-with-puppet/)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://garylarizza.com/blog/2011/03/11/using-run-stages-with-puppet/](http://garylarizza.com/blog/2011/03/11/using-run-stages-with-puppet/)'
- en: 'A caveat: many people don''t like to use run stages, feeling that Puppet already
    provides sufficient resource ordering control, and that using run stages indiscriminately
    can make your code very hard to follow. The use of run stages should be kept to
    a minimum wherever possible. There are a few key examples where the use of stages
    creates less complexity. The most notable is when a resource modifies the system
    used to install packages on the system. It helps to have a package management
    stage that comes before the main stage. When packages are defined in the `main`
    (default) stage, your manifests can count on the updated package management configuration
    information being present. For instance, for a Yum-based system, you would create
    a `yumrepos` stage that comes before `main`. You can specify this dependency using
    chaining arrows as shown in the following code snippet:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一个警告：许多人不喜欢使用运行阶段，觉得 Puppet 已经提供了足够的资源排序控制，并且不加区分地使用运行阶段会使您的代码变得非常难以理解。在可能的情况下，应尽量减少使用运行阶段。有几个关键的例子可以证明使用阶段可以减少复杂性。最明显的是当一个资源修改用于在系统上安装软件包的系统时。在默认的
    `main` 阶段定义包时，您的清单可以依赖于存在更新的包管理配置信息。例如，对于基于 Yum 的系统，您可以创建一个在 `main` 阶段之前的 `yumrepos`
    阶段。您可以使用链箭头指定这种依赖关系，如下面的代码片段所示：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can then create a class that creates a Yum repository (`yumrepo`) resource
    and assign it to the `yumrepos` stage as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建一个创建 Yum 仓库 (`yumrepo`) 资源并将其分配给 `yumrepos` 阶段的类，如下所示：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For Apt-based systems, the same example would be a stage where Apt sources are
    defined. The key with stages is to keep their definitions in your `site.pp` file
    where they are highly visible and to only use them sparingly where you can guarantee
    that you will not introduce dependency cycles.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于 Apt 的系统，相同的例子将是一个定义 Apt 源的阶段。阶段的关键在于将其定义在您的 `site.pp` 文件中，这样它们就会非常可见，并且只在确保不会引入依赖循环的情况下才使用它们。
- en: See also
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using tags* recipe, in this chapter
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用标签* 配方，在本章中'
- en: The *Drawing dependency graphs* recipe in [Chapter 10](ch10.html "Chapter 10. Monitoring,
    Reporting, and Troubleshooting"), *Monitoring, Reporting, and Troubleshooting*
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绘制依赖图* 配方在 [第 10 章](ch10.html "Chapter 10. Monitoring, Reporting, and Troubleshooting")，*监控、报告和故障排除*'
- en: Using roles and profiles
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用角色和配置文件
- en: Well organized Puppet manifests are easy to read; the purpose of a module should
    be evident in its name. The purpose of a node should be defined in a single class.
    This single class should include all classes that are required to perform that
    purpose. Craig Dunn wrote a post about such a classification system, which he
    dubbed "roles and profiles" ([http://www.craigdunn.org/2012/05/239/](http://www.craigdunn.org/2012/05/239/)).
    In this model, roles are the single purpose of a node, a node may only have one
    role, a role may contain more than one profile, and a profile contains all the
    resources related to a single service. In this example, we will create a web server
    role that uses several profiles.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 组织良好的 Puppet 清单易于阅读；模块的目的应在其名称中明显。节点的目的应在一个单一类中定义。这个单一的类应包含执行该目的所需的所有类。Craig
    Dunn 写了一篇关于这种分类系统的文章，他将其称为 "角色和配置文件" ([http://www.craigdunn.org/2012/05/239/](http://www.craigdunn.org/2012/05/239/))。在这种模型中，角色是节点的单一目的，一个节点只能有一个角色，一个角色可以包含多个配置文件，而一个配置文件包含与单个服务相关的所有资源。在这个例子中，我们将创建一个使用多个配置文件的
    web 服务器角色。
- en: How to do it…
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: We'll create two modules to store our roles and profiles. Roles will contain
    one or more profiles. Each role or profile will be defined as a subclass, such
    as `profile::base`
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个模块来存储我们的角色和配置文件。角色将包含一个或多个配置文件。每个角色或配置文件将被定义为子类，例如 `profile::base`
- en: 'Decide on a naming strategy for your roles and profiles. In our example, we
    will create two modules, `roles` and `profiles` that will contain our roles and
    profiles respectively:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 决定您的角色和配置文件的命名策略。在我们的例子中，我们将创建两个模块，`roles` 和 `profiles`，分别包含我们的角色和配置文件：
- en: '[PRE31]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Begin defining the constituent parts of our `webserver` role as profiles. To
    keep this example simple, we will create two profiles. First, a `base` profile
    to include our basic server configuration classes. Second, an `apache` class to
    install and configure the apache web server (`httpd`) as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始定义我们 `webserver` 角色的组成部分作为配置文件。为了保持这个例子简单，我们将创建两个配置文件。首先是一个 `base` 配置文件，包括我们的基本服务器配置类。其次是一个
    `apache` 类来安装和配置 Apache Web 服务器 (`httpd`)，如下所示：
- en: '[PRE32]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Define a `roles::webserver` class for our `webserver` role as follows:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的 `webserver` 角色定义一个 `roles::webserver` 类，如下所示：
- en: '[PRE33]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Apply the `roles::webserver` class to a node. In a centralized installation,
    you would use either an **External Node Classifier** (**ENC**) to apply the class
    to the node, or you would use Hiera to define the role:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`roles::webserver`类应用到一个节点。在集中式安装中，你可以使用**外部节点分类器**（**ENC**）将类应用到节点，或者使用Hiera来定义角色：
- en: '[PRE34]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works…
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Breaking down the parts of the web server configuration into different profiles
    allows us to apply those parts independently. We created a base profile that we
    can expand to include all the resources we would like applied to all nodes. Our
    `roles::webserver` class simply includes the `base` and `apache` classes.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 将Web服务器配置的各个部分分解成不同的配置文件，使我们能够独立地应用这些部分。我们创建了一个基本配置文件，可以扩展以包括我们希望应用到所有节点的所有资源。我们的`roles::webserver`类简单地包含了`base`和`apache`类。
- en: There's more…
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容……
- en: 'As we''ll see in the next section, we can pass parameters to classes to alter
    how they work. In our `roles::webserver` class, we can use the class instantiation
    syntax instead of `include`, and override it with `parameters` in the classes.
    For instance, to pass a parameter to the `base` class, we would use:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在下一节中看到的，我们可以将参数传递给类，以改变它们的工作方式。在我们的`roles::webserver`类中，我们可以使用类实例化语法，而不是`include`，并通过类中的`parameters`覆盖它。例如，要将参数传递给`base`类，我们可以使用：
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'where we previously used:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前使用过的地方：
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Tip
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In previous versions of this book, node and class inheritance were used to achieve
    a similar goal, code reuse. Node inheritance is deprecated in Puppet Version 3.7
    and higher. Node and class inheritance should be avoided. Using roles and profiles
    achieves the same level of readability and is much easier to follow.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的早期版本中，节点和类继承用于实现类似的目标，即代码重用。节点继承在Puppet版本3.7及更高版本中已被弃用。应该避免使用节点和类继承。使用角色和配置文件可以达到相同的可读性，并且更容易跟随。
- en: Passing parameters to classes
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向类传递参数
- en: Sometimes it's very useful to parameterize some aspect of a class. For example,
    you might need to manage different versions of a `gem` package, and rather than
    making separate classes for each that differ only in the version number, you can
    pass in the version number as a parameter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，将类的某些方面参数化非常有用。例如，你可能需要管理不同版本的`gem`包，而不必为每个不同版本号创建单独的类，你可以将版本号作为参数传入。
- en: How to do it…
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'In this example, we''ll create a definition that accepts parameters:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个接受参数的定义：
- en: 'Declare the parameter as a part of the class definition:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将参数声明为类定义的一部分：
- en: '[PRE37]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Use the following syntax to include the class on a node:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下语法将类包含在节点上：
- en: '[PRE38]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works…
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'The class definition `class eventmachine($version) {` is just like a normal
    class definition except it specifies that the class takes one parameter: `$version`.
    Inside the class, we''ve defined a `package` resource:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义`class eventmachine($version) {`就像普通的类定义，唯一不同的是它指定了该类需要一个参数：`$version`。在类内部，我们定义了一个`package`资源：
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is a `gem` package, and we're requesting to install version `$version`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`gem`包，我们请求安装版本`$version`。
- en: 'Include the class on a node, instead of the usual `include` syntax:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在节点上包含类，而不是使用通常的`include`语法：
- en: '[PRE40]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'On doing so, there will be a `class` statement:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做时，会出现一个`class`语句：
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This has the same effect but also sets a value for the parameter as `version`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的效果是一样的，但同时也为参数`version`设置了一个值。
- en: There's more…
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容……
- en: 'You can specify multiple parameters for a class as:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为类指定多个参数，如下所示：
- en: '[PRE42]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then supply them in the same way:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后以相同的方式提供它们：
- en: '[PRE43]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Specifying default values
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定默认值
- en: 'You can also give default values for some of your parameters. When you include
    the class without setting a parameter, the default value will be used. For instance,
    if we created a `mysql` class with three parameters, we could provide default
    values for any or all of the parameters as shown in the code snippet:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为一些参数提供默认值。当你在不设置参数的情况下包含类时，将使用默认值。例如，如果我们创建了一个具有三个参数的`mysql`类，我们可以为任何或所有参数提供默认值，如代码片段所示：
- en: '[PRE44]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'or all:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 或者全部：
- en: '[PRE45]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Defaults allow you to use a default value and override that default where you
    need it.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值允许你使用一个默认值，并在需要时覆盖该默认值。
- en: Unlike a definition, only one instance of a parameterized class can exist on
    a node. So where you need to have several different instances of the resource,
    use `define` instead.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 与定义不同，一个参数化类只能在一个节点上存在一个实例。因此，如果你需要多个不同的资源实例，应该改用`define`。
- en: Passing parameters from Hiera
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Hiera传递参数
- en: Like the parameter `defaults` we introduced in the previous chapter, Hiera may
    be used to provide default values to classes. This feature requires Puppet Version
    3 and higher.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在上一章引入的 `defaults` 参数一样，Hiera 可用于为类提供默认值。此功能要求 Puppet 版本 3 及以上。
- en: Getting ready
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Install and configure `hiera` as we did in [Chapter 2](ch02.html "Chapter 2. Puppet
    Infrastructure"), *Puppet Infrastructure*. Create a global or common `yaml` file;
    this will serve as the default for all values.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 安装并配置 `hiera`，就像我们在 [第 2 章](ch02.html "第 2 章 Puppet 基础设施") *Puppet 基础设施* 中所做的那样。创建一个全局或公共的
    `yaml` 文件；这将作为所有值的默认值。
- en: How to do it...
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Create a class with parameters and no default values:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个没有默认值的参数类：
- en: '[PRE46]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Update your common `.yaml` file in Hiera with the default values for the `mysql`
    class:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Hiera 中更新你的公共 `.yaml` 文件，加入 `mysql` 类的默认值：
- en: '[PRE47]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Apply the class to a node, you can add the mysql class to your default node
    for now.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将类应用于节点，你现在可以将 `mysql` 类添加到你的默认节点中。
- en: '[PRE48]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Run `puppet agent` and verify the output:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `puppet agent` 并验证输出：
- en: '[PRE49]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works...
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When we instantiate the `mysql` class in our manifest, we provided no values
    for any of the attributes. Puppet knows to look for a value in Hiera that matches
    `class_name::parameter_name:` or `::class_name::parameter_name:`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在清单中实例化 `mysql` 类时，并没有为任何属性提供值。Puppet 知道去 Hiera 查找与 `class_name::parameter_name:`
    或 `::class_name::parameter_name:` 匹配的值。
- en: 'When Puppet finds a value, it uses it as the parameter for the class. If Puppet
    fails to find a value in Hiera and no default is defined, a catalog failure will
    result in the following command line:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Puppet 找到一个值时，它将其作为类的参数。如果 Puppet 未能在 Hiera 中找到值并且没有定义默认值，目录失败将导致以下命令行：
- en: '[PRE50]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This error indicates that Puppet would like a value for the parameter `package`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误表示 Puppet 需要为参数 `package` 提供一个值。
- en: There's more...
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can define a Hiera hierarchy and supply different values for parameters
    based on facts. You could, for instance, have `%{::osfamily}` in your hierarchy
    and have different `yaml` files based on the `osfamily` parameter (RedHat, Suse,
    and Debian).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义一个 Hiera 层次结构，并根据事实为参数提供不同的值。例如，你可以在层次结构中使用 `%{::osfamily}`，并根据 `osfamily`
    参数（如 RedHat、Suse 和 Debian）有不同的 `yaml` 文件。
- en: Writing reusable, cross-platform manifests
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写可重用的跨平台清单
- en: Every system administrator dreams of a unified, homogeneous infrastructure of
    identical machines all running the same version of the same OS. As in other areas
    of life, however, the reality is often messy and doesn't conform to the plan.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 每个系统管理员都梦想拥有统一的、同质化的基础设施，所有机器都运行相同版本的相同操作系统。然而，正如生活中的其他领域一样，现实通常是混乱的，并且与计划不符。
- en: You are probably responsible for a bunch of assorted servers of varying age
    and architecture running different kernels from different OS distributions, often
    scattered across different data centers and ISPs.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能负责一堆不同年龄和架构的服务器，这些服务器运行着不同内核的不同操作系统，通常分布在不同的数据中心和 ISP 上。
- en: This situation should strike terror into the hearts of the sysadmins of the
    SSH in a `for` loop persuasion, because executing the same commands on every server
    can have different, unpredictable, and even dangerous results.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况应该会让 SSH 中的系统管理员感到恐惧，因为在每台服务器上执行相同的命令可能会导致不同的、不可预测的，甚至是危险的结果。
- en: We should certainly strive to bring older servers up to date and get working
    as far as possible on a single reference platform to make administration simpler,
    cheaper, and more reliable. But until we get there, Puppet makes coping with heterogeneous
    environments slightly easier.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然应该努力使旧服务器保持最新，并尽可能在单一参考平台上工作，以简化管理、降低成本并提高可靠性。但在我们达到这个目标之前，Puppet 使得应对异构环境稍微容易一些。
- en: How to do it…
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Here are some examples of how to make your manifests more portable:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些使你的清单更具可移植性的示例：
- en: 'Where you need to apply the same manifest to servers with different OS distributions,
    the main differences will probably be the names of packages and services, and
    the location of config files. Try to capture all these differences into a single
    class by using selectors to set global variables:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你需要将相同的清单应用于不同操作系统分发版的服务器时，主要的差异可能是包和服务的名称，以及配置文件的位置。尝试通过使用选择器设置全局变量，将所有这些差异捕捉到一个类中：
- en: '[PRE51]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You needn''t worry about the differences in any other part of the manifest;
    when you refer to something, use the variable with confidence that it will point
    to the right thing in each environment:'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你不必担心清单中任何其他部分的差异；当你引用某些内容时，可以放心地使用变量，它将在每个环境中指向正确的内容：
- en: '[PRE52]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Often we need to cope with mixed architectures; this can affect the paths to
    shared libraries, and also may require different versions of packages. Again,
    try to encapsulate all the required settings in a single architecture class that
    sets global variables:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们经常需要处理混合架构；这可能会影响共享库的路径，并且可能需要不同版本的软件包。同样，尽量将所有所需的设置封装在一个架构类中，该类设置全局变量：
- en: '[PRE53]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then you can use these wherever an architecture-dependent value is required
    in your manifests or even in templates:'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后你可以在清单中或甚至在模板中使用这些变量，任何需要架构相关值的地方：
- en: '[PRE54]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works...
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The advantage of this approach (which could be called top-down) is that you
    only need to make your choices once. The alternative, bottom-up approach would
    be to have a selector or `case` statement everywhere a setting is used:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法（可以称之为自上而下）的优点是你只需要做一次选择。另一种选择是自下而上的方法，即每次使用设置时，都需要有一个选择器或`case`语句：
- en: '[PRE55]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This not only results in lots of duplication, but makes the code harder to read.
    And when a new operating system is added to the mix, you'll need to make changes
    throughout the whole manifest, instead of just in one place.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这样不仅会导致大量重复，还会使代码更难以阅读。而且，当新操作系统被加入时，你需要在整个清单中进行修改，而不是仅仅在一个地方进行修改。
- en: There's more…
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: If you are writing a module for public distribution (for example, on Puppet
    Forge), making your module as cross-platform as possible will make it more valuable
    to the community. As far as you can, test it on many different distributions,
    platforms, and architectures, and add the appropriate variables so that it works
    everywhere.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在为公共发布编写模块（例如，在 Puppet Forge 上），尽可能使你的模块跨平台，将使其对社区更有价值。尽可能在许多不同的发行版、平台和架构上进行测试，并添加适当的变量，以确保它能在各处运行。
- en: If you use a public module and adapt it to your own environment, consider updating
    the public version with your changes if you think they might be helpful to other
    people.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用了一个公共模块并将其调整为适应自己的环境，考虑在认为这些更改可能对其他人有帮助时，将这些更改更新到公共版本中。
- en: Even if you are not thinking of publishing a module, bear in mind that it may
    be in production use for a long time and may have to adapt to many changes in
    the environment. If it's designed to cope with this from the start, it'll make
    life easier for you or whoever ends up maintaining your code.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你不打算发布一个模块，也要记住它可能会在生产环境中使用很长时间，并且可能需要适应环境中的许多变化。如果从一开始就设计好应对这些变化的功能，将使你或最终维护你代码的人轻松许多。
- en: '|   | *"Always code as if the guy who ends up maintaining your code will be
    a violent psychopath who knows where you live."* |   |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '|   | *"永远编写代码，假设维护你代码的人是一个暴力的精神病患者，知道你住在哪里。"* |   |'
- en: '|   | --*Dave Carhart* |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '|   | --*戴夫·卡哈特* |'
- en: See also
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Using public modules* recipe in [Chapter 7](ch07.html "Chapter 7. Managing
    Applications"), *Managing Applications*
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第7章](ch07.html "第7章 管理应用程序")中的*使用公共模块*配方，*管理应用程序*'
- en: The *Configuring Hiera* recipe in [Chapter 2](ch02.html "Chapter 2. Puppet Infrastructure"),
    *Puppet Infrastructure*
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](ch02.html "第2章 Puppet基础架构")中的*配置Hiera*配方，*Puppet基础架构*'
- en: Getting information about the environment
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取环境信息
- en: 'Often in a Puppet manifest, you need to know some local information about the
    machine you''re on. Facter is the tool that accompanies Puppet to provide a standard
    way of getting information (facts) from the environment about things such as these:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puppet 清单中，你经常需要了解你所在机器的一些本地信息。Facter 是与 Puppet 一起使用的工具，提供了一种标准的方法来从环境中获取信息（事实），例如以下内容：
- en: Operating system
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统
- en: Memory size
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存大小
- en: Architecture
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构
- en: Processor count
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器数量
- en: 'To see a complete list of the facts available on your system, run:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看系统上可用的事实的完整列表，运行：
- en: '[PRE56]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While it can be handy to get this information from the command line, the real
    power of Facter lies in being able to access these facts in your Puppet manifests.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从命令行获取这些信息很方便，但 Facter 的真正强大之处在于能够在 Puppet 清单中访问这些事实。
- en: 'Some modules define their own facts; to see any facts that have been defined
    locally, add the `-p (pluginsync)` option to facter as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一些模块定义了自己的事实；要查看任何已本地定义的事实，可以在运行 facter 时添加`-p (pluginsync)`选项，如下所示：
- en: '[PRE57]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How to do it…
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'Here''s an example of using Facter facts in a manifest:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用Facter事实在清单中的示例：
- en: 'Reference a Facter fact in your manifest like any other variable. Facts are
    global variables in Puppet, so they should be prefixed with a double colon (`::`),
    as in the following code snippet:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像引用其他变量一样在清单中引用Facter事实。事实是Puppet中的全局变量，因此它们应以双冒号(`::`)为前缀，如以下代码片段所示：
- en: '[PRE58]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'When Puppet runs, it will fill in the appropriate values for the current node:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当Puppet运行时，它将为当前节点填充适当的值：
- en: '[PRE59]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How it works…
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Facter provides a standard way for manifests to get information about the nodes
    to which they are applied. When you refer to a fact in a manifest, Puppet will
    query Facter to get the current value and insert it into the manifest. Facter
    facts are top scope variables.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Facter提供了一种标准方式，使清单能够获取它们所应用节点的信息。当你在清单中引用一个事实时，Puppet将查询Facter以获取当前值并将其插入清单。Facter事实是顶级作用域变量。
- en: Tip
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Always refer to facts with leading double colons to ensure that you are using
    the fact and not a local variable:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 始终使用前导的双冒号引用事实，以确保你使用的是事实而不是本地变量：
- en: '`$::hostname` NOT `$hostname`'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`$::hostname` 而不是 `$hostname`'
- en: There's more…
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'You can also use facts in ERB templates. For example, you might want to insert
    the node''s hostname into a file, or change a configuration setting for an application
    based on the memory size of the node. When you use fact names in templates, remember
    that they don''t need a dollar sign because this is Ruby, not Puppet:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在ERB模板中使用事实。例如，你可能想将节点的主机名插入到文件中，或者根据节点的内存大小更改应用程序的配置设置。当在模板中使用事实名称时，请记住它们不需要美元符号，因为这是Ruby而不是Puppet：
- en: '[PRE60]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'When referring to facts, use the `@` syntax. Variables that are defined at
    the same scope as the function call to template can also be referenced with the
    `@` syntax. Out of scope variables should use the `scope` function. For example,
    to reference the `mysql::port` variable we defined earlier in the `mysql` modules,
    use the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 引用事实时，请使用`@`语法。在与模板函数调用相同作用域中定义的变量也可以使用`@`语法引用。作用域外的变量应使用`scope`函数。例如，要引用我们在`mysql`模块中之前定义的`mysql::port`变量，请使用以下代码：
- en: '[PRE61]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Applying this template results in the following file:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 应用此模板会生成以下文件：
- en: '[PRE62]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: See also
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Creating custom facts* recipe in [Chapter 9](ch09.html "Chapter 9. External
    Tools and the Puppet Ecosystem"), *External Tools and the Puppet Ecosystem*
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第9章](ch09.html "第9章。外部工具与Puppet生态系统")中的*创建自定义事实*示例，*外部工具与Puppet生态系统*'
- en: Importing dynamic information
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入动态信息
- en: Even though some system administrators like to wall themselves off from the
    rest of the office using piles of old printers, we all need to exchange information
    with other departments from time to time. For example, you may want to insert
    data into your Puppet manifests that is derived from some outside source. The
    generate function is ideal for this. Functions are executed on the machine compiling
    the catalog (the master for centralized deployments); an example like that shown
    here will only work in a masterless configuration.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有些系统管理员喜欢通过堆积一堆旧打印机将自己与办公室的其他部分隔离开来，但我们都需要不时地与其他部门交换信息。例如，你可能希望将来自外部来源的数据插入到Puppet清单中。`generate`函数非常适合这种情况。函数在编译目录的机器上执行（对于集中式部署是主节点）；像这里示例的代码只适用于无主配置。
- en: Getting ready
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'Follow these steps to prepare to run the example:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤准备运行示例：
- en: 'Create the script `/usr/local/bin/message.rb` with the following contents:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建脚本`/usr/local/bin/message.rb`，其内容如下：
- en: '[PRE63]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Make the script executable:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使脚本可执行：
- en: '[PRE64]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: How to do it…
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'This example calls the external script we created previously and gets its output:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例调用我们之前创建的外部脚本并获取其输出：
- en: 'Create a `message.pp` manifest containing the following:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含以下内容的`message.pp`清单：
- en: '[PRE65]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Run Puppet:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Puppet：
- en: '[PRE66]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: How it works…
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `generate` function runs the specified script or program and returns the
    result, in this case, a cheerful message from Ruby.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`generate`函数运行指定的脚本或程序并返回结果，在此例中是来自Ruby的一个愉快消息。'
- en: This isn't terribly useful as it stands but you get the idea. Anything a script
    can do, print, fetch, or calculate, for example, the results of a database query,
    can be brought into your manifest using `generate`. You can also, of course, run
    standard UNIX utilities such as `cat` and `grep`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 目前来看这并不是非常有用，但你明白其思路了。脚本可以做的任何事情，比如打印、获取或计算数据（例如数据库查询的结果），都可以通过`generate`引入到你的清单中。当然，你也可以运行标准的UNIX工具，例如`cat`和`grep`。
- en: There's more…
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'If you need to pass arguments to the executable called by generate, add them
    as extra arguments to the function call:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要向由`generate`调用的可执行文件传递参数，可以将它们作为额外的参数添加到函数调用中：
- en: '[PRE67]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Puppet will try to protect you from malicious shell calls by restricting the
    characters you can use in a call to generate, so shell pipes and redirection aren't
    allowed, for example. The simplest and safest thing to do is to put all your logic
    into a script and then call that script.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet会通过限制在调用中可以使用的字符来保护你免受恶意的Shell调用，例如，不允许使用Shell管道和重定向。最简单且最安全的方法是将所有逻辑放入脚本中，然后调用这个脚本。
- en: See also
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Creating custom facts* recipe in [Chapter 9](ch09.html "Chapter 9. External
    Tools and the Puppet Ecosystem"), *External Tools and the Puppet Ecosystem*
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第九章](ch09.html "第九章. 外部工具与Puppet生态系统")中的*创建自定义事实*教程，*外部工具与Puppet生态系统*'
- en: The *Configuring Hiera* recipe in [Chapter 2](ch02.html "Chapter 2. Puppet Infrastructure"),
    *Puppet Infrastructure*
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第二章](ch02.html "第二章. Puppet基础设施")中的*配置Hiera*教程，*Puppet基础设施*'
- en: Passing arguments to shell commands
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向Shell命令传递参数
- en: If you want to insert values into a command line (to be run by an `exec` resource,
    for example), they often need to be quoted, especially if they contain spaces.
    The `shellquote` function will take any number of arguments, including arrays,
    and quote each of the arguments and return them all as a space-separated string
    that you can pass to commands.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将值插入命令行（例如由`exec`资源运行），它们通常需要加引号，尤其是当它们包含空格时。`shellquote`函数可以接收任意数量的参数，包括数组，并对每个参数加引号，然后将它们作为空格分隔的字符串返回，你可以将这个字符串传递给命令。
- en: In this example, we would like to set up an `exec` resource that will rename
    a file; but both the source and the target name contain spaces, so they need to
    be correctly quoted in the command line.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们想设置一个`exec`资源来重命名文件；但源文件名和目标文件名都包含空格，因此需要在命令行中正确加引号。
- en: How to do it…
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'Here''s an example of using the `shellquote` function:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用`shellquote`函数的示例：
- en: 'Create a `shellquote.pp` manifest with the following command:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建`shellquote.pp`清单：
- en: '[PRE68]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Run Puppet:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Puppet：
- en: '[PRE69]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: How it works…
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'First we define the `$source` and `$target` variables, which are the two filenames
    we want to use in the command line:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了`$source`和`$target`变量，这两个变量分别是我们在命令行中使用的文件名：
- en: '[PRE70]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Then we call `shellquote` to concatenate these variables into a quoted, space-separated
    string as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们调用`shellquote`将这些变量拼接成一个加引号的、空格分隔的字符串，如下所示：
- en: '[PRE71]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Then we put together the final command line:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们组合成最终的命令行：
- en: '[PRE72]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The result will be:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将会是：
- en: '[PRE73]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This command line can now be run with an exec resource. What would happen if
    we didn't use `shellquote`?
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以使用`exec`资源运行此命令行。如果我们不使用`shellquote`，会发生什么？
- en: '[PRE74]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This won't work because `mv` expects space-separated arguments, so it will interpret
    this as a request to move three files `Hello`, `Jerry`, and `Hello...` into a
    directory named `Newman`, which probably isn't what we want.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这将无法正常工作，因为`mv`命令期望接收空格分隔的参数，因此它会将这条命令解释为将三个文件`Hello`、`Jerry`和`Hello...`移动到名为`Newman`的目录中，而这可能不是我们想要的结果。
