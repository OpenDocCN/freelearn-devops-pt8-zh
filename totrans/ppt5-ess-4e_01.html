<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Writing Your First Manifests</h1>
                </header>
            
            <article>
                
<p class="mce-root">Configuration management has become essential to the IT world. Faster development using agile methods has a huge impact on IT operations that need to keep pace with the faster deployment of systems. Server operations in general are hardly even feasible without a robust management infrastructure. Among the available tools, Puppet has established itself as one of the most popular and widespread solutions. Originally written by Luke Kanies, the tool is now distributed under the terms of Apache License 2.0 and maintained by Luke's company, Puppet Inc. It boasts a large and bustling community, rich APIs for plugins and supporting tools, outstanding online documentation, and a great security model based on SSL authentication.</p>
<p>Like all configuration management systems, Puppet allows you to maintain a central repository of infrastructure definitions, along with a toolchain to enforce the desired state on the systems under management. The whole feature set is quite impressive. This book will guide you through some steps to quickly grasp the most important aspects and principles of Puppet.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Getting started</li>
<li>Introducing resources, parameters, and properties</li>
<li>Interpreting the output of the <kbd>puppet apply</kbd> command</li>
<li>Using variables</li>
<li>Adding control structures in manifests</li>
<li>Controlling the order of execution</li>
<li>Implementing resource interaction</li>
<li>Examining Puppet core resource types</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started</h1>
                </header>
            
            <article>
                
<p>Installing Puppet is easy. On large Linux distributions, you can just install the Puppet package via <kbd>apt-get</kbd> or <kbd>yum</kbd>.</p>
<p>The installation of Puppet can be done in the following ways:</p>
<ul>
<li>From default operating system repositories</li>
<li>From Puppet Inc</li>
</ul>
<p>The former way is generally simpler. <a href="7cafeeab-0e5c-4848-9eb0-1bae38ed3525.xhtml"><span class="ChapterrefPACKT">Chapter 2</span></a>, <em>Puppet Server and Agents</em>, provides simple instructions to install the Puppet Inc packages. A platform-independent way to install Puppet is to get the <kbd>puppet</kbd> Ruby gem. This is fine for testing and managing single systems, but it is not recommended for production use.</p>
<p>After installing Puppet, you can use it right away. Puppet is driven by manifests, the equivalent of scripts or programs, written in Puppet's <strong>Domain-Specific Language</strong> (<strong>DSL</strong>). Let's start with the obligatory <kbd>Hello, world!</kbd> manifest:</p>
<pre># hello_world.pp<br/>notify { 'Hello, world!':<br/>} </pre>
<div class="packt_tip"><span class="packt_screen">Downloading the example code</span>:<br/>
You can download the example code files for all the Packt Publishing books you have purchased from your account at <a href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register yourself to have the files emailed directly to you.</div>
<p>To put the manifest to work, use the following command (we avoided the term <kbd>execute</kbd> on purpose-manifests cannot be executed; more details will follow around the middle of this chapter):</p>
<pre><strong>root@puppetmaster:~# puppet apply hello_world.pp</strong><br/><strong>Notice: Compiled catalog for puppetmaster.example.net in environment production in 0.45 seconds</strong><br/><strong>Notice: Hello, world!</strong><br/><strong>Notice: /Stage[main]/Main/Notify[Hello, world!]/message: defined 'message' as 'Hello, world!'</strong><br/><strong>Notice: Applied catalog in 0.03 seconds  </strong></pre>
<div class="packt_infobox">The package from Puppet Inc. bundles all required software components and installs to <kbd>/opt/puppetlabs</kbd>. In the case that the puppet command cannot be found, you can either specify the full path (<kbd>/opt/puppetlabs/bin/puppet</kbd>) or you can refresh your shell environment (<kbd>exec</kbd> bash, or log out and log in again).</div>
<p>Before we take a look at the structure of the manifest and the output from the <kbd>puppet apply</kbd> command, let's do something useful, just as an example. Puppet comes with its own background service. Let's assume that you want to learn the basics before letting it mess with your system. You can write a manifest to have Puppet make sure that the service is not currently running and will not be started at system boot:</p>
<pre># puppet_service.pp<br/>service { 'puppet':<br/>  ensure =&gt; 'stopped',<br/>  enable =&gt; false,<br/>}</pre>
<p>To control system processes, boot options, software installation, and the same as the Puppet needs to be run with <kbd>root</kbd> privileges. This is the most common way to invoke the tool, because Puppet will often manage OS-level facilities. Apply your new manifest with root access, either through <kbd>sudo</kbd> or from a root shell, as shown in the following transcript:</p>
<pre><strong>root@puppetmaster:~# puppet apply puppet_service.pp</strong><br/><strong>Notice: Compiled catalog for puppetmaster.example.net in environment production in 0.61 seconds</strong><br/><strong>Notice: /Stage[main]/Main/Service[puppet]/ensure: ensure changed 'running' to 'stopped'</strong><br/><strong>Notice: Applied catalog in 0.15 seconds </strong></pre>
<p>Now, Puppet has disabled the automatic startup of its background service for you. Applying the same manifest again has no effect, because the necessary steps are already complete:</p>
<pre><strong>root@puppetmaster:~# puppet apply puppet_service.pp</strong><br/><strong>Notice: Compiled catalog for puppetmaster.example.net in environment </strong><br/><strong>production in 0.62 seconds</strong><br/><strong>Notice: Applied catalog in 0.07 seconds  </strong></pre>
<p>This reflects a standard behavior in Puppet: Puppet resources are <strong>idempotent</strong>, which means that every resource first compares the actual (system) with the desired (Puppet) state and only initiates actions in case there is a difference (configuration drift).</p>
<p>You will often get this output from Puppet. It tells you that everything is as it should be. As such, this is a desirable outcome, like the all clean output from git status.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing resources, parameters, and properties</h1>
                </header>
            
            <article>
                
<p>Each of the manifests you wrote in the previous section declared one respective resource. Resources are the elementary building blocks of manifests. Each has a type (in this case, <kbd>notify</kbd> and <kbd>service</kbd>, respectively) and a name or title (<kbd>Hello, world!</kbd> and <kbd>puppet</kbd>). Each resource is unique to a manifest, and can be referenced by the combination of its type and name, such as <kbd>Service["puppet"]</kbd>. Finally, a resource also comprises a list of zero or more attributes. An attribute is a key-value pair, such as <kbd>"enable =&gt; false"</kbd>.</p>
<p>Attribute names cannot be chosen arbitrarily. They are part of the Puppet resource type. Puppet differentiates between two different attributes: parameters and properties. Each resource type supports a specific set of attributes. Parameters describe the way that Puppet should deal with a resource type. Properties describe a specific setting of a resource. Certain parameters are available for all resource types (metaparameters), and some names are just very common, such as <kbd>ensure</kbd>. The <kbd>service</kbd> type supports the <kbd>ensure</kbd> property, which represents the status of the managed process. Its <kbd>enabled</kbd> property, on the other hand, relates to the system boot configuration (with respect to the service in question).</p>
<div class="packt_infobox">We have used the terms attribute, property, and parameter in a seemingly interchangeable fashion. Don't be deceived-there are important distinctions. Property and parameter are the two different kinds of attributes that Puppet uses.</div>
<p>You have already seen two properties in action. Let's look at a parameter:</p>
<pre>service { 'puppet':<br/>  ensure   =&gt; 'stopped',<br/>  enable   =&gt; false,<br/>  provider =&gt; 'upstart',<br/>}</pre>
<p>The <kbd>provider</kbd> parameter tells Puppet that it needs to interact with the <kbd>upstart</kbd> subsystem to control its background service, as opposed to <kbd>systemd</kbd> or <kbd>init</kbd>. If you don't specify this parameter, Puppet makes an educated guess. There is quite a multitude of supported facilities to manage services on a system. You will learn more about providers and their automatic choosing later on.</p>
<p>The difference between parameters and properties is that the parameter merely indicates how Puppet should manage the resource, not what a desired state is. Puppet will only take action on property values. In this example, these are <kbd>ensure =&gt; 'stopped'</kbd> and <kbd>enable =&gt; false</kbd>. For each such property, Puppet will perform the following tasks:</p>
<ul>
<li>Test whether the resource is already in sync with the target state</li>
<li>If the resource is not in sync, it will trigger a sync action</li>
</ul>
<p>A property is considered to be in sync when the system entity that is managed by the given resource (in this case, the <kbd>upstart</kbd> service configuration for Puppet) is in the state that is described by the property value in the manifest. In this example, the <kbd>ensure</kbd> property will be in sync only if the <kbd>puppet</kbd> service is not running. The <kbd>enable</kbd> property is in sync if <kbd>upstart</kbd> is not configured to launch Puppet at system start.</p>
<p>As a mnemonic concerning parameters versus properties, just remember that properties can be out of sync, whereas parameters cannot.</p>
<p>Puppet also allows you to read your existing system state by using the puppet resource command:</p>
<pre><strong>root@puppetmaster:~# puppet resource user root</strong><br/><strong>user { 'root':</strong><br/><strong>  ensure           =&gt; 'present',</strong><br/><strong>  comment          =&gt; 'root',</strong><br/><strong>  gid              =&gt; '0',</strong><br/><strong>  home             =&gt; '/root',</strong><br/><strong>  password         =&gt; '$6$17/7FtU/$TvYEDtFgGr0SaS7xOVloWXVTqQxxDUgH.</strong><br/><strong>  eBKJ7bgHJ.hdoc03Xrvm2ru0HFKpu1QSpVW/7o.rLdk/9MZANEGt/',</strong><br/><strong>  password_max_age =&gt; '99999',</strong><br/><strong>  password_min_age =&gt; '0',</strong><br/><strong>  shell            =&gt; '/bin/bash',</strong><br/><strong>  uid              =&gt; '0',</strong><br/><strong>}  </strong></pre>
<p>Please note that some resource types will return read-only attributes (for example, the file resource type will return <kbd>mtime</kbd> and <kbd>ctime</kbd>). Refer to the appropriate type's documentation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interpreting output of the puppet apply command</h1>
                </header>
            
            <article>
                
<p>As you have already witnessed, the output presented by Puppet is rather verbose. As you get more experienced with the tool, you will quickly learn to spot the crucial pieces of information. Let's first take a look at the informational messages, though. Apply the <kbd>service.pp</kbd> manifest once more:</p>
<pre><strong>root@puppetmaster:~# puppet apply puppet_service.pp</strong><br/><strong>Notice: Compiled catalog for puppetmaster.example.net in environment production in 0.48 seconds</strong><br/><strong>Notice: Applied catalog in 0.05 seconds</strong></pre>
<p>Puppet took no particular action. You only get two timings: one from the compiling phase of the manifest, and the other from the catalog application phase. The catalog is a comprehensive representation of a compiled manifest. Puppet bases all its efforts concerning the evaluation and syncing of resources on the content of its current catalog.</p>
<p>Now, to quickly force Puppet to show you some more interesting output, pass it a one-line manifest directly from the shell. Regular users of Ruby or Perl will recognize the call syntax:</p>
<pre><strong># puppet apply -e'service { "puppet": enable =&gt; true, }'</strong><br/><strong>Notice: Compiled catalog for puppetmaster.example.net in environment production in 0.62 seconds</strong><br/><strong>Notice: /Stage[main]/Main/Service[puppet]/enable: enable changed 'false' to 'true'</strong><br/><strong>Notice: Applied catalog in 0.12 seconds.<br/></strong></pre>
<div class="packt_infobox">We prefer double quotes in manifests that get passed as command-line arguments, because on the shell, the manifest should be enclosed in single quotes as a whole.</div>
<p>You instructed Puppet to perform yet another change on the Puppet service. The output reflects the exact change that was performed. Let's analyze this log message:</p>
<ul>
<li>The <kbd>Notice:</kbd> keyword at the beginning of the line represents the log level. Other levels include <kbd>Warning</kbd>, <kbd>Error</kbd>, and <kbd>Debug</kbd></li>
<li>The property that changed is referenced with a whole path, starting with <kbd>Stage[main]</kbd>. Stages are beyond the scope of this book, so you will always just see the default of <kbd>main</kbd> here</li>
<li>The next path element is <kbd>Main</kbd>, which is another default. It denotes the class in which the resource was declared. You will learn about classes in <a href="daf11a18-5de2-4c3c-9880-e9a242ffb35b.xhtml"><span class="ChapterrefPACKT">Chapter 4</span></a>, <em>Combining Resources in Classes and Defined Types</em></li>
<li>Next, is the resource. You already learned that <kbd>Service[puppet]</kbd> is its unique reference</li>
<li>Finally, <kbd>enable</kbd> is the name of the property in question. When several properties are out of sync, there will usually be one line of output for each property that gets synchronized</li>
<li>The rest of the log line indicates the type of change that Puppet saw fit to apply. The wording depends on the nature of the property. It can be as simple as <kbd>created</kbd>, for a resource that is newly added to the managed system, or a short phrase, such as <kbd>changed false to true</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dry testing your manifest</h1>
                </header>
            
            <article>
                
<p>Another useful command-line switch for <kbd>puppet apply</kbd> is the <kbd>--noop</kbd> option.<br/>
It instructs Puppet to refrain from taking any action on unsynced resources.<br/>
Instead, you only get a log output that indicates what will change without the switch. This is useful in determining whether a manifest would possibly break anything on your system:</p>
<pre><strong>root@puppetmaster:~# puppet apply puppet_service.pp --noop</strong><br/><strong>Notice: Compiled catalog for puppetmaster.example.net in environment production in 0.63 seconds</strong><br/><strong>Notice: /Stage[main]/Main/Service[puppet]/enable: current_value true, should be false (noop)</strong><br/><strong>Notice: Class[Main]: Would have triggered 'refresh' from 1 events</strong><br/><strong>Notice: Stage[main]: Would have triggered 'refresh' from 1 events</strong><br/><strong>Notice: Applied catalog in 0.06 seconds  </strong></pre>
<div class="packt_infobox">The output format is the same as before, with a (<kbd>noop</kbd>) marker trailing the notice about the sync action. This log can be considered a preview of what will happen when the manifest is applied without the <kbd>--noop</kbd> switch.</div>
<p>The additional notices about triggered refreshes will be described later, and can be ignored for the moment. You will have a better understanding of their significance after finishing this chapter and <a href="daf11a18-5de2-4c3c-9880-e9a242ffb35b.xhtml"><span class="ChapterrefPACKT">Chapter 4</span></a>, <em>Combining Resources in Classes and Defined Types.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using variables</h1>
                </header>
            
            <article>
                
<p>Variable assignment works just like it does in most scripting languages. Any variable name is always prefixed with the <kbd>$</kbd> sign:</p>
<pre>$download_server = 'img2.example.net'<br/>$url = "https://${download_server}/pkg/example_source.tar.gz"<strong> </strong> </pre>
<p>Also, just like most scripting languages, Puppet performs variable value substitution in strings that are in double quotes, but no interpolation at all in single-quoted strings.</p>
<p>Variables are useful for making your manifest more concise and comprehensible. They help you with the overall goal of keeping your source code free from redundancy. An important distinction from variables in imperative programming and scripting languages is the immutability of variables in Puppet manifests. Once a value has been assigned, it cannot be overwritten.</p>
<p>Why is it called a variable at all if it is a constant? One should never look at Puppet as a tool that manages a single system. For a single system, a Puppet variable might look like a constant, but Puppet manages a multitude of systems with different operating systems. Across all these systems, variables will be different and not constants.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Variable types</h1>
                </header>
            
            <article>
                
<p>As of Puppet 3.x, there are only four variable types: strings, arrays, hashes, and Booleans. Puppet 4 introduces a rich data type system. The new data type system will be explained at the end of, <a href="b38488ca-86a7-4ecf-9a69-16938576d852.xhtml"><span class="ChapterrefPACKT">Chapter 7</span></a>, <em>New Features from Puppet 4 and 5</em>. The basic variable types work much like their respective counterparts in other languages. Depending on your background, you might be familiar with using associative arrays or dictionaries as semantic equivalents to Puppet's hash type:</p>
<pre>$a_bool = true<br/>$a_string = 'This is a string value'<br/>$an_array = [ 'This', 'forms', 'an', 'array' ]<br/>$a_hash = { <br/>  'subject'   =&gt; 'Hashes',<br/>  'predicate' =&gt; 'are written',<br/>  'object'    =&gt; 'like this',<br/>  'note'      =&gt; 'not actual grammar!',<br/>  'also note' =&gt; [ 'nesting is',<br/>{ 'allowed'   =&gt; ' of course' } ], <br/>}</pre>
<p>Accessing the values is equally simple. Note that the <kbd>hash</kbd> syntax is similar to that of Ruby, not Perl:</p>
<pre>$x = $a_string<br/>$y = $an_array[1]<br/>$z = $a_hash['object'] </pre>
<p>Strings can be used as resource attribute values, but it's worth noting that a resource title can also be a variable reference:</p>
<pre>package { $apache_package:<br/>  ensure =&gt; 'installed'<br/>}</pre>
<p>It's intuitively clear what a string value means in this context. But you can also pass arrays here to declare a whole set of resources in one statement. The following manifest manages three packages, making sure that they are all installed:</p>
<pre>$packages = [<br/>  'apache2',<br/>  'libapache2-mod-php5',<br/>  'libapache2-mod-passenger',<br/> ]<br/>package { $packages:<br/>  ensure =&gt; 'installed'<br/>}</pre>
<p>You will learn how to make efficient use of hash values in later chapters.</p>
<p>The array does not need to be stored in a variable to be used, but it is a good practice in some cases.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data types</h1>
                </header>
            
            <article>
                
<p>The data type system in Puppet 4 allows you to check and verify whether a variable is of a specific data type. This prevents code from behaving incorrectly when (for example) it expects an array but receives a Boolean value.</p>
<p>The full power of data types will be explained in <a href="b38488ca-86a7-4ecf-9a69-16938576d852.xhtml">Chapter 7</a>, <em>New Features from Puppet 4 and 5</em>. Within Puppet manifests, it is possible to check for data types using the regexp control structure.</p>
<p>Puppet has core data types and abstract data types. The core data types are the most commonly used types of data, such as string or integer, whereas abstract data types allow for more sophisticated type validation, such as optional or variant.</p>
<p>Prior to dealing with data types, we must understand the concept of control structures within Puppet manifests.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding control structures in manifests</h1>
                </header>
            
            <article>
                
<p>So far, you have written three simple manifests while following the instructions in this chapter. Each comprised only one resource, and one of them was given on the command line using the <kbd>-e</kbd> option. Of course, you would not want to write distinct manifests for each possible circumstance. Instead, just as how Ruby or Perl scripts branch out into different code paths, there are structures that make your Puppet code flexible and reusable for different circumstances.</p>
<p>The most common control element is the <kbd>if</kbd>/<kbd>else</kbd> block. It is quite similar to its equivalents in many programming languages:</p>
<pre>if 'mail_lda' in $needed_services {<br/>  service { 'dovecot': enable =&gt; true }<br/>} else {<br/>  service { 'dovecot': enable =&gt; false }<br/>}</pre>
<p>The Puppet DSL also has a <kbd>case</kbd> statement, which is reminiscent of its counterparts in other languages as well:</p>
<pre>case $role {<br/>  ‘imap_server’: {<br/>    package { ‘dovecot’: ensure =&gt; installed, }<br/>    service { ‘dovecot’: ensure =&gt; running, }<br/>  }<br/>  /_webservers$/: {<br/>    service { [‘apache’, ‘ssh’]: ensure =&gt; running, }<br/>  }<br/>  default: {<br/>    service { ‘ssh’: ensure =&gt; running, }<br/>  }<br/>}</pre>
<p>At the second matcher, you can see how it is possible to use regular expressions.</p>
<p>The case statement can also be used to switch to specific code based on variable data types:</p>
<pre>case $role {<br/>  Array: {<br/>    include $role[0]<br/>  }<br/>  String: {<br/>    include $role<br/>  }<br/>  default: {<br/>    notify { 'This nodes $role variable is neither an <br/>    Array nor a String':}<br/>  }<br/>}</pre>
<p>A variation of the <kbd>case</kbd> statement is the selector. It's an expression, not a statement, and can be used in a fashion similar to the ternary <kbd>if</kbd>/<kbd>else</kbd> operator found in C-like languages:</p>
<pre>package { 'dovecot':<br/>  ensure =&gt; $role ? {<br/>    'imap_server' =&gt; 'installed',<br/>    /desktop$/    =&gt; 'purged',<br/>    default       =&gt; 'removed',<br/>  },<br/>}</pre>
<p>Similar to the case statement, the selector can also be used to return results, depending on the data types:</p>
<pre>package { 'dovecot':<br/>  ensure  =&gt; $role ? {<br/>    Boolean =&gt; 'installed',<br/>    String  =&gt; 'purged',<br/>    default =&gt; 'removed',<br/>  },<br/>}</pre>
<p>The selector should be used with caution, because in more complex manifests, this syntax will impede readability.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Controlling the order of execution</h1>
                </header>
            
            <article>
                
<p>With what you've seen this far, you might have got the impression that Puppet's DSL is a specialized scripting language. That is actually quite far from the truth. A manifest is not a script or program. The language is a tool to model a system state through a set of resources, including files, packages, and cron jobs, among others.</p>
<p>The whole paradigm is different from that of scripting languages. Ruby or Perl are imperative languages that are based around statements that will be evaluated in a strict order. The Puppet DSL is declarative, which means that the manifest declares a set of resources that are expected to have certain properties. These resources are put into a catalog, and Puppet then tries to build a path through all declared resources. The compiler parses the manifests in order, but the configurer applies resources in a very different way.</p>
<p>In other words, the manifests should always describe what you expect to be the end result. The specifics of what actions need to be taken to get there are decided by Puppet.</p>
<p>To make this distinction more clear, let's look at an example:</p>
<pre>package { 'haproxy':<br/>  ensure =&gt; 'installed',<br/>}<br/>file {'/etc/haproxy/haproxy.cfg':<br/>  ensure =&gt; file,<br/>  owner  =&gt; 'root',<br/>  group  =&gt; 'root',<br/>  mode   =&gt; '0644',<br/>  source =&gt; 'puppet:///modules/haproxy/etc/haproxy/haproxy.cfg',<br/>}<br/>service { 'haproxy':<br/>  ensure  =&gt; 'running',<br/>}</pre>
<p>With this manifest, Puppet will make sure that the following state is reached:</p>
<ol>
<li>The <kbd>HAproxy</kbd> package is installed.</li>
<li>The <kbd>haproxy.cfg</kbd> file has specific content, which has been prepared in a file in <kbd>/etc/puppet/modules/</kbd>.</li>
<li><kbd>HAproxy</kbd> is started.</li>
</ol>
<p>To make this work, it is important that the necessary steps are performed in order:</p>
<ul>
<li>A configuration file cannot usually be installed before the package because there is not yet a directory to contain it</li>
<li>The service cannot start before installation either. If it becomes active before the configuration is in place, it will use the default settings from the package instead</li>
</ul>
<p>This point is being stressed because the preceding manifest does not, in fact, contain cues for Puppet to indicate such a strict ordering. Without explicit dependencies, Puppet is free to put the resources in any order it sees fit.</p>
<p class="mce-root">The recent versions of Puppet allow a form of local manifest-based ordering, so the presented example will actually work as is. The manifest-based ordering can be configured in the <kbd>puppet.conf</kbd> configuration file as follows:</p>
<pre class="mce-root"><strong>ordering = manifest</strong></pre>
<p class="mce-root">This setting is default for Puppet 4. It is still important to be aware of the ordering principles because the implicit order is difficult to determine in more complex manifests, and as you will learn soon, there are other factors that will influence the order.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Declaring dependencies</h1>
                </header>
            
            <article>
                
<p>The easiest way to bring order to such a straightforward manifest is resource chaining. The syntax for this is a simple ASCII arrow between two resources:</p>
<pre>package { 'haproxy':<br/>  ensure =&gt; 'installed',<br/>}<br/>-&gt;<br/>file { '/etc/haproxy/haproxy.cfg':<br/>  ensure =&gt; file,<br/>  owner  =&gt; 'root',<br/>  group  =&gt; 'root',<br/>  mode   =&gt; '0644',<br/>  source =&gt; 'puppet:///modules/haproxy/etc/haproxy/haproxy.cfg',<br/>}<br/>-&gt;<br/>service {'haproxy':<br/>  ensure =&gt; 'running',<br/>}</pre>
<p>This is only viable if all the related resources can be written next to each other. In other words, if the graphic representation of the dependencies does not form a straight chain, but more of a tree, star, or any other shape, this syntax is not sufficient.</p>
<div class="packt_tip">Internally, Puppet <em>will</em> construct an ordered graph of resources and synchronize them during a traversal of that graph.</div>
<p>A more generic and flexible way to declare dependencies is through special metaparameters-parameters that are eligible for use with any resource type. There are different metaparameters, most of which have nothing to do with ordering (you have seen <kbd>provider</kbd> in an earlier example). For resource ordering, Puppet offers the metaparameters require and before.<br/>
Both take one or more references to a declared resource as their value. As was previously mentioned, Puppet references have a special syntax:</p>
<pre>Type['title']<br/>e.g.<br/>Package['haproxy'] </pre>
<div class="packt_infobox">You can only build references to resources that are declared in the catalog. You cannot build and use references to something that is not managed by Puppet, even when it exists on the managed system.</div>
<p>Here is the <kbd>HAproxy</kbd> manifest, ordered using the <kbd>require</kbd> metaparameter:</p>
<pre>package { 'haproxy':<br/>  ensure  =&gt; 'installed',<br/>}<br/>file {'/etc/haproxy/haproxy.cfg':<br/>  ensure  =&gt; file,<br/>  owner   =&gt; 'root',<br/>  group   =&gt; 'root',<br/>  mode    =&gt; '0644',<br/>  source  =&gt; 'puppet:///modules/haproxy/etc/haproxy/haproxy.cfg',<br/>  require =&gt; Package['haproxy'],<br/>}<br/> service {'haproxy':<br/>  ensure  =&gt; 'running',<br/>  require =&gt; File['/etc/haproxy/haproxy.cfg'],<br/>}</pre>
<p>The following manifest is semantically identical, but relies on the <kbd>before</kbd> metaparameter rather than <kbd>require</kbd>:</p>
<pre>package { 'haproxy':<br/>  ensure =&gt; 'installed',<br/>  before =&gt; File['/etc/haproxy/haproxy.cfg'],<br/>}<br/>file { '/etc/haproxy/haproxy.cfg':<br/>  ensure =&gt; file,<br/>  owner  =&gt; 'root',<br/>  group  =&gt; 'root',<br/>  mode   =&gt; '0644',<br/>  source =&gt; 'puppet:///modules/haproxy/etc/haproxy/haproxy.cfg',<br/>  before =&gt; Service['haproxy'],<br/>}<br/>service { 'haproxy':<br/>  ensure =&gt; 'running',<br/>}</pre>
<div class="packt_infobox">The manifest can also mix both styles of notation, of course. This is left as a reader exercise with no dedicated depiction.</div>
<p>The <kbd>require</kbd> metaparameter usually leads to more understandable code because it expresses the dependency of the annotated resource on another resource. The <kbd>before</kbd> parameter, on the other hand, implies a dependency that a referenced resource forms upon the current resource. This can be counter-intuitive, especially for frequent users of packaging systems (which usually implement a <kbd>require</kbd>-style dependency declaration).</p>
<p>Sometimes, it might be difficult to decide whether to use <kbd>require</kbd> or <kbd>before</kbd>. In simple cases, most people prefer <kbd>require</kbd>. In some cases, it is easier to use <kbd>before</kbd>. Think of services that have multiple configuration files. Keeping information about the configuration file and the requirement in a single place reduces errors caused by forgetting to also adopt changes to the service when adding or removing additional configuration files. Take a look at the following example code:</p>
<pre>file { '/etc/apache2/apache2.conf':<br/>  ensure =&gt; file,<br/>  before =&gt; Service['apache2'],<br/>}<br/>file { '/etc/apache2/httpd.conf':<br/>  ensure =&gt; file,<br/>  before =&gt; Service['apache2'],<br/>}<br/>service { 'apache2':<br/>  ensure =&gt; running,<br/>  enable =&gt; true,<br/>}</pre>
<p>In the example, all dependencies are declared within the file resource declarations. If you use the require parameter instead, you will always need to touch at least two resources in case of changes:</p>
<pre>file { '/etc/apache2/apache2.conf':<br/>  ensure =&gt; file,<br/>}<br/>file { '/etc/apache2/httpd.conf':<br/>  ensure =&gt; file,<br/>}<br/>service { 'apache2':<br/>  ensure =&gt; running,<br/>  enable =&gt; true,<br/> require =&gt; [<br/>    File['/etc/apache2/apache2.conf'],<br/>    File['/etc/apache2/httpd.conf'],<br/>  ],<br/>}</pre>
<p>Will you remember to update the service resource declaration whenever you add a new file to be managed by Puppet? Consider another, simpler example:</p>
<pre>if $os_family == 'Debian' {<br/>  file { '/etc/apt/preferences.d/example.net.prefs':<br/>    content =&gt; '...',<br/>    before  =&gt; Package['apache2'],<br/>  }<br/>}<br/>package { 'apache2':<br/>  ensure    =&gt; 'installed',<br/>} </pre>
<p>The file in the <kbd>preferences.d</kbd> directory only makes sense for Debian-like systems; that's why the package cannot safely <kbd>require</kbd> it. If the manifest is applied on a different OS, such as CentOS, the <kbd>apt</kbd> preferences file will not appear in the catalog thanks to the <kbd>if</kbd> clause. If the package had it as a requirement regardless, the resulting catalog would be inconsistent, and Puppet would not apply it. Specifying <kbd>before</kbd> in the file resource is safe, and semantically equivalent.</p>
<p>The <kbd>before</kbd> metaparameter is outright necessary in situations like this one, and can make the manifest code more elegant and straightforward in other scenarios. Familiarity with both <kbd>before</kbd> and <kbd>require</kbd> is advisable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Error propagation</h1>
                </header>
            
            <article>
                
<p>Defining requirements serves another important purpose. References on declared resources will only be validated as successful references if the depended-upon resource was finished successfully. This can be seen as a kind of stop point inside Puppet DSL code, when a required resource is not synchronized successfully.</p>
<p>For example, a <kbd>file</kbd> resource will fail if the URL of the <kbd>source</kbd> file is broken:</p>
<pre>file { '/etc/haproxy/haproxy.cfg':<br/>  ensure =&gt; file,<br/>  source =&gt; 'puppet:///modules/haproxy/etc/haproxy.cfg',<br/>}  </pre>
<p>One path segment is missing here. Puppet will report that the file resource could not be synchronized:</p>
<pre><strong>root@puppetmaster:~# puppet apply typo.pp</strong><br/><strong>Notice: Compiled catalog for puppetmaster.example.net in environment production in 0.62 seconds</strong><br/><strong>Error: /Stage[main]/Main/File[/etc/haproxy/haproxy.cfg]: Could not evaluate: Could not retrieve information from environment production source(s) puppet:///modules/haproxy/etc/haproxy.cfg</strong><br/><strong>Notice: /Stage[main]/Main/Service[haproxy]: Dependency File[/etc/haproxy/haproxy.cfg] has failures: true</strong><br/><strong>Warning: /Stage[main]/Main/Service[haproxy]: Skipping because of failed dependencies</strong><br/><strong>Notice: Applied catalog in 0.06 seconds  </strong></pre>
<p>In this example, the <kbd>Error</kbd> line describes the error caused by the broken URL. The error propagation is represented by the <kbd>Notice</kbd> and <kbd>Warning</kbd> lines below it.</p>
<p>Puppet failed to apply changes to the configuration file; it cannot compare the current state to the nonexistent source. As the service depends on the configuration file, Puppet will not even try to start it. This is for safety: if any dependencies cannot be put into the defined state, Puppet must assume that the system is not fit for the application of the dependent resource.</p>
<p>This is another important reason to make use of resource dependencies. Remember that both the chaining arrow and the <kbd>before</kbd> metaparameter imply error propagation as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Avoiding circular dependencies</h1>
                </header>
            
            <article>
                
<p>Before you learn about another way in which resources can interrelate, there is an issue that you should be aware of: dependencies must not form circles. Let's visualize this in an example:</p>
<pre>file { '/etc/haproxy':<br/>  ensure  =&gt; 'directory',<br/>  owner   =&gt; 'root',<br/>  group   =&gt; 'root',<br/>  mode    =&gt; '0644',<br/>}<br/>file { '/etc/haproxy/haproxy.cfg':<br/>  ensure  =&gt; file,<br/>  owner   =&gt; 'root',<br/>  group   =&gt; 'root',<br/>  mode    =&gt; '0644',<br/>  source  =&gt; 'puppet:///modules/haproxy/etc/haproxy/haproxy.cfg',<br/>}<br/>service { 'haproxy':<br/>  ensure  =&gt; 'running',<br/>  require =&gt; File['/etc/haproxy/haproxy.cfg'],<br/>  before  =&gt; File['/etc/haproxy'],<br/>}</pre>
<p>The dependency circle in this manifest is somewhat hidden (as will likely be the case for many such circles that you will encounter during regular use of Puppet).<br/>
It is formed by the following relations:</p>
<ul>
<li>The <kbd>File['/etc/haproxy/haproxy.cfg']</kbd> auto-requires the parent directory, <kbd>File['/etc/haproxy']</kbd>. This is an implicit, built-in dependency</li>
<li>The parent directory, <kbd>File['/etc/haproxy']</kbd>, requires <kbd>Service['haproxy']</kbd> due to its <kbd>before</kbd> metaparameter</li>
<li>The <kbd>Service['haproxy']</kbd> service requires the <kbd>File['/etc/haproxy/haproxy.cfg']</kbd> config</li>
</ul>
<p class="mce-root">Implicit dependencies exist for the following resource combinations, among others:</p>
<ul>
<li>If a directory and a file inside the <kbd>directory</kbd> are declared, Puppet will first create the <kbd>directory</kbd> and then the file</li>
<li>If a user and his/her primary group is declared, Puppet will first create the group and then the user</li>
<li>If a file and the owner (user) are declared, Puppet will first create the user and then the file</li>
</ul>
<p>Granted, the preceding example is contrived-it will not make sense to manage the service before the configuration directory. Nevertheless, even a manifest design that is apparently sound can result in circular dependencies. This is how Puppet will react to such a design:</p>
<pre><strong>root@puppetmaster:~# puppet apply circle.pp</strong><br/><strong>Notice: Compiled catalog for puppetmaster.example.net in environment production in 0.62 seconds</strong><br/><strong>Error: Failed to apply catalog: Found 1 dependency cycle:</strong><br/><strong>(File[/etc/haproxy/haproxy.cfg] =&gt; <br/>               Service[haproxy] =&gt; <br/>             File[/etc/haproxy] =&gt; File[/etc/haproxy/haproxy.cfg])</strong><br/><strong>Try the '--graph' option and opening the resulting '.dot' file in OmniGraffle or GraphViz</strong></pre>
<p>The output helps you locate the offending relation(s). For very wide dependency circles with lots of involved resources, the textual rendering is difficult to analyze. Therefore, Puppet also gives you the opportunity to get a graphical representation of the dependency graph through the <kbd>--graph</kbd> option.</p>
<p>If you do this, Puppet will include the full path to the newly created <kbd>.dot</kbd> file in its output. Its content looks similar to Puppet's output:</p>
<pre>digraph Resource_Cycles {<br/>label = "Resource Cycles"<br/>"File[/etc/haproxy/haproxy.cfg]" -&gt;"Service[haproxy]" -&gt;"File[/etc/haproxy]" -&gt;"File[/etc/haproxy/haproxy.cfg]"<br/>}  </pre>
<p>This is not helpful by itself, but it can be fed directly into tools such as <kbd>dotty</kbd> to produce an actual diagram.</p>
<p>To summarize, resource dependencies are helpful in keeping Puppet from acting upon resources in unexpected or uncontrolled situations. They are also useful in restricting the order of resource evaluation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing resource interaction</h1>
                </header>
            
            <article>
                
<p>In addition to dependencies, resources can also enter a similar yet different mutual relation. Remember the pieces of output that we skipped earlier. They are as follows:</p>
<pre><strong>root@puppetmaster:~# puppet apply puppet_service.pp --noop</strong><br/><strong>Notice: Compiled catalog for puppetmaster.example.net in environment production in 0.62 seconds</strong><br/><strong>Notice: /Stage[main]/Main/Service[puppet]/ensure: current_value running, should be stopped (noop)</strong><br/><strong>Notice: Class[Main]: Would have triggered 'refresh' from 1 events</strong><br/><strong>Notice: Stage[main]: Would have triggered 'refresh' from 1 events</strong><br/><strong>Notice: Applied catalog in 0.05 seconds  </strong></pre>
<p>Puppet mentions that <strong>refreshes</strong> would have been triggered for the reason of an <strong>event</strong>. Such events are emitted by resources whenever Puppet acts on the need for a sync action. Without explicit code to receive and react to events, they just get discarded.</p>
<p>The mechanism to set up such event receivers is named in an analogy of a generic publish/subscribe queue; resources get configured to react to events using the <kbd>subscribe</kbd> metaparameter. There is no <kbd>publish</kbd> keyword or parameter, since each and every resource is technically a publisher of events (messages). Instead, the counterpart of the <kbd>subscribe</kbd> metaparameter is called <kbd>notify</kbd>, and it explicitly directs generated events at referenced resources.</p>
<p>One of the most common practical uses of the event system is to reload service configurations. When a <kbd>service</kbd> resource consumes an event (usually from a change in a config file), Puppet invokes the appropriate action to make the service restart.</p>
<div class="packt_infobox">If you instruct Puppet to do this, it can result in brief service interruptions due to this restart operation. Note that if the new configuration causes an error, the service might fail to start and stay offline.</div>
<p>The following code example shows the relationships between the <kbd>haproxy</kbd> package, the corresponding <kbd>haproxy</kbd> configuration file, and the <kbd>haproxy</kbd> service:</p>
<pre>file { '/etc/haproxy/haproxy.cfg':<br/>  ensure  =&gt; file,<br/>  owner   =&gt; ‘root’,<br/>  group   =&gt; ‘root’<br/>  mode    =&gt; ‘0644’<br/>  source  =&gt; ‘puppet:///modules/haproxy/etc/haproxy/haproxy.cfg',<br/>  require =&gt; Package['haproxy'],<br/>}<br/>service { 'haproxy':<br/>  ensure    =&gt; 'running',<br/>  subscribe =&gt; File['/etc/haproxy/haproxy.cfg'],<br/>}</pre>
<p>If the <kbd>notify</kbd> metaparameter is to be used instead, it must be specified for the resource that emits the event:</p>
<pre>file { '/etc/haproxy/haproxy.cfg':<br/>  ensure  =&gt; file,<br/>  owner   =&gt; 'root',<br/>  group   =&gt; 'root',<br/>  mode    =&gt; '0644',<br/>  source  =&gt; 'puppet:///modules/haproxy/etc/haproxy/haproxy.cfg',<br/>  require =&gt; Package['haproxy'],<br/>  notify  =&gt; Service['haproxy'],<br/>}<br/>service { 'haproxy':<br/>  ensure  =&gt; 'running',<br/>}</pre>
<p>This will likely feel reminiscent of the <kbd>before</kbd> and <kbd>require</kbd> metaparameters, which offer symmetrical ways of expressing an interrelation of a pair of resources just as well. This is not a coincidence, these metaparameters are closely related to each other:</p>
<ul>
<li>The resource that subscribes to another resource implicitly requires it</li>
<li>The resource that notifies another is implicitly placed before the later one in the dependency graph</li>
</ul>
<p>In other words, <kbd>subscribe</kbd> is the same as <kbd>require</kbd>, except for the dependent resource receiving events from its peer. The same holds true for <kbd>notify</kbd> and <kbd>before</kbd>.</p>
<p>The chaining syntax is also available for signaling. To establish a signaling relation between neighboring resources, use an ASCII arrow with a tilde, <kbd>~&gt;</kbd>, instead of the dash in <kbd>-&gt;</kbd>:</p>
<pre>file { '/etc/haproxy/haproxy.cfg': … }<br/>~&gt;<br/>service { 'haproxy': … }</pre>
<p>The <kbd>service</kbd> resource type is one of the two notable types that support refreshing when resources get notified (the other will be discussed in the next section). There are others, but they are not as ubiquitous.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Examining Puppet core resource types</h1>
                </header>
            
            <article>
                
<p>To complete our tour of the basic elements of a manifest, let's take a closer look at the resource types that you have already used, and some of the more important ones that you have not yet encountered and are part of Puppet's base installation.</p>
<p>You probably already have a good feeling for the <kbd>file</kbd> type, which will ensure the existence of files and directories, along with their permissions. Pulling a file from a repository (usually, a Puppet module) using the <kbd>source</kbd> parameter is also a frequent use case.</p>
<p>For very short files, it is more economical to include the desired content right in the manifest:</p>
<pre>file { '/etc/modules':<br/>  ensure  =&gt; file,<br/>  content =&gt; "# Managed by Puppet!\n\ndrbd\n",<br/>}</pre>
<div class="packt_tip">The double quotes allow expansion of escape sequences, such as <kbd>\n</kbd>.</div>
<p>Another useful capability is managing symbolic links:</p>
<pre>file { '/etc/apache2/sites-enabled/001-puppet-lore.org':<br/>  ensure =&gt; 'link',<br/>  target =&gt; '../sites-available/puppet-lore.org',<br/>}</pre>
<p>You should be aware that the file resource type requires an absolute path and filename. If a relative path is used within the title, then Puppet will produce an error:</p>
<pre>file { '../demo.txt':<br/>  ensure =&gt; file,<br/>}</pre>
<pre><strong>puppet apply file_error.pp</strong><br/><strong>Notice: Compiled catalog for puppetmaster.demo.example42.com in environment production in 0.09 seconds</strong><br/><strong>Error: Parameter path failed on File[../demo.txt]: File paths must be fully qualified, not '../demo.txt' at /root/file_error.pp:1</strong></pre>
<p>The next type that you already know is <kbd>package</kbd>, and its typical usage is quite intuitive. Make sure that packages are either installed or removed. A notable use case that you have not yet seen is to use the basic package manager instead of <kbd>apt</kbd> or <kbd>yum/zypper</kbd>. This is useful if the package is not available from a repository:</p>
<pre>package { 'haproxy':<br/>  ensure   =&gt; present,<br/>  provider =&gt; 'dpkg',<br/>  source   =&gt; '/opt/packages/haproxy-1.5.1_amd64.dpkg',<br/>}</pre>
<p>Your mileage usually increases if you make the effort of setting up a simple repository instead, so that the main package manager can be used after all.</p>
<p>Last but not least, there is a <kbd>service</kbd> type, the most important attributes of which you already know. It's worth pointing out that it can serve as a simple shortcut in cases where you don't wish to add a fully-fledged <kbd>init</kbd> script or something similar. With enough information, the <kbd>base</kbd> provider for the <kbd>service</kbd> type will manage simple background processes for you:</p>
<pre>service { 'count-logins':<br/>  provider    =&gt; 'base',<br/>  ensure      =&gt; 'running',<br/>  enable      =&gt; true,<br/>  binary      =&gt; '/usr/local/bin/cnt-logins',<br/>  start       =&gt; '/usr/local/bin/cnt-logins –daemonize',<br/>  has_status  =&gt; true,<br/>  has_restart =&gt; true,<br/>  subscribe   =&gt; File['/usr/local/bin/cnt-logins'],<br/>}</pre>
<p>Puppet will not only restart the script if it is not running for some reason, but will also restart it whenever the content of the referenced configuration file changes.<br/>
This only works if Puppet manages the file content and all changes propagate through Puppet only.</p>
<div class="packt_infobox">If Puppet changes any other property of the script file (for example, the file mode), that too will lead to a restart of the process.</div>
<p>Let's take a look at some other types you will probably need.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The user and group types</h1>
                </header>
            
            <article>
                
<p>Especially in the absence of central registries, such as LDAP, it is useful to be able to manage user accounts on each of your machines. There are providers for all supported platforms; however, the available attributes vary. On Linux, the <kbd>useradd</kbd> provider is the most common. It allows the management of all fields in <kbd>/etc/passwd</kbd>, such as <kbd>uid</kbd> and <kbd>shell</kbd>, and also group memberships:</p>
<pre>group { 'proxy-admins':<br/>  ensure     =&gt; present,<br/>  gid        =&gt; 4002,<br/>}<br/>user { 'john':<br/>  ensure     =&gt; present,<br/>  uid        =&gt; 2014,<br/>  home       =&gt; '/home/john',<br/>  managehome =&gt; true, # &lt;- adds -m to useradd<br/>  gid        =&gt; 1000,<br/>  shell      =&gt; '/bin/zsh',<br/>  groups     =&gt; [ 'proxy-admins' ],<br/>}</pre>
<p>As with all resources, Puppet will not only make sure that the user and group exist, but also fix any divergent properties, such as the <kbd>home</kbd> directory.</p>
<p>Even though the user depends on the group: (because it cannot be added before the group exists), it need not be expressed in the manifest. The user automatically requires all necessary groups, similar to a file auto-requiring its parent directory.</p>
<div class="packt_infobox">Puppet will also happily manage your LDAP user accounts.</div>
<p>It was mentioned earlier that there are different attributes available, depending on the operating system. Linux (and the <kbd>useradd</kbd> provider) support setting a password, whereas on HP-UX (using the <kbd>hp-ux</kbd> provider), the user password cannot be set via Puppet.</p>
<p>In this case, Puppet will only show a warning saying that the user resource type is making use of an unsupported attribute, and will continue managing all other attributes. In other words, using an unsupported attribute in your Puppet DSL code will not break your Puppet run.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The exec resource type</h1>
                </header>
            
            <article>
                
<p>There is one oddball resource type in the Puppet core. Remember our earlier assertion that Puppet is not a specialized scripting engine, but a tool that allows you to model part of your system state in a compelling DSL, and which is capable of altering your system to meet the defined goal. This is why you declare <kbd>user</kbd> and <kbd>group</kbd>, instead of invoking <kbd>groupadd</kbd> and <kbd>useradd</kbd> in order. You can do this because Puppet comes with support to manage such entities. This is vastly beneficial because Puppet also knows that, on different platforms, other commands are used for account management, and that the arguments can be subtly different on some systems.</p>
<p>Of course, Puppet does not have knowledge of all the conceivable particulars of any supported system. Say that you wish to manage an OpenAFS file server. There are no specific resource types to aid you with this. The ideal solution is to exploit Puppet's plugin system and to write your own types and providers so that your manifests can just reflect the AFS-specific configuration. This is not simple, though, and also not worthwhile in cases where you only need Puppet to invoke some exotic commands from very few places in your manifest.</p>
<p>For such cases, Puppet ships with the <kbd>exec</kbd> resource type, which allows the execution of custom commands in lieu of an abstract sync action.</p>
<p>For example, it can be used to unpack a tar ball in the absence of a proper package:</p>
<pre>exec { 'tar cjf /opt/packages/homebrewn-3.2.tar.bz2':<br/>  cwd     =&gt; '/opt',<br/>  path    =&gt; '/bin:/usr/bin',<br/>  creates =&gt; '/opt/homebrewn-3.2',<br/>}</pre>
<p>The <kbd>creates</kbd> parameter is important for Puppet to tell whether the command needs running. Once the specified path exists, the resource counts as synchronized. For commands that do not create a telltale file or directory, there are the alternative parameters, <kbd>onlyif</kbd> and <kbd>unless</kbd>, to allow Puppet to query the sync state:</p>
<pre>exec { 'perl -MCPAN -e "install YAML"':<br/>  path   =&gt; '/bin:/usr/bin',<br/>  unless =&gt; 'cpan -l | grep -qP ^YAML\\b',<br/>}</pre>
<p>The query command's exit code determines the state. In the case of <kbd>unless</kbd>, the <kbd>exec</kbd> command runs if the query fails. This is how the <kbd>exec</kbd> type maintains idempotency. Puppet does this automatically for most resource types, but this is not possible for <kbd>exec</kbd> because synchronization is defined so arbitrarily. It becomes your responsibility as the user to define the appropriate queries per resource.</p>
<p>Finally, the <kbd>exec</kbd> type resources are the second notable case of receivers for events using <kbd>notify</kbd> and <kbd>subscribe</kbd>:</p>
<pre>exec { 'apt-get update':<br/>  path        =&gt; '/bin:/usr/bin',<br/>  subscribe   =&gt; File['/etc/apt/sources.list.d/jenkins.list'],<br/>  refreshonly =&gt; true,<br/>}</pre>
<p>You can even chain multiple <kbd>exec</kbd> resources in this fashion so that each invocation triggers the next one. However, this is bad practice, and degrades Puppet to a (rather flawed) scripting engine. The <kbd>exec</kbd> resources should be avoided in favor of regular resources whenever possible. Some resource types that are not part of the core are available as plugins from the Puppet Forge. You will learn more about this topic in <a href="3217a4c2-135e-46b4-bcf2-eef9ddce9991.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>Combining Classes, Configuration Files, and Extensions into Modules</em>.</p>
<p>Since <kbd>exec</kbd> resources can be used to perform virtually <em>any</em> operation, they are sometimes abused to stand in for more proper resource types. This is a typical antipattern in Puppet manifests. It is safer to regard <kbd>exec</kbd> resources as the last resort or emergency exit that is only to be used if all other alternatives have been exhausted.</p>
<p>Ideally, your <kbd>exec</kbd> resource types are built as one-time only commands.</p>
<div class="packt_tip">All Puppet installations have the type documentation built into the code, which is printable on the command line by using the puppet describe command:<br/>
<strong><kbd>puppet describe &lt;type&gt; [-s]</kbd><br/></strong>In case you are unsure whether a type exists, you can tell puppet describe to return a full list of all available resource types:<br/>
<kbd><strong>puppet describe --list</strong></kbd></div>
<p>Let's briefly discuss two more types that are supported out of the box. They allow the management of cron jobs, mounted partitions, and shares respectively, which are all frequent requirements in server operations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The cron resource type</h1>
                </header>
            
            <article>
                
<p>A cron job mainly consists of a command and the recurring time and date at which to run the command. Puppet models the command and each date particle as a property of a resource with the <kbd>cron</kbd> type:</p>
<pre>cron { 'clean-files':<br/>  ensure      =&gt; present,<br/>  user        =&gt; 'root',<br/>  command     =&gt; '/usr/local/bin/clean-files',<br/>  minute      =&gt; '1',<br/>  hour        =&gt; '3',<br/>  weekday     =&gt; [ '2', '6' ],<br/>  environment =&gt; 'MAILTO=felix@example.net',<br/>}</pre>
<p>The <kbd>environment</kbd> property allows you to specify one or more variable bindings for <kbd>cron</kbd> to add to the job.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The mount resource type</h1>
                </header>
            
            <article>
                
<p>Finally, Puppet will manage all aspects of mountable filesystems for you, including their basic attributes, such as the source device and mount point, the mount options, and the current state. A line from the <kbd>fstab</kbd> file translates quite literally to a Puppet manifest:</p>
<pre>mount { '/media/gluster-data':<br/>  ensure  =&gt; 'mounted',<br/>  device  =&gt; 'gluster01:/data',<br/>  fstype  =&gt; 'glusterfs',<br/>  options =&gt; 'defaults,_netdev',<br/>  dump    =&gt; 0,<br/>  pass    =&gt; 0,<br/>}</pre>
<p>For this resource, Puppet will make sure that the filesystem is indeed mounted after the run. Ensuring the <kbd>unmounted</kbd> state is also possible, of course; Puppet can also just make sure the entry is <kbd>present</kbd> in the <kbd>fstab</kbd> file, or <kbd>absent</kbd> from the system altogether.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>After installing Puppet on your system, you can use it by writing and applying manifests. These manifests are written in Puppet's DSL and contain descriptions of the desired state of your system. Even though they resemble scripts, they should not be considered as such. For one thing, they consist of resources instead of commands. These resources are generally not evaluated in the order in which they have been written. An explicit ordering should be defined through the <kbd>require</kbd> and <kbd>before</kbd> metaparameters instead.</p>
<p>Each resource has a couple of attributes: <kbd>parameters</kbd> and <kbd>properties</kbd>. Each property is evaluated in its own right; Puppet detects whether a change to the system is necessary to get any property into the state that is defined in the manifest. It will also perform such changes. This is referred to as synchronizing a resource or property.</p>
<p>The ordering parameters, <kbd>require</kbd> and <kbd>before</kbd>, are of further importance because they establish dependency of one resource on one or more others. This allows Puppet to skip parts of the catalog if an important resource cannot be synchronized. Circular dependencies must be avoided.</p>
<p>Each resource in the manifest has a resource type that describes the nature of the system entity that is being managed. Some of the types that are used most frequently are file, package, and service. Puppet comes with many types for convenient system management, and many plugins are available to add even more. Some tasks require the use of <kbd>exec</kbd> resources, but this should be done sparingly.</p>
<p>In <a href="7cafeeab-0e5c-4848-9eb0-1bae38ed3525.xhtml">Chapter 2</a>, <em>Puppet Server and Agents</em>, we will introduce the master/agent setup.</p>


            </article>

            
        </section>
    </body></html>