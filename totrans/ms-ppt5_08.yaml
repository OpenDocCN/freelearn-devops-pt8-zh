- en: Extending Puppet with Tasks and Discovery
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过任务和发现扩展 Puppet
- en: 'Since the launch of Puppet 5, three new services have been announced by Puppet:
    Tasks, Discovery, and Pipelines. Puppet Tasks provides us an imperative solution
    for automating ad hoc tasks. Puppet Discovery allows us to discover the state
    of infrastructure. Puppet Pipelines, which will be discussed briefly in the next
    chapter, covers application-level CI/CD.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 Puppet 5 发布以来，Puppet 宣布了三项新服务：任务、发现和流水线。Puppet 任务为我们提供了一个命令式的解决方案，用于自动化临时任务。Puppet
    发现使我们能够发现基础设施的状态。Puppet 流水线将在下一章简要讨论，涵盖应用程序级别的 CI/CD。
- en: In this chapter, we'll investigate and use Puppet Tasks to help manage a web
    server. We'll walk through some best practices and appropriate times for using
    Puppet Tasks. We'll then dive into Puppet Discovery and inspect our infrastructure.
    We'll use Puppet Discovery to make intelligent decisions on what to automate in
    our infrastructure.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究并使用 Puppet 任务来帮助管理 Web 服务器。我们将介绍一些最佳实践，并探讨使用 Puppet 任务的合适时机。接下来，我们将深入了解
    Puppet 发现并检查我们的基础设施。我们将使用 Puppet 发现来做出智能决策，决定在基础设施中自动化哪些内容。
- en: Puppet Tasks
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Puppet 任务
- en: 'Puppet is designed to provide continual enforcement of an end-state on nodes
    in an infrastructure. While Puppet can cover most infrastructure tasks, some things
    are better left to ad hoc tasks. Puppet Tasks are on-demand actions that can be
    run on nodes and containers. You write tasks in a similar way to scripts, and
    they can be written in any language that''s available on the target node.  When
    deciding on the right tool for the job, between a task or a Puppet manifest, I
    stick to a simple thought process: is this something I want permanently, or a
    single one-off action?'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 旨在在基础设施中的节点上持续执行最终状态的强制执行。虽然 Puppet 可以涵盖大多数基础设施任务，但有些任务最好留给临时任务来处理。Puppet
    任务是可以在节点和容器上按需运行的操作。你可以像编写脚本一样编写任务，并且它们可以用目标节点上任何可用的语言编写。在选择任务还是 Puppet 清单时，我有一个简单的思考过程：这是我希望永久存在的东西，还是一个单次执行的操作？
- en: Let's think about some things in a normal workplace that would be permanent,
    or stateful. The physical address of where I work and the building, rooms, and
    furniture are examples of physical things I'd want permanently enforced. Things
    like weekly meetings or the daily scrum would also be something to continually
    enforce, as a business rule. All of these things have components, from the brick
    and mortar to the time and place of the weekly scrum. If we could manage the real
    world with our IT tools, Puppet would be the perfect tool to describe our office
    and business rules, which we expect to stay constant.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一些在正常工作场所中是永久性或状态性的事物。我工作地点的物理地址、建筑物、房间和家具是我希望永久强制执行的物理事物的例子。像每周会议或每日站会也应该是持续强制执行的内容，作为业务规则。所有这些事物都有组成部分，从砖瓦到每周站会的时间和地点。如果我们能用
    IT 工具管理现实世界，Puppet 将是描述我们办公室和业务规则的完美工具，这些规则预计会保持不变。
- en: In the same context, an impromptu meeting or after-work function would consist
    of a series of tasks, performed once, but mostly in the same manner every time
    (with variables). If a customer orders something, we'd use a task to deliver the
    request. If the request was custom, we'd instead use a series of tasks to build
    the composite whole. These are the things we do consistently, but with variations
    and at unknown points in time. An external event or person drives the creation
    of this work, but we try to repeat things in an automated way to save time and
    increase consistency.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在同样的背景下，一次临时会议或下班后的活动由一系列任务组成，这些任务只执行一次，但每次大多数情况下都以相同的方式执行（带有变量）。如果客户订购某些东西，我们会使用任务来交付请求。如果请求是定制的，我们将使用一系列任务来构建整个复合体。这些是我们一贯做的事情，但会有变化，并且发生在不确定的时间点。一个外部事件或人推动了这项工作的创建，但我们尝试通过自动化的方式来重复这些操作，以节省时间并提高一致性。
- en: The chief difference between Tasks and Puppet for management is imperative and
    declarative models. In this section, we'll be setting up Bolt (the technology
    that powers tasks), building a web server with Puppet, and then deploying our
    websites on demand with Bolt.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 任务和 Puppet 在管理上的主要区别在于命令式和声明式模型。在本节中，我们将设置 Bolt（驱动任务的技术），使用 Puppet 构建一个 Web
    服务器，然后通过 Bolt 根据需求部署我们的网站。
- en: Bolt
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bolt
- en: Bolt is the primary driver for Puppet Tasks, and is an open source project written
    in Ruby for remotely executing scripts of any language, on systems over SSH and
    WinRM. You can write your tasks in any language supported by the end host, such
    as PowerShell and Bash on Windows and Linux, or Ruby and Python if interpreters
    are available. Bolt was designed as an agentless system to distribute scripts
    and execute remote commands over standard protocols, using SSH public key encryption
    or a username and password. There is also a built-in command-line tool for building
    inventory files over PuppetDB queries. Bolt also supports task plans, packaged
    in forge modules, which chain multiple tasks together, providing more complex
    tasks.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Bolt是Puppet任务的主要驱动程序，它是一个用Ruby编写的开源项目，用于通过SSH和WinRM远程执行任何语言的脚本。你可以用任何受目标主机支持的语言编写任务，例如在Windows和Linux上使用PowerShell和Bash，或者如果有解释器的话，可以使用Ruby和Python。Bolt被设计为一个无代理的系统，通过标准协议分发脚本并执行远程命令，使用SSH公钥加密或用户名和密码。此外，还有一个内置的命令行工具，用于通过PuppetDB查询构建库存文件。Bolt还支持任务计划，打包在forge模块中，将多个任务连接在一起，提供更复杂的任务。
- en: Installing Bolt
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Bolt
- en: 'Bolt can be installed via a number of methods, all described at [https://puppet.com/docs/bolt/0.x/bolt_installing.html](https://puppet.com/docs/bolt/0.x/bolt_installing.html):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过多种方法安装Bolt，所有方法的描述都可以在[https://puppet.com/docs/bolt/0.x/bolt_installing.html](https://puppet.com/docs/bolt/0.x/bolt_installing.html)中找到：
- en: A downloadable package from [http://downloads.puppet.com/](http://downloads.puppet.com/)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从[http://downloads.puppet.com/](http://downloads.puppet.com/)下载的软件包
- en: A public Chocolatey package
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个公共的Chocolatey软件包
- en: OSX Homebrew installation
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OSX Homebrew安装
- en: Linux native package repositories
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux本地软件包仓库
- en: Rubygems
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rubygems
- en: Bolt works remotely over standard connection protocols. Try installing it and
    using it on your workstation, instead of the Puppet Master, during this lesson.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Bolt通过标准连接协议远程工作。尝试在本课中将其安装并在工作站上使用，而不是在Puppet Master上使用。
- en: 'On my MacBook, I''ll install Bolt using Homebrew:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的MacBook上，我将使用Homebrew安装Bolt：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'I''ll then close my Terminal, and reopen it and verify that the `bolt` command
    is in my path:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我会关闭我的终端，重新打开并验证`bolt`命令是否在我的路径中：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Managing nodes
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理节点
- en: 'In Bolt, we have to explicitly list the nodes that we want to manage. We can
    do this via the `--nodes` command flag, or by providing an inventory file. An
    inventory file is a YAML file that contains groups of nodes, with configuration
    options already set. By default, an `inventory` file placed at `~/.puppetlabs/bolt/inventory.yaml`
    will be used by Bolt. For this section, we''ll only be targeting our Puppet Master,
    so I''ll ensure that it is in the `inventory` file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bolt中，我们必须明确列出要管理的节点。我们可以通过`--nodes`命令标志来实现，或者提供一个库存文件。库存文件是一个包含节点组和已经设置好的配置选项的YAML文件。默认情况下，Bolt会使用放在`~/.puppetlabs/bolt/inventory.yaml`的`inventory`文件。在这一部分中，我们将只针对Puppet
    Master，因此我会确保它出现在`inventory`文件中：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Before I can run Bolt to that server, I''m going to need to ensure that my
    SSH key is available as the root user on that system. I''ll use the `ssh-copy-id`
    utility to transfer this from my UNIX-based system to the root user:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我可以将Bolt运行到服务器之前，我需要确保我的SSH密钥作为root用户在该系统上可用。我将使用`ssh-copy-id`工具将其从我的UNIX系统传输到root用户：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Ad hoc commands
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 临时命令
- en: 'At the very basic core of Puppet Bolt, we issue remote commands, send scripts,
    and run scripts. Bolt provides three simple commands to do just that: `bolt command
    run`, `bolt file upload`, and `bolt script run`. To test our SSH key from earlier,
    let''s run a simple command using `bolt command run`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在Puppet Bolt的核心功能中，我们执行远程命令、发送脚本并运行脚本。Bolt提供了三个简单的命令来实现这一点：`bolt command run`、`bolt
    file upload`和`bolt script run`。为了测试我们之前的SSH密钥，让我们使用`bolt command run`运行一个简单的命令：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For simple one-off tasks, running the `bolt` command can be a great way to
    inspect a system. When we have a larger list of instructions to send, we''ll want
    to write a script and run it remotely. Here is a simple script that returns users
    and all open ports:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的临时任务，运行`bolt`命令是检查系统的好方法。当我们需要发送更多的指令时，我们就需要编写脚本并远程运行它。这里是一个简单的脚本，返回用户和所有开放端口：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we run this script via `bolt script run`, we get the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过`bolt script run`运行这个脚本时，我们会看到如下输出：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, if I wanted to make this script available on the Puppet Server for
    a local user, I could send it over with `bolt script upload`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我想将这个脚本提供给Puppet服务器上的本地用户，我可以通过`bolt script upload`将其发送过去：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Bolt tasks
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bolt任务
- en: Bolt tasks allow us to write and extend a script with additional metadata parameters.
    These parameters can be provided on execution by environment variables, PowerShell
    named arguments, or as JSON input in more advanced cases. Bolt tasks are similar
    to resources in Puppet, allowing us to parameterize an action and use a command
    in a repeatable way. We'll be writing a simple task that allows us to inspect
    certain log files on the Puppet Master by name. This task will be part of a logs
    module, named `puppetserver`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Bolt 任务允许我们编写并扩展脚本，加入额外的元数据参数。这些参数可以通过环境变量、PowerShell 命名参数或在更复杂的情况下作为 JSON 输入提供。Bolt
    任务类似于 Puppet 中的资源，允许我们参数化某个操作，并以可重复的方式使用该命令。我们将编写一个简单的任务，允许我们通过名称检查 Puppet Master
    上的特定日志文件。这个任务将是名为 `puppetserver` 的日志模块的一部分。
- en: task.json
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: task.json
- en: 'This JSON parameter file is an optional component for tasks and allows the
    passing of parameters as environment variables to our scripts. We can use this
    file to also limit user input as well, leaving a small number of options available
    for our users if necessary. In the following example, our script will accept a
    log and store the parameter. The log parameter will only allow three choices,
    which determine where to find the log file the user is searching for. The store
    parameter will be off by default, but will allow us to aggregate logs for the
    plan we''ll build in the next section:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 JSON 参数文件是任务的可选组件，允许将参数作为环境变量传递给我们的脚本。我们也可以使用这个文件限制用户输入，如果需要，可以仅提供少数几个选项。在下面的示例中，我们的脚本将接受一个日志并存储该参数。日志参数将只允许三种选择，用于确定用户要查找的日志文件位置。store
    参数默认关闭，但将允许我们聚合日志，用于我们将在下一节中构建的计划：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The parameters use the same data types as Puppet. You can use any data type
    available to Puppet as a data type for Puppet tasks.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 参数使用与 Puppet 相同的数据类型。你可以使用 Puppet 支持的任何数据类型作为 Puppet 任务的数据类型。
- en: Task
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务
- en: Our task will be a simple shell script that reads a named file based on our
    input parameters, makes a decision on whether or not to store the output, and
    then returns the output as JSON to Bolt. It's important that our return comes
    back as JSON so that it can be picked up by Bolt. In more complex use cases, we
    could even use this JSON to pass key value pairs to a follow-on task in plans,
    which we'll cover in the next section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务将是一个简单的 shell 脚本，基于我们的输入参数读取一个指定的文件，决定是否存储输出，然后将输出以 JSON 格式返回给 Bolt。返回为
    JSON 格式非常重要，这样它才能被 Bolt 接收。在更复杂的用例中，我们甚至可以使用这个 JSON 将键值对传递给计划中的后续任务，这部分将在下一节中讲解。
- en: A task can be written in any language available to the system. This example
    will use Bash, as nearly every administrator has worked with it. If you haven't
    tried writing scripts in Python, Ruby, Golang, or any other scripting language
    outside of shell, give it a shot. These tasks actually become easier to write
    in these more advanced languages.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 任务可以用系统支持的任何语言编写。这个示例将使用 Bash，因为几乎每个管理员都使用过它。如果你还没有尝试过用 Python、Ruby、Golang 或任何其他脚本语言（除了
    shell）写脚本，试试看。这些任务在更高级的语言中实际上更容易编写。
- en: 'There are a few things worth noting in our shell script:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 shell 脚本中有几个需要注意的事项：
- en: Values returned from our JSON parameters file become environment variables,
    and start with `PT_`. Our script refers to `$PT_log and $PT_store` to check the
    values that will be sent over the command line.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从我们的 JSON 参数文件返回的值会成为环境变量，并以 `PT_` 开头。我们的脚本通过 `$PT_log` 和 `$PT_store` 来检查通过命令行传递的值。
- en: We're using a case statement to map `$PT_log` to a log file. This use is similar
    to a selector statement in Puppet.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了一个 case 语句将 `$PT_log` 映射到一个日志文件。这种用法类似于 Puppet 中的选择语句。
- en: If `$PT_store` is true, we'll build a log file that can be appended to.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `$PT_store` 为真，我们将生成一个可以追加的日志文件。
- en: 'The log is printed out in the final line as JSON so that Puppet Tasks knows
    it is a valid output to the command line:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一行的日志以 JSON 格式打印出来，以便 Puppet Tasks 知道它是一个有效的命令行输出：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s double check that the files we''ve written are in the proper location
    before we run our command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行命令之前，让我们再检查一下我们写的文件是否在正确的位置：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can then run our command on the command line. We''ve added some parameters
    that help along the way:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在命令行上运行我们的命令。我们添加了一些有助于执行的参数：
- en: '`nodes`: This determines which nodes based on our inventory file to run on.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nodes`：这决定了基于我们的清单文件，在哪些节点上执行任务。'
- en: '`modulepath`: Where to look for modules. Because we''re working on this module
    directly, we''ve just set the modulepath to the directory above the module.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modulepath`：查找模块的路径。由于我们直接在这个模块上工作，因此我们将 `modulepath` 设置为模块上级目录。'
- en: '`--no-host-key-check`: You may not need this, but to ease troubleshooting of
    SSH in this section, we''ll use this flag.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--no-host-key-check`：你可能不需要这个标志，但为了简化本节中 SSH 故障排除的过程，我们将使用这个标志。'
- en: '`log=puppetdb`: This is the parameter which we wrote in our JSON file. It will
    be transformed into `$PT_log` and used in our shell script:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log=puppetdb`：这是我们在 JSON 文件中写入的参数。它将被转换为 `$PT_log` 并用于我们的 shell 脚本：'
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Try the command out for yourself. It will return a different log file for each
    command, and if you pass `store=true`, it will even start appending this log to
    a file in `/tmp` named `puppetlog.log`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试自己运行这个命令。它会为每个命令返回不同的日志文件，如果你传递 `store=true`，它甚至会开始将这个日志附加到 `/tmp` 中名为 `puppetlog.log`
    的文件里。
- en: Bolt plans
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bolt 计划
- en: If Puppet tasks are our imperative resources, Puppet plans are our Puppet manifests.
    Here, we combine multiple tasks and commands to form an orchestrated plan. These
    plans are written in the same DSL as Puppet code, although at the time of writing
    this book, only puppet functions can be used, and not many objects like resources
    or class are included.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Puppet 任务是我们的命令资源，那么 Puppet 计划就是我们的 Puppet 清单。在这里，我们结合多个任务和命令来形成一个协调的计划。这些计划采用与
    Puppet 代码相同的 DSL 编写，尽管在写这本书时，只能使用 puppet 函数，而且没有包含像资源或类这样的对象。
- en: 'In our sample plan, we''re going to introduce two parameters:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例计划中，我们将引入两个参数：
- en: '`$enterprise`: This is used to determine if `pe-console-services` should be
    checked in the plan (it is possible to use facts from the target or PuppetDB as
    well)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$enterprise`：这个参数用于确定是否在计划中检查 `pe-console-services`（也可以使用目标或 PuppetDB 中的 facts）。'
- en: '`$servers`: This is a list of servers that''s passed as a comma-separated list'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$servers`：这是一个服务器列表，作为一个以逗号分隔的列表传递。'
- en: 'Our task will clean up any existing stored logs and build a fresh set. This
    script will run the log scraper task we built in the last section for each section,
    and aggregate all the logs together. Enterprise, as an optional flag, will determine
    if `pe-console-services.log` is included as well. After we''ve built the log,
    we''ll simply read the log file and ensure that it is returned to the command
    line with the `return` function. Finally, we''ll clean up after ourselves and
    clean the aggregated log we just built in `/tmp`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务将清理现有的日志并生成一组新的日志。这个脚本会为每个部分运行我们在上一节中构建的日志抓取任务，并将所有日志聚合在一起。Enterprise 作为一个可选标志，将决定是否也包含
    `pe-console-services.log`。在我们构建完日志之后，我们将简单地读取日志文件，并确保它通过 `return` 函数返回到命令行。最后，我们会清理我们自己，并清理我们刚刚在
    `/tmp` 中生成的聚合日志：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once we''ve built our plan, we can run `bolt plan run`, passing our `modulepath`
    and parameters:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们构建好计划，就可以运行 `bolt plan run`，并传入我们的 `modulepath` 和参数：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You may notice that the log comes back as a big JSON object, with no line breaks
    represented. If you want to view this aggregated log file for yourself, try running
    the following command and inspecting the new `puppetlog.log` file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到日志以一个大的 JSON 对象的形式返回，且没有显示行间断。如果你想查看这个聚合的日志文件，可以尝试运行以下命令并检查新的 `puppetlog.log`
    文件：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Puppet Enterprise Task Management
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Puppet Enterprise 任务管理
- en: Bolt is a fully-featured open source product. It does not need Puppet Enterprise
    to work well in your environment. That being said, the console for Puppet Enterprise
    ties in very nicely with Bolt. There is a single tasks page on the left-hand side
    of the console that will take you to the main tasks page. Once you enter, you'll
    be greeted with the Run a task page, which provides you with a few convenient
    features if you're sharing yours tasks in your organization.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Bolt 是一个功能齐全的开源产品。它在你的环境中运行良好，并不需要 Puppet Enterprise。话虽如此，Puppet Enterprise
    的控制台与 Bolt 非常契合。在控制台的左侧有一个任务页面，点击后将带你进入主要的任务页面。一旦进入，你将看到“运行任务”页面，如果你在组织内共享任务，这些页面会为你提供一些便利的功能。
- en: This section is only relevant for Puppet Enterprise users. This module will
    need to be in `/etc/puppetlabs/code/environments/production/modules` via r10k
    or manual placement to be read by the Puppet Enterprise console.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 本节仅对 Puppet Enterprise 用户相关。此模块需要通过 r10k 或手动放置到 `/etc/puppetlabs/code/environments/production/modules`
    目录下，才能被 Puppet Enterprise 控制台读取。
- en: 'The first main feature is the ability to directly view the supporting JSON
    parameters file before running the task. Notice that our description and optional
    parameters are represented in tasks when we add `logs::puppetserver`, making documentation
    for other users convenient:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个主要特性是能够在运行任务之前直接查看支持的 JSON 参数文件。请注意，当我们添加`logs::puppetserver`时，描述和可选参数会在任务中呈现，这样能方便其他用户查看文档：
- en: '![](img/42da619d-e125-47ff-b7c4-e9c5d9fa40b2.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/42da619d-e125-47ff-b7c4-e9c5d9fa40b2.png)'
- en: 'Every parameter is also represented as a drop-down menu. Because we selected
    Enum[console,puppetdb,puppetserver] as our type in `puppetserver.json`, those
    are the only options available to the users in the console. Store is also a true
    or false only value drop-down, thanks to our Boolean selection:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 每个参数也以下拉菜单的形式呈现。由于我们在`puppetserver.json`中选择了 Enum[console,puppetdb,puppetserver]
    作为我们的类型，因此在控制台中，用户只能选择这些选项。Store 也仅是一个真假值的下拉选项，这要归功于我们的布尔选择：
- en: '![](img/f88b2203-b70f-4c09-a399-1b67f26f6b04.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f88b2203-b70f-4c09-a399-1b67f26f6b04.png)'
- en: 'Once we run the job, we''ll get back a cleaned up version of the logs that
    we''ve selected. If you''re in a large organization, you could put this task into
    the inventory and allow administrators to remotely view log files on demand without
    ever needing to log into the server or manage the code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行任务，我们将得到一个清理过的日志版本，如果您所在的组织较大，您可以将该任务加入库存，并允许管理员远程查看日志文件，而无需登录到服务器或管理代码：
- en: '![](img/cff42a38-a4e4-4dff-94cc-9d30ddd6a56f.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cff42a38-a4e4-4dff-94cc-9d30ddd6a56f.png)'
- en: This task was meant to be a simple example. With complicated tasks and plans,
    you can orchestrate automation of any kind and in any language across your infrastructure,
    using just SSH or WinRM. Our tasks have the ability to import and export JSON
    variables, allowing us to build more complex dependencies between tasks. Puppet
    Tasks is still relatively new to the Puppet ecosystem, but is a promising new
    addition, allowing for the rapid sharing of administration automation tasks within
    an organization.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务本意是一个简单的示例。对于复杂的任务和计划，您可以在基础设施中使用 SSH 或 WinRM 自动化执行任何类型的操作，且支持任何语言。我们的任务具有导入和导出
    JSON 变量的能力，这使得我们能够在任务之间构建更复杂的依赖关系。Puppet Tasks 对 Puppet 生态系统来说仍然相对较新，但它是一个有前景的新功能，允许在组织内部快速共享管理自动化任务。
- en: Puppet Discovery
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Puppet Discovery
- en: Puppet Discovery is a new product by Puppet. Puppet Discovery is a standalone
    containerized application built to discover information about containers and virtual
    machines in real-time. This platform is designed to have an inventory of all IT
    resources, discover details about each resource, and take action on those machines.
    Although still in the early phases of development, I expect to see tighter integration
    between Discovery, Puppet Tasks, and the greater Puppet ecosystem.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet Discovery 是 Puppet 推出的新产品。Puppet Discovery 是一个独立的容器化应用程序，旨在实时发现关于容器和虚拟机的信息。该平台的设计目标是拥有所有
    IT 资源的库存，发现每个资源的详细信息，并对这些机器采取行动。尽管仍处于开发初期阶段，但我预计 Discovery、Puppet Tasks 以及更广泛的
    Puppet 生态系统之间会有更紧密的集成。
- en: Puppet Discovery is generally safe to install and use to inspect a production-level
    system. Puppet Discovery does do an active scan of all sources, and may trigger
    security warnings in your organization. Make sure that you coordinate with a security
    team if you decide to use Puppet Discovery against corporate resources.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet Discovery 一般是安全的，可以用于检查生产级别的系统。Puppet Discovery 会对所有来源进行主动扫描，可能会在您的组织中触发安全警告。如果您决定在公司资源上使用
    Puppet Discovery，请确保与安全团队协调。
- en: In this section, we'll be installing Puppet Discovery and viewing what is available
    to us. We'll start by installing the system, followed by adding an IP CIDR block
    of our infrastructure machine, and then connect to our machines using credentials.
    Then we'll explore Puppet Discovery to view details of individual nodes and packages
    across our infrastructure.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将安装 Puppet Discovery，并查看我们可以使用的功能。我们将首先安装系统，然后添加我们基础设施机器的 IP CIDR 块，接着使用凭据连接到机器。然后，我们将探索
    Puppet Discovery，查看我们基础设施中各个节点和包的详细信息。
- en: This may trigger security alerts in production if security isn't notified.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提前通知安全团队，这可能会在生产环境中触发安全警报。
- en: Installing Discovery
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Puppet Discovery
- en: Puppet Discovery is not a **Free and Open Source Software** (**FOSS**). We'll
    need a license from Puppet, which can be obtained at [licenses.puppet.com](http://licenses.puppet.com/).
    Select an available Puppet Discovery license to get started and then download
    it to the target machine you'll run Puppet Discovery on. This JSON file will be
    used in the installation of our Puppet Discovery application.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet Discovery 不是**自由开源软件**（**FOSS**）。我们需要从 Puppet 获得一个许可证，可以在[licenses.puppet.com](http://licenses.puppet.com/)获取。选择一个可用的
    Puppet Discovery 许可证以开始使用，然后将其下载到你运行 Puppet Discovery 的目标机器上。此 JSON 文件将在 Puppet
    Discovery 应用程序的安装过程中使用。
- en: You'll need Docker available on the machine. In order to install Puppet Discovery,
    you'll need to have Docker on the host.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在机器上安装 Docker。为了安装 Puppet Discovery，主机上必须安装 Docker。
- en: Preparing Puppet Discovery
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备 Puppet Discovery
- en: Download Puppet Discovery for your operating system at [https://puppet.com/download-puppet-discovery](https://puppet.com/download-puppet-discovery).
    This section will help us put the binary in our path and set up Puppet Discovery
    for the first time.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://puppet.com/download-puppet-discovery](https://puppet.com/download-puppet-discovery)下载适用于你的操作系统的
    Puppet Discovery。本节将帮助我们将二进制文件放入路径中，并首次设置 Puppet Discovery。
- en: 'After we''ve downloaded Puppet Discovery, we''ll want to move the binary into
    our path. On most Unix-based operating systems, `/usr/local/bin` is in your path.
    We need to place our binary in our path, make it executable, and ensure we can
    run it as the local user:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下载 Puppet Discovery 后，我们需要将二进制文件移动到路径中。在大多数基于 Unix 的操作系统中，`/usr/local/bin` 已经包含在路径中。我们需要将二进制文件放入路径，确保它可执行，并确保我们可以作为本地用户运行它：
- en: If `/usr/local/bin` is not in your path, you can see which directories are in
    your path by using `echo $PATH` on your system. This will come back as a list
    separated by colons.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `/usr/local/bin` 不在你的路径中，你可以使用 `echo $PATH` 查看系统路径中包含的目录。返回的结果将是以冒号分隔的目录列表。
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once we''ve verified that the binary works, we''ll run `puppet-discovery start`
    to start the service. We''ll be prompted to provide a license key, read the EULA
    (which will pop up in a browser), and generate an administrative password:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦验证二进制文件工作正常，我们将运行 `puppet-discovery start` 启动服务。系统会提示我们提供许可证密钥，阅读最终用户许可协议（该协议将在浏览器中弹出）并生成管理员密码：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Once we've finished this step, Puppet Discovery will be running on port `8443`
    on our target machine in a Docker container.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成此步骤，Puppet Discovery 将在目标机器上的 `8443` 端口以 Docker 容器的形式运行。
- en: At the time of writing this book, the license prompt uses a relative path not
    an absolute path, so ensure you're running this command from somewhere you can
    find that JSON file.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，许可证提示使用的是相对路径，而不是绝对路径，因此确保你从能够找到该 JSON 文件的位置运行此命令。
- en: Managing sources
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理源
- en: Our initial login won't take us to our splash screen until we've provided a
    basic list of target machines and credentials to Puppet Discovery. Puppet Discovery
    has the ability to tie into an entire Amazon Web Services, Google Compute Platform,
    Microsoft Azure, or VMWare VSphere account and perform automatic discovery of
    available resources. We can also provide a direct list of IP addresses if no API-driven
    platform is available.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初次登录时，除非提供了目标机器的基本列表和凭证，否则不会进入欢迎界面。Puppet Discovery 能够连接到整个 Amazon Web Services、Google
    Compute Platform、Microsoft Azure 或 VMWare VSphere 帐户，并执行可用资源的自动发现。如果没有可用的 API
    驱动平台，我们也可以提供一个直接的 IP 地址列表。
- en: In this section, we'll be adding a CIDR block of IP addresses to Discovery,
    which will be available to all users regardless of platform and hypervisor.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向 Discovery 添加一个 CIDR 地址块，该地址块将对所有用户可用，无论平台和虚拟化技术如何。
- en: Adding sources by IP address
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 IP 地址添加源
- en: If you're using a cloud provider to test this setup, go ahead and use the cloud
    provider instead. The rest of this section will not be reliant on the methodology
    that we use to connect to machines.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用云服务提供商进行测试，可以直接使用云提供商的服务。此节的其余部分将不依赖于我们连接到机器的具体方法。
- en: 'During the writing of this book, several nodes have been created in my Puppet
    Infrastructure so that we can inspect them. I''ve used Vagrant and VirtualBox
    as my platform, and I will be using my local network of `10.20.1.0/24` to discover
    all of my Puppet infrastructure. When selecting the IP address you will use to
    demonstrate this section, make sure that the machine you''ve installed Docker
    on has the ability to find the nodes over the network provided:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书编写期间，我的 Puppet 基础设施中创建了多个节点，以便我们能够检查它们。我使用的是 Vagrant 和 VirtualBox 作为平台，并且我将使用我的本地网络
    `10.20.1.0/24` 来发现我所有的 Puppet 基础设施。在选择你将用来演示这一部分的 IP 地址时，确保你安装了 Docker 的机器能够在提供的网络上找到节点：
- en: '![](img/e872e04f-b7a5-42ff-8afc-b16277b84ab2.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e872e04f-b7a5-42ff-8afc-b16277b84ab2.png)'
- en: Managing credentials
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理凭证
- en: 'After our first list of nodes to discover, Puppet Discovery will automatically
    take us to a splash page, allowing us to select an authentication method. At the
    time of writing this book, three methods are available: an SSH Private Key, an
    SSH Credential, and a WinRM Credential. SSH Private Keys are generally the most
    secure method available, but if SSH keys are not available on the remote systems,
    a username and password is taken via SSH Credential for Linux or WinRM Credential
    for Windows.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们第一次列出要发现的节点后，Puppet Discovery 会自动带我们进入一个欢迎页面，让我们选择一个身份验证方法。在编写本书时，有三种方法可用：SSH
    私钥、SSH 凭证和 WinRM 凭证。SSH 私钥通常是最安全的方法，但如果远程系统上没有 SSH 密钥，则可以通过 SSH 凭证（用于 Linux）或
    WinRM 凭证（用于 Windows）输入用户名和密码。
- en: In this section, we'll be using an SSH key to provide connections to the machines
    we discovered in the previous step.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将使用 SSH 密钥提供与我们在前一步中发现的机器的连接。
- en: SSH key file
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SSH 密钥文件
- en: If you're using vagrant for testing this, rather than a cloud provider, I'm
    simply using the default insecure keys provided by vagrant. This key can always
    be found at [https://github.com/hashicorp/vagrant/tree/master/keys](https://github.com/hashicorp/vagrant/tree/master/keys).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在测试中使用 vagrant，而不是云服务提供商，我只是使用 vagrant 提供的默认不安全密钥。这个密钥可以在[https://github.com/hashicorp/vagrant/tree/master/keys](https://github.com/hashicorp/vagrant/tree/master/keys)找到。
- en: 'When adding credentials, we''re also scoping our credentials. In an SSH private
    key credential, you begin by selecting the PEM file you wish to apply from your
    local hard drive. We have three available RBAC options:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加凭证时，我们也在限定凭证的作用范围。在 SSH 私钥凭证中，你需要从本地硬盘选择你希望使用的 PEM 文件。我们有三种可用的 RBAC 选项：
- en: '**Discover data on hosts**: Should this key be used to discover information?'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在主机上发现数据**：这个密钥是否应该用于发现信息？'
- en: '**Run tasks on target hosts**: Should this key be able to run and execute tasks?'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在目标主机上运行任务**：这个密钥是否应该能够运行和执行任务？'
- en: '**Escalate privileges to root**: Should this user become the root user for
    discovery and tasks?'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提升权限至 root**：这个用户是否应该成为发现和任务的 root 用户？'
- en: 'Finally, we have a username and passphrase. Our username is the user we want
    to connect as to our remote machines. As my machines are all in vagrant, vagrant
    is also the user I''ll be connecting with. The passphrase is used to decrypt the
    SSH key, and is optional if your key doesn''t have a passphrase like mine:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个用户名和密码短语。我们的用户名是我们希望连接到远程机器的用户。由于我的机器都是在 vagrant 上，我也会使用 vagrant 作为我连接的用户。密码短语用于解密
    SSH 密钥，如果你的密钥没有密码短语，就像我的一样，则可以选择不使用：
- en: '![](img/6f84d545-1672-4fde-9f9b-8fb8a1721929.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f84d545-1672-4fde-9f9b-8fb8a1721929.png)'
- en: Once we've set up our first set of hosts and credentials, we'll be ready to
    use Puppet Discovery.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了第一组主机和凭证，我们就可以开始使用 Puppet Discovery。
- en: Discovering
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正在发现
- en: It may take some time for Puppet Discovery to collect all the information on
    your infrastructure. Additionally, browser caching can prevent population of this
    page after discovery. You may need to wait and clear your cache before you see
    any data populate on the dashboard.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet Discovery 可能需要一些时间来收集你基础设施的所有信息。此外，浏览器缓存可能会导致发现后该页面无法显示数据。你可能需要等待并清除缓存，然后才能在仪表盘上看到数据填充。
- en: 'Our splash page now displays all the hosts, packages, and containers that can
    be found against all of the sources we''ve provided and all authentication methods
    we''ve entered. This dashboard is interactive, and clicking any box will take
    you into a view, displaying all nodes that represent the information on the dashboard:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的欢迎页面现在显示了所有主机、软件包和容器，这些可以在我们提供的所有来源和所有输入的身份验证方法下找到。这个仪表盘是交互式的，点击任意框将带你进入一个视图，展示所有代表仪表盘上信息的节点：
- en: '![](img/118d339b-bffb-4597-89c5-e3e7a67965ae.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/118d339b-bffb-4597-89c5-e3e7a67965ae.png)'
- en: If you're curious about the process used to discover these nodes, you can click
    the Previous Events icon in the top-left corner of Discovery and view the log
    for the discovery.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对发现这些节点的过程感兴趣，你可以点击发现页面左上角的“历史事件”图标，查看发现日志。
- en: Viewing the Discovery
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看发现结果
- en: 'In my original sample, I provided the `10.20.1.0/24` CIDR block to scan. Puppet
    Discovery attempted a connection to the entire IP range using my provided credentials
    and returned all my nodes. You may had noticed that I have one failed node, which
    is actually my gateway and cannot be logged into using my credentials:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的原始示例中，我提供了 `10.20.1.0/24` 的 CIDR 块进行扫描。Puppet Discovery 使用我提供的凭据尝试连接整个 IP
    范围，并返回了我的所有节点。你可能已经注意到我有一个失败的节点，实际上它是我的网关，不能使用我的凭据登录：
- en: '![](img/f055ae46-3faa-458f-a6e4-7febc8905c46.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f055ae46-3faa-458f-a6e4-7febc8905c46.png)'
- en: Discovering hosts
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现主机
- en: 'Back on the dashboard, let''s go ahead and select Hosts to view a list of all
    hosts, not narrowed down to specific information. We''ll see some basic information
    displayed about all of these hosts, from the operating system to the uptime of
    the machine itself:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 返回仪表板后，我们可以选择“主机”来查看所有主机的列表，而不限定具体信息。我们将看到关于这些主机的基本信息，包括操作系统和机器本身的运行时间：
- en: '![](img/ed81f5b4-a442-4c28-bbc7-eaeaf6d0e8e3.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed81f5b4-a442-4c28-bbc7-eaeaf6d0e8e3.png)'
- en: 'If we select the hyperlink for any individual node, we''ll get a much more
    useful list of objects to work with, which provides us with detailed information
    about each host. Each tab will present us with different information:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择任何单个节点的超链接，我们将获得一个更有用的对象列表，可以帮助我们获得每个主机的详细信息。每个标签页将向我们展示不同的信息：
- en: '**Attributes**: The primary attributes used by Puppet Discovery itself, including
    hostname, DNS name, and operating system details'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性**：Puppet Discovery 本身使用的主要属性，包括主机名、DNS 名称和操作系统详细信息'
- en: '**Services**: All services on the node, and their current state (running, stopped)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**：节点上的所有服务及其当前状态（运行中，已停止）'
- en: '**Users**: All users on the system, and their home directory'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户**：系统上的所有用户及其主目录'
- en: '**Groups**: All groups available on the system'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组**：系统上所有可用的组'
- en: '**Packages**: Each package on the system, their version, and the method used
    to install them'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件包**：系统上的每个软件包、它们的版本以及安装它们所使用的方法'
- en: '**Tags**: Any tags listed by the cloud provider'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标签**：云提供商列出的任何标签'
- en: '**Containers**: Any containers running on the host system'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器**：主机系统上运行的所有容器'
- en: Discovering packages
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现软件包
- en: 'We can inspect packages as a whole in Puppet Discovery. When you select packages
    from the dashboard, you''ll be taken to a page that lists all packages, their
    version, package manager, and, most importantly, the number of instances they''re
    running on. We can use this information to see if software has been universally
    installed on our infrastructure, or to track versioning across infrastructure.
    This information is particularly helpful in security remediation when attempting
    to determine vulnerable systems in the infrastructure:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Puppet Discovery 中整体查看软件包。当你从仪表板选择软件包时，将会跳转到一个页面，列出所有软件包、它们的版本、包管理器，以及最重要的，它们运行的实例数量。我们可以利用这些信息查看软件是否已经在我们的基础设施中广泛安装，或者跟踪基础设施中的版本变化。这些信息在安全修复中尤其有用，特别是在尝试确定基础设施中存在漏洞的系统时：
- en: '![](img/19b8d522-4399-4ab0-a0ba-4b069e9a752c.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/19b8d522-4399-4ab0-a0ba-4b069e9a752c.png)'
- en: Acting
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行动作
- en: 'Puppet Discovery also allows us to take a very limited set of actions against
    our infrastructure today: installing Puppet agents and managing services. In the
    future, Puppet Discovery may include the ability to federate tasks over your infrastructure
    as well. You can access these actions by selecting the Act + icon in the top bar
    of Puppet Discovery. You''ll be redirected to the Select a task page:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet Discovery 还允许我们对基础设施执行一小部分操作：安装 Puppet 代理和管理服务。在未来，Puppet Discovery 可能还会包括通过基础设施联合执行任务的能力。你可以通过选择
    Puppet Discovery 顶部栏中的 **Act +** 图标来访问这些操作。你将被重定向到选择任务页面：
- en: '![](img/c91ac103-9e6b-482b-a52e-fa54d110359e.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c91ac103-9e6b-482b-a52e-fa54d110359e.png)'
- en: Installing agents
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装代理
- en: 'Installing agents using Puppet Discovery is one of the easiest ways to install
    Puppet agents throughout your infrastructure. You''re currently able to provide
    the following parameters and apply the tasks to a list of hosts:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Puppet Discovery 安装代理是通过基础设施安装 Puppet 代理的最简便方法之一。你现在可以提供以下参数，并将任务应用于主机列表：
- en: '`master`: Which Puppet Master to use. This is the only non-optional parameter.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`master`：要使用的 Puppet 主机。这是唯一的必选参数。'
- en: '`cacert_content`: Expected CA certificate the Master should return.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cacert_content`：主机应返回的预期 CA 证书。'
- en: '`certname`: Certname of agent.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`certname`：代理的证书名称。'
- en: '`environment`: Environment the node should run in.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`environment`：节点应运行的环境。'
- en: '`dns_alt_names`: DNS alternate names baked into the agent certificate.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dns_alt_names`：内置在代理证书中的 DNS 替代名称。'
- en: '`custom_attributes`: Any custom CSR attributes.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`custom_attributes`：任何自定义的 CSR 属性。'
- en: '`extension_request`: Any specific extension requests (such as `pp_role`) to
    add to the certificate.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extension_request`：任何特定的扩展请求（如 `pp_role`），用于添加到证书中。'
- en: Managing services
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理服务
- en: 'Managing services is also available in Puppet Discovery, and gives us only
    two fields to use: **Action** and **Name**. Use these two fields to find a service
    on the machine and start, stop, or restart any services on the node. This is a
    convenient agent-free way to do some basic management of your infrastructure before
    introducing Puppet on each node.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet Discovery 也提供了服务管理功能，并仅提供两个字段供我们使用：**操作**和**名称**。使用这两个字段可以在机器上查找服务，并启动、停止或重启节点上的任何服务。这是一种在每个节点上引入
    Puppet 之前，进行基础基础设施管理的便捷无代理方式。
- en: Uses for Discovery
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Discovery 的用途
- en: 'Discovery is still pretty new to the Puppet ecosystem. It is meant to be the
    first thing installed before determining how you want to proceed with your greater
    Puppet infrastructure rollout. That being said, Puppet Discovery has a few key
    uses:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Discovery 在 Puppet 生态系统中仍然是一个相对较新的工具。它应该是安装的第一步，帮助你决定如何继续推进更大的 Puppet 基础设施部署。也就是说，Puppet
    Discovery 有几个关键用途：
- en: Determining what you already have in your environment
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定你在环境中已经拥有的资源
- en: Ensuring that security patches are properly installed on target machines
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保目标机器正确安装了安全补丁
- en: Inspecting resources at a higher level, rather than executing on them
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在更高层次上检查资源，而不是直接对其执行操作
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a look at Puppet Tasks and Puppet Discovery. Bolt and
    Puppet Tasks allow us to perform remote ad hoc commands on target machines. We
    can parameterize these ad hoc commands and build tasks that are highly shareable
    actions in our organization. We can even chain together these tasks as Puppet
    Plans to build more complex actions that we can share across our infrastructure.
    We inspected Puppet Discovery, installed it on our local system, and viewed the
    existing infrastructure. We learned how to view and deploy agents, as well as
    manage services with Puppet Discovery.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Puppet 任务和 Puppet Discovery。Bolt 和 Puppet 任务让我们能够在目标机器上执行远程临时命令。我们可以对这些临时命令进行参数化，并构建高度可共享的任务，这些任务可以在我们组织中被广泛使用。我们甚至可以将这些任务串联成
    Puppet 计划，构建更复杂的操作，并在整个基础设施中共享。我们检查了 Puppet Discovery，安装了它并查看了现有的基础设施。我们学习了如何查看和部署代理，以及如何通过
    Puppet Discovery 管理服务。
- en: We will cover virtual and exported resources in Puppet in the next chapter.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章我们将介绍 Puppet 中的虚拟资源和导出资源。
