<html><head></head><body>
  <div id="_idContainer254">
   <h1 class="chapter-number" id="_idParaDest-185">
    <a id="_idTextAnchor230">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     11
    </span>
   </h1>
   <h1 id="_idParaDest-186">
    <a id="_idTextAnchor231">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     A Hybrid Cloud Hyperscale Use Case – Scaling a Kubernetes Workload
    </span>
   </h1>
   <p class="author-quote">
    <span class="koboSpan" id="kobo.3.1">
     “There are not more than five cardinal tastes, yet combinations of them yield more flavors than can ever be tasted.”
    </span>
   </p>
   <p class="author-quote">
    <span class="koboSpan" id="kobo.4.1">
     – Sun Tzu, The Art of War
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     In the previous chapter, we briefly explored hybrid cloud design patterns and how hybrid deployment has become a cloud trend for several organizations.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     The hybrid cloud model reflects a complex mix of services that work in tandem to satisfy different workload requirements.
    </span>
    <span class="koboSpan" id="kobo.5.3">
     When you join an OpenStack private environment, a hybrid model can be more challenging to set up due to the complexity of the dynamic mix of resources spread across private and public environments.
    </span>
    <span class="koboSpan" id="kobo.5.4">
     Building hybrid cloud networks is the first challenge that an organization would face, which requires stable, dedicated, and consistent connectivity between both public and private clouds.
    </span>
    <span class="koboSpan" id="kobo.5.5">
     Moreover, applications that can run on bare metal, virtual machines, or containers require a way to ensure configuration consistency between different cloud environments.
    </span>
    <span class="koboSpan" id="kobo.5.6">
     Several implementation challenges covered in the previous chapter still present a blocker for many organizations from enjoying the benefits of hybrid clouds.
    </span>
    <span class="koboSpan" id="kobo.5.7">
     The good
    </span>
    <a id="_idIndexMarker986">
    </a>
    <span class="koboSpan" id="kobo.6.1">
     news is that with the evolution of
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.7.1">
      application architecture patterns
     </span>
    </strong>
    <span class="koboSpan" id="kobo.8.1">
     ,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.9.1">
      containerization
     </span>
    </strong>
    <span class="koboSpan" id="kobo.10.1">
     technology has shifted how and where
    </span>
    <a id="_idIndexMarker987">
    </a>
    <span class="koboSpan" id="kobo.11.1">
     applications can be deployed.
    </span>
    <span class="koboSpan" id="kobo.11.2">
     If we are looking for application migration, cloud bursting, or running for a backup and disaster recovery strategy, adopting containerization technology is the way to go.
    </span>
    <span class="koboSpan" id="kobo.11.3">
     In this chapter, we will put into practice what was covered in the previous chapter and uncover the power of containerization in a hybrid cloud setup by covering the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.12.1">
      following topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.13.1">
      Designing hybrid cloud networking between OpenStack private cloud and a public cloud environment such
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.14.1">
       as AWS
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.15.1">
      Revisiting briefly the main concepts of Kubernetes (also referred to as K8s) to prepare for a cloud-agnostic workload model across OpenStack and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.16.1">
       AWS clouds
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.17.1">
      Exploring different approaches to implementing a hybrid
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.18.1">
       cloud setup
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.19.1">
      Deploying Kubernetes across an OpenStack private cloud and AWS
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.20.1">
       public cloud
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.21.1">
      Learning orchestration tooling for hybrid cloud deployment
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.22.1">
       using Juju
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.23.1">
      Connecting Kubernetes clusters across private and public clouds by federating its control plane and running a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.24.1">
       hybrid deployment
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-187">
    <a id="_idTextAnchor232">
    </a>
    <span class="koboSpan" id="kobo.25.1">
     Qualifying a hybrid architecture
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.26.1">
     In this section, we will explore the main motivation for adopting hybrid cloud implementation.
    </span>
    <span class="koboSpan" id="kobo.26.2">
     We will briefly illustrate how containerization helps achieve most of the hybrid
    </span>
    <a id="_idIndexMarker988">
    </a>
    <span class="koboSpan" id="kobo.27.1">
     model benefits and enables companies to move between cloud environments most efficiently.
    </span>
    <span class="koboSpan" id="kobo.27.2">
     The networking and security of connected cloud environments is another important pillar that must be looked at carefully when adopting the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.28.1">
      hybrid approach.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-188">
    <a id="_idTextAnchor233">
    </a>
    <span class="koboSpan" id="kobo.29.1">
     Adopting a cloud-agnostic stack
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.30.1">
     Being cloud-agnostic is a key motivator for several organizations that seek the best cloud experience
    </span>
    <a id="_idIndexMarker989">
    </a>
    <span class="koboSpan" id="kobo.31.1">
     when being onboarded into a cloud journey.
    </span>
    <span class="koboSpan" id="kobo.31.2">
     Thanks to the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.32.1">
      pay-as-you-go
     </span>
    </strong>
    <span class="koboSpan" id="kobo.33.1">
     model, organizations can use cloud
    </span>
    <a id="_idIndexMarker990">
    </a>
    <span class="koboSpan" id="kobo.34.1">
     resources and pay only for what they use.
    </span>
    <span class="koboSpan" id="kobo.34.2">
     However, some business workloads might require changes, and switching or expanding to another cloud provider might become necessary.
    </span>
    <span class="koboSpan" id="kobo.34.3">
     Enjoying free-pass movement between cloud providers might not sound straightforward at first.
    </span>
    <span class="koboSpan" id="kobo.34.4">
     This is due to the technology that a cloud provider offers.
    </span>
    <span class="koboSpan" id="kobo.34.5">
     A workload naturally becomes locked into more dependencies that run on a specific cloud provider.
    </span>
    <span class="koboSpan" id="kobo.34.6">
     Moving or expanding to another cloud provider can be an expensive, complex, and error-prone process.
    </span>
    <span class="koboSpan" id="kobo.34.7">
     For that reason, cloud agnosticism should be addressed in advance, starting with the workload architecture itself.
    </span>
    <span class="koboSpan" id="kobo.34.8">
     The
    </span>
    <a id="_idIndexMarker991">
    </a>
    <span class="koboSpan" id="kobo.35.1">
     best example of this is the emergent
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.36.1">
      microservices architecture
     </span>
    </strong>
    <span class="koboSpan" id="kobo.37.1">
     .
    </span>
    <span class="koboSpan" id="kobo.37.2">
     One of the main benefits of opting for a microservice design is that it breaks an application into smaller and independent modules, making it easy to test and deploy them separately without the need to rely on a specific technology stack.
    </span>
    <span class="koboSpan" id="kobo.37.3">
     Another benefit of a microservice design is the infrastructure that will run it.
    </span>
    <span class="koboSpan" id="kobo.37.4">
     That is where containerization comes into the picture.
    </span>
    <span class="koboSpan" id="kobo.37.5">
     Containers come with much more efficient compute utilization and time optimization compared to virtual machines.
    </span>
    <span class="koboSpan" id="kobo.37.6">
     That makes the microservice and containerization concepts an ideal pair to adopt cloud agnosticism.
    </span>
    <span class="koboSpan" id="kobo.37.7">
     Hence, the hybrid cloud model is much easier to implement, with some additions.
    </span>
    <span class="koboSpan" id="kobo.37.8">
     As illustrated in the following diagram, those additions
    </span>
    <a id="_idIndexMarker992">
    </a>
    <span class="koboSpan" id="kobo.38.1">
     include a container orchestration layer and automated deployment, making the cloud-agnostic model
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.39.1">
      almost complete:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer215">
     <span class="koboSpan" id="kobo.40.1">
      <img alt="Figure 11.1 – The cloud-agnostic architecture of a hybrid model" src="image/B21716_11_01.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.41.1">
     Figure 11.1 – The cloud-agnostic architecture of a hybrid model
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.42.1">
     Container orchestration engines manage the life cycle of the workloads with almost no administration need.
    </span>
    <span class="koboSpan" id="kobo.42.2">
     Most of the famous container orchestration engines such as Docker and Kubernetes are considered part of the cloud-agnostic container orchestration platform family.
    </span>
    <span class="koboSpan" id="kobo.42.3">
     While container orchestration brings more container management
    </span>
    <a id="_idIndexMarker993">
    </a>
    <span class="koboSpan" id="kobo.43.1">
     automation on its own, it would not be nearly as valuable without the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.44.1">
      Infrastructure as Code
     </span>
    </strong>
    <span class="koboSpan" id="kobo.45.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.46.1">
      IaC
     </span>
    </strong>
    <span class="koboSpan" id="kobo.47.1">
     ) concept.
    </span>
    <span class="koboSpan" id="kobo.47.2">
     Each cloud provider
    </span>
    <a id="_idIndexMarker994">
    </a>
    <span class="koboSpan" id="kobo.48.1">
     offers its
    </span>
    <a id="_idIndexMarker995">
    </a>
    <span class="koboSpan" id="kobo.49.1">
     own infrastructure templating mechanism (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.50.1">
      CloudFormation
     </span>
    </strong>
    <span class="koboSpan" id="kobo.51.1">
     for AWS,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.52.1">
      Cloud Deployment Manager
     </span>
    </strong>
    <span class="koboSpan" id="kobo.53.1">
     for Google,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.54.1">
      Deployment Manager
     </span>
    </strong>
    <span class="koboSpan" id="kobo.55.1">
     for Azure, and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.56.1">
      Heat
     </span>
    </strong>
    <span class="koboSpan" id="kobo.57.1">
     for OpenStack).
    </span>
    <span class="koboSpan" id="kobo.57.2">
     The
    </span>
    <a id="_idIndexMarker996">
    </a>
    <span class="koboSpan" id="kobo.58.1">
     vendor-specific
    </span>
    <a id="_idIndexMarker997">
    </a>
    <span class="koboSpan" id="kobo.59.1">
     syntax of each service presents a challenge as switching between cloud deployment environments becomes more complex.
    </span>
    <span class="koboSpan" id="kobo.59.2">
     The solution is obviously to take a cloud-agnostic approach by employing third-party tools that allow us to deploy the same workload infrastructure in more than one cloud environment, using the same code to abstract the infrastructure layer.
    </span>
    <span class="koboSpan" id="kobo.59.3">
     These tools became available only after the IaC concept had emerged as a DevOps principle.
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.60.1">
      Terraform
     </span>
    </strong>
    <span class="koboSpan" id="kobo.61.1">
     from Hashicorp has
    </span>
    <a id="_idIndexMarker998">
    </a>
    <span class="koboSpan" id="kobo.62.1">
     become the most commonly used cloud-agnostic tool for infrastructure management.
    </span>
    <span class="koboSpan" id="kobo.62.2">
     Today, more open source projects
    </span>
    <a id="_idIndexMarker999">
    </a>
    <span class="koboSpan" id="kobo.63.1">
     have been inspired by Terraform, and recently, the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.64.1">
      Pulumi
     </span>
    </strong>
    <span class="koboSpan" id="kobo.65.1">
     tool has appeared on the DevOps horizon.
    </span>
    <span class="koboSpan" id="kobo.65.2">
     In addition to managing infrastructure
    </span>
    <a id="_idIndexMarker1000">
    </a>
    <span class="koboSpan" id="kobo.66.1">
     using code, Pulumi allows the description of the infrastructure in any o the most popular programming languages such as Python, Java, Go, .NET,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.67.1">
      and Typescript.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.68.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.69.1">
     On August 10, 2023, Hashicorp announced that Terraform is no longer under the Mozilla Public License v2.0.
    </span>
    <span class="koboSpan" id="kobo.69.2">
     Pulumi has emerged as a successor of Terraform in the open source world and
    </span>
    <a id="_idIndexMarker1001">
    </a>
    <span class="koboSpan" id="kobo.70.1">
     has gained massive popularity in the last year.
    </span>
    <span class="koboSpan" id="kobo.70.2">
     To read more about Pulumi, check the official website
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.71.1">
      at
     </span>
    </span>
    <a href="https://www.pulumi.com/docs/get-started/">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.72.1">
       https://www.pulumi.com/docs/get-started/
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.73.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.74.1">
     To orchestrate the whole infrastructure management process, CI/CD tools define the engines to automate everything across different
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.75.1">
      cloud environments.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.76.1">
     Now that we have covered the different pieces of the hybrid cloud puzzle, we will focus on how to connect the dots between two cloud environments – in our case, OpenStack
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.77.1">
      and AWS.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-189">
    <a id="_idTextAnchor234">
    </a>
    <span class="koboSpan" id="kobo.78.1">
     Preparing for a hybrid model
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.79.1">
     Establishing a hybrid cloud architecture first requires an adequate network connection between the private and public clouds.
    </span>
    <span class="koboSpan" id="kobo.79.2">
     Such a network connection is critical to maintaining
    </span>
    <a id="_idIndexMarker1002">
    </a>
    <span class="koboSpan" id="kobo.80.1">
     business continuity.
    </span>
    <span class="koboSpan" id="kobo.80.2">
     For that reason, continuous evaluation of the connection that looks at latency, uptime, and bandwidth is a must.
    </span>
    <span class="koboSpan" id="kobo.80.3">
     Security is the other essential aspect of the hybrid connection.
    </span>
    <span class="koboSpan" id="kobo.80.4">
     Depending on the hardware and network service used for such a connection, operators should ensure encryption in transit is enabled and redundancy is considered.
    </span>
    <span class="koboSpan" id="kobo.80.5">
     Implementing a cloud hybrid connection can be greatly simplified when using cloud network-managed services.
    </span>
    <span class="koboSpan" id="kobo.80.6">
     As shown in the next simplified network diagram, an OpenStack private cloud endpoint is
    </span>
    <a id="_idIndexMarker1003">
    </a>
    <span class="koboSpan" id="kobo.81.1">
     connected to an AWS
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.82.1">
      Virtual Private Cloud
     </span>
    </strong>
    <span class="koboSpan" id="kobo.83.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.84.1">
      VPC
     </span>
    </strong>
    <span class="koboSpan" id="kobo.85.1">
     ) through two
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.86.1">
      different connections:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer216">
     <span class="koboSpan" id="kobo.87.1">
      <img alt="Figure 11.2 – A hybrid connection between the OpenStack and AWS clouds" src="image/B21716_11_02.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.88.1">
     Figure 11.2 – A hybrid connection between the OpenStack and AWS clouds
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.89.1">
     The type of connection in the upper part of the figure illustrates a site-to-site VPN connection over the internet using an IPSec tunnel.
    </span>
    <span class="koboSpan" id="kobo.89.2">
     Without exposing any resources in both cloud
    </span>
    <a id="_idIndexMarker1004">
    </a>
    <span class="koboSpan" id="kobo.90.1">
     environments (the OpenStack private network range and AWS VPC) to the public world, communication occurs in an encrypted tunnel traveling over the internet.
    </span>
    <span class="koboSpan" id="kobo.90.2">
     The implementation of a VPN connection between an OpenStack tenant environment and AWS VPC is much more automated than in a classic data center.
    </span>
    <span class="koboSpan" id="kobo.90.3">
     As we covered in
    </span>
    <a href="B21716_06.xhtml#_idTextAnchor159">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.91.1">
        Chapter 6
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.92.1">
     ,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.93.1">
      OpenStack Networking – Connectivity and Managed Service Options
     </span>
    </em>
    <span class="koboSpan" id="kobo.94.1">
     , Neutron offers a managed network service, VPNaaS, that can be deployed as a site-to-site VPN connection in minutes.
    </span>
    <span class="koboSpan" id="kobo.94.2">
     AWS offers a similar managed VPN feature as part of its VPC service that can establish a VPN connection by simply creating a VPN gateway and configuring a customer gateway (an
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.95.1">
      OpenStack endpoint).
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.96.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.97.1">
     When using a site-to-site VPN connection in AWS, two tunnels will be created for redundancy.
    </span>
    <span class="koboSpan" id="kobo.97.2">
     Each tunnel terminates in a different Availability Zone.
    </span>
    <span class="koboSpan" id="kobo.97.3">
     If one tunnel is down, traffic is automatically shifted to the second
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.98.1">
      active tunnel.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.99.1">
     VPN can be the quickest way to establish such a hybrid cloud connection.
    </span>
    <span class="koboSpan" id="kobo.99.2">
     A major pitfall of a site-to-site VPN connection linking two different locations across different regions is limited performance.
    </span>
    <span class="koboSpan" id="kobo.99.3">
     In AWS’ case, each VPN tunnel can support a bandwidth of up to 1.25 Gbps.
    </span>
    <span class="koboSpan" id="kobo.99.4">
     Other public cloud providers might offer different options.
    </span>
    <span class="koboSpan" id="kobo.99.5">
     For example, Azure allows cloud users to specify the type of VPN gateway they require, and depending on its size, the bandwidth can vary between 100 Mbps and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.100.1">
      10 Gbps.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.101.1">
     On the
    </span>
    <a id="_idIndexMarker1005">
    </a>
    <span class="koboSpan" id="kobo.102.1">
     OpenStack side, Neutron will provision a virtual appliance with a certain bandwidth limit.
    </span>
    <span class="koboSpan" id="kobo.102.2">
     Neutron offers a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.103.1">
      Quality of Service
     </span>
    </strong>
    <span class="koboSpan" id="kobo.104.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.105.1">
      QoS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.106.1">
     ) feature that can be used to set network traffic policies for better network
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.107.1">
      bandwidth control.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.108.1">
     When dealing with
    </span>
    <a id="_idIndexMarker1006">
    </a>
    <span class="koboSpan" id="kobo.109.1">
     complex and large-scale workloads that need to exist and move between different cloud environments, a limited bandwidth capacity can present a bottleneck.
    </span>
    <span class="koboSpan" id="kobo.109.2">
     Moreover, a consistent connection between both cloud environments using a simple VPN connection cannot always be guaranteed.
    </span>
    <span class="koboSpan" id="kobo.109.3">
     This is due to the long path taken across shared internet devices.
    </span>
    <span class="koboSpan" id="kobo.109.4">
     For that reason, public cloud providers offer a second category network connection to establish a connection to a private environment.
    </span>
    <span class="koboSpan" id="kobo.109.5">
     In the
    </span>
    <a id="_idIndexMarker1007">
    </a>
    <span class="koboSpan" id="kobo.110.1">
     AWS world,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.111.1">
      DirectConnect
     </span>
    </strong>
    <span class="koboSpan" id="kobo.112.1">
     is an ideal option when a stable, dedicated, isolated, and higher-performance connection
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.113.1">
      is required.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.114.1">
     Implementing a DirectConnect connection requires more steps in the deployment process, unlike a VPN connection setup.
    </span>
    <span class="koboSpan" id="kobo.114.2">
     Cloud operators can order a DirectConnect connection via the AWS console or CLI and decide which type of connection they will put in place.
    </span>
    <span class="koboSpan" id="kobo.114.3">
     DirectConnect offers two kinds
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.115.1">
      of connections:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.116.1">
       A hosted connection
      </span>
     </strong>
     <span class="koboSpan" id="kobo.117.1">
      : An AWS partner will handle the physical connection and link
     </span>
     <a id="_idIndexMarker1008">
     </a>
     <span class="koboSpan" id="kobo.118.1">
      it to the device sitting at the edge of the
     </span>
     <a id="_idIndexMarker1009">
     </a>
     <span class="koboSpan" id="kobo.119.1">
      OpenStack private
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.120.1">
       cloud environment.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.121.1">
       A dedicated connection
      </span>
     </strong>
     <span class="koboSpan" id="kobo.122.1">
      : This establishes a physical connection from the OpenStack
     </span>
     <a id="_idIndexMarker1010">
     </a>
     <span class="koboSpan" id="kobo.123.1">
      endpoint to an AWS DirectConnect
     </span>
     <a id="_idIndexMarker1011">
     </a>
     <span class="koboSpan" id="kobo.124.1">
      location.
     </span>
     <span class="koboSpan" id="kobo.124.2">
      This type of connection comes with multiple bandwidth
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.125.1">
       capacity options.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.126.1">
     Which of these connectivity options you choose depends on many factors, such as cost, geographic location, and bandwidth throughput.
    </span>
    <span class="koboSpan" id="kobo.126.2">
     To learn more about AWS DirectConnect technical details, check out the following AWS
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.127.1">
      URL:
     </span>
    </span>
    <a href="https://docs.aws.amazon.com/directconnect/latest/UserGuide/Welcome.html">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.128.1">
       https://docs.aws.amazon.com/directconnect/latest/UserGuide/Welcome.html
      </span>
     </span>
    </a>
   </p>
   <p>
    <span class="koboSpan" id="kobo.129.1">
     Hybrid connectivity requires a certain level of redundancy.
    </span>
    <span class="koboSpan" id="kobo.129.2">
     If one link fails, you still have a second to carry the traffic, even with lower bandwidth throughput.
    </span>
    <span class="koboSpan" id="kobo.129.3">
     The previous architecture diagram exposed a classic network design that leverages two connections, established using DirectConnect and VPN.
    </span>
    <span class="koboSpan" id="kobo.129.4">
     Operators can configure their devices at the OpenStack private cloud end to primarily receive traffic on the DirectConnect interface.
    </span>
    <span class="koboSpan" id="kobo.129.5">
     That will terminate both connections into two different devices in the same location endpoint.
    </span>
    <span class="koboSpan" id="kobo.129.6">
     If the DirectConnect connection fails for some reason, traffic will be switched to flow across the VPN connection as a backup.
    </span>
    <span class="koboSpan" id="kobo.129.7">
     This design pattern is considered a good compromise
    </span>
    <a id="_idIndexMarker1012">
    </a>
    <span class="koboSpan" id="kobo.130.1">
     that grants high availability at a fair price.
    </span>
    <span class="koboSpan" id="kobo.130.2">
     If a hybrid connection requires the same consistent bandwidth with exact configurations in both links, two DirectConnect links will be put in place.
    </span>
    <span class="koboSpan" id="kobo.130.3">
     That will maximize resiliency for critical production workloads.
    </span>
    <span class="koboSpan" id="kobo.130.4">
     However, that comes of course with a higher bill.
    </span>
    <span class="koboSpan" id="kobo.130.5">
     AWS recommends using dynamic routing to allow connections to fail over automatically and leverage the best available routes.
    </span>
    <span class="koboSpan" id="kobo.130.6">
     This routing capability requires that the OpenStack hardware endpoint supports dynamic routing and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.131.1">
      auto-failover features.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.132.1">
     Now that we have covered one of the most critical pieces of hybrid cloud design, networking, we will move on to the next part to cover different ways to design a containerized hybrid
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.133.1">
      cloud setup.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-190">
    <a id="_idTextAnchor235">
    </a>
    <span class="koboSpan" id="kobo.134.1">
     Designing a containerized hybrid cloud
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.135.1">
     Container technology is the way to go to develop modern applications with all the benefits of
    </span>
    <a id="_idIndexMarker1013">
    </a>
    <span class="koboSpan" id="kobo.136.1">
     portability, speed of deployment, and less operational overhead.
    </span>
    <span class="koboSpan" id="kobo.136.2">
     The evolution of containerization has allowed organizations to run and scale their workloads in an almost zero-touch, reliable, and rapid way.
    </span>
    <span class="koboSpan" id="kobo.136.3">
     With the rise of several forms of container engines such as Docker and LXD, a few container orchestration systems such as Kubernetes, Mesos, and Docker Swarm have come to light and empowered the way of developing applications.
    </span>
    <span class="koboSpan" id="kobo.136.4">
     Today, we can find organizations deploying production workloads with more confidence than ever before.
    </span>
    <span class="koboSpan" id="kobo.136.5">
     Container orchestration systems have shifted the gears on how applications are developed with the evolution of microservices architecture.
    </span>
    <span class="koboSpan" id="kobo.136.6">
     Public cloud providers seized the opportunity to provide a platform to run a fully containerized environment.
    </span>
    <span class="koboSpan" id="kobo.136.7">
     AWS, for example, offers (at the time of writing) three main container-related services, which are summarized
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.137.1">
      as follows:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.138.1">
       Elastic Container Service
      </span>
     </strong>
     <span class="koboSpan" id="kobo.139.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.140.1">
       ECS
      </span>
     </strong>
     <span class="koboSpan" id="kobo.141.1">
      ): Deploys and manages containerized workloads
     </span>
     <a id="_idIndexMarker1014">
     </a>
     <span class="koboSpan" id="kobo.142.1">
      through a fully managed container
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.143.1">
       orchestration service
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.144.1">
       Elastic Kubernetes Service
      </span>
     </strong>
     <span class="koboSpan" id="kobo.145.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.146.1">
       EKS
      </span>
     </strong>
     <span class="koboSpan" id="kobo.147.1">
      ): Runs and manages a Kubernetes control plane
     </span>
     <a id="_idIndexMarker1015">
     </a>
     <span class="koboSpan" id="kobo.148.1">
      that is responsible for container deployment, scheduling,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.149.1">
       and availability
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.150.1">
       Fargate
      </span>
     </strong>
     <span class="koboSpan" id="kobo.151.1">
      : Acts
     </span>
     <a id="_idIndexMarker1016">
     </a>
     <span class="koboSpan" id="kobo.152.1">
      as a serverless service that deploys and manages applications without the need to manage the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.153.1">
       underlying infrastructure
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.154.1">
     Azure
    </span>
    <a id="_idIndexMarker1017">
    </a>
    <span class="koboSpan" id="kobo.155.1">
     has similar managed container services such as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.156.1">
      Azure Container Instances
     </span>
    </strong>
    <span class="koboSpan" id="kobo.157.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.158.1">
      ACI
     </span>
    </strong>
    <span class="koboSpan" id="kobo.159.1">
     ),
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.160.1">
      Azure Container Apps
     </span>
    </strong>
    <span class="koboSpan" id="kobo.161.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.162.1">
      ACA
     </span>
    </strong>
    <span class="koboSpan" id="kobo.163.1">
     ), and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.164.1">
      Azure Kubernetes Service
     </span>
    </strong>
    <span class="koboSpan" id="kobo.165.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.166.1">
      AKS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.167.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.167.2">
     Kubernetes has been a great deal for GCP, which has
    </span>
    <a id="_idIndexMarker1018">
    </a>
    <span class="koboSpan" id="kobo.168.1">
     developed
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.169.1">
      Google Kubernetes Engine
     </span>
    </strong>
    <span class="koboSpan" id="kobo.170.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.171.1">
      GKE
     </span>
    </strong>
    <span class="koboSpan" id="kobo.172.1">
     ) to reliably
    </span>
    <a id="_idIndexMarker1019">
    </a>
    <span class="koboSpan" id="kobo.173.1">
     and efficiently deploy and scale
    </span>
    <a id="_idIndexMarker1020">
    </a>
    <span class="koboSpan" id="kobo.174.1">
     containerized workloads on Kubernetes.
    </span>
    <span class="koboSpan" id="kobo.174.2">
     The history of Kubernetes adoption could fill an
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.175.1">
      entire book.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.176.1">
     Deploying applications on containers in a hybrid cloud architecture requires a good understanding of a few design patterns.
    </span>
    <span class="koboSpan" id="kobo.176.2">
     Organizations should seek the right tools that fit into their strategic initiative to take advantage of the hybrid model.
    </span>
    <span class="koboSpan" id="kobo.176.3">
     In the following sections, we will explore a few implemented design patterns to deploy a hybrid containerized architecture using Kubernetes.
    </span>
    <span class="koboSpan" id="kobo.176.4">
     Before tackling the different design models, we will pick up Kubernetes as a containerization platform.
    </span>
    <span class="koboSpan" id="kobo.176.5">
     One of many reasons to choose Kubernetes is that it is widely used, with plenty of features and tools available in its ecosystem.
    </span>
    <span class="koboSpan" id="kobo.176.6">
     Another great benefit of adopting Kubernetes is its flexibility to design clusters and run containers, surrounded by several stable open source tools for container management across platforms, as well as its support federation feature that fits into a hybrid cloud architecture.
    </span>
    <span class="koboSpan" id="kobo.176.7">
     Before delving into the previously mentioned design benefits of building a hybrid model, let’s briefly look at
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.177.1">
      Kubernetes jargon.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-191">
    <a id="_idTextAnchor236">
    </a>
    <span class="koboSpan" id="kobo.178.1">
     Kubernetes in a nutshell
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.179.1">
     Today, Kubernetes
    </span>
    <a id="_idIndexMarker1021">
    </a>
    <span class="koboSpan" id="kobo.180.1">
     is everywhere.
    </span>
    <span class="koboSpan" id="kobo.180.2">
     Eight
    </span>
    <a id="_idIndexMarker1022">
    </a>
    <span class="koboSpan" id="kobo.181.1">
     years ago, companies were hesitant to start a production journey running Kubernetes, as it was new to the market since Google had recently made it publicly available.
    </span>
    <span class="koboSpan" id="kobo.181.2">
     The concept of a container orchestration engine was not new at the time, since Docker Swarm and Mesos were quite evolved and widely used.
    </span>
    <span class="koboSpan" id="kobo.181.3">
     Kubernetes, as expected, came with a different engine concept.
    </span>
    <span class="koboSpan" id="kobo.181.4">
     Understanding the basic concepts of how it works is an essential step to confidently run it in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.182.1">
      production environments.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.183.1">
     For container enthusiasts, using cloud services will facilitate the adoption of a containerization model based on Kubernetes.
    </span>
    <span class="koboSpan" id="kobo.183.2">
     As mentioned in the previous section, cloud hyperscalers offer a managed service that supports Kubernetes.
    </span>
    <span class="koboSpan" id="kobo.183.3">
     The Kubernetes PaaS
    </span>
    <a id="_idIndexMarker1023">
    </a>
    <span class="koboSpan" id="kobo.184.1">
     model simply removes any overhead to manage and install the containerization orchestration engine.
    </span>
    <span class="koboSpan" id="kobo.184.2">
     This also includes additional networking, storage, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.185.1">
      availability aspects.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.186.1">
     As shown
    </span>
    <a id="_idIndexMarker1024">
    </a>
    <span class="koboSpan" id="kobo.187.1">
     in the following figure, Kubernetes is designed to run different types of nodes within
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.188.1">
      a cluster:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer217">
     <span class="koboSpan" id="kobo.189.1">
      <img alt="Figure 11.3 – The Kubernetes engine architecture at a high level" src="image/B21716_11_03.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.190.1">
     Figure 11.3 – The Kubernetes engine architecture at a high level
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.191.1">
     The node categories can be summarized
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.192.1">
      as follows:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.193.1">
       Master node
      </span>
     </strong>
     <span class="koboSpan" id="kobo.194.1">
      : This is
     </span>
     <a id="_idIndexMarker1025">
     </a>
     <span class="koboSpan" id="kobo.195.1">
      responsible for running most of the essential processes that manage a Kubernetes cluster, including
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.196.1">
       the following:
      </span>
     </span>
     <ul>
      <li>
       <strong class="bold">
        <span class="koboSpan" id="kobo.197.1">
         Scheduler
        </span>
       </strong>
       <span class="koboSpan" id="kobo.198.1">
        : This runs the
       </span>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.199.1">
         kube-scheduler
        </span>
       </strong>
       <span class="koboSpan" id="kobo.200.1">
        process that manages the placement of containers on proper hosts based on resource availability
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.201.1">
         and load.
        </span>
       </span>
      </li>
      <li>
       <strong class="bold">
        <span class="koboSpan" id="kobo.202.1">
         Controller manager
        </span>
       </strong>
       <span class="koboSpan" id="kobo.203.1">
        : This runs the
       </span>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.204.1">
         kube-controller-manager
        </span>
       </strong>
       <span class="koboSpan" id="kobo.205.1">
        process that keeps an eye on the
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.206.1">
         cluster activities.
        </span>
       </span>
      </li>
      <li>
       <strong class="bold">
        <span class="koboSpan" id="kobo.207.1">
         API server
        </span>
       </strong>
       <span class="koboSpan" id="kobo.208.1">
        : This runs the
       </span>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.209.1">
         kube-apiserver
        </span>
       </strong>
       <span class="koboSpan" id="kobo.210.1">
        process that allows communication
       </span>
       <a id="_idIndexMarker1026">
       </a>
       <span class="koboSpan" id="kobo.211.1">
        between a Kubernetes client and the cluster.
       </span>
       <span class="koboSpan" id="kobo.211.2">
        The master node can be reached via the
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.212.1">
         API server.
        </span>
       </span>
      </li>
      <li>
       <strong class="bold">
        <span class="koboSpan" id="kobo.213.1">
         etcd
        </span>
       </strong>
       <span class="koboSpan" id="kobo.214.1">
        : This is a key-value storage that handles the state of
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.215.1">
         the cluster.
        </span>
       </span>
      </li>
     </ul>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.216.1">
       Worker node
      </span>
     </strong>
     <span class="koboSpan" id="kobo.217.1">
      : This
     </span>
     <a id="_idIndexMarker1027">
     </a>
     <span class="koboSpan" id="kobo.218.1">
      runs the workloads in containers and is composed of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.219.1">
       two components:
      </span>
     </span>
     <ul>
      <li>
       <strong class="bold">
        <span class="koboSpan" id="kobo.220.1">
         Kubelet service
        </span>
       </strong>
       <span class="koboSpan" id="kobo.221.1">
        : This runs the K
       </span>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.222.1">
         ubelet
        </span>
       </strong>
       <span class="koboSpan" id="kobo.223.1">
        process that allows cluster inter-communication.
       </span>
       <span class="koboSpan" id="kobo.223.2">
        A Kubelet process also listens from the API server to manage containers in the
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.224.1">
         worker node.
        </span>
       </span>
      </li>
      <li>
       <strong class="bold">
        <span class="koboSpan" id="kobo.225.1">
         Kube-proxy service
        </span>
       </strong>
       <span class="koboSpan" id="kobo.226.1">
        : This runs the
       </span>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.227.1">
         kube-proxy
        </span>
       </strong>
       <span class="koboSpan" id="kobo.228.1">
        service that handles networking between services in a
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.229.1">
         Kubernetes cluster.
        </span>
       </span>
      </li>
     </ul>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.230.1">
     Kubernetes jargon introduces a few concepts as well as those related to its cluster-based architecture description, as illustrated in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.231.1">
      following diagram:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer218">
     <span class="koboSpan" id="kobo.232.1">
      <img alt="Figure 11.4 – The Kubernetes engine architecture at a low level" src="image/B21716_11_04.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.233.1">
     Figure 11.4 – The Kubernetes engine architecture at a low level
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.234.1">
     Different cluster components can be described
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.235.1">
      as follows:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.236.1">
       Pod
      </span>
     </strong>
     <span class="koboSpan" id="kobo.237.1">
      : This is
     </span>
     <a id="_idIndexMarker1028">
     </a>
     <span class="koboSpan" id="kobo.238.1">
      defined as the smallest and most basic component in a Kubernetes environment.
     </span>
     <span class="koboSpan" id="kobo.238.2">
      A pod combines and runs containers, attaches storage as required, and assigns a unique IP address
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.239.1">
       for networking.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.240.1">
       Controller
      </span>
     </strong>
     <span class="koboSpan" id="kobo.241.1">
      : This
     </span>
     <a id="_idIndexMarker1029">
     </a>
     <span class="koboSpan" id="kobo.242.1">
      presents the main piece of the container orchestration engine.
     </span>
     <span class="koboSpan" id="kobo.242.2">
      It manages all different aspects of a pod such as creation, deletion, replication, and rollouts.
     </span>
     <span class="koboSpan" id="kobo.242.3">
      A Kubernetes controller keeps track
     </span>
     <a id="_idIndexMarker1030">
     </a>
     <span class="koboSpan" id="kobo.243.1">
      of workload
     </span>
     <a id="_idIndexMarker1031">
     </a>
     <span class="koboSpan" id="kobo.244.1">
      placements and allocated
     </span>
     <a id="_idIndexMarker1032">
     </a>
     <span class="koboSpan" id="kobo.245.1">
      resources.
     </span>
     <span class="koboSpan" id="kobo.245.2">
      There
     </span>
     <a id="_idIndexMarker1033">
     </a>
     <span class="koboSpan" id="kobo.246.1">
      are different kinds of controllers, including
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.247.1">
       ReplicaSet
      </span>
     </strong>
     <span class="koboSpan" id="kobo.248.1">
      ,
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.249.1">
       StatefulSet
      </span>
     </strong>
     <span class="koboSpan" id="kobo.250.1">
      ,
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.251.1">
       DaemonSet
      </span>
     </strong>
     <span class="koboSpan" id="kobo.252.1">
      ,
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.253.1">
       Deployment
      </span>
     </strong>
     <span class="koboSpan" id="kobo.254.1">
      ,
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.255.1">
       Job
      </span>
     </strong>
     <span class="koboSpan" id="kobo.256.1">
      , and
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.257.1">
       CronJob
      </span>
     </strong>
     <span class="koboSpan" id="kobo.258.1">
      .
     </span>
     <span class="koboSpan" id="kobo.258.2">
      Each
     </span>
     <a id="_idIndexMarker1034">
     </a>
     <span class="koboSpan" id="kobo.259.1">
      controller type has a different use
     </span>
     <a id="_idIndexMarker1035">
     </a>
     <span class="koboSpan" id="kobo.260.1">
      for specific pod management purposes.
     </span>
     <span class="koboSpan" id="kobo.260.2">
      For example, the
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.261.1">
       ReplicaSet
      </span>
     </strong>
     <span class="koboSpan" id="kobo.262.1">
      controller creates a set of pods that all run the same application.
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.263.1">
       CronJob
      </span>
     </strong>
     <span class="koboSpan" id="kobo.264.1">
      is more dedicated to creating scheduled jobs.
     </span>
     <span class="koboSpan" id="kobo.264.2">
      To read more about the Kubernetes controller types, refer to the official Kubernetes page
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.265.1">
       at
      </span>
     </span>
     <a href="https://kubernetes.io/docs/concepts/workloads/controllers/">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.266.1">
        https://kubernetes.io/docs/concepts/workloads/controllers/
       </span>
      </span>
     </a>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.267.1">
       .
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.268.1">
       Service
      </span>
     </strong>
     <span class="koboSpan" id="kobo.269.1">
      : This
     </span>
     <a id="_idIndexMarker1036">
     </a>
     <span class="koboSpan" id="kobo.270.1">
      exposes an application that runs in one or multiple Pods for incoming requests.
     </span>
     <span class="koboSpan" id="kobo.270.2">
      A Kubernetes service routes each request to the respective pod(s) and provides additional capabilities, such as DNS and load balancing to access
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.271.1">
       a pod.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.272.1">
       Namespace
      </span>
     </strong>
     <span class="koboSpan" id="kobo.273.1">
      : This
     </span>
     <a id="_idIndexMarker1037">
     </a>
     <span class="koboSpan" id="kobo.274.1">
      is a scoped logical layer to isolate Kubernetes resource names, thus avoiding name collisions when many users launch several Kubernetes clusters in the
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.275.1">
       same
      </span>
     </em>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.276.1">
       physical cluster.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.277.1">
       Volume
      </span>
     </strong>
     <span class="koboSpan" id="kobo.278.1">
      : This
     </span>
     <a id="_idIndexMarker1038">
     </a>
     <span class="koboSpan" id="kobo.279.1">
      provides persistent storage when required by a workload running in Pods.
     </span>
     <span class="koboSpan" id="kobo.279.2">
      The latest version of Kubernetes supports more storage and volume features, as well as an exhaustive list of volume types.
     </span>
     <span class="koboSpan" id="kobo.279.3">
      A full list of supported types of volumes can be found
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.280.1">
       at
      </span>
     </span>
     <a href="https://kubernetes.io/docs/concepts/storage/volumes/">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.281.1">
        https://kubernetes.io/docs/concepts/storage/volumes/
       </span>
      </span>
     </a>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.282.1">
       .
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.283.1">
     Now that we have covered most of the important aspects of the Kubernetes world, we can verify how it fits into a hybrid cloud setup by exploring two of the most widely adopted
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.284.1">
      deployment models.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-192">
    <a id="_idTextAnchor237">
    </a>
    <span class="koboSpan" id="kobo.285.1">
     Designing a decentralized models
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.286.1">
     The decentralized Kubernetes model, which is adapted for cloud hybrid architecture, is referred to
    </span>
    <a id="_idIndexMarker1039">
    </a>
    <span class="koboSpan" id="kobo.287.1">
     as a
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.288.1">
      bursting
     </span>
    </em>
    <span class="koboSpan" id="kobo.289.1">
     model.
    </span>
    <span class="koboSpan" id="kobo.289.2">
     Organizations adopt such a design to overcome the over-provisioning of resources in their private clouds by leveraging
    </span>
    <a id="_idIndexMarker1040">
    </a>
    <span class="koboSpan" id="kobo.290.1">
     public cloud resources.
    </span>
    <span class="koboSpan" id="kobo.290.2">
     In such a layout, each
    </span>
    <a id="_idIndexMarker1041">
    </a>
    <span class="koboSpan" id="kobo.291.1">
     cloud environment has its own Kubernetes infrastructure deployed and managed separately.
    </span>
    <span class="koboSpan" id="kobo.291.2">
     In a second iteration, operators need to manage network connectivity between clusters that reside in both cloud environments.
    </span>
    <span class="koboSpan" id="kobo.291.3">
     The next figure illustrates public cloud bursting in a hybrid setup where a Kubernetes cluster that runs in a private cloud extends its resources by reaching public resources (additional
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.292.1">
      worker nodes):
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer219">
     <span class="koboSpan" id="kobo.293.1">
      <img alt="Figure 11.5 – A hybrid bursting model for OpenStack and a public cloud provider" src="image/B21716_11_05.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.294.1">
     Figure 11.5 – A hybrid bursting model for OpenStack and a public cloud provider
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.295.1">
     Depending on each public Kubernetes managed service, operators will need to define extra parameters, such as DNS, cluster API endpoint, and namespace configurations, so that public resources can be used within the same workload or application context.
    </span>
    <span class="koboSpan" id="kobo.295.2">
     The implementation of such a model can be far from complex and requires additional tweaks to properly synchronize the Kubernetes cluster resources, such as services and deployments.
    </span>
    <span class="koboSpan" id="kobo.295.3">
     Operators must ensure that both clusters are consistent when it comes to configuration, identity management, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.296.1">
      workload deployments.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.297.1">
     As highlighted at the beginning of this section, AWS offers two managed services for workloads based on Kubernetes: EKS and Fargate.
    </span>
    <span class="koboSpan" id="kobo.297.2">
     Before drafting a bursting Kubernetes layout joining the OpenStack and AWS environments, it is essential to recognize the use cases for each AWS EKS and AWS Fargate service,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.298.1">
      as follows:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.299.1">
      Use EKS if you need to do
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.300.1">
       the following:
      </span>
     </span>
     <ul>
      <li>
       <span class="koboSpan" id="kobo.301.1">
        Provision a managed Kubernetes cluster by AWS without the need to manage its control plane and operate its underlying infrastructure and scaling and
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.302.1">
         security configurations
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.303.1">
        Have more flexibility in the networking, storage, and
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.304.1">
         scaling options
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.305.1">
        Deploy complex and
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.306.1">
         large workloads
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.307.1">
        Have more control of its deployment of cross-regional, on-premises, and private and
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.308.1">
         public clouds
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.309.1">
        Have a wider integration with AWS native services for advanced configuration, such as Elastic Load Balancing and AWS
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.310.1">
         App Mesh
        </span>
       </span>
      </li>
     </ul>
    </li>
    <li>
     <span class="koboSpan" id="kobo.311.1">
      Use Fargate if you
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.312.1">
       don’t
      </span>
     </em>
     <span class="koboSpan" id="kobo.313.1">
      need to do
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.314.1">
       the following:
      </span>
     </span>
     <ul>
      <li>
       <span class="koboSpan" id="kobo.315.1">
        Provision
       </span>
       <a id="_idIndexMarker1042">
       </a>
       <span class="koboSpan" id="kobo.316.1">
        a Kubernetes infrastructure and its
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.317.1">
         associated resources
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.318.1">
        Manage
       </span>
       <a id="_idIndexMarker1043">
       </a>
       <span class="koboSpan" id="kobo.319.1">
        workloads by provisioning resources (EC2 instances) but via task
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.320.1">
         definitions instead
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.321.1">
        Run containers based on cluster and instance sizes but on the CPU and RAM resources you
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.322.1">
         need instead
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.323.1">
        Not focus on managing the cluster nodes but the
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.324.1">
         workloads instead
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.325.1">
        Include additional features that come with the
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.326.1">
         Kubernetes engine
        </span>
       </span>
      </li>
     </ul>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.327.1">
     If you require advanced configurations that support a cloud-agnostic setup and more networking customization, then EKS would be a suitable choice for a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.328.1">
      hybrid layout.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.329.1">
     Another key consideration is that when employing storage in a Kubernetes hybrid decentralized model, both storage (volume) endpoints should have the same data.
    </span>
    <span class="koboSpan" id="kobo.329.2">
     There are several ways to ensure data synchronization across both storage endpoints by leveraging some public cloud-managed storage services.
    </span>
    <span class="koboSpan" id="kobo.329.3">
     For example, a volume attached to Pods running in a Kubernetes cluster in OpenStack can be copied over a private
    </span>
    <a id="_idIndexMarker1044">
    </a>
    <span class="koboSpan" id="kobo.330.1">
     connection to AWS using
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.331.1">
       DataSync
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.332.1">
      (
     </span>
    </span>
    <a href="https://aws.amazon.com/datasync/">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.333.1">
       https://aws.amazon.com/datasync/
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.334.1">
      ).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.335.1">
     As shown in the following architecture diagram, DataSync requires an endpoint for the inbound
    </span>
    <a id="_idIndexMarker1045">
    </a>
    <span class="koboSpan" id="kobo.336.1">
     data transfer from a private cloud storage endpoint.
    </span>
    <span class="koboSpan" id="kobo.336.2">
     You can create an
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.337.1">
      Elastic File System
     </span>
    </strong>
    <span class="koboSpan" id="kobo.338.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.339.1">
      EFS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.340.1">
     ) as a destination location in your AWS VPC.
    </span>
    <span class="koboSpan" id="kobo.340.2">
     The EFS location can be configured in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.341.1">
      DataSync
     </span>
    </strong>
    <span class="koboSpan" id="kobo.342.1">
     task so that any data
    </span>
    <a id="_idIndexMarker1046">
    </a>
    <span class="koboSpan" id="kobo.343.1">
     being transferred from a volume located in the private cloud is synced in an EFS share.
    </span>
    <span class="koboSpan" id="kobo.343.2">
     It is important to
    </span>
    <a id="_idIndexMarker1047">
    </a>
    <span class="koboSpan" id="kobo.344.1">
     note that it is possible to mount an EFS filesystem on Fargate, but it is only limited to volume static provisioning, whereas, with EKS nodes, it is possible to use dynamic persistent
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.345.1">
      volume provisioning.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer220">
     <span class="koboSpan" id="kobo.346.1">
      <img alt="Figure 11.6 – A hybrid Kubernetes bursting model with volume synchronization" src="image/B21716_11_06.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.347.1">
     Figure 11.6 – A hybrid Kubernetes bursting model with volume synchronization
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.348.1">
     This hybrid model is suitable for workloads that do not require low latency with immediate scaling resources dynamically during peak demand.
    </span>
    <span class="koboSpan" id="kobo.348.2">
     In such a model, cloud operators should expect more networking management, as well as ensuring data consistency across hybrid cloud environments.
    </span>
    <span class="koboSpan" id="kobo.348.3">
     Managing multiple Kubernetes clusters across different cloud environments can be overwhelming, even when you employ public Kubernetes-managed services such as EKS and Fargate.
    </span>
    <span class="koboSpan" id="kobo.348.4">
     The good news is that a few open source tools and wrappers based on the Kubernetes ecosystem have been developed
    </span>
    <a id="_idIndexMarker1048">
    </a>
    <span class="koboSpan" id="kobo.349.1">
     to empower more extended designs.
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.350.1">
      Kubernetes Cloud Instance Provider
     </span>
    </strong>
    <span class="koboSpan" id="kobo.351.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.352.1">
      KIP
     </span>
    </strong>
    <span class="koboSpan" id="kobo.353.1">
     ) enables you to manage Pods in cloud instances from one single and simplified interface.
    </span>
    <span class="koboSpan" id="kobo.353.2">
     The next section will explore an abstracted layout that measures a decentralized hybrid Kubernetes layout between AWS and OpenStack
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.354.1">
      using KIP.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.355.1">
     Hybrid cloud bursting
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.356.1">
     Before tackling the idea behind KIP in this section, it is essential to cover briefly the term
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.357.1">
      Kubelet
     </span>
    </em>
    <span class="koboSpan" id="kobo.358.1">
     as another
    </span>
    <a id="_idIndexMarker1049">
    </a>
    <span class="koboSpan" id="kobo.359.1">
     key concept of the Kubernetes
    </span>
    <a id="_idIndexMarker1050">
    </a>
    <span class="koboSpan" id="kobo.360.1">
     framework.
    </span>
    <span class="koboSpan" id="kobo.360.2">
     The Kubelet is simply an agent that runs Kubernetes at the node level.
    </span>
    <span class="koboSpan" id="kobo.360.3">
     It provides all kinds of features that deal with Pods, such as deployment, management, and communication between nodes and Pods.
    </span>
    <span class="koboSpan" id="kobo.360.4">
     A Kubelet can be considered a coordinator between the Kubernetes control plane and the containers running
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.361.1">
      on nodes.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.362.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.363.1">
     To read
    </span>
    <a id="_idIndexMarker1051">
    </a>
    <span class="koboSpan" id="kobo.364.1">
     more about the Kubelet, refer to the official Kubernetes page found
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.365.1">
      at
     </span>
    </span>
    <a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.366.1">
       https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/
      </span>
     </span>
    </a>
   </p>
   <p>
    <span class="koboSpan" id="kobo.367.1">
     Based
    </span>
    <a id="_idIndexMarker1052">
    </a>
    <span class="koboSpan" id="kobo.368.1">
     on the same Kubelet concept, the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.369.1">
      Cloud Native Computing Foundation
     </span>
    </strong>
    <span class="koboSpan" id="kobo.370.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.371.1">
      CNCF
     </span>
    </strong>
    <span class="koboSpan" id="kobo.372.1">
     ) has initiated an open source project that
    </span>
    <a id="_idIndexMarker1053">
    </a>
    <span class="koboSpan" id="kobo.373.1">
     focuses on a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.374.1">
      Virtual Kubelet
     </span>
    </strong>
    <span class="koboSpan" id="kobo.375.1">
     .
    </span>
    <span class="koboSpan" id="kobo.375.2">
     The official Virtual Kubelet project web page can be found at
    </span>
    <a href="https://virtual-kubelet.io/">
     <span class="koboSpan" id="kobo.376.1">
      https://virtual-kubelet.io/
     </span>
    </a>
    <span class="koboSpan" id="kobo.377.1">
     .
    </span>
    <span class="koboSpan" id="kobo.377.2">
     It defines it as
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.378.1">
      “an open source Kubernetes kubelet implementation that masquerades as a kubelet.”
     </span>
    </em>
    <span class="koboSpan" id="kobo.379.1">
     The term
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.380.1">
      masquerades
     </span>
    </em>
    <span class="koboSpan" id="kobo.381.1">
     is quite metaphoric, but one way to understand its concept is to consider the difference between a Kubelet and a Virtual Kubelet.
    </span>
    <span class="koboSpan" id="kobo.381.2">
     The Virtual Kubelet provides more capabilities than the standard Kubelet by scheduling the provisioning of containers in other cloud solutions, but not on the nodes themselves.
    </span>
    <span class="koboSpan" id="kobo.381.3">
     Under the hood, the Virtual Kubelet is highly customizable, allowing users to use other cloud environments
    </span>
    <a id="_idIndexMarker1054">
    </a>
    <span class="koboSpan" id="kobo.382.1">
     and deploy Pods with their own APIs.
    </span>
    <span class="koboSpan" id="kobo.382.2">
     The other piece of the Virtual Kubelet is the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.383.1">
      Kubelet providers
     </span>
    </strong>
    <span class="koboSpan" id="kobo.384.1">
     .
    </span>
    <span class="koboSpan" id="kobo.384.2">
     A Virtual Kubelet provider is a pluggable interface that provides all the necessary operational features and management of Pods and containers.
    </span>
    <span class="koboSpan" id="kobo.384.3">
     A few of the providers commonly used to back Kubernetes nodes on cloud container platforms are AWS Fargate, Azure Container Instances, and OpenStack’s Zun.
    </span>
    <span class="koboSpan" id="kobo.384.4">
     An up-to-date list of supported providers can be found
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.385.1">
      at
     </span>
    </span>
    <a href="https://virtual-kubelet.io/docs/providers/#current-providers">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.386.1">
       https://virtual-kubelet.io/docs/providers/#current-providers
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.387.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.388.1">
     The following diagram illustrates a simple cloud bursting example, from a private OpenStack
    </span>
    <a id="_idIndexMarker1055">
    </a>
    <span class="koboSpan" id="kobo.389.1">
     cloud environment to the AWS public
    </span>
    <a id="_idIndexMarker1056">
    </a>
    <span class="koboSpan" id="kobo.390.1">
     cloud.
    </span>
    <span class="koboSpan" id="kobo.390.2">
     In an OpenStack tenant environment, a Kubernetes cluster runs alongside a Virtual
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.391.1">
      Kubelet pod.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer221">
     <span class="koboSpan" id="kobo.392.1">
      <img alt="Figure 11.7 – Hybrid Kubernetes bursting between OpenStack and AWS via KIP" src="image/B21716_11_07.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.393.1">
     Figure 11.7 – Hybrid Kubernetes bursting between OpenStack and AWS via KIP
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.394.1">
     The other usage of a hybrid decentralized model is to deploy different Kubernetes clusters in more than one cloud environment (private and public) from a single deployer.
    </span>
    <span class="koboSpan" id="kobo.394.2">
     This setup would require additional networking by connecting different clusters at the network layer.
    </span>
    <span class="koboSpan" id="kobo.394.3">
     However, controlling and operating the clusters is performed individually.
    </span>
    <span class="koboSpan" id="kobo.394.4">
     To centralize the management of workloads running across multiple cloud environments, we would need to provide a common control plane layer.
    </span>
    <span class="koboSpan" id="kobo.394.5">
     This design brings the bursting model to the next level by adding a centralized control aspect to the hybrid model, which will be explored in more detail in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.395.1">
      next subsection.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-193">
    <a id="_idTextAnchor238">
    </a>
    <span class="koboSpan" id="kobo.396.1">
     Designing a centralized model
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.397.1">
     The second
    </span>
    <a id="_idIndexMarker1057">
    </a>
    <span class="koboSpan" id="kobo.398.1">
     hybrid model consolidates different Kubernetes
    </span>
    <a id="_idIndexMarker1058">
    </a>
    <span class="koboSpan" id="kobo.399.1">
     clusters that run in both the private and public clouds.
    </span>
    <span class="koboSpan" id="kobo.399.2">
     This type of architecture is referred to as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.400.1">
      Kubernetes Federation
     </span>
    </strong>
    <span class="koboSpan" id="kobo.401.1">
     , which is primarily based on multi-cluster deployments with additional
    </span>
    <a id="_idIndexMarker1059">
    </a>
    <span class="koboSpan" id="kobo.402.1">
     and common control planes.
    </span>
    <span class="koboSpan" id="kobo.402.2">
     Under the Kubernetes Federation setup, one single source of a workload deployment is applied to a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.403.1">
      host cluster
     </span>
    </strong>
    <span class="koboSpan" id="kobo.404.1">
     as a central
    </span>
    <a id="_idIndexMarker1060">
    </a>
    <span class="koboSpan" id="kobo.405.1">
     deployment location that reaches different clusters across different connected cloud endpoints.
    </span>
    <span class="koboSpan" id="kobo.405.2">
     The deployment of the application is then propagated to all environments with a view of a single target cluster.
    </span>
    <span class="koboSpan" id="kobo.405.3">
     That removes any need to configure or maintain the state of an application in each cluster separately.
    </span>
    <span class="koboSpan" id="kobo.405.4">
     The
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.406.1">
      Federation model
     </span>
    </strong>
    <span class="koboSpan" id="kobo.407.1">
     is a desirable hybrid option when you need to manage
    </span>
    <a id="_idIndexMarker1061">
    </a>
    <span class="koboSpan" id="kobo.408.1">
     several clusters through a single API interface.
    </span>
    <span class="koboSpan" id="kobo.408.2">
     An application is packaged and deployed from a single source.
    </span>
    <span class="koboSpan" id="kobo.408.3">
     It spreads out its deployments equally across all visible clusters.
    </span>
    <span class="koboSpan" id="kobo.408.4">
     From a host cluster (master configuration host) perspective, all connected clusters under its view are considered member clusters, so each deployed application will have its replicas throughout all worker nodes at scale.
    </span>
    <span class="koboSpan" id="kobo.408.5">
     Kubernetes
    </span>
    <a id="_idIndexMarker1062">
    </a>
    <span class="koboSpan" id="kobo.409.1">
     Federation can also be customized during
    </span>
    <a id="_idIndexMarker1063">
    </a>
    <span class="koboSpan" id="kobo.410.1">
     the application deployment.
    </span>
    <span class="koboSpan" id="kobo.410.2">
     Some member clusters are part of different environments and might require specific local variables, such as network policies.
    </span>
    <span class="koboSpan" id="kobo.410.3">
     Such member cluster-specific configurations can be supplemented by the host cluster holding the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.411.1">
      Federation configuration.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.412.1">
     There are a variety of tools to deploy a hybrid Kubernetes centralized model.
    </span>
    <span class="koboSpan" id="kobo.412.2">
     In the next section, we will focus on deploying a production-grade Kubernetes cluster across the OpenStack and AWS clouds using some trending open
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.413.1">
      source solutions.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.414.1">
     Deploying Kubernetes everywhere
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.415.1">
     There are
    </span>
    <a id="_idIndexMarker1064">
    </a>
    <span class="koboSpan" id="kobo.416.1">
     several ways to orchestrate the deployment
    </span>
    <a id="_idIndexMarker1065">
    </a>
    <span class="koboSpan" id="kobo.417.1">
     of Kubernetes
    </span>
    <a id="_idIndexMarker1066">
    </a>
    <span class="koboSpan" id="kobo.418.1">
     clusters.
    </span>
    <span class="koboSpan" id="kobo.418.2">
     Using
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.419.1">
      PaaS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.420.1">
     and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.421.1">
      SaaS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.422.1">
     can be the fastest way that uses
    </span>
    <a id="_idIndexMarker1067">
    </a>
    <span class="koboSpan" id="kobo.423.1">
     the least operational overhead.
    </span>
    <span class="koboSpan" id="kobo.423.2">
     The open source world has also contributed to facilitating the deployment across clouds, but that involves preparation and understanding how each solution works under the hood.
    </span>
    <span class="koboSpan" id="kobo.423.3">
     In the following section, we will focus on an open source solution named
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.424.1">
      Juju
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.425.1">
      from
     </span>
    </span>
    <span class="No-Break">
     <a id="_idIndexMarker1068">
     </a>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.426.1">
      Canonical.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.427.1">
     Juju integrates very well with a hybrid cloud deployment model and, more specifically, Kubernetes
    </span>
    <a id="_idIndexMarker1069">
    </a>
    <span class="koboSpan" id="kobo.428.1">
     workloads across different cloud environments.
    </span>
    <span class="koboSpan" id="kobo.428.2">
     Under the hood, a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.429.1">
      Juju controller
     </span>
    </strong>
    <span class="koboSpan" id="kobo.430.1">
     host should exist per environment, whereas a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.431.1">
      Juju client
     </span>
    </strong>
    <span class="koboSpan" id="kobo.432.1">
     performs
    </span>
    <a id="_idIndexMarker1070">
    </a>
    <span class="koboSpan" id="kobo.433.1">
     deployment actions and other functions.
    </span>
    <span class="koboSpan" id="kobo.433.2">
     As shown in the following diagram, a Juju cloud controller runs in each cloud environment and supports multiple cloud environments, including AWS
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.434.1">
      and OpenStack.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer222">
     <span class="koboSpan" id="kobo.435.1">
      <img alt="Figure 11.8 – A Juju workflow in a hybrid deployment model" src="image/B21716_11_08.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.436.1">
     Figure 11.8 – A Juju workflow in a hybrid deployment model
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.437.1">
     The latest
    </span>
    <a id="_idIndexMarker1071">
    </a>
    <span class="koboSpan" id="kobo.438.1">
     list of Juju’s supported clouds can be found at
    </span>
    <a href="https://juju.is/docs/juju/juju-supported-clouds">
     <span class="koboSpan" id="kobo.439.1">
      https://juju.is/docs/juju/juju-supported-clouds
     </span>
    </a>
    <span class="koboSpan" id="kobo.440.1">
     .
    </span>
    <span class="koboSpan" id="kobo.440.2">
     This architecture
    </span>
    <a id="_idIndexMarker1072">
    </a>
    <span class="koboSpan" id="kobo.441.1">
     can be compared to the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.442.1">
      Puppet
     </span>
    </strong>
    <span class="koboSpan" id="kobo.443.1">
     or
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.444.1">
      Chef
     </span>
    </strong>
    <span class="koboSpan" id="kobo.445.1">
     system management tools.
    </span>
    <span class="koboSpan" id="kobo.445.2">
     Puppet
    </span>
    <a id="_idIndexMarker1073">
    </a>
    <span class="koboSpan" id="kobo.446.1">
     uses master-slave architecture, in which the slave component can be compared to a Juju client and the master component is akin to a Juju
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.447.1">
      cloud controller.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.448.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.449.1">
     Several projects and open-source solutions exist that support hybrid and multi-cloud architecture using containers.
    </span>
    <span class="koboSpan" id="kobo.449.2">
     Use cases of hybrid deployments using containers can be found
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.450.1">
      at
     </span>
    </span>
    <a href="https://openinfra.dev/hybrid-cloud/">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.451.1">
       https://openinfra.dev/hybrid-cloud/
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.452.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.453.1">
     Juju, similar to Puppet (manifests) or Chef (cookbooks), uses its own script operators, which are named
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.454.1">
      charms
     </span>
    </strong>
    <span class="koboSpan" id="kobo.455.1">
     .
    </span>
    <span class="koboSpan" id="kobo.455.2">
     Charms deploy
    </span>
    <a id="_idIndexMarker1074">
    </a>
    <span class="koboSpan" id="kobo.456.1">
     applications across different infrastructure resources including containers, virtual machines, and even bare metal machines.
    </span>
    <span class="koboSpan" id="kobo.456.2">
     Juju charms have been designed to be flexible for deployment and can be written in several
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.457.1">
      programming languages.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.458.1">
     The following
    </span>
    <a id="_idIndexMarker1075">
    </a>
    <span class="koboSpan" id="kobo.459.1">
     steps describe how a hybrid Kubernetes cluster can be deployed across public and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.460.1">
      private clouds:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.461.1">
      Install the Juju client in a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.462.1">
       management/deployer host.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.463.1">
      Configure the Juju client in the management host to bootstrap the AWS and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.464.1">
       OpenStack clouds.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.465.1">
      Deploy the Juju cloud controller in the AWS
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.466.1">
       public cloud.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.467.1">
      Deploy the Juju cloud controller in the OpenStack
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.468.1">
       private cloud.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.469.1">
      Deploy Kubernetes clusters across both private and public clouds
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.470.1">
       using Juju.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.471.1">
      Connect both
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.472.1">
       Kubernetes clusters.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.473.1">
      Configure both Kubernetes clusters
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.474.1">
       for federation.
      </span>
     </span>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.475.1">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.476.1">
      step 1
     </span>
    </em>
    <span class="koboSpan" id="kobo.477.1">
     , we will need to pick up a dedicated host for Juju cloud management and install the Juju client.
    </span>
    <span class="koboSpan" id="kobo.477.2">
     This can be any machine that has connectivity to both the OpenStack and AWS environments.
    </span>
    <span class="koboSpan" id="kobo.477.3">
     The Juju client supports several operating systems, a list of which can be found at
    </span>
    <a href="https://juju.is/docs/juju/install-juju">
     <span class="koboSpan" id="kobo.478.1">
      https://juju.is/docs/juju/install-juju
     </span>
    </a>
    <span class="koboSpan" id="kobo.479.1">
     .
    </span>
    <span class="koboSpan" id="kobo.479.2">
     The following step-by-step walkthrough installs the Juju client in a machine running
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.480.1">
      on macOS:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.481.1">
$ brew install juju</span></pre>
   <p>
    <span class="koboSpan" id="kobo.482.1">
     To install the Juju client on a Linux machine that runs the Ubuntu operating system, use the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.483.1">
      command lines:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.484.1">
$ sudo add-apt-repository ppa:juju/stable
$ sudo apt update
$ sudo apt install juju</span></pre>
   <p>
    <span class="koboSpan" id="kobo.485.1">
     The Juju client installation can be checked by running its interactive command line interface,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.486.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.487.1">
$ sudo juju</span></pre>
   <p>
    <span class="koboSpan" id="kobo.488.1">
     Here is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.489.1">
      the output:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer223">
     <span class="koboSpan" id="kobo.490.1">
      <img alt="Figure 11.9 – Verifying the Juju installation" src="image/B21716_11_09.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.491.1">
     Figure 11.9 – Verifying the Juju installation
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.492.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.493.1">
     The Juju command line does not return any Juju cloud controller, as we have fresh-installed, and so far, no cloud controller in any cloud has been configured.
    </span>
    <span class="koboSpan" id="kobo.493.2">
     Juju automatically registers each newly configured cloud controller, as we will
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.494.1">
      see later.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.495.1">
     You can
    </span>
    <a id="_idIndexMarker1076">
    </a>
    <span class="koboSpan" id="kobo.496.1">
     also list the currently supported list of cloud environments by running the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.497.1">
      command line:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.498.1">
$ sudo juju list-clouds --all</span></pre>
   <p>
    <span class="koboSpan" id="kobo.499.1">
     We get the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.500.1">
      following output:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer224">
     <span class="koboSpan" id="kobo.501.1">
      <img alt="Figure 11.10 – The Juju supported cloud providers list" src="image/B21716_11_10.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.502.1">
     Figure 11.10 – The Juju supported cloud providers list
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.503.1">
     The next step is to bootstrap our cloud environments using Juju.
    </span>
    <span class="koboSpan" id="kobo.503.2">
     To interact with AWS resources and bootstrap the first Juju cloud controller, we will need to generate a key pair of EC2 instances in AWS, constructed by access and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.504.1">
      secret keys.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.505.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.506.1">
     OpenStack is
    </span>
    <a id="_idIndexMarker1077">
    </a>
    <span class="koboSpan" id="kobo.507.1">
     not listed here, as Juju lists only public cloud providers.
    </span>
    <span class="koboSpan" id="kobo.507.2">
     Private clouds, including OpenStack, would require adding it via the Juju command-line interface, which will be covered in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.508.1">
      following sections.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.509.1">
     The following
    </span>
    <a id="_idIndexMarker1078">
    </a>
    <span class="koboSpan" id="kobo.510.1">
     part of the walkthrough requires
    </span>
    <a id="_idIndexMarker1079">
    </a>
    <span class="koboSpan" id="kobo.511.1">
     you to have an AWS account and an
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.512.1">
      Identity Access Management
     </span>
    </strong>
    <span class="koboSpan" id="kobo.513.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.514.1">
      IAM
     </span>
    </strong>
    <span class="koboSpan" id="kobo.515.1">
     ) user with programmatic access.
    </span>
    <span class="koboSpan" id="kobo.515.2">
     Access your AWS account and make sure that you have sufficient IAM permissions to create an IAM user with programmatic access.
    </span>
    <span class="koboSpan" id="kobo.515.3">
     From the main console services tab, click
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.516.1">
      IAM
     </span>
    </strong>
    <span class="koboSpan" id="kobo.517.1">
     and select
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.518.1">
      Users
     </span>
    </strong>
    <span class="koboSpan" id="kobo.519.1">
     from the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.520.1">
      Access management
     </span>
    </strong>
    <span class="koboSpan" id="kobo.521.1">
     drop-down option list in the bottom-left corner of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.522.1">
      the console:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer225">
     <span class="koboSpan" id="kobo.523.1">
      <img alt="Figure 11.11 – The AWS IAM console" src="image/B21716_11_11.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.524.1">
     Figure 11.11 – The AWS IAM console
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.525.1">
     Next, click on the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.526.1">
      Create
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.527.1">
       user
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.528.1">
      button:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer226">
     <span class="koboSpan" id="kobo.529.1">
      <img alt="Figure 11.12 – Creating an IAM user in the AWS console" src="image/B21716_11_12.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.530.1">
     Figure 11.12 – Creating an IAM user in the AWS console
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.531.1">
     Provide an IAM user in the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.532.1">
      User name
     </span>
    </strong>
    <span class="koboSpan" id="kobo.533.1">
     field and click on
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.534.1">
      Next
     </span>
    </strong>
    <span class="koboSpan" id="kobo.535.1">
     .
    </span>
    <span class="koboSpan" id="kobo.535.2">
     Leave the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.536.1">
      Provide user access to the AWS Management Console
     </span>
    </strong>
    <span class="koboSpan" id="kobo.537.1">
     checkbox unchecked, as we just need a user with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.538.1">
      programmatic access:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer227">
     <span class="koboSpan" id="kobo.539.1">
      <img alt="Figure 11.13 – Specifying user details in the AWS console" src="image/B21716_11_13.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.540.1">
     Figure 11.13 – Specifying user details in the AWS console
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.541.1">
     The next step involves allowing our Juju user to perform on AWS resources.
    </span>
    <span class="koboSpan" id="kobo.541.2">
     The Juju client will
    </span>
    <a id="_idIndexMarker1080">
    </a>
    <span class="koboSpan" id="kobo.542.1">
     bootstrap a cloud controller in an EC2 instance.
    </span>
    <span class="koboSpan" id="kobo.542.2">
     For the sake of simplicity and based on the least privilege principle, we will
    </span>
    <a id="_idIndexMarker1081">
    </a>
    <span class="koboSpan" id="kobo.543.1">
     assign an AWS-managed policy with full permissions on EC2 resources in AWS by attaching an
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.544.1">
      AmazonEC2FullAccess
     </span>
    </strong>
    <span class="koboSpan" id="kobo.545.1">
     policy to the created user,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.546.1">
      as follows:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer228">
     <span class="koboSpan" id="kobo.547.1">
      <img alt="Figure 11.14 – Assigning an IAM policy to the Juju IAM user in the AWS console" src="image/B21716_11_14.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.548.1">
     Figure 11.14 – Assigning an IAM policy to the Juju IAM user in the AWS console
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.549.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.550.1">
     From a best security practice perspective in AWS, it is not recommended to attach a full array of permissions to an IAM user or role.
    </span>
    <span class="koboSpan" id="kobo.550.2">
     Custom policies can restrict the allowed actions on services and resources.
    </span>
    <span class="koboSpan" id="kobo.550.3">
     As a rule of thumb, always use the least privilege principle when creating policies and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.551.1">
      assigning permissions.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.552.1">
     Click on
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.553.1">
      Next
     </span>
    </strong>
    <span class="koboSpan" id="kobo.554.1">
     and on the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.555.1">
      Review and create
     </span>
    </strong>
    <span class="koboSpan" id="kobo.556.1">
     page, click on
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.557.1">
       Create user
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.558.1">
      :
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer229">
     <span class="koboSpan" id="kobo.559.1">
      <img alt="Figure 11.15 – Reviewing and creating the Juju IAM user in the AWS console" src="image/B21716_11_15.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.560.1">
     Figure 11.15 – Reviewing and creating the Juju IAM user in the AWS console
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.561.1">
     On
    </span>
    <a id="_idIndexMarker1082">
    </a>
    <span class="koboSpan" id="kobo.562.1">
     the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.563.1">
      IAM
     </span>
    </strong>
    <span class="koboSpan" id="kobo.564.1">
     |
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.565.1">
      Users
     </span>
    </strong>
    <span class="koboSpan" id="kobo.566.1">
     dashboard, select the newly created Juju IAM user.
    </span>
    <span class="koboSpan" id="kobo.566.2">
     In the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.567.1">
      Summary
     </span>
    </strong>
    <span class="koboSpan" id="kobo.568.1">
     tab, click on the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.569.1">
      Create access
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.570.1">
       key
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.571.1">
      link:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer230">
     <span class="koboSpan" id="kobo.572.1">
      <img alt="Figure 11.16 – Creating an access key for the Juju IAM user in the AWS console" src="image/B21716_11_16.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.573.1">
     Figure 11.16 – Creating an access key for the Juju IAM user in the AWS console
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.574.1">
     The next page in the IAM user wizard will require you to select the credentials use case.
    </span>
    <span class="koboSpan" id="kobo.574.2">
     Select the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.575.1">
      Application running outside
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.576.1">
       AWS
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.577.1">
      option:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer231">
     <span class="koboSpan" id="kobo.578.1">
      <img alt="Figure 11.17 – Selecting an access key use case for the Juju IAM user in the AWS console" src="image/B21716_11_17.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.579.1">
     Figure 11.17 – Selecting an access key use case for the Juju IAM user in the AWS console
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.580.1">
     The last
    </span>
    <a id="_idIndexMarker1083">
    </a>
    <span class="koboSpan" id="kobo.581.1">
     step of the creation of the IAM user credentials is optional: providing a tag value for the AWS credentials resources.
    </span>
    <span class="koboSpan" id="kobo.581.2">
     Add a tag value and click on
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.582.1">
      Create
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.583.1">
       access key
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.584.1">
      :
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer232">
     <span class="koboSpan" id="kobo.585.1">
      <img alt="Figure 11.18 – Adding an AWS tag resource for the Juju IAM user in the AWS console" src="image/B21716_11_18.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.586.1">
     Figure 11.18 – Adding an AWS tag resource for the Juju IAM user in the AWS console
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.587.1">
     This will generate a pair of access and secret keys.
    </span>
    <span class="koboSpan" id="kobo.587.2">
     You can copy and save them or download a CSV file containing the credentials in a secure
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.588.1">
      location locally:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer233">
     <span class="koboSpan" id="kobo.589.1">
      <img alt="Figure 11.19 – Retrieving the generated keys for the Juju IAM user in the AWS console" src="image/B21716_11_19.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.590.1">
     Figure 11.19 – Retrieving the generated keys for the Juju IAM user in the AWS console
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.591.1">
     Switch back
    </span>
    <a id="_idIndexMarker1084">
    </a>
    <span class="koboSpan" id="kobo.592.1">
     to the Juju command-line interface in the management host and run the following command line to provide a key pair, including the access and secret keys created in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.593.1">
      previous step:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.594.1">
$  sudo juju add-credential aws</span></pre>
   <p>
    <span class="koboSpan" id="kobo.595.1">
     The output is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.596.1">
      as follows:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer234">
     <span class="koboSpan" id="kobo.597.1">
      <img alt="Figure 11.20 – Adding AWS IAM user cloud credentials using the Juju client" src="image/B21716_11_20.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.598.1">
     Figure 11.20 – Adding AWS IAM user cloud credentials using the Juju client
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.599.1">
     The previous
    </span>
    <a id="_idIndexMarker1085">
    </a>
    <span class="koboSpan" id="kobo.600.1">
     command line will optionally request which region Juju will be operating within by providing the generated access and secrets previously.
    </span>
    <span class="koboSpan" id="kobo.600.2">
     Juju will create a local AWS profile
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.601.1">
      named
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.602.1">
       packetpub-kube
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.603.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.604.1">
     The next step is to create our first Juju cloud controller in AWS by running the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.605.1">
      command line:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.606.1">
$ sudo juju  bootstrap aws juju-controller</span></pre>
   <p>
    <span class="koboSpan" id="kobo.607.1">
     We get the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.608.1">
      following output:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer235">
     <span class="koboSpan" id="kobo.609.1">
      <img alt="Figure 11.21 – Creating a Juju cloud controller in AWS" src="image/B21716_11_21.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.610.1">
     Figure 11.21 – Creating a Juju cloud controller in AWS
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.611.1">
     Under
    </span>
    <a id="_idIndexMarker1086">
    </a>
    <span class="koboSpan" id="kobo.612.1">
     the hood, Juju performs an API call to the AWS environment and spawns an EC2 instance.
    </span>
    <span class="koboSpan" id="kobo.612.2">
     The cloud controller instance can be checked in the AWS console in an initializing status from the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.613.1">
      EC2 dashboard:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer236">
     <span class="koboSpan" id="kobo.614.1">
      <img alt="Figure 11.22 – A Juju cloud controller EC2 instance created in the AWS console" src="image/B21716_11_22.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.615.1">
     Figure 11.22 – A Juju cloud controller EC2 instance created in the AWS console
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.616.1">
     Note that Juju bootstraps the Juju controller with default configurations, such as the size of the instance (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.617.1">
      m7g.medium
     </span>
    </strong>
    <span class="koboSpan" id="kobo.618.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.618.2">
     Make sure, in the Juju command line output, that the bootstrapping process completes, as shown in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.619.1">
      following figure:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer237">
     <span class="koboSpan" id="kobo.620.1">
      <img alt="Figure 11.23 – The completion of Juju cloud controller bootstrapping in AWS" src="image/B21716_11_23.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.621.1">
     Figure 11.23 – The completion of Juju cloud controller bootstrapping in AWS
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.622.1">
     Our created controller host is assigned a public IP (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.623.1">
      34.233.124.117
     </span>
    </strong>
    <span class="koboSpan" id="kobo.624.1">
     ) that the Juju client
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.625.1">
      communicates with.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.626.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.627.1">
     The Juju bootstrap command can be customized further by specifying the size of the instance and the region where the cloud controller will be deployed.
    </span>
    <span class="koboSpan" id="kobo.627.2">
     That can be achieved by
    </span>
    <a id="_idIndexMarker1087">
    </a>
    <span class="koboSpan" id="kobo.628.1">
     using the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.629.1">
      constraint
     </span>
    </strong>
    <span class="koboSpan" id="kobo.630.1">
     option in the Juju command-line interface, which
    </span>
    <a id="_idIndexMarker1088">
    </a>
    <span class="koboSpan" id="kobo.631.1">
     uses a key-value format.
    </span>
    <span class="koboSpan" id="kobo.631.2">
     A full list of Juju constraints can be found
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.632.1">
      at
     </span>
    </span>
    <a href="https://juju.is/docs/juju/constraint">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.633.1">
       https://juju.is/docs/juju/constraint
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.634.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.635.1">
     The Juju
    </span>
    <a id="_idIndexMarker1089">
    </a>
    <span class="koboSpan" id="kobo.636.1">
     cloud controller can be listed by running the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.637.1">
      command line:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.638.1">
$ juju list-controllers</span></pre>
   <p>
    <span class="koboSpan" id="kobo.639.1">
     Here is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.640.1">
      the output:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer238">
     <span class="koboSpan" id="kobo.641.1">
      <img alt="Figure 11.24 – Listing the deployed Juju controller using the Juju CLI" src="image/B21716_11_24.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.642.1">
     Figure 11.24 – Listing the deployed Juju controller using the Juju CLI
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.643.1">
     Another amazing benefit of Juju deployment is the support of a user graphical interface that comes with several features, such as the interactive creation of controller systems and the status of deployments.
    </span>
    <span class="koboSpan" id="kobo.643.2">
     The user interface link can be accessed by default via the assigned public IP of the EC2 instance, which is generated by running the Juju dashboard command line.
    </span>
    <span class="koboSpan" id="kobo.643.3">
     If you are running Juju version 3.0 or later, you will need to add the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.644.1">
      juju-dashboard
     </span>
    </strong>
    <span class="koboSpan" id="kobo.645.1">
     charm to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.646.1">
      deployed controller.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.647.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.648.1">
     Prior to version 3.0.0, the Juju dashboard charm was deployed by default when installing the Juju controller, and access details were generated by running the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.649.1">
      $ juju guis
     </span>
    </strong>
    <span class="koboSpan" id="kobo.650.1">
     command line.
    </span>
    <span class="koboSpan" id="kobo.650.2">
     The previous command line was dropped from Juju 3.0.0 and later versions, and was replaced by the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.651.1">
      $ juju dashboard
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.652.1">
      command-line option.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.653.1">
     As we aim to expose Kubernetes resources, we will add the Kubernetes dashboard charm.
    </span>
    <span class="koboSpan" id="kobo.653.2">
     Switch to the created controller by running the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.654.1">
      command line:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.655.1">
$ juju switch juju-controller</span></pre>
   <p>
    <span class="koboSpan" id="kobo.656.1">
     The output is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.657.1">
      as follows:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer239">
     <span class="koboSpan" id="kobo.658.1">
      <img alt="Figure 11.25 – Switching Juju controllers using the Juju CLI" src="image/B21716_11_25.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.659.1">
     Figure 11.25 – Switching Juju controllers using the Juju CLI
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.660.1">
     Deploy the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.661.1">
      juju-dashboard
     </span>
    </strong>
    <span class="koboSpan" id="kobo.662.1">
     charm for Kubernetes on the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.663.1">
      selected controller:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.664.1">
$ juju deploy juju-dashboard-k8s dashboard</span></pre>
   <p>
    <span class="koboSpan" id="kobo.665.1">
     Next, link the dashboard to the selected controller
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.666.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.667.1">
$ juju integrate dashboard juju-controller</span></pre>
   <p>
    <span class="koboSpan" id="kobo.668.1">
     Finally, make the dashboard accessible by running the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.669.1">
      command line:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.670.1">
$ juju expose dashboard</span></pre>
   <p>
    <span class="koboSpan" id="kobo.671.1">
     The Juju
    </span>
    <a id="_idIndexMarker1090">
    </a>
    <span class="koboSpan" id="kobo.672.1">
     dashboard for Kubernetes should be deployed on the controller instance and accessed by pointing to the generated URL and login credentials provided in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.673.1">
      previous output.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.674.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.675.1">
     The output of the dashboard link and associated login credentials are no longer valid.
    </span>
    <span class="koboSpan" id="kobo.675.2">
     Make sure to use your own generated link and credentials to access the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.676.1">
      deployed dashboard.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.677.1">
     Once the Juju client and cloud controller are configured, we can start by deploying the first Kubernetes cluster in AWS.
    </span>
    <span class="koboSpan" id="kobo.677.2">
     Juju provides different alternatives to deploy a Kubernetes cluster in AWS by simply deploying the respective charm.
    </span>
    <span class="koboSpan" id="kobo.677.3">
     That can be a cluster deployed via a managed Kubernetes service, such as EKS, or a custom Kubernetes cluster running on an EC2 instance.
    </span>
    <span class="koboSpan" id="kobo.677.4">
     Any of those aforementioned alternatives can be deployed simply via the Juju charms.
    </span>
    <span class="koboSpan" id="kobo.677.5">
     In the following steps, we will deploy a self-managed Kubernetes cluster in AWS.
    </span>
    <span class="koboSpan" id="kobo.677.6">
     Juju charms come with a production-grade Kubernetes cluster that can be deployed by simply running the following command line in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.678.1">
      deployer host:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.679.1">
$ juju deploy charmed-kubernetes</span></pre>
   <p>
    <span class="koboSpan" id="kobo.680.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.681.1">
      charmed-kubernetes
     </span>
    </strong>
    <span class="koboSpan" id="kobo.682.1">
     Juju charm deploys several components in AWS, including
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.683.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.684.1">
      Kubernetes
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.685.1">
       master node
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.686.1">
      Kubernetes
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.687.1">
       slave node
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.688.1">
       Certificate authority
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.689.1">
       etcd
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.690.1">
      Kubernetes API
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.691.1">
       load balancer
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.692.1">
       Containerd engine
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.693.1">
      Virtual networking service
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.694.1">
       running Calico
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.695.1">
     A full list
    </span>
    <a id="_idIndexMarker1091">
    </a>
    <span class="koboSpan" id="kobo.696.1">
     with respective links for each component can
    </span>
    <a id="_idIndexMarker1092">
    </a>
    <span class="koboSpan" id="kobo.697.1">
     be found at the Juju Charmhub at
    </span>
    <a href="https://charmhub.io/charmed-kubernetes">
     <span class="koboSpan" id="kobo.698.1">
      https://charmhub.io/charmed-kubernetes
     </span>
    </a>
    <span class="koboSpan" id="kobo.699.1">
     .
    </span>
    <span class="koboSpan" id="kobo.699.2">
     The previous command line will deploy the Kubernetes cluster on the created cloud controller.
    </span>
    <span class="koboSpan" id="kobo.699.3">
     We can check each component’s status and details by running the following command line in the Juju
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.700.1">
      deployer host:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.701.1">
$ juju status</span></pre>
   <p>
    <span class="koboSpan" id="kobo.702.1">
     Here is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.703.1">
      the output:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer240">
     <span class="koboSpan" id="kobo.704.1">
      <img alt="Figure 11.26 – Listing the K8s cluster status in AWS using the Juju CLI" src="image/B21716_11_26.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.705.1">
     Figure 11.26 – Listing the K8s cluster status in AWS using the Juju CLI
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.706.1">
     Alternatively, a new Kubernetes cluster can be checked through the installed dashboard.
    </span>
    <span class="koboSpan" id="kobo.706.2">
     First, make sure that you have
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.707.1">
      kubectl
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.708.1">
      installed locally:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.709.1">
$ brew install kubectl</span></pre>
   <p>
    <span class="koboSpan" id="kobo.710.1">
     Once installed, run the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.711.1">
      kubectl
     </span>
    </strong>
    <span class="koboSpan" id="kobo.712.1">
     proxy command line locally on
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.713.1">
      127.0.0.1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.714.1">
     and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.715.1">
      port
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.716.1">
       8001
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.717.1">
      :
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.718.1">
$ kubectl proxy --address='127.0.0.1' --port=8001</span></pre>
   <p>
    <span class="koboSpan" id="kobo.719.1">
     In a browser, enter
    </span>
    <a href="http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/">
     <span class="koboSpan" id="kobo.720.1">
      http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/
     </span>
    </a>
    <span class="koboSpan" id="kobo.721.1">
     .
    </span>
    <span class="koboSpan" id="kobo.721.2">
     This will show you a graphical user interface showing different deployed K8s cluster components
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.722.1">
      as follows:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer241">
     <span class="koboSpan" id="kobo.723.1">
      <img alt="Figure 11.27 – The Juju dashboard for the K8s cluster deployed in AWS" src="image/B21716_11_27.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.724.1">
     Figure 11.27 – The Juju dashboard for the K8s cluster deployed in AWS
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.725.1">
     Once we
    </span>
    <a id="_idIndexMarker1093">
    </a>
    <span class="koboSpan" id="kobo.726.1">
     have achieved a fully deployed and running Kubernetes cluster in AWS, we can move to do the same steps in the OpenStack
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.727.1">
      private cloud.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.728.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.729.1">
      juju list-clouds
     </span>
    </strong>
    <span class="koboSpan" id="kobo.730.1">
     command line, as mentioned earlier, does not return OpenStack as a supported cloud by default.
    </span>
    <span class="koboSpan" id="kobo.730.2">
     As a first step, add the OpenStack private cloud to Juju by running the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.731.1">
      command line:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.732.1">
$ juju add-cloud</span></pre>
   <p>
    <span class="koboSpan" id="kobo.733.1">
     The output we get
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.734.1">
      is this:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer242">
     <span class="koboSpan" id="kobo.735.1">
      <img alt="Figure 11.28 – Adding the OpenStack cloud using the Juju client" src="image/B21716_11_28.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.736.1">
     Figure 11.28 – Adding the OpenStack cloud using the Juju client
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.737.1">
     Once the OpenStack cloud is added, use the same
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.738.1">
      juju add-credentials
     </span>
    </strong>
    <span class="koboSpan" id="kobo.739.1">
     command line to authenticate against the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.740.1">
      OpenStack API:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.741.1">
$ juju add-credential awesome-openstack</span></pre>
   <p>
    <span class="koboSpan" id="kobo.742.1">
     Run the following command line to bootstrap the OpenStack cloud
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.743.1">
      in Juju:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.744.1">
$ juju bootstrap awesome-openstack juju-controller2</span></pre>
   <p>
    <span class="koboSpan" id="kobo.745.1">
     As with the bootstrapping process in the AWS world, Juju will create a new cloud controller instance in OpenStack
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.746.1">
      named
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.747.1">
       juju-controller2
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.748.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.749.1">
     Once created, we can deploy a Kubernetes cluster using the same Juju charm deployed in AWS.
    </span>
    <span class="koboSpan" id="kobo.749.2">
     Use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.750.1">
      juju deploy
     </span>
    </strong>
    <span class="koboSpan" id="kobo.751.1">
     command line targeting the OpenStack Juju model
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.752.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.753.1">
$ juju deploy charmed-kubernetes -m juju-controller2</span></pre>
   <p>
    <span class="koboSpan" id="kobo.754.1">
     The deployment
    </span>
    <a id="_idIndexMarker1094">
    </a>
    <span class="koboSpan" id="kobo.755.1">
     process can take several minutes, and it can be checked by running the Juju status command line with the controller name as a flag,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.756.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.757.1">
$ juju status -m juju-controller2</span></pre>
   <p>
    <span class="koboSpan" id="kobo.758.1">
     This will be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.759.1">
      the output:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer243">
     <span class="koboSpan" id="kobo.760.1">
      <img alt="Figure 11.29 – Checking the K8s cluster status in OpenStack using the Juju client" src="image/B21716_11_29.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.761.1">
     Figure 11.29 – Checking the K8s cluster status in OpenStack using the Juju client
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.762.1">
     As we deployed the same Kubernetes Juju charm in OpenStack as AWS, we should expect to see the same components listed in AWS up and running after the process has finished successfully.
    </span>
    <span class="koboSpan" id="kobo.762.2">
     The previous command line provides the current state of each unit of the Kubernetes cluster.
    </span>
    <span class="koboSpan" id="kobo.762.3">
     The cluster is fully deployed when all agents in each unit have the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.763.1">
       idle
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.764.1">
      value.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.765.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.766.1">
     The deployment process can take a while, and a real-time view of the deployment can be performed by running a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.767.1">
      watch -c juju status
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.768.1">
      command line.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.769.1">
     Once the cluster is deployed, it can be accessed from either the Kubernetes master or worker node.
    </span>
    <span class="koboSpan" id="kobo.769.2">
     To take control of the cluster, we will need to set up the client and credentials access.
    </span>
    <span class="koboSpan" id="kobo.769.3">
     Create a dedicated config directory in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.770.1">
      deployer workstation:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.771.1">
$ mkdir -p ~/.kube</span></pre>
   <p>
    <span class="koboSpan" id="kobo.772.1">
     The next step aims to centralize the management of both clusters created in AWS and OpenStack through the same configuration location.
    </span>
    <span class="koboSpan" id="kobo.772.2">
     To do this, we will copy the configuration
    </span>
    <a id="_idIndexMarker1095">
    </a>
    <span class="koboSpan" id="kobo.773.1">
     files of each Kubernetes master deployed in both the AWS and OpenStack environments over an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.774.1">
      scp
     </span>
    </strong>
    <span class="koboSpan" id="kobo.775.1">
     command line.
    </span>
    <span class="koboSpan" id="kobo.775.2">
     The following command lines will switch the Juju controller to the respective Kubernetes environment and copy the configuration file to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.776.1">
      ~/.kube
     </span>
    </strong>
    <span class="koboSpan" id="kobo.777.1">
     directory.
    </span>
    <span class="koboSpan" id="kobo.777.2">
     Let’s start with the AWS
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.778.1">
      Juju controller:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.779.1">
$ juju switch aws
$ juju scp kubernetes-master/0:config ~/.kube/aws-config</span></pre>
   <p>
    <span class="koboSpan" id="kobo.780.1">
     Run the previous command but switch to the OpenStack
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.781.1">
      Juju controller:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.782.1">
$ juju switch awesome-openstack
$ juju scp kubernetes-master/0:config ~/.kube/os-config</span></pre>
   <p>
    <span class="koboSpan" id="kobo.783.1">
     To query the Kubernetes resources for both cloud environments, we can run the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.784.1">
      kubectl
     </span>
    </strong>
    <span class="koboSpan" id="kobo.785.1">
     native tool that is, by default, installed in each master and worker node.
    </span>
    <span class="koboSpan" id="kobo.785.2">
     In the management host, make sure that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.786.1">
      kubectl
     </span>
    </strong>
    <span class="koboSpan" id="kobo.787.1">
     is installed (if this was not done previously) by running the following command line on a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.788.1">
      macOS machine:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.789.1">
$ brew install kubectl</span></pre>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.790.1">
     Tip
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.791.1">
     The Kubectl setup guide
    </span>
    <a id="_idIndexMarker1096">
    </a>
    <span class="koboSpan" id="kobo.792.1">
     for other platforms is detailed on the official Kubernetes website page
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.793.1">
      at
     </span>
    </span>
    <a href="https://kubernetes.io/docs/tasks/tools/#kubectl">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.794.1">
       https://kubernetes.io/docs/tasks/tools/#kubectl
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.795.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.796.1">
     We can then query each Kubernetes cluster from the Juju client machine by specifying the respective
    </span>
    <a id="_idIndexMarker1097">
    </a>
    <span class="koboSpan" id="kobo.797.1">
     configuration path of each cloud environment.
    </span>
    <span class="koboSpan" id="kobo.797.2">
     The following command line displays the status of the deployed Kubernetes cluster
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.798.1">
      in AWS:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.799.1">
$ kubectl cluster-info --kubeconfig=~/.kube/aws-config</span></pre>
   <p>
    <span class="koboSpan" id="kobo.800.1">
     Here is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.801.1">
      the output:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer244">
     <span class="koboSpan" id="kobo.802.1">
      <img alt="Figure 11.30 – Listing the deployed K8s cluster components in AWS using kubectl" src="image/B21716_11_30.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.803.1">
     Figure 11.30 – Listing the deployed K8s cluster components in AWS using kubectl
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.804.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.805.1">
     Alternatively, you can access the Kubernetes dashboard on the Juju client machine by running
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.806.1">
      $ kubectl
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.807.1">
       proxy 127.0.0.1:8001
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.808.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.809.1">
     Now that we have two fully deployed Kubernetes clusters in AWS and OpenStack clouds, we will focus on connecting them.
    </span>
    <span class="koboSpan" id="kobo.809.2">
     To use hybrid Kubernetes jargon, we will rely on the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.810.1">
      Federation feature.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.811.1">
     Bringing clusters together
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.812.1">
     The Kubernetes Federation, a functionality that is known as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.813.1">
      KubeFed
     </span>
    </strong>
    <span class="koboSpan" id="kobo.814.1">
     , enables workloads
    </span>
    <a id="_idIndexMarker1098">
    </a>
    <span class="koboSpan" id="kobo.815.1">
     to run over multiple clusters, spread across multiple data centers and geographical locations.
    </span>
    <span class="koboSpan" id="kobo.815.2">
     KubeFed leverages the control
    </span>
    <a id="_idIndexMarker1099">
    </a>
    <span class="koboSpan" id="kobo.816.1">
     of different clusters from one central host that propagates any configuration changes to all or a selected member of the clusters.
    </span>
    <span class="koboSpan" id="kobo.816.2">
     From an architecture perspective, the federated control plane leverages a set of standard APIs to control and manage cluster-wide operations.
    </span>
    <span class="koboSpan" id="kobo.816.3">
     Since isolated clusters can be associated with DNS entries, KubeFed takes care of managing them by automatically configuring DNS for all discovered nodes.
    </span>
    <span class="koboSpan" id="kobo.816.4">
     As shown in the next figure (in our case, with the hybrid model), KubeFed enables multiple clusters to be managed through a single
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.817.1">
      control plane:
     </span>
    </span>
   </p>
   <p class="IMG---Figure">
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer245">
     <span class="koboSpan" id="kobo.818.1">
      <img alt="Figure 11.31 – A Kubernetes federation layout across OpenStack and AWS clouds" src="image/B21716_11_31.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.819.1">
     Figure 11.31 – A Kubernetes federation layout across OpenStack and AWS clouds
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.820.1">
     KubeFed can coordinate the state and configuration of many clusters running the standard
    </span>
    <a id="_idIndexMarker1100">
    </a>
    <span class="koboSpan" id="kobo.821.1">
     Kubernetes API.
    </span>
    <span class="koboSpan" id="kobo.821.2">
     In our use case, and for the
    </span>
    <a id="_idIndexMarker1101">
    </a>
    <span class="koboSpan" id="kobo.822.1">
     AWS public cloud, any Kubernetes cluster deployed in EC2, EKS, or Fargate can be federated and linked to the cluster deployed in OpenStack’s
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.823.1">
      private cloud.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.824.1">
     Before we look at the federation implementation, let’s take a quick detour to look at some technical concepts of the KubeFed.
    </span>
    <span class="koboSpan" id="kobo.824.2">
     The Kubernetes federation piece runs a regular Pod
    </span>
    <a id="_idIndexMarker1102">
    </a>
    <span class="koboSpan" id="kobo.825.1">
     into a Kubernetes cluster on its own.
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.826.1">
      Federation Pods
     </span>
    </strong>
    <span class="koboSpan" id="kobo.827.1">
     are purely used for federation purposes and live within a created federated service.
    </span>
    <span class="koboSpan" id="kobo.827.2">
     Functions such as service deployments, health monitoring, and DNS management are handled by the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.828.1">
      federated Pods.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.829.1">
     The following steps will demonstrate how to use KubeFed to bring the AWS and OpenStack
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.830.1">
      worlds together.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.831.1">
     To start working with Federation, we will need to deploy a dedicated Kubernetes cluster on the host cluster.
    </span>
    <span class="koboSpan" id="kobo.831.2">
     The simplest and quickest way to do so is by setting a Federation controller using Juju.
    </span>
    <span class="koboSpan" id="kobo.831.3">
     Kubernetes’ Federation cluster can be deployed in either OpenStack or AWS.
    </span>
    <span class="koboSpan" id="kobo.831.4">
     You can also choose to deploy it in a different management environment and interact with it through a local client that can be installed later.
    </span>
    <span class="koboSpan" id="kobo.831.5">
     For the sake of simplicity, we will use the OpenStack environment to run the Federation cluster.
    </span>
    <span class="koboSpan" id="kobo.831.6">
     Using Juju, we can switch to the OpenStack private cloud environment and deploy a new federation cluster, using the same Kubernetes charm as earlier,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.832.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.833.1">
$ juju switch awesome-openstack
$ juju deploy charmed-kubernetes -m juju-controller-fed</span></pre>
   <p>
    <span class="koboSpan" id="kobo.834.1">
     Make sure
    </span>
    <a id="_idIndexMarker1103">
    </a>
    <span class="koboSpan" id="kobo.835.1">
     to follow the status of the cluster deployment using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.836.1">
      $juju status
     </span>
    </strong>
    <span class="koboSpan" id="kobo.837.1">
     command line.
    </span>
    <span class="koboSpan" id="kobo.837.2">
     Once the nine-component clusters are
    </span>
    <a id="_idIndexMarker1104">
    </a>
    <span class="koboSpan" id="kobo.838.1">
     deployed, we can proceed to set up the federation cluster locally.
    </span>
    <span class="koboSpan" id="kobo.838.2">
     With the same command lines we used for the OpenStack and AWS Kubernetes clusters, use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.839.1">
      scp
     </span>
    </strong>
    <span class="koboSpan" id="kobo.840.1">
     to copy the cluster config file from any node under the ~/.
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.841.1">
      kube/ directory:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.842.1">
$ juju scp kubernetes-master/0:config ~/.kube/fed-config</span></pre>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.843.1">
     Tip
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.844.1">
     We copied the config file by renaming it, as we did with the AWS and OpenStack Kube files,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.845.1">
      to
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.846.1">
       fed-config
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.847.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.848.1">
     A good practice when dealing with multiple Kubernetes clusters is to centralize the management of all of them within a single command line.
    </span>
    <span class="koboSpan" id="kobo.848.2">
     That will remove extra overhead when switching between clusters every time we need to operate a specific cluster.
    </span>
    <span class="koboSpan" id="kobo.848.3">
     One way to do this is simply by merging all Kubernetes config files into one file.
    </span>
    <span class="koboSpan" id="kobo.848.4">
     The latest releases of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.849.1">
      kubectl
     </span>
    </strong>
    <span class="koboSpan" id="kobo.850.1">
     support the management of multiple cluster views.
    </span>
    <span class="koboSpan" id="kobo.850.2">
     Start by creating an empty config file if it does not
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.851.1">
      exist yet:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.852.1">
$ touch ~/.kube/config</span></pre>
   <p>
    <span class="koboSpan" id="kobo.853.1">
     Then, set the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.854.1">
      KUBECONFIG
     </span>
    </strong>
    <span class="koboSpan" id="kobo.855.1">
     environment variable with a list of paths to all configuration files,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.856.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.857.1">
$ export KUBECONFIG=~/.kube/config:~/.kube/os-config:~/.kube/aws-config: ~/.kube/fed-config</span></pre>
   <p>
    <span class="koboSpan" id="kobo.858.1">
     Once exported, run the following command line to merge all the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.859.1">
      kubeconfig
     </span>
    </strong>
    <span class="koboSpan" id="kobo.860.1">
     files
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.861.1">
      into one:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.862.1">
$ kubectl config view --flatten &gt; ~/.kube/config</span></pre>
   <p>
    <span class="koboSpan" id="kobo.863.1">
     Using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.864.1">
      kubectl get-contexts
     </span>
    </strong>
    <span class="koboSpan" id="kobo.865.1">
     command line, we can display available contexts from the merged
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.866.1">
      configuration step:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.867.1">
$ kubectl config get-contexts</span></pre>
   <p>
    <span class="koboSpan" id="kobo.868.1">
     Here is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.869.1">
      the output:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer246">
     <span class="koboSpan" id="kobo.870.1">
      <img alt="Figure 11.32 – A listing of the K8s contexts of the Juju controllers" src="image/B21716_11_32.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.871.1">
     Figure 11.32 – A listing of the K8s contexts of the Juju controllers
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.872.1">
     Tip
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.873.1">
     We can display all clusters defined in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.874.1">
      kubeconfig
     </span>
    </strong>
    <span class="koboSpan" id="kobo.875.1">
     file by running the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.876.1">
      kubectl config get-clusters
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.877.1">
      command line.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.878.1">
     Before moving to construct the federated control plane, we will need to expose the federated
    </span>
    <a id="_idIndexMarker1105">
    </a>
    <span class="koboSpan" id="kobo.879.1">
     service controller via DNS names.
    </span>
    <span class="koboSpan" id="kobo.879.2">
     In our case, we have deployed the federation cluster in the OpenStack environment.
    </span>
    <span class="koboSpan" id="kobo.879.3">
     Hence, a DNS
    </span>
    <a id="_idIndexMarker1106">
    </a>
    <span class="koboSpan" id="kobo.880.1">
     provider configuration should be available to the federated service controller.
    </span>
    <span class="koboSpan" id="kobo.880.2">
     When deploying the federated service controller in other cloud providers, DNS provider configuration is generated automatically if the deployed host cluster is the same as the DNS provider.
    </span>
    <span class="koboSpan" id="kobo.880.3">
     For example, if the federated service controller is running in AWS and pre-configurated with a Route 53 hosted zone, the DNS provider will be automatically generated and pass DNS names
    </span>
    <a id="_idIndexMarker1107">
    </a>
    <span class="koboSpan" id="kobo.881.1">
     to the federated service controller.
    </span>
    <span class="koboSpan" id="kobo.881.2">
     In the following setup, we will configure
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.882.1">
      CoreDNS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.883.1">
     as a federation DNS provider in the OpenStack federation cluster.
    </span>
    <span class="koboSpan" id="kobo.883.2">
     To enable CoreDNS on
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.884.1">
      juju-controller-fed
     </span>
    </strong>
    <span class="koboSpan" id="kobo.885.1">
     , run the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.886.1">
      command lines:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.887.1">
$ juju switch juju-controller-fed
$ juju config kubernetes-master enable-coredns=True</span></pre>
   <p>
    <span class="koboSpan" id="kobo.888.1">
     Then, create a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.889.1">
      coredns-provider.conf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.890.1">
     file that contains the IP address of the etcd service, obtained from the cluster status of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.891.1">
      juju-controller-fed
     </span>
    </strong>
    <span class="koboSpan" id="kobo.892.1">
     cluster and the DNS zone.
    </span>
    <span class="koboSpan" id="kobo.892.2">
     The content of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.893.1">
      CoreDNS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.894.1">
     file is configured
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.895.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.896.1">
[Global]
etcd-endpoints = http://10.0.0.54:2379
zones = kube-fed.com.</span></pre>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.897.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.898.1">
     The zone configured in this example is based on a local DNS configuration in the OpenStack environment.
    </span>
    <span class="koboSpan" id="kobo.898.2">
     Feel free to use a custom DNS provider or a local one of your choice to create and manage zones for private cloud resources.
    </span>
    <span class="koboSpan" id="kobo.898.3">
     Public cloud providers also offer a managed DNS service to create zones and DNS records, such as Route53 for AWS and Azure DNS for the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.899.1">
      Azure cloud.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.900.1">
     Now, it is
    </span>
    <a id="_idIndexMarker1108">
    </a>
    <span class="koboSpan" id="kobo.901.1">
     time to deploy the federation control
    </span>
    <a id="_idIndexMarker1109">
    </a>
    <span class="koboSpan" id="kobo.902.1">
     plane on
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.903.1">
      juju-controller-fed
     </span>
    </strong>
    <span class="koboSpan" id="kobo.904.1">
     .
    </span>
    <span class="koboSpan" id="kobo.904.2">
     We briefly discussed Kubefed, the tool for Kubernetes federation, but we have not installed it yet.
    </span>
    <span class="koboSpan" id="kobo.904.3">
     To do so, run the following command lines on macOS to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.905.1">
      install Kubefed:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.906.1">
$ curl -LO https://github.com/kubernetes-sigs/kubefed/releases/download/v0.10.0/kubefedctl-0.10.0-darwin-amd64.tgz</span></pre>
   <p>
    <span class="koboSpan" id="kobo.907.1">
     Next, extract binaries to one of the directories and set the necessary executable permissions for the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.908.1">
      Kubefed binary:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.909.1">
$ tar -xzvf kubefedctl-0.10.0-darwin-amd64.tgz
$ sudo cp kubernetes/client/bin/kubefed /usr/local/bin
$ sudo chmod +x /usr/local/bin/kubefed</span></pre>
   <p>
    <span class="koboSpan" id="kobo.910.1">
     Run the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.911.1">
      kubefed init
     </span>
    </strong>
    <span class="koboSpan" id="kobo.912.1">
     command line to deploy and initialize the required service in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.913.1">
      federation cluster:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.914.1">
$ kubefed init hybridfed --host-cluster-context=juju-controllerfed --dns-provider="coredns" --dns-zone-name="kube-fed.com" --dns-provider-config=coredns-provider.conf</span></pre>
   <p>
    <span class="koboSpan" id="kobo.915.1">
     Here is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.916.1">
      the output:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer247">
     <span class="koboSpan" id="kobo.917.1">
      <img alt="Figure 11.33 – Running the Kubefed Federation control plane" src="image/B21716_11_33.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.918.1">
     Figure 11.33 – Running the Kubefed Federation control plane
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.919.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.920.1">
      kubefed init
     </span>
    </strong>
    <span class="koboSpan" id="kobo.921.1">
     Federation command line will install a new API server by exposing the Federation service, as shown previously.
    </span>
    <span class="koboSpan" id="kobo.921.2">
     It also takes care of installing the controller manager for Federation in addition to a dedicated namespace, referred to as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.922.1">
      federation-system
     </span>
    </strong>
    <span class="koboSpan" id="kobo.923.1">
     in the host cluster.
    </span>
    <span class="koboSpan" id="kobo.923.2">
     Now that we have Federation ready for usage, we
    </span>
    <a id="_idIndexMarker1110">
    </a>
    <span class="koboSpan" id="kobo.924.1">
     can start controlling the Kubernetes clusters
    </span>
    <a id="_idIndexMarker1111">
    </a>
    <span class="koboSpan" id="kobo.925.1">
     for Federation.
    </span>
    <span class="koboSpan" id="kobo.925.2">
     Proceed by switching to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.926.1">
      Federation context:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.927.1">
$ kubectl config use-context hybridfed</span></pre>
   <p>
    <span class="koboSpan" id="kobo.928.1">
     Next, add Kubernetes clusters running in OpenStack and AWS clouds to the joined Federation context.
    </span>
    <span class="koboSpan" id="kobo.928.2">
     Let’s start by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.929.1">
      adding AWS:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.930.1">
$ kubefed join aws --host-cluster-context=juju-controller-fed</span></pre>
   <p>
    <span class="koboSpan" id="kobo.931.1">
     The output is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.932.1">
      as follows:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer248">
     <span class="koboSpan" id="kobo.933.1">
      <img alt="Figure 11.34 – Joining an AWS K8s cluster to the federation" src="image/B21716_11_34.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.934.1">
     Figure 11.34 – Joining an AWS K8s cluster to the federation
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.935.1">
     The next command line will join the Kubernetes cluster running
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.936.1">
      on OpenStack:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.937.1">
 $ kubefed join awesome-openstack \
    --host-cluster-context=jujucontroller-fed</span></pre>
   <p>
    <span class="koboSpan" id="kobo.938.1">
     This is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.939.1">
      the output:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer249">
     <span class="koboSpan" id="kobo.940.1">
      <img alt="Figure 11.35 – Joining an OpenStack K8s cluster to the federation" src="image/B21716_11_35.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.941.1">
     Figure 11.35 – Joining an OpenStack K8s cluster to the federation
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.942.1">
     Both previous command lines will add the necessary configuration in the Federation control plane so we can interact with the new construct through the Federating API
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.943.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.944.1">
$ kubectl get clusters</span></pre>
   <p>
    <span class="koboSpan" id="kobo.945.1">
     The output is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.946.1">
      as follows:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer250">
     <span class="koboSpan" id="kobo.947.1">
      <img alt="Figure 11.36 – Listing federated K8s clusters running in OpenStack and AWS" src="image/B21716_11_36.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.948.1">
     Figure 11.36 – Listing federated K8s clusters running in OpenStack and AWS
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.949.1">
     At this level, we have constructed a few federated Kubernetes clusters running in public AWS and private OpenStack clouds.
    </span>
    <span class="koboSpan" id="kobo.949.2">
     Further operations on both clusters can be performed using the standard Kubernetes APIs.
    </span>
    <span class="koboSpan" id="kobo.949.3">
     This federation enables the deployment of all the
    </span>
    <a id="_idIndexMarker1112">
    </a>
    <span class="koboSpan" id="kobo.950.1">
     Kubernetes primitives such as namespaces, services, deployments, ConfigMaps, and so on.
    </span>
    <span class="koboSpan" id="kobo.950.2">
     For example, through the same
    </span>
    <a id="_idIndexMarker1113">
    </a>
    <span class="koboSpan" id="kobo.951.1">
     federating endpoint, we can deploy a Kubernetes namespace that will be spread across the hybrid cloud environment.
    </span>
    <span class="koboSpan" id="kobo.951.2">
     Let’s create a new YAML namespace called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.952.1">
      fed-ns.yaml
     </span>
    </strong>
    <span class="koboSpan" id="kobo.953.1">
     with the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.954.1">
      following content:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.955.1">
apiVersion: v1
kind: Namespace
metadata:
  name: fed-ns</span></pre>
   <p>
    <span class="koboSpan" id="kobo.956.1">
     Then, run the following command line to create the namespace in the federating context
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.957.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.958.1">
$ kubectl --context= hybridfed create –f fed-ns.yaml</span></pre>
   <p>
    <span class="koboSpan" id="kobo.959.1">
     Here is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.960.1">
      the output:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer251">
     <span class="koboSpan" id="kobo.961.1">
      <img alt="Figure 11.37 – Creating a federated K8s namespace" src="image/B21716_11_37.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.962.1">
     Figure 11.37 – Creating a federated K8s namespace
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.963.1">
     Let’s look at the creation of the namespace in both the AWS and OpenStack worlds.
    </span>
    <span class="koboSpan" id="kobo.963.2">
     Starting with AWS, simply switch the context by getting the list of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.964.1">
      deployed namespaces:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.965.1">
$ kubectl --context=aws get ns</span></pre>
   <p>
    <span class="koboSpan" id="kobo.966.1">
     The following is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.967.1">
      the output:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer252">
     <span class="koboSpan" id="kobo.968.1">
      <img alt="Figure 11.38 – Listing the namespace for the K8s context running in AWS" src="image/B21716_11_38.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.969.1">
     Figure 11.38 – Listing the namespace for the K8s context running in AWS
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.970.1">
     Similarly, run the same command line but switch to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.971.1">
      OpenStack context:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.972.1">
$ kubectl --context=awesome-openstack get ns</span></pre>
   <p>
    <span class="koboSpan" id="kobo.973.1">
     Here is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.974.1">
      the output:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer253">
     <span class="koboSpan" id="kobo.975.1">
      <img alt="Figure 11.39 – Listing the namespace for the K8s context running in OpenStack" src="image/B21716_11_39.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.976.1">
     Figure 11.39 – Listing the namespace for the K8s context running in OpenStack
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.977.1">
     Congratulations!
    </span>
    <span class="koboSpan" id="kobo.977.2">
     Our federation is ready to handle workloads in a hybrid setup across the OpenStack
    </span>
    <a id="_idIndexMarker1114">
    </a>
    <span class="koboSpan" id="kobo.978.1">
     and AWS clouds.
    </span>
    <span class="koboSpan" id="kobo.978.2">
     Deploying services and
    </span>
    <a id="_idIndexMarker1115">
    </a>
    <span class="koboSpan" id="kobo.979.1">
     Pods will only require creating them via the federating context, and the federation controller will take care of sharing the services on both the private and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.980.1">
      public clouds.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-194">
    <a id="_idTextAnchor239">
    </a>
    <span class="koboSpan" id="kobo.981.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.982.1">
     This chapter explored more cloud opportunities with OpenStack.
    </span>
    <span class="koboSpan" id="kobo.982.2">
     Leveraging container technology to deploy workloads across multiple cloud environments has been adopted by several organizations that seek the best usage of the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.983.1">
      cloud
     </span>
    </em>
    <span class="koboSpan" id="kobo.984.1">
     paradigm.
    </span>
    <span class="koboSpan" id="kobo.984.2">
     This chapter highlighted some of the adopted approaches to deploying a hybrid cloud based on containers.
    </span>
    <span class="koboSpan" id="kobo.984.3">
     The decentralized model can be considered a simple version of the centralized one where cloud operators can deploy workloads in multiple cloud environments.
    </span>
    <span class="koboSpan" id="kobo.984.4">
     With the centralized model, firing one deployment from one place propagates a workload across multiple environments.
    </span>
    <span class="koboSpan" id="kobo.984.5">
     The chapter demonstrated a use case of a hybrid model between AWS and OpenStack.
    </span>
    <span class="koboSpan" id="kobo.984.6">
     Both worlds can meet, and having the capability to move between both cloud platforms is a great
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.985.1">
      cloudy power
     </span>
    </em>
    <span class="koboSpan" id="kobo.986.1">
     .
    </span>
    <span class="koboSpan" id="kobo.986.2">
     Containerization allows companies to deploy, manage, and scale their workloads in more than a cloud environment, as we learned in this chapter.
    </span>
    <span class="koboSpan" id="kobo.986.3">
     Federation mode has proven to be a rapid, reliable, and zero-touch way to operate workloads managed by Kubernetes, which we also learned about in this chapter.
    </span>
    <span class="koboSpan" id="kobo.986.4">
     We further learned that OpenStack did not miss the chance again, and that with the rise of hybrid cloud adoption over the last few years, OpenStack has come to light.
    </span>
    <span class="koboSpan" id="kobo.986.5">
     Due to the maturity of its ecosystem and rich set of APIs, OpenStack has become in demand to manage private cloud infrastructure.
    </span>
    <span class="koboSpan" id="kobo.986.6">
     We learned that the marriage of both private and public clouds has, so far, been a successful experience.
    </span>
    <span class="koboSpan" id="kobo.986.7">
     Let’s keep it
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.987.1">
      cloudy
     </span>
    </em>
    <span class="koboSpan" id="kobo.988.1">
     , where OpenStack
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.989.1">
      keeps
     </span>
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.990.1">
       shining
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.991.1">
      .
     </span>
    </span>
   </p>
  </div>
 </body></html>