<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;9.&#xA0;OpenStack Orchestration Using Heat and Ansible" id="3BOFI1-189e69df43a248268db97cde1b1a8e47"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09" class="calibre1"/>Chapter 9. OpenStack Orchestration Using Heat and Ansible</h1></div></div></div><p class="calibre10">In this chapter, we will cover the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Introduction – orchestrating with OpenStack</li><li class="listitem">Creating your first stack with Heat</li><li class="listitem">Launching your stack with Heat</li><li class="listitem">Viewing the resources and output of a stack created with Heat</li><li class="listitem">Deleting a Heat stack</li><li class="listitem">Updating a Heat stack</li><li class="listitem">Installing and configuring Ansible for OpenStack</li><li class="listitem">Using Ansible to launch instances</li><li class="listitem">Using Ansible to orchestrate software installation</li><li class="listitem">Using Ansible to orchestrate software installations across multiple instances</li><li class="listitem">Using Ansible to fully orchestrate the creation of a web server and load balancer stack</li></ul></div></div>

<div class="book" title="Chapter&#xA0;9.&#xA0;OpenStack Orchestration Using Heat and Ansible" id="3BOFI1-189e69df43a248268db97cde1b1a8e47">
<div class="book" title="Introduction – orchestrating with OpenStack"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch09lvl1sec110" class="calibre1"/>Introduction – orchestrating with OpenStack</h1></div></div></div><p class="calibre10">OpenStack is <a id="id500" class="calibre1"/>chosen as a platform for many reasons, but one that frequently tops the list is orchestration. Without an element of orchestration in your OpenStack environment, you have a powerful turbo engine car that is just used for the school-run. As with any cloud environment, there are various tools to help with your orchestrated workloads, but out of the box, OpenStack provides Heat, the orchestration engine.</p><p class="calibre10">With Heat, you can define rich environments in a template, such as a multi-tier web application, which allows users consistency in launching these relatively complex deployments. I view the Heat orchestration templates (known as <span class="strong"><strong class="calibre2">HOT</strong></span> (<span class="strong"><strong class="calibre2">Heat Orchestration Template</strong></span>) – get it?) as a recipe that is written in <span class="strong"><strong class="calibre2">YAML</strong></span> (<span class="strong"><strong class="calibre2">Yet Another Markup Language</strong></span>). You define your ingredients that make up the environment. In a cooking recipe, this would be listing the amount of chocolate, flour, and sugar that is required for something like a cake. In a HOT ()file, this is the parameters section. You define the flavor of instances, the images used, and what networks the instances should launch against.</p><p class="calibre10">Like any <a id="id501" class="calibre1"/>good recipe, you can override these defaults—so if you fancy experimenting with jam instead of chocolate sauce, or varying the amount of sugar required—you can adjust these. Also, with Heat you do this in an environment file. This file is laid out as though you're assigning values to the parameters. For example, an input parameter in the HOT file might be <code class="email">image_name</code>, and in an environment file, you assign <code class="email">image_name=ubuntu-image</code>.</p><p class="calibre10">The next section in the HOT file is the largest and most complex as it is the method section of the recipe – the "how all the ingredients create a cake" section. In Heat, this is the start of the resources section. The resources section describes how the instances interact with each other. For example, a load balancer might get created during the Heat run that includes three web servers. The load balancer resources would have a method to attach these three unknown web servers to the load balance pool for that resource to be complete.</p><p class="calibre10">The final section is the output section. In a cooking recipe, you'd be taking the cake out of the oven. In OpenStack, this will be the end result—your multi-tier web application. However, with OpenStack and the nature of launching a number of instances into an environment that may not have even had a network created at that point, it would be hard to know the IP addresses that have been used, which may be needed in order to access the deployed stack. So, for this, we have the output section where a user of OpenStack can interrogate the stack and get useful information so that the launched stack is usable.</p><p class="calibre10">However, we are not limited to using the Heat orchestration engine within OpenStack when it comes to instance and application life cycle management. As introduced in <a class="calibre1" title="Chapter 1. Installing OpenStack with Ansible" href="part0014_split_000.html#DB7S2-189e69df43a248268db97cde1b1a8e47">Chapter 1</a>, <span class="strong"><em class="calibre18">Installing OpenStack with Ansible</em></span>, Ansible is a great example of a platform independent tool that we can use to help orchestrate tasks. Using Ansible modules specific to the target environment, such as OpenStack, we can launch instances and perform software installations in a structured way that may suit users of both OpenStack and other cloud environments.</p><p class="calibre10">The basic structure of Ansible is quite straightforward. In its simplest form, it has a notion of playbooks, plays, and tasks. If you study the OpenStack-Ansible playbooks that were described in <a class="calibre1" title="Chapter 1. Installing OpenStack with Ansible" href="part0014_split_000.html#DB7S2-189e69df43a248268db97cde1b1a8e47">Chapter 1</a>, <span class="strong"><em class="calibre18">Installing OpenStack with Ansible</em></span> you'll get an insight into advanced features not covered in this chapter, which allow you to extend your OpenStack-based cloud environments into fully orchestrated masterpieces!</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Creating your first stack" id="3CN041-189e69df43a248268db97cde1b1a8e47"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec111" class="calibre1"/>Creating your first stack</h1></div></div></div><p class="calibre10">With Heat, we can create a wide variety of templates from spinning up basic instances, to creating <a id="id502" class="calibre1"/>complete environments for an application. In this section, we will show the basics of Heat by spinning up an instance and attaching it to an existing Neutron network, and assigning a floating IP to it. Heat templates describe the resources being used, the type and size of the instances, the network an instance will be attached to, among other pieces of information required to run that environment.</p><p class="calibre10">In this section, we will show you how to use a HOT file to spin up two web servers running Apache, connected behind a third instance running HAProxy acting as the load balancer.</p></div>

<div class="book" title="Creating your first stack" id="3CN041-189e69df43a248268db97cde1b1a8e47">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec332" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre10">Ensure that you are logged onto a correctly configured OpenStack client and can access the OpenStack environment. Refer to <a class="calibre1" title="Chapter 2. The OpenStack Client" href="part0024_split_000.html#MSDG1-189e69df43a248268db97cde1b1a8e47">Chapter 2</a>, <span class="strong"><em class="calibre18">The OpenStack Client</em></span>, for details of setting up your environment to use Heat.</p></div></div>

<div class="book" title="Creating your first stack" id="3CN041-189e69df43a248268db97cde1b1a8e47">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec333" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre10">In this <a id="id503" class="calibre1"/>section, we will download a HOT file called <code class="email">cookbook.yaml</code>, which will describe our instance and the network to attach it to:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, we download the HOT file from the Cookbook GitHub repository:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">wget -O cookbook.yaml </strong></span>
<span class="strong"><strong class="calibre2">https://raw.githubusercontent.com/OpenStackCookbook/OpenStackCookbook/master/cookbook.yaml</strong></span>
</pre></div></li><li class="listitem" value="2">Heat takes input parameters from the command line, or from an environment file, which get passed to the template. These parameters are seen at the top of the HOT file, as shown here:<div class="informalexample"><pre class="programlisting">parameters:
  key_name:
    type: string
    description: Name of keypair to assign to servers
  image:
    type: string
    description: Name of image to use for servers
  flavor:
    type: string
    description: Flavor to use for servers
  public_net_id:
    type: string
    description: &gt;
      ID of public network for which floating IP addresses will be allocated
  private_net_id:
    type: string
    description: ID of private network into which servers get deployed
  private_subnet_id:
    type: string
    description: ID of private sub network into which servers get deployed</pre></div></li><li class="listitem" value="3">As can <a id="id504" class="calibre1"/>be seen, we expect to pass in various parameters when we launch this template. Ensure that we have these details by running the following commands:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">openstack keypair list</strong></span>
<span class="strong"><strong class="calibre2">openstack image list</strong></span>
<span class="strong"><strong class="calibre2">openstack flavor list</strong></span>
<span class="strong"><strong class="calibre2">openstack network list</strong></span>
</pre></div><p class="calibre22">The <code class="email">openstack network list</code> output may look like the following:</p><div class="mediaobject"><img src="../images/00166.jpeg" alt="How to do it..." class="calibre16"/></div><p class="calibre23"> </p></li><li class="listitem" value="4">With the information at hand, we create an environment file that will be used to store our parameters that we will pass to the HOT file when we launch the stack. Create <code class="email">cookbook-env.yaml</code> in the same directory as <code class="email">cookbook.yaml</code> with the following contents based on the output of the previous commands (adjust to suit your environment):<div class="informalexample"><pre class="programlisting">parameters:
  key_name: demokey
  image: xenial-image
  flavor: m1.tiny
  public_net_id: 2da8979e-dcf8-4eb8-b207-f33bfce4a15a
  private_net_id: 78a5a119-c27a-41c4-8310-5c04d3a6bc31
  private_subnet_id: 3cee2bb9-5673-4a6e-bb1e-8cb66be066b2</pre></div></li></ol><div class="calibre20"/></div></div></div>

<div class="book" title="Creating your first stack" id="3CN041-189e69df43a248268db97cde1b1a8e47">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec334" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre10">Heat Orchestration Templates (HOT) are YAML files that describe our environment, or "Stacks" as they're known. The basic templates generally have the following structure:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">description:</code></li><li class="listitem"><code class="email">parameters:</code></li><li class="listitem"><code class="email">resources:</code></li><li class="listitem"><code class="email">outputs:</code></li></ul></div><p class="calibre10">The <code class="email">description:</code> section has a number of words that helps a user understand what is expected to occur when the template is used.</p><p class="calibre10">The <code class="email">parameters:</code> section defines the input variables, for example, the type of image(s) to be used, the network(s) to attach the instances on, and the key pair name to associate with the instances. Parameters are arbitrary and can contain any information needed to execute the template properly. The parameters: section works directly with the information found in the accompanying environment file (as specified by the <code class="email">--environment</code> parameter). Each parameter <a id="id505" class="calibre1"/>must either have a default value or be specified in the environment file for the stack to launch successfully.</p><p class="calibre10">The <code class="email">resources:</code> section is usually the biggest section as it describes the environment. It can describe the instances that will be used, the naming of them, which networks to attach, and essentially how all of the elements relate to each other and how the environment is orchestrated. Explanations of how best to write these resources are beyond the scope of this book.</p><p class="calibre10">The <code class="email">outputs:</code> section refers to the "return" values from running the stack. For example, a user will need to know how to access a particular stack that has just been created. Random IPs and hostnames can all be assigned as normal operation of running stacks, so being able to interrogate the right information in order to access the environment is a must.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Launching your stack with Heat" id="3DLGM1-189e69df43a248268db97cde1b1a8e47"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec112" class="calibre1"/>Launching your stack with Heat</h1></div></div></div><p class="calibre10">To launch <a id="id506" class="calibre1"/>a Heat stack we need three things: a <span class="strong"><em class="calibre18">name</em></span> for the stack, the <span class="strong"><em class="calibre18">template</em></span> (HOT) that describes the deployment, and finally, the <span class="strong"><em class="calibre18">environment file</em></span> that fills in the blanks of the input parameters.</p></div>

<div class="book" title="Launching your stack with Heat" id="3DLGM1-189e69df43a248268db97cde1b1a8e47">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec335" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre10">Ensure that you are logged on to a correctly configured OpenStack client and can access the OpenStack environment. Refer to <a class="calibre1" title="Chapter 2. The OpenStack Client" href="part0024_split_000.html#MSDG1-189e69df43a248268db97cde1b1a8e47">Chapter 2</a>, <span class="strong"><em class="calibre18">The OpenStack Client</em></span>, for details of setting up your environment to use OpenStack.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip81" class="calibre1"/>Tip</h3><p class="calibre10">If you get the <code class="email">openstack: 'stack' is not an openstack</code> command, refer to <code class="email">openstack --help</code>.</p><p class="calibre10">Ensure that the <code class="email">python-heatclient</code> package is installed:</p><p class="calibre10">
<code class="email">sudo -H pip install python-heatclient</code>
</p></div><p class="calibre10">Also ensure that you have downloaded the example <code class="email">cookbook.yaml</code> Heat template and have created the environment file, as described in the previous recipe.</p></div></div>

<div class="book" title="Launching your stack with Heat" id="3DLGM1-189e69df43a248268db97cde1b1a8e47">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec336" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre10">In this <a id="id507" class="calibre1"/>section, we will download a HOT file called <code class="email">cookbook.yaml</code>, which will describe our instance and the network to attach it to:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">We will launch the stack with the following commands:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">openstack stack create myStack</strong></span>
<span class="strong"><strong class="calibre2">    --template cookbook.yaml</strong></span>
<span class="strong"><strong class="calibre2">    --environment cookbook-env.yaml</strong></span>
</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip82" class="calibre1"/>Tip</h3><p class="calibre10">
<span class="strong"><strong class="calibre2">Tip</strong></span>: You can use the <code class="email">-t</code> flags instead of <code class="email">--template</code>, and <code class="email">-e</code> instead of <code class="email">--environment</code>.</p></div><p class="calibre22">This will produce an output like the following:</p><div class="mediaobject"><img src="../images/00167.jpeg" alt="How to do it..." class="calibre16"/></div><p class="calibre23"> </p></li><li class="listitem" value="2">To view a list of stacks, execute the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">openstack stack list</strong></span>
</pre></div><p class="calibre22">This will bring back a list of stacks currently running:</p><div class="mediaobject"><img src="../images/00168.jpeg" alt="How to do it..." class="calibre16"/></div><p class="calibre23"> </p></li></ol><div class="calibre20"/></div><p class="calibre10">Note <span class="strong"><strong class="calibre2">Stack Status</strong></span>. A successful launch is when it is marked as <span class="strong"><strong class="calibre2">CREATE_COMPLETE</strong></span>.</p></div></div>

<div class="book" title="Launching your stack with Heat" id="3DLGM1-189e69df43a248268db97cde1b1a8e47">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec337" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre10">Launching <a id="id508" class="calibre1"/>a stack is simple. We will specify the HOT file with the <code class="email">--template</code> parameter, and then we will specify the inputs that get described in the template in a file that we specify with the <code class="email">--environment</code> parameter.</p><p class="calibre10">The syntax is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">openstack stack create nameOfStack</strong></span>
<span class="strong"><strong class="calibre2">    --template template.yaml</strong></span>
<span class="strong"><strong class="calibre2">    --environment template-env.yaml</strong></span>
</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note52" class="calibre1"/>Note</h3><p class="calibre10">Note that the name of the stack must be unique in your project.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Viewing the resources and output of a stack created with Heat" id="3EK181-189e69df43a248268db97cde1b1a8e47"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec113" class="calibre1"/>Viewing the resources and output of a stack created with Heat</h1></div></div></div><p class="calibre10">A stack <a id="id509" class="calibre1"/>is an orchestrated set of services, where the user launching the stack shouldn't care too much about what IP addresses were assigned. However, the application stack has been launched to serve a purpose and therefore <a id="id510" class="calibre1"/>it is helpful to know how to access it! To access the environment, the user interrogates the "outputs" of the stack, which were defined as part of the template. In this example, we are concerned about how to access the website running behind the HAProxy server. The HAProxy server has been assigned a floating IP from the GATEWAY_NET network, and it is assumed that this is how the application will be accessed.</p></div>

<div class="book" title="Viewing the resources and output of a stack created with Heat" id="3EK181-189e69df43a248268db97cde1b1a8e47">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec338" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre10">Ensure that you are logged on to a correctly configured OpenStack client and can access the OpenStack environment. Refer to <a class="calibre1" title="Chapter 2. The OpenStack Client" href="part0024_split_000.html#MSDG1-189e69df43a248268db97cde1b1a8e47">Chapter 2</a>, <span class="strong"><em class="calibre18">The OpenStack Client</em></span>, for details of setting up your environment to use Heat.</p></div></div>

<div class="book" title="Viewing the resources and output of a stack created with Heat" id="3EK181-189e69df43a248268db97cde1b1a8e47">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec339" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre10">To view the application stack and get information about how to access it, carry out the following <a id="id511" class="calibre1"/>steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">You can <a id="id512" class="calibre1"/>view more details of a stack using the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">openstack stack show myStack</strong></span>
</pre></div><p class="calibre22">This will bring back a number of details about the created stack:</p><div class="mediaobject"><img src="../images/00169.jpeg" alt="How to do it..." class="calibre16"/></div><p class="calibre23"> </p></li><li class="listitem" value="2">A section in the template references <span class="strong"><em class="calibre18">outputs</em></span>. Outputs allow a user to interrogate these values so that they can access the running stack. Without this, the user would have to do more digging into the running systems to find out what IP addresses were assigned to the instances that make up the stack. To see a list of outputs associated with our running stack, execute the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">openstack stack output list myStack</strong></span>
</pre></div><p class="calibre22">This will bring back the following output:</p><div class="mediaobject"><img src="../images/00170.jpeg" alt="How to do it..." class="calibre16"/></div><p class="calibre23"> </p></li><li class="listitem" value="3">To view <a id="id513" class="calibre1"/>a particular value, such as the public IP (<span class="strong"><em class="calibre18">floating IP</em></span>) assigned to our HAProxy instance, we can access the <a id="id514" class="calibre1"/>websites that are running on private addresses behind the load balancer. To do so, issue the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">openstack stack output show myStack haproxy_public_ip</strong></span>
</pre></div><p class="calibre22">This gives the IP address that we would then use to access this particular service set up as a stack:</p><div class="mediaobject"><img src="../images/00171.jpeg" alt="How to do it..." class="calibre16"/></div><p class="calibre23"> </p></li><li class="listitem" value="4">In this example application stack, we can then use the <code class="email">http://192.168.100.108/</code> address, which will send the request to either of the web servers that are running, configured as part of this HAProxy load balancer demonstration.</li></ol><div class="calibre20"/></div></div></div>

<div class="book" title="Viewing the resources and output of a stack created with Heat" id="3EK181-189e69df43a248268db97cde1b1a8e47">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec340" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre10">A stack is designed to take a number of inputs, performs some actions, and produces a number of instances running an application ready for service. However, this hands-off approach <a id="id515" class="calibre1"/>means a lot of decisions are automatically dictated by OpenStack—predominantly because the instances get served from <a id="id516" class="calibre1"/>DHCP-enabled subnets. In order to find out the state of the stack and information about how to access the stack, a user would interrogate the <span class="strong"><strong class="calibre2">outputs</strong></span>, which were described in the template. In the example template, the output section looks like the following:</p><div class="informalexample"><pre class="programlisting">outputs:
  webserver1_private_ip:
    description: IP address of webserver1 in private network
    value: { get_attr: [ webserver1, first_address ] }
  webserver2_private_ip:
    description: IP address of webserver2 in private network
    value: { get_attr: [ webserver2, first_address ] }
  haproxy_public_ip:
    description: Floating IP address of haproxy in public network
    value: { get_attr: [ haproxy_floating_ip, floating_ip_address ] }</pre></div><p class="calibre10">The outputs that have more information are labelled as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">webserver1_private_ip</code></li><li class="listitem"><code class="email">webserver2_private_ip</code></li><li class="listitem"><code class="email">haproxy_public_ip</code></li></ul></div><p class="calibre10">In this recipe, we specifically targeted <code class="email">haproxy_public_ip</code>, as this is how we would access the web service that we created. We issued the following command to do this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">openstack stack output show myStack haproxy_public_ip</strong></span>
</pre></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Deleting a Heat stack" id="3FIHQ1-189e69df43a248268db97cde1b1a8e47"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec114" class="calibre1"/>Deleting a Heat stack</h1></div></div></div><p class="calibre10">To delete <a id="id517" class="calibre1"/>a running Heat stack we will make a simple call as shown in this recipe.</p></div>

<div class="book" title="Deleting a Heat stack" id="3FIHQ1-189e69df43a248268db97cde1b1a8e47">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec341" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre10">Ensure that you are logged on to a correctly configured OpenStack client and can access the OpenStack environment. Refer to <a class="calibre1" title="Chapter 2. The OpenStack Client" href="part0024_split_000.html#MSDG1-189e69df43a248268db97cde1b1a8e47">Chapter 2</a>, <span class="strong"><em class="calibre18">The OpenStack Client</em></span> for details of setting up your environment to use OpenStack.</p></div></div>

<div class="book" title="Deleting a Heat stack" id="3FIHQ1-189e69df43a248268db97cde1b1a8e47">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec342" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre10">In this section, we'll show how to delete a stack.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">To delete a running stack named <code class="email">myStack</code>, issue the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">openstack stack delete myStack</strong></span>
</pre></div></li><li class="listitem" value="2">You will be prompted to confirm this deletion, as shown here. Type <code class="email">y</code> to continue destroying the stack:<div class="mediaobject"><img src="../images/00172.jpeg" alt="How to do it..." class="calibre16"/></div><p class="calibre23"> </p></li><li class="listitem" value="3">You can check on the status of the deletion by listing the created stacks:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">openstack stack list</strong></span>
</pre></div><p class="calibre22">This will bring back an empty list if there is no stack to show or the following during deletion:</p><div class="mediaobject"><img src="../images/00173.jpeg" alt="How to do it..." class="calibre16"/></div><p class="calibre23"> </p></li></ol><div class="calibre20"/></div></div></div>

<div class="book" title="Deleting a Heat stack" id="3FIHQ1-189e69df43a248268db97cde1b1a8e47">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec343" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre10">In very <a id="id518" class="calibre1"/>much the same way that we can launch a stack easily, deleting one is achieved by simply specifying which stack we want to destroy and using the <code class="email">stack delete</code> command.</p><p class="calibre10">If you prefer to destroy a stack without confirmation, use the following syntax:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">openstack stack delete nameOfStack -y</strong></span>
</pre></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Updating a Heat stack" id="3GH2C1-189e69df43a248268db97cde1b1a8e47"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec115" class="calibre1"/>Updating a Heat stack</h1></div></div></div><p class="calibre10">Our running <a id="id519" class="calibre1"/>Stack is based on templates, so this allows us to modify our application stack by altering the inputs. If we wanted to change the size of a flavor, or the key used, you can trigger a rebuild of the instances in the stack by altering the inputs and issuing the <code class="email">stack update</code> command.</p></div>

<div class="book" title="Updating a Heat stack" id="3GH2C1-189e69df43a248268db97cde1b1a8e47">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec344" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre10">Ensure that you are logged on to a correctly configured OpenStack client and can access the OpenStack environment. Refer to <a class="calibre1" title="Chapter 2. The OpenStack Client" href="part0024_split_000.html#MSDG1-189e69df43a248268db97cde1b1a8e47">Chapter 2</a>, <span class="strong"><em class="calibre18">The OpenStack Client</em></span>, for details of setting up your environment to use OpenStack.</p></div></div>

<div class="book" title="Updating a Heat stack" id="3GH2C1-189e69df43a248268db97cde1b1a8e47">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec345" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre10">In this <a id="id520" class="calibre1"/>section, we'll modify the environment file to change a flavor from <code class="email">m1.tiny</code> to <code class="email">m1.large</code>. (Ensure that you have a valid flavor with this name before continuing!)</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">We first edit the environment file, called <code class="email">cookbook-env.yaml</code>, to show the changes we want to make to our running stack:<div class="informalexample"><pre class="programlisting">parameters:
  key_name: demokey
  image: xenial-image
  <span class="strong"><strong class="calibre2">flavor: m1.large</strong></span>
  public_net_id: 2da8979e-dcf8-4eb8-b207-f33bfce4a15a
  private_net_id: 78a5a119-c27a-41c4-8310-5c04d3a6bc31
  private_subnet_id: 3cee2bb9-5673-4a6e-bb1e-8cb66be066b2</pre></div></li><li class="listitem" value="2">Ensure that the stack is running without issues by viewing the resources:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">openstack stack show myStack</strong></span>
</pre></div><p class="calibre22">This will bring back an output like the following:</p><div class="mediaobject"><img src="../images/00169.jpeg" alt="How to do it..." class="calibre16"/></div><p class="calibre23"> </p></li><li class="listitem" value="3">We will <a id="id521" class="calibre1"/>now use the updated environment file to modify the running stack:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">openstack stack update myStack --existing</strong></span>
</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip83" class="calibre1"/>Tip</h3><p class="calibre10">Tip: We're using the parameter <span class="strong"><strong class="calibre2">--existing</strong></span> to avoid specifying the template and environment file again.</p></div><p class="calibre22">This will bring back an output like the following, showing the update has started:</p><div class="mediaobject"><img src="../images/00174.jpeg" alt="How to do it..." class="calibre16"/></div><p class="calibre23"> </p></li><li class="listitem" value="4">Also we <a id="id522" class="calibre1"/>can view the state of the stack once this has been completed, to show the reflected change:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">openstack stack show myStack</strong></span>
</pre></div><p class="calibre22">This will bring back an output like the following (note that the flavor has changed from <code class="email">m1.tiny</code> to <code class="email">m1.large</code>). Also note that the IP addresses have not changed:</p><div class="mediaobject"><img src="../images/00175.jpeg" alt="How to do it..." class="calibre16"/></div><p class="calibre23"> </p></li></ol><div class="calibre20"/></div></div></div>

<div class="book" title="Updating a Heat stack" id="3GH2C1-189e69df43a248268db97cde1b1a8e47">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec346" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre10">The OpenStack <a id="id523" class="calibre1"/>Orchestration service, Heat, is designed to follow a template to provide a running service to end users. Everything is automated from start to finish. This crucial feature allows us to update a running stack, effectively redeploying the stack with updates, which runs through the fully automated routine to restore the service, on the same IP addresses, but with the required changes.</p><p class="calibre10">The syntax for updating the stack is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">openstack stack update nameOfStack</strong></span>
<span class="strong"><strong class="calibre2">    --environment updatedEnvironmentFile.yaml</strong></span>
<span class="strong"><strong class="calibre2">    --template originalStackTemplate.yml</strong></span>
</pre></div><p class="calibre10">In our example, we omitted the <code class="email">--environment</code> and <code class="email">--template</code> parameters as we made the <a id="id524" class="calibre1"/>required change to our stack directly in the environment file used originally. This allowed for a simpler syntax:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">openstack stack update nameOfStack --existing</strong></span>
</pre></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Installing and configuring Ansible for OpenStack" id="3HFIU1-189e69df43a248268db97cde1b1a8e47"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec116" class="calibre1"/>Installing and configuring Ansible for OpenStack</h1></div></div></div><p class="calibre10">Ansible has <a id="id525" class="calibre1"/>relatively few prerequisites that are not installed on most Linux- and macOS-based systems. However, there are a few steps to <a id="id526" class="calibre1"/>follow before we can use Ansible for managing our OpenStack environment.</p></div>

<div class="book" title="Installing and configuring Ansible for OpenStack" id="3HFIU1-189e69df43a248268db97cde1b1a8e47">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec347" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre10">Ensure that you are logged on to a correctly configured OpenStack client and can access the OpenStack environment. Refer to <a class="calibre1" title="Chapter 2. The OpenStack Client" href="part0024_split_000.html#MSDG1-189e69df43a248268db97cde1b1a8e47">Chapter 2</a>, <span class="strong"><em class="calibre18">The OpenStack Client</em></span>, for details of setting up your environment to use OpenStack.</p><p class="calibre10">The version of Ansible 2.x requires Python 2.6 or 2.7. Most modern Linux distributions and macOS/OS X have this already installed. If you were able to successfully execute the <code class="email">openstack</code> commands as described in <a class="calibre1" title="Chapter 2. The OpenStack Client" href="part0024_split_000.html#MSDG1-189e69df43a248268db97cde1b1a8e47">Chapter 2</a>, <span class="strong"><em class="calibre18">The OpenStack Client</em></span>, then you're good to go here.</p><p class="calibre10">You may <a id="id527" class="calibre1"/>need to install Shade. Shade is a simple client library for interacting with OpenStack clouds. Red Hat and CentOS environments don't have this installed by default. Install it with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">sudo pip install shade</strong></span>
</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note53" class="calibre1"/>Note</h3><p class="calibre10">Be aware that Shade may pull in other dependencies that may break your environment. It is suggested that you use a <span class="strong"><strong class="calibre2">virtual environment</strong></span> (<span class="strong"><strong class="calibre2">venv</strong></span>) to avoid this issue.</p></div></div></div>

<div class="book" title="Installing and configuring Ansible for OpenStack" id="3HFIU1-189e69df43a248268db97cde1b1a8e47">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec348" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre10">As we're performing this on our client machine, ensure that you have the necessary permissions to install software. When ready, carry out the following steps depending on your chosen operating system.</p><div class="book" title="Ubuntu"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec30" class="calibre1"/>Ubuntu</h3></div></div></div><p class="calibre10">For Ubuntu, <a id="id528" class="calibre1"/>we can use the Ansible PPA as follows:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, ensure that we can add <span class="strong"><strong class="calibre2">PPA</strong></span> (<span class="strong"><strong class="calibre2">Personal Package Archives</strong></span>) by installing the following tool:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">sudo apt-get install software-properties-common</strong></span>
</pre></div></li><li class="listitem" value="2">Next, we will add the PPA:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">sudo apt-add-repository ppa:ansible/ansible</strong></span>
</pre></div></li><li class="listitem" value="3">Finally, we will run the installation:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">sudo apt-get update</strong></span>
<span class="strong"><strong class="calibre2">sudo apt-get install ansible</strong></span>
</pre></div></li></ol><div class="calibre20"/></div></div><div class="book" title="macOS/OS X (and for those wanting to use pip)"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec31" class="calibre1"/>macOS/OS X (and for those wanting to use pip)</h3></div></div></div><p class="calibre10">For macOS, we <a id="id529" class="calibre1"/>can use pip as follows:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Ensure that <code class="email">pip</code> is available:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">sudo easy_install pip</strong></span>
</pre></div></li><li class="listitem" value="2">Next, use <code class="email">pip</code> to install Ansible:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">sudo pip install ansible</strong></span>
</pre></div></li></ol><div class="calibre20"/></div></div><div class="book" title="Verifying the installation"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec32" class="calibre1"/>Verifying the installation</h3></div></div></div><p class="calibre10">To verify <a id="id530" class="calibre1"/>the installation, issue the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">ansible --version</strong></span>
</pre></div><p class="calibre10">This should produce an output like the following:</p><div class="mediaobject"><img src="../images/00176.jpeg" alt="Verifying the installation" class="calibre16"/></div><p class="calibre17"> </p></div></div></div>

<div class="book" title="Installing and configuring Ansible for OpenStack" id="3HFIU1-189e69df43a248268db97cde1b1a8e47">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec349" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre10">In order for us to be able to use Ansible to manage our OpenStack environment, we must ensure that we have a good working Ansible set up. The preceding steps merely helped us install Ansible onto our client using the tools available for that operating system.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Using Ansible to launch instances" id="3IE3G1-189e69df43a248268db97cde1b1a8e47"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec117" class="calibre1"/>Using Ansible to launch instances</h1></div></div></div><p class="calibre10">Launching an <a id="id531" class="calibre1"/>instance using Ansible is a convenient, platform agnostic method. While we have to specify how to do this for OpenStack, as a particular task, an Ansible playbook could be extended to allow a user to use the same Ansible command to launch an instance on any cloud. This recipe is a very basic introduction to the use of Ansible with OpenStack.</p></div>

<div class="book" title="Using Ansible to launch instances" id="3IE3G1-189e69df43a248268db97cde1b1a8e47">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec350" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre10">Ensure that you <a id="id532" class="calibre1"/>are logged on to a correctly configured OpenStack client and can access the OpenStack environment that has Ansible installed.</p></div></div>

<div class="book" title="Using Ansible to launch instances" id="3IE3G1-189e69df43a248268db97cde1b1a8e47">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec351" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre10">Ansible executes tasks in what is known as a playbook. In this example, we will create a simple task that launches a specific instance called <code class="email">cookbook1</code>:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">The first step is to create the Ansible playbook for our tasks that will launch our instance. Create the following file called <code class="email">launch-instance.yml</code> on your client, in a directory of your choosing:<div class="informalexample"><pre class="programlisting">- name: Launch instance on OpenStack
  hosts: localhost
  gather_facts: false
  tasks:
  - name: Deploy an instance
    os_server:
       state: present
       name: cookbook1
       image: xenial-image
       key_name: demokey
       timeout: 200
       flavor: m1.tiny
       network: private-net
       verify: false</pre></div></li><li class="listitem" value="2">Once that has been described, we will simply run that particular task using the <code class="email">ansible-playbook</code> command, as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">source openrc</strong></span>
<span class="strong"><strong class="calibre2">ansible-playbook launch-instance.yml</strong></span>
</pre></div><p class="calibre22">This will bring back the familiar Ansible output like the following:</p><div class="mediaobject"><img src="../images/00177.jpeg" alt="How to do it..." class="calibre16"/></div><p class="calibre23"> </p><div class="note" title="Note"><h3 class="title2"><a id="note54" class="calibre1"/>Note</h3><p class="calibre10">This is a <code class="email">localhost</code> task, so the warning can be ignored.</p></div></li><li class="listitem" value="3">We can verify that an instance was launched in OpenStack by viewing the server listing as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">openstack server list</strong></span>
</pre></div><p class="calibre22">This will bring back an output like the following:</p><div class="mediaobject"><img src="../images/00178.jpeg" alt="How to do it..." class="calibre16"/></div><p class="calibre23"> </p></li></ol><div class="calibre20"/></div><p class="calibre10">Note that <a id="id533" class="calibre1"/>the task automatically assigned a public floating IP address from the <code class="email">GATEWAY_NET</code> network. This is an important detail as Ansible can do much more than just launch instances. If we want to be able to install and configure instances, Ansible must be able to SSH from the client to the running instance. Private tenant networks are generally not accessible; therefore, Ansible would use the public routed network to access the instance, just like you would if you were to SSH to it.</p></div></div>

<div class="book" title="Using Ansible to launch instances" id="3IE3G1-189e69df43a248268db97cde1b1a8e47">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec352" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre10">Launching an instance using Ansible uses the <code class="email">os_server</code> Ansible module. This is available from Ansible 2.0 onwards. The <code class="email">os_server</code> module takes a number of parameters that describe the usual parameters you would expect when launching instances using the command line.</p><p class="calibre10">Note that we didn't specify any authentication details as part of the task. This is because this module interprets our shell environment variables, just like we would use when executing OpenStack client tools.</p><p class="calibre10">You will notice that one of the entries in the task denotes the following:</p><div class="informalexample"><pre class="programlisting">os_server:
  state: present</pre></div><p class="calibre10">This has a specific intent in Ansible, as Ansible is designed to give state consistency of running that task, despite how many times that task may get run. This simple statement basically says that this instance must be present. If not, it will launch that instance. Once it has <a id="id534" class="calibre1"/>launched, it satisfies that predicate. In the Ansible output, you will see that the overall run says <span class="strong"><strong class="calibre2">ok=1 changed=1</strong></span>. This means that it changes the state of this environment. In other words, it launched the instance (which is a change of state).</p><p class="calibre10">However, if we run the task again, we get the following subtle change in the output denoting that the task didn't need to run to satisfy the fact the instance needed to be "present" (that is, running):</p><div class="mediaobject"><img src="../images/00179.jpeg" alt="How it works..." class="calibre16"/></div><p class="calibre17"> </p><p class="calibre10">Note that the task executed successfully, but didn't need to change anything as denoted by the <span class="strong"><strong class="calibre2">changed=0</strong></span> output in the <span class="strong"><strong class="calibre2">PLAY RECAP</strong></span> line.</p></div></div>

<div class="book" title="Using Ansible to launch instances" id="3IE3G1-189e69df43a248268db97cde1b1a8e47">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec353" class="calibre1"/>See also</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">Visit <a class="calibre1" href="http://docs.ansible.com/ansible/latest/os_server_module.html">http://docs.ansible.com/ansible/latest/os_server_module.html</a> for more information</li><li class="listitem">For those who do not want to source environment variables into their playbooks using the <code class="email">source openrc</code> method, visit <a class="calibre1" href="https://docs.openstack.org/shade/latest/">https://docs.openstack.org/shade/latest/</a> to set up a <code class="email">clouds.yaml</code> cloud environment file</li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Using Ansible to orchestrate software installation"><div class="book" id="3JCK22-189e69df43a248268db97cde1b1a8e47"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec118" class="calibre1"/>Using Ansible to orchestrate software installation</h1></div></div></div><p class="calibre10">Launching <a id="id535" class="calibre1"/>an instance using Ansible doesn't provide a user much beyond consistency, in that a playbook describes the end state of the environment: every time a user runs the task, it will either need to launch that specific instance to ensure that it is present, or it will skip that task because the instance is already running. However, we can achieve a lot more with Ansible beyond just launching a virtual machine. In this recipe, we will launch another instance that will install and start Apache.</p></div>

<div class="book" title="Using Ansible to orchestrate software installation">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec354" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre10">Ensure that you are logged on to a correctly configured OpenStack client and can access the OpenStack environment that has Ansible installed.</p></div></div>

<div class="book" title="Using Ansible to orchestrate software installation">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec355" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre10">Ansible executes playbooks of tasks. In this example, we will extend the task that launches a specific instance to allow Ansible to then connect to that instance and install Apache:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">We start off by extending the Ansible playbook introduced in the previous recipe to include the creation of <span class="strong"><em class="calibre18">security group rules</em></span> (this is to ensure that Ansible can access to the instance on port <code class="email">22</code>, and we are ultimately able to access the running web server on port <code class="email">80</code>). Create the file called <code class="email">orchestrate-instance.yml</code> with the following contents:<div class="informalexample"><pre class="programlisting">- name: Launch instances on OpenStack
  hosts: localhost
  gather_facts: false

  tasks:
    - name: Create ansible security group
      os_security_group:
        state: present
        name: ansible
        verify: false
    - name: Create a rule to allow SSH connections
      os_security_group_rule:
        security_group: ansible
        protocol: tcp
        port_range_min: 22
        port_range_max: 22
        remote_ip_prefix: 0.0.0.0/0
        verify: false
    - name: Create webserver security group
      os_security_group:
        state: present
        name: webserver
        verify: false
    - name: Create rule to allow http connections
      os_security_group_rule:
        security_group: webserver
        protocol: tcp
        port_range_min: 80
        port_range_max: 80
        remote_ip_prefix: 0.0.0.0/0
        verify: false</pre></div></li><li class="listitem" value="2">Once <a id="id536" class="calibre1"/>we have our <span class="strong"><strong class="calibre2">security groups</strong></span> configured, we can then ensure that these security group rules are included in the <span class="strong"><strong class="calibre2">task</strong></span> that launches the instance. We also ensure that we include a new entry called <code class="email">register</code>. This allows us to set a variable associated with this instance that we can then refer to in other tasks. Carry on editing this file with the following tasks:<div class="informalexample"><pre class="programlisting">    - name: Deploy an instance
      os_server:
        state: present
        name: cookbook1
        image: xenial-image
        key_name: demokey
        timeout: 200
        flavor: m1.tiny
        network: private-net
        security_groups: default,ansible,webserver
        verify: false
      register: nova_cookbook</pre></div></li><li class="listitem" value="3">Next, we will add in a task that adds this particular instance to an internal in-memory inventory that we can then access later on in the playbook. As part of this inventory, we're telling Ansible that when the particular inventory item is accessed, when Ansible wants to connect to it (via <code class="email">ssh</code>), it will use a particular IP address (in our case, the public floating IP). Carry on editing the file and add this next entry as shown as follows. As we are using YAML, ensure that the spacing matches for each element. For example, this additional <code class="email">- name: Add instance to Inventory</code> block must match the same column as the previous block <code class="email">- name: Deploy an instance</code>, as it is a task that is part of the same play:<div class="informalexample"><pre class="programlisting">  - name: Add instance to Inventory
    add_host: name=cookbook1 groups=webservers
              ansible_ssh_host={{ nova_cookbook.server.accessIPv4 }}</pre></div></li><li class="listitem" value="4">Next, we will add in a new play that tells Ansible to wait for this instance <a id="id537" class="calibre1"/>to complete its boot process. As Ansible uses SSH to perform its tasks, it makes sense to only continue when the SSH daemon is running and accepting connections. Ensure that your private key running the Ansible task matches the public key portion described in <code class="email">key_name:</code>.<div class="note" title="Note"><h3 class="title2"><a id="tip84" class="calibre1"/>Tip</h3><p class="calibre10">Note that this is a new play and task, so ensure that this entry begins at the start of the line at column 0.</p></div><div class="informalexample"><pre class="programlisting">- name: Wait for port 22 to be ready
  hosts: webservers
  gather_facts: False
  tasks:
    - local_action: wait_for port=22 host="{{ ansible_ssh_host }}"  search_regex=OpenSSH delay=10</pre></div></li><li class="listitem" value="5">This final set of tasks perform the steps inside the running instance; this next task performs the installation of Apache on this running instance. Ansible knows to operate on this instance because this set of tasks is performed against the <code class="email">webservers</code> group of hosts. We registered this new group, in the in-memory inventory, in the task in step 2.<div class="note" title="Note"><h3 class="title2"><a id="note55" class="calibre1"/>Note</h3><p class="calibre10">The <code class="email">pre_tasks:</code> section is <span class="strong"><em class="calibre18">optional</em></span> and may not be needed in all circumstances. The example in this book was created using an Ubuntu 16.04 image. Ubuntu 16.04 doesn't install Python 2 by default, however this particular Ansible <code class="email">apt</code> module, that will ultimately install Apache, expects to execute Python 2 code in order to work. So, we do an initial <code class="email">raw</code> command, that doesn't execute any Python, to run some shell script to set some things up for us. This example is also further complicated if you are using the accompanying Vagrant environment, which the instances do not have direct access to the internet. So, as part of the <code class="email">pre_tasks:</code> section, we also configure a proxy server for APT to use.</p></div><div class="informalexample"><pre class="programlisting">- hosts: webservers
  remote_user: ubuntu
  become: yes
  gather_facts: no
  pre_tasks:
    - name: Set APT proxy
      raw: echo "Acquire::http::Proxy \"http://192.168.1.20:3128\";" &gt; /etc/apt/apt.conf
    - name: 'install python2'
      raw: sudo apt-get -y install python-simplejson
  tasks:
    - name: Ensure Apache is installed
      apt: name=apache2 state=latest
    - name: Ensure that Apache is started
      service: name=apache2 state=started</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip85" class="calibre1"/>Tip</h3><p class="calibre10">Hint: This playbook can also be found at <a class="calibre1" href="https://raw.githubusercontent.com/OpenStackCookbook/vagrant-openstack/master/orchestrate-instance.yml">https://raw.githubusercontent.com/OpenStackCookbook/vagrant-openstack/master/orchestrate-instance.yml</a>.</p></div></li></ol><div class="calibre20"/></div><p class="calibre10">Once this <a id="id538" class="calibre1"/>file has been created, save and exit. Then run the following commands which will launch an instance and install Apache:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">source openrc</strong></span>
<span class="strong"><strong class="calibre2">ansible-playbook orchestrate-instance.yml</strong></span>
</pre></div><p class="calibre10">This will bring back the familiar Ansible output like the following:</p><div class="mediaobject"><img src="../images/00180.jpeg" alt="How to do it..." class="calibre16"/></div><p class="calibre17"> </p></div></div>

<div class="book" title="Using Ansible to orchestrate software installation">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec356" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre10">What we <a id="id539" class="calibre1"/>did here was extending the original, simple <span class="strong"><em class="calibre18">playbook</em></span> that launched a single instance, and adding in subsequent <span class="strong"><em class="calibre18">tasks</em></span> that allow us to install some software onto that instance once it has completed its boot process. The important details of how this is achieved are described here.</p><p class="calibre10">In the first <span class="strong"><em class="calibre18">play</em></span>, named <code class="email">Launch instance on OpenStack</code>, we first configure some tasks to set up our security group rules. By default, there are no incoming connections allowed, and Ansible uses SSH to perform its tasks, so we have to at least ensure that TCP port 22 is open. We also configure rules appropriate for the service that we are installing. In this case, we are running Apache, so we open up TCP port 80. Once the security groups are configured, we then have a <span class="strong"><em class="calibre18">task</em></span> named <code class="email">Deploy an instance</code>. We ensure this instance is launched with the appropriate security groups that we have just configured, and we also register that instance in a variable named <code class="email">nova_cookbook</code>.</p><p class="calibre10">Ansible uses an <span class="strong"><strong class="calibre2">inventory</strong></span> of data to allow subsequent plays and tasks to access details that Ansible have performed in your environment, and so the next <span class="strong"><em class="calibre18">task</em></span>, named <code class="email">Add instance to Inventory</code> places a <span class="strong"><em class="calibre18">host</em></span> named <code class="email">cookbook1</code> into a <span class="strong"><strong class="calibre2">host group</strong></span> called <code class="email">webservers</code>. And for this particular <span class="strong"><em class="calibre18">host</em></span>, named <code class="email">cookbook1</code>, in the group <code class="email">webservers</code>, we are setting the variable that Ansible would use to access that instance as the floating IP address <a id="id540" class="calibre1"/>assigned: <code class="email">(ansible_ssh_host={{ nova_cookbook.server.accessIPv4 }}</code>. As you can see, we are using our registered variable, <code class="email">nova_cookbook</code>, to access some information that Ansible has stored about that instance. It is important that we use the floating IP because the private tenant network is not routable from our client, and therefore Ansible would not be able to connect to perform the Apache install.</p><p class="calibre10">The next <span class="strong"><em class="calibre18">play</em></span> named <code class="email">Wait for port 22 to be ready </code>basically has a <span class="strong"><em class="calibre18">task</em></span> that waits for SSH to be running. This signals that the instance is ready for use, and therefore we are able to SSH into this to run further Ansible commands.</p><p class="calibre10">The last one is the <span class="strong"><em class="calibre18">play</em></span> that has <span class="strong"><em class="calibre18">tasks</em></span> that perform the install of Apache. As described earlier, we have placed an optional set of <code class="email">pre_tasks</code> into this section to overcome the fact that Ubuntu 16.04 doesn't come with the necessary prerequisite Python packages needed for Ansible to run. We have also set an optional APT proxy here too, so feel free to remove and adjust this section according to the image and environment you are operating with.</p><p class="calibre10">The last set of <span class="strong"><em class="calibre18">tasks</em></span> in this <span class="strong"><em class="calibre18">play</em></span> basically ensure that Apache is installed and runs. Here you could then add in additional tasks to pull in Apache configuration data from GitHub, or install additional packages, thus completing the set up of this instance from a single Ansible command.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Using Ansible to orchestrate software installations across multiple instances" id="3KB4K1-189e69df43a248268db97cde1b1a8e47"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec119" class="calibre1"/>Using Ansible to orchestrate software installations across multiple instances</h1></div></div></div><p class="calibre10">So far, we <a id="id541" class="calibre1"/>created playbooks that first launched an instance, and then we extended this in the previous recipe to subsequently install Apache onto the running instance. This recipe describes a playbook that can launch any number of instances, and install Apache onto each of those instances.</p></div>

<div class="book" title="Using Ansible to orchestrate software installations across multiple instances" id="3KB4K1-189e69df43a248268db97cde1b1a8e47">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec357" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre10">Ensure that you are logged on to a correctly configured OpenStack client and can access the OpenStack environment that has Ansible installed.</p></div></div>

<div class="book" title="Using Ansible to orchestrate software installations across multiple instances" id="3KB4K1-189e69df43a248268db97cde1b1a8e47">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec358" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre10">We will <a id="id542" class="calibre1"/>extend the previous recipe's playbook to add flexibility to include a variable number of instances. </p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">The basic structure was provided in the previous recipe, so the only <span class="strong"><strong class="calibre2">play</strong></span> we need to adjust is the first one that launches the instances, called <code class="email">Launch instances on OpenStack</code>. This complete <span class="strong"><em class="calibre18">play</em></span> is shown as follows, where we introduce a variable called <code class="email">count</code>, which we have set to <code class="email">2</code>, and we also introduce the <code class="email">with_sequence</code> section, which forms our loop that will execute that <span class="strong"><em class="calibre18">task</em></span> the specified number of <span class="strong"><em class="calibre18">count </em></span>times. Note that we also include the count value as part of the instance name:<div class="informalexample"><pre class="programlisting">- name: Launch instances on OpenStack
  hosts: localhost
  gather_facts: false

  vars:
    count: 2

  tasks:
    - name: Create ansible security group
      os_security_group:
        state: present
        name: ansible
        verify: false
    - name: Create a rule to allow SSH connections
      os_security_group_rule:
        security_group: ansible
        protocol: tcp
        port_range_min: 22
        port_range_max: 22
        remote_ip_prefix: 0.0.0.0/0
        verify: false
    - name: Create webserver security group
      os_security_group:
        state: present
        name: webserver
        verify: false
    - name: Create a rule to allow http connections
      os_security_group_rule:
        security_group: webserver
        protocol: tcp
        port_range_min: 80
        port_range_max: 80
        remote_ip_prefix: 0.0.0.0/0
        verify: false
    - name: Deploy an instance
      os_server:
        state: present
        name: cookbook{{ item }}
        image: xenial-image
        key_name: demokey
        timeout: 200
        flavor: m1.tiny
        network: private-net
        verify: false
    register: nova_cookbook
    with_sequence:
        count={{ count }}

    - name: Add instance to Inventory
      add_host: name="{{ item.server.name }}" groups=webservers
         	ansible_ssh_host="{{ item.server.accessIPv4 }}"
    with_items: "{{ nova_cookbook.results }}"</pre></div></li><li class="listitem" value="2">The next <a id="id543" class="calibre1"/>set of plays copy what was described in the previous recipe, such as waiting for the instance's SSH to be available and subsequently installing Apache, and is shown here for completeness:<div class="informalexample"><pre class="programlisting">- name: Wait for port 22 to be ready
  hosts: webservers
  gather_facts: False
  tasks:
    - local_action: wait_for port=22 host="{{ ansible_ssh_host }}"  search_regex=OpenSSH delay=10

- hosts: webservers
  remote_user: ubuntu
  become: yes
  gather_facts: no</pre></div><div class="note" title="Note"><h3 class="title2"><a id="note56" class="calibre1"/>Note</h3><p class="calibre10">The <code class="email">pre_tasks:</code> section is optional. Your use will vary on any implicit restrictions imposed on the image or environment you are using. This was described in the previous recipe on its use here:</p><div class="informalexample"><pre class="programlisting">  pre_tasks:
    - name: Set APT proxy
      raw: echo "Acquire::http::Proxy \"http://192.168.1.20:3128\";" &gt; /etc/apt/apt.conf
    - name: 'install python2'
      raw: sudo apt-get -y install python-simplejson
  
tasks:
    - name: Ensure Apache is installed
      apt: name=apache2 state=latest
    - name: Ensure that Apache is started
      service: name=apache2 state=started</pre></div></div></li><li class="listitem" value="3">Assuming <a id="id544" class="calibre1"/>the file that you have created is called <code class="email">multi-orchestrate-instances.yml</code>, you execute this with the following:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">source openrc</strong></span>
<span class="strong"><strong class="calibre2">ansible-playbook multi-orchestrate-instances.yml</strong></span>
</pre></div><p class="calibre22">This will bring back an output like the following. This produces more output than the other plays so far, so only the last part is shown:</p><div class="mediaobject"><img src="../images/00181.jpeg" alt="How to do it..." class="calibre16"/></div><p class="calibre23"> </p></li></ol><div class="calibre20"/></div></div></div>

<div class="book" title="Using Ansible to orchestrate software installations across multiple instances" id="3KB4K1-189e69df43a248268db97cde1b1a8e47">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec359" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre10">We have <a id="id545" class="calibre1"/>included a few extra items in this playbook that extends the previous playbook that installs Apache to a newly launched instance. These are described here:</p><div class="informalexample"><pre class="programlisting">vars:
   count: 2</pre></div><p class="calibre10">We introduce a variable called <code class="email">count</code>, to which we assign the value <code class="email">2</code>. This variable is limited to the scope of this particular play (named <code class="email">Launch instances on OpenStack</code>). This variable is used to form a loop, as indicated by this attribute assigned to the <code class="email">os_server</code> call:</p><div class="informalexample"><pre class="programlisting">with_sequence:
          count={{ count }}</pre></div><p class="calibre10">This basically states: run the <code class="email">os_server</code> module task when <code class="email">count = 1</code>, and when <code class="email">count = 2</code>. As we are in a sequence, we have access to the value of <code class="email">count</code>, in a variable <a id="id546" class="calibre1"/>called <code class="email">item</code>. We use this to append to the <code class="email">name</code> variable of the instance allowing us to end up with <code class="email">cookbook1</code> and <code class="email">cookbook2</code> with the following syntax:</p><div class="informalexample"><pre class="programlisting">name: cookbook{{ item }}</pre></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Using Ansible to fully orchestrate the creation of a web server and load balancer stack"><div class="book" id="3L9L62-189e69df43a248268db97cde1b1a8e47"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec120" class="calibre1"/>Using Ansible to fully orchestrate the creation of a web server and load balancer stack</h1></div></div></div><p class="calibre10">The previous <a id="id547" class="calibre1"/>recipes launched instances into an existing environment, including existing networks, images and keys, for <a id="id548" class="calibre1"/>example. However, using Ansible for orchestration of OpenStack environments brings a full suite of modules that can be used to operate more than just Nova. For example, we can use Ansible to control Glance, Neutron, Cinder, and so on.</p><p class="calibre10">In this recipe, we only assume that a user is able to authenticate into a project. We don't assume that any networks exist, or even any images exist. We can get Ansible's view of the world to ensure that images and networks are present, and if not—create them. </p><p class="calibre10">Note that this recipe is intended to introduce you to the wonderful world of Ansible. The example is to show the creation of a stack from start to finish. Optimizing Ansible playbooks is beyond the scope of this book.</p></div>

<div class="book" title="Using Ansible to fully orchestrate the creation of a web server and load balancer stack">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec360" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre10">Ensure that you are logged on to a correctly configured OpenStack client and can access the OpenStack environment that has Ansible installed.</p></div></div>

<div class="book" title="Using Ansible to fully orchestrate the creation of a web server and load balancer stack">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec361" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre10">Carry out the following steps to launch an environment that ensures an image is available for use, sets the correct security groups, creates new networks and routers, and finally installs Apache onto two web servers:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">We can assume a blank OpenStack project, but we want to ensure that we have the appropriate running instances and services. We first include tasks as part of our <code class="email">Create OpenStack Cloud Environment</code> play that first downloads an Ubuntu 16.04 image and then loads into OpenStack. Start off by creating the <code class="email">full-stack.yml</code> file with the following contents:<div class="informalexample"><pre class="programlisting">- name: Create OpenStack Cloud Environment
  hosts: localhost
  gather_facts: false

  vars:
    webserver_count: 2

  tasks:
    - name: Download Ubuntu 16.04 Xenial
      get_url:
        url: http://releases.ubuntu.com/16.04/ubuntu-16.04.3-server-amd64.img
        dest: /tmp/ubuntu-16.04.img

    - name: Ensure Ubuntu 16.04 Xenial Image Exists
      os_image:
        name: xenial-image
        container_format: bare
        disk_format: qcow2
        state: present
        filename: /tmp/ubuntu-16.04.img
        verify: false</pre></div></li><li class="listitem" value="2">Next, we <a id="id549" class="calibre1"/>will create the <span class="strong"><em class="calibre18">private tenant network and router</em></span>. We only assume that a shared provider <a id="id550" class="calibre1"/>network already exists. In this instance, we assume this provider network—that provides floating IP addresses—is called <code class="email">GATEWAY_NET</code>. Carry on editing the file to include the following <span class="strong"><em class="calibre18">tasks</em></span> as part of the same <code class="email">Create OpenStack Cloud Environment</code> play:<div class="informalexample"><pre class="programlisting">    - name: Create the cookbook network
      os_network:
        state: present
        name: cookbook_network
        external: false
        shared: false
        verify: false
      register: cookbook_network

    - name: Create the test subnet
      os_subnet:
        state: present
        network_name: "{{ cookbook_network.id }}"
        name: cookbook_subnet
        ip_version: 4
        cidr: 192.168.0.0/24
        gateway_ip: 192.168.0.1
        enable_dhcp: yes
        dns_nameservers:
          - 192.168.1.20
        verify: false
      register: cookbook_subnet

    - name: Create the test router
      os_router:
        state: present
        name: cookbook_router
        network: GATEWAY_NET
        external_fixed_ips:
          - subnet: GATEWAY_SUBNET
        interfaces:
          - cookbook_subnet
        verify: false</pre></div><div class="note" title="Note"><h3 class="title2"><a id="note57" class="calibre1"/>Note</h3><p class="calibre10">
<span class="strong"><em class="calibre18">Optional (if using the Vagrant environment)</em></span>. Currently, the <code class="email">os_router</code> module is unable to insert static routes into a router, so if you have a requirement to utilize static routes into your Ansible controlled playbooks, a workaround is to execute an <code class="email">openstack</code> command instead as shown as follows. If you are using the <span class="strong"><em class="calibre18">Vagrant</em></span> lab that accompanies this book, you may need to provide static routes to your router in order for traffic to flow from the physical host to the VirtualBox/VMware environment. If you require this, add in the following <span class="strong"><em class="calibre18">task</em></span> (edit to suit your environment). In this instance, the physical host running the Vagrant environment has an IP of 192.168.100.1 and allows traffic to flow from the physical host to the instances that have a floating IP from a <code class="email">192.168.100.0/24</code> provider network. This provider network here is the <code class="email">GATEWAY_NET</code> referred to in this example:</p><div class="informalexample"><pre class="programlisting">    - name: Insert routes into router
      command: openstack router set --route destination=192.168.1.0/24,gateway=192.168.100.1 cookbook_router
      register: cookbook_router_route</pre></div></div></li><li class="listitem" value="3">Next, we <a id="id551" class="calibre1"/>configure <a id="id552" class="calibre1"/>the security groups. Remember that Ansible uses SSH to connect to servers, and by default, cloud images prevent any incoming connections. So one of the rules should be for allowing incoming SSH connections. We also need to configure security group rules for the intended service that is to run on the instances. In this case, we're running Apache and HAProxy on TCP Port 80, so that also needs to be set up here:<div class="informalexample"><pre class="programlisting">    - name: Create ansible security group
      os_security_group:
        state: present
        name: ansible
        verify: false
    - name: Create rule to allow SSH connections
      os_security_group_rule:
        security_group: ansible
        protocol: tcp
        port_range_min: 22
        port_range_max: 22
        remote_ip_prefix: 0.0.0.0/0
        verify: false

    - name: Create webserver security group
      os_security_group:
        state: present
        name: webserver
        verify: false
    - name: Create rule to allow http connections
      os_security_group_rule:
        security_group: webserver
        protocol: tcp
        port_range_min: 80
        port_range_max: 80
        remote_ip_prefix: 0.0.0.0/0
        verify: false</pre></div><div class="note" title="Note"><h3 class="title2"><a id="note58" class="calibre1"/>Note</h3><p class="calibre10">As we are running Ansible from one specific host, we can further secure the Ansible SSH security group rule by limiting the access from a single IP address, and not a general 0.0.0.0/0 range.</p></div></li><li class="listitem" value="4">We can <a id="id553" class="calibre1"/>now launch the instances. Carry on editing this file to add in the tasks to launch multiple <a id="id554" class="calibre1"/>web servers and a single HAProxy instance as follows. Note that the chosen network, image, and security groups match what we created in the preceding tasks:<div class="informalexample"><pre class="programlisting">    - name: Deploy Webserver Instances
      os_server:
        state: present
        name: webserver{{ item }}
        image: xenial-image
        key_name: demokey
        timeout: 200
        flavor: m1.tiny
        network: cookbook_network
        security_groups: default,ansible,webserver
        verify: false
      register: nova_webservers
      with_sequence:
        count={{ webserver_count }}

    - name: Add webservers to Inventory
      add_host: name="{{ item.server.name }}" groups=webservers
             ansible_ssh_host="{{ item.server.accessIPv4 }}"
      with_items: "{{ nova_webservers.results }}"

    - name: Deploy HAProxy Instance
      os_server:
        state: present
        name: haproxy
        image: xenial-image
        key_name: demokey
        timeout: 200
        flavor: m1.tiny
        network: cookbook_network
        security_groups: default,ansible,webserver
        verify: false
      register: nova_haproxy
      with_sequence:
        count=1

    - name: Add HAProxy to Inventory
      add_host: name="{{ item.server.name }}" groups=haproxy
             ansible_ssh_host="{{ item.server.accessIPv4 }}"
      with_items: "{{ nova_haproxy.results }}"</pre></div></li><li class="listitem" value="5">As we <a id="id555" class="calibre1"/>have seen, we <a id="id556" class="calibre1"/>need to wait for SSH to be available before Ansible should continue, so we add in a <span class="strong"><em class="calibre18">wait</em></span> until this is so. Note that we apply this play to both the <code class="email">webservers</code> and <code class="email">haproxy</code> <span class="strong"><em class="calibre18">hosts</em></span> groups:<div class="informalexample"><pre class="programlisting">- name: Wait for port 22 to be ready
  hosts: webservers:haproxy
  gather_facts: False
  tasks:
    - local_action: wait_for port=22 host="{{ ansible_ssh_host }}"  search_regex=OpenSSH delay=10</pre></div></li><li class="listitem" value="6">With the <a id="id557" class="calibre1"/>instances up and running, the final tasks are concerned with installation and configuration of the services that run on the instances. We will first install Apache <a id="id558" class="calibre1"/>on our web servers. This play is applied to our <code class="email">webservers</code> hosts, so these tasks will run for each of them:<div class="informalexample"><pre class="programlisting">- name: Configure Web Servers
  hosts: webservers
  remote_user: ubuntu
  become: yes
  gather_facts: False

pre_tasks:
    - name: Set APT proxy
      raw: echo "Acquire::http::Proxy \"http://192.168.1.20:3128\";" &gt; /etc/apt/apt.conf
    - name: 'install python2'
      raw: sudo apt-get -y install python-simplejson

tasks:
    - name: Ensure Apache is installed
      apt: name=apache2 state=latest
    - name: Ensure that Apache is started
      service: name=apache2 state=started</pre></div></li><li class="listitem" value="7">As our plays have <code class="email">gather_facts</code> set to <code class="email">False</code> (because the <span class="strong"><em class="calibre18">image</em></span> we're using doesn't have the Python libraries expected to run Ansible out of the box, which would mean that the Ansible task that gathers facts about a running instance would immediately fail), we will launch a separate task in a new play that just populates the Ansible inventory of facts, knowing we installed the prerequisite Python 2 libraries in the preceding play. We need this information to populate the HAProxy configuration file later on:<div class="informalexample"><pre class="programlisting">- name: Gathering facts about webservers
  hosts: webservers
  remote_user: ubuntu
  become: yes
  tasks:
    - name: Gathering facts
      setup:</pre></div></li><li class="listitem" value="8">We can now install and configure HAProxy. This gets applied to our <span class="strong"><em class="calibre18">haproxy</em></span> group <a id="id559" class="calibre1"/>of hosts (of which there is only one server, named <span class="strong"><em class="calibre18">haproxy</em></span>). As part of this play, we will reference <a id="id560" class="calibre1"/>a HAProxy configuration file template. We will create this in the next step.<div class="note" title="Note"><h3 class="title2"><a id="note59" class="calibre1"/>Note</h3><p class="calibre10">Ansible provides pre-defined, and extensively tested roles that can be used for the installation of software. The guide below is for example purposes only. In reality, you would utilize roles from <a class="calibre1" href="https://galaxy.ansible.com/">https://galaxy.ansible.com/</a>.</p></div><p class="calibre22">Carry on building out this <code class="email">full-stack.yml</code> playbook file with the following contents:</p><div class="informalexample"><pre class="programlisting">- name: Configure HAProxy
  hosts: haproxy
  remote_user: ubuntu
  become: yes
  gather_facts: False

  pre_tasks:
    - name: Set APT proxy
      raw: echo "Acquire::http::Proxy \"http://192.168.1.20:3128\";" &gt; /etc/apt/apt.conf
    - name: 'install python2'
      raw: sudo apt-get -y install python-simplejson

  tasks:
    - name: Update apt cache
      apt: update_cache=yes cache_valid_time=3600

    - name: Install haproxy
      apt: name=haproxy state=present

    - name: Enable init script
      replace: dest='/etc/default/haproxy'
            regexp='ENABLED=0'
            replace='ENABLED=1'

    - name: Update HAProxy config
      template: src=templates/haproxy.cfg.j2
            dest=/etc/haproxy/haproxy.cfg
      notify:
        - restart haproxy

  handlers:
    - name: restart haproxy
      service: name=haproxy state=restarted</pre></div></li><li class="listitem" value="9">Before we <a id="id561" class="calibre1"/>can continue executing our playbook, we need to create the HAProxy configuration <a id="id562" class="calibre1"/>template file as specified in the previous step. The configuration pointed to a template file named <code class="email">haproxy.cfg.j2</code> in the <code class="email">templates</code> directory. Create this directory from the current working directory where you are editing the <code class="email">full-stack.yml</code> file:<div class="informalexample"><pre class="programlisting">mkdir templates/
vi templates/haproxy.cfg.j2</pre></div></li><li class="listitem" value="10">Populate the <code class="email">haproxy.cfg.j2</code> file with the following contents:<div class="informalexample"><pre class="programlisting">global
    log 127.0.0.1 local0 notice
    maxconn 2000
    user haproxy
    group haproxy
    daemon

defaults
    log  global
    mode  http
    option  httplog
    option  dontlognull
    retries 3
    option redispatch
    timeout connect  5000
    timeout client  10000
    timeout server  10000

listen {{haproxy_app_name}}
    bind *:80
    mode {{haproxy_mode}}
    stats {{haproxy_enable_stats}}
    {% if haproxy_enable_stats == 'enable' %}
    stats uri /haproxy?stats
    stats realm Strictly\ Private
   {% endif %}
    balance {{haproxy_algorithm}}
    option httpclose
    option forwardfor
    {% for host in groups['webservers'] %}
    server {{ hostvars[host].inventory_hostname }} {{ hostvars[host]['ansible_all_ipv4_addresses'][0] }} check
    {% endfor %}</pre></div><div class="note" title="Note"><h3 class="title2"><a id="note60" class="calibre1"/>Note</h3><p class="calibre10">The <code class="email">server {{ hostvars[host]...check</code> line is all on a single line.</p></div></li><li class="listitem" value="11">The <code class="email">templates/haproxy.cfg.j2</code> file also refers to some variables that we have not yet declared to Ansible, such as <code class="email">haproxy_app_name</code> and <code class="email">haproxy_algorithm</code>. These are in a <code class="email">group_var</code> file specific to our <code class="email">haproxy</code> group. To create this group variable file, we need to create a <code class="email">group_vars/haproxy</code> directory, with a file called <code class="email">main.yml</code> that lists these variables. From the same directory as our <code class="email">full-stack.yml</code> file, carry out the following steps:<div class="informalexample"><pre class="programlisting">mkdir -p group_vars/haproxy
vi group_vars/haproxy/main.yml</pre></div></li><li class="listitem" value="12">Populate <a id="id563" class="calibre1"/>the <code class="email">group_vars/haproxy/main.yml</code> file with the following contents:<div class="informalexample"><pre class="programlisting">---
haproxy_app_name: myapp
haproxy_mode: http
haproxy_enable_stats: enable
haproxy_algorithm: roundrobin</pre></div></li><li class="listitem" value="13">We are <a id="id564" class="calibre1"/>now ready to run our <code class="email">full-stack.yml</code> playbook to create our environment similar to the one described by the Heat example. Execute the following commands:<div class="informalexample"><pre class="programlisting">source openrc
ansible-playbook full-stack.yml</pre></div><p class="calibre22">This will produce an output similar to the following. Due to this being a longer playbook, only the last part is shown:</p><div class="mediaobject"><img src="../images/00182.jpeg" alt="How to do it..." class="calibre16"/></div><p class="calibre23"> </p><p class="calibre22">We are <a id="id565" class="calibre1"/>also able to verify that these instances are running, and the addresses it has assigned by viewing an <code class="email">openstack server list</code> output:</p><div class="mediaobject"><img src="../images/00183.jpeg" alt="How to do it..." class="calibre16"/></div><p class="calibre23"> </p></li><li class="listitem" value="14">Finally, we <a id="id566" class="calibre1"/>can test our setup by visiting the HAProxy server floating IP address, as shown here. Here we can view the HAProxy stats:<div class="mediaobject"><img src="../images/00184.jpeg" alt="How to do it..." class="calibre16"/></div><p class="calibre23"> </p></li></ol><div class="calibre20"/></div></div></div>

<div class="book" title="Using Ansible to fully orchestrate the creation of a web server and load balancer stack">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec362" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre10">What we <a id="id567" class="calibre1"/>did here was to methodically build out a playbook, called <code class="email">full-stack.yml</code>, that carries out the following steps:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Download and install Ubuntu 16.04 image if necessary</li><li class="listitem">Create our web server and ansible SSH security groups</li><li class="listitem">Create a private tenant network, router and configure the router</li><li class="listitem">Launch two web server instances and one HAProxy instance</li><li class="listitem">For each web server, install Apache</li><li class="listitem">For the HAProxy server, install HAProxy and configure the configuration file, auto-populated with information that Ansible knows about from launching the web servers (such as what IP address was assigned to each of them)</li></ul></div><p class="calibre10">In this <a id="id568" class="calibre1"/>recipe, we introduced a few notable items: Ansible <span class="strong"><em class="calibre18">facts</em></span>, the <span class="strong"><em class="calibre18">Jinja2</em></span> configuration template file (the <code class="email">haproxy.cfg.j2</code> file), and <code class="email">group_vars</code>.</p><p class="calibre10">The Ansible facts and HAProxy <code class="email">group_var</code> variables were used to populate the HAProxy configuration file called <code class="email">templates/haproxy.cfg.j2</code>. This file mostly looks like a normal <code class="email">haproxy.cfg</code> file, but has elements that are applicable to Jinja2, which Ansible interprets. Of particular interest is the <code class="email">haproxy.cfg</code> file that has the load balance pool member lines, that ordinarily look like the following basic construct:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">server webserver1 192.168.0.6 check</strong></span>
<span class="strong"><strong class="calibre2">server webserver2 192.168.0.3 check</strong></span>
</pre></div><p class="calibre10">When we launch our instances into OpenStack, we have no idea what IP address they will be assigned, however Ansible does this with its <span class="strong"><em class="calibre18">fact gathering</em></span>. If we take a look at the same line in our template, we get the following:</p><div class="informalexample"><pre class="programlisting">{% for host in groups['webservers'] %}
server {{ hostvars[host].inventory_hostname }} {{ hostvars[host]['ansible_all_ipv4_addresses'][0] }} check
{% endfor %}</pre></div><p class="calibre10">This line <a id="id569" class="calibre1"/>has some static text at the beginning and end, denoted by <code class="email">server</code> and <code class="email">check</code>. They're the same <code class="email">server</code> and <code class="email">check</code> text, as we can see in our final output.</p><p class="calibre10">The magic <a id="id570" class="calibre1"/>of the template and Ansible is what we can do with the loop that surrounds this line and <code class="email">hostvars</code> we can access. The loop says:</p><p class="calibre10">For each of the <code class="email">hosts</code> in the <code class="email">webservers</code> <span class="strong"><em class="calibre18">group</em></span> (recall that we registered the web server instances into this specific inventory group), get the value of <code class="email">hostvars[host].inventory_hostname</code> and <code class="email">hostvars[host]['ansible_all_ipv4_addresses'][0](</code>from the <span class="strong"><strong class="calibre2">gathered facts</strong></span>). This last variable takes the first entry in the <code class="email">ansible_all_ipv4_addresses</code> dict, which is our internal IP of our instance.</p><p class="calibre10">The result is the output shown on the previous page, which lists the web servers that HAProxy can access in the load balance pool.</p><p class="calibre10">We aren't restricted to the variables that Ansible has gathered. We have specified a <code class="email">group_var </code>variable file that specifies the following:</p><div class="informalexample"><pre class="programlisting">---
haproxy_app_name: myapp
haproxy_mode: http
haproxy_enable_stats: enable
haproxy_algorithm: roundrobin</pre></div><p class="calibre10">This is referenced directly in the template file in the following places. This allows us to add some static elements that are user-configurable, but allows us to maintain a flexible, environment agnostic set of playbooks.</p><div class="informalexample"><pre class="programlisting">listen {{haproxy_app_name}}
   bind *:80
   mode {{haproxy_mode}}
   stats {{haproxy_enable_stats}}
   {% if haproxy_enable_stats == 'enable' %}
   stats uri /haproxy?stats
   stats realm Strictly\ Private
   {% endif %}
   balance {{haproxy_algorithm}}</pre></div></div></div></body></html>