["```\nFROM mcr.microsoft.com/dotnet/sdk:6.0 AS build-env\nWORKDIR /app\n```", "```\nCOPY ./FleetPortal/FleetPortal.csproj ./FleetPortal/\nRUN dotnet restore ./FleetPortal/FleetPortal.csproj\n```", "```\nCOPY . ./\nRUN dotnet publish ./FleetPortal/FleetPortal.csproj -c Release -o out\n```", "```\nFROM mcr.microsoft.com/dotnet/aspnet:6.0\nWORKDIR /app\nCOPY --from=build-env /app/out .\n```", "```\nENTRYPOINT [“dotnet”, “FleetPortal.dll”]\n```", "```\nlocals {\n  repository_list = [“frontend”, “backend”]\n  repositories    = { for name in local.repository_list : name => name }\n}\n```", "```\nresource “aws_ecr_repository” “main” {\n  for_each = local.repositories\n  name                 = “ecr-${var.application_name}-${var.environment_name}-${each.key}”\n  image_tag_mutability = “MUTABLE”\n}\n```", "```\nresource “aws_iam_group” “ecr_image_pushers” {\n  name = “${var.application_name}-${var.environment_name}-ecr-image-pushers”\n}\n```", "```\nresource “aws_iam_group_policy” “ecr_image_pushers” {\n  for_each = local.repositories\n  name  = “${var.application_name}-${var.environment_name}-${each.key}-ecr-image-push-policy”\n  group = aws_iam_group.ecr_image_pushers.name\n  policy = jsonencode({\n    Version = “2012-10-17”,\n    Statement = [\n      {\n        Effect = “Allow”,\n        Action = [\n          “ecr:GetDownloadUrlForLayer”,\n          “ecr:BatchGetImage”,\n          “ecr:BatchCheckLayerAvailability”,\n          “ecr:PutImage”,\n          “ecr:InitiateLayerUpload”,\n          “ecr:UploadLayerPart”,\n          “ecr:CompleteLayerUpload”\n        ],\n        Resource = aws_ecr_repository.main[each.key].arn\n      }\n    ]\n  })\n}\n```", "```\nresource “aws_iam_group_membership” “ecr_image_pushers” {\n  name  = “${var.application_name}-${var.environment_name}-ecr-image-push-membership”\n  users = var.ecr_image_pushers\n  group = aws_iam_group.ecr_image_pushers.name\n}\n```", "```\ndata “aws_iam_policy_document” “container_cluster_assume_role” {\n  statement {\n    effect = “Allow”\n    principals {\n      type        = “Service”\n      identifiers = [“eks.amazonaws.com”]\n    }\n    actions = [“sts:AssumeRole”]\n  }\n}\n```", "```\nresource “aws_iam_role” “container_cluster” {\n  name               = “eks-${var.application_name}-${var.environment_name}-cluster-role”\n  assume_role_policy = data.aws_iam_policy_document.container_cluster_assume_role.json\n}\n```", "```\nresource “aws_iam_role_policy_attachment” “eks_cluster_policy” {\n  policy_arn = “arn:aws:iam::aws:policy/AmazonEKSClusterPolicy”\n  role       = aws_iam_role.container_cluster.name\n}\n```", "```\nresource “aws_eks_cluster” “main” {\n  name                      = local.cluster_name\n  role_arn                  = aws_iam_role.container_cluster.arn\n  vpc_config {\n    security_group_ids = [\n      aws_security_group.cluster.id,\n      aws_security_group.cluster_nodes.id\n    ]\n    subnet_ids              = local.cluster_subnet_ids\n    endpoint_public_access  = true\n    endpoint_private_access = true\n  }\n  // Other configurations like logging, encryption, etc.\n}\n```", "```\n  depends_on = [\n    aws_iam_role_policy_attachment.eks_cluster_policy,\n    aws_iam_role_policy_attachment.eks_vpc_controller_policy,\n    aws_cloudwatch_log_group.container_cluster\n  ]\n```", "```\ndata “aws_iam_policy_document” “container_node_group” {\n  statement {\n    sid     = “EKSNodeAssumeRole”\n    actions = [“sts:AssumeRole”]\n    principals {\n      type        = “Service”\n      identifiers = [“ec2.amazonaws.com”]\n    }\n  }\n}\n```", "```\nresource “aws_eks_node_group” “main” {\n  cluster_name    = aws_eks_cluster.main.name\n  node_group_name = “ng-user”\n  node_role_arn   = aws_iam_role.container_node_group.arn\n  subnet_ids      = local.cluster_subnet_ids\n  scaling_config {\n    desired_size = 3\n    min_size     = 1\n    max_size     = 4\n  }\n  ami_type       = var.node_image_type\n  instance_types = [var.node_size]\n}\n```", "```\n  depends_on = [\n    aws_iam_role_policy_attachment.eks_worker_node_policy,\n    aws_iam_role_policy_attachment.eks_cni_policy,\n    aws_iam_role_policy_attachment.eks_ecr_policy,\n    aws_iam_role_policy_attachment.eks_cloudwatch_policy\n  ]\n```", "```\nenabled_cluster_log_types = [“api”, “audit”]\n```", "```\nresource “aws_cloudwatch_log_group” “container_cluster” {\n  name              = “/aws/eks/${local.cluster_name}/cluster”\n  retention_in_days = 7\n}\n```", "```\ndata “tls_certificate” “container_cluster_oidc” {\n  url = aws_eks_cluster.main.identity[0].oidc[0].issuer\n}\n```", "```\nresource “aws_iam_openid_connect_provider” “container_cluster_oidc” {\n  client_id_list  = [“sts.amazonaws.com”]\n  thumbprint_list = [data.tls_certificate.container_cluster_oidc.certificates[0].sha1_fingerprint]\n  url             = data.tls_certificate.container_cluster_oidc.url\n}\n```", "```\ndata “aws_iam_policy_document” “workload_identity_assume_role_policy” {\n  statement {\n    actions = [“sts:AssumeRoleWithWebIdentity”]\n    effect  = “Allow”\n    condition {\n      test     = “StringEquals”\n      variable = “${replace(aws_iam_openid_connect_provider.container_cluster_oidc.url, “https://”, “”)}:sub”\n      values   = [“system:serviceaccount:${var.k8s_namespace}:${var.k8s_service_account_name}”]\n    }\n    principals {\n      identifiers = [aws_iam_openid_connect_provider.container_cluster_oidc.arn]\n      type        = “Federated”\n    }\n  }\n}\n```", "```\ndata “aws_iam_policy_document” “workload_identity_policy” {\n  statement {\n    effect = “Allow”\n    actions = [\n      “secretsmanager:GetSecretValue”,\n      “secretsmanager:DescribeSecret”,\n    ]\n    resources = [\n      “arn:aws:secretsmanager:${var.primary_region}:${data.aws_caller_identity.current.account_id}:secret:*”,\n    ]\n  }\n}\n```", "```\nresource “aws_secretsmanager_secret” “database_connection_string” {\n  name        = “${var.application_name}-${var.environment_name}-connection-string”\n  description = “Database connection string”\n}\n```", "```\nresource “aws_secretsmanager_secret_version” “database_connection_string” {\n  secret_id     = aws_secretsmanager_secret.database_connection_string.id\n  secret_string = random_password.database_connection_string.result\n}\n```", "```\ndata “aws_eks_cluster” “cluster” {\n  name = var.eks_cluster_name\n}\n```", "```\nprovider “kubernetes” {\n  host                   = data.aws_eks_cluster.cluster.endpoint\n  cluster_ca_certificate = base64decode(data.aws_eks_cluster.cluster.certificate_authority[0].data)\n  token                  = data.aws_eks_cluster_auth.cluster.token\n  load_config_file       = false\n}\n```", "```\nprovider “helm” {\n  kubernetes {\n    host                   = data.aws_eks_cluster.main.endpoint\n    cluster_ca_certificate = base64decode(data.aws_eks_cluster.main.certificate_authority[0].data)\n    token                  = data.aws_eks_cluster_auth.main.token\n  }\n}\n```", "```\nresource “kubernetes_namespace” “main” {\n  metadata {\n    name = var.k8s_namespace\n    labels = {\n      name = var.k8s_namespace\n    }\n  }\n}\n```", "```\nresource “kubernetes_service_account” “workload_identity” {\n  metadata {\n    name      = var.k8s_service_account_name\n    namespace = var.k8s_namespace\n    annotations = {\n      “eks.amazonaws.com/role-arn” = var.workload_identity_role\n    }\n  }\n}\n```", "```\nresource “helm_release” “csi_secrets_store” {\n  name       = “csi-secrets-store”\n  repository = “https://kubernetes-sigs.github.io/secrets-store-csi-driver/charts”\n  chart      = “secrets-store-csi-driver”\n  namespace  = “kube-system”\n  set {\n    name  = “syncSecret.enabled”\n    value = “true”\n  }\n}\n```", "```\nresource “helm_release” “aws_secrets_provider” {\n  name       = “secrets-provider-aws”\n  repository = “https://aws.github.io/secrets-store-csi-driver-provider-aws”\n  chart      = “secrets-store-csi-driver-provider-aws”\n  namespace  = “kube-system”\n}\n```", "```\nresource “kubernetes_manifest” “secret_provider_class” {\n  manifest = {\n    apiVersion = “secrets-store.csi.x-k8s.io/v1”\n    kind       = “SecretProviderClass”\n    metadata = {\n      name      = “${var.application_name}-${var.environment_name}-secret-provider-class”\n      namespace = var.k8s_namespace\n    }\n    spec = {\n      provider = “aws”\n      parameters = {\n        objects = yamlencode([ ... ])\n      }\n      secretObjects = [ ... ]\n    }\n  }\n}\n```", "```\n{\n  objectName         = “fleet-portal-dev-connection-string”\n  objectType         = “secretsmanager”\n  objectVersionLabel = “AWSCURRENT”\n}\n```", "```\n{\n  data = [\n    {\n      key        = “fleet-portal-dev-connection-string”\n      objectName = “fleet-portal-dev-connection-string”\n    }\n  ]\n  secretName = “fleet-portal-dev-connection-string”\n  type       = “Opaque”\n}\n```", "```\nlocals {\n  account_id         = data.aws_caller_identity.current.account_id\n  container_registry = “${local.account_id}.dkr.ecr.${var.primary_region}.amazonaws.com/”\n}\n```", "```\ndata “aws_caller_identity” “current” {}\n```", "```\nresource “kubernetes_deployment” “web_app” {\n  metadata {\n    name      = local.web_app_name\n    namespace = var.k8s_namespace\n  }\n  spec {\n    replicas = 3\n    selector {\n      match_labels = {\n        app = local.web_app_name\n      }\n    }\n    template {\n      metadata {\n        labels = {\n          app = local.web_app_name\n        }\n      }\n      spec {\n        service_account_name = kubernetes_service_account.workload_identity.metadata[0].name\n        container {\n          image = local.web_app_image_name\n          name  = local.web_app_name\n          port {\n            container_port = 5000\n          }\n          env_from {\n            config_map_ref {\n              name = kubernetes_config_map.web_app.metadata.0.name\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```", "```\nenv {\n  name = “DB_CONNECTION_STRING”\n  value_from {\n    secret_key_ref {\n      name = “fleet-portal-dev-connection-string”\n      key  = “fleet-portal-dev-connection-string”\n    }\n  }\n}\n```", "```\nresource “kubernetes_service” “web_app” {\n  metadata {\n    name      = “${local.web_app_name}-service”\n    namespace = var.k8s_namespace\n  }\n  spec {\n    type = “ClusterIP”\n    port {\n      port        = 80\n      target_port = 5000\n    }\n    selector = {\n      app = local.web_app_name\n    }\n  }\n}\n```", "```\nresource “kubernetes_config_map” “web_app” {\n  metadata {\n    name      = “${local.web_app_name}-config”\n    namespace = var.k8s_namespace\n  }\n  data = {\n    BackendEndpoint = “”\n  }\n}\n```", "```\nresource “helm_release” “ingress” {\n  name       = “ingress”\n  repository = “https://charts.bitnami.com/bitnami”\n  chart      = “nginx-ingress-controller”\n  create_namespace = true\n  namespace        = “ingress-nginx”\n  set {\n    name  = “service.type”\n    value = “LoadBalancer”\n  }\n  set {\n    name  = “service.annotations”\n    value = “service.beta.kubernetes.io/aws-load-balancer-type: nlb”\n  }\n}\n```", "```\nresource “kubernetes_ingress_v1” “ingress” {\n  metadata {\n    name      = “${local.web_app_name}-ingress”\n    namespace = var.k8s_namespace\n    annotations = {\n      “kubernetes.io/ingress.class” = “nginx”\n    }\n  }\n  spec {\n    rule {\n      http { ... }\n    }\n  }\n}\n```", "```\npath {\n  path      = “/”\n  path_type = “Prefix”\n  backend {\n    service {\n      name = kubernetes_service.web_app.metadata[0].name\n      port {\n        number = 80\n      }\n    }\n  }\n} \n```", "```\ndepends_on = [\n  kubernetes_service.web_app,\n  kubernetes_service.web_api,\n  helm_release.ingress\n]\n```", "```\non:\n  push:\n    branches: \n    - main\n    paths:\n    - ‘src/dotnet/frontend/**’\n```", "```\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      ...\n  packer:\n    runs-on: ubuntu-latest\n    steps:\n      ...\n```", "```\n    - id: image-version\n      name: Generate Version Number\n      run: |\n        echo “version=$(date +’%Y.%m’).${{ github.run_number }}” >> “$GITHUB_OUTPUT”\n```", "```\n    - name: Set up Docker Buildx\n      uses: docker/setup-buildx-action@v1\n```", "```\n    - name: Configure AWS Credentials\n      uses: aws-actions/configure-aws-credentials@v4\n      with:\n        aws-access-key-id: ${{ vars.AWS_ACCESS_KEY_ID }}\n        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n        aws-region: ${{ vars.PRIMARY_REGION }}\n```", "```\n    - name: Log in to Amazon ECR\n      id: login-ecr\n      uses: aws-actions/amazon-ecr-login@v2\n```", "```\n    - name: Build and push Docker image to ACR\n      uses: docker/build-push-action@v5\n      with:\n        context: ${{ env.DOCKER_WORKING_DIRECTORY }}\n        push: true\n        tags: ${{ steps.terraform.outputs.registry_endpoint }}:${{ steps.image-version.outputs.version }}\n```"]