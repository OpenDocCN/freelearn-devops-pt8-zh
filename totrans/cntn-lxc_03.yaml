- en: Chapter 3. Command-Line Operations Using Native and Libvirt Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LXC supports a variety of backing stores for its root filesystem. In [Chapter
    2,](ch02.html "Chapter 2. Installing and Running LXC on Linux Systems") *Installing
    and Running LXC on Linux Systems* we used the default `dir` type, which creates
    a directory under `/var/lib/lxc/containername/rootfs`. Using the default store
    might be sufficient in some cases, however, to take advantage of more advanced
    features, such as container snapshots and backups, other types such as the LVM,
    Btrfs, and ZFS are available.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to container snapshots, LXC provides tools for controlling resource
    usage through cgroups, the ability to execute programs before, during, and after
    the container starts, and to freeze/suspend the state of a running LXC instance.
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative to the LXC tools, we will also look at a different set of
    userspace tools and libraries for creating and managing containers, particularly
    the one provided by libvirt.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Building containers using the LVM as the backing store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LXC on Btrfs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the ZFS backing store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autostarting containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding container hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing files from the host and exploring the running filesystem of an instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Freezing running containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limiting container resource usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building containers using the libvirt library and tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the LVM backing store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Logical Volume Manager** (**LVM**) uses the device mapper framework in
    the Linux kernel that allows for mapping physical block devices onto more abstract
    virtual block devices. This abstraction allows for aggregating various block devices
    into logical volumes for better resource control. With the LVM, one can extend
    the size of a filesystem by adding more block devices to a pool of resources called
    **Physical Volumes** (**PVs**). The PVs contain block devices. From the PVs one
    can then carve out **Volume Groups** (**VGs**). The VGs can then be split, merged,
    or moved between PVs and can be resized online if enough blocks are available
    from the PVs. The VGs can have one or more **Logical Volumes** (**LVs**). The
    LVs can span across multiple disks, and hold the filesystem. If more disk space
    is to be added, one can just add a new block device to the PVs, then extend the
    VG and the LV.
  prefs: []
  type: TYPE_NORMAL
- en: The LVM allows for creating snapshots, a feature that LXC takes advantage of,
    which creates an LV to act as a clone of the original LV. Using this feature,
    we can clone containers pretty quickly as, we'll see next.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the LVM layout and the userspace tools that are
    used to manage the volumes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the LVM backing store](img/image_03_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s start by first installing the LVM package. On Ubuntu, this can be done
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'On CentOS similarly run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s examine the block device we are going to use, in this example,
    `xvdb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a partition of type LVM, we will use the `fdisk` utility, following
    the steps outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: Press `n` for creating a new partition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then choose `p` for primary partition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, choose the partition number `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the default value by just pressing the *Enter* key two times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, press `p` to print the defined partition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press `L` to list all available types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `t` to choose the partitions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose `8e` for the Linux LVM and press *Enter* to apply.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again use `p` to print the changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, use `w` to save the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the LVM partition defined, let''s create the PV:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, the `xvdb1` partition is now part of the LVM. It''s time to create
    the VG; we''ll name it `lxc` as this is the default VG that LXC uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Creating LXC containers using the LVM backing store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a container using the LVM backing store, we need to specify it on
    the command line, along with the desired root filesystem size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding truncated output, the `lxc-create` command
    made a new LV named `lvm_container` and built the container filesystem on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s list the container and the LVM volumes that were created with the `pvs`,
    `vgs`, and `lvs` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As expected, we can see the PV and the VG that we created earlier, along with
    the LV that LXC added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start the container and make sure it is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon examination of the container configuration file we can see that the backend
    store for the root filesystem is set to `lvm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Have a look at the new block devices that the device mapper has created in
    `/dev/lxc` and `/dev/mapper`, which are links to `/dev/dm-0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a second, smaller container and observe the effect of the device
    mapper again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Notice how this time the container build was much faster because the root filesystem
    was cached on disk from the earlier build and the presence of two block devices
    `dm-0` and `dm-1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get more information about the LV the LXC created for the two containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice the presence of two LVs and their respective properties.
  prefs: []
  type: TYPE_NORMAL
- en: Creating container snapshots on the LVM backing store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have containers on a backing store that supports snapshots, let's
    experiment with the `lxc-copy` utility. The `lxc-copy` utility creates copies
    of existing containers that can be either complete clones of the original container,
    meaning the entire root filesystem is copied to the new container, or snapshots,
    using **Copy-on-write** (**COW**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a snapshot of the second container and observe the
    effect on the LVs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice from the preceding output the presence of the `s` attribute, indicating
    that this container is a snapshot, and the `Origin` column listing `lvm_container_2`,
    from which we cloned. COW is a great way for quickly creating snapshots of containers
    that will use less disk space, recording only the new changes that occur after
    the snapshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, we can create a full copy of the original container filesystem,
    if we don''t specify the `--snapshot` attribute to `lxc-copy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Observe how the new clone does not have the `s` attribute and the `Origin` column
    is now blank, indicating a full copy instead of a snapshot.
  prefs: []
  type: TYPE_NORMAL
- en: Creating block devices using truncate, dd, and losetup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the examples in this chapter, it's best to use a cloud provider such as
    Rackspace or Amazon, because of their free tiers and the ability to add or block
    devices on demand. However, if you are unable to use block devices for testing,
    you can create logical block devices with the help of a few tools and use that
    instead. It goes without saying that this is just for testing and should not be
    implemented in production due to the inherited overhead of such abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s demonstrate how we can make a block device and create a PV on it for
    use with the LVM:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a file that we''ll use as a base for the new software
    block device, using either the `truncate` or `dd` commands, and specify a size
    of 5 GB:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding command created a regular 5 GB file on disk:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we'll use the `loop` kernel module and the `losetup` tool to create a
    new block device by associating the loop device with the regular file we created
    earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s load the kernel module first:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then find the first available loop device that is not in use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Associate the loop device with the image file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can use `/dev/loop0` as a regular block device. Let''s create the LVM
    PV on it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, we can use the `dd` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice how `loop1` is now the next available loop device to use:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Listing the loop devices now, show two of them associated with the regular
    files we created with `truncate` and `dd`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, to remove the loop devices, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using the Btrfs backing store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **B-tree filesystem** (**Btrfs**) is a COW filesystem that provides modern
    features such as dynamic inode allocation, compression, and online filesystem
    defragmentation - and most importantly for the purposes of this book, writable
    and read-only snapshots.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without going into much detail about the design of Btrfs, the following diagram
    shows the main components of the filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the Btrfs backing store](img/image_03_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each Btrfs filesystem consists of a **Btrfs Root Tree**, which records the root
    block for the **Extent Tree** and **Subvolume Tree**. The root block pointers
    are updated with each transaction, to point to the new roots created by the transaction.
    The **Extent Tree** shown in the preceding diagram manages disk space and contains
    information about the blocks on the device. The **Subvolume Tree** record snapshots,
    which are subvolumes.
  prefs: []
  type: TYPE_NORMAL
- en: Note that subvolumes are different than the LVs in the LVM, in the sense that
    the Btrfs subvolume is not an actual block device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a few examples on how to use the Btrfs backing store with LXC:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let's install the Btrfs support tools.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On Ubuntu, run the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On CentOS, install using:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Load the kernel module if not already loaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With Btrfs, we don''t need to have a partition on the block device, so let''s
    go ahead and create the filesystem:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice the filesystem type on the `xvdd` block device:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To get more information about the filesystem we can use the `btrfs` tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s mount the block device so we can actually use it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the device mounted, let''s show the subvolumes and disk space utilization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creating LXC containers using the Btrfs backing store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have the backing store ready, let''s create a new LXC container
    by specifying the Btrfs backing store and the location for the root filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we are using a different path for the root filesystem of the container
    than the default one in `/var/lib/lxc`. We specified it with the `--lxcpath` parameter
    to point to the Btrfs volume. We need to pass the same path each time we run LXC
    commands, or we can update the default path for the container with the `lxc-config`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can list all running Btrfs containers without explicitly specifying
    the path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The container root filesystem and configuration file reside on the Btrfs volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To make sure that the container''s root resides on the Btrfs filesystem, let''s
    list all subvolumes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Creating container snapshots on the Btrfs backing store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a COW snapshot with Btrfs is similar to that of the LVM: we specify
    the backend store, the location of the container''s root filesystem, and the name
    for the new container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what the effect on the Brtfs filesystem is after the cloning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the preceding output, we now have two subvolumes and directories
    on the Btrfs filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can start the containers, make sure that the `lxc.rootfs` config
    option points to the correct root filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On some Linux distributions and LXC versions, the `lxc.rootfs` might not point
    to the correct location of the container's filesystem, resulting in failure during
    the start. If this is the case, change the path and start the container again.
  prefs: []
  type: TYPE_NORMAL
- en: 'If all looks good, let''s start the containers and make sure they are running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To cleanup, let''s first stop the containers, unmount the Btrfs block device,
    and restore the LXC default path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Using the ZFS backing store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ZFS is both a filesystem and LVM. It consists of a storage pool that manages
    multiple block devices and provides a virtual storage interface to the filesystem
    that can then easily be extended on the go. The following diagram shows the general
    structure of ZFS and its components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the ZFS backing store](img/image_03_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Similar to the LVM, multiple block devices can be aggregated into a **Storage
    pool**, from which different directories can be carved.
  prefs: []
  type: TYPE_NORMAL
- en: The main features ZFS provides are data reliability due to the implementation
    of transparent checksums, automatic compression and deduplication of data, parallel
    constant time directory operations and, most importantly in the context of LXC,
    COW snapshots and clones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s install the userspace tools on Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The package names are different on CentOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, load the kernel module and ensure it''s being used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a pool named `lxc` as this is the default name that LXC uses
    for the ZFS backend when creating the container root filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Substitute `xvdb` with the name of the block device you would like to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s list the newly created pool and check its status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything looks good; let''s see the mount point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: With this, we are ready to use ZFS as a backing store for LXC.
  prefs: []
  type: TYPE_NORMAL
- en: Creating LXC containers using the ZFS backing store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a new LXC container by specifying the backing store and the root
    filesystem path in the same way we did with the LVM and Btrfs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that since we are using a custom path for the root filesystem of the container,
    each LXC command will need to be passed the `--lxcpath` parameter. This can be
    avoided by specifying the new path with the `lxc.lxcpath` variable in the system
    wide LXC config file, as we saw in the Btrfs section earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the root filesystem resides on the ZFS volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Creating container snapshots on the ZFS backing store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s make a snapshot based on the container we just built. Make sure the
    original container is stopped and the location of the root filesystem is specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The clone directory resides on the ZFS filesystem:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, start both containers and ensure they are in a running state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally let''s clean up. First, stop the containers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, try to destroy both the containers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The clone got destroyed but the original container failed. This is because
    we first need to clean up the child ZFS dataset that was created when snapshotting
    the original container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, delete the ZFS pool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this, ZFS does not contain any datasets or pools.
  prefs: []
  type: TYPE_NORMAL
- en: Autostarting LXC containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, LXC containers do not start after a server reboot. To change that,
    we can use the `lxc-autostart` tool and the containers configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, let''s create a new container first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the `lxc.start.auto` stanza to its config file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'List all containers that are configured to start automatically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can use the `lxc-autostart` command again to start all containers configured
    to autostart, in this case just one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Two other useful autostart configuration parameters are adding a delay to the
    start, and defining a group in which multiple containers can start as a single
    unit. Stop the container and add the following to configuration options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s list the containers configured to autostart again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice that no containers showed from the preceding output. This is because
    our container now belongs to an autostart group. Let''s specify it:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, start all containers belonging to a given autostart group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For `lxc-autostart` to automatically start containers after a server reboot,
    it first needs to be started. This can be achieved by either adding the preceding
    command in `crontab`, or creating an init script.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, in order to clean up, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: LXC container hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'LXC provides a convenient way to execute programs during the life cycle of
    containers. The following table summarizes the various configuration options available
    to allow this feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Option** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `lxc.hook.pre-start` | A hook to be run in the host namespace before the
    container ttys, consoles, or mounts are loaded |'
  prefs: []
  type: TYPE_TB
- en: '| `lxc.hook.pre-mount` | A hook to be run in the container''s filesystem namespace,
    but before the `rootfs` has been set up |'
  prefs: []
  type: TYPE_TB
- en: '| `lxc.hook.mount` | A hook to be run in the container after mounting has been
    done, but before the `pivot_root` |'
  prefs: []
  type: TYPE_TB
- en: '| `lxc.hook.autodev` | A hook to be run in the container after mounting has
    been done and after any mount hooks have run, but before the `pivot_root` |'
  prefs: []
  type: TYPE_TB
- en: '| `lxc.hook.start` | A hook to be run in the container right before executing
    the container''s init |'
  prefs: []
  type: TYPE_TB
- en: '| `lxc.hook.stop` | A hook to be run in the host''s namespace after the container
    has been shut down |'
  prefs: []
  type: TYPE_TB
- en: '| `lxc.hook.post-stop` | A hook to be run in the host''s namespace after the
    container has been shut down |'
  prefs: []
  type: TYPE_TB
- en: '| `lxc.hook.clone` | A hook to be run when the container is cloned |'
  prefs: []
  type: TYPE_TB
- en: '| `lxc.hook.destroy` | A hook to be run when the container is destroyed |'
  prefs: []
  type: TYPE_TB
- en: 'To demonstrate this, let''s create a new container and write a simple script
    that will output the values of four LXC variables to a file, when the container
    starts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create the container and add the `lxc.hook.pre-start` option to its
    configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a simple bash script and make it executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the container and check the contents of the file that the bash script
    should have written to, ensuring the script got triggered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: From the preceding output, we can see that the script got triggered when we
    started the container, and the value of the LXC variables got written to the temp
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching directories from the host OS and exploring the running filesystem
    of a container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The root filesystem of LXC containers is visible from the host OS as a regular
    directory tree. We can directly manipulate files in a running container by just
    making changes in that directory. LXC also allows for attaching directories from
    the host OS inside the container using bind mount. A bind mount is a different
    view of the directory tree. It achieves this by replicating the existing directory
    tree under a different mount point.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, let''s create a new container, directory, and a file on
    the host:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we are going to use the `lxc.mount.entry` option in the configuration
    file of the container, telling LXC what directory to bind mount from the host,
    and the mount point inside the container to bind to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the container is started, we can see that the `/mnt` inside it now contains
    the file that we created in the `/tmp/export_to_container` directory on the host
    OS earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When an LXC container is in a running state, some files are only visible from
    `/proc` on the host OS. To examine the running directory of a container, first
    grab its PID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the PID in hand, we can examine the running directory of the container:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure you replace the PID with the output of `lxc-info` from your host,
    as it will differ from the preceding example.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In order to make persistent changes in the root filesystem of a container, modify
    the files in `/var/lib/lxc/mount_container/rootfs/` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Freezing a running container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LXC takes advantage of the `freezer` cgroup to freeze all the processes running
    inside a container. The processes will be in a blocked state until thawed. Freezing
    a container can be useful in cases where the system load is high and you want
    to free some resources without actually stopping the container and preserving
    its running state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure you have a running container and check its state from the `freezer`
    cgroup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how a currently running container shows as thawed. Let''s freeze it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The container state shows as frozen, let''s check the cgroup file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'To unfreeze it, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We can monitor the state change by running the `lxc-monitor` command on a separate
    console while freezing and unfreezing a container. The change of the container''s
    state will show as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Limiting container resource usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Introduction to Linux Containers"), *Introduction
    to Linux Containers* we saw how easy it is to limit process resources by either
    directly manipulating files in the cgroup hierarchy or using the userspace tools.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, LXC comes with tools that are just as straightforward and easy to
    use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by setting up the available memory for a container to 512 MB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'We can verify that the new setting has been applied by directly inspecting
    the `memory` cgroup for the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Changing the value only requires running the same command again. Let''s change
    the available memory to 256 MB and inspect the container by attaching to it and
    running the free utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: As the preceding output shows, the container only has a total available memory
    of 256 MB.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also pin a CPU core to a container. In the next example, our test server
    has two cores. Let''s allow the container to only run on core 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: By attaching to the container and checking the available CPUs, we see that only
    one is presented, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make changes to persist server reboots, we need to add them to the configuration
    file of the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting various other cgroup parameters is done in a similar way. For example,
    let''s see the cpu shares and the block IO on a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: For a full list of all available cgroup options refer to [Chapter 1](ch01.html
    "Chapter 1. Introduction to Linux Containers"), *Introduction to Linux Containers,*
    or explore the mounted cgroup hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Building and running LXC containers with libvirt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Libvirt is a set of libraries and language bindings used to interact with various
    virtualization technologies in a standard and uniform way. These include KVM,
    XEN, QEMU, OpenVZ, and of course LXC. Libvirt uses XML files to define virtualized
    entities such as LXC containers, and describe their properties, such as available
    memory, block devices, networking, the init system, and other metadata. It supports
    multiple storage drivers such as the LVM, local and network filesystems, iSCSI,
    and others.
  prefs: []
  type: TYPE_NORMAL
- en: Libvirt provides a completely independent way of working with Linux containers
    from the mainstream LXC project and the toolset we've seen and used so far. It
    implements the kernel feature set that constitutes LXC, and exposes its own tools
    and libraries to work with containers without the need to install other packages.
    In [Chapter 4](ch04.html "Chapter 4. LXC Code Integration with Python"), *LXC
    Code Integration with Python,* we'll see how to write Python programs using the
    libvirt API, but for now let's explore the toolkit that it provides.
  prefs: []
  type: TYPE_NORMAL
- en: Installing libvirt from packages on Debian and CentOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both Ubuntu and CentOS package libvirt, though the versions are lagging behind
    from the upstream trunk. For the latest version, we'll compile it from source
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To get the most out of the examples in this chapter and avoid conflicts and
    errors, I recommend that you use a fresh VM or a new cloud instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the packages on Ubuntu run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, make sure the libvirt daemon is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'On CentOS, the package name is different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Once package install is complete, start the libvirt service and ensure it''s
    running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: For the rest of the examples in this chapter we'll be using the latest version
    of libvirt compiled from source on Ubuntu.
  prefs: []
  type: TYPE_NORMAL
- en: Installing libvirt from source
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On Ubuntu, make sure your system is up to date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, install the prerequisite packages that will enable us to obtain the source
    from `git` and build it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'With all the packages installed, let''s clone the source from the master `git`
    branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Generate the config file, compile and install the binaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the necessary links and cache to the most recent shared libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the libvirt daemon and check its version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Defining LXC containers with libvirt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To build a container, we need to define its properties in an XML file that Libvirt
    will use. Once defined, libvirt starts a helper process called `libvirt_lxc`,
    responsible for creating the actual container, spawning the first process and
    handling I/O. Depending on the installation type, version, and distribution, its
    location may differ, so let's find it.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Ubuntu, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'On CentOS, the location will be different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'As pointed out earlier, libvirt supports many different hypervisors and to
    accommodate working with all of them it uses hypervisor canonical URIs. The URI
    points to the hypervisor that libvirt will communicate with. To list the currently
    configured URI, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding output, we can see that the default URI is QEMU. To work
    with LXC we''ll need to change it. To do that, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'For the life of your session, the default hypervisor will now be LXC. You can
    explicitly tell libvirt what to use by passing it as a command-line option. For
    example, to list all LXC containers you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can define and build a container, we''ll need a root filesystem for
    it. Let''s build one using `debootstrap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'With the root filesystem in place, let''s define the container properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: The file is mostly self-explanatory and well documented. We define the domain
    type to be `lxc`, memory and CPU properties, the location of the root filesystem,
    and most importantly, the location of the `libvirt_lxc` helper process. In the
    networking section, we define a MAC address and the name of the host bridge. Not
    all options need to be specified, and if omitted, libvirt will create sane defaults.
    Later in this chapter, I'll demonstrate how we can generate this file from an
    LXC container that was built with the LXC tools instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the file in place let''s define the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: We see that the container is now defined but in a shut-off state.
  prefs: []
  type: TYPE_NORMAL
- en: Starting and connecting to LXC containers with libvirt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The container we defined earlier specifies the `lxcbr0` bridge. We need to
    create it before we can start the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a defined container and a bridge to connect it to, let''s
    go ahead and start it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can connect to the container''s console, we need to add it to the
    allowed terminals. To do this, we can `chroot` to the filesystem of the container
    and edit the `securetty` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s connect to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Attaching block devices to running containers with libvirt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Libvirt provides a convenient way of attaching block devices to an already
    running container. To demonstrate this, let''s create a block device from a regular
    file, as demonstrated earlier in this chapter using the `truncate` and `losetup`
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Our new block device is now `/dev/loop0`. Let''s create a filesystem on it,
    mount it, and create a test file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Time to define the block device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding config file, we define the driver to be `lxc`, the path to
    the block device we just created, and the name of the device that will be presented
    inside the container, in this case `vdb`. It''s time to attach the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s connect to the container and make sure the block device is there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'To detach the block device we can similarly run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Networking with libvirt LXC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Libvirt comes with a default network that uses `dnsmasq` and is configured
    to start automatically. To list all networks, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'To examine the configuration of the default network let''s dump it to XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'From the output, it''s apparent that the default networks will create a bridge
    named `virbr0`, and what the network ranges configured in `dnsmasq` are. If we''d
    rather use our own network, we can describe its properties in a new XML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the name of the bridge will be `br0` and it will use a different
    subnet. Let''s define it and list the networks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'We can confirm that the two networks created the bridges by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the `lxcbr0` is the one we created manually earlier. Each network
    will start a `dnsmasq` process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: To build a container that will be part of one of the defined networks, we need
    to change the name of the bridge in the XML file, log in the container, and configure
    the network interface.
  prefs: []
  type: TYPE_NORMAL
- en: Generating config from an existing LXC container with libvirt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Libvirt provides a way to convert the config file of an existing LXC container
    that was built with the LXC tools we used in the beginning of this chapter to
    a format that libvirt can use.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, let''s create a new LXC container with `lxc-create`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'With the new container ready, let''s convert its configuration file to the
    XML specification that libvirt supports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command is the new configuration file for the container in
    XML format saved in the `lxc-container.xml` file. We can use this file to start
    the container with `virsh` instead of `lxc-start`. Before we can do this, we need
    to specify a console type first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the new container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'And start it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Stopping and removing LXC containers with libvirt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s stop all the running libvirt containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'To completely remove the containers, we need to undefine them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LXC supports various backing stores for its filesystem. In this chapter, we
    explored how to use the LVM, Btrfs, and ZFS backing stores to create COW snapshots.
    We also looked into how to create block devices from regular files for testing
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: We demonstrated how to autostart containers, create hooks that will execute
    programs during the life cycle of the instance, and how to expose directories
    and files from the host OS to LXC.
  prefs: []
  type: TYPE_NORMAL
- en: LXC uses the cgroup mechanism for controlling and allocating resources to containers.
    Changes to these resources are stored in the config file and can be persisted
    if the need arises. We explored ways of doing that with the provided toolset.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we introduced a different way of creating and managing LXC with libvirt
    and the `virsh` command.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll have a look at how to create and manage containers
    using the LXC APIs and libvirt bindings for Python.
  prefs: []
  type: TYPE_NORMAL
