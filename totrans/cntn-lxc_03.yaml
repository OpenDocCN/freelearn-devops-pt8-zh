- en: Chapter 3. Command-Line Operations Using Native and Libvirt Tools
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章 使用原生和 Libvirt 工具的命令行操作
- en: LXC supports a variety of backing stores for its root filesystem. In [Chapter
    2,](ch02.html "Chapter 2. Installing and Running LXC on Linux Systems") *Installing
    and Running LXC on Linux Systems* we used the default `dir` type, which creates
    a directory under `/var/lib/lxc/containername/rootfs`. Using the default store
    might be sufficient in some cases, however, to take advantage of more advanced
    features, such as container snapshots and backups, other types such as the LVM,
    Btrfs, and ZFS are available.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: LXC 支持多种后备存储用于其根文件系统。在 [第 2 章，](ch02.html "第 2 章. 在 Linux 系统上安装和运行 LXC") *在
    Linux 系统上安装和运行 LXC* 中，我们使用了默认的 `dir` 类型，该类型在 `/var/lib/lxc/containername/rootfs`
    下创建一个目录。使用默认存储在某些情况下可能足够，但为了利用更多高级功能，如容器快照和备份，还可以使用其他类型，如 LVM、Btrfs 和 ZFS。
- en: In addition to container snapshots, LXC provides tools for controlling resource
    usage through cgroups, the ability to execute programs before, during, and after
    the container starts, and to freeze/suspend the state of a running LXC instance.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 除了容器快照，LXC 还提供了通过 cgroups 控制资源使用的工具，能够在容器启动前、启动时和启动后执行程序，并冻结/挂起正在运行的 LXC 实例的状态。
- en: As an alternative to the LXC tools, we will also look at a different set of
    userspace tools and libraries for creating and managing containers, particularly
    the one provided by libvirt.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 LXC 工具的替代方案，我们还将查看一组不同的用户空间工具和库，用于创建和管理容器，特别是 libvirt 提供的工具。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Building containers using the LVM as the backing store
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 LVM 作为后备存储构建容器
- en: LXC on Btrfs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LXC 在 Btrfs 上
- en: Using the ZFS backing store
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ZFS 后备存储
- en: Autostarting containers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动启动容器
- en: Adding container hooks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加容器钩子
- en: Accessing files from the host and exploring the running filesystem of an instance
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从主机访问文件并探索实例的运行文件系统
- en: Freezing running containers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冻结正在运行的容器
- en: Limiting container resource usage
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制容器资源使用
- en: Building containers using the libvirt library and tools
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 libvirt 库和工具构建容器
- en: Using the LVM backing store
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 LVM 后备存储
- en: The **Logical Volume Manager** (**LVM**) uses the device mapper framework in
    the Linux kernel that allows for mapping physical block devices onto more abstract
    virtual block devices. This abstraction allows for aggregating various block devices
    into logical volumes for better resource control. With the LVM, one can extend
    the size of a filesystem by adding more block devices to a pool of resources called
    **Physical Volumes** (**PVs**). The PVs contain block devices. From the PVs one
    can then carve out **Volume Groups** (**VGs**). The VGs can then be split, merged,
    or moved between PVs and can be resized online if enough blocks are available
    from the PVs. The VGs can have one or more **Logical Volumes** (**LVs**). The
    LVs can span across multiple disks, and hold the filesystem. If more disk space
    is to be added, one can just add a new block device to the PVs, then extend the
    VG and the LV.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**逻辑卷管理器**（**LVM**）使用 Linux 内核中的设备映射框架，该框架允许将物理块设备映射到更抽象的虚拟块设备上。这种抽象允许将各种块设备聚合到逻辑卷中，从而更好地控制资源。通过
    LVM，可以通过向称为 **物理卷**（**PVs**）的资源池中添加更多块设备来扩展文件系统的大小。PVs 包含块设备。然后可以从 PV 中切出 **卷组**（**VGs**）。VG
    可以在 PV 之间拆分、合并或移动，如果 PV 中有足够的块，则可以在线调整其大小。VG 可以拥有一个或多个 **逻辑卷**（**LVs**）。LV 可以跨多个磁盘并承载文件系统。如果需要添加更多磁盘空间，可以向
    PV 中添加新的块设备，然后扩展 VG 和 LV。'
- en: The LVM allows for creating snapshots, a feature that LXC takes advantage of,
    which creates an LV to act as a clone of the original LV. Using this feature,
    we can clone containers pretty quickly as, we'll see next.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: LVM 允许创建快照，这是 LXC 利用的功能，它创建一个 LV 作为原始 LV 的克隆。通过此功能，我们可以快速克隆容器，正如我们接下来所看到的那样。
- en: 'The following diagram shows the LVM layout and the userspace tools that are
    used to manage the volumes:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了 LVM 布局以及用于管理卷的用户空间工具：
- en: '![Using the LVM backing store](img/image_03_001.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![使用 LVM 后备存储](img/image_03_001.jpg)'
- en: 'Let''s start by first installing the LVM package. On Ubuntu, this can be done
    with the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们从安装 LVM 包开始。在 Ubuntu 上，可以通过以下命令来完成：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'On CentOS similarly run:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CentOS 上同样运行：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, let''s examine the block device we are going to use, in this example,
    `xvdb`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们检查一下我们将要使用的块设备，在本例中为 `xvdb`：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To create a partition of type LVM, we will use the `fdisk` utility, following
    the steps outlined here:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建LVM类型的分区，我们将使用`fdisk`工具，按照这里的步骤进行：
- en: Press `n` for creating a new partition.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按`n`键创建一个新分区。
- en: Then choose `p` for primary partition.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后选择`p`为主分区。
- en: Next, choose the partition number `1`.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择分区号`1`。
- en: Use the default value by just pressing the *Enter* key two times.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只需按两次*Enter*键使用默认值。
- en: Next, press `p` to print the defined partition.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，按`p`打印出定义的分区。
- en: Press `L` to list all available types.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按`L`列出所有可用的类型。
- en: Type `t` to choose the partitions.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`t`来选择分区。
- en: Choose `8e` for the Linux LVM and press *Enter* to apply.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`8e`作为Linux LVM类型，并按*Enter*键应用。
- en: Again use `p` to print the changes.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用`p`打印出更改。
- en: 'Finally, use `w` to save the changes:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，按`w`保存更改：
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With the LVM partition defined, let''s create the PV:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 定义好LVM分区后，我们来创建PV：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With this, the `xvdb1` partition is now part of the LVM. It''s time to create
    the VG; we''ll name it `lxc` as this is the default VG that LXC uses:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`xvdb1`分区现在成为了LVM的一部分。接下来是创建VG，我们将其命名为`lxc`，因为这是LXC使用的默认VG：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Creating LXC containers using the LVM backing store
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用LVM存储后端创建LXC容器
- en: 'To create a container using the LVM backing store, we need to specify it on
    the command line, along with the desired root filesystem size:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用LVM存储后端创建容器，我们需要在命令行中指定它，并指定所需的根文件系统大小：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see from the preceding truncated output, the `lxc-create` command
    made a new LV named `lvm_container` and built the container filesystem on it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面截断的输出中可以看到，`lxc-create`命令创建了一个名为`lvm_container`的新LV，并在其上构建了容器文件系统。
- en: 'Let''s list the container and the LVM volumes that were created with the `pvs`,
    `vgs`, and `lvs` commands:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`pvs`、`vgs`和`lvs`命令列出创建的容器和LVM卷：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As expected, we can see the PV and the VG that we created earlier, along with
    the LV that LXC added.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期所示，我们可以看到之前创建的PV和VG，以及LXC添加的LV。
- en: 'Let''s start the container and make sure it is running:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动容器，并确保它正在运行：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Upon examination of the container configuration file we can see that the backend
    store for the root filesystem is set to `lvm`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 检查容器配置文件时，我们可以看到根文件系统的后端存储被设置为`lvm`：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Have a look at the new block devices that the device mapper has created in
    `/dev/lxc` and `/dev/mapper`, which are links to `/dev/dm-0`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 查看设备映射器在`/dev/lxc`和`/dev/mapper`中创建的新块设备，它们是`/dev/dm-0`的链接：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s create a second, smaller container and observe the effect of the device
    mapper again:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个第二个较小的容器，并观察设备映射器的效果：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice how this time the container build was much faster because the root filesystem
    was cached on disk from the earlier build and the presence of two block devices
    `dm-0` and `dm-1`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到这次容器的构建速度更快，因为根文件系统已经被缓存到磁盘中，并且存在两个块设备`dm-0`和`dm-1`。
- en: 'Let''s get more information about the LV the LXC created for the two containers:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们获取更多关于LXC为两个容器创建的LV的信息：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice the presence of two LVs and their respective properties.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到有两个LV及其各自的属性。
- en: Creating container snapshots on the LVM backing store
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在LVM存储后端上创建容器快照
- en: Now that we have containers on a backing store that supports snapshots, let's
    experiment with the `lxc-copy` utility. The `lxc-copy` utility creates copies
    of existing containers that can be either complete clones of the original container,
    meaning the entire root filesystem is copied to the new container, or snapshots,
    using **Copy-on-write** (**COW**).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有支持快照的存储后端容器，接下来我们来试验一下`lxc-copy`工具。`lxc-copy`工具可以创建现有容器的副本，这些副本可以是原始容器的完整克隆，意味着整个根文件系统都会被复制到新容器中，或者是快照，采用**写时复制**（**COW**）。
- en: 'Let''s start by creating a snapshot of the second container and observe the
    effect on the LVs:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建第二个容器的快照开始，并观察LV的变化：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice from the preceding output the presence of the `s` attribute, indicating
    that this container is a snapshot, and the `Origin` column listing `lvm_container_2`,
    from which we cloned. COW is a great way for quickly creating snapshots of containers
    that will use less disk space, recording only the new changes that occur after
    the snapshot.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中可以注意到`s`属性，表示该容器是一个快照，而`Origin`列显示了`lvm_container_2`，这是我们克隆的容器。COW（写时复制）是一种快速创建容器快照的好方法，能够节省磁盘空间，仅记录快照后发生的新变化。
- en: 'In contrast, we can create a full copy of the original container filesystem,
    if we don''t specify the `--snapshot` attribute to `lxc-copy`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果我们不为 `lxc-copy` 指定 `--snapshot` 属性，我们可以创建原始容器文件系统的完整副本：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Observe how the new clone does not have the `s` attribute and the `Origin` column
    is now blank, indicating a full copy instead of a snapshot.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 观察新克隆容器没有 `s` 属性，并且 `Origin` 列现在为空，这表示它是完整的副本，而不是快照。
- en: Creating block devices using truncate, dd, and losetup
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 truncate、dd 和 losetup 创建块设备
- en: For the examples in this chapter, it's best to use a cloud provider such as
    Rackspace or Amazon, because of their free tiers and the ability to add or block
    devices on demand. However, if you are unable to use block devices for testing,
    you can create logical block devices with the help of a few tools and use that
    instead. It goes without saying that this is just for testing and should not be
    implemented in production due to the inherited overhead of such abstractions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章中的示例，最好使用诸如 Rackspace 或 Amazon 之类的云服务提供商，因为它们提供免费套餐，并且能够按需添加或阻塞设备。然而，如果无法使用块设备进行测试，您可以借助一些工具创建逻辑块设备并使用它。无需多言，这仅适用于测试，并且由于此类抽象所带来的额外开销，不应在生产环境中实施。
- en: 'Let''s demonstrate how we can make a block device and create a PV on it for
    use with the LVM:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们展示如何创建一个块设备，并在其上创建一个 PV 供 LVM 使用：
- en: 'First, let''s create a file that we''ll use as a base for the new software
    block device, using either the `truncate` or `dd` commands, and specify a size
    of 5 GB:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个文件，作为新软件块设备的基础，可以使用 `truncate` 或 `dd` 命令，并指定大小为 5 GB：
- en: '[PRE15]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding command created a regular 5 GB file on disk:'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述命令在磁盘上创建了一个常规的 5 GB 文件：
- en: '[PRE16]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Next, we'll use the `loop` kernel module and the `losetup` tool to create a
    new block device by associating the loop device with the regular file we created
    earlier.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 `loop` 内核模块和 `losetup` 工具，通过将环回设备与之前创建的常规文件关联，来创建一个新的块设备。
- en: 'Let''s load the kernel module first:'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们加载内核模块：
- en: '[PRE17]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then find the first available loop device that is not in use:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，找到第一个未使用的可用环回设备：
- en: '[PRE18]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Associate the loop device with the image file:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将环回设备与映像文件关联：
- en: '[PRE19]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we can use `/dev/loop0` as a regular block device. Let''s create the LVM
    PV on it:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将 `/dev/loop0` 作为常规块设备使用。让我们在其上创建 LVM PV：
- en: '[PRE20]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Alternatively, we can use the `dd` command:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 `dd` 命令：
- en: '[PRE21]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Notice how `loop1` is now the next available loop device to use:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，`loop1` 现在是下一个可用的环回设备：
- en: '[PRE22]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing the loop devices now, show two of them associated with the regular
    files we created with `truncate` and `dd`:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在列出环回设备，显示其中两个与我们通过 `truncate` 和 `dd` 创建的常规文件关联：
- en: '[PRE23]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, to remove the loop devices, run the following:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，若要移除环回设备，请运行以下命令：
- en: '[PRE24]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Using the Btrfs backing store
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Btrfs 后备存储
- en: The **B-tree filesystem** (**Btrfs**) is a COW filesystem that provides modern
    features such as dynamic inode allocation, compression, and online filesystem
    defragmentation - and most importantly for the purposes of this book, writable
    and read-only snapshots.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**B 树文件系统**（**Btrfs**）是一个 COW 文件系统，提供现代功能，如动态 inode 分配、压缩和在线文件系统碎片整理——最重要的是，适用于本书目的，可写和只读的快照。'
- en: 'Without going into much detail about the design of Btrfs, the following diagram
    shows the main components of the filesystem:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入讨论 Btrfs 的设计，下面的图示展示了文件系统的主要组件：
- en: '![Using the Btrfs backing store](img/image_03_002.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Btrfs 后备存储](img/image_03_002.jpg)'
- en: Each Btrfs filesystem consists of a **Btrfs Root Tree**, which records the root
    block for the **Extent Tree** and **Subvolume Tree**. The root block pointers
    are updated with each transaction, to point to the new roots created by the transaction.
    The **Extent Tree** shown in the preceding diagram manages disk space and contains
    information about the blocks on the device. The **Subvolume Tree** record snapshots,
    which are subvolumes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Btrfs 文件系统包含一个 **Btrfs 根树**，它记录 **Extent Tree** 和 **Subvolume Tree** 的根块。根块指针会随着每次事务的进行而更新，指向由事务创建的新根。前面图示中的
    **Extent Tree** 管理磁盘空间，并包含设备上块的信息。**Subvolume Tree** 记录快照，这些快照是子卷。
- en: Note that subvolumes are different than the LVs in the LVM, in the sense that
    the Btrfs subvolume is not an actual block device.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，子卷与 LVM 中的 LV 是不同的，因为 Btrfs 子卷并不是一个实际的块设备。
- en: 'Let''s look at a few examples on how to use the Btrfs backing store with LXC:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看几个例子，了解如何在 LXC 中使用 Btrfs 后备存储：
- en: First, let's install the Btrfs support tools.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们安装 Btrfs 支持工具。
- en: 'On Ubuntu, run the following:'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Ubuntu 上，运行以下命令：
- en: '[PRE25]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'On CentOS, install using:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 CentOS 上，通过以下命令进行安装：
- en: '[PRE26]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Load the kernel module if not already loaded:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未加载，请加载内核模块：
- en: '[PRE27]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With Btrfs, we don''t need to have a partition on the block device, so let''s
    go ahead and create the filesystem:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Btrfs 时，我们不需要在块设备上创建分区，因此可以直接创建文件系统：
- en: '[PRE28]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Notice the filesystem type on the `xvdd` block device:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `xvdd` 块设备上的文件系统类型：
- en: '[PRE29]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To get more information about the filesystem we can use the `btrfs` tool:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取有关文件系统的更多信息，我们可以使用 `btrfs` 工具：
- en: '[PRE30]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s mount the block device so we can actually use it:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们挂载块设备，以便实际使用它：
- en: '[PRE31]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With the device mounted, let''s show the subvolumes and disk space utilization:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 挂载设备后，让我们展示子卷和磁盘空间使用情况：
- en: '[PRE32]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Creating LXC containers using the Btrfs backing store
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Btrfs 后端存储创建 LXC 容器
- en: 'Now that we have the backing store ready, let''s create a new LXC container
    by specifying the Btrfs backing store and the location for the root filesystem:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好后端存储，让我们通过指定 Btrfs 后端存储和根文件系统位置来创建一个新的 LXC 容器：
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Note that we are using a different path for the root filesystem of the container
    than the default one in `/var/lib/lxc`. We specified it with the `--lxcpath` parameter
    to point to the Btrfs volume. We need to pass the same path each time we run LXC
    commands, or we can update the default path for the container with the `lxc-config`
    command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们为容器的根文件系统使用了与 `/var/lib/lxc` 默认路径不同的路径。我们通过 `--lxcpath` 参数指定它指向 Btrfs
    卷。每次运行 LXC 命令时，我们需要传递相同的路径，或者可以通过 `lxc-config` 命令更新容器的默认路径：
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we can list all running Btrfs containers without explicitly specifying
    the path:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以列出所有正在运行的 Btrfs 容器，而无需显式指定路径：
- en: '[PRE35]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The container root filesystem and configuration file reside on the Btrfs volume:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的根文件系统和配置文件位于 Btrfs 卷上：
- en: '[PRE36]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To make sure that the container''s root resides on the Btrfs filesystem, let''s
    list all subvolumes:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保容器的根目录位于 Btrfs 文件系统上，让我们列出所有子卷：
- en: '[PRE37]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Creating container snapshots on the Btrfs backing store
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Btrfs 后端存储上创建容器快照
- en: 'Creating a COW snapshot with Btrfs is similar to that of the LVM: we specify
    the backend store, the location of the container''s root filesystem, and the name
    for the new container:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Btrfs 创建 COW 快照与 LVM 类似：我们需要指定后端存储、容器根文件系统的位置以及新容器的名称：
- en: '[PRE38]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s see what the effect on the Brtfs filesystem is after the cloning:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看克隆操作后对 Btrfs 文件系统的影响：
- en: '[PRE39]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As we can see from the preceding output, we now have two subvolumes and directories
    on the Btrfs filesystem.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中可以看到，我们现在在 Btrfs 文件系统上有两个子卷和目录。
- en: 'Before we can start the containers, make sure that the `lxc.rootfs` config
    option points to the correct root filesystem:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动容器之前，确保 `lxc.rootfs` 配置选项指向正确的根文件系统：
- en: '[PRE40]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Tip
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: On some Linux distributions and LXC versions, the `lxc.rootfs` might not point
    to the correct location of the container's filesystem, resulting in failure during
    the start. If this is the case, change the path and start the container again.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些 Linux 发行版和 LXC 版本中，`lxc.rootfs` 可能指向错误的容器文件系统位置，从而导致启动失败。如果是这种情况，请更改路径并重新启动容器。
- en: 'If all looks good, let''s start the containers and make sure they are running:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，我们启动容器并确保它们正在运行：
- en: '[PRE41]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To cleanup, let''s first stop the containers, unmount the Btrfs block device,
    and restore the LXC default path:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行清理，首先停止容器，卸载 Btrfs 块设备，并恢复 LXC 默认路径：
- en: '[PRE42]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Using the ZFS backing store
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ZFS 后端存储
- en: 'ZFS is both a filesystem and LVM. It consists of a storage pool that manages
    multiple block devices and provides a virtual storage interface to the filesystem
    that can then easily be extended on the go. The following diagram shows the general
    structure of ZFS and its components:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ZFS 既是一个文件系统，又是一个 LVM。它由一个存储池组成，管理多个块设备，并为文件系统提供虚拟存储接口，之后可以轻松扩展。以下图示展示了 ZFS
    的总体结构及其组件：
- en: '![Using the ZFS backing store](img/image_03_003.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![使用 ZFS 后端存储](img/image_03_003.jpg)'
- en: Similar to the LVM, multiple block devices can be aggregated into a **Storage
    pool**, from which different directories can be carved.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 与 LVM 类似，多个块设备可以聚合成一个 **存储池**，从中可以划分出不同的目录。
- en: The main features ZFS provides are data reliability due to the implementation
    of transparent checksums, automatic compression and deduplication of data, parallel
    constant time directory operations and, most importantly in the context of LXC,
    COW snapshots and clones.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ZFS 提供的主要功能包括由于透明校验和的实现而带来的数据可靠性、自动压缩和去重、并行常数时间目录操作，以及在 LXC 环境下最重要的功能：COW 快照和克隆。
- en: 'Let''s install the userspace tools on Ubuntu:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Ubuntu上安装用户空间工具：
- en: '[PRE43]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The package names are different on CentOS:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在CentOS上，软件包名称不同：
- en: '[PRE44]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, load the kernel module and ensure it''s being used:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，加载内核模块并确保它正在使用：
- en: '[PRE45]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s create a pool named `lxc` as this is the default name that LXC uses
    for the ZFS backend when creating the container root filesystem:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`lxc`的池，因为这是LXC在创建容器根文件系统时使用的ZFS后端的默认名称：
- en: '[PRE46]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Substitute `xvdb` with the name of the block device you would like to use.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 将`xvdb`替换为你想要使用的块设备名称。
- en: 'Let''s list the newly created pool and check its status:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出新创建的池并检查其状态：
- en: '[PRE47]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Everything looks good; let''s see the mount point:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一切看起来不错，让我们查看挂载点：
- en: '[PRE48]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: With this, we are ready to use ZFS as a backing store for LXC.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经准备好将ZFS作为LXC的后端存储来使用。
- en: Creating LXC containers using the ZFS backing store
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ZFS后端存储创建LXC容器
- en: 'Let''s create a new LXC container by specifying the backing store and the root
    filesystem path in the same way we did with the LVM and Btrfs:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过指定后端存储和根文件系统路径来创建一个新的LXC容器，就像我们在LVM和Btrfs中做的那样：
- en: '[PRE49]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that since we are using a custom path for the root filesystem of the container,
    each LXC command will need to be passed the `--lxcpath` parameter. This can be
    avoided by specifying the new path with the `lxc.lxcpath` variable in the system
    wide LXC config file, as we saw in the Btrfs section earlier in this chapter.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于我们使用的是自定义路径作为容器的根文件系统，每个LXC命令都需要传递`--lxcpath`参数。通过在系统范围的LXC配置文件中指定新的路径，可以避免这种情况，就像我们在本章的Btrfs部分中看到的那样。
- en: 'Note that the root filesystem resides on the ZFS volume:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，根文件系统位于ZFS卷上：
- en: '[PRE50]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Creating container snapshots on the ZFS backing store
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在ZFS后端存储上创建容器快照
- en: 'Let''s make a snapshot based on the container we just built. Make sure the
    original container is stopped and the location of the root filesystem is specified:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们基于刚刚创建的容器做一个快照。确保原始容器已停止，并指定根文件系统的位置：
- en: '[PRE51]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The clone directory resides on the ZFS filesystem:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆目录位于ZFS文件系统上：
- en: '[PRE52]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, start both containers and ensure they are in a running state:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，启动两个容器并确保它们处于运行状态：
- en: '[PRE53]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally let''s clean up. First, stop the containers:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们清理一下。首先，停止容器：
- en: '[PRE54]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next, try to destroy both the containers:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，尝试销毁两个容器：
- en: '[PRE55]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The clone got destroyed but the original container failed. This is because
    we first need to clean up the child ZFS dataset that was created when snapshotting
    the original container:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆被销毁了，但原始容器失败了。这是因为我们首先需要清理在快照原始容器时创建的子ZFS数据集：
- en: '[PRE56]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally, delete the ZFS pool:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，删除ZFS池：
- en: '[PRE57]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: With this, ZFS does not contain any datasets or pools.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，ZFS中没有任何数据集或池。
- en: Autostarting LXC containers
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动启动LXC容器
- en: 'By default, LXC containers do not start after a server reboot. To change that,
    we can use the `lxc-autostart` tool and the containers configuration file:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，LXC容器在服务器重启后不会启动。要更改这一点，我们可以使用`lxc-autostart`工具和容器配置文件：
- en: 'To demonstrate this, let''s create a new container first:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示这一点，首先让我们创建一个新的容器：
- en: '[PRE58]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next, add the `lxc.start.auto` stanza to its config file:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将`lxc.start.auto`段添加到其配置文件中：
- en: '[PRE59]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'List all containers that are configured to start automatically:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出所有配置为自动启动的容器：
- en: '[PRE60]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now we can use the `lxc-autostart` command again to start all containers configured
    to autostart, in this case just one:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以再次使用`lxc-autostart`命令来启动所有配置为自动启动的容器，在这种情况下只有一个容器：
- en: '[PRE61]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Two other useful autostart configuration parameters are adding a delay to the
    start, and defining a group in which multiple containers can start as a single
    unit. Stop the container and add the following to configuration options:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另两个有用的自动启动配置参数是给启动添加延迟，以及定义一个组，使多个容器可以作为一个单元启动。停止容器并将以下内容添加到配置选项中：
- en: '[PRE62]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Next, let''s list the containers configured to autostart again:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们再次列出配置为自动启动的容器：
- en: '[PRE63]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Notice that no containers showed from the preceding output. This is because
    our container now belongs to an autostart group. Let''s specify it:'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在前面的输出中没有显示任何容器。这是因为我们的容器现在属于一个自动启动组。让我们指定它：
- en: '[PRE64]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Similarly, start all containers belonging to a given autostart group:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，启动属于给定自动启动组的所有容器：
- en: '[PRE65]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: For `lxc-autostart` to automatically start containers after a server reboot,
    it first needs to be started. This can be achieved by either adding the preceding
    command in `crontab`, or creating an init script.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要使`lxc-autostart`在服务器重启后自动启动容器，首先需要启动它。可以通过将前述命令添加到`crontab`中，或者创建一个初始化脚本来实现。
- en: 'Finally, in order to clean up, run the following:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了清理，运行以下命令：
- en: '[PRE66]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: LXC container hooks
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LXC 容器钩子
- en: 'LXC provides a convenient way to execute programs during the life cycle of
    containers. The following table summarizes the various configuration options available
    to allow this feature:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: LXC 提供了一种方便的方式，在容器生命周期内执行程序。以下表格总结了可用于启用此功能的各种配置选项：
- en: '| **Option** | **Description** |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| **选项** | **描述** |'
- en: '| `lxc.hook.pre-start` | A hook to be run in the host namespace before the
    container ttys, consoles, or mounts are loaded |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `lxc.hook.pre-start` | 在容器的终端、控制台或挂载点加载之前，在主机命名空间中运行的钩子 |'
- en: '| `lxc.hook.pre-mount` | A hook to be run in the container''s filesystem namespace,
    but before the `rootfs` has been set up |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `lxc.hook.pre-mount` | 在容器的文件系统命名空间中运行的钩子，但在设置 `rootfs` 之前 |'
- en: '| `lxc.hook.mount` | A hook to be run in the container after mounting has been
    done, but before the `pivot_root` |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `lxc.hook.mount` | 在挂载完成后，但在 `pivot_root` 之前，容器中运行的钩子 |'
- en: '| `lxc.hook.autodev` | A hook to be run in the container after mounting has
    been done and after any mount hooks have run, but before the `pivot_root` |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `lxc.hook.autodev` | 在挂载完成且所有挂载钩子运行之后，但在 `pivot_root` 之前，容器中运行的钩子 |'
- en: '| `lxc.hook.start` | A hook to be run in the container right before executing
    the container''s init |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `lxc.hook.start` | 在容器初始化之前，容器内运行的钩子 |'
- en: '| `lxc.hook.stop` | A hook to be run in the host''s namespace after the container
    has been shut down |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `lxc.hook.stop` | 在容器关闭后，在主机的命名空间中运行的钩子 |'
- en: '| `lxc.hook.post-stop` | A hook to be run in the host''s namespace after the
    container has been shut down |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `lxc.hook.post-stop` | 在容器关闭后，在主机命名空间中运行的钩子 |'
- en: '| `lxc.hook.clone` | A hook to be run when the container is cloned |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `lxc.hook.clone` | 在容器被克隆时运行的钩子 |'
- en: '| `lxc.hook.destroy` | A hook to be run when the container is destroyed |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `lxc.hook.destroy` | 在容器被销毁时运行的钩子 |'
- en: 'To demonstrate this, let''s create a new container and write a simple script
    that will output the values of four LXC variables to a file, when the container
    starts:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，让我们创建一个新的容器，并编写一个简单的脚本，当容器启动时，将四个 LXC 变量的值输出到文件中：
- en: 'First, create the container and add the `lxc.hook.pre-start` option to its
    configuration file:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建容器并将 `lxc.hook.pre-start` 选项添加到其配置文件中：
- en: '[PRE67]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Next, create a simple bash script and make it executable:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个简单的 bash 脚本并使其可执行：
- en: '[PRE68]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Start the container and check the contents of the file that the bash script
    should have written to, ensuring the script got triggered:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动容器并检查 bash 脚本应写入的文件的内容，确保脚本已被触发：
- en: '[PRE69]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: From the preceding output, we can see that the script got triggered when we
    started the container, and the value of the LXC variables got written to the temp
    file.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以看到，当我们启动容器时，脚本被触发了，并且 LXC 变量的值被写入了临时文件。
- en: Attaching directories from the host OS and exploring the running filesystem
    of a container
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从主机操作系统附加目录并探索容器的运行文件系统
- en: The root filesystem of LXC containers is visible from the host OS as a regular
    directory tree. We can directly manipulate files in a running container by just
    making changes in that directory. LXC also allows for attaching directories from
    the host OS inside the container using bind mount. A bind mount is a different
    view of the directory tree. It achieves this by replicating the existing directory
    tree under a different mount point.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: LXC 容器的根文件系统在主机操作系统中作为常规目录树可见。我们可以直接通过在该目录中进行更改来操作运行中的容器中的文件。LXC 还允许通过绑定挂载将主机操作系统中的目录挂载到容器内部。绑定挂载是对目录树的另一种视图，它通过在不同的挂载点下复制现有的目录树来实现。
- en: 'To demonstrate this, let''s create a new container, directory, and a file on
    the host:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示这一点，让我们创建一个新的容器、目录，并在主机上创建一个文件：
- en: '[PRE70]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Next, we are going to use the `lxc.mount.entry` option in the configuration
    file of the container, telling LXC what directory to bind mount from the host,
    and the mount point inside the container to bind to:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用容器配置文件中的 `lxc.mount.entry` 选项，告诉 LXC 从主机挂载哪个目录，并指定容器内的挂载点：
- en: '[PRE71]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Once the container is started, we can see that the `/mnt` inside it now contains
    the file that we created in the `/tmp/export_to_container` directory on the host
    OS earlier:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦容器启动，我们可以看到容器内的 `/mnt` 现在包含了我们之前在主机操作系统 `/tmp/export_to_container` 目录中创建的文件：
- en: '[PRE72]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'When an LXC container is in a running state, some files are only visible from
    `/proc` on the host OS. To examine the running directory of a container, first
    grab its PID:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 LXC 容器处于运行状态时，一些文件仅能在宿主操作系统的`/proc`中看到。要查看容器的运行目录，首先获取其 PID：
- en: '[PRE73]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'With the PID in hand, we can examine the running directory of the container:'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 拿到 PID 后，我们可以检查容器的运行目录：
- en: '[PRE74]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Tip
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Make sure you replace the PID with the output of `lxc-info` from your host,
    as it will differ from the preceding example.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保将 PID 替换为宿主机上 `lxc-info` 输出的 PID，因为它与前面的示例不同。
- en: In order to make persistent changes in the root filesystem of a container, modify
    the files in `/var/lib/lxc/mount_container/rootfs/` instead.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在容器的根文件系统中进行持久化更改，可以修改 `/var/lib/lxc/mount_container/rootfs/` 中的文件。
- en: Freezing a running container
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冻结一个运行中的容器
- en: LXC takes advantage of the `freezer` cgroup to freeze all the processes running
    inside a container. The processes will be in a blocked state until thawed. Freezing
    a container can be useful in cases where the system load is high and you want
    to free some resources without actually stopping the container and preserving
    its running state.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: LXC 利用 `freezer` cgroup 来冻结容器内运行的所有进程。这些进程将处于阻塞状态，直到被解冻。冻结容器在系统负载高时很有用，可以释放一些资源，而不需要实际停止容器并保持其运行状态。
- en: 'Ensure you have a running container and check its state from the `freezer`
    cgroup:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你有一个正在运行的容器，并通过`freezer` cgroup检查其状态：
- en: '[PRE75]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Notice how a currently running container shows as thawed. Let''s freeze it:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意当前正在运行的容器显示为已解冻。让我们冻结它：
- en: '[PRE76]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The container state shows as frozen, let''s check the cgroup file:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 容器状态显示为冻结状态，让我们检查 cgroup 文件：
- en: '[PRE77]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'To unfreeze it, run the following command:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要解冻容器，运行以下命令：
- en: '[PRE78]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We can monitor the state change by running the `lxc-monitor` command on a separate
    console while freezing and unfreezing a container. The change of the container''s
    state will show as the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在另一个控制台上运行 `lxc-monitor` 命令，同时冻结和解冻容器来监控状态变化。容器状态的变化将如下所示：
- en: '[PRE79]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Limiting container resource usage
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制容器资源使用
- en: In [Chapter 1](ch01.html "Chapter 1. Introduction to Linux Containers"), *Introduction
    to Linux Containers* we saw how easy it is to limit process resources by either
    directly manipulating files in the cgroup hierarchy or using the userspace tools.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 1 章](ch01.html "第 1 章. Linux 容器介绍")，*Linux 容器介绍*中，我们了解了如何通过直接操作 cgroup 层次结构中的文件或使用用户空间工具轻松地限制进程资源。
- en: Similarly, LXC comes with tools that are just as straightforward and easy to
    use.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，LXC 也提供了同样简便易用的工具。
- en: 'Let''s start by setting up the available memory for a container to 512 MB:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从设置容器的可用内存为 512 MB 开始：
- en: '[PRE80]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We can verify that the new setting has been applied by directly inspecting
    the `memory` cgroup for the container:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过直接检查容器的 `memory` cgroup 来验证新设置是否已应用：
- en: '[PRE81]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Changing the value only requires running the same command again. Let''s change
    the available memory to 256 MB and inspect the container by attaching to it and
    running the free utility:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 更改该值只需要再次运行相同的命令。让我们将可用内存更改为 256 MB，并通过附加到容器并运行 free 工具来检查容器：
- en: '[PRE82]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: As the preceding output shows, the container only has a total available memory
    of 256 MB.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，容器的可用内存只有 256 MB。
- en: 'We can also pin a CPU core to a container. In the next example, our test server
    has two cores. Let''s allow the container to only run on core 0:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将一个 CPU 核心绑定到容器。下一个示例中，我们的测试服务器有两个核心。让我们允许容器只在核心 0 上运行：
- en: '[PRE83]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: By attaching to the container and checking the available CPUs, we see that only
    one is presented, as expected.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 通过附加到容器并检查可用的 CPU，我们看到只有一个呈现出来，正如预期的那样。
- en: 'To make changes to persist server reboots, we need to add them to the configuration
    file of the container:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使更改在服务器重启后生效，我们需要将它们添加到容器的配置文件中：
- en: '[PRE84]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Setting various other cgroup parameters is done in a similar way. For example,
    let''s see the cpu shares and the block IO on a container:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 设置其他各种 cgroup 参数的方法类似。例如，我们来查看容器的 CPU 份额和块 IO：
- en: '[PRE85]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: For a full list of all available cgroup options refer to [Chapter 1](ch01.html
    "Chapter 1. Introduction to Linux Containers"), *Introduction to Linux Containers,*
    or explore the mounted cgroup hierarchy.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 有关所有可用 cgroup 选项的完整列表，请参阅[第 1 章](ch01.html "第 1 章. Linux 容器介绍")，*Linux 容器介绍*，或者探索挂载的
    cgroup 层次结构。
- en: Building and running LXC containers with libvirt
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 libvirt 构建和运行 LXC 容器
- en: Libvirt is a set of libraries and language bindings used to interact with various
    virtualization technologies in a standard and uniform way. These include KVM,
    XEN, QEMU, OpenVZ, and of course LXC. Libvirt uses XML files to define virtualized
    entities such as LXC containers, and describe their properties, such as available
    memory, block devices, networking, the init system, and other metadata. It supports
    multiple storage drivers such as the LVM, local and network filesystems, iSCSI,
    and others.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Libvirt 是一组库和语言绑定，用于以标准和统一的方式与各种虚拟化技术进行交互。这些技术包括 KVM、XEN、QEMU、OpenVZ，当然还有 LXC。Libvirt
    使用 XML 文件来定义虚拟化实体（如 LXC 容器），并描述其属性，如可用内存、块设备、网络、初始化系统以及其他元数据。它支持多种存储驱动程序，如 LVM、本地和网络文件系统、iSCSI
    等。
- en: Libvirt provides a completely independent way of working with Linux containers
    from the mainstream LXC project and the toolset we've seen and used so far. It
    implements the kernel feature set that constitutes LXC, and exposes its own tools
    and libraries to work with containers without the need to install other packages.
    In [Chapter 4](ch04.html "Chapter 4. LXC Code Integration with Python"), *LXC
    Code Integration with Python,* we'll see how to write Python programs using the
    libvirt API, but for now let's explore the toolkit that it provides.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Libvirt 提供了一种与主流 LXC 项目以及我们目前看到并使用的工具集完全独立的方式来处理 Linux 容器。它实现了构成 LXC 的内核特性，并暴露了自己的工具和库，用于与容器进行交互，而无需安装其他包。在[第
    4 章](ch04.html "第 4 章. LXC 代码与 Python 的集成")，*LXC 代码与 Python 的集成* 中，我们将看到如何使用 libvirt
    API 编写 Python 程序，但现在我们先来探索它提供的工具集。
- en: Installing libvirt from packages on Debian and CentOS
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Debian 和 CentOS 上从包安装 libvirt
- en: Both Ubuntu and CentOS package libvirt, though the versions are lagging behind
    from the upstream trunk. For the latest version, we'll compile it from source
    in the next section.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu 和 CentOS 都提供 libvirt 包，尽管版本相比上游版本较旧。为了获取最新版本，我们将在下一节从源代码编译它。
- en: Tip
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To get the most out of the examples in this chapter and avoid conflicts and
    errors, I recommend that you use a fresh VM or a new cloud instance.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用本章中的示例并避免冲突和错误，我建议您使用一个全新的虚拟机或新的云实例。
- en: 'To install the packages on Ubuntu run the following:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Ubuntu 上安装包，请运行以下命令：
- en: '[PRE86]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Once installed, make sure the libvirt daemon is running:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，确保 libvirt 守护进程正在运行：
- en: '[PRE87]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'On CentOS, the package name is different:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CentOS 上，包的名称不同：
- en: '[PRE88]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Once package install is complete, start the libvirt service and ensure it''s
    running:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 安装包完成后，启动 libvirt 服务并确保其正在运行：
- en: '[PRE89]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: For the rest of the examples in this chapter we'll be using the latest version
    of libvirt compiled from source on Ubuntu.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余示例中，我们将使用从源代码编译的最新版本的 libvirt 在 Ubuntu 上进行操作。
- en: Installing libvirt from source
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从源代码安装 libvirt
- en: 'On Ubuntu, make sure your system is up to date:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu 上，确保您的系统是最新的：
- en: '[PRE90]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Next, install the prerequisite packages that will enable us to obtain the source
    from `git` and build it:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，安装必要的前提包，以便我们能够从 `git` 获取源代码并进行构建：
- en: '[PRE91]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'With all the packages installed, let''s clone the source from the master `git`
    branch:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 安装所有包之后，克隆主 `git` 分支中的源代码：
- en: '[PRE92]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Generate the config file, compile and install the binaries:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 生成配置文件，编译并安装二进制文件：
- en: '[PRE93]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Update the necessary links and cache to the most recent shared libraries:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 更新必要的链接和缓存，以获取最新的共享库：
- en: '[PRE94]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Start the libvirt daemon and check its version:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 libvirt 守护进程并检查其版本：
- en: '[PRE95]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Defining LXC containers with libvirt
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 libvirt 定义 LXC 容器
- en: To build a container, we need to define its properties in an XML file that Libvirt
    will use. Once defined, libvirt starts a helper process called `libvirt_lxc`,
    responsible for creating the actual container, spawning the first process and
    handling I/O. Depending on the installation type, version, and distribution, its
    location may differ, so let's find it.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个容器，我们需要在 libvirt 将使用的 XML 文件中定义其属性。一旦定义，libvirt 会启动一个名为 `libvirt_lxc` 的辅助进程，负责创建实际的容器，启动第一个进程并处理
    I/O。根据安装类型、版本和发行版的不同，其位置可能有所不同，我们来查找它。
- en: 'On Ubuntu, run:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu 上运行：
- en: '[PRE96]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'On CentOS, the location will be different:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CentOS 上，位置会有所不同：
- en: '[PRE97]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'As pointed out earlier, libvirt supports many different hypervisors and to
    accommodate working with all of them it uses hypervisor canonical URIs. The URI
    points to the hypervisor that libvirt will communicate with. To list the currently
    configured URI, run the following command:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，libvirt 支持许多不同的虚拟化管理程序，并为适配所有虚拟化管理程序使用了虚拟化管理程序的标准 URI。URI 指向 libvirt 将与之通信的虚拟化管理程序。要列出当前配置的
    URI，请运行以下命令：
- en: '[PRE98]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'From the preceding output, we can see that the default URI is QEMU. To work
    with LXC we''ll need to change it. To do that, run the following command:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出可以看到，默认的 URI 是 QEMU。要与 LXC 配合使用，我们需要将其更改。为此，请运行以下命令：
- en: '[PRE99]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'For the life of your session, the default hypervisor will now be LXC. You can
    explicitly tell libvirt what to use by passing it as a command-line option. For
    example, to list all LXC containers you can run the following command:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在会话期间，默认的虚拟化程序将是 LXC。你可以通过命令行选项显式告诉 libvirt 使用什么。例如，要列出所有 LXC 容器，可以运行以下命令：
- en: '[PRE100]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Before we can define and build a container, we''ll need a root filesystem for
    it. Let''s build one using `debootstrap`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义并构建容器之前，我们需要一个根文件系统。让我们使用 `debootstrap` 来构建一个：
- en: '[PRE101]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'With the root filesystem in place, let''s define the container properties:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 根文件系统准备好后，让我们定义容器属性：
- en: '[PRE102]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The file is mostly self-explanatory and well documented. We define the domain
    type to be `lxc`, memory and CPU properties, the location of the root filesystem,
    and most importantly, the location of the `libvirt_lxc` helper process. In the
    networking section, we define a MAC address and the name of the host bridge. Not
    all options need to be specified, and if omitted, libvirt will create sane defaults.
    Later in this chapter, I'll demonstrate how we can generate this file from an
    LXC container that was built with the LXC tools instead.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件大部分内容不言自明且有很好的文档说明。我们将域类型定义为 `lxc`，内存和 CPU 属性，根文件系统的位置，最重要的是，`libvirt_lxc`
    辅助进程的位置。在网络部分，我们定义了一个 MAC 地址和主机桥接的名称。并非所有选项都需要指定，如果省略，libvirt 会创建合理的默认值。在本章后面，我将演示如何从使用
    LXC 工具构建的 LXC 容器生成此文件。
- en: 'With the file in place let''s define the container:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 文件准备好后，让我们定义容器：
- en: '[PRE103]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: We see that the container is now defined but in a shut-off state.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到容器已经定义，但处于关机状态：
- en: Starting and connecting to LXC containers with libvirt
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 libvirt 启动和连接 LXC 容器
- en: 'The container we defined earlier specifies the `lxcbr0` bridge. We need to
    create it before we can start the container:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前定义的容器指定了 `lxcbr0` 桥接。我们需要先创建它，才能启动容器：
- en: '[PRE104]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Now that we have a defined container and a bridge to connect it to, let''s
    go ahead and start it:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了定义好的容器和桥接，来连接它，让我们启动它：
- en: '[PRE105]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Before we can connect to the container''s console, we need to add it to the
    allowed terminals. To do this, we can `chroot` to the filesystem of the container
    and edit the `securetty` file:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以连接到容器的控制台之前，我们需要将其添加到允许的终端中。为此，我们可以 `chroot` 进入容器的文件系统并编辑 `securetty` 文件：
- en: '[PRE106]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Let''s connect to the console:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们连接到控制台：
- en: '[PRE107]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Attaching block devices to running containers with libvirt
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 libvirt 将块设备附加到正在运行的容器
- en: 'Libvirt provides a convenient way of attaching block devices to an already
    running container. To demonstrate this, let''s create a block device from a regular
    file, as demonstrated earlier in this chapter using the `truncate` and `losetup`
    commands:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Libvirt 提供了一种便捷的方式将块设备附加到已经运行的容器上。为了演示这一点，让我们从一个常规文件创建一个块设备，就像本章前面所演示的，使用 `truncate`
    和 `losetup` 命令：
- en: '[PRE108]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Our new block device is now `/dev/loop0`. Let''s create a filesystem on it,
    mount it, and create a test file:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新块设备现在是 `/dev/loop0`。让我们在上面创建文件系统，挂载它，并创建一个测试文件：
- en: '[PRE109]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Time to define the block device:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是定义块设备的时候了：
- en: '[PRE110]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'In the preceding config file, we define the driver to be `lxc`, the path to
    the block device we just created, and the name of the device that will be presented
    inside the container, in this case `vdb`. It''s time to attach the device:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配置文件中，我们定义了驱动程序为 `lxc`，我们刚刚创建的块设备的路径，以及将在容器内呈现的设备名称，这里是 `vdb`。现在是时候附加设备了：
- en: '[PRE111]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Let''s connect to the container and make sure the block device is there:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们连接到容器并确保块设备存在：
- en: '[PRE112]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'To detach the block device we can similarly run the following:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 要分离块设备，我们可以同样运行以下命令：
- en: '[PRE113]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Networking with libvirt LXC
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 libvirt LXC 进行网络配置
- en: 'Libvirt comes with a default network that uses `dnsmasq` and is configured
    to start automatically. To list all networks, run the following command:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: Libvirt 提供了一个默认网络，使用 `dnsmasq` 并配置为自动启动。要列出所有网络，请运行以下命令：
- en: '[PRE114]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'To examine the configuration of the default network let''s dump it to XML:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查默认网络的配置，让我们将其导出为XML格式：
- en: '[PRE115]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'From the output, it''s apparent that the default networks will create a bridge
    named `virbr0`, and what the network ranges configured in `dnsmasq` are. If we''d
    rather use our own network, we can describe its properties in a new XML file:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出结果来看，很明显默认网络会创建一个名为 `virbr0` 的桥接，并显示 `dnsmasq` 中配置的网络范围。如果我们更愿意使用自己的网络，可以在一个新的
    XML 文件中描述其属性：
- en: '[PRE116]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'In this example, the name of the bridge will be `br0` and it will use a different
    subnet. Let''s define it and list the networks:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，桥接的名称将是 `br0`，并将使用不同的子网。让我们定义它并列出网络：
- en: '[PRE117]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'We can confirm that the two networks created the bridges by running the following:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令来确认两个网络已创建桥接：
- en: '[PRE118]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Notice that the `lxcbr0` is the one we created manually earlier. Each network
    will start a `dnsmasq` process:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`lxcbr0` 是我们之前手动创建的那个。每个网络将启动一个 `dnsmasq` 进程：
- en: '[PRE119]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: To build a container that will be part of one of the defined networks, we need
    to change the name of the bridge in the XML file, log in the container, and configure
    the network interface.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建一个将成为某个已定义网络一部分的容器，我们需要在 XML 文件中更改桥接的名称，登录容器并配置网络接口。
- en: Generating config from an existing LXC container with libvirt
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从现有 LXC 容器生成配置文件并使用 libvirt
- en: Libvirt provides a way to convert the config file of an existing LXC container
    that was built with the LXC tools we used in the beginning of this chapter to
    a format that libvirt can use.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: Libvirt 提供了一种方法，将我们在本章开始时使用的 LXC 工具构建的现有 LXC 容器的配置文件转换为 libvirt 可以使用的格式。
- en: 'To demonstrate this, let''s create a new LXC container with `lxc-create`:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，让我们使用 `lxc-create` 创建一个新的 LXC 容器：
- en: '[PRE120]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'With the new container ready, let''s convert its configuration file to the
    XML specification that libvirt supports:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的容器准备好后，让我们将其配置文件转换为 libvirt 支持的 XML 规范：
- en: '[PRE121]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The output of the command is the new configuration file for the container in
    XML format saved in the `lxc-container.xml` file. We can use this file to start
    the container with `virsh` instead of `lxc-start`. Before we can do this, we need
    to specify a console type first:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出是容器的新配置文件，保存为 XML 格式的 `lxc-container.xml` 文件。我们可以使用这个文件通过 `virsh` 启动容器，而不是使用
    `lxc-start`。在此之前，我们需要先指定控制台类型：
- en: '[PRE122]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Define the new container:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 定义新的容器：
- en: '[PRE123]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'And start it:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 并启动它：
- en: '[PRE124]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Stopping and removing LXC containers with libvirt
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 libvirt 停止和删除 LXC 容器
- en: 'Let''s stop all the running libvirt containers:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们停止所有正在运行的 libvirt 容器：
- en: '[PRE125]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'To completely remove the containers, we need to undefine them:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全删除容器，我们需要取消定义它们：
- en: '[PRE126]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Summary
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: LXC supports various backing stores for its filesystem. In this chapter, we
    explored how to use the LVM, Btrfs, and ZFS backing stores to create COW snapshots.
    We also looked into how to create block devices from regular files for testing
    purposes.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: LXC 支持多种文件系统后端存储。在本章中，我们探讨了如何使用 LVM、Btrfs 和 ZFS 后端存储来创建 COW 快照。我们还研究了如何从常规文件中创建块设备以进行测试。
- en: We demonstrated how to autostart containers, create hooks that will execute
    programs during the life cycle of the instance, and how to expose directories
    and files from the host OS to LXC.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了如何设置容器自启动、创建生命周期中执行程序的钩子，以及如何将主机操作系统中的目录和文件暴露给 LXC。
- en: LXC uses the cgroup mechanism for controlling and allocating resources to containers.
    Changes to these resources are stored in the config file and can be persisted
    if the need arises. We explored ways of doing that with the provided toolset.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: LXC 使用 cgroup 机制来控制和分配资源给容器。对这些资源的更改会存储在配置文件中，并可以根据需要进行持久化。我们探索了如何使用提供的工具集来实现这一点。
- en: Finally, we introduced a different way of creating and managing LXC with libvirt
    and the `virsh` command.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了另一种使用 libvirt 和 `virsh` 命令来创建和管理 LXC 的方法。
- en: In the next chapter, you'll have a look at how to create and manage containers
    using the LXC APIs and libvirt bindings for Python.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何使用 LXC API 和 libvirt 的 Python 绑定来创建和管理容器。
