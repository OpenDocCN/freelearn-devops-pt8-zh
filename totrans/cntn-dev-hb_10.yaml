- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Leveraging Application Data Management in Kubernetes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中利用应用程序数据管理
- en: Deploying applications in Kubernetes helps in managing resilience, **high availability**
    (**HA**), and scalability by using replicated instances. But none of these features
    can be used without knowing how your application actually works and how to manage
    its data. In this chapter, we will review how to create and manage **Secrets**,
    **ConfigMaps**, and different **volume** options. While Secret and ConfigMap resources
    will be used to integrate different authentication options inside containers,
    volumes are used to manage an application’s data, as we briefly introduced in
    [*Chapter 8*](B19845_08.xhtml#_idTextAnchor170), *Deploying Applications with*
    *the* *Kubernetes Orchestrator*. Applications can be either stateful, stateless
    or – as is usually the case – a combination of both. We will learn in this chapter
    about different options for managing data and separating it from the application’s
    life cycle.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中部署应用程序有助于通过使用副本实例来管理弹性、**高可用性** (**HA**) 和可扩展性。但如果不了解应用程序的实际工作方式以及如何管理其数据，这些功能都无法使用。本章中，我们将回顾如何创建和管理
    **Secrets**、**ConfigMaps** 和不同的 **volume** 选项。虽然 Secret 和 ConfigMap 资源将用于在容器内集成不同的身份验证选项，但卷用于管理应用程序的数据，正如我们在
    [*第 8 章*](B19845_08.xhtml#_idTextAnchor170)中简要介绍的内容，*使用 Kubernetes 编排器部署应用程序*。应用程序可以是有状态的、无状态的，或像通常情况那样是两者的组合。本章将介绍管理数据的不同选项，并将其与应用程序生命周期分开。
- en: 'The following main concepts are reviewed in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章回顾了以下主要概念：
- en: Understanding the data within your application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解应用程序中的数据
- en: Applying configurations using ConfigMaps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ConfigMaps 应用配置
- en: Managing sensitive data using Secret resources
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Secret 资源管理敏感数据
- en: Managing stateless and stateful data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理无状态和有状态数据
- en: Enhancing storage management in Kubernetes with **PersistentVolume** (**PV**)
    resources
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **PersistentVolume** (**PV**) 资源增强 Kubernetes 中的存储管理
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the labs for this chapter at [https://github.com/PacktPublishing/Containers-for-Developers-Handbook/tree/main/Chapter10](https://github.com/PacktPublishing/Containers-for-Developers-Handbook/tree/main/Chapter10),
    where you will find some extended explanations, omitted in the chapter’s content
    to make it easier to follow. The *Code In Action* video for this chapter can be
    found at [https://packt.link/JdOIY](https://packt.link/JdOIY).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://github.com/PacktPublishing/Containers-for-Developers-Handbook/tree/main/Chapter10](https://github.com/PacktPublishing/Containers-for-Developers-Handbook/tree/main/Chapter10)
    找到本章的实验，其中包含了一些在章节内容中省略的详细说明，目的是为了更容易跟随。您可以在 [https://packt.link/JdOIY](https://packt.link/JdOIY)
    找到本章的 *Code In Action* 视频。
- en: As the data used by your application is very important, we will first review
    the different options we have and the resources we can use within Kubernetes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您应用程序所使用的数据非常重要，我们将首先回顾在 Kubernetes 中可以使用的不同选项和资源。
- en: Understanding the data within your application
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解应用程序中的数据
- en: '**Microservices architecture** improves the performance and resilience of your
    applications by distributing functionalities in different pieces, allowing us
    to scale them up or down and continue serving some functionalities even when some
    components fail. But this distribution of functionalities entails the distribution
    of the data associated with each component and somehow sharing it when more than
    one component needs it. It is very important to also understand that your application
    must allow scaling up without corrupting the data in case more than one replica
    is accessing the same data. Running application components as containers will
    help us distribute the processes, keeping the same data content in each replica,
    and starting and stopping processes quickly. The container runtime will attach
    defined volumes to the containers, but it doesn’t manage your application’s logic.
    That’s why it is key to understand how data will be used when you are preparing
    your applications for running in container-orchestrated environments.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**微服务架构**通过将功能分布到不同的模块中来提高应用程序的性能和弹性，这使得我们能够对其进行横向扩展或缩减，并在某些组件故障时继续提供部分功能。但功能的分布意味着与每个组件相关的数据也会分布，并在多个组件需要时共享它。还需要理解的是，应用程序必须允许在不破坏数据的情况下进行扩展，以防多个副本同时访问相同的数据。将应用程序组件作为容器运行将帮助我们分布进程，保持每个副本中相同的数据内容，并快速启动和停止进程。容器运行时将定义的卷附加到容器，但它不管理应用程序的逻辑。这就是为什么在准备应用程序在容器编排环境中运行时，理解数据如何使用是至关重要的。'
- en: Container orchestrators will provide you with mechanisms for injecting configurations
    into your containers, maintaining these configurations synced within all container
    replicas. These configurations can be used as either files within the containers
    or environment variables. You must understand that if your application uses configurations
    in clear text, you will not be able to protect them from attackers if they get
    into your containers. This will always be the case, even if you encrypt your configurations
    before they are injected into the containers. If your code reads the configuration
    content in clear text, it will always be accessible because permissions will be
    adequate to allow your processes to read the configurations, and the container
    will use the main process user to attach any new processes (via `docker exec`
    or `kubectl exec`). If you use environment variables, they will be easily readable
    by any process running inside the container. But these things don’t mean that
    your information is insecure inside containers. Different mechanisms, such as
    RBAC, allow us to limit access to containers from the orchestrated platform, but
    accessing cluster nodes will override the platform’s security. You should never
    run commands from cluster nodes. Your container orchestrator administrators may
    provide you with a complete **continuous deployment** (**CD**) solution, or you
    may use your platform client (command line or graphical interface) to gain access.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 容器编排器将为你提供将配置注入容器的机制，并保持这些配置在所有容器副本中同步。这些配置可以作为容器中的文件或环境变量使用。你必须明白，如果你的应用程序使用明文配置，在攻击者进入容器后，你将无法保护它们。这种情况始终存在，即使你在将配置注入容器之前加密它们。如果你的代码以明文方式读取配置内容，它始终是可以访问的，因为权限足够允许你的进程读取配置，并且容器将使用主进程用户来附加任何新进程（通过`docker
    exec`或`kubectl exec`）。如果你使用环境变量，任何在容器内运行的进程都能轻松读取它们。但这些并不意味着你的信息在容器内部不安全。不同的机制，如RBAC，允许我们限制从编排平台对容器的访问，但访问集群节点将覆盖平台的安全性。你永远不应该从集群节点执行命令。你的容器编排器管理员可能会为你提供一个完整的**持续部署**（**CD**）解决方案，或者你也可以使用平台客户端（命令行或图形界面）来访问。
- en: 'Injecting data into an application’s containers can be accomplished by using
    any of the following mechanisms:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 向应用程序的容器注入数据可以通过以下任何机制实现：
- en: '`arguments` key to any Pod resource. You should never pass sensitive data using
    this method.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arguments` 是任何Pod资源的关键。你永远不应通过这种方法传递敏感数据。'
- en: '**Environment variables**: It is usual to include information by using environment
    variables. Some coding languages even have standardized nomenclature for working
    directly with variables; in any case, your application must be prepared to include
    them. This method should also be avoided when including sensitive data unless
    it is combined with Secret resources, as we will learn about in the next section.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境变量**：使用环境变量包含信息是很常见的做法。一些编程语言甚至有标准化的命名法来直接操作变量；无论如何，您的应用程序必须准备好使用它们。在包括敏感数据时，也应该避免这种方法，除非它与
    Secret 资源结合使用，正如我们将在下一节中学习到的。'
- en: '**ConfigMaps**: These resources are the best option for adding configurations
    to our workloads. We can use them to add files inside containers, knowing that
    they will be available no matter which node runs the instance. The container orchestrator
    will manage and sync any change in its content. They can also be used to set up
    some variables with their values and use them as environment variables.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ConfigMaps**：这些资源是将配置添加到我们的工作负载中的最佳选择。我们可以使用它们将文件添加到容器内部，确保它们在任何节点上运行实例时都能可用。容器编排工具将管理并同步其内容的任何更改。它们也可以用于设置一些带有值的变量，并将它们用作环境变量。'
- en: '**Secrets**: Secret resources are the appropriate method for managing sensitive
    data in either Kubernetes or Docker Swarm platforms. However, there’s a big difference
    in how they are packaged inside each platform. Docker Swarm encrypts their content,
    and we aren’t even allowed to retrieve the content, while Kubernetes uses the
    Base64 format for storing content within a cluster. Encryption for storing Secret
    resources at rest in etcd can be enabled, but it is not enabled by default. This
    only affects the etcd database, which shouldn’t be accessible to normal users,
    but it may be useful to ask your Kubernetes administrators about such configuration
    if you are worried about the data you keep in your Secret resources. It is quite
    common to use Secret resources for either adding sensitive files, such as passwords,
    authentication tokens, certificates, or even container image registry connection
    strings, or to present variables to containers.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Secrets**：Secret 资源是管理 Kubernetes 或 Docker Swarm 平台中敏感数据的合适方法。然而，它们在每个平台中封装的方式存在很大差异。Docker
    Swarm 对其内容进行加密，且我们甚至无法检索其内容，而 Kubernetes 使用 Base64 格式在集群中存储内容。可以启用加密来保护在 etcd
    中存储的 Secret 资源，但默认情况下是未启用的。这只会影响 etcd 数据库，而正常用户不应能访问该数据库，但如果您对存储在 Secret 资源中的数据感到担忧，可以向您的
    Kubernetes 管理员询问相关配置。使用 Secret 资源来添加敏感文件（如密码、身份验证令牌、证书，甚至是容器镜像注册表连接字符串）或将变量呈现给容器是非常常见的做法。'
- en: '**Volumes**: Volumes are not intended to be used for injecting data but for
    storing it during the execution of the containers. They can be either ephemeral
    or stateful, to persist data between executions. In Kubernetes, we consider volumes
    as those storage resources integrated into the Kubernetes platform’s code. A lot
    of cloud storage solutions were integrated from the beginning of its development
    because it was part of the design, although host bind mounts, ephemeral directories,
    NFS, and other on-premises solutions are also available. ConfigMap and Secret
    resources are also Volumes, but we will treat them differently because of their
    content.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Volumes**：Volumes 不是用来注入数据的，而是用来在容器执行期间存储数据的。它们可以是短暂的或持久的，用于在执行之间持久化数据。在
    Kubernetes 中，我们将 Volumes 视为集成到 Kubernetes 平台代码中的存储资源。许多云存储解决方案从 Kubernetes 开发之初就已集成，因为它是设计的一部分，尽管也可以使用主机绑定挂载、临时目录、NFS
    和其他本地解决方案。ConfigMap 和 Secret 资源也属于 Volumes，但由于它们的内容不同，我们会对它们进行不同的处理。'
- en: '**The downward API**: Although the downward API is considered a Volume resource,
    we can think of it as a completely different concept due to its usage. You can
    mount metadata information from the current namespace’s resources to be used in
    your application by using the downward API, which automatically manages the required
    requests to the Kubernetes API to retrieve it.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向下 API**：尽管向下 API 被认为是一个 Volume 资源，但由于其使用方式，我们可以将其视为完全不同的概念。您可以通过使用向下 API
    挂载来自当前命名空间资源的元数据，以便在应用程序中使用，向下 API 会自动管理向 Kubernetes API 发出的必要请求来获取这些信息。'
- en: '**PVs**: A PV is storage provisioned by the Kubernetes administrator to accommodate
    a **PersistentVolumeClaim** (**PVC**) resource, which is a request for storage
    for your application component. Whenever you create a PVC resource, it will be
    bound to an existing PV resource if there is one free with the required size and
    properties.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PVs**: PV 是由 Kubernetes 管理员提供的存储，用于满足应用组件的 **PersistentVolumeClaim** (**PVC**)
    资源的存储需求。每当创建 PVC 资源时，如果存在符合所需大小和属性的空闲 PV 资源，则会将其绑定。'
- en: Important note
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The concept of **Projected Volumes** also exists, which is a specific map of
    different volumes integrated into the same directory inside a container. This
    feature allows us to locate Secret and ConfigMap resources in the same directory.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 还存在 **Projected Volumes** 的概念，这是容器内同一目录中集成的不同卷的特定映射。此功能允许我们在同一目录中定位 Secret 和
    ConfigMap 资源。
- en: We will learn how to inject data and use it inside containers by using ConfigMaps
    to include non-sensitive information.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何通过使用 ConfigMaps 来包含非敏感信息，将数据注入并在容器内使用。
- en: Applying configurations using ConfigMaps
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ConfigMaps 应用配置
- en: In this section, we are going to learn how to use ConfigMap resources, mount
    files inside containers or as environment variables, and present the information
    for our application’s processes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用 ConfigMap 资源，在容器内挂载文件或作为环境变量，并为我们应用的进程呈现信息。
- en: 'The content of a ConfigMap resource is stored in the Kubernetes etcd key-value
    store. Due to this, the content can’t exceed 1 MB in size. The manifest of these
    resources doesn’t have a `spec` section. Instead, we can have either `data` or
    `binaryData` (for Base64 content) keys for defining the content. The following
    screenshot shows an example of a ConfigMap manifest:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMap 资源的内容存储在 Kubernetes 的 etcd 键值存储中。因此，内容大小不能超过 1 MB。这些资源的清单没有 `spec`
    部分。相反，我们可以使用 `data` 或 `binaryData`（用于 Base64 内容）键来定义内容。以下截图显示了一个 ConfigMap 清单示例：
- en: '![Figure 10.1 – ConfigMap resource manifest](img/B19845_10_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – ConfigMap 资源清单](img/B19845_10_01.jpg)'
- en: Figure 10.1 – ConfigMap resource manifest
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – ConfigMap 资源清单
- en: In the code in the presented screenshot, we have declared two types of configurations.
    While `APP_VAR1` and `APP_VAR2` are defined in key-value format, the `appsettings`
    section defines a complete configuration file that can be mounted. Notice the
    pipe symbol (`|`) used to define the `appsettings` key. This allows us to include
    all the subsequent content as the value for the key. You should be very careful
    with the indentation of the YAML file to avoid any issues with the file content.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在所示的截图中的代码中，我们声明了两种类型的配置。`APP_VAR1` 和 `APP_VAR2` 以键值对的形式定义，而 `appsettings` 部分定义了一个完整的配置文件，可以被挂载。请注意，管道符号
    (`|`) 用于定义 `appsettings` 键。这允许我们将所有后续内容包含为键的值。在编写 YAML 文件时务必注意缩进，以避免文件内容出现问题。
- en: 'Let’s see now how we will use these configurations in a Pod:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在 Pod 中使用这些配置：
- en: '![Figure 10.2 – Pod resource manifest using a ConfigMap resource](img/B19845_10_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – 使用 ConfigMap 资源的 Pod 资源清单](img/B19845_10_02.jpg)'
- en: Figure 10.2 – Pod resource manifest using a ConfigMap resource
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 使用 ConfigMap 资源的 Pod 资源清单
- en: In the Pod manifest shown in the preceding screenshot, we have presented two
    mechanisms for using the information declared in a ConfigMap resource. We used
    the key-value definitions in the `settings` ConfigMap as environment variables.
    But the content of the `appsettings` key, defined in the `settings` ConfigMap
    too, is presented as a volume in the `demo` container. In this case, a `/app/config/appsettings`
    file will be created, with the content of the `appsettings` key. Notice that we
    used the `ReadOnly` key to define that the mounted file will not be writable.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面截图中显示的 Pod 清单中，我们展示了两种使用 ConfigMap 资源中声明信息的机制。我们使用了 `settings` ConfigMap
    中的键值对作为环境变量。但是 `settings` ConfigMap 中 `appsettings` 键的内容被作为 `demo` 容器中的一个卷展示。在这种情况下，将创建一个
    `/app/config/appsettings` 文件，其内容来自 `appsettings` 键。请注意，我们使用 `ReadOnly` 键来定义挂载的文件不可写。
- en: 'In this example, we didn’t use the simplest mechanism for mounting configuration
    files. Let’s see how we simply add a complete configuration file, created with
    `kubectl create configmap <CONFIGMAP_NAME> --from-file=<CONFIGURATION_FILE>`.
    We will use the `appsettings.json` file as an example, with any content, and created
    using `kubectl create cm` `appsettings –from-file=appsettings.json`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们没有使用最简单的挂载配置文件的机制。让我们看看如何简单地添加一个完整的配置文件，使用`kubectl create configmap
    <CONFIGMAP_NAME> --from-file=<CONFIGURATION_FILE>`创建。我们将以`appsettings.json`文件为例，文件内容可以是任何内容，且是使用`kubectl
    create cm` `appsettings –from-file=appsettings.json`创建的：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this case, we used the `subPath` key to set up the filename and complete
    path for the configuration file.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用了`subPath`键来设置配置文件的文件名和完整路径。
- en: 'Configuration files can be updated at any time unless we have used the `immutable`
    key (which defaults to `false`), in which case we will need to recreate the resource.
    To modify the content or any of the allowed keys (use `kubectl explain configmap`
    to review them), we can use any of the following methods:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件可以随时更新，除非我们使用了`immutable`键（默认为`false`），在这种情况下，我们需要重新创建资源。要修改内容或任何允许的键（使用`kubectl
    explain configmap`查看），我们可以使用以下任意方法：
- en: Use `kubectl edit` to edit and modify its values online.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`kubectl edit`在线编辑并修改其值。
- en: Patch the file by using `kubectl` `patch` ([https://kubernetes.io/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch](https://kubernetes.io/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch)).
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`kubectl patch`修补文件（[https://kubernetes.io/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch](https://kubernetes.io/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch)）。
- en: Replace the resource with a new manifest file by using `kubectl replace –f <MANIFEST_FILE>`.
    This is the preferred option as all changes can be followed by storing the manifest
    files (using **GitOps** methodology, as we will learn in [*Chapter 13*](B19845_13.xhtml#_idTextAnchor287),
    *Managing the Application* *Life Cycle*).
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`kubectl replace –f <MANIFEST_FILE>`替换资源文件。这是首选方法，因为所有更改都可以通过存储清单文件来追踪（使用**GitOps**方法论，正如我们将在[*第13章*](B19845_13.xhtml#_idTextAnchor287)中学习的，*管理应用生命周期*）。
- en: ConfigMap resources will be updated on your running workloads unless their values
    are used in your containers as environment variables or mounted using the `subPath`
    key, in which case this will not be done. It is very important to understand how
    updates will be managed by Kubernetes in your application’s workloads. Even if
    your configuration is updated, it depends on how your application uses it, when
    it is loaded, and how these changes affect your container processes. If your processes
    only read configurations when they start, you will need to recreate the application’s
    Pods. Hence, the only way you can ensure that a new configuration is applied is
    by recreating the containers. Depending on the workloads you used for your configuration,
    you will just need to remove or scale your resources down/up to make the configuration
    changes update.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 配置映射资源将会在正在运行的工作负载中更新，除非它们的值作为环境变量被使用，或者通过`subPath`键挂载到容器中，在这种情况下将不会更新。非常重要的是理解Kubernetes如何在应用工作负载中管理更新。即使配置被更新，也取决于你的应用如何使用它、何时加载以及这些更改如何影响容器进程。如果你的进程只在启动时读取配置，那么你需要重新创建应用的Pods。因此，确保新配置生效的唯一方法是重新创建容器。根据你为配置使用的工作负载，你只需要删除或缩放资源，以便使配置更改生效。
- en: Important note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We can use `kubectl create cm <CONFIGMAP_NAME> --from-literal=KEY=VALUE` to
    create ConfigMap resources with key-value resource types directly.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`kubectl create cm <CONFIGMAP_NAME> --from-literal=KEY=VALUE`直接创建包含键值对的配置映射资源。
- en: We can add annotations to our ConfigMap resources and update them to trigger
    the update of your workloads. This will ensure that your Pods will be recreated,
    hence the ConfigMap is updated immediately. By default, when a ConfigMap is updated,
    Kubernetes will update the content on the Pods using this configuration at regular
    intervals. This automatic update doesn’t work if you use the `subPath` key to
    mount the content. However, notice that updating the content of the file does
    not include the update of your application; it depends on how your application
    works and how often the configuration is refreshed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将注解添加到 ConfigMap 资源中，并更新它们以触发工作负载的更新。这将确保您的 Pods 会被重新创建，从而 ConfigMap 会立即更新。默认情况下，当
    ConfigMap 被更新时，Kubernetes 会定期更新使用此配置的 Pods 中的内容。如果您使用 `subPath` 键挂载内容，则此自动更新机制不起作用。然而，请注意，更新文件内容并不意味着更新您的应用程序；它取决于应用程序的工作方式以及配置刷新频率。
- en: Kubernetes also allows us to include information in Pods at runtime. We will
    use the downward API to inject Kubernetes data into Pods, which we will learn
    about in the next section.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 还允许我们在运行时将信息包含在 Pods 中。我们将使用向下 API 将 Kubernetes 数据注入 Pods，相关内容将在下一节中学习。
- en: Using the downward API to inject configuration data
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用向下 API 注入配置数据
- en: We will use the downward API mount endpoints to inject information about the
    current Pod resource. This way, we can import information such as the Pod’s name
    (`metadata.name`), its annotations, labels, and service account, for example.
    Information can be passed as environment variables or mounted as a volume file.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用向下 API 挂载端点来注入关于当前 Pod 资源的信息。通过这种方式，我们可以导入诸如 Pod 名称（`metadata.name`）、注解、标签和服务账户等信息。例如，可以通过环境变量传递信息或将其挂载为卷文件。
- en: 'Imagine a Pod with the following annotations:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个 Pod 拥有以下注解：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can mount this information in a Pod’s container with a volume definition
    and the `mountPath` parameter inside it:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过卷定义和其中的 `mountPath` 参数将此信息挂载到 Pod 的容器中：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that we are injecting the annotations inside the `/etc/pod-annotations`
    file. We can use either static data (added manually) or dynamic information, retrieved
    from Kubernetes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在将注解注入到 `/etc/pod-annotations` 文件中。我们可以使用静态数据（手动添加）或动态信息（从 Kubernetes
    中获取）。
- en: Next, let’s see how to include sensitive data by using Secrets.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看一下如何通过使用 Secrets 来包含敏感数据。
- en: Managing sensitive data using Secret resources
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Secret 资源管理敏感数据
- en: We should always avoid adding sensitive information to our application images.
    Neither passwords, connection strings, tokens, certificates, nor license information
    should be written inside container images; all this content must be included in
    the runtime. Therefore, instead of using ConfigMap resources, which are stored
    in clear text, we will use Secrets. Kubernetes Secret resource content is described
    in `base64` format. They are not encrypted, and anyone with access to them can
    read their data. This includes any user who can create a Pod in the same namespace,
    as the Secret can be included and hence read. Only appropriate RBAC resource access
    can ensure Secrets’ security. Therefore, it is important to understand that you
    should avoid access to your Secret resources using appropriate Kubernetes **Roles**
    and **RoleBindings** (Kubernetes RBAC). Also, by default, Kubernetes doesn’t encrypt
    Secrets in etcd, hence access to the key-value data files at the filesystem level
    shouldn’t be allowed. Secrets are namespaced resources, therefore we will be able
    to manage Kubernetes access at the namespace level. Your Kubernetes administrators
    should ensure the appropriate access at the cluster level.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应始终避免将敏感信息添加到应用镜像中。密码、连接字符串、令牌、证书或许可证信息都不应写入容器镜像中；所有这些内容必须在运行时包含。因此，代替使用以明文存储的
    ConfigMap 资源，我们将使用 Secrets。Kubernetes Secret 资源内容采用 `base64` 格式描述。它们并未加密，任何有权限访问的人都可以读取其数据。这包括任何可以在同一命名空间中创建
    Pod 的用户，因为 Secret 可以被包含并因此被读取。只有适当的 RBAC 资源访问权限才能确保 Secret 的安全。因此，重要的是要理解，应该通过适当的
    Kubernetes **角色**和 **角色绑定**（Kubernetes RBAC）来避免访问您的 Secret 资源。此外，默认情况下，Kubernetes
    不会加密 etcd 中的 Secrets，因此不应允许在文件系统级别访问键值数据文件。Secrets 是命名空间级资源，因此我们能够在命名空间级别管理 Kubernetes
    访问权限。Kubernetes 管理员应确保在集群级别的适当访问。
- en: We will use Secret resources as **volumes** (presenting files such as certificates
    or tokens), as **environment variables** (with their content hidden when you review
    the online Pod resource’s manifest), or as **authentication** for accessing a
    remote registry (on-premise or cloud service).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Secret 资源作为 **卷**（呈现文件，如证书或令牌）、**环境变量**（当查看在线 Pod 资源清单时，内容被隐藏）或作为 **认证**
    来访问远程注册表（本地或云服务）。
- en: 'We can use `kubectl create secret generic <SECRET_NAME> --from-file=<SENSITIVE_DATA_FILE>`
    or `kubectl create secret generic <SECRET_NAME> --from-literal=SECRET_VARIABLE_NAME=SECRET_VALUE`.
    Either the `--from-file` or `--from-literal` arguments can be used multiple times
    to add multiple data keys. The following Secret resource types can be created:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `kubectl create secret generic <SECRET_NAME> --from-file=<SENSITIVE_DATA_FILE>`
    或 `kubectl create secret generic <SECRET_NAME> --from-literal=SECRET_VARIABLE_NAME=SECRET_VALUE`。`--from-file`
    或 `--from-literal` 参数可以多次使用，以添加多个数据键。可以创建以下类型的 Secret 资源：
- en: '`generic`: This is the most usual type and can be used to include any sensitive
    file or value.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generic`：这是最常见的类型，可以用于包含任何敏感文件或值。'
- en: '`tls`: This stands for `SSL_CERT_FILE` variable with its content or by using
    the associated `.cert` and `.key` files in your configuration.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tls`：这表示包含其内容的 `SSL_CERT_FILE` 变量，或者在配置中使用关联的 `.cert` 和 `.key` 文件。'
- en: '`docker-registry`: These resources can include `dockercfg` or `dockerconfigjson`
    content. They will be used to configure a profile for pulling images from a registry.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-registry`：这些资源可以包含 `dockercfg` 或 `dockerconfigjson` 内容。它们将用于配置从注册表拉取镜像的配置文件。'
- en: Kubernetes, by default, creates a Secret for each service account automatically.
    These Secret resources contain an associated token that can be used for interacting
    with the Kubernetes API from your application’s components. This token is used
    to authenticate and authorize your processes with Kubernetes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Kubernetes 为每个服务帐户自动创建一个 Secret。这些 Secret 资源包含一个关联的令牌，可用于从应用程序组件与 Kubernetes
    API 交互。此令牌用于对您的进程进行认证和授权。
- en: Ask your Kubernetes administrators if you have some **ResourceQuota** resources
    associated with your applications’ namespaces because Secrets, as with many other
    resources, can be limited in their number. Hence, you may be limited when creating
    lots of Secrets, and you have to think about the information included. The size
    of Secret content is also limited to 1 MB, which will usually be more than enough
    for delivering sensitive configurations. If you need more, you may need to use
    appropriate Volumes or PVs.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的 Kubernetes 管理员配置了与您应用程序的命名空间相关联的 **ResourceQuota** 资源，请向他们询问，因为像许多其他资源一样，Secret
    也可能会受到数量限制。因此，在创建大量 Secret 时，您可能会受到限制，并且需要考虑包含的信息。Secret 内容的大小也限制为 1 MB，这通常足够用于传递敏感配置。如果需要更多空间，您可能需要使用适当的
    Volumes 或 PVs。
- en: 'Let’s look at a quick example. We used `kubectl create secret settings --from-literal=user=test
    --from-literal=pass=testpass --from-file=mysecretfile --dry-run=client -o yaml`
    to generate the following Secret manifest:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个快速示例。我们使用 `kubectl create secret settings --from-literal=user=test --from-literal=pass=testpass
    --from-file=mysecretfile --dry-run=client -o yaml` 来生成以下 Secret 清单：
- en: '![Figure 10.3 – Secret manifest](img/B19845_10_03.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3 – Secret 清单](img/B19845_10_03.jpg)'
- en: Figure 10.3 – Secret manifest
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – Secret 清单
- en: 'We will now use the Secret values in a Pod as environment variables and mounted
    as a volume:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用 Pod 中的 Secret 值作为环境变量，并作为卷进行挂载：
- en: '![Figure 10.4 – Example of the usage of a Secret resource](img/B19845_10_04.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4 – Secret 资源使用示例](img/B19845_10_04.jpg)'
- en: Figure 10.4 – Example of the usage of a Secret resource
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – Secret 资源使用示例
- en: 'In the previous screenshot, we used `user` and `pass` two times. First, we
    added their values as environment variables, but we also used them as volumes,
    mounted inside `/etc/settings`. In this example, three files were created: `/etc/settings/user`,
    `/etc/settings/pass`, and `/etc/settings/mysecretfile`. Each file’s content was
    defined in the Secret. Notice that we defined the file permissions using the `defaultMode`
    key, and we mounted the volumes in read-only mode. If we just need to mount a
    Secret as a file and we require this file in a specific path, we use the `subPath`
    key to define the name of the file. For example, if we used `kubectl create secret
    generic example --from-file=mysecretfile`, we could mount it as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们使用了 `user` 和 `pass` 两次。首先，我们将它们的值作为环境变量添加，但我们也将它们作为卷挂载到 `/etc/settings`
    中。在此示例中，创建了三个文件：`/etc/settings/user`、`/etc/settings/pass` 和 `/etc/settings/mysecretfile`。每个文件的内容在
    Secret 中进行了定义。请注意，我们使用 `defaultMode` 键定义了文件权限，并且我们将卷挂载为只读模式。如果我们仅需将 Secret 挂载为文件，并且需要此文件位于特定路径下，我们使用
    `subPath` 键定义文件的名称。例如，如果我们使用 `kubectl create secret generic example --from-file=mysecretfile`，我们可以按如下方式挂载它：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will never store Secret file manifests in clear text in our code repository.
    You can use any third-party tool to encrypt its content before uploading it. On
    the other hand, a better solution may be a solution such as `SealedSecret`, which
    generates your Secret for you. In the `SealedSecret` manifests, the data is encrypted
    and you can manage it in your repositories without any problems. The `SealedSecret`
    entity works inside the Kubernetes cluster, hence your `SealedSecret` instance
    is the only software that can decrypt your data (encrypted by using certificate
    exchange). Your data will be safely encrypted, and it will be automatically decrypted
    when needed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们永远不会将 Secret 文件清单以明文形式存储在代码库中。在上传之前，你可以使用任何第三方工具加密其内容。另一方面，更好的解决方案可能是像 `SealedSecret`
    这样的工具，它会为你生成 Secret。在 `SealedSecret` 清单中，数据是加密的，你可以在代码库中管理它而不会遇到任何问题。`SealedSecret`
    实体在 Kubernetes 集群内工作，因此只有你的 `SealedSecret` 实例能够解密你的数据（通过证书交换加密）。你的数据将安全加密，并且在需要时会自动解密。
- en: You can use more complex solutions such as **Hashicorp’s Vault** to manage your
    Kubernetes Secret resources. This solution provides a lot of functionalities that
    can help you manage sensitive data for multiple platforms, not only Kubernetes,
    but it may require lots of hardware resources and management if you plan to have
    a highly available environment.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用更复杂的解决方案，如 **Hashicorp 的 Vault** 来管理 Kubernetes Secret 资源。这个解决方案提供了许多功能，可以帮助你管理多个平台的敏感数据，不仅仅是
    Kubernetes，但如果你计划在高可用环境中使用它，可能需要大量的硬件资源和管理。
- en: Cloud providers have their own software tools for deploying sensitive data on
    your Kubernetes cluster. They provide different access control integrations with
    your cloud **Identity and Access Management** (**IAM**) and may be a better solution
    if you plan to use a cloud platform for production. It is always interesting to
    ask your Kubernetes administrators for the best solution for deploying your Secrets
    in your environment.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 云服务提供商有自己的软件工具，用于在 Kubernetes 集群上部署敏感数据。它们提供与云 **身份与访问管理** (**IAM**) 的不同访问控制集成，如果你计划使用云平台进行生产环境部署，这可能是更好的解决方案。在部署
    Secrets 到你的环境中时，向 Kubernetes 管理员询问最佳解决方案总是很有帮助的。
- en: '**Projected Volumes** allow us to mount multiple resources (only Secrets, ConfigMaps,
    the downward API, or ServiceAccount tokens are allowed) into a container’s directory.
    The following example shows how to mount a Secret, a container’s specifications,
    and a ConfigMap resource:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**投影卷**允许我们将多个资源（仅 Secrets、ConfigMaps、向下 API 或 ServiceAccount 令牌允许）挂载到容器的目录中。以下示例展示了如何挂载一个
    Secret、一个容器规格和一个 ConfigMap 资源：'
- en: '![Figure 10.5 – Example of a Projected Volume](img/B19845_10_05.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5 – 投影卷示例](img/B19845_10_05.jpg)'
- en: Figure 10.5 – Example of a Projected Volume
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – 投影卷示例
- en: Now that we know how to inject configurations and sensitive data cluster-wide
    using Kubernetes resources, we will continue by reviewing how to store data from
    our applications. We will start with volumes, which are a storage solution included
    in Kubernetes’ core.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何使用 Kubernetes 资源集群范围内注入配置和敏感数据，我们将继续审查如何存储来自应用程序的数据。我们将从卷开始，卷是 Kubernetes
    核心中包含的存储解决方案。
- en: Managing stateless and stateful data
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理无状态和有状态数据
- en: When we think about storing an application’s data, we must consider whether
    the data should persist or whether it’s temporary. If the data must persist when
    a Pod is recreated, we must take into account that data should be available cluster-wide
    because containers may run on any worker host. Containers’ state isn’t stored
    by Kubernetes. If your application manages its state by using files, you may use
    volumes, but if this is not possible – for example, because multiple instances
    work at the same time – we should implement a mechanism such as a database to
    store its status and make it available to all instances.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑存储应用程序的数据时，我们必须考虑数据是否应该持久化，还是临时的。如果数据在 Pod 重新创建时必须持久化，我们必须考虑到数据应该在整个集群范围内可用，因为容器可能在任何工作节点上运行。Kubernetes
    不存储容器的状态。如果您的应用程序通过使用文件管理其状态，您可以使用卷，但如果不可能这样做——例如，因为多个实例同时工作——我们应该实现一种机制，例如数据库来存储其状态，并使其对所有实例可用。
- en: 'Storage can be either filesystem-based, block-based, or object-based. This
    also applies to Kubernetes data volumes, hence before moving forward on how Kubernetes
    provides different solutions for volumes, let’s have a quick review of these storage-type
    concepts:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 存储可以是基于文件系统、基于块或基于对象。这也适用于 Kubernetes 数据卷，因此在深入了解 Kubernetes 为卷提供不同解决方案之前，让我们快速回顾一下这些存储类型概念：
- en: '**Filesystem-based storage**: When we use filesystem-based storage (or file
    storage), we manage it by saving all the data in a hierarchal structure of folders
    and subfolders, provided by a local or remote operating system, where the files
    are kept. We use access control lists to decide whether a user is able to read
    or modify files’ content.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于文件系统的存储**：当我们使用基于文件系统的存储（或文件存储）时，我们通过将所有数据保存在本地或远程操作系统提供的文件和子文件夹的分层结构中来管理它。我们使用访问控制列表来决定用户是否能够读取或修改文件的内容。'
- en: Filesystems are quite common and easy to use. We use them every day locally
    in our workstation or remotely via NAS, **Common Internet File System** (**CIFS**),
    or even with cloud-specific solutions. Filesystem storage works fine for a limited
    number of files, with limited size, but it may be problematic with large files.
    In these solutions, files are indexed and this limits usage when we have an enormous
    number of files. It also doesn’t scale well, and it’s difficult to manage file
    locks when multiple processes are accessing the same file remotely, although it
    works very well for local storage.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文件系统非常常见且易于使用。我们每天都在工作站上本地使用它们，或通过 NAS、**通用 Internet 文件系统**（**CIFS**）甚至云特定的解决方案远程使用它们。对于有限数量和有限大小的文件，文件系统存储效果很好，但对于大文件可能存在问题。在这些解决方案中，文件被索引化，这限制了当我们有大量文件时的使用。它也不易扩展，并且在多个进程远程访问同一文件时难以管理文件锁，尽管它对本地存储非常有效。
- en: '**Block storage**: Block storage (or block devices) is used by splitting your
    data into small blocks of a defined size that can be distributed in different
    physical local devices. Block devices can be used locally or remotely (SAN or
    even cloud-provided solutions), and they may be used directly or formatted using
    different filesystem options, depending on the underlying operating system. This
    storage solution is faster than filesystems and can include HA and resilience
    using distributed devices. But redundancy isn’t cheap as it is based on the duplication
    of blocks. Applications must be prepared for working with block devices, and block
    storage isn’t commonly used because it depends a lot on the infrastructure. It
    is very efficient for virtualization and database solutions prepared for it.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**块存储**：块存储（或块设备）通过将数据分割成指定大小的小块，这些小块可以分布在不同的物理本地设备上来使用。块设备可以在本地或远程（SAN 或甚至云提供的解决方案）使用，并且可以直接使用或使用不同的文件系统选项格式化，这取决于底层操作系统。此存储解决方案比文件系统更快，并且可以通过使用分布式设备实现高可用性和韧性。但冗余性不便宜，因为它基于块的复制。应用程序必须准备好使用块设备，并且块存储不常用，因为它在很大程度上依赖于基础架构。它非常适合虚拟化和为其准备的数据库解决方案。'
- en: '**Object storage**: Object storage is a solution that divides the data into
    separate units that are stored in an underlying storage backend (block devices
    or filesystems). We can use distributed backends, which improves resilience and
    HA. Files are identified uniquely using IDs, and access to the data is easier
    to manage by using ACLs. It also provides redundancy and versioning. It was first
    developed for publishing storage on cloud providers but it is now very common
    in data centers. It’s usually consumed via a REST API (HTTP/HTTPS), which makes
    it easy to include in our applications. Many backup solutions are prepared for
    object storage backends nowadays because they are suitable for storing large files
    and an enormous number of items.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象存储**：对象存储是一种解决方案，它将数据划分为单独的单元，这些单元存储在底层存储后端（块设备或文件系统）中。我们可以使用分布式后端，从而提高容错性和高可用性。文件通过
    ID 唯一标识，使用 ACL 管理数据访问变得更加容易。它还提供冗余和版本控制。最初它是为云提供商的发布存储开发的，但现在在数据中心中也非常普遍。它通常通过
    REST API（HTTP/HTTPS）进行访问，这使得它可以轻松地集成到我们的应用程序中。如今，许多备份解决方案已经为对象存储后端做好了准备，因为它们适合存储大文件和大量数据项。'
- en: Kubernetes includes some drivers that will allow us to use the reviewed storage
    solutions mounted as volumes, but we will use PVC resources for more advanced
    results.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 包括一些驱动程序，允许我们将经过审核的存储解决方案挂载为卷，但我们将使用 PVC 资源以获得更先进的效果。
- en: Using volumes for storing data
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用卷来存储数据
- en: Volumes in Kubernetes are used by adding their definitions to the `.spec.volumes`
    key. Kubernetes supports different types of volumes, and Pod resources can use
    any number of volume types at the same time. We have temporal (or ephemeral) volumes
    that will only exist during the Pod’s execution, while data may persist using
    non-ephemeral volumes. All the volumes associated with a Pod can be mounted on
    any mount point (directories from containers’ filesystems) on all the containers
    running inside. Using these volumes, we can persist an application’s data.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，卷通过将其定义添加到 `.spec.volumes` 键来使用。Kubernetes 支持不同类型的卷，Pod 资源可以同时使用任意数量的卷类型。我们有临时（或短暂的）卷，这些卷只会在
    Pod 执行期间存在，而数据可以通过非短暂卷来持久化。与 Pod 关联的所有卷可以挂载到所有容器内运行的任何挂载点（来自容器文件系统的目录）。使用这些卷，我们可以持久化应用程序的数据。
- en: While the `.spec.volumes` key allows us to define the volumes to be included
    in the Pod’s mount namespace, we will use `.spec.containers[*].volumeMounts` to
    define in each container how and where the volumes should be used.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `.spec.volumes` 键允许我们定义要包含在 Pod 挂载命名空间中的卷，但我们将使用 `.spec.containers[*].volumeMounts`
    来定义每个容器如何以及在哪里使用这些卷。
- en: 'Let’s review some of the most popular volume types:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下几种最流行的卷类型：
- en: '`emptyDir`: An `emptyDir` definition asks the kubelet component to create an
    empty temporary directory on your host that will follow the associated container’s
    life cycle. When the Pod is deleted, the containers free up this storage, and
    kubelet removes it. By default, `emptyDir` type volumes are created on a host’s
    filesystem but can use the `medium` subkey to define where the storage should
    be created. Size can also be limited by using the `sizeLimit` key. It is important
    to understand that these volumes are created on the hosts, hence you must be careful
    about their content and size. Never use them for storing unlimited logs, for example.
    And remember that they will be removed once the Pod is deleted/recreated.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emptyDir`：`emptyDir` 定义要求 kubelet 组件在主机上创建一个空的临时目录，该目录将跟随关联容器的生命周期。当 Pod 被删除时，容器释放该存储，kubelet
    将其删除。默认情况下，`emptyDir` 类型的卷会在主机的文件系统上创建，但可以使用 `medium` 子键定义存储应创建的位置。通过使用 `sizeLimit`
    键，也可以限制其大小。需要注意的是，这些卷是在主机上创建的，因此必须小心其内容和大小。例如，永远不要使用它们来存储无限量的日志。并且要记住，一旦 Pod 被删除或重新创建，它们将被移除。'
- en: '`hostPath`: These volumes allow us to include a defined host’s storage inside
    the Pods. This is an important security breach that must be avoided unless your
    application needs to monitor or modify your host’s files. Different types of `hostPath`
    volumes can be used by setting the `type` key. By default, a directory will be
    created if doesn’t exist when the Pod starts, but we can create or use specific
    files, sockets, block devices, or even special types such as `hostPath` volumes
    should be limited, and you must inform your Kubernetes administrators about their
    use in your workloads.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hostPath`：这些卷允许我们将定义的主机存储包含在Pod中。这是一个重要的安全隐患，除非你的应用需要监控或修改主机的文件，否则必须避免使用。通过设置`type`键，可以使用不同类型的`hostPath`卷。默认情况下，如果Pod启动时目录不存在，它将被创建，但我们也可以创建或使用特定的文件、套接字、块设备，甚至特殊类型的文件。由于`hostPath`卷应受到限制，因此你必须将其使用情况告知Kubernetes管理员。'
- en: '`iscsi`: If you are already using `hostPath`). It is not very common to use
    `iscsi` volumes nowadays because it requires all the worker nodes to be completely
    equal (disk devices’ names must be completely equal in all cluster hosts). You
    can use node labels to specify where the workloads should run, but this makes
    them too fixed to the underlying infrastructure.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iscsi`：如果你已经在使用`hostPath`。目前，使用`iscsi`卷并不常见，因为它要求所有工作节点完全相同（所有集群主机中的磁盘设备名称必须完全相同）。你可以使用节点标签指定工作负载的运行位置，但这使得它们对底层基础设施过于固定。'
- en: '`nfs`: NFS volume types allow us to include a remote NFS filesystem in a Pod.
    The content of the mounted filesystem is maintained unless you remove it from
    your Pod’s processes. We specify the server and the exposed path, and we can mount
    it in read-only mode by setting the `readOnly` key to `true`. The following screenshot
    shows a quick example displaying the required keys:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nfs`：NFS卷类型允许我们在Pod中包含远程NFS文件系统。除非你从Pod的进程中移除它，否则挂载的文件系统内容会被保持。我们指定服务器和暴露的路径，并可以通过将`readOnly`键设置为`true`来以只读模式挂载它。下图展示了一个快速示例，显示了所需的键：'
- en: '![Figure 10.6 – Manifest showing an NFS volume mounted in a Pod](img/B19845_10_06.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – 展示在Pod中挂载NFS卷的清单](img/B19845_10_06.jpg)'
- en: Figure 10.6 – Manifest showing an NFS volume mounted in a Pod
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – 展示在Pod中挂载NFS卷的清单
- en: '`PersistentVolumeClaim`: This is the most advanced volume definition and requires
    a full section to describe its usage. We will learn how to use them in the next
    subsection.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PersistentVolumeClaim`：这是最先进的卷定义，需要一个完整的章节来描述其使用方式。我们将在下一小节学习如何使用它们。'
- en: '`ephemeral`: These volumes may be considered similar to `emptyDir` because
    they are designed to provide ephemeral storage while a Pod is running, but they
    differ in that we can integrate PVC resources as ephemeral volumes or local storage.
    The volumes can be empty or they can already have some content when they are attached
    to the Pod.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ephemeral`：这些卷可以被认为类似于`emptyDir`，因为它们旨在提供在Pod运行期间的临时存储，但它们的不同之处在于我们可以将PVC资源作为临时卷或本地存储进行集成。当卷挂载到Pod时，它们可以是空的，也可以已经包含一些内容。'
- en: A lot of cloud providers’ volumes have moved from Kubernetes core-based storage
    to modern PVC management using external PV dynamic provisioners. Disassembling
    the storage provisioning from the Kubernetes code allows hardware storage manufacturers,
    cloud providers, and middleware software creators to prepare their own solutions
    and evolve them out of the Kubernetes development cycle. We will now learn how
    PV and PVC resources allow us to improve storage management on Kubernetes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 很多云提供商的卷已经从基于Kubernetes核心的存储转向使用外部PV动态供应器的现代PVC管理。将存储供应从Kubernetes代码中拆分出来，使硬件存储制造商、云提供商和中间件软件开发者能够准备自己的解决方案，并将其发展到Kubernetes开发周期之外。我们现在将学习PV和PVC资源如何帮助我们改善Kubernetes中的存储管理。
- en: Enhancing storage management in Kubernetes with PV resources
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Kubernetes中通过PV资源增强存储管理
- en: A PV resource presents a unit of storage that can be used within Kubernetes.
    PVs can be created manually or dynamically by a storage provisioning backend.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: PV资源表示可以在Kubernetes中使用的存储单元。PV可以通过存储提供后端手动或动态创建。
- en: 'While the volume definitions seen so far are declared namespace-wide, PV resources
    are defined cluster-wide, by Kubernetes administrators. We use them to define
    the storage capacity (size) using the `capacity.storage` key and the mode it will
    be consumed using the `accessMode` key. Let’s quickly review these modes, because
    our applications may need specific access to the data, especially when we run
    multiple replicas of a process:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止看到的卷定义是命名空间级别的，而PV资源是由Kubernetes管理员在集群级别定义的。我们使用它们来定义存储容量（大小），使用`capacity.storage`键，并定义它的访问模式，使用`accessMode`键。让我们快速回顾这些模式，因为我们的应用可能需要特定的数据访问，特别是当我们运行多个副本进程时：
- en: '`ReadWriteOnce`: This mode presents the storage in write mode only for the
    first Pod that attaches it. Other Pods (replicas or even defined in other different
    workloads) can only have read access to the data.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadWriteOnce`：此模式仅为第一个附加该存储的Pod提供写模式。其他Pod（无论是副本还是定义在其他不同工作负载中的Pod）只能对数据进行读取访问。'
- en: '`ReadOnlyMany`: In this mode, all the Pods will mount the volume in read-only
    mode.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadOnlyMany`：在此模式下，所有Pod将以只读模式挂载卷。'
- en: '`ReadWriteMany`: This is the option to use when processes running in different
    Pods need to write on a PV at the same time. You must ensure your application
    manages the locks for writing your data without corrupting it.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadWriteMany`：当在不同Pod中运行的进程需要同时写入PV时，使用此选项。您必须确保应用程序管理写数据时的锁，以避免数据损坏。'
- en: You have to be aware that `accessMode` does not enforce write protection once
    the volume is mounted. If you need to ensure that it is mounted in read-only mode
    in some Pods, you must use the `readOnly` key.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要注意的是，`accessMode`并不会在卷挂载后强制执行写保护。如果您需要确保某些Pod挂载时是只读模式，必须使用`readOnly`键。
- en: Multiple access modes can be defined in a PV resource but it only uses one when
    it is mounted. This helps the cluster to bind PVs, but it will fit the specifications
    in each volume request.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在PV资源中可以定义多个访问模式，但在挂载时仅使用其中一种。这有助于集群绑定PV，但它将根据每个卷请求的规格来适配。
- en: Important note
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The mode also affects how applications will be updated by issuing a rolling
    update. By default, Deployment resources will start a new Pod instance before
    the old one is stopped to maintain the application working. But the `ReadWriteOnce`
    access mode will only allow the old Pod to access the storage while the new one
    will wait forever to attach it. In such situations, it may be interesting to change
    the default rolling update behavior to ensure that the old processes stop completely
    and free the volume before the new ones start with the storage attached.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式还会影响应用程序的更新方式，特别是在发起滚动更新时。默认情况下，Deployment资源会在旧Pod停止之前先启动新Pod实例，以保持应用程序的运行。但是，`ReadWriteOnce`访问模式只允许旧Pod访问存储，而新Pod则会永远等待挂载。在这种情况下，可能需要改变默认的滚动更新行为，以确保旧进程完全停止并释放卷，之后新进程再开始使用附加的存储。
- en: To use an available PV, we will use a PVC resource that may be considered a
    request for storage. These resources are defined namespace-wide because they will
    be used by our workloads. You, as a developer, will ask for storage for your application,
    defining a PVC with the required `capacity.storage` and `accessMode` keys. When
    both options match an already created and free PV resource, they are bound and
    the storage is attached to the Pod. In fact, the volumes are attached to the host
    that runs the Pod, and kubelet makes it available inside the Pod.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用可用的PV，我们将使用PVC资源，可以将其视为对存储的请求。这些资源是命名空间级别定义的，因为它们将被我们的工作负载使用。作为开发人员，您将为应用程序请求存储，定义一个带有所需`capacity.storage`和`accessMode`键的PVC。当这两个选项与已创建并空闲的PV资源匹配时，它们会绑定，并且存储将附加到Pod上。实际上，卷会附加到运行Pod的主机上，kubelet会使其在Pod内可用。
- en: 'Labels can be used to fix PVCs with a subset of PVs by using `selector.matchLabels`
    and an appropriate label. The following screenshot shows an example of `PersistentVolume`
    created as a local `hostPath` variable:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用标签通过`selector.matchLabels`和适当的标签来固定PVC和PV的子集。以下截图展示了一个作为本地`hostPath`变量创建的`PersistentVolume`示例：
- en: '![Figure 10.7 – PV and PVC manifests](img/B19845_10_07.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7 – PV 和 PVC 清单](img/B19845_10_07.jpg)'
- en: Figure 10.7 – PV and PVC manifests
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – PV 和 PVC 清单
- en: If the PVC is created, but there isn’t a PV available matching the PVC’s defined
    requirements, it will stay unbound forever, waiting for a PV to be created or
    free in the Kubernetes cluster.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果创建了PVC，但没有可用的PV满足PVC的定义要求，它将永远保持未绑定状态，等待创建或释放一个PV在Kubernetes集群中。
- en: 'When a Pod is using a PVC and it is bound to a PV, the storage can’t be removed
    until the Pod frees it when the Pod is removed. The following screenshot shows
    how a Pod uses a PVC:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 Pod 使用 PVC 并且绑定到 PV 时，在 Pod 释放它并删除 Pod 之前，存储不能被移除。以下截图展示了一个 Pod 如何使用 PVC：
- en: '![Figure 10.8 – Pod manifest using a PVC associated with a PV](img/B19845_10_08.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.8 – 使用与 PV 关联的 PVC 的 Pod 清单](img/B19845_10_08.jpg)'
- en: Figure 10.8 – Pod manifest using a PVC associated with a PV
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 – 使用与 PV 关联的 PVC 的 Pod 清单
- en: PVs can be resized if the underlying filesystem is either `xfs`, `ext3`, or
    `ext4`. Depending on the storage backend, we can clone the PV content or even
    create snapshots, which may be very interesting for debugging purposes when a
    problem is occurring in your application with a set of data or for backups.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果底层文件系统是 `xfs`、`ext3` 或 `ext4`，则可以调整 PV 的大小。根据存储后端，我们可以克隆 PV 内容，甚至创建快照，这对于调试应用程序出现问题时的数据集，或进行备份可能非常有用。
- en: Node affinity can be used to use specific cluster nodes with specific directories
    or even disk devices and mount the PVs wherever the directory is present. You,
    as a developer, should avoid node affinity unless your Kubernetes administrators
    ask you to use this feature as it makes your workloads infrastructure-dependent.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 节点亲和性可以用于将特定的集群节点与特定目录或甚至磁盘设备一起使用，并将 PV 挂载到该目录所在的节点。作为开发人员，除非您的 Kubernetes 管理员要求您使用此功能，否则应避免使用节点亲和性，因为它会使您的工作负载依赖于基础设施。
- en: PVs can be provisioned either manually by your Kubernetes administrator or dynamically,
    using a container storage interface integrated solution that will interact with
    a storage backend to create the volumes for you. Multiple storage solutions can
    coexist in your cluster, which may provide different storage capabilities. No
    matter whether your platform uses dynamic provisioning or manually created volumes,
    we may access faster backends, more resilient ones, or some with specific housekeeping.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: PV 可以由您的 Kubernetes 管理员手动配置，也可以通过动态方式配置，使用与存储后端交互的容器存储接口集成解决方案来为您创建卷。多个存储解决方案可以在您的集群中共存，这些解决方案可能提供不同的存储能力。无论您的平台使用动态配置还是手动创建卷，我们都可能访问更快的后端、更具韧性的后端，或者具有特定管理功能的后端。
- en: Important note
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It is important to understand that matching a PVC to an appropriate PV can lead
    to bad use of disk space. When a PVC asks for 5 Gi and a PV with a size of 10
    Gi is available, they will be bound despite their size not matching. This means
    we’ll use only 50% of the available space. That’s why dynamic provisioning is
    so important, because it creates PVs with the exact size required and then they
    are bound, hence the data fits perfectly in the provisioned storage.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，将 PVC 与合适的 PV 匹配可能会导致磁盘空间的浪费。当 PVC 请求 5 Gi 而可用的 PV 大小为 10 Gi 时，它们会被绑定，尽管它们的大小不匹配。这意味着我们只会使用可用空间的
    50%。这就是动态配置如此重要的原因，因为它创建与所需大小完全匹配的 PV，然后它们会被绑定，从而数据完美地适配到配置的存储中。
- en: We will use StorageClass resources to classify the PVs by their capabilities.
    Kubernetes administrators will associate created PV resources to any of the configured
    StorageClass resources. A default StorageClass may be defined to associate all
    PVs without a `spec.storageClassName` key. Whenever we create a PVC resource,
    we can either define a specific StorageClass or wait for the cluster to assign
    a PV from the default StorageClass to our claim.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 StorageClass 资源按能力对 PV 进行分类。Kubernetes 管理员将把创建的 PV 资源与任何已配置的 StorageClass
    资源关联。可以定义默认的 StorageClass 来关联所有没有 `spec.storageClassName` 键的 PV。每当我们创建 PVC 资源时，我们可以定义一个特定的
    StorageClass，或者等待集群从默认的 StorageClass 为我们的声明分配一个 PV。
- en: Now that we know about the basic concepts of storage management, we can take
    a quick look at the provisioning and decommissioning of storage.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了存储管理的基本概念，我们可以快速查看存储的配置和退役过程。
- en: Provisioning and decommissioning storage
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储的配置和退役
- en: Kubernetes does not manage how PVs are created or destroyed in storage backends.
    It just interacts with their interfaces via a REST API to retrieve and follow
    the changes and states of the storage.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 不管理如何在存储后端创建或销毁 PV。它只是通过 REST API 与它们的接口交互，以检索和跟踪存储的变化和状态。
- en: '**Dynamic provisioning** requires some Kubernetes administration work. Kubernetes
    administrators will deploy **Container Storage Interface** (**CSI**) solutions
    and attach them to specific StorageClass resources, making them available for
    users. Each StorageClass resource includes its own parameters for invoking the
    provisioner, hence different PV resources will be created, depending on the mechanism
    used to create them.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**动态配置** 需要一些 Kubernetes 管理工作。Kubernetes 管理员将部署 **容器存储接口**（**CSI**）解决方案，并将它们附加到特定的
    StorageClass 资源，使用户能够使用它们。每个 StorageClass 资源都有自己调用提供者的参数，因此将根据使用的机制创建不同的 PV 资源。'
- en: 'The following screenshot shows two StorageClass resources using a `kubernetes.io/gce-pd`
    API endpoint) for creating standard and SSD (fast hard drives) PVs:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了两个 StorageClass 资源，使用 `kubernetes.io/gce-pd` API 端点来创建标准和 SSD（快速硬盘）PV：
- en: '![Figure 10.9 – StorageClass manifests for standard and SSD storage](img/B19845_10_09.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.9 – 标准存储和 SSD 存储的 StorageClass 清单](img/B19845_10_09.jpg)'
- en: Figure 10.9 – StorageClass manifests for standard and SSD storage
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – 标准存储和 SSD 存储的 StorageClass 清单
- en: 'Notice the `reclaimPolicy` key, which manages the behavior of the provisioner
    when a Pod frees a PV and this is reused:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `reclaimPolicy` 键，它管理当 Pod 释放一个 PV 并且该 PV 被重新使用时，提供者的行为：
- en: A `Retain` policy will not modify the content of the PV, therefore we need to
    remove it from the provisioner backend manually when the data isn’t needed anymore.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Retain` 策略不会修改 PV 中的内容，因此当数据不再需要时，我们需要手动从提供者后台移除该 PV。'
- en: A `Recycle` policy will basically delete all the content of the volume (such
    as issuing `rm -rf /volumedata/*` from a Pod mounting the PV). This is only supported
    in NFS and `hostPath` provisioners.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Recycle` 策略基本上会删除卷中的所有内容（例如，通过从挂载 PV 的 Pod 发出 `rm -rf /volumedata/*` 命令）。这仅在
    NFS 和 `hostPath` 提供者中受支持。'
- en: A `Delete` policy will completely delete the PV and its content by asking the
    provisioner API to delete the associated volume.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Delete` 策略将完全删除 PV 及其内容，通过请求提供者 API 删除关联的卷。'
- en: Important note
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Using PV and PVC resources allows us to prepare our application’s workloads
    to work on any Kubernetes infrastructure. We will just modify `StorageClassName`
    to fit any of the StorageClasses present in the deployment platform.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PV 和 PVC 资源可以让我们准备好应用程序的工作负载，使其能够在任何 Kubernetes 基础设施上运行。我们只需修改 `StorageClassName`
    来适应部署平台上现有的任何 StorageClass。
- en: We will now review some labs that will help us better understand some of the
    content of this chapter.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将回顾一些实验，以帮助我们更好地理解本章的某些内容。
- en: Labs
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验
- en: In this section, we will use some of the resources presented to improve our
    `simplestlab` application. We will include sensitive data in a Secret resource,
    NGINX configurations in a ConfigMap resource, and a simple StorageClass resource
    to implement a PV resource and a PVC resource to present storage for our StatefulSet
    resource.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用一些已呈现的资源来改进我们的 `simplestlab` 应用程序。我们将在 Secret 资源中包含敏感数据，在 ConfigMap
    资源中包含 NGINX 配置，并通过 StorageClass 资源实现一个 PV 资源和一个 PVC 资源，为我们的 StatefulSet 资源提供存储。
- en: The code for all the labs is available in this book’s GitHub repository at [https://github.com/PacktPublishing/Containers-for-Developers-Handbook.git](https://github.com/PacktPublishing/Containers-for-Developers-Handbook.git).
    Ensure you have the latest revision available by simply executing `git clone https://github.com/PacktPublishing/Containers-for-Developers-Handbook.git`
    to download all its content or `git pull` if you have already downloaded the repository.
    All the manifests and the steps required for adding storage to the `simplestlab`
    application are located inside the `Containers-for-Developers-Handbook/Chapter10`
    directory.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的所有实验代码可以在其 GitHub 仓库中找到，链接为 [https://github.com/PacktPublishing/Containers-for-Developers-Handbook.git](https://github.com/PacktPublishing/Containers-for-Developers-Handbook.git)。通过执行
    `git clone https://github.com/PacktPublishing/Containers-for-Developers-Handbook.git`
    下载所有内容，或者如果你已经下载了仓库，则执行 `git pull` 来确保你有最新的版本。所有清单文件和为 `simplestlab` 应用程序添加存储的步骤都位于
    `Containers-for-Developers-Handbook/Chapter10` 目录下。
- en: This section will show you how to implement different volume solutions on the
    `simplestlab` tier-three application, prepared for Kubernetes in [*Chapter 9*](B19845_09.xhtml#_idTextAnchor202),
    *Implementing* *Architecture Patterns*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将向你展示如何在为 Kubernetes 准备的 `simplestlab` 第三层应用程序中实现不同的卷解决方案，详见 [*第9章*](B19845_09.xhtml#_idTextAnchor202)，*实现*
    *架构模式*。
- en: 'These are the tasks you will find in the [*Chapter 10*](B19845_10.xhtml#_idTextAnchor231)
    GitHub repository:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: We will improve the security of the `simplestlab` application by adding Secret
    resources on any sensitive data required by the application. We will review each
    application component, create the required Secret resources, and modify the component’s
    manifests to include the newly created resources. This includes some database
    initialization scripts required for the database component.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also prepare different ConfigMap resources for the `lb` application’s
    component and verify how these changes impact the application behavior.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can use one of the following Kubernetes desktop environments:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Docker Desktop
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rancher Desktop
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minikube
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The labs will work on any of them, and of course, on any other Kubernetes environment.
    You may find issues with their default storage class, but there are some comments
    on the files that may be changed. We’ll start with improving the `simplestlab`
    application on Kubernetes:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: The `simplestlab` application is a very simple tier-3 application (a load balancer
    could present additional static content but it is not added for the purposes of
    the labs). To make it more secure, we’re going to add Secret resources for defining
    all the required user authentications.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The application is composed of three components:'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A `db` component: Postgres database'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An `app` component: Application backend in Node.js'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An `lb` component: NGINX fronted for static content'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We have included in their manifests some of the storage solutions learned in
    this chapter.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s look at the database component first. As we are already using a StatefulSet
    resource, a PVC resource is configured, but the `postgres` user password was presented
    in the database container in clear text. We added a Secret resource to include
    this password, and we also included a complete database initialization script
    that will allow us to prepare the database. In the previous labs, this component
    was initialized with the script included in the container image. In this case,
    we can manage how the database for the application will be created by modifying
    this script and replacing the Secret. You must know that we can’t use this mechanism
    to modify a previously initialized database. That’s why we expect to deploy this
    component from scratch.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These are two Secret manifests created:'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`dbcredentials.secret.yaml`, the content of which is shown here:'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`initdb.secret.yaml`: This Secret is created by including the content of `init-demo.sh`
    script:'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: $ kubectl create secret generic initdb \
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: --from-file=init-demo.sh --dry-run=client \
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: -o yaml |tee initdb.secret.yaml
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'apiVersion: v1'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'data:'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'init-demo.sh: IyEvYmluL2Jhc2gKc2V0IC1lCgpwc3FsIC12IE9OX0VSUk9SX1NUT1A9MSAt....pZCkKICAgICk7CiAgICBBTFRFUiBUQUJMRSBoaXRzIE9XTkVSIFRPIGRlbW87CkVPU1FMCg=='
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'kind: Secret'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'metadata:'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'creationTimestamp: null'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'name: initdb'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In both cases, the values are encoded in Base64 format. They aren’t encrypted,
    as we can verify:'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'apiVersion: apps/v1'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: API 版本：apps/v1
- en: 'kind: StatefulSet'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型：StatefulSet
- en: 'metadata:'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 元数据：
- en: 'name: db'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 名称：db
- en: 'labels:'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 标签：
- en: 'component: db'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 组件：db
- en: 'app: simplestlab'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用程序：simplestlab
- en: 'spec:'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 规格：
- en: 'replicas: 1'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 副本：1
- en: '...'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...'
- en: 'volumes:'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 卷：
- en: '- name: initdb-secret'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- 名称：initdb-secret'
- en: 'secret:'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 密钥：
- en: 'secretName: initdb'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: secretName：initdb
- en: 'optional: true'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可选：true
- en: 'containers:'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 容器：
- en: '- name: database'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- 名称：database'
- en: 'image: docker.io/frjaraur/simplestdb:1.0'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 镜像：docker.io/frjaraur/simplestdb:1.0
- en: '...'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...'
- en: 'env:'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 环境：
- en: '- name: POSTGRES_PASSWORD'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- 名称：POSTGRES_PASSWORD'
- en: 'valueFrom:'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: valueFrom：
- en: 'secretKeyRef:'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: secretKeyRef：
- en: 'name: dbcredentials'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 名称：dbcredentials
- en: 'key: POSTGRES_PASSWORD'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 键：POSTGRES_PASSWORD
- en: '- name: PGDATA'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- 名称：PGDATA'
- en: 'value: /data/postgres'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 值：/data/postgres
- en: 'volumeMounts:'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: volumeMounts：
- en: '- name: postgresdata'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- 名称：postgresdata'
- en: 'mountPath: /data'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'mountPath: /data'
- en: '- name: initdb-secret'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- 名称：initdb-secret'
- en: 'mountPath: "/docker-entrypoint-initdb.d/"'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'mountPath: "/docker-entrypoint-initdb.d/"'
- en: 'readOnly: true'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 只读：true
- en: '...'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...'
- en: 'volumeClaimTemplates:'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: volumeClaimTemplates：
- en: '- metadata:'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- 元数据：'
- en: 'name: postgresdata'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 名称：postgresdata
- en: 'spec:'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 规格：
- en: 'accessModes: [ "ReadWriteOnce" ]'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 访问模式：[ "ReadWriteOnce" ]
- en: '#storageClassName: "csi-hostpath-sc"'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#storageClassName: "csi-hostpath-sc"'
- en: 'resources:'
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 资源：
- en: 'requests:'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请求：
- en: 'storage: 1Gi'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 存储：1Gi
- en: '[PRE8]'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We create all the components for the database:'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了数据库的所有组件：
- en: '[PRE9]'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The service wasn’t modified at all.
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 服务完全未修改。
- en: 'We check if the user was created by connecting to the database server and showing
    its users:'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过连接到数据库服务器并显示其用户来检查是否已创建用户：
- en: '[PRE10]'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can now review the PVC, created by using a template (because it is a StatefulSet)
    and the associated PV:'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们可以查看通过使用模板创建的 PVC（因为它是一个 StatefulSet）以及相关的 PV：
- en: '[PRE11]'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A StorageClass resource is defined in Docker Desktop and we use it by default:'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Docker Desktop 中定义了一个 StorageClass 资源，并且我们默认使用它：
- en: '[PRE12]'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: $ kubectl create secret generic appcredentials \
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ kubectl create secret generic appcredentials \
- en: --from-literal=dbhost=db \
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: --from-literal=dbhost=db \
- en: --from-literal=dbname=demo \
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: --from-literal=dbname=demo \
- en: --from-literal=dbuser=demo \
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: --from-literal=dbuser=demo \
- en: --from-literal=dbpasswd=d3m0
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: --from-literal=dbpasswd=d3m0
- en: secret/appcredentials created
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: secret/appcredentials 已创建
- en: '[PRE13]'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s review the changes included to load the database authentication in the
    application:'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们审查包含在应用程序中加载数据库身份验证的更改：
- en: '[PRE14]'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The full manifest file can be found in the `Chapter10/app.deployment.yaml` file.
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完整的清单文件可以在 `Chapter10/app.deployment.yaml` 文件中找到。
- en: 'We have just included all the required environment variables from the Secret
    created before. We deploy the app manifests:'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们刚刚从之前创建的 Secret 中包含了所有必需的环境变量。我们部署了应用程序清单：
- en: '[PRE15]'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We now verify the content included in the containers:'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们验证容器中包含的内容：
- en: '[PRE16]'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can now continue with the frontend component. In the previous versions of
    this application’s deployment, we were already using a ConfigMap resource for
    configuring the NGINX load balancer.
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们可以继续处理前端组件。在此应用程序部署的早期版本中，我们已经使用 ConfigMap 资源配置了 NGINX 负载均衡器。
- en: 'This is the content of the ConfigMap resource with these special configurations
    for our NGINX load balancer:'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是带有特殊配置的 ConfigMap 资源的内容，用于我们的 NGINX 负载均衡器：
- en: '[PRE17]'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We deploy all the `lb` manifests:'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们部署所有的 `lb` 清单：
- en: '[PRE18]'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We review the status of all the application’s components and the configuration
    applied to the NGINX component:'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们审查所有应用程序组件的状态和应用于 NGINX 组件的配置：
- en: '[PRE19]'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And now, we can reach our application in any Kubernetes cluster host’s port
    32000\. Your browser should access the application and show something like this
    (if you’re using Docker Desktop, you will need to use [http://localhost:32000](http://localhost:32000)):'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们可以在任何 Kubernetes 集群主机的端口 32000 上访问我们的应用程序。您的浏览器应该访问该应用程序并显示类似以下内容（如果您使用
    Docker Desktop，则需要使用 [http://localhost:32000](http://localhost:32000)）：
- en: '![Figure 10.10 – simplestlab application web GUI](img/B19845_10_10.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.10 – simplestlab 应用程序 Web GUI](img/B19845_10_10.jpg)'
- en: Figure 10.10 – simplestlab application web GUI
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 – simplestlab 应用程序 Web GUI
- en: With this final step, you deployed completely the three components of the `simplestlab`
    application. You will find additional steps in the `Chapter10` folder in the GitHub
    repository to add a new app component instance and modify the load balancer component
    to reach this new backend.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一最后步骤，您完全部署了 `simplestlab` 应用程序的三个组件。在 GitHub 存储库的 `Chapter10` 文件夹中，您将找到额外的步骤以添加新的应用程序组件实例并修改负载均衡器组件以连接到此新后端。
- en: These labs will help you understand how Secret resources improve the security
    of an application and how to implement different volume types for different application
    needs.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实验将帮助您了解 Secret 资源如何提高应用程序的安全性，以及如何为不同的应用程序需求实现不同的卷类型。
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed how we can manage data in a Kubernetes cluster,
    which is currently the most popular container orchestrator, and you will probably
    use it for most of your projects. We learned how to include configurations and
    sensitive data in our application’s containers, and how we can manage stateless
    and stateful storage using different Kubernetes resources. At the end of the chapter,
    we learned how we can use dynamic provisioning of data volumes for our applications,
    which really fits in the microservices model, where automation is crucial for
    abstracting resources from the underlying infrastructure. This chapter is very
    important because it has taught you how to manage data in microservices and container-based
    environments.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们回顾了如何在Kubernetes集群中管理数据，Kubernetes目前是最流行的容器编排工具，你可能会在大多数项目中使用它。我们学习了如何在应用程序的容器中包含配置和敏感数据，以及如何使用不同的Kubernetes资源来管理无状态和有状态存储。在本章的最后，我们学习了如何为我们的应用程序使用动态数据卷配置，这非常适合微服务模型，在微服务中，自动化对底层基础设施的资源抽象至关重要。本章非常重要，因为它教会了你如何在微服务和基于容器的环境中管理数据。
- en: We will follow this up in the next chapter, in which we will learn how to publish
    our applications using best security practices, isolating all backend components
    from users and other applications.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中继续讨论，在这一章中，我们将学习如何使用最佳安全实践发布我们的应用程序，隔离所有后台组件与用户和其他应用程序之间的关系。
